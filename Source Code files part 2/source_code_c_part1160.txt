  |= MARSHAL_INVOKE_fakeVarResult;
                    }
                    
                    if (NULL == m_remoteFrame.pExcepInfo)
                    {
                        m_remoteFrame.pExcepInfo = &m_excepInfo;
                        m_remoteFrame.dwFlags   |= MARSHAL_INVOKE_fakeExcepInfo;
                    }
                    
                    if (NULL == m_remoteFrame.puArgErr)
                    {
                        m_remoteFrame.puArgErr   = &m_uArgErr;
                        m_remoteFrame.dwFlags   |= MARSHAL_INVOKE_fakeArgErr;
                    }
                    //
                    // Finish filling out our remote frame
                    //
                    m_remoteFrame.dispIdMember  = pframe->dispIdMember;
                    m_remoteFrame.piid          = pframe->piid;
                    m_remoteFrame.lcid          = pframe->lcid;
                }
            }
        }
    }

    if (!hr)
    {
        m_fDoneProxyPrecheck = TRUE;
    }
        
    return hr;
}

////////////////////////////

HRESULT DISPATCH_SERVER_FRAME::StubPreCheck()
// As in InvokeStubPreCheck(), prepare newly-unmarshalled remote in-arguments for execution
// on the actual server object. Yucko-rama.
//
// This must be done before we get an actual in-memory frame
//
{
    HRESULT hr = S_OK;

    if (!m_fDoneStubPrecheck)
    {
        m_fDoneStubPrecheck = TRUE;
        Zero(&m_memoryFrame);

        FRAME_RemoteInvoke* premoteFrame = (FRAME_RemoteInvoke*)m_pvArgs;

        const UINT cArgs = premoteFrame->pDispParams->cArgs;

        if (cArgs == 0)
        {
            premoteFrame->pDispParams->cNamedArgs = 0;
        }
        else
        {
            if (premoteFrame->pDispParams->rgvarg == NULL || (premoteFrame->pDispParams->cNamedArgs != 0 && premoteFrame->pDispParams->rgdispidNamedArgs == NULL))
                return E_INVALIDARG;

            // Restore what should be in the pDispParams->rgvarg array
            //
            for (UINT i = 0; i < premoteFrame->cVarRef; i++)  
            {
                premoteFrame->pDispParams->rgvarg[premoteFrame->rgVarRefIdx[i]] = premoteFrame->rgVarRef[i];
            }
        }
        //
        // Initialize our local copy of the actual in-memory frame from the remote frame that we're given
        //
        m_memoryFrame.CopyFrom(*premoteFrame);
        //
        // NULL the parameters that were in-fact given as NULL way back on the client side
        //
        const DWORD dwFlags = premoteFrame->dwFlags;
        if ((dwFlags & MARSHAL_INVOKE_fakeVarResult) != 0)
        {
            m_memoryFrame.pVarResult = NULL;    // was NULL in the first place, so set it back
        }

        if ((dwFlags & MARSHAL_INVOKE_fakeExcepInfo) != 0)
        {
            m_memoryFrame.pExcepInfo = NULL;    // was NULL in the first place, so set it back
        }
        else
        {
            (m_memoryFrame.pExcepInfo)->pfnDeferredFillIn = NULL;
        }

        if ((dwFlags & MARSHAL_INVOKE_fakeArgErr) != 0)
        {
            m_memoryFrame.puArgErr = NULL;      // was NULL in the first place, so set it back
        }
    }

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::StubPostCheck()
// See also InvokeStubPostCheck().
//
// This must be done before we can marshal our out parameters
//
{
    HRESULT hr = S_OK;

    if (!m_fDoneStubPostcheck)
    {
        m_fDoneStubPostcheck = TRUE;
        //
        if (m_hrReturnValue == DISP_E_EXCEPTION) 
        {
            if (m_memoryFrame.pExcepInfo != NULL && m_memoryFrame.pExcepInfo->pfnDeferredFillIn != NULL) 
            {
                // since we are going to cross address space, fill in ExcepInfo now
                //
                (*m_memoryFrame.pExcepInfo->pfnDeferredFillIn)(m_memoryFrame.pExcepInfo);
                m_memoryFrame.pExcepInfo->pfnDeferredFillIn = NULL;
            }
        }
        //
        ASSERT(m_premoteFrame);
        PVOID pvArgsRemote = m_premoteFrame->GetStackLocation();

        FRAME_RemoteInvoke* premoteFrame = (FRAME_RemoteInvoke*)pvArgsRemote;
        for (UINT i=0; i<premoteFrame->cVarRef; i++)
        {
            V_VT(& premoteFrame->pDispParams->rgvarg[premoteFrame->rgVarRefIdx[i]]) = VT_EMPTY;
        }
    }

    return hr;
}

HRESULT DISPATCH_FRAME::GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO* pInfo)
{
    HRESULT hr = S_OK;

    hr = GetMemoryFrame();
    if (!hr)
    {
        m_pmemoryFrame->GetParamInfo(iparam, pInfo);
    }

    return hr;
}

HRESULT DISPATCH_FRAME::GetParam(ULONG iparam, VARIANT* pvar)
{
    VariantClear(pvar);
    return E_NOTIMPL;
}
HRESULT DISPATCH_FRAME::SetParam(ULONG iparam, VARIANT* pvar)
{
    return E_NOTIMPL;
}


///////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded)
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        // These three methods are completely declarative in the OICF strings. So we can just use
        // the underlying declarative callframe engine.
        //
        hr = GetRemoteFrame();
        if (!hr) hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
    }
    break;

    case IMETHOD_Invoke:
    {
        // Invoke, however, uses a [call_as] attribution, so it's a little trickier.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters
                //
                hr = ProxyPreCheck();
                if (!hr)
                {
                    // Set the stack location for the oicf frame. It needs to be a fn that has the signature
                    // of IDispatch::RemoteInvoke, excepting the receiver. We don't bother to restore the 
                    // previous setting, on the theory that it'll always get re-set appropriately whenever
                    // it's needed, since you have to cons up a IDispatch::RemoteInvoke frame to do so.
                    //
                    m_premoteFrame->SetStackLocation(&m_remoteFrame);
                    //
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the sizing request.
                    //
                    hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
                }
            }
            else
            {
                // Marshal the out-parameters. 
                //
                // This is quite rare: (re)marshalling the out-parameters on the client side of a call.
                //
                NYI(); hr = E_NOTIMPL;
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferNeeded = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded)
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr) hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
    }
    break;

    case IMETHOD_Invoke:
    {
        // Invoke, however, uses a [call_as] attribution, so it's a little trickier.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters. 
                //
                // This is quite rare: (re)marshalling the in-parameters on the server side of a remote call.
                // REVIEW: Probably should make it work, though.
                //
                NYI(); hr = E_NOTIMPL;
            }
            else
            {
                // Marshal the out-parameters
                //
                hr = StubPostCheck();
                if (!hr)
                {
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the sizing request.
                    //
                    hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
                }
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferNeeded = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

/////////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::Marshal(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                       ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags) 
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        // Tricky because we have to deal correctly with the transformations performed by
        // IDispatch_Invoke_Proxy: remember that there's a [call_as] on IDispatch::Invoke.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters
                //
                hr = ProxyPreCheck();
                if (!hr)
                {
                    // Set the stack location for the oicf frame. It needs to be a fn that has the signature
                    // of IDispatch::RemoteInvoke, excepting the receiver. We don't bother to restore the 
                    // previous setting, on the theory that it'll always get re-set appropriately whenever
                    // it's needed, since you have to cons up a IDispatch::RemoteInvoke frame to do so.
                    //
                    m_premoteFrame->SetStackLocation(&m_remoteFrame);
                    //
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the marshalling request.
                    //
                    hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
                }
            }
            else
            {
                // Marshal the out-parameters. 
                //
                // This is quite rare: (re)marshalling the out-parameters on the client side of a call.
                //
                NYI(); hr = E_NOTIMPL;
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferUsed = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::Marshal(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                       ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags) 
{
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        // These three methods are completely declarative in the OICF strings. So we can just use
        // the underlying declarative callframe engine.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            m_premoteFrame->SetReturnValue((HRESULT)m_hrReturnValue);
            hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        // Invoke, however, uses a [call_as] attribution, so it's a little trickier.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters. 
                //
                // This is quite rare: (re)marshalling the in-parameters on the server side of a remote call.
                // REVIEW: Probably should make it work, though.
                //
                NYI(); hr = E_NOTIMPL;
            }
            else
            {
                // Marshal the out-parameters
                //
                hr = StubPostCheck();
                if (!hr)
                {
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the request.
                    //
                    m_premoteFrame->SetReturnValue((HRESULT)m_hrReturnValue);
                    hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
                }
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferUsed = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}


///////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::Unmarshal(PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarhalled)
// Unmarshal out-parameters back into this call frame
{ 
    HRESULT hr = S_OK;

    m_hrReturnValue = RPC_E_CLIENT_CANTUNMARSHAL_DATA;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            hr = m_premoteFrame->Unmarshal(pBuffer, cbBuffer, dataRep, pctx, pcbUnmarhalled);
            if (!hr)
            {
                m_hrReturnValue = m_premoteFrame->GetReturnValue();
            }
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;
        hr = GetRemoteFrame();
        if (!hr)
        {
            m_premoteFrame->SetStackLocation(&m_remoteFrame);
            hr = m_premoteFrame->Unmarshal(pBuffer, cbBuffer, dataRep, pctx, pcbUnmarhalled);
            if (!hr)
            {
                m_hrReturnValue = m_premoteFrame->GetReturnValue();
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbUnmarhalled = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::Unmarshal(PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarhalled)
//
// Very rarely needed, if ever.
//
{
    HRESULT hr = S_OK;
    NYI(); hr = E_NOTIMPL;
    return hr;
}

//////////////////////////////////
    
HRESULT DISPATCH_CLIENT_FRAME::ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx) 
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            hr = m_premoteFrame->ReleaseMarshalData(pBuffer, cbBuffer, ibFirstRelease, dataRep, pctx);
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;
        NYI(); hr = E_NOTIMPL;
    }
    break;

    default:
        NOTREACHED();
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx) 
{
    HRESULT hr = S_OK;
    NYI(); hr = E_NOTIMPL;
    return hr;
}

////////////////////////////////////

inline void DISPATCH_CLIENT_FRAME::InitializeInvoke()
{
    FRAME_Invoke* pframe = (FRAME_Invoke*) m_pvArgs;
    //
    // Initialize the [out, unique] parameters if needed. In our hacked IDispatch_In_Memory, they're 
    // declared as [in,out,unique]. But if non-NULL, caller will NOT have initialized them, since he
    // thinks they're [out]-only. Thus, we must initialize things for him now.
    //
    // Sure wish MIDL would just support [out, unique] by themselves in this manner.
    //
    if (!m_fAfterCall && m_iMethod == IMETHOD_Invoke)
    {
        if (pframe->pVarResult) { V_VT(pframe->pVarResult) = VT_EMPTY; }
        if (pframe->pExcepInfo) { Zero(pframe->pExcepInfo);            }
        if (pframe->puArgErr)
        {
            // just a UINT; leave as junk
        }
    }
}

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif


HRESULT GetFieldCount(IRecordInfo *, ULONG *);          // Defined in oautil.cpp
HRESULT SafeArrayDestroyDescriptor(SAFEARRAY *);        // Defined in oautil.cpp
BOOL CheckSafeArrayDataForInterfacePointers(SAFEARRAY *, IRecordInfo *, ULONG, PVOID);
BOOL SAFEARRAY_ContainsByRefInterfacePointer(SAFEARRAY *, PVOID);
BOOL RECORD_ContainsByRefInterfacePointer(IRecordInfo *, PVOID);
BOOL VARIANT_ContainsByRefInterfacePointer(VARIANT *);

BOOL RECORD_ContainsByRefInterfacePointer(IRecordInfo* pinfo, PVOID pvData)
{
    HRESULT hr = S_OK;
    BOOL    fResult = FALSE;

    ULONG cFields; 
    ULONG iField;
    
    hr = GetFieldCount(pinfo, &cFields);
    if (!hr)
    {
        // Allocate and fetch the names of the fields
        //
        BSTR* rgbstr = new BSTR[cFields];
        if (rgbstr)
        {
            Zero(rgbstr, cFields*sizeof(BSTR));

            ULONG cf = cFields;
            hr = pinfo->GetFieldNames(&cf, rgbstr);
            if (!hr)
            {
                ASSERT(cf == cFields);
                
                //
                // Get a copy of the record data. We'll use this to see if any of the IRecordInfo
                // fn's we call end up stomping on the data, as GetFieldNoCopy is suspected of doing.
                // Making a copy both allows us to detect this and avoids stomping on memory that we
                // probably aren't allowed to stomp on in the original actual frame.
                //
                ULONG cbRecord;
                hr = pinfo->GetSize(&cbRecord);
                if (!hr)
                {
                    BYTE* pbRecordCopy = (BYTE*)AllocateMemory(cbRecord);
                    if (pbRecordCopy)
                    {
                        memcpy(pbRecordCopy, pvData, cbRecord);
                        
                        //
                        // Iterate over the fields, walking each one
                        //
                        for (iField = 0; !hr && iField < cFields; iField++)
                        {
                            VARIANT v; VariantInit(&v);
                            PVOID pvDataCArray;

                            //
                            // Use IRecordInfo::GetFieldNoCopy to find location and type of field.
                            // 
                            hr = pinfo->GetFieldNoCopy(pbRecordCopy, rgbstr[iField], &v, &pvDataCArray);
                            //
                            if (!hr)
                            {
                                VARTYPE vt = v.vt; ASSERT(vt & VT_BYREF);
                                //
                                if (vt & VT_ARRAY)
                                {
                                    // Either a VT_SAFEARRAY or a VT_CARRAY
                                    //
                                    if (pvDataCArray)
                                    {
                                        ASSERT( (vt & ~(VT_BYREF|VT_ARRAY)) == VT_CARRAY );
                                        //
                                        // pvDataCArray is the actual data to check. A descriptor for it exists
                                        // in the variant; this descriptor is managed by the IRecordInfo, not us.
                                        // 
                                        SAFEARRAY* psa = *v.pparray;
                                        ASSERT( psa->pvData == NULL );
                                        
                                        fResult = SAFEARRAY_ContainsByRefInterfacePointer(psa, pvDataCArray);
                                    }
                                    else
                                    {

                                                                                // [a-sergiv, 5/21/99] SafeArrays of VT_RECORD are designated as
                                                                                // VT_ARRAY|VT_RECORD. Therefore, checking for VT_SAFEARRAY only is not sufficient.
                                                                                // COM+ #13619

                                        ASSERT( (vt & ~(VT_BYREF|VT_ARRAY)) == VT_SAFEARRAY
                                                || (vt & ~(VT_BYREF|VT_ARRAY)) == VT_RECORD);
                                        //
                                        // GetFieldNoCopy might have allocated a descriptor on us. We want to detect this
                                        //
                                        SAFEARRAY** ppsaNew = v.pparray;
                                        SAFEARRAY** ppsaOld = (SAFEARRAY**)((PBYTE(ppsaNew) - pbRecordCopy) + PBYTE(pvData));
                                        //
                                        SAFEARRAY* psaNew = *ppsaNew;
                                        SAFEARRAY* psaOld = *ppsaOld;
                                        //
                                        ASSERT(psaNew); // would get error hr if not so
                                        //
                                        if (psaOld)
                                        {
                                            // GetFieldNoCopy did no allocations. Just check what we had in the first place.
                                            //
                                            fResult = SAFEARRAY_ContainsByRefInterfacePointer(psaOld, psaOld->pvData);
                                        }
                                        else
                                        {
                                            // GetFieldNoCopy did an allocation of an array descriptor. There was nothing
                                            // to walk in the first place. Just free that descriptor now.
                                            //
                                            SafeArrayDestroyDescriptor(psaNew);
                                        }
                                    }
                                }
                                else
                                {
                                    // Not an array. Just a simple by-ref. Use variant helper to check.
                                    // First translate the addresses, though, to point to the actual data.
                                    //
                                    v.pbVal = (v.pbVal - pbRecordCopy) + PBYTE(pvData);
                                    
                                    fResult = VARIANT_ContainsByRefInterfacePointer(&v);
                                }
                            }
                        }

                        FreeMemory(pbRecordCopy);
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
            }
            
            //
            // Free the fetched names
            //
            for (iField = 0; iField < cFields; iField++) 
            {
                SysFreeString(rgbstr[iField]);
            }
            delete [] rgbstr;
        }
    }

    return fResult;
}


BOOL CheckSafeArrayDataForInterfacePointers(SAFEARRAY* psa, IRecordInfo* pinfo, ULONG iDim, PVOID pvData)
{
    //
    // FYI: The bounds are stored in the array descriptor in reverse-textual order
    //
    const SAFEARRAYBOUND bound = psa->rgsabound[psa->cDims-1 - iDim];

    if (iDim + 1 == psa->cDims)
    {
        //
        // We're at the innermost dimension. 
        //
        for (ULONG iElement = 0; iElement < bound.cElements; iElement++)
        {
            //
            // Process the one element.
            //            
            if (psa->fFeatures & FADF_VARIANT)
            {
                if (VARIANT_ContainsByRefInterfacePointer((VARIANT*)pvData))
                    return TRUE;
            }
            else if (psa->fFeatures & FADF_RECORD)
            {
                if (RECORD_ContainsByRefInterfacePointer(pinfo, pvData))
                    return TRUE;
            }
            
            //
            // Point to the next element
            //
            pvData = (BYTE*)pvData + psa->cbElements;
        }
    }
    else
    {
        //
        // We're not at the innermost dimension. Walk that dimension.
        //
        for (ULONG iElement = 0; iElement < bound.cElements; iElement++)
        {
            //
            // Recurse for the next dimension.
            //
            if (CheckSafeArrayDataForInterfacePointers(psa, pinfo, iDim+1, pvData))
                return TRUE;
        }
    }

    return FALSE;
}

BOOL SAFEARRAY_ContainsByRefInterfacePointer(SAFEARRAY* psa, PVOID pvData)
{
    BOOL fResult = FALSE;
    
    if (psa)
    {
        if (psa->fFeatures & (FADF_UNKNOWN | FADF_DISPATCH))
        {
            if (pvData)
            {
                fResult = TRUE;
            }
        }
        else if (psa->fFeatures & FADF_VARIANT)
        {
            if (pvData)
            {
                fResult = CheckSafeArrayDataForInterfacePointers(psa, NULL, 0, pvData);
            }
        }
        else if (psa->fFeatures & FADF_RECORD)
        {
            //
            // AddRef the record info.
            //
            IRecordInfo* pinfo = SAFEARRAY_INTERNAL::From(psa)->piri;
            pinfo->AddRef();

            //
            // Current thinking is, we don't marshal IRecordInfo; it's context-agnostic.
            //

            //    
            // Walk the data in the array.
            //
            if (pvData)
            {
                fResult = CheckSafeArrayDataForInterfacePointers(psa, pinfo, 0, pvData);
            }

            //
            // Release our reference on the IRecordInfo.
            //
            ::Release(pinfo);
        }
    }

    return fResult;
}


BOOL VARIANT_ContainsByRefInterfacePointer(VARIANT* pVar)
{
    __try
        {
            if (V_VT(pVar) & VT_BYREF)
            {
                VARTYPE vt = V_VT(pVar) & ~VT_BYREF;
                if (vt & VT_ARRAY)
                {
                    // Check if byref safearray contains any interface pointers.
                    return SAFEARRAY_ContainsByRefInterfacePointer(*pVar->pparray, (*pVar->pparray)->pvData);
                }
                else
                {
                    switch (vt)
                    {
                    case VT_UNKNOWN:
                    case VT_DISPATCH:
                        return TRUE;
                    
                    case VT_VARIANT:
                        // Recurse and see if the contained VARIANT contains any interface pointers.
                        return VARIANT_ContainsByRefInterfacePointer(pVar->pvarVal);                

                    case VT_RECORD:
                        // Check if the record contains any interface pointers.
                        return RECORD_ContainsByRefInterfacePointer(pVar->pRecInfo, pVar->pvRecord);
                
                    default:
                        // No other types can contain interface pointers.
                        break;
                    }
                };
            }
            else if (V_VT(pVar) & VT_ARRAY)
            {
                // Check if the safearray contains any interface pointers.
                return SAFEARRAY_ContainsByRefInterfacePointer(pVar->parray, pVar->parray->pvData);
            }
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

    return FALSE;
}


HRESULT DISPATCH_CLIENT_FRAME::Free(ICallFrame* pframeArgsTo, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags) 
{ 
    HRESULT hr = S_OK;

    InitializeInvoke();    
    //
    // Ask our memory frame to do the actual work on the stack.
    //
    hr = GetMemoryFrame();
    if (!hr)
    {
        if (m_iMethod == IMETHOD_Invoke)
        {
            __try
            {
                // Invoke has the quirk that pDispParams is an [in] datum with [in,out] members, which
                // you can't express correctly in MIDL (sigh). So we have to fool the NDR engine here
                // into not freeing that which it really isn't supposed to. We also have to be particularly
                // careful with our user mode addresses, capturing and probing them carefully.
                //
                PVOID pvArgsTo;
                FRAME_Invoke *pstackFrameMe,*pstackFrameHim;
                DISPPARAMS   *pdispparamsMe,*pdispparamsHim;
                DISPPARAMS     dispParamsMe,  dispParamsHim;
                //
                pstackFrameMe = (FRAME_Invoke*)m_pvArgs;
                //
                // Save away copy of the actual DISPPARAMS structure
                //
                pdispparamsMe = pstackFrameMe->pDispParams;
                TestReadSrc(pdispparamsMe, sizeof(DISPPARAMS));
                dispParamsMe = *pdispparamsMe; 
                //
                // NULL out the offending [in,out] pointers inside the frames. They're [unique]
                // pointers, so we're allowed to do that.
                //
                pdispparamsMe->rgvarg = NULL;
                pdispparamsMe->rgdispidNamedArgs = NULL;
                //
                // Do the same to the destination frame, if there is one
                //
                if (pframeArgsTo)
                {
                    pvArgsTo = pframeArgsTo->GetStackLocation(); SetToUser(pvArgsTo);
                    pstackFrameHim = (FRAME_Invoke*)pvArgsTo; 
                    //
                    pdispparamsHim = pstackFrameHim->pDispParams;
                    TestReadDst(pdispparamsHim, sizeof(DISPPARAMS));   
                    dispParamsHim = *pdispparamsHim;
                    //
                    pdispparamsHim->rgvarg = NULL;
                    pdispparamsHim->rgdispidNamedArgs = NULL;
                }
                //
                // Call our helper to do the bulk of the work
                //
                hr = m_pmemoryFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
                //
                if (!hr)
                {
                    // Now fix up the DISPPARAMs
                    //
                    if (pframeArgsTo)
                    {
                        // Copy pDispParams->rgvarg back to the parent frame
                        //
                        OAUTIL util(m_fFromUser, m_fToUser, pWalkerCopy, pWalkerFreeDest, NULL, TRUE, TRUE);
                        //
                        SetToUser(pvArgsTo);
                        BOOL fInSameSpace = InSameSpace(freeFlags);
                        //
                        const ULONG cArgs = min(dispParamsMe.cArgs, dispParamsHim.cArgs);
                        //
                        for (ULONG iArg = 0; !hr && iArg < cArgs; iArg++)
                        {
                            VARIANT* pvarSrc = &dispParamsMe.rgvarg[iArg];      TestReadSrc (pvarSrc, sizeof(VARIANT));
                            VARIANT* pvarDst = &dispParamsHim.rgvarg[iArg];     TestWriteDst(pvarDst, sizeof(VARIANT));
                            
                            //
                            // We are propagating the individual members of a DISPPARAMS
                            // from a server frame back to a client frame.  
                            //
                            // We must ONLY do this if we've got a byref variant here.
                            // Those map to [in,out] parameters.  We must ignore all
                            // others.
                            //
                            // Now, logic would dictate that we call VariantClear on the
                            // original variant (pvarDst) before we copy it back over.
                            // This would be true, if our VariantCopy weren't so damned
                            // clever.  Our VariantCopy shares a lot of memory.  A LOT of
                            // memory.  So, for example, when copy a VT_BYREF | VT_VARIANT
                            // or VT_BYREF | VT_UNKNOWN back, we won't bother to allocate 
                            // the new variant or interface pointer wrapper for them.  Since
                            // the top-level VT is not allowed to change, we can safely assume
                            // that this will work.  What about a VT_BYREF | VT_BSTR?  Surely
                            // we need to free the BSTR in that variant before we copy back?
                            // Not so!  Our VariantCopy() routine just blindly copies the pointer
                            // in this case, instead of copying the BSTR.  So if the caller
                            // changed it, they've already free'd the memory.  Thus, we can
                            // just blindly copy the pointer on the way back, too.
                            //
                            // So we don't need to call VariantClear on the original variant.
                            //
                            // Note that VariantCopy *does* call VariantClear on the original
                            // variant, but since we don't own the byref, we don't care.
                            // 
                            if (V_VT(pvarSrc) & VT_BYREF)
                            {
                                // Make sure we're walking correctly.
                                BOOL WalkInterface = util.WalkInterfaces();
                                
                                util.SetWalkInterfaces(TRUE);
                                
                                // You are not allowed to change the VT of a
                                // dispparam during a call.  Period.
                                ASSERT(V_VT(pvarSrc) == V_VT(pvarDst));
                                
                                // Copy the variant back.
                                hr = util.VariantCopy(pvarDst, pvarSrc);
                                
                                // Reset interface walking.
                                util.SetWalkInterfaces(WalkInterface);
                            }
                        }
                    }

                    if (freeFlags && SUCCEEDED(hr))
                    {
                        // Free our pDispParams->rgvarg and pDispParams->rgdispidNamedArgs.
                        //
                        SetToUser(m_pvArgs); // free routines check against destination
                        //
                        OAUTIL util(m_fFromUser, m_fToUser, NULL, pWalkerFree, NULL, TRUE, TRUE);
                        
                        //
                        // pDispParams->rgvarg is logically [in,out]. So we always free its
                        // contents if there's anything at all to free.
                        //
                        const ULONG cArgs = dispParamsMe.cArgs;
                        for (ULONG iArg = 0; !hr && iArg < cArgs; iArg++)
                        {
                            // Parameters are in reverse order inside the DISPPARAMS.  We iterate
                            // in forward order as a matter of style and for consistency with the
                            // CallFrame implementation.
                            //
                            VARIANTARG *pvarDst = &dispParamsMe.rgvarg[cArgs-1 - iArg];
                            TestReadDst(pvarDst, sizeof(VARIANT));

                            // We only own byrefs if we're a copy.
                            hr = util.VariantClear(pvarDst, m_fIsCopy);
                        }                        

                        if (SUCCEEDED(hr))
                        {
                            //
                            // The two arrays themselves, pDispParams->rgvarg and pDispParams->rgdispidNamedArgs
                            // are actually caller allocated. We shouldn't, properly, actually free them at all.
                            // Only exception is if we're actually a copy, in which case they're ours and should
                            // be free'd as would be the case in a normal call.
                            //
                            if (m_fIsCopy)
                            {
                                ICallFrameInit* pinit;
                                HRESULT hr2 = QI(m_pmemoryFrame, pinit);
                                if (!hr2)
                                {
                                    //
                                    CallFrame* pMemoryFrame = pinit->GetCallFrame();
                                    pMemoryFrame->Free(dispParamsMe.rgvarg);
                                    pMemoryFrame->Free(dispParamsMe.rgdispidNamedArgs);
                                    //
                                    pinit->Release();
                                }
                                else
                                {
                                    DEBUG(NOTREACHED()); // Ignore bug and leak the memory
                                }
                                
                                dispParamsMe.rgvarg = NULL;
                                dispParamsMe.rgdispidNamedArgs = NULL;
                            }
                        }
                    }
                    //
                    if (nullFlags & (CALLFRAME_NULL_INOUT))
                    {
                        // Don't restore the rgvarg/rgdispidNamedargs in the callframe.
                        // Nulling work has already been done in the helper and by hand above
                    }
                    else
                    {
                        if ((freeFlags & (CALLFRAME_FREE_IN | CALLFRAME_FREE_OUT | CALLFRAME_FREE_INOUT)) == 0)
                        {
                            // Restore our pDispParams to what they were before we started, but
                            // only if we didn't just free them.
                            //
                            pdispparamsMe->rgvarg            = dispParamsMe.rgvarg;
                            pdispparamsMe->rgdispidNamedArgs = dispParamsMe.rgdispidNamedArgs;
                        }
                    }
                    //
                    if (pframeArgsTo)
                    {
                        // Restore his pDispParams to what they were before we started
                        //
                        pdispparamsHim->rgvarg            = dispParamsHim.rgvarg;
                        pdispparamsHim->rgdispidNamedArgs = dispParamsHim.rgdispidNamedArgs;
                    }
                }
            }
            __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
            {
                hr = HrNt(GetExceptionCode());
            }
        }
        else
        {
            // Normal call. Just propogate/free/null the in-memory variation
            //
            hr = m_pmemoryFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
        }
    }
    
    if (!hr)
    {
        // We ourselves are the guys that have the actual return value: it's not on the stack and so
        // what our helper has set already is bogus.
        //
        if (pframeArgsTo)
        {
            pframeArgsTo->SetReturnValue((HRESULT)m_hrReturnValue);
        }
    }

    return hr;
}

HRESULT DISPATCH_CLIENT_FRAME::FreeParam(ULONG iparam, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
{
    HRESULT hr = S_OK;

    BOOL fUseMemoryFrame = TRUE;

    if (m_iMethod == IMETHOD_Invoke)
    {
        FRAME_Invoke *pstackFrameMe = (FRAME_Invoke*)m_pvArgs;

        switch (iparam)
        {
            //
            // Some of the parameters are declared as [in,out,unique] to MIDL when they are in fact [out,unique].
            // So we must modify the conditions under which the freeing happens.
            //
        case IPARAM_Invoke_PVarResult:
        case IPARAM_Invoke_PExcepInfo:
        {
            freeFlags = freeFlags & (CALLFRAME_FREE_OUT | CALLFRAME_FREE_TOP_OUT);
            nullFlags = nullFlags & (CALLFRAME_NULL_OUT);
        }
        break;
        //
        // The DISPPARAMS are just special, period. We handle them here.
        //
        case IPARAM_Invoke_DispParams:
        {
            __try
                {
                    // Invoke has the quirk that pDispParams is an [in] datum with [in,out] members.
                    // So we do the freeing by hand.
                    //
                    // Save away copy of the actual DISPPARAMS structure
                    //
                    DISPPARAMS *pdispparamsMe = pstackFrameMe->pDispParams;
                    TestReadSrc(pdispparamsMe, sizeof(DISPPARAMS));
                    DISPPARAMS dispParamsMe = *pdispparamsMe; 

                    if (freeFlags) // REVIEW: Should this be a finer grained check?
                    {
                        SetToUser(m_pvArgs); // free routines check against destination
                        //
                        OAUTIL util(m_fFromUser, m_fToUser, NULL, pWalkerFree, NULL, TRUE, TRUE);
                        //
                        // pDispParams->rgvarg is logically [in,out]. So we always free its
                        // contents if there's anything at all to free.
                        //
                        const ULONG cArgs = dispParamsMe.cArgs;
                        if (dispParamsMe.rgvarg)
                        {
                            for (ULONG iArg = 0; !hr && iArg < cArgs; iArg++)
                            {
                                VARIANT* pvarDst = &dispParamsMe.rgvarg[iArg]; TestReadDst(pvarDst, sizeof(VARIANT));
                                void* pvTemp = pvarDst->ppunkVal;
                                hr = util.VariantClear(pvarDst);
                                pvarDst->ppunkVal = (IUnknown**)pvTemp;                            
                            }                        
                        }
                        else
                        {
                            // Ignore missing arguments. It's a unique pointer, so technically that's legal, and
                            // besides, we reliably NULL this out during propogation in DISPATCH_CLIENT_FRAME::Free
                            // so as to be able to handle things ourself very carefully there.
                        }
                        //
                    }
                }
            __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
                {
                    hr = HrNt(GetExceptionCode());
                }

            fUseMemoryFrame = FALSE;
        }
        break;

        default:
            //
            // The other IDispatch::Invoke don't need any freeing
            //
            fUseMemoryFrame = FALSE;
            break;

            /* end switch */
        }
    }
    //
    // If we still have more work to do, then get our memory frame to carry it out
    //
    if (!hr && fUseMemoryFrame)
    {
        hr = GetMemoryFrame();
        if (!hr)
        {
            hr = m_pmemoryFrame->FreeParam(iparam, freeFlags, pWalkerFree, nullFlags);
        }
    }

    return hr;
}

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

///////////////////////////////////////////////

HRESULT DISPATCH_SERVER_FRAME::Free(ICallFrame* pframeArgsTo, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags) 
{
    HRESULT hr = S_OK;

    if (m_iMethod == IMETHOD_Invoke)
    {
        hr = GetMemoryFrame();
        if (!hr)
        {            
            // Remote call to invoke. Remote frame has some additional arguments that need to be freed but
            // must not be propogated. So use the memory frame to do the propogation.
            // 
            hr = m_pmemoryFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, CALLFRAME_FREE_NONE, NULL, CALLFRAME_NULL_NONE);
            if (!hr)
            {
                // Now that we've propagated the things we were going to propagate, do a 
                // SubPostCheck to make sure that we don't try to free memory more than once.
                //
                StubPostCheck();

                // Always use the remote frame to do the actual freeing, since it did the allocations in the first place
                //
                ASSERT(m_premoteFrame);
                hr = m_premoteFrame->Free(NULL, NULL, NULL, freeFlags, pWalkerFree, nullFlags);
            }
        }
    }
    else
    {
        // Always use the remote frame to do the actual freeing, since it did the allocations in the first place
        //
        ASSERT(m_premoteFrame);
        hr = m_premoteFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
    }

    if (!hr)
    {
        // We ourselves are the guys that have the actual return value: it's not on the stack
        //
        if (pframeArgsTo)
        {
            pframeArgsTo->SetReturnValue((HRESULT)m_hrReturnValue);
        }
    }

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::FreeParam(ULONG iparam, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
{
    HRESULT hr = S_OK;
    //
    // Always use the remote frame to do the actual freeing, since it did the allocations in the first place
    //
    ASSERT(m_premoteFrame);
    hr = m_premoteFrame->FreeParam(iparam, freeFlags, pWalkerFree, nullFlags);
    //
    return hr;
}

/////////////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame) 
{ 
    HRESULT hr = S_OK;

    *ppFrame = NULL;
    //
    // IDispatch::Invoke needs some prepatory work on its [out,unique] parameters.
    //
    InitializeInvoke();
    //
    // Ask our memory frame to actually do the copying
    //
    DISPATCH_CLIENT_FRAME* pNewFrame = NULL;
    //
    hr = GetMemoryFrame();
    if (!hr)
    {
        ICallFrame*   pframeCopy;
        
        if (m_iMethod == IMETHOD_Invoke)
                {
            // Need to do some free-esque work here...
            // The problem is that the walker needs to know whether the DISPPARAM we're marshalling
            // is in or in-out.  This is only a valid distinction to make for the top-level variant,
            // so we can't encode the logic into OAUTIL (which is used in CopyWorker, etc.).
            //
            FRAME_Invoke *pstackFrameMe,*pstackFrameHim;
            DISPPARAMS   *pdispparamsMe,*pdispparamsHim;
            DISPPARAMS     dispParamsMe,  dispParamsHim;
            //
            pstackFrameMe = (FRAME_Invoke*)m_pvArgs;
            //
            // Save away copy of the actual DISPPARAMS structure
            //
            pdispparamsMe = pstackFrameMe->pDispParams;
            TestReadSrc(pdispparamsMe, sizeof(DISPPARAMS));
            dispParamsMe = *pdispparamsMe; 
            //
            // NULL out the offending [in,out] pointers inside the frames. They're [unique]
            // pointers, so we're allowed to do that.
            //
            pdispparamsMe->rgvarg = NULL;
            //
            // Call our helper to do the bulk of the work
            // This will copy everything but the DISPPARAMS.
            //
            hr = m_pmemoryFrame->Copy(callControl, pWalker, &pframeCopy);
            if (!hr)
            {
                // Allocate his DISPPARAMS arrays.
                //
                // This is a bit of a back door, since we know that pframeCopy
                // is really a CallFrame, and we need to allocate some more memory
                // for the DISPPARAMS.
                //
                CallFrame *cfDest = (CallFrame *)(pframeCopy);
                
                PVOID pvArgsTo = pframeCopy->GetStackLocation(); SetToUser(pvArgsTo);
                pstackFrameHim = (FRAME_Invoke*)pvArgsTo; 
                pdispparamsHim = pstackFrameHim->pDispParams;
                
                pdispparamsHim->rgvarg     = (VARIANTARG *)cfDest->Alloc(sizeof(VARIANTARG) * dispParamsMe.cArgs);
                if (!pdispparamsHim->rgvarg)
                    hr = E_OUTOFMEMORY;
                
                if (!hr)
                {
                    // OK! Copy the DISPPARAMS!
                    //
                    OAUTIL util(m_fFromUser, m_fToUser, pWalker, NULL, NULL, TRUE, FALSE);
                    
                    for (ULONG iArg = 0; iArg < dispParamsMe.cArgs; iArg++)
                    {
                        VARIANT* pvarSrc = &dispParamsMe.rgvarg[iArg];      
                        VARIANT* pvarDst = &(pdispparamsHim->rgvarg[iArg]);
                        
                        TestReadSrc (pvarSrc, sizeof(VARIANT));
                        TestWriteDst(pvarDst, sizeof(VARIANT));
                        
                        VariantInit(pvarDst);
                        //
                        // We 'accumulate' hr's from VariantCopy below.
                        // We cannot break out of the loop because we want
                        // each VARIANTARG to be at least initialized (above).
                        //
                        if (!hr)
                        {
                            // Set the OAUTIL's 'this is an out parameter' flag.
                            // Note that the 'in' flag is always on. 
                            //
                            // (My favorite part is that the following two lines
                            // are the whole reason for doing this complicated
                            // allocation and loop.  ^_^)
                            //
                            BOOL fInOut = (V_VT(pvarSrc) & VT_BYREF) ? TRUE : FALSE;
                            util.SetWorkingOnOut(fInOut);
                            
                            hr = util.VariantCopy(pvarDst, pvarSrc, TRUE);
                        }
                    }
                }
                else
                {
                    // Allocations failed, going to be returing E_OUTOFMEMORY.
                    ::Release(pframeCopy);
                }
            }

            // Restore our DISPPARAMS.
            //
            pdispparamsMe->rgvarg  = dispParamsMe.rgvarg;
        }
        else
        {
            // Call our helper to do the bulk of the work            
            //
            hr = m_pmemoryFrame->Copy(callControl, pWalker, &pframeCopy);
        }
            
        if (!hr)
        {
            // Got a copy of the memory frame; now wrap with a legacy guy around that
            //
            PVOID pvArgsCopy = pframeCopy->GetStackLocation();
            
            pNewFrame = new DISPATCH_CLIENT_FRAME(NULL, m_iMethod, pvArgsCopy, m_pInterceptor);
            if (pNewFrame)  
            {
                // Tell him his memory frame
                //
                ::Set(pNewFrame->m_pmemoryFrame, pframeCopy);
                //
                // Tell him that he's in fact a copy. This modifies his freeing behaviour
                // on pDispParams in IDispatch::Invoke.
                //
                pNewFrame->m_fIsCopy = TRUE;
            }
            else
                hr = E_OUTOFMEMORY;

            ::Release(pframeCopy);
        }
    }

    if (!hr)
    {
        hr = QI(pNewFrame, *ppFrame);
        ::Release(pNewFrame);
    }

    return hr;
}



HRESULT DISPATCH_SERVER_FRAME::Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame) 
{
    HRESULT hr = S_OK;
    *ppFrame = NULL;
    //
    // Ask our _remote_ frame to actually do the copying
    //
    DISPATCH_SERVER_FRAME* pframeCopy = NULL;
    //
    if (!hr) hr = StubPreCheck();
    if (!hr) hr = GetMemoryFrame();
    if (!hr)
    {
        ICallFrame* premoteFrameCopy;
        hr = m_premoteFrame->Copy(callControl, pWalker, &premoteFrameCopy);
        if (!hr)
        {
            // Got a copy of the remote frame; now wrap with a legacy guy around that
            //
            PVOID pvArgsCopy = premoteFrameCopy->GetStackLocation();

            pframeCopy = new DISPATCH_SERVER_FRAME(NULL, m_iMethod, pvArgsCopy, m_pInterceptor);
            if (pframeCopy)  
            {
                ::Set(pframeCopy->m_premoteFrame, premoteFrameCopy);
                //
                // Copy over the in-memory frame that we'll use for actually invoking
                //
                pframeCopy->m_fDoneStubPrecheck = m_fDoneStubPrecheck;
                pframeCopy->m_memoryFrame       = m_memoryFrame;
            }
            else
                hr = E_OUTOFMEMORY;

            ::Release(pframeCopy);
        }
    }

    if (!hr)
    {
        hr = QI(pframeCopy, *ppFrame);
        ::Release(pframeCopy);
    }

    return hr;
}





HRESULT DISPATCH_FRAME::WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker) 
// Walk the in-parameters and / or out-parameters for interface pointers
{
    HRESULT hr = S_OK;
    
    if (pWalker)
    { 
        switch (m_iMethod)
        {
        case IMETHOD_GetTypeInfoCount:
        {
            FRAME_GetTypeInfoCount* pframe = (FRAME_GetTypeInfoCount*)m_pvArgs;
            //
            // No interfaces here
            //
        }
        break;

        case IMETHOD_GetTypeInfo:
        {
            FRAME_GetTypeInfo* pframe = (FRAME_GetTypeInfo*)m_pvArgs;
            // REVIEW: Should this really be walked?  (See oautil.cpp and the UDT stuff)
            if (walkWhat & CALLFRAME_WALK_OUT)
            {
                hr = OAUTIL(FALSE, FALSE, NULL, NULL, pWalker, FALSE, TRUE).WalkInterface(pframe->ppTInfo);
            }
        }
        break;

        case IMETHOD_GetIDsOfNames:
        {
            FRAME_GetIDsOfNames* pframe = (FRAME_GetIDsOfNames*)m_pvArgs;
            //
            // No interfaces here
            //
        }
        break;

        case IMETHOD_Invoke:
        {
            FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;
            //
            // DISPPARAMS are [in,out]
            //
            if (pframe->pDispParams)
            {
                hr = OAUTIL(FALSE, FALSE, NULL, NULL, pWalker, TRUE, TRUE).Walk(walkWhat, pframe->pDispParams);
            }
            //
            // pVarResult is just [out]
            //
            if ((walkWhat & CALLFRAME_WALK_OUT) && SUCCEEDED(hr))
            {
                if (pframe->pVarResult)
                {
                    hr = OAUTIL(FALSE, FALSE, NULL, NULL, pWalker, FALSE, TRUE).Walk(pframe->pVarResult);
                }
            }
        }
        break;

        default:
            NOTREACHED();
            hr = RPC_E_INVALIDMETHOD;
            break;
        }
    }
    else
        hr = E_INVALIDARG;
        
    return hr;  
}










////////////////////////////////////////////////////////////////////////////////////////
//
// Invoking


HRESULT DISPATCH_FRAME::Invoke(void *pvReceiver) 
// Invoke ourselves on the indicated receiver
{ 
    HRESULT hr = S_OK; 
    IDispatch* pdisp = reinterpret_cast<IDispatch*>(pvReceiver);

    m_fAfterCall = TRUE;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    {
        FRAME_GetTypeInfoCount* pframe = (FRAME_GetTypeInfoCount*)m_pvArgs;
        m_hrReturnValue = pdisp->GetTypeInfoCount(pframe->pctinfo);
    }
    break;

    case IMETHOD_GetTypeInfo:
    {
        FRAME_GetTypeInfo* pframe = (FRAME_GetTypeInfo*)m_pvArgs;
        m_hrReturnValue = pdisp->GetTypeInfo(pframe->iTInfo, pframe->lcid, pframe->ppTInfo);
    }
    break;

    case IMETHOD_GetIDsOfNames:
    {
        FRAME_GetIDsOfNames* pframe = (FRAME_GetIDsOfNames*)m_pvArgs;
        m_hrReturnValue = pdisp->GetIDsOfNames(pframe->riid, pframe->rgszNames, pframe->cNames, pframe->lcid, pframe->rgDispId);
    }
    break;

    default:
        NOTREACHED();
        m_hrReturnValue = CALLFRAME_E_COULDNTMAKECALL;
        m_fAfterCall = FALSE;
        break;
    }
        
    return hr;  
}
    
HRESULT DISPATCH_CLIENT_FRAME::Invoke(void *pvReceiver, ...) 
// Invoke ourselves on the indicated receiver
{ 
    HRESULT hr = S_OK; 
    
    if (m_iMethod == IMETHOD_Invoke)
    {
        FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;
        IDispatch* pdisp = reinterpret_cast<IDispatch*>(pvReceiver);
        //
        m_hrReturnValue = pdisp->Invoke(pframe->dispIdMember, *pframe->piid, pframe->lcid, pframe->wFlags, pframe->pDispParams, pframe->pVarResult, pframe->pExcepInfo, pframe->puArgErr);
        //
        m_fAfterCall = TRUE;
    }
    else
        hr = DISPATCH_FRAME::Invoke(pvReceiver);
        
    return hr;  
}


HRESULT DISPATCH_SERVER_FRAME::Invoke(void *pvReceiver, ...) 
// Invoke ourselves on the indicated receiver
{ 
    HRESULT hr = S_OK;
    
    m_hrReturnValue = CALLFRAME_E_COULDNTMAKECALL; 
    
    if (m_iMethod == IMETHOD_Invoke)
    {
        hr = StubPreCheck();
        if (!hr)
        {
            IDispatch* pdisp = reinterpret_cast<IDispatch*>(pvReceiver);
            //
            m_hrReturnValue = pdisp->Invoke(m_memoryFrame.dispIdMember, *m_memoryFrame.piid, m_memoryFrame.lcid, m_memoryFrame.wFlags, m_memoryFrame.pDispParams, m_memoryFrame.pVarResult, m_memoryFrame.pExcepInfo, m_memoryFrame.puArgErr);
            //
            m_fAfterCall = TRUE;
        }
    }
    else
        hr = DISPATCH_FRAME::Invoke(pvReceiver);
        
    return hr;  
}


////////////////////////////////////////////////////////////////////////////////////////
//
// COM infrastructure


STDMETHODIMP LEGACY_FRAME::InnerQueryInterface (REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown)           { *ppv = (IUnkInner*) this; }
    else if (iid == __uuidof(ICallFrame))   { *ppv = (ICallFrame*) this; }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}








////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// LEGACY_INTERCEPTOR
//
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

LEGACY_INTERCEPTOR::LEGACY_INTERCEPTOR(IUnknown * punkOuter)
{
    m_refs              = 1;
    m_punkOuter         = punkOuter ? punkOuter : (IUnknown *)(void*)((IUnkInner *)this);
    m_psink             = NULL;
    m_iid               = IID_NULL;
    m_premoteInterceptor         = NULL;
    m_pmemoryInterceptor         = NULL;
    m_fRegdWithRemoteInterceptor = FALSE;
    m_fRegdWithMemoryInterceptor = FALSE;
    m_ppframeCustomer            = NULL;
    m_fShuttingDown              = FALSE;
    m_pmdMostDerived             = NULL;
}

LEGACY_INTERCEPTOR::~LEGACY_INTERCEPTOR (void)
{
    // Paranoia: Prevent reference count disturbences on our aggregator as we
    // shut ourselves down.
    //
    m_punkOuter = (IUnknown *)(void*)((IUnkInner *)this);
    //
    // Don't let _ourselves_ get bothered 
    //
    m_fShuttingDown = TRUE;
    //
    // Actually do the cleanup work
    //
    ::Release(m_psink);
    //
    ::Release(m_pmdMostDerived);
    //
    ReleaseRemoteInterceptor();
    ReleaseMemoryInterceptor();
}

HRESULT LEGACY_INTERCEPTOR::Init()
{
    HRESULT hr = S_OK;
    if (m_frameLock.FInit() == FALSE)
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT LEGACY_INTERCEPTOR::GetRemoteFrameFor(ICallFrame** ppFrame, LEGACY_FRAME* pFrame)
// Create and return a reference on an oicf-driven frame for the indicated legacy frame
{
    HRESULT hr = S_OK;
    m_frameLock.LockExclusive();
    m_ppframeCustomer = ppFrame;

    HRESULT hrReturnValue;
    ULONG cbArgs;
    hr = m_premoteInterceptor->CallIndirect(&hrReturnValue, pFrame->m_iMethod, pFrame->m_pvArgs, &cbArgs);

    m_ppframeCustomer = NULL;
    m_frameLock.ReleaseLock();
    return hr;
}

HRESULT LEGACY_INTERCEPTOR::GetMemoryFrameFor(ICallFrame** ppFrame, LEGACY_FRAME* pFrame)
// Create and return a reference on an oicf-driven frame that understands the in-memory
// representation of the interface.
{
    HRESULT hr = S_OK;
    m_frameLock.LockExclusive();
    m_ppframeCustomer = ppFrame;

    HRESULT hrReturnValue;
    ULONG cbArgs;
    hr = m_pmemoryInterceptor->CallIndirect(&hrReturnValue, pFrame->m_iMethod, pFrame->m_pvArgs, &cbArgs);

    m_ppframeCustomer = NULL;
    m_frameLock.ReleaseLock();
    return hr;
}

HRESULT LEGACY_INTERCEPTOR::OnCall(ICallFrame* pframe)
// Callback from our m_premoteInterceptor when it gets a call. It only ever does so in
// response to our stimulous in GetRemoteFrameFor above.
{
    HRESULT hr = S_OK;
    ASSERT(m_frameLock.WeOwnExclusive() && m_ppframeCustomer);

    *m_ppframeCustomer = pframe;
    (*m_ppframeCustomer)->AddRef(); // hold on to the frame beyond the callback here

    return hr;
}

///////////////////////////////////////////////////////////////////
//
// IDispatch
//
///////////////////////////////////////////////////////////////////
#if defined(_AMD64_) || defined(_X86_)
HRESULT LEGACY_INTERCEPTOR::GetTypeInfoCount(UINT* pctinfo)
{
    INTERCEPT_CALL(pctinfo, pctinfo, IMETHOD_GetTypeInfoCount)
        }
HRESULT LEGACY_INTERCEPTOR::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo)
{
    INTERCEPT_CALL(iTInfo, ppTInfo, IMETHOD_GetTypeInfo)
        }
HRESULT LEGACY_INTERCEPTOR::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId)
{
    return GetIDsOfNames(&riid, rgszNames, cNames, lcid, rgDispId); // avoid & problems with the ref
}
HRESULT LEGACY_INTERCEPTOR::GetIDsOfNames(const IID* piid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId)
{
    INTERCEPT_CALL(piid, rgDispId, IMETHOD_GetIDsOfNames)
        }
HRESULT LEGACY_INTERCEPTOR::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pDispParams,
                                   VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr)
{
    INTERCEPT_CALL(dispIdMember, puArgErr, IMETHOD_Invoke)
        }
#else
HRESULT LEGACY_INTERCEPTOR::GetTypeInfoCount(UINT* pctinfo)
{
    return GenericCall(IMETHOD_GetTypeInfoCount,
                       this,
                       pctinfo);
}
HRESULT LEGACY_INTERCEPTOR::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo)
{
    return GenericCall(IMETHOD_GetTypeInfo,
                       this,
                       iTInfo,
                       lcid, ppTInfo);
}
HRESULT LEGACY_INTERCEPTOR::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, 
                                          UINT cNames, LCID lcid, DISPID * rgDispId)
{
    return GenericCall(IMETHOD_GetIDsOfNames, 
                       this, 
                       &riid, 
                       rgszNames, 
                       cNames, 
                       lcid, 
                       rgDispId);
}
HRESULT LEGACY_INTERCEPTOR::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                                   WORD wFlags,DISPPARAMS * pDispParams,
                                   VARIANT * pVarResult, EXCEPINFO * pExcepInfo, 
                                   UINT * puArgErr)
{
    return GenericCall(IMETHOD_Invoke, 
                       this, 
                       dispIdMember,
                       &riid,
                       lcid,
                       wFlags,
                       pDispParams,
                       pVarResult,
                       pExcepInfo,
                       puArgErr);
}

    
HRESULT LEGACY_INTERCEPTOR::GenericCall(ULONG iMethod, ...)
{
    va_list va;
    va_start(va, iMethod);

    const void* pvArgs = va;
    ULONG cbArgs;
    HRESULT hrReturn;
    CallIndirect(&hrReturn, iMethod, const_cast<void*>(pvArgs), &cbArgs);
    return hrReturn;
}
#endif



///////////////////////////////////////////////////////////////////
//
// ICallIndirect
//
///////////////////////////////////////////////////////////////////
    
STDMETHODIMP LEGACY_INTERCEPTOR::CallIndirect(HRESULT* phReturnValue, ULONG iMethod, void* pvArgs, ULONG* pcbArgs)
// Act as though an invocation on the indicated method in this interface
// has been received, with the indicated stack frame.
{
    HRESULT hr = S_OK;
    //
    // Assume a failed call until we know otherwise
    //
    if (phReturnValue) *phReturnValue = CALLFRAME_E_COULDNTMAKECALL;

    if (IMETHOD_FIRST <= iMethod && iMethod < m_cMethods)
    {
        // Make a new frame to service the call
        //
        LEGACY_FRAME* pNewFrame = NULL;
        
        if (__uuidof(IDispatch) == m_iid)
        {
            pNewFrame = new DISPATCH_CLIENT_FRAME(NULL, iMethod, pvArgs, this);
        }
        else
            hr = E_NOINTERFACE;

        if (pNewFrame) 
        {
            if (m_psink)
            {
                // Deliver the call to the registered sink
                //
                hr = m_psink->OnCall( static_cast<ICallFrame*>(pNewFrame) );
                if (!hr && phReturnValue)
                {
                    // Pass the return value back to our caller
                    //
                    *phReturnValue = pNewFrame->GetReturnValue();
                }
            }
            
            pNewFrame->Release();
        }
        else if (!hr)
        {
            hr = E_OUTOFMEMORY;
        }
        //
        // In all valid-iMethod cases compute the stack size
        //
        GetStackSize(iMethod, pcbArgs);
    }
    else
    {
        *pcbArgs = 0;
        hr = E_INVALIDARG;  // Caller bug, so we're graceful
    }

    return hr;
}

STDMETHODIMP LEGACY_INTERCEPTOR::GetStackSize(ULONG iMethod, ULONG * pcbStack)
// Return the stack size for the indicated method in this interface
{
    HRESULT hr = S_OK;
    ASSERT (pcbStack);
    //
    // Should be implemented by subclasses
    //
    *pcbStack = 0;
    hr = E_INVALIDARG;

    return hr;
}

STDMETHODIMP DISPATCH_INTERCEPTOR::GetStackSize(ULONG iMethod, ULONG* pcbStack)
// Return the stack size for the indicated method in this interface
{
    HRESULT hr = S_OK;

    if (m_pmemoryInterceptor)
    {
        return m_pmemoryInterceptor->GetStackSize(iMethod, pcbStack);
    }
    else
    {
        *pcbStack = 0;
        hr = E_UNEXPECTED;
    }

    return hr;
}
        
STDMETHODIMP LEGACY_INTERCEPTOR::GetIID(IID* piid, BOOL* pfDerivesFromIDispatch, ULONG* pcMethod, LPWSTR* pwszInterface)
{
    HRESULT hr = S_OK;

    if (piid)
    {
        if (m_pmdMostDerived)
        {
            *piid = *m_pmdMostDerived->m_pHeader->piid;
        }
        else
        {
            *piid = m_iid;
        }
    }

    if (pfDerivesFromIDispatch)
    {
        *pfDerivesFromIDispatch = (m_iid == __uuidof(IDispatch));
    }
           
    if (pcMethod)
    {
        if (m_pmdMostDerived)
        {
            *pcMethod = m_pmdMostDerived->m_pHeader->DispatchTableCount;
        }
        else
        {
            *pcMethod = m_cMethods;
        }
    }

    if (pwszInterface)
    {
        *pwszInterface = NULL;

        if (m_pmdMostDerived)
        {
            if (m_pmdMostDerived->m_szInterfaceName)
            {
                *pwszInterface = ToUnicode(m_pmdMostDerived->m_szInterfaceName);
                if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
            }
        }
        else if (m_iid == __uuidof(IDispatch))
        {
            *pwszInterface = CopyString(L"IDispatch");
            if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDMETHODIMP LEGACY_INTERCEPTOR::GetMethodInfo(ULONG iMethod, CALLFRAMEINFO * pinfo, LPWSTR* pwszMethodName)
{
    HRESULT hr = S_OK;

    ASSERT(pinfo);
    Zero(pinfo);
    if (pwszMethodName) *pwszMethodName = NULL;

    if (m_pmdMostDerived)
    {
        pinfo->iid     = *m_pmdMostDerived->m_pHeader->piid;
        pinfo->cMethod =  m_pmdMostDerived->m_pHeader->DispatchTableCount;
        //
        ASSERT(pinfo->cMethod >= m_cMethods);   // can never have too many asserts!
    }
    else
    {
        pinfo->iid     = m_iid;
        pinfo->cMethod = m_cMethods;
    }
    pinfo->iMethod = iMethod;
    
    if (m_iid == __uuidof(IDispatch))
    {
        pinfo->fDerivesFromIDispatch = TRUE;

        switch (iMethod)
        {
        case IMETHOD_GetTypeInfoCount:
            pinfo->fHasOutValues         = TRUE;
            if (pwszMethodName) *pwszMethodName = CopyString(L"GetTypeInfoCount");
            break;

        case IMETHOD_GetTypeInfo: 
            pinfo->fHasInValues          = TRUE;
            pinfo->fHasOutValues         = TRUE;
            pinfo->cOutInterfacesMax     = 1;
            if (pwszMethodName) *pwszMethodName = CopyString(L"GetTypeInfo");
            break;

        case IMETHOD_GetIDsOfNames:
            pinfo->fHasInValues          = TRUE;
            pinfo->fHasOutValues         = TRUE;
            if (pwszMethodName) *pwszMethodName = CopyString(L"GetIDsOfNames");
            break;

        case IMETHOD_Invoke:
            pinfo->fHasInValues            = TRUE; // dispIdMember, riid, lcid, wFlags
            pinfo->fHasInOutValues         = TRUE; // dispParams
            pinfo->fHasOutValues           = TRUE; // pVarResult, pExcepInfo, puArgErr
            pinfo->cInInterfacesMax        = -1;   // an unbounded number of them can be in dispparams
            pinfo->cInOutInterfacesMax     = -1;   // an unbounded number of them can be in dispparams
            pinfo->cOutInterfacesMax       = -1;   // an unbounded number of them can be in pVarResult
            if (pwszMethodName) *pwszMethodName = CopyString(L"Invoke");
            break;

        default:
            NOTREACHED();
            hr = E_INVALIDARG;
            break;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (!hr && pwszMethodName && *pwszMethodName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (!!hr && pwszMethodName)
    {
        FreeMemory(*pwszMethodName);
        *pwszMethodName = NULL;
    }

    return hr;
} //end GetMethodInfo

HRESULT LEGACY_FRAME::GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod)
{
    HRESULT hr = S_OK;

    if (pwszInterface)
    {
        hr = m_pInterceptor->GetIID((IID*)NULL, (BOOL*)NULL, (ULONG*)NULL, pwszInterface);
    }

    if (pwszMethod)
    {
        if (!hr)
        {
            CALLFRAMEINFO info;
            hr = m_pInterceptor->GetMethodInfo(m_iMethod, &info, pwszMethod);
        }
        else
            *pwszMethod = NULL;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
// ICallInterceptor
//
///////////////////////////////////////////////////////////////////

STDMETHODIMP LEGACY_INTERCEPTOR::RegisterSink(ICallFrameEvents* psink)
{
    HRESULT hr = S_OK;
    ::Set(m_psink, psink);
    return hr;
}
        
STDMETHODIMP LEGACY_INTERCEPTOR::GetRegisteredSink(ICallFrameEvents ** ppsink)
{
    ::Set(*ppsink, m_psink);
    return (m_psink ? S_OK : CO_E_OBJNOTREG); 
}

STDMETHODIMP DISPATCH_INTERCEPTOR::Unmarshal( 
    ULONG                       iMethod,
    PVOID                       pBuffer,
    ULONG                       cbBuffer,
    BOOL                        fForceCopyBuffer,
    RPCOLEDATAREP               dataRep,
    CALLFRAME_MARSHALCONTEXT *  pcontext,
    ULONG *                     pcbUnmarshalled,
    ICallFrame **               ppFrame)
// Unmarshal in-parameters to create a new call frame
{
    HRESULT hr = S_OK;
    *ppFrame = NULL;
    //
    // Ask our remote interceptor to cons us up a new frame from the remote invocation
    //
    DISPATCH_SERVER_FRAME* pNewFrame = NULL;
    //
    ICallUnmarshal* punmarshal;
    hr = QI(m_premoteInterceptor, punmarshal);
    if (!hr)
    {
        ICallFrame* premoteFrame;
        hr = punmarshal->Unmarshal(iMethod, pBuffer, cbBuffer, fForceCopyBuffer, dataRep, pcontext, pcbUnmarshalled, &premoteFrame);
        if (!hr)
        {
            // Got the remote frame into memory. Wrap in a DISPATCH_FRAME
            //
            PVOID pvArgsRemote = premoteFrame->GetStackLocation();

            pNewFrame = new DISPATCH_SERVER_FRAME(NULL, iMethod, pvArgsRemote, this);
            if (pNewFrame)  
            {
                ::Set(pNewFrame->m_premoteFrame, premoteFrame);
                //
                // Always make sure that these things are initialized
                //
                if (iMethod == IMETHOD_Invoke)
                {
                    hr = pNewFrame->StubPreCheck();
                }
            }
            else
                hr = E_OUTOFMEMORY;

            ::Release(premoteFrame);
        }
        ::Release(punmarshal);
    }

    if (!hr)
    {
        hr = QI(pNewFrame, *ppFrame);
        ::Release(pNewFrame);
    }

    return hr;
}

        
STDMETHODIMP LEGACY_INTERCEPTOR::ReleaseMarshalData( 
    ULONG                       iMethod,
    PVOID                       pBuffer,
    ULONG                       cbBuffer,
    ULONG                       ibFirstRelease,
    RPCOLEDATAREP               dataRep,
    CALLFRAME_MARSHALCONTEXT *  pcontext)
{
    HRESULT hr = S_OK;
    NYI(); hr = E_NOTIMPL;
    return hr;
}

//////////////////////////////////////////////////////////


HRESULT LEGACY_INTERCEPTOR::GetInternalInterceptor(REFIID iid, ICallInterceptor** ppInterceptor)
{
    HRESULT hr = S_OK;
    *ppInterceptor = NULL;

    // Get an oicf-driven interceptor that we can delegate to as we need
    //
    Interceptor* pnew = new Interceptor(NULL);
    if (pnew)
    {
        // Set it's proxy-file-list by hand; in the normal case, this is
        // done by its class factory. See ComPsClassFactory::CreateInstance.
        //
        pnew->m_pProxyFileList = CallFrameInternal_aProxyFileList;

        IUnkInner* pme = (IUnkInner*)pnew;
        if (hr == S_OK)
        {
            hr = pme->InnerQueryInterface(__uuidof(**ppInterceptor), (void**)ppInterceptor);
            if (!hr)
            {
                // If we got the interceptor, then initialize it with the right IID
                //
                IInterfaceRelated* prelated;
                hr = QI(*ppInterceptor, prelated);
                if (!hr)
                {
                    hr = prelated->SetIID(iid);
                    //
                    // We only tolerate one error.. out of memory.  Anything else is a bad failure
                    // on our part.
                    if (hr != E_OUTOFMEMORY)
                    {
                        ASSERT(!hr);
                    }
                    prelated->Release();
                }
                //
                // Set up ourselves as the sink for this guy, being careful not to create a refcnt cycle
                //
                if (!hr)
                {
                    ICallFrameEvents* psink = (ICallFrameEvents*)this;
                    hr = (*ppInterceptor)->RegisterSink(psink);
                    if (!hr)
                    {
                        psink->Release();
                    }
                }
            }
        }
        pme->InnerRelease();                // balance starting ref cnt of one    
    }
    else 
        hr = E_OUTOFMEMORY;

    return hr;
}

STDMETHODIMP LEGACY_INTERCEPTOR::SetIID(REFIID iid)
{
    HRESULT hr = S_OK;

    ReleaseRemoteInterceptor();
    ReleaseMemoryInterceptor();
    //
    if (!hr)
    {
        hr = GetInternalInterceptor(iid, &m_premoteInterceptor);
        if (!hr)
        {
            m_fRegdWithRemoteInterceptor = TRUE;
        }
    }
    
    return hr;
}

STDMETHODIMP DISPATCH_INTERCEPTOR::SetIID(REFIID iid)
{
    HRESULT hr = LEGACY_INTERCEPTOR::SetIID(iid);
    if (!hr)
    {
        // Set our IID and method count.
        //
        if (iid == IID_IDispatch)
        {
            m_iid      = iid;
            m_cMethods = IMETHOD_DISPATCH_MAX;

            hr = GetInternalInterceptor(__uuidof(IDispatch_In_Memory), &m_pmemoryInterceptor);
            if (!hr)
            {
                m_fRegdWithMemoryInterceptor = TRUE;
            }
        }
        else
            hr = E_NOINTERFACE;
    }

    return hr;
}

/////////////////
        
STDMETHODIMP LEGACY_INTERCEPTOR::GetIID(IID* piid)
{
    if (piid) *piid = m_iid;
    return S_OK;
}

//////////////////////////////////////////////////////////

STDMETHODIMP LEGACY_INTERCEPTOR::InnerQueryInterface (REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown)               { *ppv = (IUnkInner*) this; }
  
    else if ((iid == __uuidof(ICallIndirect)) || (iid == __uuidof(ICallInterceptor)))
    {
        *ppv = (ICallInterceptor *) this;
    }
    else if (iid == __uuidof(IInterfaceRelated))   { *ppv = (IInterfaceRelated*) this; }
    else if (iid == __uuidof(ICallUnmarshal))      { *ppv = (ICallUnmarshal*)    this; }
    else if (iid == __uuidof(ICallFrameEvents))    { *ppv = (ICallFrameEvents*)  this; }
    else if (iid == __uuidof(IInterceptorBase))    { *ppv = (IInterceptorBase*)  this; }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP DISPATCH_INTERCEPTOR::InnerQueryInterface(REFIID iid, void ** ppv)
{
    if (iid == __uuidof(IDispatch))
    {
        *ppv = (IDispatch*) this;
    }
    else
        return LEGACY_INTERCEPTOR::InnerQueryInterface(iid, ppv);

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Our pool of allocated call frames. We keep dead shells around so that they can quickly
// be allocated w/o taking any locks.

IFastStack<DISPATCH_CLIENT_FRAME>* 
DedicatedAllocator<DISPATCH_CLIENT_FRAME,PagedPool>::g_pStack;

IFastStack<DISPATCH_SERVER_FRAME>* 
DedicatedAllocator<DISPATCH_SERVER_FRAME,PagedPool>::g_pStack;

BOOL InitLegacy()
{
        BOOL fOK = FALSE;

        if (DedicatedAllocator<DISPATCH_CLIENT_FRAME,PagedPool>::g_pStack 
                = DedicatedAllocator<DISPATCH_CLIENT_FRAME,PagedPool>::CreateStack())
        {
                if (DedicatedAllocator<DISPATCH_SERVER_FRAME,PagedPool>::g_pStack 
                        = DedicatedAllocator<DISPATCH_SERVER_FRAME,PagedPool>::CreateStack())
                {
                        fOK = TRUE;
                }
                else
                {
                        DedicatedAllocator<DISPATCH_CLIENT_FRAME,PagedPool>::DeleteStack();
                }
        }

        return fOK;
}

extern "C"
void ShutdownCallFrame()
// Support for making PrintMemoryLeaks more intelligent
{
    DedicatedAllocator<CallFrame,              PagedPool>::DeleteStack();
    DedicatedAllocator<DISPATCH_CLIENT_FRAME,  PagedPool>::DeleteStack();
    DedicatedAllocator<DISPATCH_SERVER_FRAME,  PagedPool>::DeleteStack();
        
    FreeTypeInfoCache();
        
    FreeMetaDataCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\cleginterface.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft COM Plus (Microsoft Confidential)

 @doc
 @module CLegInterface.H : Header file for the supporting interceptor for 
    legacy interfaces
 
 Description:<nl>
 
-------------------------------------------------------------------------------
Revision History:

 @rev 0     | 04/30/98 | Gaganc  | Created
 @rev 1     | 07/17/98 | BobAtk  | Cleaned, fixed leaks etc
---------------------------------------------------------------------------- */
#ifndef __CLEGINTERFACE_H_
#define __CLEGINTERFACE_H_

#include "CallFrameInternal.h"

struct LEGACY_INTERCEPTOR;
struct LEGACY_FRAME;

struct DISPATCH_INTERCEPTOR;
struct DISPATCH_FRAME;
struct DISPATCH_CLIENT_FRAME;
struct DISPATCH_SERVER_FRAME;


////////////////////////////////////////////////////////////////////////////////////////
//
// An interceptor for legacy interfaces
//
struct LEGACY_INTERCEPTOR : ICallInterceptor,
                            ICallUnmarshal,
                            IInterfaceRelated,
                            ICallFrameEvents,
                            IInterceptorBase,
                            IDispatch,
                            IUnkInner
    {
    ///////////////////////////////////////////////////////////////////
    //
    // state
    //
    ///////////////////////////////////////////////////////////////////

    ICallFrameEvents*           m_psink;
    IID                         m_iid;
    ULONG                       m_cMethods;
                                
    XLOCK_LEAF                  m_frameLock;
    ICallFrame**                m_ppframeCustomer;
    //
    // An interceptor that dispenses frames that understand the wire-format variation
    // of methods in this interface. A difference between the in-memory and wire variations
    // arises through the use of [call_as] attribution on methods.
    //
    ICallInterceptor*           m_premoteInterceptor;
    BOOL                        m_fRegdWithRemoteInterceptor;
    //
    // An interceptor that dispenses frames that actually understand the in-memory call
    // stack representation of our interface's methods, as opposed to the wire-rep call stack.
    // 
    ICallInterceptor*           m_pmemoryInterceptor;
    BOOL                        m_fRegdWithMemoryInterceptor;
    //
    // Support for being a base interceptor
    //
    MD_INTERFACE*               m_pmdMostDerived;       // If we're a base, then the most derived interface that we actually service

#ifdef DBG
    ULONG                       m_signature;
#endif


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    LEGACY_INTERCEPTOR(IUnknown * punkOuter);
    virtual ~LEGACY_INTERCEPTOR();
    HRESULT Init();
    
    ///////////////////////////////////////////////////////////////////
    //
    // IInterceptorBase
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetAsBaseFor(MD_INTERFACE* pmdMostDerived, BOOL* pfDerivesFromIDispatch)
        {
        ASSERT(pmdMostDerived);
        ::Set(m_pmdMostDerived, pmdMostDerived);
        *pfDerivesFromIDispatch = FALSE;
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP CallIndirect   (HRESULT * phReturn, ULONG iMethod, void* pvArgs, ULONG* pcbArgs);
    STDMETHODIMP GetStackSize   (ULONG iMethod, ULONG* pcbArgs);
    STDMETHODIMP GetIID         (IID * piid, BOOL* pfDerivesFromIDispatch, ULONG* pcMethod, LPWSTR* pwszInterfaceName);
    STDMETHODIMP GetMethodInfo  (ULONG iMethod, CALLFRAMEINFO* pinfo, LPWSTR* pwszMethodName);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallInterceptor
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP RegisterSink       (ICallFrameEvents * psink);
    STDMETHODIMP GetRegisteredSink  (ICallFrameEvents ** ppsink);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallUnmarshal
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP ReleaseMarshalData
                ( 
                ULONG                       iMethod,
                PVOID                       pBuffer,
                ULONG                       cbBuffer,
                ULONG                       ibFirstRelease,
                RPCOLEDATAREP               dataRep,
                CALLFRAME_MARSHALCONTEXT *  pcontext
                );

    ///////////////////////////////////////////////////////////////////
    //
    // IInterfaceRelated
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP SetIID     (REFIID iid);
    STDMETHODIMP GetIID     (IID * piid);

    ///////////////////////////////////////////////////////////////////
    //
    // IDispatch
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo);
    STDMETHODIMP GetIDsOfNames(REFIID     riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId);
    STDMETHODIMP GetIDsOfNames(const IID* piid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId);
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pDispParams,
                        VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr);
#if defined(_IA64_)                        
    STDMETHODIMP GenericCall(ULONG iMethod, ...);
#endif    

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;
    BOOL        m_fShuttingDown;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0 || m_fShuttingDown); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { if (!m_fShuttingDown) { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;} else return 0; }

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrameEvents
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL OnCall(ICallFrame*);

    ///////////////////////////////////////////////////////////////////
    //
    // Utilities
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT GetRemoteFrameFor(ICallFrame**, LEGACY_FRAME* pFrame);
    HRESULT GetMemoryFrameFor(ICallFrame**, LEGACY_FRAME* pFrame); 

    void ReleaseRemoteInterceptor()
        {
        if (m_fRegdWithRemoteInterceptor)
            {
            m_fRegdWithRemoteInterceptor = FALSE;
            ((ICallFrameEvents*)this)->AddRef();
            }
        ::Release(m_premoteInterceptor);
        }
   
    void ReleaseMemoryInterceptor()
        {
        if (m_fRegdWithMemoryInterceptor)
            {
            m_fRegdWithMemoryInterceptor = FALSE;
            ((ICallFrameEvents*)this)->AddRef();
            }
        ::Release(m_pmemoryInterceptor);
        }

    HRESULT GetInternalInterceptor(REFIID iid, ICallInterceptor** ppInterceptor);
    };


struct DISPATCH_INTERCEPTOR : public LEGACY_INTERCEPTOR
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend class GenericInstantiator<DISPATCH_INTERCEPTOR>;

public:
    DISPATCH_INTERCEPTOR(IUnknown * punkOuter = NULL) : LEGACY_INTERCEPTOR(punkOuter)
        {
        }

    ~DISPATCH_INTERCEPTOR()
        {
        }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallUnmarshal
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP Unmarshal
                ( 
                ULONG                       iMethod,
                PVOID                       pBuffer,
                ULONG                       cbBuffer,
                BOOL                        fForceCopyBuffer,
                RPCOLEDATAREP               dataRep,
                CALLFRAME_MARSHALCONTEXT *  pcontext,
                ULONG *                     pcbUnmarshalled,
                ICallFrame **               ppFrame
                );

    ///////////////////////////////////////////////////////////////////
    //
    // IInterceptorBase
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetAsBaseFor(MD_INTERFACE* pmdMostDerived, BOOL* pfDerivesFromIDispatch)
        {
        LEGACY_INTERCEPTOR::SetAsBaseFor(pmdMostDerived, pfDerivesFromIDispatch);
        //
        *pfDerivesFromIDispatch = TRUE;
        //
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // IInterfaceRelated
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetIID(REFIID iid);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP GetStackSize   (ULONG iMethod, ULONG* pcbArgs);
    };



////////////////////////////////////////////////////////////////////////////////////////
//
// A hand-coded call frame. For now, just IDispatch. Later, will subclass and
// factor for other interfaces.
//
struct LEGACY_FRAME : IUnkInner, public ICallFrame, public CAREFUL_MEMORY_READER_WRITER
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    PVOID                   m_pvArgs;
    const ULONG             m_iMethod;

    REGISTER_TYPE           m_hrReturnValue;
    LEGACY_INTERCEPTOR*     m_pInterceptor;
    ICallFrame*             m_premoteFrame;
    ICallFrame*             m_pmemoryFrame;
    BOOL                    m_fAfterCall;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend struct DISPATCH_FRAME;
    friend struct DISPATCH_INTERCEPTOR;

    friend struct LEGACY_INTERCEPTOR;

    LEGACY_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor)
            : m_iMethod(iMethod)
        {
        m_refs              = 1;            // nb starts at one
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pInterceptor      = pinterceptor;
        m_premoteFrame      = NULL;
        m_pmemoryFrame      = NULL;
        m_fAfterCall        = FALSE;

        m_pInterceptor->AddRef();

        SetStackLocation(pvArgs);
        }

protected:
    virtual ~LEGACY_FRAME()
        {
        ::Release(m_pmemoryFrame);
        ::Release(m_premoteFrame);
        m_pInterceptor->Release();
        }
public:

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetInfo(CALLFRAMEINFO *pInfo);
//  HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*) = 0;
    PVOID   STDCALL GetStackLocation()
        {
        return m_pvArgs;
        }
    void    STDCALL SetStackLocation(PVOID pvArgs)
        {
        m_pvArgs = pvArgs;
        SetFromUser(m_pvArgs);
        }
//  HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded) = 0;
//  HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
//                                  ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags) = 0;
//  HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled) = 0;
//  HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx) = 0;
//  HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags) = 0;

    void STDCALL SetReturnValue(HRESULT hrReturnValue)
        { 
        m_hrReturnValue = hrReturnValue;
        }
    HRESULT STDCALL GetReturnValue()
        { 
        return (HRESULT)m_hrReturnValue;
        }

//  HRESULT STDCALL Invoke(void *pvReceiver, ...) = 0;
//  HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame) = 0;
//  HRESULT STDCALL WalkFrame(BOOLEAN fIn, GUID*pguidTag, ICallFrameWalker *pWalker) = 0;

    HRESULT STDCALL GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    ///////////////////////////////////////////////////////////////////
    //
    // Utilties
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT GetRemoteFrame();
    HRESULT GetMemoryFrame();
    };


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// Meta data about methods in particular interfaces. This will have to change for 64 bit.
//
#include "IDispatchInfo.h"


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////


#include "DispatchFrame.h"


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// Support for spilling and getting access to stack frames. Easy on x86, trickier on Alpha.
// All this will have to change for 64 bit.
//

#if defined(_AMD64_) || defined(_X86_)

    #define INTERCEPT_CALL(firstNonThisParam, lastParam, iMethod)                               \
        const void* pvArgs = reinterpret_cast<const BYTE*>(&firstNonThisParam) - sizeof(PVOID); \
        ULONG cbArgs;                                                                           \
        HRESULT hrReturn;                                                                       \
        CallIndirect(&hrReturn, iMethod, const_cast<void*>(pvArgs), &cbArgs);                   \
        return hrReturn;                                                                        

#endif

#if defined(_IA64_)

    #define INTERCEPT_CALL(firstNonThisParam, lastParam, iMethod)                               \
                va_list va;                                                                                                                                                     \
                va_start(va, lastParam);                                                                                                                \
                                                                                                \
        const void* pvArgs = reinterpret_cast<const BYTE*>(&firstNonThisParam) - sizeof(PVOID); \
        ULONG cbArgs;                                                                           \
        HRESULT hrReturn;                                                                       \
        CallIndirect(&hrReturn, iMethod, const_cast<void*>(pvArgs), &cbArgs);                   \
        return hrReturn;                                                                        

#endif

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//

inline void FRAME_RemoteInvoke::CopyTo(FRAME_Invoke& him) const
    {
    him.CopyFrom(*this);
    }
inline void FRAME_Invoke::CopyTo(FRAME_RemoteInvoke& him) const
    {
    him.CopyFrom(*this);
    }

inline void FRAME_Invoke::CopyFrom(const FRAME_RemoteInvoke& him)
    {
    This            = him.This;
    dispIdMember    = him.dispIdMember;
    piid            = him.piid;
    lcid            = him.lcid;
    wFlags          = LOWORD(him.dwFlags);
    pDispParams     = him.pDispParams;
    pVarResult      = him.pVarResult;
    pExcepInfo      = him.pExcepInfo;
    puArgErr        = him.puArgErr;
    }

inline void FRAME_RemoteInvoke::CopyFrom(const FRAME_Invoke& him)
    {
    This            = him.This;
    dispIdMember    = him.dispIdMember;
    piid            = him.piid;
    lcid            = him.lcid;
    dwFlags         = him.wFlags;
    pDispParams     = him.pDispParams;
    pVarResult      = him.pVarResult;
    pExcepInfo      = him.pExcepInfo;
    puArgErr        = him.puArgErr;
    cVarRef         = 0;
    rgVarRefIdx     = NULL;
    rgVarRef        = NULL;
    }


#endif __CLEGINTERFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\callframeworker.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrameWorker.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "typeinfo.h"

#ifdef DBG

#define ThrowIfError(hr)    ThrowIfError_(hr, __FILE__, __LINE__)

void ThrowIfError_(HRESULT hr, LPCSTR szFile, ULONG iline)
{
    if (!!hr) Throw_(hr, TAG, szFile, iline);
}

#else

void ThrowIfError(HRESULT hr)
{
    if (!!hr) Throw(hr);
}

#endif

//
// Alignment macros.
//
#ifndef _WIN64
#define ALIGNED_VALUE(pStuff, cAlign)           ((uchar *)((ulong)((pStuff) + (cAlign)) & ~ (cAlign)))
#else
#define ALIGNED_VALUE(pStuff, cAlign)           ((uchar *)((ULONGLONG)((pStuff) + (cAlign)) & ~ (cAlign)))
#endif


///////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// See rpc's attack.h
#define NDR_CORR_EXTENSION_SIZE 2

#define CORRELATION_DESC_INCREMENT( pFormat ) \
            if ( m_pmd && m_pmd->m_pHeaderExts && m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc) \
                   pFormat += NDR_CORR_EXTENSION_SIZE;

#ifndef LOW_NIBBLE
#define LOW_NIBBLE(Byte)            (((unsigned char)Byte) & 0x0f)
#endif

#ifndef HIGH_NIBBLE
#define HIGH_NIBBLE(Byte)           (((unsigned char)Byte) >> 4)
#endif

void CallFrame::CopyWorker(BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
// Copy from the indicated source location to the destination location, allocating
// if requested. Source and destination pointers are to be considered not yet probed.
// 
{
    switch (*pFormat)
    {
        /////////////////////////////////////////////////////////////////////
        //
        // Pointers
        //
        // In the future, we can be more clever here about sharing with our
        // source data than we are. For example, we could take advantage of the
        // ALLOCED_ON_STACK information that MIDL emits. For the moment, that 
        // would complicate things beyond their worth, however.
        //
        /////////////////////////////////////////////////////////////////////
    case FC_RP: // ref pointer
        if (NULL == pMemoryFrom)
        {
            Throw(RPC_NT_NULL_REF_POINTER);
        }
        //
        // Fall through
        //
    case FC_UP: // unique pointer
    case FC_OP: // a unique pointer, which is not the top most pointer, in a COM interface, 
    {
        if (NULL == pMemoryFrom)
        {
            ZeroDst(ppMemoryTo, sizeof(void*));
            return;
        }
        //
        // Make the "must allocate" decision
        //
        BOOL fPointeeAlloc;
        if (m_fPropogatingOutParam)
        {
            ASSERT(m_fWorkingOnOutParam);
            PVOID pvPointee = *(PVOID*)ppMemoryTo;
            fPointeeAlloc = (pvPointee == NULL) || fMustAlloc;
        }
        else
        {
            fPointeeAlloc = TRUE;
        }
        //
        BYTE bPointerAttributes = pFormat[1];
        if (SIMPLE_POINTER(bPointerAttributes))
        {
            // It's a pointer to a simple type or a string pointer. Either way, just recurse to copy
            //
            CopyWorker(pMemoryFrom, ppMemoryTo, &pFormat[2], fPointeeAlloc);
        }
        else
        {
            // It's a more complex pointer type
            //
            PFORMAT_STRING pFormatPointee = pFormat + 2;
            pFormatPointee += *((signed short *)pFormatPointee);
            //
            // We don't handle [allocate] attributes in this implementation
            //
            //if (ALLOCATE_ALL_NODES(bPointerAttributes) || DONT_FREE(bPointerAttributes)) ThrowNYI();

            if (FIndirect(bPointerAttributes, pFormatPointee, TRUE))
            {
                if (fPointeeAlloc)
                {
                    PVOID pv = m_pAllocatorFrame->Alloc(sizeof(PVOID), m_fWorkingOnOutParam); // guarantees to return a safe buffer
                    Zero(pv, sizeof(PVOID));                                                // null out that buffer
                    DerefStoreDst(((PVOID*)ppMemoryTo), pv);
                }
                ppMemoryTo  = DerefDst((PBYTE**)ppMemoryTo);              // ppMemoryTo  = *(PBYTE**)ppMemoryTo;
                pMemoryFrom = DerefSrc((PBYTE*)pMemoryFrom);              // pMemoryFrom = *(PBYTE*)pMemoryFrom;
            }
            CopyWorker(pMemoryFrom, ppMemoryTo, pFormatPointee, fPointeeAlloc);
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Copying interface Pointers
    //
    /////////////////////////////////////////////////////////////////////
    case FC_IP:
    {
        // Copy the binary value of the interface pointer over. Do it carefully.
        //
        LPUNKNOWN   punkFrom = (LPUNKNOWN) pMemoryFrom;
        LPUNKNOWN* ppunkTo   = (LPUNKNOWN*)ppMemoryTo;
        //
        TestWriteDst(ppunkTo, sizeof(LPUNKNOWN));
        memcpy(ppunkTo, &punkFrom, sizeof(LPUNKNOWN));
        //
        // Figure out the IID and call the walker if there is one. If there's no
        // walker, then just AddRef the pointer.
        //
        if (m_pWalkerCopy)
        {
            IID* pIID;

            if (pFormat[1] == FC_CONSTANT_IID)
            {
                pIID = (IID*)&pFormat[2];
            }
            else
            {
                pIID = (IID *)ComputeConformance(pMemoryFrom, pFormat, TRUE);
                if (NULL == pIID)
                    Throw(STATUS_INVALID_PARAMETER);
            }

            IID iid;
            CopyMemory(&iid, pIID, sizeof(IID));
            ThrowIfError(m_pWalkerCopy->OnWalkInterface(iid, (PVOID*)ppunkTo, m_fWorkingOnInParam, m_fWorkingOnOutParam));
        }
        else
        {
            // There is no walker. Just do an AddRef. But only do that if object
            // appears to be in same space as us: a sanity check, not a security
            // safeguard.
            //
            if (punkFrom)
            {
                punkFrom->AddRef();
            }
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Simple structs
    //
    /////////////////////////////////////////////////////////////////////
    case FC_STRUCT:
    case FC_PSTRUCT:
    {
        if (NULL == pMemoryFrom)
        {
            Throw(RPC_NT_NULL_REF_POINTER);
        }

        ULONG cbStruct = (ULONG) *((ushort *)(&pFormat[2]));
        //
        // If the destination is already pointing to something, then use that rather
        // than allocating. One case of this is that of by-value structures on the stack.
        //
        BYTE* pbStruct = DerefDst(ppMemoryTo);
        if (NULL == pbStruct || fMustAlloc)
        {
            pbStruct = (BYTE*) m_pAllocatorFrame->Alloc(cbStruct, m_fWorkingOnOutParam);
            DerefStoreDst(ppMemoryTo, pbStruct);
        }

        CopyToDst(pbStruct, pMemoryFrom, cbStruct);
        if (*pFormat == FC_PSTRUCT)
        {
            CopyEmbeddedPointers(pMemoryFrom, pbStruct, &pFormat[4], fMustAlloc);
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Conformant strings
    //
    /////////////////////////////////////////////////////////////////////
    case FC_C_CSTRING:  // ascii string
    case FC_C_WSTRING:  // unicode string
    {
        SIZE_T cbCopy;
        SIZE_T cbAlloc;

        if (pFormat[1] == FC_STRING_SIZED)
        {
            // A sized string. Not presently implemented, though that's just out of laziness.
            ThrowNYI();
        }
        else
        {
            // An unsized string; that is, a NULL-terminated string.
            //
            // Computing the length may read random junk in memory, but as that is just reading, that's 
            // ok for now. Actual probing is done in the copy below.
            //
            switch (*pFormat)
            {
            case FC_C_CSTRING:  cbCopy =  strlen((LPSTR)pMemoryFrom)  + 1;                  break;
            case FC_C_WSTRING:  cbCopy = (wcslen((LPWSTR)pMemoryFrom) + 1) * sizeof(WCHAR); break;
            }
            cbAlloc = cbCopy;
        }

        PVOID pvNew = m_pAllocatorFrame->Alloc(cbAlloc, m_fWorkingOnOutParam);
        DerefStoreDst(ppMemoryTo, (BYTE*)pvNew);
        CopyToDst(pvNew, pMemoryFrom, (ULONG)cbCopy);
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Simple Types
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CHAR:
    case FC_BYTE:
    case FC_SMALL:
    case FC_WCHAR:
    case FC_SHORT:
    case FC_LONG:
    case FC_HYPER:
    case FC_ENUM16:
    case FC_ENUM32:
    case FC_DOUBLE:
    case FC_FLOAT:
    case FC_INT3264:
    case FC_UINT3264:
    {
        ULONG cb = SIMPLE_TYPE_MEMSIZE(*pFormat);
        BYTE* pMemoryTo = DerefDst(ppMemoryTo);
        if (fMustAlloc || NULL == pMemoryTo)
        {
            pMemoryTo = (BYTE*)m_pAllocatorFrame->Alloc(cb, m_fWorkingOnOutParam);
            DerefStoreDst(ppMemoryTo, pMemoryTo);
        }
        CopyToDst(pMemoryTo, pMemoryFrom, cb);
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Fixed sized arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        ULONG cbArray;
        if (*pFormat == FC_SMFARRAY)
        {
            pFormat += 2;               // skip code and alignment
            cbArray = *(ushort*)pFormat;
            pFormat += sizeof(ushort);
        }
        else // FC_LGFARRAY
        {
            pFormat += 2;
            cbArray = *(ulong UNALIGNED*)pFormat;
            pFormat += sizeof(ulong);
        }

        BYTE* pbArray = DerefDst(ppMemoryTo);
        if (!fMustAlloc && pbArray) 
        { /* nothing to do */ }
        else
        {
			pbArray = (BYTE*) m_pAllocatorFrame->Alloc(cbArray, m_fWorkingOnOutParam);
            DerefStoreDst(ppMemoryTo, pbArray);
        }

        CopyToDst(pbArray, pMemoryFrom, cbArray);

        if (*pFormat == FC_PP)
        {
            CopyEmbeddedPointers(pMemoryFrom, DerefDst(ppMemoryTo), pFormat, fMustAlloc);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Copying Conformant arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CARRAY:
    {
        ULONG count = (ULONG)ComputeConformance(pMemoryFrom, pFormat, TRUE);
        ASSERT(count == m_MaxCount);

        SIZE_T cbAlloc = m_MaxCount *   *((ushort*)(pFormat+2));

        BYTE* pArray = DerefDst(ppMemoryTo);
        if (!fMustAlloc && pArray) 
        { /* nothing to allocate */ }
        else
        {
            if (cbAlloc > 0)
            {
                pArray = (BYTE*)m_pAllocatorFrame->Alloc(cbAlloc, m_fWorkingOnOutParam);
				if (pArray == NULL)
					ThrowHRESULT(E_OUTOFMEMORY);
                Zero(pArray, cbAlloc);
            }
            else
                pArray = 0;                
        }

        DerefStoreDst(ppMemoryTo, pArray);
        
        if (pArray)
        {
            CopyConformantArrayPriv(pMemoryFrom, ppMemoryTo, pFormat, fMustAlloc);
        }
    
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Really hard arrays. These are arrays that do not fall into any of
    // the other more simple categories. See also NdrpComplexArrayMarshall
    // and NdrpComplexArrayUnmarshall.
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_ARRAY:
    {
        ARRAY_INFO*     pArrayInfoStart = m_pArrayInfo;
        PFORMAT_STRING  pFormatStart    = pFormat;

        __try
        {
            // Initialize m_pArrayInfo if necessary
            //
            ARRAY_INFO arrayInfo;
            if (NULL == m_pArrayInfo)
            {
                m_pArrayInfo = &arrayInfo;
                Zero(&arrayInfo);
            }
            const LONG dimension = m_pArrayInfo->Dimension;
            //
            // Get the array's alignment
            //
            const BYTE alignment = pFormat[1];
            pFormat += 2;
            //
            // Get the number of elements (0 if the array has conformance)
            //
#ifndef _WIN64
            ULONG cElements = *(USHORT*)pFormat;
#else
            ULONGLONG cElements = *(USHORT*)pFormat;
#endif
            pFormat += sizeof(USHORT);
            //
            // Check for conformance description
            //
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                cElements = ComputeConformance(pMemoryFrom, pFormatStart, TRUE);
            }

            pFormat += 4;
		    CORRELATION_DESC_INCREMENT( pFormat );

            //
            // Check for variance description
            //
            ULONG offset;
            ULONG count;
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
			{
                ComputeVariance(pMemoryFrom, pFormatStart, &offset, &count, TRUE);
			}
            else
			{
                offset = 0;
#ifndef _WIN64
                count  = cElements;
#else
                count  = (ULONG)cElements;
#endif
			}
			pFormat += 4;
			CORRELATION_DESC_INCREMENT( pFormat );

            /////////////////////////////////////////////////
            //
            // Compute the size of each element in the array
            //
            ULONG cbElement;
            //
            BYTE bFormat = pFormat[0];
            switch (bFormat)
			{
            case FC_EMBEDDED_COMPLEX:
            {
                pFormat += 2;
                pFormat += *((signed short *)pFormat);
                //
                m_pArrayInfo->Dimension = dimension + 1;
                cbElement = PtrToUlong(MemoryIncrement(pMemoryFrom, pFormat, TRUE)) - PtrToUlong(pMemoryFrom);
                break;
            }

            case FC_RP: 
			case FC_UP: 
			case FC_FP: 
			case FC_OP:
            case FC_IP:
            {
                cbElement = PTR_MEM_SIZE;
                break;
            }

            case FC_ENUM16:
            {
				cbElement = sizeof(int);
                for (ULONG i = 0 ; i < count; i++)
                {
                    int element = DerefSrc( (int*)pMemoryFrom + i );
                    if (element & ~((int)0x7FFF))
                    {
                        Throw(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
                    }
                }
                break;
            }

            default:
                ASSERT(IS_SIMPLE_TYPE(pFormat[0]));
                cbElement = SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                break;
            }

            /////////////////////////////////////////////////
            //
            // Allocate and initialize the destination array
            //
            ULONG cbArray = (ULONG)cElements * (ULONG)cbElement;
            ULONG cbValid =     count * cbElement;
            //
            BYTE* pMemoryTo = DerefDst(ppMemoryTo);
            if (fMustAlloc || NULL == pMemoryTo)
            {
                pMemoryTo = (BYTE*)m_pAllocatorFrame->Alloc(cbArray, m_fWorkingOnOutParam);
				if (pMemoryTo == NULL)
					ThrowHRESULT(E_OUTOFMEMORY);
                DerefStoreDst(ppMemoryTo, pMemoryTo);
            }
            ZeroDst(pMemoryTo, cbArray);

            /////////////////////////////////////////////////
            //
            // Adjust source and destination pointers to the start of the variance, if any
            //
            pMemoryFrom += offset * cbElement;
            pMemoryTo   += offset * cbElement;

            /////////////////////////////////////////////////
            //
            // Actually do the copying of the array
            //
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                BOOL fIsArray = IS_ARRAY_OR_STRING(pFormat[0]);
                if (!fIsArray)
                {
                    m_pArrayInfo = NULL;
                }
                //
                // Do it element by element
                //
                if (FC_IP == pFormat[0])
                {
                    for (ULONG i = 0; i < count ; i++)
                    {
                        // Keep track of multidimensional array information
                        //
                        if (fIsArray)
                        {
                            m_pArrayInfo->Dimension = dimension + 1;
                        }
                        // A conformant array of interface pointers shows up as an FC_EMBEDDED_COMPLEX
                        // case. Don't ask me why, but be sure to give the right levels of indirection
                        // in any case.
                        //
                        ASSERT(cbElement == sizeof(LPUNKNOWN));
                        PBYTE* rgpbMemoryFrom = (PBYTE*)pMemoryFrom;
                        PBYTE* rgpbMemoryTo   = (PBYTE*)pMemoryTo;
                        CopyWorker(DerefSrc(rgpbMemoryFrom + i), &rgpbMemoryTo[i], pFormat, /*we've already allocated the pointer for him*/ FALSE);
                    }
                }
                else
                {
                    // As we recurse to copy, we need to make sure we have
                    // memory in the right spaces for checking purposes.
                    //
                    PBYTE pbTemp;
                    PBYTE* ppbTo = GetAllocatedPointer(pbTemp);
                    for (ULONG i = 0; i < count ; i++)
                    {
                        // Keep track of multidimensional array information
                        //
                        if (fIsArray)
                        {
                            m_pArrayInfo->Dimension = dimension + 1;
                        }
                        //
                        PBYTE  pbFrom = pMemoryFrom + (i*cbElement);
                        PBYTE  pbTo   = pMemoryTo   + (i*cbElement);

                        *ppbTo = pbTo;
                        CopyWorker(pbFrom, ppbTo, pFormat, FALSE);
                    }
                    FreeAllocatedPointer(ppbTo);
                }

                break;
            }

            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            case FC_IP:
            {
                PBYTE* rgpbMemoryFrom = (PBYTE*)pMemoryFrom;
                PBYTE* rgpbMemoryTo   = (PBYTE*)pMemoryTo;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    CopyWorker(DerefSrc(rgpbMemoryFrom + i), &rgpbMemoryTo[i], pFormat, FALSE);
                }
                break;
            }

            case FC_ENUM16:
            default:
                CopyToDst(pMemoryTo, pMemoryFrom, cbValid);
                break;
            }
        }
        __finally
        {
            m_pArrayInfo = pArrayInfoStart;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Copying bogus structures
    //
    /////////////////////////////////////////////////////////////////////

    case FC_BOGUS_STRUCT:
    {
        const BYTE alignment = pFormat[1];              // wire alignment of the structure
#ifndef _WIN64
        const LONG alignMod8 = (LONG)pMemoryFrom % 8;   // for wierd structs. e.g.: doubles in a by-value-on-stack x86 struct
        const LONG alignMod4 = (LONG)pMemoryFrom % 4;   // 
#else
        const LONGLONG alignMod8 = (LONGLONG)pMemoryFrom % 8;   // for wierd structs. e.g.: doubles in a by-value-on-stack x86 struct
        const LONGLONG alignMod4 = (LONGLONG)pMemoryFrom % 4;   // 
#endif

        const PBYTE prevMemory = m_Memory;
        m_Memory = pMemoryFrom;

        __try
        {
            const PFORMAT_STRING pFormatSave = pFormat;
            const PBYTE pMemFrom = pMemoryFrom;
            //
            pFormat += 4;   // to conformant array offset field
            //
            // Get conformant array description
            //
            const PFORMAT_STRING pFormatArray = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Get pointer layout description
            //
            PFORMAT_STRING pFormatPointers = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Compute the size of this struct
            //
            ULONG cbStruct = PtrToUlong(MemoryIncrement(pMemFrom, pFormatSave, TRUE)) - PtrToUlong(pMemFrom);
            //
            // Allocate and initialize the destination struct
            //
            PBYTE pbT = DerefDst(ppMemoryTo);
            if (fMustAlloc || NULL == pbT)
            {
                pbT = (BYTE*)m_pAllocatorFrame->Alloc(cbStruct, m_fWorkingOnOutParam);
				if (pbT == NULL)
					ThrowHRESULT(E_OUTOFMEMORY);
                DerefStoreDst(ppMemoryTo, pbT);
            }
            const PBYTE pMemoryTo = pbT;
            ZeroDst(pMemoryTo, cbStruct);
            //
            // Copy the structure member by member
            //
            PBYTE pbTemp;
            PBYTE* ppbTo = GetAllocatedPointer(pbTemp);
            __try
            {
                ULONG dib = 0;
                for (BOOL fContinue = TRUE; fContinue ; pFormat++)
                {
                    switch (pFormat[0])
                    {
                    case FC_CHAR:  case FC_BYTE:  case FC_SMALL:  case FC_WCHAR:  case FC_SHORT: case FC_LONG:
                    case FC_FLOAT: case FC_HYPER: case FC_DOUBLE: case FC_ENUM16: case FC_ENUM32: 
                    case FC_INT3264: case FC_UINT3264:
                    {
                        *ppbTo = pMemoryTo + dib;
                        CopyWorker(pMemFrom + dib, ppbTo, pFormat, FALSE);
                        dib += SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                        break;
                    }
                    case FC_IGNORE:
                        break;
                    case FC_POINTER:
                    {
                        PBYTE* ppbFrom = (PBYTE*)(pMemFrom  + dib);
                        PBYTE* ppbTo   = (PBYTE*)(pMemoryTo + dib);
                        CopyWorker(DerefSrc(ppbFrom), ppbTo, pFormatPointers, FALSE);
                        dib += PTR_MEM_SIZE;
                        pFormatPointers += 4;
                        break;
                    }
                    case FC_EMBEDDED_COMPLEX:
                    {
                        dib += pFormat[1]; // skip padding
                        pFormat += 2;
                        PFORMAT_STRING pFormatComplex = pFormat + * ((signed short UNALIGNED*) pFormat);
                        if (FC_IP == pFormatComplex[0])
                        {
                            LPUNKNOWN* ppunkFrom = (LPUNKNOWN*)(pMemFrom  + dib);
                            LPUNKNOWN* ppunkTo   = (LPUNKNOWN*)(pMemoryTo + dib);
                            CopyWorker((PBYTE)DerefSrc(ppunkFrom), (PBYTE*)(ppunkTo), pFormatComplex, FALSE);
                        }
                        else
                        {
                            *ppbTo = pMemoryTo + dib;
                            CopyWorker(pMemFrom + dib, ppbTo, pFormatComplex, FALSE);
                        }
                        dib = PtrToUlong(MemoryIncrement(pMemFrom + dib, pFormatComplex, TRUE)) - PtrToUlong(pMemFrom);
                        pFormat++;      // main loop does one more for us
                        break;
                    }
                    case FC_ALIGNM2:
                        dib = PtrToUlong(ALIGNED_VALUE(pMemFrom + dib, 0x01)) - PtrToUlong(pMemFrom);
                        break;
                    case FC_ALIGNM4:
                        dib = PtrToUlong(ALIGNED_VALUE(pMemFrom + dib, 0x03)) - PtrToUlong(pMemFrom);
                        break;
                    case FC_ALIGNM8:
                        //
                        // Handle 8 byte aligned structure passed by value. Alignment of the struct on 
                        // the stack isn't guaranteed to be 8 bytes
                        //
                        dib -= (ULONG)alignMod8;
                        dib  = PtrToUlong(ALIGNED_VALUE(pMemFrom + dib, 0x07)) - PtrToUlong(pMemFrom);
                        dib += (ULONG)alignMod8;
                        break;
                    case FC_STRUCTPAD1: case FC_STRUCTPAD2: case FC_STRUCTPAD3: case FC_STRUCTPAD4:
                    case FC_STRUCTPAD5: case FC_STRUCTPAD6: case FC_STRUCTPAD7: 
                        dib += (pFormat[0] - FC_STRUCTPAD1) + 1;
                        break;
                    case FC_PAD:
                        break;
                    case FC_END:
                        //
                        fContinue = FALSE;
                        break;
                        //
                    default:
                        NOTREACHED();
                        return;
                    }
                }
                //
                // Copy the conformant array if we have one
                //
                if (pFormatArray)
                {
                    if (FC_C_WSTRING == pFormatArray[0])
                    {
                        dib = PtrToUlong(ALIGNED_VALUE(pMemFrom + dib, 0x01)) - PtrToUlong(pMemFrom);
                    }
                    
                    *ppbTo = pMemoryTo + dib;
                    CopyWorker(pMemFrom + dib, ppbTo, pFormatArray, FALSE);
                }
            }
            __finally
            {
                FreeAllocatedPointer(ppbTo);
            }
        }
        __finally
        {
            m_Memory = prevMemory;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // We handle a few special cases of user-marshal in our copying
    //
    /////////////////////////////////////////////////////////////////////
    case FC_USER_MARSHAL:
    {
        HRESULT hr;
        //
        // The format string layout is as follows:
        //      FC_USER_MARSHAL
        //      flags & alignment<1>
        //      quadruple index<2>
        //      memory size<2>
        //      wire size<2>
        //      type offset<2>
        // The wire layout description is at the type offset.  
        //
        USHORT iquad = *(USHORT *)(pFormat + 2);
        const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

        if (g_oa.IsVariant(rgQuad[iquad]))
        {
            VARIANT* pvarFrom = (VARIANT*)  pMemoryFrom;
            VARIANT** ppvarTo = (VARIANT**) ppMemoryTo;

            VARIANT*   pvarTo = DerefDst(ppvarTo);
            if (fMustAlloc || NULL==pvarTo)
            {
                pvarTo = (VARIANT*)m_pAllocatorFrame->Alloc(sizeof(VARIANT), m_fWorkingOnOutParam);				
                DerefStoreDst(ppvarTo, pvarTo);
            }

            if (pvarTo)
            {
                VariantInit(pvarTo);
                hr = GetHelper().VariantCopy(pvarTo, pvarFrom, TRUE);
            }
            else
                hr = E_OUTOFMEMORY;
            
            if (!!hr) 
            { ThrowHRESULT(hr); }
        }

        else if (g_oa.IsBSTR(rgQuad[iquad]))
        {
            BSTR* pbstrFrom = (BSTR*) pMemoryFrom;
            BSTR   bstrFrom = DerefSrc(pbstrFrom);

            BSTR** ppbstrTo = (BSTR**) ppMemoryTo;
            BSTR*   pbstrTo = DerefDst(ppbstrTo);

            if (NULL==pbstrTo) // REVIEW: also for fMustAlloc case?
            {
                pbstrTo = (BSTR*)m_pAllocatorFrame->Alloc(sizeof(BSTR), m_fWorkingOnOutParam);
                DerefStoreDst(ppbstrTo, pbstrTo);
            }

            if (pbstrTo)
            {
                hr = S_OK;
                //
                BSTR bstrNew = NULL;
                if (bstrFrom)
                {
                    bstrNew = SysCopyBSTRSrc(bstrFrom);
                    if (NULL == bstrNew)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                DerefStoreDst(pbstrTo, bstrNew);
            }
            else
                hr = E_OUTOFMEMORY;

            if (!!hr) 
            { ThrowHRESULT(hr); }
        }

        else if (g_oa.IsSAFEARRAY(rgQuad[iquad]))
        {
            SAFEARRAY** ppsaFrom = (SAFEARRAY**) pMemoryFrom;
            SAFEARRAY*   psaFrom = DerefSrc(ppsaFrom);

            SAFEARRAY*** pppsaTo = (SAFEARRAY***) ppMemoryTo;
            SAFEARRAY**   ppsaTo = DerefDst(pppsaTo);

            if (NULL==ppsaTo) // REVIEW: also for fMustAlloc case?
            {
                ppsaTo = (SAFEARRAY**)m_pAllocatorFrame->Alloc(sizeof(SAFEARRAY*), m_fWorkingOnOutParam);
                DerefStoreDst(pppsaTo, ppsaTo);
            }

            if (ppsaTo)
            {
                hr = GetHelper().SafeArrayCopy(psaFrom, ppsaTo);
            }
            else
                hr = E_OUTOFMEMORY;

            if (!!hr) 
            { ThrowHRESULT(hr); }
        }

        else
        {
            ThrowNYI();
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Unimplemented stuff that probably we just should forget about
    //
    /////////////////////////////////////////////////////////////////////

    case FC_C_BSTRING:          // obsolete. only used by stubs compiled with an old NT Beta2 Midl compiler
    case FC_TRANSMIT_AS:        // need MIDL changes in order to support
    case FC_REPRESENT_AS:       // need MIDL changes in order to support
    case FC_TRANSMIT_AS_PTR:    // need MIDL changes in order to support
    case FC_REPRESENT_AS_PTR:   // need MIDL changes in order to support
    case FC_PIPE:               // a DCE-only-ism
        ThrowNYI();
        break;


        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that maybe we should get around to
        //
        /////////////////////////////////////////////////////////////////////

    case FC_C_SSTRING:              // 'struct string': is rare
    case FC_FP:                     // full pointer
    case FC_ENCAPSULATED_UNION:
    case FC_NON_ENCAPSULATED_UNION:
        ThrowNYI();
        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that remains to be evaluated
        //
        /////////////////////////////////////////////////////////////////////

    case FC_CSTRUCT:                // conformant struct
    case FC_CPSTRUCT:               // conformant struct with pointers
    case FC_CVSTRUCT:               // conformant varying struct
    case FC_CVARRAY:                // conformant varying array
    case FC_SMVARRAY:               
    case FC_LGVARRAY:
    case FC_CSTRING:                // [size_is(xxx), string]
    case FC_BSTRING:                // [size_is(xxx), string]
    case FC_SSTRING:                // [size_is(xxx), string]
    case FC_WSTRING:                // [size_is(xxx), string]
    case FC_BYTE_COUNT_POINTER:
    case FC_HARD_STRUCT:
    case FC_BLKHOLE:
    case FC_RANGE:
    default:
        ThrowNYI();
    }
}


void CallFrame::CopyConformantArrayPriv(BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
// Copy the body of a conformant array after the allocation has been done elsewhere
{
    if (m_MaxCount > 0)
    {
        SIZE_T cbCopy = m_MaxCount *   *((ushort*)(pFormat+2));
        CopyToDst(DerefDst(ppMemoryTo), pMemoryFrom, cbCopy);
        pFormat += 8;
        if (*pFormat == FC_PP)      // Is there a trailing pointer layout?
        {
            CopyEmbeddedPointers(pMemoryFrom, DerefDst(ppMemoryTo), pFormat, fMustAlloc);
        }
    }
}


inline PFORMAT_STRING CallFrame::CopyEmbeddedRepeatPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
// Copies an array's embedded pointers
{
    SIZE_T repeatCount, repeatIncrement;
    //
    // Get the repeat count
    //
    switch (*pFormat)
    {
    case FC_FIXED_REPEAT:
        pFormat += 2;
        repeatCount = *(ushort*)pFormat;
        break;

    case FC_VARIABLE_REPEAT:
        repeatCount = m_MaxCount;           // ??? the last conformance calculation or something?
        //
        // Check if this variable repeat instance also has a variable offset (this would be the case for a conformant
        // varying array of pointers, or structures which contain pointers). If so then increment the format string
        // to point to the actual first array element which is being copied
        //
        if (pFormat[1] == FC_VARIABLE_OFFSET)
        {
            pbFrom += *((ushort *)(&pFormat[2])) * m_Offset;       // REVIEW!
            pbTo   += *((ushort *)(&pFormat[2])) * m_Offset;       // REVIEW!
        } 
        else
        {
            ASSERT(pFormat[1] == FC_FIXED_OFFSET);
        }
        break;

    default:
        NOTREACHED();
        repeatCount = 0;
    }

    pFormat += 2;                           // increment to increment field

    repeatIncrement = *(ushort*)pFormat;    // get increment amount between successive pointers
    pFormat += sizeof(ushort);
    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're copying.
    //
    m_Memory += *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;

    // Loop over the number of array elements
    //
    for( ; repeatCount--; pbFrom += repeatIncrement, pbTo += repeatIncrement, m_Memory += repeatIncrement )
    {
        pFormat = pFormatSave;
        ULONG cPointers = cPointersSave;
        //
        // Loop over the number of pointers per array element. Can be more than one for an array of structures
        //
        for ( ; cPointers--; )
        {
            PVOID* ppvFrom = (PVOID*) (pbFrom + *((signed short *)(pFormat)));    // address of source pointer
            PVOID* ppvTo   = (PVOID*) (pbTo   + *((signed short *)(pFormat)));    // address of dest pointer

            pFormat += sizeof(signed short) * 2;

            if (fMustAlloc)
            {
                DerefStoreDst(ppvTo, (PVOID)NULL);
            }
            
            ASSERT(IsPointer(pFormat));     // Recurse to copy the pointer
            CopyWorker((BYTE*)DerefSrc(ppvFrom), (BYTE**)ppvTo, pFormat, fMustAlloc);

            pFormat += 4;                   // increment to the next pointer description
        }
    }

    // return location of format string after the array's pointer description
    return pFormatSave + cPointersSave * 8;
}


void CallFrame::CopyEmbeddedPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
// Fix up the embedded pointers in a copied struct or array. pFormat is pointing to the pointer_layout<>
// description of the struct or array; pbStruct is the copied structure / array which needs rectification.
// See also NdrpEmbeddedPointerUnmarshal in unmrshlp.c.
{
    ULONG_PTR       MaxCountSave = m_MaxCount;
    ULONG_PTR       OffsetSave   = m_Offset;

    // From NDR:
    // "The Memory field in the stub message keeps track of the pointer to the current embedding structure or 
    // array.  This is needed to handle size/length pointers, so that we can get a pointer to the current 
    // embedding struct when computing conformance and variance."
    //
    BYTE* pMemoryOld = SetMemory(pbFrom);

    ASSERT(*pFormat == FC_PP);
    pFormat += 2;   // Skip FC_PP and FC_PAD

    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            PVOID* ppvFrom = (PVOID*) (pbFrom + *((signed short *)(pFormat + 2)));    // address of source pointer
            PVOID* ppvTo   = (PVOID*) (pbTo   + *((signed short *)(pFormat + 2)));    // address of dest pointer
            
            pFormat += 6;                   // increment to the pointer description

            if (fMustAlloc)
                *ppvTo = NULL;              // if the incoming encapsulating ptr was just allocated then NULL it
            
            ASSERT(IsPointer(pFormat));     // Recurse to copy the pointer
            CopyWorker((BYTE*)DerefSrc(ppvFrom), (BYTE**)ppvTo, pFormat, m_fPropogatingOutParam);

            pFormat += 4;                   // increment ot the next pointer description
        }
        else
        {
            pFormat = CopyEmbeddedRepeatPointers(pbFrom, pbTo, pFormat, m_fPropogatingOutParam);
        }
    }

    SetMemory(pMemoryOld);
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////


void CallFrame::FreeWorker(BYTE* pMemory, PFORMAT_STRING pFormat, BOOL fFreePointer)
// Free this darn data. m_fToUser is to control whether we are to check for user mode addresses; that
// is, we check against the destination.
//
{
    switch (*pFormat)
    {
        /////////////////////////////////////////////////////////////////////
        //
        // Pointers
        //
        /////////////////////////////////////////////////////////////////////
    case FC_RP: // ref pointer
    case FC_UP: // unique pointer
    case FC_OP: // a unique pointer in a COM interface, which is not the top most pointer
    {
        if (NULL == pMemory) break;

        BYTE* pMemoryPointee = pMemory;
        BYTE  bPointerAttributes = pFormat[1];

        ASSERT(!DONT_FREE(bPointerAttributes));
        ASSERT(!ALLOCATE_ALL_NODES(bPointerAttributes));

        if (!SIMPLE_POINTER(bPointerAttributes))
        {
            // Free embedded pointers
            //
            PFORMAT_STRING pFormatPointee = &pFormat[2];
            pFormatPointee += *((signed short *)pFormatPointee);
            
            if (FIndirect(bPointerAttributes, pFormatPointee, FALSE))
            {
                pMemoryPointee = DerefDst((BYTE**)pMemoryPointee);
            }
            
            FreeWorker(pMemoryPointee, pFormatPointee, TRUE);
        }
        //
        // Free top level pointer. 
        //
        // We only check one byte for being in the proper memory space, since
        // the free logic, if it is in user mode, will go to user mode to free it,
        // where any bogosities beyond that one byte will be caught by the hardware.
        //
        if (fFreePointer)
        {
            TestWriteDst(pMemory, 1);
            Free(pMemory);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Simple structs
    //
    /////////////////////////////////////////////////////////////////////
    case FC_PSTRUCT:
    {
        FreeEmbeddedPointers(pMemory, &pFormat[4]);
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Simple Types
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CHAR:
    case FC_BYTE:
    case FC_SMALL:
    case FC_WCHAR:
    case FC_SHORT:
    case FC_LONG:
    case FC_HYPER:
    case FC_ENUM16:
    case FC_ENUM32:
    case FC_DOUBLE:
    case FC_FLOAT:
    case FC_INT3264:
    case FC_UINT3264:
    {
        NOTREACHED();
        /*
          if (fFreePointer)
          {
          TestWriteDst(pMemory, 1);
          Free(pMemory);
          }
        */
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Fixed sized arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        if (pMemory) 
        {
            if (*pFormat == FC_SMFARRAY) 
		        pFormat += 4;
	        else
		        pFormat += 6;

	        if (*pFormat == FC_PP) 
		        FreeEmbeddedPointers(pMemory, pFormat);
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Conformant arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CARRAY:
    {
        if (pMemory)
        {
            if (pFormat[8] == FC_PP)
            {
                ComputeConformance(pMemory, pFormat, FALSE);
                FreeEmbeddedPointers(pMemory, pFormat + 8);
            }
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Freeing really hard arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_ARRAY:
    {
        ARRAY_INFO*     pArrayInfoStart = m_pArrayInfo;
        PFORMAT_STRING  pFormatStart    = pFormat;

        __try
        {
            // Initialize m_pArrayInfo if necessary
            //
            ARRAY_INFO arrayInfo;
            if (NULL == m_pArrayInfo)
            {
                m_pArrayInfo = &arrayInfo;
                Zero(&arrayInfo);
            }
            const LONG dimension = m_pArrayInfo->Dimension;
            //
            // Get the array's alignment
            //
            const BYTE alignment = pFormat[1];
            pFormat += 2;
            //
            // Get the number of elements (0 if the array has conformance)
            //
            ULONG cElements = *(USHORT*)pFormat;
            pFormat += sizeof(USHORT);
            //
            // Check for conformance description
            //
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormatStart, FALSE);
            }
            pFormat += 4;
			CORRELATION_DESC_INCREMENT( pFormat );

            //
            // Check for variance description
            //
            ULONG offset;
            ULONG count;
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                ComputeVariance(pMemory, pFormatStart, &offset, &count, FALSE);
            }
            else
            {
                offset = 0;
                count  = cElements;
            }
            pFormat += 4;
			CORRELATION_DESC_INCREMENT( pFormat );

            /////////////////////////////////////////////////
            //
            // Compute the size of each element in the array
            //
            ULONG cbElement;
            //
            BYTE bFormat = pFormat[0];
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                pFormat += 2;
                pFormat += *((signed short *)pFormat);
                //
                m_pArrayInfo->Dimension = dimension + 1;
                cbElement = PtrToUlong(MemoryIncrement(pMemory, pFormat, FALSE)) - PtrToUlong(pMemory);
                break;
            }

            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            case FC_IP:
            {
                cbElement = PTR_MEM_SIZE;
                break;
            }

            default:
                ASSERT(IS_SIMPLE_TYPE(pFormat[0]));
                //
                // Fall through
                //
            case FC_ENUM16:
                //
                // Nothing to free
                //
                return;
            }

            /////////////////////////////////////////////////
            //
            // Adjust memory pointer to the start of the variance, if any
            //
            pMemory += offset * cbElement;

            /////////////////////////////////////////////////
            //
            // Actually do the freeing
            //
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                BOOL fIsArray = IS_ARRAY_OR_STRING(pFormat[0]);
                if (!fIsArray)
                {
                    m_pArrayInfo = NULL;
                }
                //
                // Do it element by element
                //
                for (ULONG i = 0; i < count ; i++)
                {
                    if (fIsArray)
                    {
                        m_pArrayInfo->Dimension = dimension + 1;
                    }
                    //
                    PBYTE pb = pMemory + (i*cbElement);
                    FreeWorker(pb, pFormat, TRUE);
                    //
                }

                break;
            }

            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            {
                PBYTE* rgpbMemory = (PBYTE*)pMemory;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    FreeWorker(DerefDst(rgpbMemory + i), pFormat, TRUE);
                }
                break;
            }

            case FC_IP:
                // In the free cycle, interface pointers have one less level of indirection than FC_RP etc
            {
                LPUNKNOWN* rgpunk = (LPUNKNOWN*)pMemory;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    FreeWorker( (PBYTE) &rgpunk[i], pFormat, TRUE);
                }
                break;
            }

            default:
                NOTREACHED();
            }
        }
        __finally
        {
            m_pArrayInfo = pArrayInfoStart;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Freeing bogus structures
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_STRUCT:
    {
        const BYTE alignment = pFormat[1];          // wire alignment of the structure
#ifndef _WIN64
        const LONG alignMod8 = (LONG)pMemory % 8;   // for wierd structs. e.g.: doubles in a by-value-on-stack x86 struct
        const LONG alignMod4 = (LONG)pMemory % 4;   // 
#else
        const LONGLONG alignMod8 = (LONGLONG)pMemory % 8;   // for wierd structs. e.g.: doubles in a by-value-on-stack x86 struct
        const LONGLONG alignMod4 = (LONGLONG)pMemory % 4;   // 
#endif

        const PBYTE prevMemory = m_Memory;
        m_Memory = pMemory;

        __try
        {
            const PFORMAT_STRING pFormatSave = pFormat;
            const PBYTE pMem = pMemory;
            //
            pFormat += 4;   // to conformant array offset field
            //
            // Get conformant array description
            //
            const PFORMAT_STRING pFormatArray = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Get pointer layout description
            //
            PFORMAT_STRING pFormatPointers = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Free the structure member by member
            //
            ULONG dib = 0;
            for (BOOL fContinue = TRUE; fContinue ; pFormat++)
            {
                switch (pFormat[0])
                {
                case FC_CHAR:  case FC_BYTE:  case FC_SMALL:  case FC_WCHAR:  case FC_SHORT: case FC_LONG:
                case FC_FLOAT: case FC_HYPER: case FC_DOUBLE: case FC_ENUM16: case FC_ENUM32:
                case FC_INT3264: case FC_UINT3264:
                {
                    // Nothing to free
                    dib += SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                    break;
                }
                case FC_IGNORE:
                    break;
                case FC_POINTER:
                {
                    PBYTE* ppb = (PBYTE*)(pMem + dib);
                    FreeWorker(DerefDst(ppb), pFormatPointers, TRUE);
                    DerefStoreDst(ppb, (PBYTE)NULL);
                    //
                    dib += PTR_MEM_SIZE;
                    pFormatPointers += 4;
                    break;
                }
                case FC_EMBEDDED_COMPLEX:
                {
                    dib += pFormat[1]; // skip padding
                    pFormat += 2;
                    PFORMAT_STRING pFormatComplex = pFormat + * ((signed short UNALIGNED*) pFormat);
                    FreeWorker(pMem + dib, pFormatComplex, TRUE);
                    ULONG dibNew = PtrToUlong(MemoryIncrement(pMem + dib, pFormatComplex, TRUE)) - PtrToUlong(pMem);
                    if (pFormatComplex[0] == FC_IP)     // REVIEW: Also for other pointer types?
                    {
                        ZeroDst(pMem + dib, dibNew - dib);
                    }
                    dib = dibNew;
                    pFormat++;      // main loop does one more for us
                    break;
                }
                case FC_ALIGNM2:
                    dib = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x01)) - PtrToUlong(pMem);
                    break;
                case FC_ALIGNM4:
                    dib = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x03)) - PtrToUlong(pMem);
                    break;
                case FC_ALIGNM8:
                    //
                    // Handle 8 byte aligned structure passed by value. Alignment of the struct on 
                    // the stack isn't guaranteed to be 8 bytes
                    //
                    dib -= (ULONG)alignMod8;
                    dib  = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x07)) - PtrToUlong(pMem);
                    dib += (ULONG)alignMod8;
                    break;
                case FC_STRUCTPAD1: case FC_STRUCTPAD2: case FC_STRUCTPAD3: case FC_STRUCTPAD4:
                case FC_STRUCTPAD5: case FC_STRUCTPAD6: case FC_STRUCTPAD7: 
                    dib += (pFormat[0] - FC_STRUCTPAD1) + 1;
                    break;
                case FC_PAD:
                    break;
                case FC_END:
                    //
                    fContinue = FALSE;
                    break;
                    //
                default:
                    NOTREACHED();
                    return;
                }
            }
            //
            // Copy the conformant array if we have one
            //
            if (pFormatArray)
            {
                if (FC_C_WSTRING == pFormatArray[0])
                {
                    dib = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x01)) - PtrToUlong(pMem);
                }
                FreeWorker(pMem + dib, pFormatArray, TRUE);
            }
        }
        __finally
        {
            m_Memory = prevMemory;
        }
    }
    break;


    /////////////////////////////////////////////////////////////////////
    //
    // Freeing interface pointers: 
    //
    /////////////////////////////////////////////////////////////////////
    case FC_IP:
    {
        // Figure out the IID and call the walker if there is one. Otherwise,
        // leave the interface pointer just as it is.
        //
        IUnknown** ppUnk = (IUnknown**)pMemory;

        if (m_pWalkerFree)
        {
            IID* pIID;

            if (pFormat[1] == FC_CONSTANT_IID)
            {
                pIID = (IID*)&pFormat[2];
            }
            else
            {
                pIID = (IID *)ComputeConformance(pMemory, pFormat, FALSE);
                if (NULL == pIID)
                    Throw(STATUS_INVALID_PARAMETER);
            }
            //
            // Note: in freeing case, changing the interface pointer has no effect
            // in its container; our caller will NULL it anyway.
            //
            IID iid;
            CopyMemory(&iid, pIID, sizeof(IID));
            ThrowIfError(m_pWalkerFree->OnWalkInterface(iid, (void**)ppUnk, m_fWorkingOnInParam, m_fWorkingOnOutParam));
        }
        else
        {
            // We've been asked to free the thing, but he hasn't given us a walker
            // to do so. So just release the thing. Note that in the post-'unmarshal'
            // case on the server side, this will be the right thing.
            //
            // SECURITY NOTE: If caller is in kernel mode worried about the possibility of user 
            // mode malicious guy then he should either a) always provide a walker to deal with the 
            // callbacks, or b) make sure by the way that the frame got created in the first
            // place that there aren't any user mode objects lying around. Here, we only release
            // the objects that are in kernel, assuming that user mode guys are handled elsewise.
            //
            IUnknown* punk = DerefDst(ppUnk);
            DerefStoreDst(ppUnk, (IUnknown*)NULL);
            if (punk)
            {
                punk->Release();
            }
        }

        DerefStoreDst(ppUnk, (LPUNKNOWN)NULL); // NULL out the pointer
        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // We handle a few special cases of user-marshal
    //
    /////////////////////////////////////////////////////////////////////
    case FC_USER_MARSHAL:
    {
        const USHORT iquad = *(USHORT *)(pFormat + 2);
        const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

        if (m_fIsUnmarshal)
        {
            // If we're beeing asked to Free() on an umarshalled frame, we should just do 
            // the "user free" routine.  (Since it was allocated with the "user unmarshal"
            // routine.)
            ULONG Flags = 0;
            rgQuad[iquad].pfnFree(&Flags, pMemory);
        }
        else
        {
            if (g_oa.IsVariant(rgQuad[iquad]))
            {
                VARIANT* pvar = (VARIANT*) pMemory;
                GetHelper().VariantClear(pvar, TRUE);
                //
                // Don't free the pointer here, do this, as 'container' will free us. Consider,
                // for example, an array of VARIANTs, where each VARIANT itself isn't independently
                // allocated. Can't happen with BSTRs and LPSAFEARRAYs, where the runtime always
                // owns the allocation thereof.
            }
            else if (g_oa.IsBSTR(rgQuad[iquad]))
            {
                BSTR* pbstr = (BSTR*) pMemory;
                BSTR bstr = DerefDst(pbstr);
                DerefStoreDst(pbstr, (BSTR)NULL);
                
                SysFreeStringDst(bstr);
            }
            else if (g_oa.IsSAFEARRAY(rgQuad[iquad]))
            {
                LPSAFEARRAY* ppsa = (LPSAFEARRAY*) pMemory;
                LPSAFEARRAY   psa = DerefDst(ppsa);
                DerefStoreDst(ppsa, (LPSAFEARRAY)NULL);
                
                GetHelper().SafeArrayDestroy(psa);
            }
            else
                ThrowNYI();
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Stuff that doesn't need freeing
    //
    /////////////////////////////////////////////////////////////////////
    case FC_STRUCT:
    case FC_CSTRUCT:
    case FC_C_CSTRING:
    case FC_C_BSTRING:
    case FC_C_SSTRING:
    case FC_C_WSTRING:
    case FC_CSTRING:
    case FC_BSTRING:
    case FC_SSTRING:
    case FC_WSTRING:

        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that probably we just should forget about
        //
        /////////////////////////////////////////////////////////////////////

    case FC_TRANSMIT_AS:        // need MIDL changes in order to support
    case FC_REPRESENT_AS:       // need MIDL changes in order to support
    case FC_TRANSMIT_AS_PTR:    // need MIDL changes in order to support
    case FC_REPRESENT_AS_PTR:   // need MIDL changes in order to support
    case FC_PIPE:               // a DCE-only-ism
        ThrowNYI();
        break;


        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that maybe we should get around to
        //
        /////////////////////////////////////////////////////////////////////

    case FC_FP:                     // full pointer
    case FC_ENCAPSULATED_UNION:
    case FC_NON_ENCAPSULATED_UNION:
        ThrowNYI();
        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that remains to be evaluated
        //
        /////////////////////////////////////////////////////////////////////

    case FC_CPSTRUCT:               // conformant struct with pointers
    case FC_CVSTRUCT:               // conformant varying struct
    case FC_CVARRAY:                // conformant varying array
    case FC_SMVARRAY:               
    case FC_LGVARRAY:
    case FC_BYTE_COUNT_POINTER:
    case FC_HARD_STRUCT:
    case FC_BLKHOLE:
    case FC_RANGE:
    default:
        ThrowNYI();
    }
}


inline PFORMAT_STRING CallFrame::FreeEmbeddedRepeatPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
{
    ULONG_PTR repeatCount, repeatIncrement;

    switch (*pFormat)
    {
    case FC_FIXED_REPEAT:
        pFormat += 2;                       // past FC_FIXED_REPEAT and FC_PAD
        repeatCount = *(ushort*)pFormat;
        break;

    case FC_VARIABLE_REPEAT:
        repeatCount = m_MaxCount;           // ??? the last conformance calculation or something?
        //
        // Check if this variable repeat instance also has a variable offset (this would be the case for a conformant
        // varying array of pointers, or structures which contain pointers). If so then incremnent the format string
        // to point to the actual first array element which is being copied
        //
        if (pFormat[1] == FC_VARIABLE_OFFSET)
        {
            pMemory += *((ushort*)(&pFormat[2])) * m_Offset;        // REVIEW!
        } 
        else
        {
            ASSERT(pFormat[1] == FC_FIXED_OFFSET);
        }
        break;

    default:
        NOTREACHED();
        repeatCount = 0;
    }

    pFormat += 2;                           // increment to increment field
    repeatIncrement = *(ushort*)pFormat;    // get increment amount between successive pointers
    pFormat += sizeof(ushort);              // skip that 
    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're copying.
    //
    m_Memory += *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;

    // Loop over the number of array elements
    //
    for( ; repeatCount--; pMemory += repeatIncrement, m_Memory += repeatIncrement )
    {
        pFormat = pFormatSave;
        ULONG cPointers = cPointersSave;
        //
        // Loop over the number of pointers per array element. Can be more than one for an array of structures
        //
        for ( ; cPointers--; )
        {
            PVOID* pp = (PVOID*) (pMemory + *((signed short *)(pFormat)));    // address of pointer to free

            pFormat += sizeof(signed short) * 2;

            ASSERT(IsPointer(pFormat));     
            FreeWorker((BYTE*)DerefDst(pp), pFormat, TRUE);
            DerefStoreDst(pp, (PVOID)NULL);

            pFormat += 4;                   // increment to the next pointer description
        }
    }

    // return location of format string after the array's pointer description
    return pFormatSave + cPointersSave * 8;
}

void CallFrame::FreeEmbeddedPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
// Free pointers in an embedded struct or array
{
    ASSERT(*pFormat == FC_PP);
    pFormat += 2;   // Skip FC_PP and FC_PAD

    BYTE* pMemoryOld = SetMemory(pMemory);

    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            PVOID* pp = (PVOID*) (pMemory + *((signed short *)(pFormat + 2)));    // address of pointer in struct
            
            pFormat += 6;                       // skip to pointer description

            ASSERT(IsPointer(pFormat));     
            FreeWorker((BYTE*)DerefDst(pp), pFormat, TRUE);    // recurse to free the pointer
            DerefStoreDst(pp, (PVOID)NULL);

            pFormat += 4;                       // skip to next pointer description
        }
        else
        {
            pFormat = FreeEmbeddedRepeatPointers(pMemory, pFormat);
        }
    }

    SetMemory(pMemoryOld);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

void CallFrame::WalkWorker(BYTE* pMemory, PFORMAT_STRING pFormat)
// Walk the call frame, looking for interface pointers, calling our walker callback when we find them
// 
{
    switch (*pFormat)
    {
        /////////////////////////////////////////////////////////////////////
        //
        // Pointers
        //
        // In the future, we can be more clever here about sharing with our
        // source data than we are. For example, we could take advantage of the
        // ALLOCED_ON_STACK information that MIDL emits. For the moment, that 
        // would complicate things beyond their worth, however.
        //
        /////////////////////////////////////////////////////////////////////
    case FC_RP: // ref pointer
        if (NULL == pMemory)
        {
            Throw(RPC_NT_NULL_REF_POINTER);
        }
        //
        // Fall through
        //
    case FC_UP: // unique pointer
    case FC_OP: // a unique pointer, which is not the top most pointer, in a COM interface, 
    {
        if (NULL == pMemory)
        {
            return;
        }
        BYTE bPointerAttributes = pFormat[1];
        if (SIMPLE_POINTER(bPointerAttributes))
        {
            // It's a pointer to a simple type or a string pointer. Either way, just recurse to Walk
            //
            WalkWorker(pMemory, &pFormat[2]);
        }
        else
        {
            // It's a more complex pointer type
            //
            PFORMAT_STRING pFormatPointee = pFormat + 2;
            pFormatPointee += *((signed short *)pFormatPointee);
            //
            // We don't handle [allocate] attributes
            //
            //if (ALLOCATE_ALL_NODES(bPointerAttributes) || DONT_FREE(bPointerAttributes)) ThrowNYI();

            if (FIndirect(bPointerAttributes, pFormatPointee, FALSE))
            {
                pMemory = DerefSrc((PBYTE*)pMemory);
            }
            WalkWorker(pMemory, pFormatPointee);
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Walking interface Pointers
    //
    /////////////////////////////////////////////////////////////////////
    case FC_IP:
    {
        // Figure out the IID and call the walker if there is one
        //
        if (m_pWalkerWalk)
        {
            IID* pIID;

            if (pFormat[1] == FC_CONSTANT_IID)
            {
                pIID = (IID*)&pFormat[2];
            }
            else
            {
                pIID = (IID *)ComputeConformance(pMemory, pFormat, TRUE);
                if (NULL == pIID)
                    Throw(STATUS_INVALID_PARAMETER);
            }

            IID iid;
            CopyMemory(&iid, pIID, sizeof(IID));
            ThrowIfError(m_pWalkerWalk->OnWalkInterface(iid, (PVOID*)pMemory, m_fWorkingOnInParam, m_fWorkingOnOutParam));
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Walking simple structs
    //
    /////////////////////////////////////////////////////////////////////
    case FC_STRUCT:
    case FC_PSTRUCT:
    {
        if (NULL == pMemory)
            Throw(RPC_NT_NULL_REF_POINTER);

        if (*pFormat == FC_PSTRUCT)
        {
            WalkEmbeddedPointers(pMemory, &pFormat[4]);
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Types that never have interface pointers
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CHAR:
    case FC_BYTE:
    case FC_SMALL:
    case FC_WCHAR:
    case FC_SHORT:
    case FC_LONG:
    case FC_HYPER:
    case FC_ENUM16:
    case FC_ENUM32:
    case FC_DOUBLE:
    case FC_FLOAT:
    case FC_CSTRING:                // [size_is(xxx), string]
    case FC_BSTRING:                // [size_is(xxx), string]
    case FC_SSTRING:                // [size_is(xxx), string]
    case FC_WSTRING:                // [size_is(xxx), string]
    case FC_C_CSTRING:              // ascii zero-terminated-string
    case FC_C_WSTRING:              // unicode zero-terminated-string
    case FC_INT3264:
    case FC_UINT3264:
    {
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Fixed sized arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        ULONG cbArray;
        if (*pFormat == FC_SMFARRAY)
        {
            pFormat += 2;               // skip code and alignment
            cbArray = *(ushort*)pFormat;
            pFormat += sizeof(ushort);
        }
        else // FC_LGFARRAY
        {
            pFormat += 2;
            cbArray = *(ulong UNALIGNED*)pFormat;
            pFormat += sizeof(ulong);
        }

        if (*pFormat == FC_PP)
        {
            WalkEmbeddedPointers(pMemory, pFormat);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Walking conformant arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CARRAY:
    {
        ULONG count = (ULONG)ComputeConformance(pMemory, pFormat, FALSE);
        ASSERT(count == m_MaxCount);

        if (m_MaxCount > 0)
        {
            WalkConformantArrayPriv(pMemory, pFormat);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Walking bogus arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_ARRAY:
    {
        ARRAY_INFO*     pArrayInfoStart = m_pArrayInfo;
        PFORMAT_STRING  pFormatStart    = pFormat;

        __try
        {
            // Initialize m_pArrayInfo if necessary
            //
            ARRAY_INFO arrayInfo;
            if (NULL == m_pArrayInfo)
            {
                m_pArrayInfo = &arrayInfo;
                Zero(&arrayInfo);
            }
            const LONG dimension = m_pArrayInfo->Dimension;
            //
            // Get the array's alignment
            //
            const BYTE alignment = pFormat[1];
            pFormat += 2;
            //
            // Get the number of elements (0 if the array has conformance)
            //
            ULONG cElements = *(USHORT*)pFormat;
            pFormat += sizeof(USHORT);
            //
            // Check for conformance description
            //
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormatStart, TRUE);
            }
            pFormat += 4;
            //
            // Check for variance description
            //
            ULONG offset;
            ULONG count;
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                ComputeVariance(pMemory, pFormatStart, &offset, &count, TRUE);
            }
            else
            {
                offset = 0;
                count  = cElements;
            }
            pFormat += 4;

            /////////////////////////////////////////////////
            //
            // Compute the size of each element in the array
            //
            ULONG cbElement;
            //
            BYTE bFormat = pFormat[0];
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                pFormat += 2;
                pFormat += *((signed short *)pFormat);
                //
                m_pArrayInfo->Dimension = dimension + 1;
                cbElement = PtrToUlong(MemoryIncrement(pMemory, pFormat, TRUE)) - PtrToUlong(pMemory);
                break;
            }

            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            case FC_IP:
            {
                cbElement = PTR_MEM_SIZE;
                break;
            }

            default:
                ASSERT(IS_SIMPLE_TYPE(pFormat[0]));
                //
                // Fall through
                //
            case FC_ENUM16:
                //
                // Nothing to walk
                //
                return;
            }

            /////////////////////////////////////////////////
            //
            // Adjust memory pointer to the start of the variance, if any
            //
            pMemory += offset * cbElement;

            /////////////////////////////////////////////////
            //
            // Actually do the walking
            //
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                BOOL fIsArray = IS_ARRAY_OR_STRING(pFormat[0]);
                if (!fIsArray)
                {
                    m_pArrayInfo = NULL;
                }
                //
                // Do it element by element
                //
                for (ULONG i = 0; i < count ; i++)
                {
                    if (fIsArray)
                    {
                        m_pArrayInfo->Dimension = dimension + 1;
                    }
                    //
                    PBYTE pb = pMemory + (i*cbElement);
                    WalkWorker(pb, pFormat);
                    //
                }

                break;
            }

            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            {
                PBYTE* rgpbMemory = (PBYTE*)pMemory;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    WalkWorker(DerefSrc(rgpbMemory + i), pFormat);
                }
                break;
            }

            case FC_IP:
                // In the walk cycle, interface pointers have one less level of indirection than FC_RP etc
            {
                LPUNKNOWN* rgpunk = (LPUNKNOWN*)pMemory;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    WalkWorker( (PBYTE) &rgpunk[i], pFormat);
                }
                break;
            }

            default:
                NOTREACHED();
            }
        }
        __finally
        {
            m_pArrayInfo = pArrayInfoStart;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Walking bogus structures
    //
    /////////////////////////////////////////////////////////////////////

    case FC_BOGUS_STRUCT:
    {
        const BYTE alignment = pFormat[1];          // wire alignment of the structure
#ifndef _WIN64
        const LONG alignMod8 = (LONG)pMemory % 8;   // for wierd structs. e.g.: doubles in a by-value-on-stack x86 struct
        const LONG alignMod4 = (LONG)pMemory % 4;   // 
#else
        const LONGLONG alignMod8 = (LONGLONG)pMemory % 8;   // for wierd structs. e.g.: doubles in a by-value-on-stack x86 struct
        const LONGLONG alignMod4 = (LONGLONG)pMemory % 4;   // 
#endif

        const PBYTE prevMemory = m_Memory;
        m_Memory = pMemory;

        __try
        {
            const PFORMAT_STRING pFormatSave = pFormat;
            const PBYTE pMem = pMemory;
            //
            pFormat += 4;   // to conformant array offset field
            //
            // Get conformant array description
            //
            const PFORMAT_STRING pFormatArray = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Get pointer layout description
            //
            PFORMAT_STRING pFormatPointers = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Walk the structure member by member
            //
            ULONG dib = 0;
            for (BOOL fContinue = TRUE; fContinue ; pFormat++)
            {
                switch (pFormat[0])
                {
                case FC_CHAR:  case FC_BYTE:  case FC_SMALL:  case FC_WCHAR:  case FC_SHORT: case FC_LONG:
                case FC_FLOAT: case FC_HYPER: case FC_DOUBLE: case FC_ENUM16: case FC_ENUM32:
                case FC_INT3264: case FC_UINT3264:
                {
                    // Nothing to walk
                    dib += SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                    break;
                }
                case FC_IGNORE:
                    break;
                case FC_POINTER:
                {
                    PBYTE* ppb = (PBYTE*)(pMem + dib);
                    WalkWorker(DerefDst(ppb), pFormatPointers);
                    //
                    dib += PTR_MEM_SIZE;
                    pFormatPointers += 4;
                    break;
                }
                case FC_EMBEDDED_COMPLEX:
                {
                    dib += pFormat[1]; // skip padding
                    pFormat += 2;
                    PFORMAT_STRING pFormatComplex = pFormat + * ((signed short UNALIGNED *) pFormat);
                    WalkWorker(pMem + dib, pFormatComplex);
                    dib = PtrToUlong(MemoryIncrement(pMem + dib, pFormatComplex, TRUE)) - PtrToUlong(pMem);
                    pFormat++;      // main loop does one more for us
                    break;
                }
                case FC_ALIGNM2:
                    dib = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x01)) - PtrToUlong(pMem);
                    break;
                case FC_ALIGNM4:
                    dib = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x03)) - PtrToUlong(pMem);
                    break;
                case FC_ALIGNM8:
                    //
                    // Handle 8 byte aligned structure passed by value. Alignment of the struct on 
                    // the stack isn't guaranteed to be 8 bytes
                    //
                    dib -= (ULONG)alignMod8;
                    dib  = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x07)) - PtrToUlong(pMem);
                    dib += (ULONG)alignMod8;
                    break;
                case FC_STRUCTPAD1: case FC_STRUCTPAD2: case FC_STRUCTPAD3: case FC_STRUCTPAD4:
                case FC_STRUCTPAD5: case FC_STRUCTPAD6: case FC_STRUCTPAD7: 
                    dib += (pFormat[0] - FC_STRUCTPAD1) + 1;
                    break;
                case FC_PAD:
                    break;
                case FC_END:
                    //
                    fContinue = FALSE;
                    break;
                    //
                default:
                    NOTREACHED();
                    return;
                }
            }
            //
            // Walk the conformant array if we have one
            //
            if (pFormatArray)
            {
                if (FC_C_WSTRING == pFormatArray[0])
                {
                    dib = PtrToUlong(ALIGNED_VALUE(pMem + dib, 0x01)) - PtrToUlong(pMem);
                }
                WalkWorker(pMem + dib, pFormatArray);
            }
        }
        __finally
        {
            m_Memory = prevMemory;
        }
    }
    break;


    /////////////////////////////////////////////////////////////////////
    //
    // We handle a few special cases of user-marshal in our walking
    //
    /////////////////////////////////////////////////////////////////////
    case FC_USER_MARSHAL:
    {
        // The format string layout is as follows:
        //      FC_USER_MARSHAL
        //      flags & alignment<1>
        //      quadruple index<2>
        //      memory size<2>
        //      wire size<2>
        //      type offset<2>
        // The wire layout description is at the type offset.  
        //
        USHORT iquad = *(USHORT *)(pFormat + 2);
        const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

        if (g_oa.IsVariant(rgQuad[iquad]))
        {
            VARIANT* pvar = (VARIANT*) pMemory;
            ThrowIfError(GetWalker().Walk(pvar));
        }
        else if (g_oa.IsBSTR(rgQuad[iquad]))
        {
            // No interfaces here
        }
        else if (g_oa.IsSAFEARRAY(rgQuad[iquad]))
        {
            LPSAFEARRAY* ppsa = (LPSAFEARRAY*) pMemory;
            ThrowIfError(GetWalker().Walk(*ppsa));
        }
        else
            ThrowNYI();

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Unimplemented stuff that probably we just should forget about
    //
    /////////////////////////////////////////////////////////////////////

    case FC_C_BSTRING:          // obsolete. only used by stubs compiled with an old NT Beta2 Midl compiler
    case FC_TRANSMIT_AS:        // need MIDL changes in order to support
    case FC_REPRESENT_AS:       // need MIDL changes in order to support
    case FC_TRANSMIT_AS_PTR:    // need MIDL changes in order to support
    case FC_REPRESENT_AS_PTR:   // need MIDL changes in order to support
    case FC_PIPE:               // a DCE-only-ism
        ThrowNYI();
        break;


        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that maybe we should get around to
        //
        /////////////////////////////////////////////////////////////////////

    case FC_C_SSTRING:              // 'struct string': is rare
    case FC_FP:                     // full pointer
    case FC_ENCAPSULATED_UNION:
    case FC_NON_ENCAPSULATED_UNION:
        ThrowNYI();
        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that remains to be evaluated
        //
        /////////////////////////////////////////////////////////////////////

    case FC_CSTRUCT:                // conformant struct
    case FC_CPSTRUCT:               // conformant struct with pointers
    case FC_CVSTRUCT:               // conformant varying struct
    case FC_CVARRAY:                // conformant varying array
    case FC_SMVARRAY:               
    case FC_LGVARRAY:
    case FC_BYTE_COUNT_POINTER:
    case FC_HARD_STRUCT:
    case FC_BLKHOLE:
    case FC_RANGE:
    default:
        ThrowNYI();
    }
}


void CallFrame::WalkConformantArrayPriv(BYTE* pMemory, PFORMAT_STRING pFormat)
// Walk the body of a conformant array
{
    if (m_MaxCount > 0)
    {
        pFormat += 8;
        if (*pFormat == FC_PP)      // Is there a trailing pointer layout?
        {
            WalkEmbeddedPointers(pMemory, pFormat);
        }
    }
}


inline PFORMAT_STRING CallFrame::WalkEmbeddedRepeatPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
// Walks an array's embedded pointers
{
    ULONG_PTR repeatCount, repeatIncrement;
    //
    // Get the repeat count
    //
    switch (*pFormat)
    {
    case FC_FIXED_REPEAT:
        pFormat += 2;
        repeatCount = *(ushort*)pFormat;
        break;

    case FC_VARIABLE_REPEAT:
        repeatCount = m_MaxCount;           // ??? the last conformance calculation or something?
        //
        // Check if this variable repeat instance also has a variable offset (this would be the case for a conformant
        // varying array of pointers, or structures which contain pointers). If so then increment the format string
        // to point to the actual first array element which is being walked
        //
        if (pFormat[1] == FC_VARIABLE_OFFSET)
        {
            pMemory += *((ushort *)(&pFormat[2])) * m_Offset;       // REVIEW!
        } 
        else
        {
            ASSERT(pFormat[1] == FC_FIXED_OFFSET);
        }
        break;

    default:
        NOTREACHED();
        repeatCount = 0;
    }

    pFormat += 2;                           // increment to increment field
    repeatIncrement = *(ushort*)pFormat;    // get increment amount between successive pointers
    pFormat += sizeof(ushort);              // skip that 
    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're copying.
    //
    m_Memory += *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;

    // Loop over the number of array elements
    //
    for( ; repeatCount--; pMemory += repeatIncrement, m_Memory += repeatIncrement )
    {
        pFormat = pFormatSave;
        ULONG cPointers = cPointersSave;
        //
        // Loop over the number of pointers per array element. Can be more than one for an array of structures
        //
        for ( ; cPointers--; )
        {
            PVOID* ppvFrom = (PVOID*) (pMemory + *((signed short *)(pFormat)));    // address of source pointer

            pFormat += sizeof(signed short) * 2;

            ASSERT(IsPointer(pFormat));     // Recurse to Walk the pointer

            WalkWorker((BYTE*)DerefSrc(ppvFrom), pFormat);

            pFormat += 4;                   // increment to the next pointer description
        }
    }

    // return location of format string after the array's pointer description
    return pFormatSave + cPointersSave * 8;
}


void CallFrame::WalkEmbeddedPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
// Fix up the embedded pointers in a copied struct or array. pFormat is pointing to the pointer_layout<>
// description of the struct or array; pbStruct is the copied structure / array which needs rectification.
// See also NdrpEmbeddedPointerUnmarshal in unmrshlp.c.
{
    ULONG_PTR       MaxCountSave = m_MaxCount;
    ULONG_PTR       OffsetSave   = m_Offset;

    // From NDR:
    // "The Memory field in the stub message keeps track of the pointer to the current embedding structure or 
    // array.  This is needed to handle size/length pointers, so that we can get a pointer to the current 
    // embedding struct when computing conformance and variance."
    //
    BYTE* pMemoryOld = SetMemory(pMemory);

    ASSERT(*pFormat == FC_PP);
    pFormat += 2;   // Skip FC_PP and FC_PAD

    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            PVOID* ppvFrom = (PVOID*) (pMemory + *((signed short *)(pFormat + 2)));    // address of source pointer
            
            pFormat += 6;                   // increment to the pointer description

            ASSERT(IsPointer(pFormat));     // Recurse to Walk the pointer
            WalkWorker((BYTE*)DerefSrc(ppvFrom), pFormat);

            pFormat += 4;                   // increment ot the next pointer description
        }
        else
        {
            pFormat = WalkEmbeddedRepeatPointers(pMemory, pFormat);
        }
    }

    SetMemory(pMemoryOld);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

static BYTE ComputeConformanceIncrements[] = 
{ 
    4,              // Conformant array.
    4,              // Conformant varying array.
    0, 0,           // Fixed arrays - unused.
    0, 0,           // Varying arrays - unused.
    4,              // Complex array.

    2,              // Conformant char string. 
    2,              // Conformant byte string.
    4,              // Conformant stringable struct. 
    2,              // Conformant wide char string.

    0, 0, 0, 0,     // Non-conformant strings - unused.

    0,              // Encapsulated union - unused. 
    2,              // Non-encapsulated union.
    2,              // Byte count pointer.
    0, 0,           // Xmit/Rep as - unused.
    2               // Interface pointer.
};

// Review: There are places in callframes where the output of this
// method is cast to a pointer.
#ifndef _WIN64
ULONG CallFrame::ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat, BOOL fProbeSrc)
#else
    ULONGLONG CallFrame::ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat, BOOL fProbeSrc)
#endif
// This routine computes the conformant size for an array or the switch_is value for a union.
// 
{
	void* pCount = NULL;
	//
	// Advance the format string to the size_is, switch_is, iid_is, or byte count description.
	//
	pFormat += ComputeConformanceIncrements[*pFormat - FC_CARRAY];
	//
	// First check if this is a 'callback'. A 'callback' requires that we call some compiled
	// code in order to compute the conformance. The compiled code expects a MIDL_STUB_MESSAGE
	// parameter with certain of its fields appropriately initialized
	//
	//      StackTop    - pointer to the top level structure relavant to the conformance computation
	//
	// The code then returns the computed result in the
	//
	//      MaxCount
	//      Offset
	//
	// field(s).
	//
	if (pFormat[1] == FC_CALLBACK)
	{
		// Index into expression callback routines table.
		ushort iexpr = *((ushort *)(pFormat + 2));
		
		ASSERT(GetStubDesc()->apfnExprEval != 0);
		ASSERT(GetStubDesc()->apfnExprEval[iexpr] != 0);
		//
		// The callback routine uses the StackTop field of the stub message
		// to base it's offsets from.  So if this is a complex attribute for 
		// an embedded field of a structure then set StackTop equal to the 
		// pointer to the structure.
		//
		MIDL_STUB_MESSAGE stubMsg; Zero(&stubMsg); stubMsg.StackTop = m_StackTop;
		
		if ((*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE) 
		{
			if ((*pFormat & 0xf0) == FC_POINTER_CONFORMANCE)
			{
				pMemory = m_Memory;
			}
			stubMsg.StackTop = pMemory;
		}
		//
		// This call puts the result in stubMsg.MaxCount
		//
		// REVIEW: For security reasons we might have to disallow callbacks
		// in kernel mode. The reason is that the code we call can be touching arbitrary
		// chunks of user mode memory w/o doing the proper probing.
		//
		// HOWEVER: Given that this is READING the memory only, and given that we'll be
		// using the returned count in a protected probing manner anyway, maybe it's ok?
		//
		(GetStubDesc()->apfnExprEval[iexpr])(&stubMsg);
		
		m_MaxCount = stubMsg.MaxCount;
		m_Offset   = stubMsg.Offset;
		return m_MaxCount;
	}
	
	if ((*pFormat & 0xf0) == FC_NORMAL_CONFORMANCE)
	{
		// Get the address where the conformance variable is in the struct.
		pCount = pMemory + *((signed short *)(pFormat + 2));
		goto GetCount;
	}
	
	//
	// Get a pointer to the conformance describing variable.
	//
	if ((*pFormat & 0xf0) == FC_TOP_LEVEL_CONFORMANCE) 
	{
		// Top level conformance.  For /Os stubs, the stubs put the max
		// count in the stub message.  For /Oi stubs, we get the max count
		// via an offset from the stack top. We don't support /Os stubs here.
		//
		ASSERT(m_StackTop);
		pCount = m_StackTop + *((signed short *)(pFormat + 2));
		goto GetCount;
	}
	//
	// If we're computing the size of an embedded sized pointer then we
	// use the memory pointer in the stub message, which points to the 
	// beginning of the embedding structure.
	//
	if ((*pFormat & 0xf0) == FC_POINTER_CONFORMANCE)
	{
		pMemory = m_Memory;
		pCount = pMemory + *((signed short *)(pFormat + 2));
		goto GetCount;
	}
	//
	// Check for constant size/switch.
	//
	if ((*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE)
	{
		// The size/switch is contained in the lower three bytes of the 
		// long currently pointed to by pFormat.
		//
		ULONG count = (ULONG)pFormat[1] << 16;
		count |= (ULONG) *((ushort *)(pFormat + 2));
		m_MaxCount = count;
		return m_MaxCount;
	}
	
	//
	// Check for conformance of a multidimensional array element in a -Os stub.
	//
	if ((*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE)
	{
		// If pArrayInfo is non-null than we have a multi-D array.  If it is null then we have multi-leveled sized pointers.
		//
		if ( m_pArrayInfo ) 
		{
			m_MaxCount = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
		}
		else
		{
			ThrowNYI(); // probably not needed for fully interpreted stubs ?
			// long dimension = *((ushort *)(pFormat + 2));
			// pStubMsg->MaxCount = pStubMsg->SizePtrCountArray[dimension];
		}
		return m_MaxCount;
	}
	
 GetCount:
	
	//
	// Must check now if there is a dereference op.
	//
	if (pFormat[1] == FC_DEREFERENCE)
	{
		pCount = DerefSrc((PVOID*)pCount);
	}
	//
	// Now get the conformance count.
	//
	// BLOCK
	{
		long count = 0;
		switch (*pFormat & 0x0f)
		{
		case FC_ULONG :
		case FC_LONG :
			count = (long) DerefSrc((long *)pCount);
			break;
			
		case FC_ENUM16:
		case FC_USHORT :
			count = (long) DerefSrc((unsigned short *)pCount);
			break;
			
		case FC_SHORT :
			count = (long) DerefSrc((short *)pCount);
			break;
			
		case FC_USMALL :
			count = (long) DerefSrc((unsigned  *)pCount);
			break;
			
		case FC_SMALL :
			count = (long) DerefSrc((signed char *)pCount);
			break;
			
		default :
			NOTREACHED();
			count = 0;
		} 
		
		//
		// Check the operator.
		//
		switch (pFormat[1])
		{
		case FC_DIV_2:      count /= 2; break;
		case FC_MULT_2:     count *= 2; break;
		case FC_SUB_1:      count -= 1; break;
		case FC_ADD_1:      count += 1; break;
		default :           /* OK */    break;
		}
		m_MaxCount = count;
	}
	
    return m_MaxCount;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

static BYTE ComputeVarianceIncrements[] = 
{ 
    8,      // Conformant varying array.
    0,      // Fixed arrays - unsed.
    0,      // Fixed arrays - unsed.
    8,      // Varying array.
    12,     // Varying array.
    8       // Complex array. 
};

void CallFrame::ComputeVariance(BYTE* pMemory, PFORMAT_STRING pFormat, ULONG* pOffset, ULONG* pActualCount, BOOL fProbeSrc)
{
    pFormat += ComputeVarianceIncrements[*pFormat - FC_CVARRAY];

    PVOID pLength = NULL;
    //
    // First check if this is a callback: if we have to run code to compute the variance
    //
    if (pFormat[1] == FC_CALLBACK)
    {
        // Index into expression callback routines table.
        ushort iexpr = *((ushort *)(pFormat + 2));

        ASSERT(GetStubDesc()->apfnExprEval != 0);
        ASSERT(GetStubDesc()->apfnExprEval[iexpr] != 0);
        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        MIDL_STUB_MESSAGE stubMsg; Zero(&stubMsg); stubMsg.StackTop = m_StackTop;
        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ((*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE) 
        {
            if ((*pFormat & 0xf0) == FC_POINTER_CONFORMANCE)
            {
                pMemory = m_Memory;
            }
            stubMsg.StackTop = pMemory;
        }
        //
        // This puts the computed offset in pStubMsg->Offset and the length in pStubMsg->MaxCount.
        //
        (GetStubDesc()->apfnExprEval[iexpr])(&stubMsg);
        //
        *pOffset      = stubMsg.Offset;
        *pActualCount = (ULONG)stubMsg.MaxCount;
        return;
    }

    else if ((*pFormat & 0xf0) == FC_NORMAL_VARIANCE)
    {
        // Get the address where the variance variable is in the struct.
        //
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // Get a pointer to the variance variable.
    //
    else if ((*pFormat & 0xf0) == FC_TOP_LEVEL_VARIANCE)
    {
        // Top level variance. For /Oi stubs, we get the 
        // actual count via an offset from the stack top.  The first_is must
        // be zero if we get here.
        //
        ASSERT(m_StackTop);
        pLength = m_StackTop + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // If we're computing the length of an embedded size/length pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    else if ((*pFormat & 0xf0) == FC_POINTER_VARIANCE)
    {
        pMemory = m_Memory;
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // Check for constant length.
    //
    else if ((*pFormat & 0xf0) == FC_CONSTANT_VARIANCE)
    {
        // The length is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        LONG length  = (ULONG)pFormat[1] << 16;
        length |= (ULONG) *((ushort *)(pFormat + 2));
        *pOffset      = 0;
        *pActualCount = length;
        return;
    }

    //
    // Check for variance of a multidimensional array element
    //
    else if ((*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE)
    {
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if (m_pArrayInfo)
        {
            *pOffset      =  m_pArrayInfo->OffsetArray[m_pArrayInfo->Dimension];
            *pActualCount =  m_pArrayInfo->ActualCountArray[m_pArrayInfo->Dimension];
        }
        else
        {
            ThrowNYI();
            long Dimension = *((ushort *)(pFormat + 2));
        }

        return;
    }

 GetCount:
    //
    LONG length;
    //
    // Must check now if there is a dereference op.
    //
    if (pFormat[1] == FC_DEREFERENCE)
    {
        pLength = DerefSrc((PVOID*)pLength);
    }
    //
    // Now get the variance length
    //
    switch (*pFormat & 0x0f)
    {
    case FC_ULONG:
    case FC_LONG:
        length = (long) DerefSrc((long*)pLength);
        break;

    case FC_USHORT:
        length = (long) DerefSrc((ushort *)pLength);
        break;

    case FC_SHORT :
        length = (long) DerefSrc((short *)pLength);
        break;

    case FC_USMALL :
        length = (long) DerefSrc((uchar *)pLength);
        break;

    case FC_SMALL :
        length = (long) DerefSrc((char *)pLength);
        break;

    default :
        NOTREACHED();
        length = 0;
    } 
    //
    // Check the operator.
    //
    switch (pFormat[1])
    {
    case FC_DIV_2:      length /= 2; break;
    case FC_MULT_2:     length *= 2; break;
    case FC_SUB_1:      length -= 1; break;
    case FC_ADD_1:      length += 1; break;
    default :           /* ok */     break;
    }

    *pOffset      = 0;
    *pActualCount = length;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

BYTE* CallFrame::MemoryIncrement(PBYTE pMemory, PFORMAT_STRING pFormat, BOOL fCheckFrom)
/* Returns a memory pointer incremeted past a complex data type.  This routine
   is also overloaded to compute the size of a complex data type by passing
   a NULL memory pointer.

   Return value: A memory pointer incremented past the complex type.  If a NULL pMemory
   was passed in then the returned value is the size of the complex type.
*/
{
    long Elements;
    long ElementSize;

    switch (*pFormat)
    {
        // Structs
        //
    case FC_STRUCT :
    case FC_PSTRUCT :
    case FC_HARD_STRUCT :
        pMemory += *((ushort *)(pFormat + 2));
        break;

    case FC_CSTRUCT :
    case FC_CVSTRUCT :
        pMemory += *((ushort *)(pFormat + 2));
        
        // Get conformant array or string description.
        pFormat += 4;
        pFormat += *((signed short *)pFormat);

        // Get the memory pointer past the conformant array.
        pMemory = MemoryIncrement(pMemory, pFormat, fCheckFrom);
        break;

    case FC_BOGUS_STRUCT :
        pMemory += *((ushort *)(pFormat + 2));
            
        pFormat += 4;

        // Check for a conformant array or string in the struct.
        if ( *((signed short *)pFormat) )
        {
            pFormat += *((signed short *)pFormat);

            // Get the memory pointer past the conformant array.
            pMemory = MemoryIncrement(pMemory, pFormat, fCheckFrom);
        }
        break;

        // Unions
        //
    case FC_ENCAPSULATED_UNION :
        pMemory += HIGH_NIBBLE(pFormat[1]);
        pMemory += *((ushort *)(pFormat + 2));
        break;

    case FC_NON_ENCAPSULATED_UNION :
        // Go to the size/arm description.
        pFormat += 6;
        pFormat += *((signed short *)pFormat);
        
        pMemory += *((ushort *)pFormat);
        break;

        // Arrays
        //
    case FC_SMFARRAY :
    case FC_SMVARRAY :
        pMemory += *((ushort *)(pFormat + 2));
        break;

    case FC_LGFARRAY :
    case FC_LGVARRAY :
        pMemory += *((ulong UNALIGNED *)(pFormat + 2));
        break;

    case FC_CARRAY:
    case FC_CVARRAY:
        pMemory += *((ushort *)(pFormat + 2)) * ComputeConformance(pMemory, pFormat, fCheckFrom);
        break;

    case FC_BOGUS_ARRAY :
    {
        ULONG cElements;

        if (*((long UNALIGNED *)(pFormat + 4)) == 0xffffffff)
        {
            cElements = *((ushort *)(pFormat + 2));
        }
        else
        {
            if (m_pArrayInfo && m_pArrayInfo->MaxCountArray && (m_pArrayInfo->MaxCountArray == m_pArrayInfo->BufferConformanceMark))
            {
                cElements = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
            }
            else
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormat, fCheckFrom);
            }
        }

        // Go to the array element's description.
        pFormat += 12;

        // 
        // Get the size of one element.
        //
        ULONG cbElementSize;
        switch (*pFormat)
        {
        case FC_ENUM16 :    cbElementSize = sizeof(int);    break;

        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :        cbElementSize = sizeof(void*);  break;

        case FC_EMBEDDED_COMPLEX :
        {
            // It's some complicated thingy.
            //
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ((*pFormat == FC_TRANSMIT_AS) || (*pFormat == FC_REPRESENT_AS) || (*pFormat == FC_USER_MARSHAL))
            {
                cbElementSize = *((ushort *)(pFormat + 4)); // Get the presented type size.
            }
            else
            {
                if (m_pArrayInfo) m_pArrayInfo->Dimension++;
                cbElementSize = PtrToUlong(MemoryIncrement(pMemory, pFormat, fCheckFrom)) - PtrToUlong(pMemory);
                if (m_pArrayInfo) m_pArrayInfo->Dimension--;
            }
        }
        break;

        default:
        {
            if (IS_SIMPLE_TYPE(*pFormat))
            {
                cbElementSize = SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;
            }
            NOTREACHED();
            return 0;
        }
        }

        pMemory += cElements * cbElementSize; 
    }
    break;

    //
    // String arrays (a.k.a. non-conformant strings).
    //
    case FC_CSTRING :
    case FC_BSTRING :
    case FC_WSTRING :
        pMemory += *((ushort *)(pFormat + 2))   *  ((*pFormat == FC_WSTRING) ? sizeof(wchar_t) : sizeof(char));
        break;

    case FC_SSTRING :
        pMemory += pFormat[1] * *((ushort *)(pFormat + 2));
        break;

        //
        // Sized conformant strings.
        //
    case FC_C_CSTRING:
    case FC_C_BSTRING:
    case FC_C_WSTRING:
    {
        ULONG cElements;
        if (pFormat[1] == FC_STRING_SIZED)
        {
            if (m_pArrayInfo && m_pArrayInfo->MaxCountArray &&(m_pArrayInfo->MaxCountArray == m_pArrayInfo->BufferConformanceMark))
            {
                cElements = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
            }
            else
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormat, fCheckFrom);
            }
            pMemory += cElements * ( (*pFormat == FC_C_WSTRING) ? sizeof(wchar_t) : sizeof(char) );
        }
        else
        {
            // An unsized string; that is, a NULL-terminated string. We shouldn't be calling 
            // MemoryIncrement on these!
            //
            NOTREACHED();
            pMemory += sizeof(PVOID);
        }
    }
    break;

    case FC_C_SSTRING:
    {
        ULONG cElements;
        if (m_pArrayInfo && m_pArrayInfo->MaxCountArray && (m_pArrayInfo->MaxCountArray == m_pArrayInfo->BufferConformanceMark))
        {
            cElements = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
        }
        else
        {
            cElements = (ULONG)ComputeConformance(pMemory, pFormat, fCheckFrom);
        }
        pMemory += cElements * pFormat[1];
    }
    break;


    case FC_TRANSMIT_AS :
    case FC_REPRESENT_AS :
    case FC_USER_MARSHAL :
        pMemory += *((ushort *)(pFormat + 4));  // Get the presented type size.
        break;

    case FC_BYTE_COUNT_POINTER:
        //
        // ???? REVIEW ????
        //
        // Should only hit this case when called from NdrSrvOutInit(). In this case it's the 
        // total byte count allocation size we're looking for.
        //
        pMemory += ComputeConformance(pMemory, pFormat, fCheckFrom);
        break;

    case FC_IP :
        pMemory += sizeof(void *);
        break;

    default:
        NOTREACHED();
        return 0;
    }

    return pMemory;
}

BOOL CallFrame::IsSafeArray(PFORMAT_STRING pFormat) const
{
    ASSERT(pFormat[0] == FC_USER_MARSHAL);

    USHORT iquad = *(USHORT *)(pFormat + 2);
    const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

    return (g_oa.IsSAFEARRAY(rgQuad[iquad]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\callframeinternal.c ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrameInternal.c
//
// Make sure that the global variable names used in dlldata.c
// don't conflict with those in other places. 
//
#define aProxyFileList          CallFrameInternal_aProxyFileList
#define gPFactory               CallFrameInternal_gPFactory
#define GetProxyDllInfo         CallFrameInternal_GetProxyDllInfo
#define hProxyDll               CallFrameInternal_hProxyDll
#define _purecall               CallFrameInternal__purecall
#define CStdStubBuffer_Release  CallFrameInternal_CStdStubBuffer_Release
#define CStdStubBuffer2_Release CallFrameInternal_CStdStubBuffer2_Release
#define UserMarshalRoutines     CallFrameInternal_UserMarshalRoutines
#define Object_StubDesc         CallFrameInternal_Object_StubDesc

#define __MIDL_ProcFormatString CallFrameInternal___MIDL_ProcFormatString
#define __MIDL_TypeFormatString CallFrameInternal___MIDL_TypeFormatString
#if defined(_WIN64)
#define CLEANLOCALSTORAGE_UserSize64        CLEANLOCALSTORAGE_UserSize
#define CLEANLOCALSTORAGE_UserMarshal64     CLEANLOCALSTORAGE_UserMarshal
#define CLEANLOCALSTORAGE_UserUnmarshal64   CLEANLOCALSTORAGE_UserUnmarshal
#define CLEANLOCALSTORAGE_UserFree64        CLEANLOCALSTORAGE_UserFree
#endif

#include "callframeimpl_i.c"

//////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

#define IRpcStubBufferVtbl_DEFINED

#include "callframeinternal_p.c"

#pragma data_seg(".data") 

#include "callframeinternal_dlldata.c" 

//
// If inside ole32.dll, then we don't need the definitions of these IIDs,
// they're defined already....
//
#ifndef _OLE32_

#include "callframeinternal_i.c"

#else 

// The only thing we need is IID_IDispatch_In_Memory, so here it is.
const IID IID_IDispatch_In_Memory = {0x83FB5D85,0x2339,0x11d2,{0xB8,0x9D,0x00,0xC0,0x4F,0xB9,0x61,0x8A}};

#endif

//////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

#if defined(KERNELMODE) && 0

#include "comps.h"

HRESULT ComPs_NdrDllGetClassObject(
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer)
    {
    return N(ComPs_NdrDllGetClassObject)(rclsid, riid, ppv, pProxyFileList, pclsid, pPSFactoryBuffer);
    }

HRESULT ComPs_NdrDllCanUnloadNow(IN CStdPSFactoryBuffer * pPSFactoryBuffer)
    {
    return N(ComPs_NdrDllCanUnloadNow)(pPSFactoryBuffer);
    }

long ComPs_NdrStubCall2(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    )
    {
    return N(ComPs_NdrStubCall2)(pThis, pChannel, pRpcMsg, pdwStubPhase);
    }

void ComPs_NdrStubForwardingFunction(IRpcStubBuffer*p1, IRpcChannelBuffer*p2, PRPC_MESSAGE pmsg, DWORD* pdwStubPhase)
    {
    N(ComPs_NdrStubForwardingFunction)(p1, p2, pmsg, pdwStubPhase);
    }

CLIENT_CALL_RETURN ComPs_NdrClientCall2_va(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, va_list va)
    {
    return N(ComPs_NdrClientCall2_va)(pStubDescriptor, pFormat, va);
    }


HRESULT ComPs_CStdStubBuffer_QueryInterface(IRpcStubBuffer *This, REFIID iid, void** ppv)
    {
    return N(ComPs_CStdStubBuffer_QueryInterface)(This, iid, ppv);
    }
ULONG ComPs_CStdStubBuffer_AddRef(IRpcStubBuffer *This)
    {
    return N(ComPs_CStdStubBuffer_AddRef)(This);
    }
ULONG ComPs_NdrCStdStubBuffer_Release(IRpcStubBuffer *This, IPSFactoryBuffer* pPSF)
    {
    return N(ComPs_NdrCStdStubBuffer_Release)(This, pPSF);
    }
ULONG ComPs_NdrCStdStubBuffer2_Release(IRpcStubBuffer *This, IPSFactoryBuffer* pPSF)
    {
    return N(ComPs_NdrCStdStubBuffer2_Release)(This, pPSF);
    }



HRESULT ComPs_CStdStubBuffer_Connect(IRpcStubBuffer *This, IUnknown *pUnkServer)
    {
    return N(ComPs_CStdStubBuffer_Connect)(This, pUnkServer);
    }
void ComPs_CStdStubBuffer_Disconnect(IRpcStubBuffer *This)
    {
    N(ComPs_CStdStubBuffer_Disconnect)(This);
    }
HRESULT ComPs_CStdStubBuffer_Invoke(IRpcStubBuffer *This, RPCOLEMESSAGE *pRpcMsg, IRpcChannelBuffer *pRpcChannelBuffer)
    {
    return N(ComPs_CStdStubBuffer_Invoke)(This, pRpcMsg, pRpcChannelBuffer);
    }
IRpcStubBuffer* ComPs_CStdStubBuffer_IsIIDSupported(IRpcStubBuffer *This, REFIID riid)
    {
    return N(ComPs_CStdStubBuffer_IsIIDSupported)(This, riid);
    }
ULONG ComPs_CStdStubBuffer_CountRefs(IRpcStubBuffer *This)
    {
    return N(ComPs_CStdStubBuffer_CountRefs)(This);
    }
HRESULT ComPs_CStdStubBuffer_DebugServerQueryInterface(IRpcStubBuffer *This, void **ppv)
    {
    return N(ComPs_CStdStubBuffer_DebugServerQueryInterface)(This, ppv);
    }
void ComPs_CStdStubBuffer_DebugServerRelease(IRpcStubBuffer *This, void *pv)
    {
    N(ComPs_CStdStubBuffer_DebugServerRelease)(This, pv);
    }


HRESULT ComPs_IUnknown_QueryInterface_Proxy(IUnknown* This, REFIID riid, void**ppvObject)
    {
    return N(ComPs_IUnknown_QueryInterface_Proxy)(This, riid, ppvObject);
    }
ULONG ComPs_IUnknown_AddRef_Proxy(IUnknown* This)
    {
    return N(ComPs_IUnknown_AddRef_Proxy)(This);
    }
ULONG ComPs_IUnknown_Release_Proxy(IUnknown* This)
    {
    return N(ComPs_IUnknown_Release_Proxy)(This);
    }




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\common.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// common.h
//
#ifndef __COMMON_H__
#define __COMMON_H__

// On WIN64 the current headers or build system let this warning through.
// For 32 bit builds this warning is demoted from level 3 to 4 in warning.h.
#ifdef _WIN64
#pragma warning(4:4509)   // use of SEH with destructor
#endif

#define STDCALL __stdcall
#define NTKECOM

#define TRAP_HRESULT_ERRORS

///////////////////////////////////////////////////////////////////////////////////
//
// Control of whether we turn on legacy and / or typelib-driven interceptor support

#define ENABLE_INTERCEPTORS_LEGACY      (TRUE)
#define ENABLE_INTERCEPTORS_TYPELIB     (TRUE)

///////////////////////////////////////////////////////////////////////////////////
//
// What key do we look for interface helpers under? We allow independent, separate
// registration for user mode and kernel mode.
//
#ifndef KERNELMODE
    #define PSCLSID_KEY_NAME                L"ProxyStubClsid32"
    #define INTERFACE_HELPER_VALUE_NAME     L"InterfaceHelperUser"
#else
    #define PSCLSID_KEY_NAME                L"ProxyStubClsidKernel"
    #define INTERFACE_HELPER_VALUE_NAME     L"InterfaceHelperKernel"
#endif

#define PS_CLASS_NAME                       L"Interface Proxy Stub"

#define INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME           L"InterfaceHelperDisableAll"
#define INTERFACE_HELPER_DISABLE_TYPELIB_VALUE_NAME       L"InterfaceHelperDisableTypeLib"
#define INTERFACE_HELPER_DISABLE_ALL_FOR_OLE32_VALUE_NAME L"InterfaceHelperDisableAllForOle32"

///////////////////////////////////////////////////////////////////////////////////
//
// Tracing support

#define TAG                 "CallFrame"
#define TRACE_COPY          0x40000000
#define TRACE_FREE          0x20000000
#define TRACE_MARSHAL       0x10000000
#define TRACE_UNMARSHAL     0x08000000
#define TRACE_MEMORY        0x04000000
#define TRACE_TYPEGEN       0x02000000
#define TRACE_ANY           (0xFFFFFFFF)


///////////////////////////////////////////////////////////////////////////////////
//
// Miscellany



typedef unsigned char  uchar;
typedef unsigned short ushort;
typedef unsigned int   uint;
typedef unsigned long  ulong;

#define GUID_CCH    39 // length of a printable GUID, with braces & trailing NULL

///////////////////////////////////////////////////////////////////////////////////
//
// 

#include "txfcommon.h"
#include "oainternalrep.h"
#include "txfaux.h"

typedef struct tagCStdPSFactoryBuffer CStdPSFactoryBuffer;

#include "TxfRpcProxy.h"    // must be before kominternal.h
#include "kominternal.h"

//
// Internal CLSCTX used for loading Proxy/Stub DLLs. Specifying
// this class context overrides thread model comparisons in 
// certain (all?) cases.
//
#define CLSCTX_PS_DLL                 0x80000000

#include "misc.h"
#include "registry.h"
#include "CallObj.h"
#include "vtable.h"


///////////////////////////////////////////////////////////////////////////////////
//
// Memory managment, with tracing

#ifdef _DEBUG
    inline PVOID TracedAlloc_(size_t cb, PVOID pvReturnAddress)
        {
        PVOID pv;
        pv = AllocateMemory_(cb, PagedPool, pvReturnAddress);
        DebugTrace(TRACE_MEMORY, TAG, "0x%08x: allocated 0x%02x from task allocator", pv, cb);
        return pv;
        }
    inline PVOID TracedAlloc(size_t cb)
        {
        return TracedAlloc_(cb, _ReturnAddress());
        }
#else
    inline PVOID TracedAlloc(size_t cb)
        {
        return AllocateMemory(cb);
        }
#endif

inline void TracedFree(PVOID pv)
    {
    #ifdef _DEBUG
        if (pv)
            {
            DebugTrace(TRACE_MEMORY, TAG, "                                                   0x%08x: freeing to task allocator", pv);
            }
    #endif
    FreeMemory(pv);
    }

///////////////////////////////////////////////////////////////////////////////////


#include <ndrtoken.h>
#include <ndrmisc.h>

#ifndef Oi_OBJ_USE_V2_INTERPRETER
#define Oi_OBJ_USE_V2_INTERPRETER               0x20
#endif

#include "comps.h"
#include "stublessclient.h"
#include "forwarder.h"

#include "InterfaceProxy.h"
#include "InterfaceStub.h"
#include "oleautglue.h"
#include "metadata.h"

class Interceptor;

#include "CallFrame.h"
#include "Interceptor.h"

#include "CallFrameInline.h"

//////////////////////////////////////////////////////////////////////////
//
// Support for Invoking
//
#if defined(_IA64_)
    extern     void  establishF8_15(double f8, double f9, double f10, double f11, 
                                    double f12, double f13, double f14, double f15);
    extern     void* pvGlobalSideEffect;
    extern "C" void* getSP (int r32, int r33, int r34, int r35, int r36, int r37, int r38, int r39);
#endif

//////////////////////////////////////////////////////////////////////////
//
// Leak tracing support
//
#ifdef _DEBUG
    extern "C" void ShutdownCallFrame();
#endif

#ifndef KERNELMODE
    void FreeTypeInfoCache();
#endif

void FreeMetaDataCache();


//////////////////////////////////////////////////////////////////////////
//
// Miscellaneous macros
//
#define PCHAR_LV_CAST   *(char **)&
#define PSHORT_LV_CAST  *(short **)&
//#define PLONG_LV_CAST   *(long **)&
#define PHYPER_LV_CAST  *(hyper **)&

#define PUSHORT_LV_CAST *(unsigned short **)&
//#define PULONG_LV_CAST  *(unsigned long **)&

// This is a conversion macro for WIN64.  It is defined here so that
// It works on 32 bit builds.
#ifndef LongToHandle
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
#endif

//////////////////////////////////////////////////////////////////////////
//
// Name "proxy file list" that we use internally here as our support engine
// See also CallFrameInternal.c
//
extern "C" const ProxyFileInfo * CallFrameInternal_aProxyFileList[];

//////////////////////////////////////////////////////////////////////////
//
// Flag as to whether this DLL is detaching from the process. Implemented
// in txfaux/init.cpp
//
#ifndef KERNELMODE
extern BOOL g_fProcessDetach;
#endif

#endif // end #ifndef __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\cltcall.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// cltcall.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"

#include <debnot.h>

// see ndrp.h
#ifndef EXCEPTION_FLAG
#define EXCEPTION_FLAG  \
            ( (!(RpcFlags & RPCFLG_ASYNCHRONOUS)) &&        \
              (!InterpreterFlags.IgnoreObjectException) &&  \
              (StubMsg.dwStubPhase != PROXY_SENDRECEIVE) )
#endif

/////////////////////////////////////////////////////////////////////////
//
// TODO: Make this more fully use RPC code, instead of duplicating it 
//       here.
//
/////////////////////////////////////////////////////////////////////////

CLIENT_CALL_RETURN __stdcall N(ComPs_NdrClientCall2_va)(
// Invoke a marshalling call 
        PMIDL_STUB_DESC pStubDescriptor,
        PFORMAT_STRING  pFormat,
        va_list         ArgList
        )
{
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    PFORMAT_STRING              pFormatParam, pHandleFormatSave;
    CLIENT_CALL_RETURN          ReturnValue;
    ulong                       ProcNum, RpcFlags;
    uchar *                     pArg;
    uchar *                     StartofStack;
    void *                      pThis;
    handle_t                    Handle;
    handle_t                    SavedGenericHandle = 0;
    uchar                       HandleType;
    INTERPRETER_FLAGS           InterpreterFlags;
    INTERPRETER_OPT_FLAGS       OptFlags;
    PPARAM_DESCRIPTION          Params;
    long                        NumberParams;
    long                        n;
    PFORMAT_STRING              pNewProcDescr;

/*#if defined( NDR_PIPE_SUPPORT )
    NDR_PIPE_DESC               PipeDesc;
    NDR_PIPE_MESSAGE            PipeMsg[ PIPE_MESSAGE_MAX ];
#endif*/

#ifdef _PPC_
    long iFloat = 0;
#endif // _PPC_

    ReturnValue.Pointer = 0;

    //
    // Get the address of the stack where the parameters are.
    //
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar*)GET_STACK_START(ArgList);

    HandleType = *pFormat++;

    InterpreterFlags = *((PINTERPRETER_FLAGS)pFormat++);

    StubMsg.FullPtrXlatTables = 0;

    if ( InterpreterFlags.HasRpcFlags )
        {
        RpcFlags = *((ulong UNALIGNED *)pFormat);
        pFormat += sizeof(ulong);
        }
    else
        RpcFlags = 0;

    ProcNum = *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    // Skip the stack size.
    pFormat += 2;

    pHandleFormatSave = pFormat;

    //
    // Set Params and NumberParams before a call to initialization.
    //

    pNewProcDescr = pFormat;

    if ( ! HandleType )
        {
        // explicit handle

        pNewProcDescr += ((*pFormat == FC_BIND_PRIMITIVE) ?  4 :  6);
        }

    OptFlags = *((PINTERPRETER_OPT_FLAGS) &pNewProcDescr[4]);
    NumberParams = pNewProcDescr[5];

    //
    // Parameter descriptions are nicely spit out by MIDL.
    //
    Params = (PPARAM_DESCRIPTION) &pNewProcDescr[6];

    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {
            BOOL fRaiseExcFlag;
/*
#if defined( NDR_OLE_SUPPORT )
            if ( InterpreterFlags.ObjectProc ) */
                { 
                pThis = *(void **)StartofStack;

                NdrProxyInitialize( pThis,
                                    &RpcMsg,
                                    &StubMsg,
                                    pStubDescriptor,
                                    ProcNum );

                SetMarshalFlags(&StubMsg, MSHLFLAGS_NORMAL);
                } /*
            else
#endif
                {
                NdrClientInitializeNew( &RpcMsg,
                                        &StubMsg,
                                        pStubDescriptor,
                                        (uint) ProcNum );

                if ( HandleType )
                    {
                    //
                    // We have an implicit handle.
                    //
                    Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                    HandleType,
                                                    &SavedGenericHandle);
                    }
                else
                    {
                    Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                    StartofStack,
                                                    pFormat,
                                                    &SavedGenericHandle );
                    }
                } */

            //if ( InterpreterFlags.FullPtrUsed )
            //    StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );

            //if ( InterpreterFlags.RpcSsAllocUsed )
            //    NdrRpcSmSetClientToOsf( &StubMsg );

            // Set Rpc flags after the call to client initialize.
            StubMsg.RpcMsg->RpcFlags = RpcFlags;

/*#if defined( NDR_PIPE_SUPPORT )
            if ( OptFlags.HasPipes )
                NdrPipesInitialize( & StubMsg,
                                    (PFORMAT_STRING) Params,
                                    & PipeDesc,
                                    & PipeMsg[0],
                                    StartofStack,
                                    NumberParams );
#endif*/

            // Must do this before the sizing pass!
            StubMsg.StackTop = StartofStack;


            //
            // ----------------------------------------------------------------
            // Sizing Pass.
            // ----------------------------------------------------------------
            //

            //
            // Get the compile time computed buffer size.
            //
            StubMsg.BufferLength = *((ushort *)pNewProcDescr);

            //
            // Check ref pointers and do object proc [out] zeroing.
            //

            fRaiseExcFlag = FALSE;

            for ( n = 0; n < NumberParams; n++ )
                {
                pArg = StartofStack + Params[n].StackOffset;

                if ( Params[n].ParamAttr.IsSimpleRef )
                    {
                    // We cannot raise the exception here,
                    // as some out args may not be zeroed out yet.
                    
                    if ( ! *((uchar **)pArg) )
                        fRaiseExcFlag = TRUE;
                    }

                //
                // In object procs we have to zero out all [out]
                // parameters.  We do the basetype check to cover the
                // [out] simple ref to basetype case.
                //
                if ( /* InterpreterFlags.ObjectProc && */
                     ! Params[n].ParamAttr.IsIn &&
                     ! Params[n].ParamAttr.IsReturn &&
                     ! Params[n].ParamAttr.IsBasetype )
                    {
                    pFormatParam = pStubDescriptor->pFormatTypes +
                                   Params[n].TypeOffset;

                    NdrClientZeroOut(
                        &StubMsg,
                        pFormatParam,
                        *(uchar **)pArg );
                    }
                }

            if ( fRaiseExcFlag )
                RpcRaiseException( RPC_X_NULL_REF_POINTER );

            //
            // Skip buffer size pass if possible.
            //
            if ( ! OptFlags.ClientMustSize )
                goto DoGetBuffer;

            // Compiler prevents variable size non-pipe args for NT v.4.0.

            if ( OptFlags.HasPipes )
                RpcRaiseException( RPC_X_WRONG_PIPE_VERSION );

            for ( n = 0; n < NumberParams; n++ )
                {
                if ( ! Params[n].ParamAttr.IsIn ||
                     ! Params[n].ParamAttr.MustSize )
                    continue;

                //
                // Note : Basetypes will always be factored into the
                // constant buffer size emitted by in the format strings.
                //

                pFormatParam = pStubDescriptor->pFormatTypes +
                               Params[n].TypeOffset;

                pArg = StartofStack + Params[n].StackOffset;

                if ( ! Params[n].ParamAttr.IsByValue )
                    pArg = *((uchar **)pArg);

				NdrTypeSize
		        ( &StubMsg,
		          pArg,
		          pFormatParam );
                }

DoGetBuffer:
            //
            // Do the GetBuffer.
            //
/*          if ( (HandleType == FC_AUTO_HANDLE) &&
                 (! InterpreterFlags.ObjectProc) )
                {
                NdrNsGetBuffer( &StubMsg,
                                StubMsg.BufferLength,
                                Handle );
                }
            else
                {
#if defined( NDR_OLE_SUPPORT )
                if ( InterpreterFlags.ObjectProc ) */
                    NdrProxyGetBuffer( pThis, &StubMsg ); /*
                else
#endif

#if defined( NDR_PIPE_SUPPORT )
                    if ( OptFlags.HasPipes )
                        NdrGetPipeBuffer( &StubMsg,
                                          StubMsg.BufferLength,
                                          Handle );
                    else
#endif
                        NdrGetBuffer( &StubMsg,
                                      StubMsg.BufferLength,
                                      Handle );
                } */

            Win4Assert( StubMsg.fBufferValid && "Invalid buffer" );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            for ( n = 0; n < NumberParams; n++ )
                {
                if ( ! Params[n].ParamAttr.IsIn  ||
                     Params[n].ParamAttr.IsPipe )
                    continue;

                pArg = StartofStack + Params[n].StackOffset;

                if ( Params[n].ParamAttr.IsBasetype )
                    {
                    //
                    // Check for pointer to basetype.
                    //
                    if ( Params[n].ParamAttr.IsSimpleRef )
                        pArg = *((uchar **)pArg);
                     
#ifdef _ALPHA_
                    else if((Params[n].SimpleType.Type == FC_FLOAT) &&
                            (n < 5))
                        {
                        //Special case for top-level float on Alpha.
                        //Copy the parameter from the floating point area to
                        //the argument buffer. Convert double to float.
                        *((float *) pArg) = (float) *((double *)(pArg - 48));
                        }
                    else if((Params[n].SimpleType.Type == FC_DOUBLE) &&
                            (n < 5))
                        {
                        //Special case for top-level double on Alpha.
                        //Copy the parameter from the floating point area to
                        //the argument buffer.
                        *((double *) pArg) = *((double *)(pArg - 48));
                        }
#endif //_ALPHA_
#ifdef _PPC_
                    //Special case for top-level float on PowerPC.
                    else if(Params[n].SimpleType.Type == FC_FLOAT &&
                            iFloat < 13)
                        {
                        //Special case for top-level float on PowerPC.
                        //Copy the parameter from the floating point area to
                        //the argument buffer. Convert double to float.
                        *((float *) pArg) = ((double *)(StartofStack - 152))[iFloat];
                        iFloat++;
                        }
                    //Special case for top-level double on PowerPC.
                    else if(Params[n].SimpleType.Type == FC_DOUBLE &&
                            iFloat < 13)
                        {
                        //Special case for top-level float on PowerPC.
                        //Copy the parameter from the floating point area to
                        //the argument buffer.
                        *((double *) pArg) = ((double *)(StartofStack - 152))[iFloat];
                        iFloat++;
                        }
#endif

                    if ( Params[n].SimpleType.Type == FC_ENUM16 )
                        {
                        if ( *((int *)pArg) & ~((int)0x7fff) )
                            RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                        #if defined(__RPC_MAC__)
                            // adjust to the right half of the Mac int
                            pArg += 2;
                        #endif

                        }

                    ALIGN( StubMsg.Buffer,
                           SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

                    RtlCopyMemory(
                        StubMsg.Buffer,
                        pArg,
                        (uint)SIMPLE_TYPE_BUFSIZE(Params[n].SimpleType.Type) );

                    StubMsg.Buffer +=
                        SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

                    continue;
                    }

                pFormatParam = pStubDescriptor->pFormatTypes +
                               Params[n].TypeOffset;

                if ( ! Params[n].ParamAttr.IsByValue )
                    pArg = *((uchar **)pArg);

				NdrTypeMarshall( &StubMsg,
								 pArg,
								 pFormatParam );
                }


            //
            // Make the RPC call.
            //
/*          if ( (HandleType == FC_AUTO_HANDLE) &&
                 (!InterpreterFlags.ObjectProc) )
                {
                NdrNsSendReceive( &StubMsg,
                                  StubMsg.Buffer,
                                  (RPC_BINDING_HANDLE *) pStubDescriptor->
                                      IMPLICIT_HANDLE_INFO.pAutoHandle );
                }
            else
                {
#if defined( NDR_OLE_SUPPORT )
                if ( InterpreterFlags.ObjectProc ) */
                    NdrProxySendReceive( pThis, &StubMsg ); /*
                else
#endif

#if defined( NDR_PIPE_SUPPORT )
                    if ( OptFlags.HasPipes )
                        NdrPipeSendReceive( & StubMsg, & PipeDesc );
                    else
#endif
                        NdrSendReceive( &StubMsg, StubMsg.Buffer );
                } */

            //
            // Do endian/floating point conversions if necessary.
            //
            if ( (RpcMsg.DataRepresentation & 0X0000FFFFUL) !=
                  NDR_LOCAL_DATA_REPRESENTATION )
                {
                NdrConvert2( &StubMsg,
                             (PFORMAT_STRING) Params,
                             NumberParams );
                }

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            for ( n = 0; n < NumberParams; n++ )
                {
                if ( ! Params[n].ParamAttr.IsOut  ||
                     Params[n].ParamAttr.IsPipe )
                    continue;

                if ( Params[n].ParamAttr.IsReturn )
                    pArg = (uchar *) &ReturnValue;
                else
                    pArg = StartofStack + Params[n].StackOffset;

                //
                // This is for returned basetypes and for pointers to
                // basetypes.
                //
                if ( Params[n].ParamAttr.IsBasetype )
                    {
                    //
                    // Check for a pointer to a basetype.
                    //
                    if ( Params[n].ParamAttr.IsSimpleRef )
                        pArg = *((uchar **)pArg);

                    if ( Params[n].SimpleType.Type == FC_ENUM16 )
                        {
                        *((int *)(pArg)) = *((int *)pArg) & ((int)0x7fff) ;

                        #if defined(__RPC_MAC__)
                            // Adjust to the less significant Mac short,
                            // both for params and ret value.

                            pArg += 2;
                        #endif
                        }

                    #if defined(__RPC_MAC__)

                        if ( Params[n].ParamAttr.IsReturn )
                            {
                            // Adjust to the right spot of the Mac long
                            // only for rets; params go by the stack offset.

                            if ( FC_BYTE <= Params[n].SimpleType.Type  &&
                                   Params[n].SimpleType.Type <= FC_USMALL )
                                pArg += 3;
                            else
                            if ( FC_WCHAR <= Params[n].SimpleType.Type  &&
                                  Params[n].SimpleType.Type <= FC_USHORT )
                                pArg += 2;
                            }
                    #endif

                    ALIGN(
                        StubMsg.Buffer,
                        SIMPLE_TYPE_ALIGNMENT(Params[n].SimpleType.Type) );

                    RtlCopyMemory(
                        pArg,
                        StubMsg.Buffer,
                        (uint)SIMPLE_TYPE_BUFSIZE(Params[n].SimpleType.Type) );

                    StubMsg.Buffer +=
                        SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

                    continue;
                    }

                pFormatParam = pStubDescriptor->pFormatTypes +
                               Params[n].TypeOffset;

                //
                // Transmit/Represent as can be passed as [out] only, thus
                // the IsByValue check.
                //
				NdrTypeUnmarshall( &StubMsg,
								   Params[n].ParamAttr.IsByValue ? &pArg : (uchar **) pArg,
								   pFormatParam,
								   FALSE );
                }
            }
        RpcExcept( EXCEPTION_FLAG )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

/*#if defined( NDR_OLE_SUPPORT )
            //
            // In OLE, since they don't know about error_status_t and wanted to
            // reinvent the wheel, check to see if we need to map the exception.
            // In either case, set the return value and then try to free the
            // [out] params, if required.
            //
            if ( InterpreterFlags.ObjectProc ) */
                {
                ReturnValue.Simple = NdrProxyErrorHandler(ExceptionCode);

                //
                // Set the Buffer endpoints so the NdrFree routines work.
                //
                StubMsg.BufferStart = 0;
                StubMsg.BufferEnd   = 0;

                for ( n = 0; n < NumberParams; n++ )
                    {
                    //
                    // Skip everything but [out] only parameters.  We make
                    // the basetype check to cover [out] simple ref pointers
                    // to basetypes.
                    //
                    if ( Params[n].ParamAttr.IsIn ||
                         Params[n].ParamAttr.IsReturn ||
                         Params[n].ParamAttr.IsBasetype )
                        continue;

                    pArg = StartofStack + Params[n].StackOffset;

                    pFormatParam = pStubDescriptor->pFormatTypes +
                                   Params[n].TypeOffset;

                    NdrClearOutParameters( &StubMsg,
                                           pFormatParam,
                                           *((uchar **)pArg) );
                    }
                } /*
            else
#endif  // NDR_OLE_SUPPORT
                if ( InterpreterFlags.HasCommOrFault )
                    {
                    NdrClientMapCommFault( &StubMsg,
                                           ProcNum,
                                           ExceptionCode,
                                           &ReturnValue.Simple );
                    }
                else
                    {
                    RpcRaiseException(ExceptionCode);
                    } */
            }
        RpcEndExcept
        }
    RpcFinally
        {
        //if ( StubMsg.FullPtrXlatTables )
        //    NdrFullPointerXlatFree(StubMsg.FullPtrXlatTables);

/*#if defined( NDR_PIPE_SUPPORT )
        if ( OptFlags.HasPipes )
            NdrPipesDone( & StubMsg );
#endif*/

        //
        // Free the RPC buffer.
        //
/*#if defined( NDR_OLE_SUPPORT )
        if ( InterpreterFlags.ObjectProc )
            { */
            NdrProxyFreeBuffer( pThis, &StubMsg ); /*
            } 
        else
#endif
            NdrFreeBuffer( &StubMsg ); */

        //
        // Unbind if generic handle used.  We do this last so that if the
        // the user's unbind routine faults, then all of our internal stuff
        // will already have been freed.
        //
/*      if ( SavedGenericHandle )
            {
            GenericHandleUnbind( pStubDescriptor,
                                 StartofStack,
                                 pHandleFormatSave,
                                 (HandleType) ? IMPLICIT_MASK : 0,
                                 &SavedGenericHandle );
            }
*/      }
    RpcEndFinally

    return ReturnValue;
}

CLIENT_CALL_RETURN RPC_VAR_ENTRY N(ComPs_NdrClientCall2)(
// Invoke a marshalling call 
        PMIDL_STUB_DESC pStubDescriptor,
        PFORMAT_STRING  pFormat,
        ...
        )
    {
    va_list va;
    va_start (va, pFormat);

    CLIENT_CALL_RETURN c = N(ComPs_NdrClientCall2_va)(pStubDescriptor, pFormat, va);

    va_end(va);

    return c;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\compsregistration.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ComPsRegistration.cpp
//
#include "stdpch.h"
#include "common.h"

#include <debnot.h>

//////////////////////////////////////////////////////////////////////////////////////////
//
// Proxy-stub registration utiltiies
//

HRESULT GetProxyStubClsid(const CLSID* pclsid, const ProxyFileInfo ** pProxyFileList, CLSID* pclsidOut)
    {
    HRESULT hr = S_OK;
    //
    // If necessary, use the IID of the first interface as the CLSID.
    //
    for(int i = 0; (pProxyFileList[i] != 0) && (!pclsid); i++)
        {
        for(int j = 0; (pProxyFileList[i]->pProxyVtblList[j] != 0) && (!pclsid); j++)
            {
            pclsid = pProxyFileList[i]->pStubVtblList[j]->header.piid;
            }
        }
    if (pclsid)
        *pclsidOut = *pclsid;
    else
        hr = E_NOINTERFACE;
    return hr;
    }

static inline UNICODE_STRING From(LPCWSTR wsz) 
    {
    UNICODE_STRING u;
    RtlInitUnicodeString(&u, wsz);
    return u;
    }

HRESULT TestRegistryValue(HREG hreg, LPCWSTR wszValueName, LPCWSTR wszTestValue)
// Answer as to whether the indcated registry value exists and is equal to 
// the indicated test value.
{
    HRESULT hr = S_OK;

    PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
    hr = GetRegistryValue(hreg, wszValueName, &pinfo, REG_SZ);
	Win4Assert(pinfo || FAILED(hr));
    if (!hr && pinfo)
	{
        LPWSTR wszExistingValue = StringFromRegInfo(pinfo);
        //
        // If the existing value is in fact our class, then delete the clsid key
        //
        UNICODE_STRING u1 = From(wszExistingValue);
        UNICODE_STRING u2 = From(wszTestValue);
        if (RtlCompareUnicodeString(&u1, &u2, TRUE) == 0)
		{
            hr = S_OK;
		}
        else
		{
            hr = S_FALSE;
		}
        FreeMemory(pinfo);
	}

    return hr;
}


HRESULT RegisterUnregisterInterface
    (
        IN BOOL     fRegister,
        IN HREG     hKeyInterface,
        IN REFIID   riid, 
        IN LPCSTR   szInterfaceName,
        IN LPCWSTR  wszClassID,
        IN long     NumMethods,
        IN BOOL     fMarshal,
        IN BOOL     fCallFrame
    )
    {
    HRESULT hr = S_OK;
    WCHAR wszIID[GUID_CCH];
    StringFromGuid(riid, &wszIID[0]);
    //
    // Open or create the IID key itself
    //
    HREG hKeyIID;
    if (fRegister)
        hr = CreateRegistryKey(&hKeyIID, hKeyInterface, wszIID);
    else
        hr = OpenRegistryKey(&hKeyIID, hKeyInterface, wszIID, KEY_ALL_ACCESS);
    //
    if (!hr)
        {
        /////////////////////////////////////////////////////////////////////////////
        //
        // Add the interface name if we're registering; leave it alone 
        // if we're unregistering.
        // 
        if (!hr && fRegister)
            {
            LPWSTR wszInterfaceName = ToUnicode(szInterfaceName);
            if (wszInterfaceName)
                {
                hr= SetRegistryValue(hKeyIID, L"", wszInterfaceName);
                FreeMemory(wszInterfaceName);
                }
            else
                hr = E_OUTOFMEMORY;
            }
        //
        /////////////////////////////////////////////////////////////////////////////
        //
        // In the marshalling case, create the ProxyStubClsid32 if registering
        // but delete it when unregistering only if it's in fact our class that's
        // registered there in the first place.
        //
        if (!hr && fMarshal)
            {
            HREG hKeyClsid;
            if (fRegister)
                {
                hr = CreateRegistryKey(&hKeyClsid, hKeyIID, PSCLSID_KEY_NAME);
                if (!hr)
                    {
                    // Note the appropriate CLSID
                    hr = SetRegistryValue(hKeyClsid, L"", wszClassID);
                    CloseRegistryKey(hKeyClsid);
                    }
                }
            else
                {
                hr = OpenRegistryKey(&hKeyClsid, hKeyIID, PSCLSID_KEY_NAME, KEY_ALL_ACCESS);
                if (!hr)
                    {
                    if (TestRegistryValue(hKeyClsid, L"", wszClassID) == S_OK)
                        DeleteRegistryKey(hKeyClsid);
                    else
                        CloseRegistryKey(hKeyClsid);
                    }
                //
                hr = S_OK; // In unregister case, we did our best
                }
            }
        //
        /////////////////////////////////////////////////////////////////////////////
        //
        if (!hr && fCallFrame)
            {
            if (fRegister)
                {
                // Make sure that InterfaceHelper exists
                // 
                hr = SetRegistryValue(hKeyIID, INTERFACE_HELPER_VALUE_NAME, wszClassID);
                }
            else
                {
                // Delete InterfaceHelper value if it's equal to us
                //
                if (TestRegistryValue(hKeyIID, INTERFACE_HELPER_VALUE_NAME, wszClassID) == S_OK)
                    {
                    DeleteRegistryValue(hKeyIID, INTERFACE_HELPER_VALUE_NAME);
                    }

                hr = S_OK;
                }
            }
        //
        /////////////////////////////////////////////////////////////////////////////
        //
        CloseRegistryKey(hKeyIID);
        }

    //
    // Ignore errors during unregistration: we did the best we can
    //
    if (!fRegister)
        {
        hr = S_OK;
        }

    return hr;
    }

BOOL IsIidInList(REFIID iid, const IID** rgiid)
    {
    while (rgiid && *rgiid)
        {
        if (iid == **rgiid)
            return TRUE;
        rgiid++;
        }
    return FALSE;
    }


HRESULT RegisterUnregisterProxy(
    IN BOOL                     fRegister,
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN const IID**              rgiidNoCallFrame,
    IN const IID**              rgiidNoMarshal
    )
    {
    HRESULT hr = S_OK;
    //
    // Find the right CLSID
    //
    CLSID clsid;
    hr = GetProxyStubClsid(pclsid, pProxyFileList, &clsid);
    if (!hr)
        {
        // Register/unregister the class
        //
        WCHAR wszClsid[GUID_CCH];
        StringFromGuid(clsid, &wszClsid[0]);

        #ifdef KERNELMODE

            if (fRegister)
                {
                hr = KoRegisterKernelModeClass(clsid, clsid, PS_CLASS_NAME);
                }
            else
                {
                KoUnregisterKernelModeClass(clsid); // Ignore errors: we try our best
                }

        #else

            ClassRegistration c;
            c.clsid             = clsid;
            c.className         = PS_CLASS_NAME;
            c.threadingModel    = L"Both";
            c.hModule           = hDll;

            if (fRegister)
                {
                hr = c.Register();
                }
            else
                {
                c.Unregister(); // Ignore errors: we try our best
                }

        #endif

        if (!hr)
            {
            // Register/unregister the interfaces serviced by this class
            //
            HREG hKeyInterface;
            
            LPCWSTR wszInterface = L"\\Registry\\Machine\\Software\\Classes\\Interface";

            if (fRegister)
                {
                hr = CreateRegistryKey(&hKeyInterface, HREG(), wszInterface);
                }
            else
                {
                hr = OpenRegistryKey(&hKeyInterface, HREG(), wszInterface);
                }

            if (!hr)
                {
                // Iterate over the list of proxy files
                for(int i = 0; pProxyFileList[i] != 0; i++)
                    {
                    //iterate over the list of interfaces in the proxy file
                    for(int j = 0; pProxyFileList[i]->pProxyVtblList[j] != 0; j++)
                        {
                        IID iid = *pProxyFileList[i]->pStubVtblList[j]->header.piid;

                        BOOL fMarshal   = !IsIidInList(iid, rgiidNoMarshal);
                        BOOL fCallFrame = !IsIidInList(iid, rgiidNoCallFrame);

                        HRESULT hr2 = RegisterUnregisterInterface(
                                       fRegister,
                                       hKeyInterface, 
                                       iid, 
                                       pProxyFileList[i]->pNamesArray[j], 
                                       &wszClsid[0],
                                       pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                       fMarshal,
                                       fCallFrame
                                       );

                        if (!!hr2 && !hr)
                            hr = hr2;
                        }
                    }
                CloseRegistryKey(hKeyInterface);
                }
            }
        }

    if (!fRegister)
        {
        hr = S_OK; // Ignore errors: we tried our best
        }

    return hr; 
    }

extern "C" HRESULT RPC_ENTRY N(ComPs_NdrDllRegisterProxy)(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN const IID**              rgiidNoCallFrame,
    IN const IID**              rgiidNoMarshal
    )
    {
    return RegisterUnregisterProxy(TRUE, hDll, pProxyFileList, pclsid, rgiidNoCallFrame, rgiidNoMarshal);
    }

extern "C" HRESULT RPC_ENTRY N(ComPs_NdrDllUnregisterProxy)(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN const IID**              rgiidNoCallFrame,
    IN const IID**              rgiidNoMarshal
    )
    {
    return RegisterUnregisterProxy(FALSE, hDll, pProxyFileList, pclsid, rgiidNoCallFrame, rgiidNoMarshal);
    }

//////////////////////////////////////////////////////////////////////////////////////////
//
// Routines to be called by the registration / unregistraton logic of whatever DLL we
// find ourselves embedded in that do the necessary registration and unregistration of
// the Call Frame Infrastructure itself

extern "C" HRESULT STDCALL RegisterCallFrameInfrastructure()
    {
    HRESULT hr = S_OK;
    //
    // REVIEW: In kernel mode, we should register ourselves as the marshalling engine for IDispatch.
    //
    return hr;
    }

extern "C" HRESULT STDCALL UnregisterCallFrameInfrastructure()
    {
    HRESULT hr = S_OK;

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\comps.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ComPs.cpp
//
#include "stdpch.h"
#include "common.h"

////////////////////////////////////
//
// Data declarations
//

extern const IPSFactoryBufferVtbl CStdPSFactoryBufferVtbl;

////////////////////////////////////

BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList, 
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex)
// Search the ProxyFileInfo and find the specified interface. If the count is specified in the ProxyFileInfo, 
// then the interfaces in the file are sorted by IID.  This means that we can perform a binary  search for the IID.
//
    {
    int 				j;
    BOOL 				fFound 			= FALSE;
	ProxyFileInfo	**	ppProxyFileCur;
	ProxyFileInfo	*	pProxyFileCur;

    //Search the list of proxy files.
    for (ppProxyFileCur = (ProxyFileInfo **) pProxyFileList; (*ppProxyFileCur != 0) && (fFound != TRUE); ppProxyFileCur++)
	    {
	    //Search for the interface proxy vtable.
        pProxyFileCur = *ppProxyFileCur;

        // see if it has a lookup routine already
        if ((pProxyFileCur->TableVersion >= 1) && (pProxyFileCur->pIIDLookupRtn))
			{
			fFound = (*pProxyFileCur->pIIDLookupRtn)(&riid, &j);
			}
		else	
	        {
            // Linear search.
	        for (j = 0; (pProxyFileCur->pProxyVtblList[j] != 0); j++)
		        {
	            if(memcmp(&riid, pProxyFileCur->pStubVtblList[j]->header.piid, sizeof(IID)) == 0)
		            {
	                fFound = TRUE;
		            break;
		            }
		        }
			}
	    }
    
	if (fFound)
		{
        if (ppProxyFileInfo != 0)
            *ppProxyFileInfo = pProxyFileCur;

        if (pIndex != 0)
            *pIndex = j;
		}

    return fFound;
    }

////////////////////////////////////

BOOL FindSharedMethod(const ProxyFileInfo *pProxyFileInfo, REFIID iid, ULONG cMethodsIID, unsigned short dibTargetMethod, IID* piidBase)
// Try to find an interface different from IID that has one of its methods at format string offset 
// dibTargetMethod. If said interface has fewer methods than cMethodsIID, then return it.
// 
    {
    long j;
	for (j = 0; (pProxyFileInfo->pProxyVtblList[j] != 0); j++)
		{
        ULONG cMethods = pProxyFileInfo->pStubVtblList[j]->header.DispatchTableCount;
        if (cMethods < cMethodsIID)
            {
            for (int iMethod = cMethods -1; iMethod >=3; iMethod--)
                {
                unsigned short dibMethod = GetDibProcFormat(pProxyFileInfo, j, iMethod);
                if (dibMethod == dibTargetMethod)
                    {
                    // Found it!
                    //
                    *piidBase = *pProxyFileInfo->pStubVtblList[j]->header.piid;
                    return TRUE;
                    }
                }
            }
		}

    *piidBase = IID_NULL;
    return FALSE;
    }


BOOL GetBaseIID(const ProxyFileInfo ** pProxyFileList, REFIID iid, IID* piidBase)
// Return the base IID for the indicated IID, if said can be computed from the proxy file information
//
    {
    long j;
    const ProxyFileInfo *pProxyFileInfo;
    if (NdrpFindInterface(pProxyFileList, iid, &pProxyFileInfo, &j))
        {
        // We found an entry for this interface. Is it delegated, and so can yield the answer easily?
        // MIDL does this case if the base interface is from a different IDL file. The delegation can
        // also be 'forced': From cgobject.cxx in MIDL:
        //
        // BOOL fForcesDelegation = HasStublessProxies() && !HasItsOwnStublessProxies() && CountMemberFunctions() > 3;
        //
        if ((pProxyFileInfo->pDelegatedIIDs != 0) && (pProxyFileInfo->pDelegatedIIDs[j] != 0))
            {
            *piidBase = *(pProxyFileInfo->pDelegatedIIDs[j]);
            return TRUE;
            }
        //
        // Didn't have a delegation entry for this interface. Maybe we can find another interface that
        // shares a format string offset with us, and which has a fewer number of methods than us. If so,
        // we can use that to find our base.
        //
        ULONG cMethodsInInterface = pProxyFileInfo->pStubVtblList[j]->header.DispatchTableCount;
        //
        // Try each method in the interface in reverse order
        //
        for (int iMethod = cMethodsInInterface-1; iMethod >= 3; iMethod--)
            {
            // Find the format string offset for this iMethod
            //
            unsigned short dibMethod = GetDibProcFormat(pProxyFileInfo, j, iMethod);
            //
            // For the indicated method, try to find another interface that shares that method
            //
            IID iidBase;
            if (FindSharedMethod(pProxyFileInfo, iid, cMethodsInInterface, dibMethod, &iidBase))
                {
                // Because we go in decreasing method order, the first one we find is the immediate base
                //
                *piidBase = iidBase; 
                return TRUE;
                }
            }
        }

    *piidBase = IID_NULL;
    return FALSE;
    }

////////////////////////////////////

inline void NdrpInitializeProxyVtbl(CInterfaceProxyVtbl *pProxyVtbl, ULONG cpfnVtable, BOOL isDelegated)
// Initialize the vtable for the interface proxy of a particular interface
// 
    {
    void **  vtbl       = pProxyVtbl->Vtbl;
    void **  vtblSource = (void**) (isDelegated ? g_ProxyForwarderVtable : g_StublessProxyVtable);
    //
    // In the delegated case, the NDR runtime forcibly set the IUnknown methods to IUnknown_QueryInterface_Proxy,
    // IUnknown_AddRef_Proxy, and IUnknown_Release_Proxy rather than copying them from the source vtable. 
    // This is because in their implementation, ForwardingVtbl / g_ProxyForwarderVtable has junk methods 
    // for it's IUnknown implementation (why, I can't imagine). We, instead, use real methods, in fact, we use 
    // exactly these methods (actually, their equivalent). So we don't have to special case these methods.
    //
    // BTW: Here's a typical CInterfaceProxyVtbl as emited by MIDL:
    //
    //            CINTERFACE_PROXY_VTABLE(11) _ITestThreeProxyVtbl = {
    //                &ITestThree_ProxyInfo,
    //                &IID_ITestThree,
    //                IUnknown_QueryInterface_Proxy,
    //                IUnknown_AddRef_Proxy,
    //                IUnknown_Release_Proxy ,
    //                0 /* (void *)-1 /* ITestTwo::ITestTwoMethodOne */ ,
    //                0 /* (void *)-1 /* ITestTwo::ITestTwoMethodTwo */ ,
    //                0 /* (void *)-1 /* ITestTwo::ITestTwoMethodThree */ ,
    //                (void *)-1 /* ITestThree::ITestThreeMethodOne */ ,
    //                (void *)-1 /* ITestThree::ITestThreeMethodTwo */ ,
    //                (void *)-1 /* ITestThree::ITestThreeMethodThree */ ,
    //                (void *)-1 /* ITestThree::ITestThreeMethodFour */ ,
    //                (void *)-1 /* ITestThree::ITestThreeMethodFive */
    //                };
    //
    for (unsigned iMethod = 0 ; iMethod < cpfnVtable; iMethod++)
        {
        if ((void*)0 == vtbl[iMethod])
            {
            vtbl[iMethod] = vtblSource[iMethod];
            }
        else if ((void*)-1 == vtbl[iMethod])
            {
            vtbl[iMethod] = g_StublessProxyVtable[iMethod];
            }
        }
    }

////////////////////////////////////

inline void NdrpInitializeStubVtbl(CInterfaceStubVtbl *pStubVtbl, BOOL isDelegated)
// Initialize the vtable for the interface stub of a particular interface
    {
    void ** vtbl          = (void **) &pStubVtbl->Vtbl;
    void ** vtblSource    = (isDelegated ? (void**)&CStdStubBuffer2Vtbl : (void**)&CStdStubBufferVtbl );

    for (int i=0; i<sizeof(IRpcStubBufferVtbl)/sizeof(LPVOID); i++)
        {
        if (0 == vtbl[i])
            {
            vtbl[i] = vtblSource[i];
            }
        }
    }

////////////////////////////////////

void NdrpInitializeProxyDll(IN const ProxyFileInfo** pProxyFileList, IN CStdPSFactoryBuffer* pPSFactoryBuffer)
// Initialize the proxy DLL
//
    {
    // We may have already done this previously
    //
    if (pPSFactoryBuffer->lpVtbl == 0) 
        {
        //iterate over the list of proxy files in the proxy DLL.
        for (long iProxyFile = 0; pProxyFileList[iProxyFile] != 0; iProxyFile++)
            {
            const ProxyFileInfo*& pfile = pProxyFileList[iProxyFile];

            //iterate over the list of interfaces in the proxy file.
            for(long j = 0; pfile->pProxyVtblList[j] != 0; j++)
                {
                BOOL isInterfaceDelegated = (pfile->pDelegatedIIDs != 0) && (pfile->pDelegatedIIDs[j] != 0);
                //
                // We don't handle older style proxies, stuff prior to NT 3.51 Beta
                //
                ASSERT(pfile->TableVersion >= 2);
            
                //Initialize the proxy vtbl.
                NdrpInitializeProxyVtbl(pfile->pProxyVtblList[j], 
                                        pfile->pStubVtblList[j]->header.DispatchTableCount,
                                        isInterfaceDelegated
                                        );

                //Initialize the stub vtbl.
                NdrpInitializeStubVtbl(pfile->pStubVtblList[j], isInterfaceDelegated);
                }
            }

        pPSFactoryBuffer->pProxyFileList = pProxyFileList;

        // Set the lpVtbl.  This code is safe for multiple threads.
#ifndef _WIN64
        InterlockedExchange((long *) &pPSFactoryBuffer->lpVtbl, (long) &CStdPSFactoryBufferVtbl);
#else
        InterlockedExchangePointer( (PVOID*)&pPSFactoryBuffer->lpVtbl, (PVOID) &CStdPSFactoryBufferVtbl);
#endif
        }
    }






///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class factory
//
///////////////////////////////////////////////////////////////////////////////////////////////////

class ComPsClassFactory : public IClassFactory, IPSFactoryBuffer
    {
public:
    ////////////////////////////////////////////////////////////
    //
    // IUnknown methods
    //
    ////////////////////////////////////////////////////////////

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
        {
             if (iid == IID_IUnknown || iid == IID_IClassFactory)   { *ppv = (IClassFactory*)this; }
        else if (iid == IID_IPSFactoryBuffer)                       { *ppv = (IPSFactoryBuffer*)this; }
        else { *ppv = NULL; return E_NOINTERFACE; }

        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
        }

    ULONG STDCALL AddRef()  { InterlockedIncrement(&m_crefs); return (m_crefs); }
    ULONG STDCALL Release() { long cRef = InterlockedDecrement(&m_crefs); if (cRef == 0) delete this; return cRef; }

    ////////////////////////////////////////////////////////////
    //
    // IClassFactory methods
    //
    ////////////////////////////////////////////////////////////

    HRESULT STDCALL LockServer (BOOL fLock) { return S_OK; }

    HRESULT STDCALL CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv)
    // Create an instance of an interceptor. It needs to know the m_pProxyFileList
        {
        HRESULT hr = S_OK;
        if (!(ppv && (punkOuter==NULL || iid==IID_IUnknown))) return E_INVALIDARG;
        
        *ppv = NULL;
        Interceptor* pnew = new Interceptor(punkOuter);
        if (pnew)
            {
            pnew->m_pProxyFileList = m_pProxyFileList;

            IUnkInner* pme = (IUnkInner*)pnew;
            if (hr == S_OK)
                {
                hr = pme->InnerQueryInterface(iid, ppv);
                }
            pme->InnerRelease();                // balance starting ref cnt of one    
            }
        else 
            hr = E_OUTOFMEMORY;
    
        return hr;
        }

    ////////////////////////////////////////////////////////////
    //
    // IPSFactoryBuffer methods
    //
    ////////////////////////////////////////////////////////////

    HRESULT STDCALL CreateProxy(IUnknown* punkOuter, REFIID iid, IRpcProxyBuffer** ppProxy, void** ppv)
        {
        return m_pDelegatee->CreateProxy(punkOuter, iid, ppProxy, ppv);
        }

    HRESULT STDCALL CreateStub(REFIID iid, IUnknown* punkServer, IRpcStubBuffer** ppStub)
        {
        return m_pDelegatee->CreateStub(iid, punkServer, ppStub);
        }

    ////////////////////////////////////////////////////////////
    //
    // State / Construction
    //
    ////////////////////////////////////////////////////////////
    
    long                    m_crefs;
    IPSFactoryBuffer*       m_pDelegatee;
    const ProxyFileInfo **  m_pProxyFileList;

    ComPsClassFactory()
        {
        m_crefs = 1;
        m_pDelegatee = NULL;
        m_pProxyFileList = NULL;
        }

    void SetDelegatee(CStdPSFactoryBuffer* pPSFactoryBuffer)
        {
        ASSERT(NULL == m_pDelegatee);
        pPSFactoryBuffer->lpVtbl->QueryInterface((IPSFactoryBuffer*)pPSFactoryBuffer, IID_IPSFactoryBuffer, (void**)&m_pDelegatee);
        ASSERT(m_pDelegatee);
        m_pProxyFileList = pPSFactoryBuffer->pProxyFileList;
        }

    };

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiation
//
///////////////////////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT RPC_ENTRY N(ComPs_NdrDllGetClassObject)(
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer)
    {
    HRESULT hr;
    BOOL    fFound;

    NdrpInitializeProxyDll(pProxyFileList, pPSFactoryBuffer);
    *ppv = NULL;

    // 
    // Figure out if the requested class is in fact our class
    //
    if ((pclsid != 0) && rclsid == *pclsid)
        fFound = TRUE;
    else
        {
        //Search the list of proxy files.
        fFound = NdrpFindInterface(pProxyFileList, rclsid, 0, 0);
        }

    if (fFound != TRUE)
        hr = CLASS_E_CLASSNOTAVAILABLE;
    else
        {
        // Yes it's our class. Instantiate a class factory that can do both IClassFactory and
        // IPSFactoryBuffer. REVIEW: Make this a singleton class factory, cached for speed.
        //
        ComPsClassFactory* pFactory = new ComPsClassFactory;
        if (pFactory)
            {
            pFactory->SetDelegatee(pPSFactoryBuffer);
            hr = pFactory->QueryInterface(riid, ppv);
            pFactory->Release();                                // compensate for starting ref cnt of one
            }
        else
            hr = E_OUTOFMEMORY;            
        }

    return hr;
    }

extern "C" HRESULT RPC_ENTRY N(ComPs_NdrDllCanUnloadNow)(IN CStdPSFactoryBuffer * pPSFactoryBuffer)
    {
    // We don't pretend to be unloadable, as the the DllCanUnloadNow mechanism works poorly at best
    // if at all for free threaded DLLs such as us.
    return S_FALSE;
    }


////////////////////////////////////////////////////////////////////////////////////
//
// Create proxy
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CStdPSFactoryBuffer_CreateProxy
(
    IN  IPSFactoryBuffer *  me,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
)
// Create a proxy for the specified interface
    {
    HRESULT hr  = S_OK;
    *ppv        = NULL;
    *ppProxy    = NULL;

    CStdPSFactoryBuffer* This = (CStdPSFactoryBuffer*)me;

    long j;
    const ProxyFileInfo *pProxyFileInfo;
    //
    // Is the requested interface something that this proxy class supports?
    //
    BOOL fFound = NdrpFindInterface(This->pProxyFileList, riid, &pProxyFileInfo, &j);
    if (fFound)
        {
        BOOL fDelegate = 
            (pProxyFileInfo->pDelegatedIIDs     != 0) && 
            (pProxyFileInfo->pDelegatedIIDs[j]  != 0) && 
           (*pProxyFileInfo->pDelegatedIIDs[j]) != IID_IUnknown;

        IUnknown* punkProxyIdentity = NULL;

        if (fDelegate)
            {
            // Need to delegate to the proxy for the base interface. So need a proxy that can handle same. Create a forwarding guy.
            //
            hr = GenericInstantiator<ForwardingInterfaceProxy>::CreateInstance(punkOuter, IID_IUnknown, (void**)&punkProxyIdentity);
            }
        else
            {
            // Just create a normal proxy for this interface
            //
            hr = GenericInstantiator<InterfaceProxy>::CreateInstance(punkOuter, IID_IUnknown, (void**)&punkProxyIdentity);
            }

        if (!hr)
            {
            // Created the proxy ok; now init it all up
            //
            IInterfaceProxyInit* pInit;
            hr = punkProxyIdentity->QueryInterface(__uuidof(IInterfaceProxyInit), (void**)&pInit);
            if (!hr)
                {
                hr = pInit->Initialize1(&pProxyFileInfo->pProxyVtblList[j]->Vtbl);

                if (!hr && fDelegate)
                    {
                    // Delegation guys need more initialization. 
                    //
                    // REVIEW: The delegatee here was aggregated into us. Should he be?
                    // Probaby not: since we never expose his vtables to the outside world
                    // there's no reason to add the extra complication. Besides, it's likely
                    // there are ref counting bugs lurking in NDR in the aggregated case: see
                    // NdrpCreateProxy in ...\factory.c, ~line 1527 where it dicks with the ref cnt.
                    //
                    // REVIEW REVIEW: Unfortunately, because we don't know our IID's inheritance
                    // chain, in the forwarding case we blind delegate to that interface proxy.
                    // (see ForwardingInterfaceProxy::InnerQueryInterface). So he better be aggregated
                    // into us to get the identity right.
                    //
                    IUnknown*        punkOuterForDelegatee = ForwardingInterfaceProxy::PunkOuterForDelegatee(punkProxyIdentity, punkOuter);

                    IRpcProxyBuffer* pBaseProxyBuffer;
                    void*            pBaseProxy;
                    hr = NdrpCreateProxy(*pProxyFileInfo->pDelegatedIIDs[j], punkOuterForDelegatee, &pBaseProxyBuffer, &pBaseProxy);
                    if (!hr)
                        {
                        hr = pInit->Initialize2(*pProxyFileInfo->pDelegatedIIDs[j], pBaseProxyBuffer, pBaseProxy);

                        pBaseProxyBuffer->Release();

						if (pBaseProxy)
							{
							((IUnknown*)pBaseProxy)->Release();
							}
                        }
                    }

                pInit->Release();
                }
            }

        if (!hr)
            {
            // Everything is (finally) initialized. Give caller back the interfaces he asked for.
            //
            hr = punkProxyIdentity->QueryInterface(riid, ppv);
            if (!hr)
                {
                hr = punkProxyIdentity->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
                }
            }

        ::Release(punkProxyIdentity);
        }
    else
        hr = E_NOINTERFACE;

    if (!!hr)
        {
        if (*ppProxy) { (*ppProxy)->Release(); *ppProxy = NULL; }
        if (*ppv)     { ((IUnknown*)*ppv)->Release(); *ppv = NULL; }
        }

    return hr;
    }


////////////////////////////////////////////////////////////////////////////////////
//
// Create stub
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CStdPSFactoryBuffer_CreateStub
    (
        IN  IPSFactoryBuffer *  me,
        IN  REFIID              riid,
        IN  IUnknown *          punkServer,
        OUT IRpcStubBuffer **   ppStub
    )
    {
    HRESULT hr = S_OK;
    *ppStub    = NULL;

    CStdPSFactoryBuffer* This = (CStdPSFactoryBuffer*)me;

    long j;
    const ProxyFileInfo *pProxyFileInfo;
    //
    // Is the requested interface something that this stub class supports?
    //
    BOOL fFound = NdrpFindInterface(This->pProxyFileList, riid, &pProxyFileInfo, &j);
    if (fFound)
        {
        BOOL fDelegate = 
            (pProxyFileInfo->pDelegatedIIDs     != 0) && 
            (pProxyFileInfo->pDelegatedIIDs[j]  != 0) && 
           (*pProxyFileInfo->pDelegatedIIDs[j]) != IID_IUnknown;

        IUnknown* punkStub = NULL;

        if (fDelegate)
            {
            // Need to delegate to the stub for the base interface. So need a stub that can handle same
            //
            hr = GenericInstantiator<ForwardingInterfaceStub>::CreateInstance(NULL, IID_IUnknown, (void**)&punkStub);
            }
        else
            {
            // Just create a normal stub for this interface
            //
            hr = GenericInstantiator<InterfaceStub>::CreateInstance(NULL, IID_IUnknown, (void**)&punkStub);
            }

        if (!hr)
            {
            // Created the stub ok; now init it all up
            //
            IInterfaceStubInit* pInit;
            hr = punkStub->QueryInterface(__uuidof(IInterfaceStubInit), (void**)&pInit);
            if (!hr)
                {
                hr = pInit->Initialize1(&pProxyFileInfo->pStubVtblList[j]->Vtbl);
                if (!hr && fDelegate)
                    {
                    // Delegated stubs need more initialization. 
                    //
                    IRpcStubBuffer* pBaseStubBuffer;
                    hr = NdrpCreateStub(*pProxyFileInfo->pDelegatedIIDs[j], NULL, &pBaseStubBuffer);
                    if (!hr)
                        {
                        hr = pInit->Initialize2(pBaseStubBuffer, *pProxyFileInfo->pDelegatedIIDs[j]);
                        pBaseStubBuffer->Release();
                        }
                    }
                pInit->Release();
                }
            }

        if (!hr)
            {
            // If we initialized successfully, then connect it all up
            //
            hr = punkStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);
            if (!hr && punkServer)
                {
                hr = (*ppStub)->Connect(punkServer);
                if (!hr)    
                    {
                    // all is well
                    }
                else
                    {
                    ::Release(*ppStub);
                    }
                }
            }

        ::Release(punkStub);
        }
    else
        hr = E_NOINTERFACE;

    return hr;
    }



////////////////////////////////////////////////////////////////////////////////////
//
// Other COM plumbing
//
////////////////////////////////////////////////////////////////////////////////////


HRESULT STDMETHODCALLTYPE CStdPSFactoryBuffer_QueryInterface(IPSFactoryBuffer* This, REFIID iid, void** ppv)
    {
    HRESULT hr;
    if (iid == IID_IUnknown || iid == IID_IPSFactoryBuffer)
        {
        *ppv = This;
        This->AddRef();
        hr = S_OK;
        }
    else
        {
        *ppv = 0;
        hr = E_NOINTERFACE;
        }
    return hr;
    }

ULONG STDMETHODCALLTYPE CStdPSFactoryBuffer_AddRef(IPSFactoryBuffer *This)
    {
    return InterlockedIncrement(&((CStdPSFactoryBuffer *) This)->RefCount);
    }

ULONG STDMETHODCALLTYPE CStdPSFactoryBuffer_Release(IPSFactoryBuffer *This)
    {
    ULONG crefs = InterlockedDecrement(&((CStdPSFactoryBuffer *) This)->RefCount);
    if (0 == crefs)
        {
        // We're a static instance: do nothing
        }
    return crefs;
    }

const IPSFactoryBufferVtbl CStdPSFactoryBufferVtbl = 
    {
    CStdPSFactoryBuffer_QueryInterface,
    CStdPSFactoryBuffer_AddRef,
    CStdPSFactoryBuffer_Release,
    CStdPSFactoryBuffer_CreateProxy,
    CStdPSFactoryBuffer_CreateStub
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\getsp.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// 
// getsp.cpp in CallFrame
//
// Used on the AMD64 and IA64 to return the caller's stack pointer. This code was taken
// from the original implementation in the Context Wrapper code of MTS 1.0, written
// by Jan Gray, the stud.
//
// This is in a separate compilation unit because to perform the trickery we have to 
// have callers use a different signature to the method than what it's implementation
// says it should be, namely  extern "C" void* getSP();. See common.h.
//
#include "stdpch.h"
//
// Return the caller's SP.
//
#pragma warning(disable: 4172) // returning address of local variable or temporary
#if defined(_AMD64_)
extern "C" void* getSP(int rcx)
    {
        return (void*)&rcx;
    }
#elif defined(_IA64_)
extern "C" void* getSP(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
    {
    return (void*)&a8;
    }
#else
#error "No Target Architecture"
#endif // _AMD64_
#pragma warning(default: 4172)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\forwarder.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// forwarder.h
//

// 
// _LANGUAGE_ASSEMBLY is defined by the ALPHA assembler
//
#ifndef _LANGUAGE_ASSEMBLY

extern "C" const PFN_VTABLE_ENTRY g_ProxyForwarderVtable[];
extern "C" const PFN_VTABLE_ENTRY g_StubForwarderVtable[];

#endif

//
// These next constants are used in forwarderAlpha.s to implement the 
// functionality provided by ForwardingInterfaceProxy::From and 
// ForwardingInterfaceStub::From
//
// WARNING: These constants MUST be kept in sync with the actual values
//          determined by the offsets of the indicated members in the
//          indicated classes.

#if !defined(_WIN64)
#define ForwardingInterfaceProxy_m_pProxyVtbl   (sizeof(void*) * 2)
#define ForwardingInterfaceProxy_m_pBaseProxy   (40 + 16 + 4)

#define ForwardingInterfaceStub_m_pStubVtbl         16
#define ForwardingInterfaceStub_m_punkServerObject  20
#define ForwardingInterfaceStub_m_lpForwardingVtbl  32

#else

#define ForwardingInterfaceProxy_m_pProxyVtbl       (16)
#define ForwardingInterfaceProxy_m_pBaseProxy       (80)
#define ForwardingInterfaceStub_m_pStubVtbl         (32)
#define ForwardingInterfaceStub_m_punkServerObject  (40)
#define ForwardingInterfaceStub_m_lpForwardingVtbl  (64)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\dispatchframe.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// DispatchFrame.h
//


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// Implementation of a call frame that handles IDispatch
// 

struct DISPATCH_FRAME : LEGACY_FRAME
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    DISPATCH_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor) 
            : LEGACY_FRAME(punkOuter, iMethod, pvArgs, pinterceptor)
        {
        }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);
//  HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS	mshlflags, ULONG *pcbBufferNeeded);
//  HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
//                                  ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags);
//  HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
//  HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
//  HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags);

    HRESULT STDCALL Invoke(void *pvReceiver);
//  HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame);
    HRESULT STDCALL WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker);
    HRESULT STDCALL GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO*);
    HRESULT STDCALL GetParam(ULONG iparam, VARIANT* pvar);
    HRESULT STDCALL SetParam(ULONG iparam, VARIANT* pvar);
    };


//////////////////////////////////////////


struct DISPATCH_CLIENT_FRAME : DISPATCH_FRAME, DedicatedAllocator<DISPATCH_CLIENT_FRAME, PagedPool>
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    BOOL                    m_fDoneProxyPrecheck;
    BOOL                    m_fIsCopy;
    FRAME_RemoteInvoke      m_remoteFrame;

    DISPPARAMS              m_dispParams;
    VARIANT                 m_varResult;
    EXCEPINFO               m_excepInfo;
    UINT                    m_uArgErr;

    UINT                    m_aVarRefIdx[PREALLOCATE_PARAMS];
    VARIANT                 m_aVarRef   [PREALLOCATE_PARAMS];
    VARIANT                 m_aVarArg   [PREALLOCATE_PARAMS];

    BYTE*                   m_pBuffer;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    DISPATCH_CLIENT_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor) 
            : DISPATCH_FRAME(punkOuter, iMethod, pvArgs, pinterceptor)
        {
        m_fDoneProxyPrecheck      = FALSE;
        m_pBuffer                 = NULL;
        m_fIsCopy                 = FALSE;
        }

private:
    ~DISPATCH_CLIENT_FRAME()
        {
        TracedFree(m_pBuffer);
        }
public:

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

//  HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);
    HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS	mshlflags, ULONG *pcbBufferNeeded);
    HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                    ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags);
    HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags);
    HRESULT STDCALL FreeParam(
         ULONG              iparam,
         DWORD              freeFlags,
         ICallFrameWalker*  pWalkerFree,
         DWORD              nullFlags);

    HRESULT STDCALL Invoke(void *pvReceiver, ...);
    HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame);
//  HRESULT STDCALL WalkFrame(BOOLEAN fIn, GUID*pguidTag, ICallFrameWalker *pWalker);


    ///////////////////////////////////////////////////////////////////
    //
    // Utilties
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT ProxyPreCheck();
    void    InitializeInvoke();

    };

struct DISPATCH_SERVER_FRAME : DISPATCH_FRAME, DedicatedAllocator<DISPATCH_SERVER_FRAME, PagedPool>
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////
    //
    // NB: In a DISPATCH_SERVER_FRAME, m_pvArgs is of shape FRAME_RemoteInvoke, not FRAME_Invoke
    //

    FRAME_Invoke    m_memoryFrame;
    BOOL            m_fDoneStubPrecheck;
    BOOL            m_fDoneStubPostcheck;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    DISPATCH_SERVER_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor) 
            : DISPATCH_FRAME(punkOuter, iMethod, pvArgs, pinterceptor)
        {
        m_fDoneStubPrecheck = FALSE;
        m_fDoneStubPostcheck = FALSE;
        }

private:
    ~DISPATCH_SERVER_FRAME()
        {
        }
public:

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

//  HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);
    HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS	mshlflags, ULONG *pcbBufferNeeded);
    HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                    ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags);
    HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags);
    HRESULT STDCALL FreeParam(
         ULONG              iparam,
         DWORD              freeFlags,
         ICallFrameWalker*  pWalkerFree,
         DWORD              nullFlags);
    HRESULT STDCALL Invoke(void *pvReceiver, ...);
    HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame);
//  HRESULT STDCALL WalkFrame(BOOLEAN fIn, GUID*pguidTag, ICallFrameWalker *pWalker);

    ///////////////////////////////////////////////////////////////////
    //
    // Utilties
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT StubPreCheck();
    HRESULT StubPostCheck();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\format.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//+----------------------------------------------------------------------------
//
// Microsoft Windows
//
// File:        Format.H
//
// Contents:    Format String helper classes
//
// History:     04-Nov-98   ScottKon        Created
//
//+----------------------------------------------------------------------------

//
// Includes
//
#include "..\inc\jtl\txfarray.h"
#include "mrshlp.h"


/*++

Class description :

    This is a self unmarshalling Pointer class.

    Used for FC_RP, FC_UP, FC_FP, and FC_OP.

History :

    Created     10-23-98    scottkon

--*/
class Pointer
    {
public:
    BYTE    m_Type;         // One of FC_RP, FC_UP, FC_FP, or FC_OP
    BYTE    m_Attributes;   // Bitmask of FC_ALLOCATE_ALL_NODES, FC_DONT_FREE, 
                            //      FC_ALLOCATED_ON_STACKFC_SIMPLE_POINTER, and FC_POINTER_DEREF
    BYTE    m_SimpleType;   // If this pointer has the FC_SIMPLE_POINTER attribute
                            //      this field descrives the referent.
    PFORMAT_STRING  m_ComplexOffsetPosition;// If this isn't a FC_SIMPLE_POINTER this is the offset to
                            //      the complex description.
    PFORMAT_STRING  m_pPtrLayout;   // Pointer format codes.

    Pointer() : m_Type(0), m_Attributes(0), m_SimpleType(0), m_ComplexOffsetPosition(NULL) { };

    ~Pointer() {};

    // This function creates a pointer class from a PFORMAT_STRING.
    static HRESULT From(PFORMAT_STRING pFormat, Pointer **ppNewPointer)
        {
        HRESULT hr=S_OK;
        Pointer *pNewPointer = new Pointer;
        if (pNewPointer)
            {
            pNewPointer->m_pPtrLayout = pFormat;
            pNewPointer->m_Type = pFormat[0];
            pNewPointer->m_Attributes = pFormat[1];
            if (pNewPointer->m_Attributes & FC_SIMPLE_POINTER)
                pNewPointer->m_SimpleType = pFormat[2];
            else
                pNewPointer->m_ComplexOffsetPosition = &pFormat[2];
            }
        else
             hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewPointer = pNewPointer;
        else
            if (pNewPointer)
                delete pNewPointer;
        return (hr);
        };
    };



/*++

Class description :

    This is a self unmarshalling Pointer_Description class.

    Used for decoding the repeating format codes for the following:
    offset_to_pointer_in_memory<2>offset_to_pointer_in_buffer<2>pointer_descritpion<4>
    Which is a part of every pointer_layout.

History :

    Created     10-23-98    scottkon

--*/
class Pointer_Description
    {
public:
    SHORT   m_Offset_To_Pointer_In_Memory;
    SHORT   m_Offset_To_Pointer_In_Buffer;
    Pointer *m_Pointer;
    PFORMAT_STRING  pFormatEnd; // The location of the end of the pointer_layout block.

    Pointer_Description() : m_Offset_To_Pointer_In_Memory(0), m_Offset_To_Pointer_In_Buffer(0),
        m_Pointer(NULL), pFormatEnd(NULL) { };

    ~Pointer_Description() { if (m_Pointer) delete m_Pointer; };

    static HRESULT From(PFORMAT_STRING pFormat, Pointer_Description **ppNewPointerDesc)
        {
        HRESULT hr=S_OK;
        Pointer_Description *pNewPointerDesc = new Pointer_Description;
        if (pNewPointerDesc)
            {
            pNewPointerDesc->m_Offset_To_Pointer_In_Memory = (short)pFormat[0];
            pNewPointerDesc->m_Offset_To_Pointer_In_Buffer = (short)pFormat[2];
            hr = Pointer::From(&pFormat[4], &pNewPointerDesc->m_Pointer);
            pNewPointerDesc->pFormatEnd = &pFormat[8];
            }
        else
            hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewPointerDesc = pNewPointerDesc;
        else
            if (pNewPointerDesc)
                delete pNewPointerDesc;

        return (hr);
        };
    };

/*++

Class description :

    This is a self unmarshalling Pointer_Layout class.

    Used for FC_NO_REPEAT, FC_FIXED_REPEAT, and FC_VARIABLE_REPEAT.

History :

    Created     10-23-98    scottkon

--*/
class Pointer_Layout
    {
public:
    BYTE    m_Type;         // One of FC_NO_REPEAT, FC_FIXED_REPEAT, and FC_VARIABLE_REPEAT
    SHORT   m_Iterations;   // Iterations if FC_FIXED_REPEAT or FC_VARIABLE_REPEAT
    SHORT   m_Increment;    // The increment between successive pointers during repeat
    SHORT   m_Offset_To_Array;  // Offset from enclosing structure to the embedded array.
    SHORT   m_NumberOfPointers; // Number of different pointers in a repeat instance.
    Array<Pointer_Description *, PagedPool> m_Pointers; // List of pointer descriptions
    PFORMAT_STRING  pFormatEnd; // The location of the end of the pointer_layout block.

    Pointer_Layout() : m_Type(0), m_Iterations(0), m_Increment(0), m_Offset_To_Array(0),
        m_NumberOfPointers(0), pFormatEnd(NULL) { };

    ~Pointer_Layout()
        {
        for (unsigned int i=0; i < m_Pointers.size(); i++)
            {
            Pointer_Description *pPDesc = m_Pointers[i];
            delete pPDesc;
            }
        };

    /*++
        Method description: Pointer_Layout::From
            This function creates a pointer class from a PFORMAT_STRING.
        Arguments:
            pFormat - The format string should be pointing to the FC_PP FC_PAD.
    --*/
    static HRESULT From(PFORMAT_STRING pFormat, Pointer_Layout **ppNewPointerLayout)
        {
        HRESULT hr=S_OK;
        Pointer_Layout *pNewPointerLayout = new Pointer_Layout;
        if (NULL != pNewPointerLayout)
            {
            Pointer_Description *pPointerDesc=NULL;
            pNewPointerLayout->m_Type = pFormat[2];
            if (FC_NO_REPEAT == pNewPointerLayout->m_Type)
                {
                hr = Pointer_Description::From(&pFormat[4], &pPointerDesc);
                if (!hr)
                    {
                    pNewPointerLayout->m_Pointers.append(pPointerDesc);
                    pNewPointerLayout->pFormatEnd = pPointerDesc->pFormatEnd;
                    }
                }
            else
                {
                if (FC_FIXED_REPEAT == pNewPointerLayout->m_Type)
                    {
                    pNewPointerLayout->m_Iterations        = *(short *)&pFormat[4];
                    pNewPointerLayout->m_Increment         = *(short *)&pFormat[6];
                    pNewPointerLayout->m_Offset_To_Array   = *(short *)&pFormat[8];
                    pNewPointerLayout->m_NumberOfPointers  = *(short *)&pFormat[10];
                    PFORMAT_STRING pFormatPD = &pFormat[12];
                    for (int iPointers = 0; iPointers < pNewPointerLayout->m_NumberOfPointers; iPointers++)
                        {
                        hr = Pointer_Description::From(pFormatPD, &pPointerDesc);
                        if (!hr)
                            {
                            pNewPointerLayout->m_Pointers.append(pPointerDesc);
                            pFormatPD += 8; // Move to the next pointer_description
                            }
                        else
                            break;
                        }
                    pNewPointerLayout->pFormatEnd = pPointerDesc->pFormatEnd;
                    }
                else
                    {
                    if (FC_VARIABLE_REPEAT == pNewPointerLayout->m_Type)
                        {
                        pNewPointerLayout->m_Increment         = *(short *)&pFormat[4];
                        pNewPointerLayout->m_Offset_To_Array   = *(short *)&pFormat[6];
                        pNewPointerLayout->m_NumberOfPointers  = *(short *)&pFormat[8];
                        PFORMAT_STRING pFormatPD = &pFormat[10];
                        while (FC_END != *pFormatPD)
                            {
                            hr = Pointer_Description::From(pFormatPD, &pPointerDesc);
                            if (!hr)
                                {
                                pNewPointerLayout->m_Pointers.append(pPointerDesc);
                                pFormatPD += 8; // Move to the next pointer_description
                                }
                            else
                                break;
                            }
                        pNewPointerLayout->pFormatEnd = pFormatPD;
                        }
                    else
                        {
                        NDR_ASSERT(0,"Pointer_Layout : bad pointer type");
                        hr = RPC_S_INTERNAL_ERROR;
                        }
                    }
                }
            }
        else
            hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewPointerLayout = pNewPointerLayout;
        else
            if (pNewPointerLayout)
                delete pNewPointerLayout;

        return hr;
        };
    };


/*++

Class description :

    This is a self unmarshalling Array_Conformance class.

    Used for array conformance description fields.

    m_ConformanceLocation can be FC_NORMAL_CONFORMANCE, FC_POINTER_CONFORMANCE,
            FC_TOP_LEVEL_CONFORMANCE, FC_TOP_LEVEL_MULTID_CONFORMANCE, or
            FC_CONSTANT_CONFORMANCE

    m_VariableType can be FC_LONG, FC_ULONG, FC_SHORT, FC_USHORT, FC_SMALL or FC_USMALL

    m_SizeIsOp can be FC_DEREFERENCE, FC_DIV_2, FC_MULT_2, FC_SUB_1, FC_ADD_1, or FC_CALLBACK

History :

    Created     11-04-98    scottkon

--*/
class Array_Conformance
    {
public:
    BYTE            m_ConformanceLocation;
    BYTE            m_VariableType;
    BYTE            m_SizeIsOp;
    PFORMAT_STRING  m_pConfFormat;
    SIZE_T           m_cElements;
    SIZE_T           m_ElementSize;
    void            *m_ConformanceField;

    Array_Conformance() : m_ConformanceLocation(0), m_VariableType(0), m_SizeIsOp(0),
        m_pConfFormat(NULL), m_cElements(0), m_ConformanceField(NULL) { };

    ~Array_Conformance() {};

    /*++
        Method description: Array_Layout::From
            This function creates an array class from a PFORMAT_STRING.
        Arguments:
            pStubMsg -      This is a MIDL stub message structure.  We need this to compute
                            varying arrays where the actual element count and offset are on
                            the stack.

            pMemory -       This is the pointer to the Array in memory.

            pFormat -       The format string should be pointing to the start of the array
                            format.

            ppNewConf -     The newly created conformance layout class.
    --*/
    static HRESULT From(PMIDL_STUB_MESSAGE  pStubMsg, uchar *pMemory,
        PFORMAT_STRING pFormat, Array_Conformance **ppNewConf)
        {
        HRESULT hr=S_OK;
        Array_Conformance *pNewConf = new Array_Conformance;
        if (pNewConf)
            {
                pNewConf->m_ConformanceLocation = pFormat[4] & 0xF0;
                pNewConf->m_VariableType = pFormat[4] & 0x0F;
                pNewConf->m_SizeIsOp = pFormat[5];

                // The offset field is interpreted in different ways.
                // Summarized are the rules
                //      Not Attributed pointer && Field in a structure
                //          Then offset field from the end of the non-conformant part of the structure
                //          to the conformance describing field.
                //      Attributed pointer && Field in a structure
                //          Then offset field from the beginning of the structure to the conformance
                //          describing field.
                //      Top level conformance
                //          Then offset field form the stub's first parameter location on the stack
                //          to the parameter which describes the conformance.
                if (FC_TOP_LEVEL_CONFORMANCE == pNewConf->m_ConformanceLocation)
                    {
                    if ( pStubMsg->StackTop ) 
                        {
                        pNewConf->m_ConformanceField = pStubMsg->StackTop + *((signed short *)(&pFormat[6]));
                        }
                    else
                        {
                        //
                        // If this is top level conformance with /Os then we don't have 
                        // to do anything, the proper conformance count is placed in the 
                        // stub message inline in the stubs.
                        //
                        pNewConf->m_cElements = pStubMsg->MaxCount;
                        }
                    }
                else if (FC_POINTER_CONFORMANCE == pNewConf->m_ConformanceLocation)
                    {
                    pNewConf->m_ConformanceField = (ULONG*)(pStubMsg->Memory + *(signed short *)&pFormat[6]);
                    pNewConf->m_cElements = *(ULONG*)(pStubMsg->Memory + *(signed short *)&pFormat[6]);
                    }
                else if (FC_NORMAL_CONFORMANCE == pNewConf->m_ConformanceLocation)
                    {
                    pNewConf->m_ConformanceField = pMemory + *((signed short *)(&pFormat[6]));
                    }
                else if (FC_CONSTANT_CONFORMANCE == pNewConf->m_ConformanceLocation)
                    {
                    pNewConf->m_cElements = (long)pFormat[5] << 16;
                    pNewConf->m_cElements |= (long) *((ushort *)(&pFormat[6]));
                    }

                //
                // Must check now if there is a dereference op.
                //
                if ( FC_DEREFERENCE == pNewConf->m_SizeIsOp )
                    {
                    pNewConf->m_ConformanceField = *(void **)pNewConf->m_ConformanceField;
                    }

                if ((0 == pNewConf->m_cElements) && (NULL != pNewConf->m_ConformanceField))
                    pNewConf->GetConformanceField();

                pNewConf->m_ElementSize = PtrToUlong(NdrpMemoryIncrement( pStubMsg, pMemory, pFormat)) - PtrToUlong(pMemory);
            }
        else
             hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewConf = pNewConf;
        else
            if (pNewConf)
                delete pNewConf;

        return (hr);
        };

    HRESULT GetConformanceField()
        {
        if (NULL == m_ConformanceField)
            return E_INVALIDARG;

        switch ( m_VariableType ) 
            {
            case FC_ULONG :
            case FC_LONG :
                m_cElements = *((long *)m_ConformanceField);
                break;

            case FC_ENUM16:
                #if defined(__RPC_MAC__)
                    // Take it from the other half of the long.

                    m_cElements = (long) *( ((short *)m_ConformanceField) + 1);
                    break;
                #endif

                // For non Mac platforms just fall thru to ushort

            case FC_USHORT :
                m_cElements = (long) *((ushort *)m_ConformanceField);
                break;

            case FC_SHORT :
                m_cElements = (long) *((short *)m_ConformanceField);
                break;

            case FC_USMALL :
                m_cElements = (long) *((uchar *)m_ConformanceField);
                break;

            case FC_SMALL :
                m_cElements = (long) *((char *)m_ConformanceField);
                break;

            default :
                NDR_ASSERT(0,"ArrayConformance::From : bad count type");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            } 

        //
        // Check the operator.
        //
        switch ( m_SizeIsOp ) 
            {
            case FC_DIV_2 :
                m_cElements /= 2;
                break;
            case FC_MULT_2 :
                m_cElements *= 2;
                break;
            case FC_SUB_1 :
                m_cElements -= 1;
                break;
            case FC_ADD_1 :
                m_cElements += 1;
                break;
            default :
                // OK
                break;
            }
        return (S_OK);
        }

    HRESULT SetConformanceField(void *value)
        {
        if (NULL == m_ConformanceField)
            return E_INVALIDARG;

        switch ( m_VariableType ) 
            {
            case FC_ULONG :
            case FC_LONG :
                //
                // Check the operator.
                //
                switch ( m_SizeIsOp ) 
                    {
                    case FC_DIV_2 :
                        *((long *)value) *= 2;
                        break;
                    case FC_MULT_2 :
                        *((long *)value) /= 2;
                        break;
                    case FC_SUB_1 :
                        *((long *)value) += 1;
                        break;
                    case FC_ADD_1 :
                        *((long *)value) -= 1;
                        break;
                    default :
                        // OK
                        break;
                    }
                *((long *)m_ConformanceField) = *((long *)value);
                break;

            case FC_ENUM16:
                #if defined(__RPC_MAC__)
                    // Take it from the other half of the long.

                    //
                    // Check the operator.
                    //
                    switch ( m_SizeIsOp ) 
                        {
                        case FC_DIV_2 :
                            *((short *)value) *= 2;
                            break;
                        case FC_MULT_2 :
                            *((short *)value) /= 2;
                            break;
                        case FC_SUB_1 :
                            *((short *)value) += 1;
                            break;
                        case FC_ADD_1 :
                            *((short *)value) -= 1;
                            break;
                        default :
                            // OK
                            break;
                        }
                    *( ((short *)m_ConformanceField) + 1) = *((short *)value);
                    break;
                #endif

                // For non Mac platforms just fall thru to ushort

            case FC_USHORT :
                //
                // Check the operator.
                //
                switch ( m_SizeIsOp ) 
                    {
                    case FC_DIV_2 :
                        *((ushort *)value) *= 2;
                        break;
                    case FC_MULT_2 :
                        *((ushort *)value) /= 2;
                        break;
                    case FC_SUB_1 :
                        *((ushort *)value) += 1;
                        break;
                    case FC_ADD_1 :
                        *((ushort *)value) -= 1;
                        break;
                    default :
                        // OK
                        break;
                    }
                *((ushort *)m_ConformanceField) = *((ushort *)value);
                break;

            case FC_SHORT :
                //
                // Check the operator.
                //
                switch ( m_SizeIsOp ) 
                    {
                    case FC_DIV_2 :
                        *((short *)value) *= 2;
                        break;
                    case FC_MULT_2 :
                        *((short *)value) /= 2;
                        break;
                    case FC_SUB_1 :
                        *((short *)value) += 1;
                        break;
                    case FC_ADD_1 :
                        *((short *)value) -= 1;
                        break;
                    default :
                        // OK
                        break;
                    }
                *((short *)m_ConformanceField) = *((short *)value);
                break;

            case FC_USMALL :
                //
                // Check the operator.
                //
                switch ( m_SizeIsOp ) 
                    {
                    case FC_DIV_2 :
                        *((uchar *)value) *= 2;
                        break;
                    case FC_MULT_2 :
                        *((uchar *)value) /= 2;
                        break;
                    case FC_SUB_1 :
                        *((uchar *)value) += 1;
                        break;
                    case FC_ADD_1 :
                        *((uchar *)value) -= 1;
                        break;
                    default :
                        // OK
                        break;
                    }
                *((uchar *)m_ConformanceField) = *((uchar *)value);
                break;

            case FC_SMALL :
                //
                // Check the operator.
                //
                switch ( m_SizeIsOp ) 
                    {
                    case FC_DIV_2 :
                        *((char *)value) *= 2;
                        break;
                    case FC_MULT_2 :
                        *((char *)value) /= 2;
                        break;
                    case FC_SUB_1 :
                        *((char *)value) += 1;
                        break;
                    case FC_ADD_1 :
                        *((char *)value) -= 1;
                        break;
                    default :
                        // OK
                        break;
                    }
                *((char *)m_ConformanceField) = *((char *)value);
                break;

            default :
                NDR_ASSERT(0,"ArrayConformance::From : bad count type");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            } 

        return (S_OK);
        }
    };



/*++

Class description :

    This is a self unmarshalling Array_Variance class.

    Used for array variance description fields.

    m_ConformanceLocation can be FC_NORMAL_CONFORMANCE, FC_POINTER_CONFORMANCE,
            FC_TOP_LEVEL_CONFORMANCE, FC_TOP_LEVEL_MULTID_CONFORMANCE, or
            FC_CONSTANT_CONFORMANCE

    m_VariableType can be FC_LONG, FC_ULONG, FC_SHORT, FC_USHORT, FC_SMALL or FC_USMALL

    m_SizeIsOp can be FC_DEREFERENCE, FC_DIV_2, FC_MULT_2, FC_SUB_1, FC_ADD_1, or FC_CALLBACK

History :

    Created     11-04-98    scottkon

--*/
class Array_Variance
    {
public:
    BYTE                m_VarianceLocation;
    BYTE                m_VariableType;
    BYTE                m_SizeIsOp;
    PFORMAT_STRING      m_pVarFormat;
    ULONG               m_cElements;            // The actual number of elements in a varying array
    ULONG               m_cOffset;              // The offset of the first transfered element in a varying array

    Array_Variance() : m_VarianceLocation(0), m_VariableType(0), m_SizeIsOp(0),
        m_pVarFormat(NULL), m_cElements(0), m_cOffset(0) { };

    ~Array_Variance() {};

    /*++
        Method description: Array_Variance::From
            This function creates an array variance class from a PFORMAT_STRING.
        Arguments:
            pStubMsg -      This is a MIDL stub message structure.  We need this to compute
                            varying arrays where the actual element count and offset are on
                            the stack.

            pMemory -       This is the pointer to the Array in memory.

            pFormat -       The format string should be pointing to the start of the array
                            format.

            ppNewConf -     The newly created variance layout class.
    --*/
    static HRESULT From(PMIDL_STUB_MESSAGE  pStubMsg, uchar *pMemory, 
        PFORMAT_STRING pFormat, Array_Variance **ppNewVar)
        {
        HRESULT hr=S_OK;
        Array_Variance *pNewVar = new Array_Variance;
        if (pNewVar)
            {
                NdrpComputeVariance( pStubMsg,
                        pMemory,
                        pFormat );
                pNewVar->m_cOffset    = pStubMsg->Offset;
                pNewVar->m_cElements  = pStubMsg->ActualCount; // This is how many are really transfered.

                pNewVar->m_VarianceLocation = pFormat[4] & 0xF0;
                pNewVar->m_VariableType = pFormat[4] & 0x0F;
                pNewVar->m_SizeIsOp = pFormat[5];
                pNewVar->m_pVarFormat = &pFormat[6] + *(signed short *)&pFormat[6];
            }
        else
             hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewVar = pNewVar;
        else
            if (pNewVar)
                delete pNewVar;

        return (hr);
        };
    };



/*++

Class description :

    This is a self unmarshalling Array_Layout class.

    Used for    FC_SMFARRAY, FC_LGFARRAY, FC_CARRAY, FC_CVARRAY, FC_SMVARRAY,
                FC_LGVARRAY, FC_BOGUS_ARRAY

History :

    Created     11-04-98    scottkon

--*/
class Array_Layout
    {
public:
    BYTE                m_Alignment;            // Alignment of the array
    SIZE_T              m_TotalArraySize;       // The total memory size of the array
    SIZE_T              m_ElementSize;          // The size in memory of a single element
    SIZE_T              m_cElements;            // The number of elements in a varying array
    Pointer_Layout      *m_pPointerLayout;      // Pointer layout class
    Array_Conformance   *m_pConformance;        // Array conformance class
    Array_Variance      *m_pVariance;           // Array variance class
    PFORMAT_STRING      m_pFormatLayout;        // The FORMAT_STRING for the array element

    Array_Layout() : m_Alignment(0), m_TotalArraySize(0), m_ElementSize(0),
        m_cElements(0), m_pPointerLayout(NULL), m_pConformance(NULL), m_pVariance(NULL),
        m_pFormatLayout(NULL)
        {
        };

    ~Array_Layout()
        {
        if (m_pPointerLayout)
            delete m_pPointerLayout;
        if (m_pConformance)
            delete m_pConformance;
        if (m_pVariance)
            delete m_pVariance;
        };

    /*++
        Method description: Array_Layout::From
            This function creates an array class from a PFORMAT_STRING.
        Arguments:
            pStubMsg -      This is a MIDL stub message structure.  We need this to compute
                            varying arrays where the actual element count and offset are on
                            the stack.

            pMemory -       This is the pointer to the Array in memory.

            pFormat -       The format string should be pointing to the start of the array
                            format.

            ppNewArray -    The newly created array layout class.
    --*/
    static HRESULT From(PMIDL_STUB_MESSAGE  pStubMsg, uchar *pMemory,
        PFORMAT_STRING pFormat, /* out */Array_Layout **ppNewArray)
        {
        HRESULT hr=S_OK;
        Array_Layout *pNewArray = new Array_Layout;
        if (pNewArray)
            {
            pNewArray->m_Alignment = pFormat[1];

            switch (pFormat[0])
                {
                case FC_SMFARRAY:
                    {
                    pNewArray->m_TotalArraySize = *((ushort *)&pFormat[2]);
                    // Does this definition have a pointer layout?
                    if (pFormat[4] == FC_PP)
                        {
                        hr = Pointer_Layout::From(&pFormat[4], &pNewArray->m_pPointerLayout);
                        if (!hr)
                            {
                            pNewArray->m_pFormatLayout = pNewArray->m_pPointerLayout->pFormatEnd + 1;
                            if (FC_EMBEDDED_COMPLEX != *(pNewArray->m_pFormatLayout))
                                {
                                pNewArray->m_ElementSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));
                                if (0 != pNewArray->m_ElementSize)
                                    pNewArray->m_cElements = pNewArray->m_TotalArraySize/pNewArray->m_ElementSize;
                                else
                                    {
                                    // Element size is bogus
                                    hr = RPC_S_INTERNAL_ERROR;
                                    }
                                }
                            else
                                {
                                pNewArray->m_cElements = pNewArray->m_pPointerLayout->m_Iterations;
                                if (0 != pNewArray->m_cElements)
                                    pNewArray->m_ElementSize = pNewArray->m_TotalArraySize/pNewArray->m_cElements;
                                else
                                    {
                                    // pNewArray->m_cElements is bogus
                                    hr = RPC_S_INTERNAL_ERROR;
                                    }
                                }
                            }
                        }
                    else
                        {
                        ULONG cSimpleTypeSize; // temp/local variable to compute m_cElements
                        pNewArray->m_pFormatLayout = &pFormat[4];
                        cSimpleTypeSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));
                        pNewArray->m_ElementSize = cSimpleTypeSize;
                        if (0 != cSimpleTypeSize)
                            pNewArray->m_cElements = pNewArray->m_TotalArraySize/cSimpleTypeSize;
                        else
                            {
                            // cSimpleTypeSize is bogus
                            hr = RPC_S_INTERNAL_ERROR;
                            }
                        }
                    }
                    break;

                case FC_LGFARRAY:
                    {
                    pNewArray->m_TotalArraySize = *((ULONG *)&pFormat[2]);
                    // Does this definition have a pointer layout?
                    if (pFormat[6] == FC_PP)
                        {
                        hr = Pointer_Layout::From(&pFormat[6], &pNewArray->m_pPointerLayout);
                        if (!hr)
                            {
                            pNewArray->m_pFormatLayout = pNewArray->m_pPointerLayout->pFormatEnd + 1;
                            if (FC_EMBEDDED_COMPLEX != *(pNewArray->m_pFormatLayout))
                                {
                                pNewArray->m_ElementSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));
                                if (0 != pNewArray->m_ElementSize)
                                    pNewArray->m_cElements = pNewArray->m_TotalArraySize/pNewArray->m_ElementSize;
                                else
                                    {
                                    // Element size is bogus
                                    hr = RPC_S_INTERNAL_ERROR;
                                    }
                                }
                            else
                                {
                                pNewArray->m_cElements = pNewArray->m_pPointerLayout->m_Iterations;
                                if (0 != pNewArray->m_cElements)
                                    pNewArray->m_ElementSize = pNewArray->m_TotalArraySize/pNewArray->m_cElements;
                                else
                                    {
                                    // pNewArray->m_cElements is bogus
                                    hr = RPC_S_INTERNAL_ERROR;
                                    }
                                }
                            }
                        }
                    else
                        {
                        ULONG cSimpleTypeSize; // temp/local variable to compute m_cElements
                        pNewArray->m_pFormatLayout = &pFormat[6];
                        cSimpleTypeSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));
                        pNewArray->m_ElementSize = cSimpleTypeSize;
                        if (0 != cSimpleTypeSize)
                            pNewArray->m_cElements = pNewArray->m_TotalArraySize/cSimpleTypeSize;
                        else
                            {
                            // cSimpleTypeSize is bogus
                            hr = RPC_S_INTERNAL_ERROR;
                            }
                        }
                    }
                    break;

                case FC_CARRAY:
                    {
                    pNewArray->m_ElementSize = (unsigned short)pFormat[2];
                    hr = Array_Conformance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pConformance);
                    if (!hr)
                        {
                        if (FC_PP == pFormat[8])
                            {
                            hr = Pointer_Layout::From(&pFormat[8], &pNewArray->m_pPointerLayout);
                            if (!hr)
                                {
                                pNewArray->m_pFormatLayout = pNewArray->m_pPointerLayout->pFormatEnd + 1;
                                if (FC_EMBEDDED_COMPLEX != *(pNewArray->m_pFormatLayout))
                                    {
                                    // BUGBUG we are calculating m_ElementSize twice ?
                                    pNewArray->m_ElementSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));
                                    pNewArray->m_cElements = pNewArray->m_pConformance->m_cElements;
                                    }
                                else
                                    {
                                    if (0 != pNewArray->m_pPointerLayout->m_Iterations)
                                        pNewArray->m_cElements = pNewArray->m_pPointerLayout->m_Iterations;
                                    else
                                        pNewArray->m_cElements = pNewArray->m_pConformance->m_cElements;
                                    }
                                }
                            pNewArray->m_TotalArraySize = pNewArray->m_ElementSize * pNewArray->m_cElements;
                            }
                        else
                            {
                            pNewArray->m_pFormatLayout = &pFormat[8];
                            pNewArray->m_cElements = pNewArray->m_pConformance->m_cElements;
                            pNewArray->m_ElementSize = pNewArray->m_pConformance->m_ElementSize;
                            pNewArray->m_TotalArraySize = pNewArray->m_ElementSize * pNewArray->m_cElements;
                            }
                        }
                    }
                    break;
                    
                case FC_SMVARRAY:
                    {
                    pNewArray->m_TotalArraySize = *(unsigned short *)&pFormat[2];
                    pNewArray->m_cElements = *(unsigned short *)&pFormat[4];
                    pNewArray->m_ElementSize = *(unsigned short *)&pFormat[6];
                    hr = Array_Variance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pVariance);
                    if (!hr)
                        {
                        if (FC_PP == pFormat[12])
                            {
                            hr = Pointer_Layout::From(&pFormat[12], &pNewArray->m_pPointerLayout);
                            if (!hr)
                                pNewArray->m_pFormatLayout = pNewArray->m_pPointerLayout->pFormatEnd + 1;
                            }
                        else
                            {
                            pNewArray->m_pFormatLayout = &pFormat[12];
                            }
                        }
                    }
                    break;
                    
                case FC_LGVARRAY:
                    {
                    pNewArray->m_TotalArraySize = *(unsigned short *)&pFormat[2];
                    pNewArray->m_cElements = *(unsigned short *)&pFormat[6];
                    pNewArray->m_ElementSize = *(unsigned short *)&pFormat[8];
                    hr = Array_Variance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pVariance);
                    if (!hr)
                        {
                        if (FC_PP == pFormat[16])
                            {
                            hr = Pointer_Layout::From(&pFormat[16], &pNewArray->m_pPointerLayout);
                            if (!hr)
                                pNewArray->m_pFormatLayout = pNewArray->m_pPointerLayout->pFormatEnd + 1;
                            }
                        else
                            {
                            pNewArray->m_pFormatLayout = &pFormat[16];
                            }
                        }
                    }
                    break;
                    
                case FC_CVARRAY:
                    {
                    pNewArray->m_ElementSize = (unsigned short)pFormat[2];
                    hr = Array_Conformance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pConformance);
                    if (!hr)
                        {
                        hr = Array_Variance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pVariance);
                        if (!hr)
                            {
                            if (FC_PP == pFormat[12])
                                {
                                hr = Pointer_Layout::From(&pFormat[14], &pNewArray->m_pPointerLayout);
                                if (!hr)
                                    {
                                    pNewArray->m_pFormatLayout = pNewArray->m_pPointerLayout->pFormatEnd + 1;
                                    if (FC_EMBEDDED_COMPLEX != *(pNewArray->m_pFormatLayout))
                                        {
                                        pNewArray->m_ElementSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));
                                        pNewArray->m_cElements = pNewArray->m_pConformance->m_cElements;
                                        }
                                    else
                                        {
                                        if (0 != pNewArray->m_pPointerLayout->m_Iterations)
                                            pNewArray->m_cElements = pNewArray->m_pPointerLayout->m_Iterations;
                                        else
                                            pNewArray->m_cElements = pNewArray->m_pConformance->m_cElements;
                                        }
                                    }
                                }
                            else
                                {
                                pNewArray->m_pFormatLayout = &pFormat[12];
                                pNewArray->m_cElements = pNewArray->m_pVariance->m_cElements; // BUGBUG verify!
                                }
                            
                            pNewArray->m_TotalArraySize = pNewArray->m_ElementSize * pNewArray->m_cElements;
                            }
                        }
                    }
                    break;
                    
                case FC_BOGUS_ARRAY:
                    {
                    pNewArray->m_cElements = (unsigned short)pFormat[2];    // 0 If we've got conformance
                    pNewArray->m_pFormatLayout = &pFormat[12];
                    if (0xFFFFFFFF != *(unsigned long *)&pFormat[4]) // Got Conformance?
                        {
                        hr = Array_Conformance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pConformance);
                        if (!hr)
                            pNewArray->m_cElements = pNewArray->m_pConformance->m_cElements;
                        }
                    if (!hr)
                        {
                        if (pNewArray->m_pConformance)
                            pNewArray->m_ElementSize = pNewArray->m_pConformance->m_ElementSize;
                        else
                            pNewArray->m_ElementSize = SIMPLE_TYPE_BUFSIZE(*(pNewArray->m_pFormatLayout));

                        if (0xFFFFFFFF != *(unsigned long *)&pFormat[8]) // Got Variance?
                            hr = Array_Variance::From(pStubMsg, pMemory, pFormat, &pNewArray->m_pVariance);
                        }

                    pNewArray->m_TotalArraySize = pNewArray->m_ElementSize * pNewArray->m_cElements;
                    }
                    break;
                    
                default:
                    NDR_ASSERT(0,"Array_Format::From : bad array type");
                    hr = RPC_S_INTERNAL_ERROR;
                }
            }
        else
            hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewArray = pNewArray;
        else
            if (pNewArray)
                delete pNewArray;

        return(hr);
        }
    };


/*++

Class description :

    This is a self unmarshalling Struct_Layout class.

    Used for    FC_STRUCT, FC_PSTRUCT, FC_CSTRUCT, FC_CPSTRUCT, FC_CVSTRUCT,
                FC_HARD_STRUCTURE, FC_BOGUS_STRUCT

History :

    Created     11-04-98    scottkon

--*/
class Struct_Layout
    {
public:
    BYTE                m_Alignment;            // Alignment of the struct
    ULONG               m_TotalSize;            // The total memory size of the struct
    Pointer_Layout      *m_pPointer;            // Pointer layout class
    Array_Layout        *m_pCArray;             // Contained conformant array
    PFORMAT_STRING      m_pFormatLayout;        // The FORMAT_STRING for the array element
    // Stuff for embeded arrays
    PFORMAT_STRING      m_pArrayLayout;         // The FORMAT_STRING for the embeded array layout
    // Stuff for bogus struct
    PFORMAT_STRING      m_pPointerLayout;       // The FORMAT_STRING for the bogus struct pointer layout
    // Stuff for hard struct
    USHORT              m_EnumOffset;           // Offset from the beginning of the struct to an enum16
    USHORT              m_HardCopySize;         // The amount of the hard struct which can be copied.
    USHORT              m_HardCopyIncr;         // The amount to increment the memory pointer after copy.
    PFORMAT_STRING      m_pUnionLayout;         // Offset to a union description in a hard struct

    Struct_Layout() : m_Alignment(0), m_TotalSize(0), m_pPointer(NULL), m_pCArray(NULL),
        m_pFormatLayout(NULL), m_pArrayLayout(NULL), m_pPointerLayout(NULL), m_EnumOffset(0),
        m_HardCopySize(0), m_HardCopyIncr(0), m_pUnionLayout(NULL)
        {
        }

    ~Struct_Layout()
        {
        if (m_pPointer)
            delete m_pPointer;
        if (m_pCArray)
            delete m_pCArray;
        }

    /*++
        Method description: Struct_Layout::From
            This function creates a struct class from a PFORMAT_STRING.
        Arguments:
            pStubMsg -      This is a MIDL stub message structure.  We need this to compute
                            varying arrays where the actual element count and offset are on
                            the stack.

            pMemory -       This is the pointer to the struct in memory.

            pFormat -       The format string should be pointing to the start of the struct
                            format.

            ppNewArray -    The newly created struct layout class.
    --*/
    static HRESULT From(PMIDL_STUB_MESSAGE  pStubMsg, uchar *pMemory,
        PFORMAT_STRING pFormat, /* out */Struct_Layout **ppNewStruct)
        {
        HRESULT hr=S_OK;
        Struct_Layout *pNewStruct = new Struct_Layout;
        if (pNewStruct)
            {
            pNewStruct->m_Alignment = pFormat[1];
            pNewStruct->m_TotalSize = *((unsigned short *)&pFormat[2]);

            switch (pFormat[0])
                {
                case FC_STRUCT:
                    {
                    pNewStruct->m_pFormatLayout = &pFormat[4];
                    }
                    break;

                case FC_PSTRUCT:
                    {
                    hr = Pointer_Layout::From(&pFormat[4], &pNewStruct->m_pPointer);
                    if (!hr)
                        pNewStruct->m_pFormatLayout = pNewStruct->m_pPointer->pFormatEnd+1;
                    }
                    break;

                case FC_CSTRUCT:
                    {
                    signed short ArrayOffset = *(signed short *)&pFormat[4];
                    if (0 != ArrayOffset)
                        {
                        // We have an embedded conformant array
                        pNewStruct->m_pArrayLayout = &pFormat[4] + ArrayOffset;
                        hr = Array_Layout::From(pStubMsg, pMemory, &pFormat[4] + ArrayOffset, &pNewStruct->m_pCArray);
                        }
                    if (!hr)
                        {
                        pNewStruct->m_pFormatLayout = &pFormat[6];
                        }
                    }
                    break;

                case FC_CPSTRUCT:
                    {
                    signed short ArrayOffset = *(signed short *)&pFormat[4];
                    if (0 != ArrayOffset)
                        {
                        // We have an embedded conformant array
                        pNewStruct->m_pArrayLayout = &pFormat[4] + ArrayOffset;
                        hr = Array_Layout::From(pStubMsg, pMemory, &pFormat[4] + ArrayOffset, &pNewStruct->m_pCArray);
                        }
                    if (!hr)
                        {
                        hr = Pointer_Layout::From(&pFormat[6], &pNewStruct->m_pPointer);
                        if (!hr)
                            pNewStruct->m_pFormatLayout = pNewStruct->m_pPointer->pFormatEnd+1;
                        }
                    }
                    break;

                case FC_CVSTRUCT:
                    {
                    signed short ArrayOffset = *(signed short *)&pFormat[4];
                    if (0 != ArrayOffset)
                        {
                        // We have an embedded conformant array
                        pNewStruct->m_pArrayLayout = &pFormat[4] + ArrayOffset;
                        hr = Array_Layout::From(pStubMsg, pMemory, &pFormat[4] + ArrayOffset, &pNewStruct->m_pCArray);
                        }
                    if (!hr)
                        {
                        // Optional pointer layout
                        if (FC_PP == pFormat[6])
                            {
                            hr = Pointer_Layout::From(&pFormat[6], &pNewStruct->m_pPointer);
                            if (!hr)
                                pNewStruct->m_pFormatLayout = pNewStruct->m_pPointer->pFormatEnd+1;
                            }
                        else
                            pNewStruct->m_pFormatLayout = &pFormat[6];
                        }
                    }
                    break;

                case FC_HARD_STRUCT:
                    {
                    pNewStruct->m_EnumOffset = *((unsigned short *)&pFormat[8]);
                    pNewStruct->m_HardCopySize = *((unsigned short *)&pFormat[10]);
                    pNewStruct->m_HardCopyIncr = *((unsigned short *)&pFormat[12]);
                    pNewStruct->m_pUnionLayout = &pFormat[14] + *(signed short *)&pFormat[14];
                    pNewStruct->m_pFormatLayout = &pFormat[16];
                    }
                    break;

                case FC_BOGUS_STRUCT:
                    {
                    signed short ArrayOffset = *(signed short *)&pFormat[4];
                    if (0 != ArrayOffset)
                        {
                        // We have an embedded conformant array
                        hr = Array_Layout::From(pStubMsg, pMemory, &pFormat[4] + ArrayOffset, &pNewStruct->m_pCArray);
                        }
                    if (!hr)
                        {
                        pNewStruct->m_pFormatLayout = &pFormat[8];
                        pNewStruct->m_pPointerLayout = &pFormat[6] + *(signed short *)&pFormat[6];
                        }
                    }
                    break;

                default:
                    NDR_ASSERT(0,"Struct_Format::From : bad format char");
                    hr = RPC_S_INTERNAL_ERROR;
                }
            }
        else
            hr = E_OUTOFMEMORY;

        if (!hr)
            *ppNewStruct = pNewStruct;
        else
            if (pNewStruct)
                delete pNewStruct;

        return(hr);
        }


    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\forwarder.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// forwarder.cpp
//
#include "stdpch.h"
#include "common.h"

////////////////////////////////////////////////////////////////////////////////////////////
//
// Definition of the method thunks for proxy forwarders
//         
// This vtable implements the hooked IID in interface proxies. The implementation of that
// interface simply forwards the call along to some base interface proxy.
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _X86_ 

#define methname(i) __ForwarderProxy_meth##i

#define meth(i)                                                         \
HRESULT __declspec(naked) methname(i)(void* this_, ...)                 \
    {                                                                   \
    __asm push i                                                        \
    __asm jmp ForwarderProxyThunk                                       \
    }


void __declspec(naked) ForwarderProxyThunk(ULONG iMethod, void* This, ...)
    {
    // Manually establish a stack frame so that references to locals herein will work
    // 
    __asm 
        {
        push     ebp
        mov      ebp, esp
        }

    // Change 'this' pointer on stack to refer to delegatee.
    // 
    This = ForwardingInterfaceProxy::From(This)->m_pBaseProxy;

    __asm {
        //
        // Get the method number into edx. In actuality, the return address
        // is where the compiler thinks iMethod is, and iMethod is where the
        // return address is:
        //
        //      12  this_
        //      8   return address
        //      4   iMethod
        //      0   saved ebp
        //      
        mov     edx, 4[ebp]
        // 
        // Pop the above established stack frame, and the extra iMethod pushed previously
        //
        pop     ebp
        pop     ecx
        //
        // Vector through delegatee's table
        //
        mov     ecx, [esp + 4]              // fetch delegatee's this pointer
        mov     ecx, [ecx]                  // get his vtable pointer
        mov     ecx, [ecx + 4*edx]          // get iMethod's entry in that vtable
        jmp     ecx
        }
    }

//
/////////////////////////////////////////////////////////////////////////


#include "vtableimpl.h"

defineVtableMethods()

defineVtable(g_ProxyForwarderVtable, N(ComPs_IUnknown_QueryInterface_Proxy), N(ComPs_IUnknown_AddRef_Proxy), N(ComPs_IUnknown_Release_Proxy))
// Note that in the NDR system ForwarderVtable begins with Forwarding_QueryInterface, etc, which 
// end up being junk IUnknown methods. We choose here not to have junk.
//

////////////////////////////////////////////////////////////////////////////////////////////


#endif // _X86_


////////////////////////////////////////////////////////////////////////////////////////////
//
// Definition of the method thunks for stub forwarders
//
// This forwarding vtable is convolutedly used in situations where an interface stub wishes
// to delegate some its functionality to some other interface stub. We end up being the
// 'server object' to that base stub; when invoked, we just forward the call along to the
// real server object.
//
////////////////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT ForwarderStub_QueryInterface(IUnknown* This, REFIID iid, void**ppv)
    {
    return ForwardingInterfaceStub::From((const void*)This)->QueryInterface(iid, ppv);
    }
extern "C" ULONG ForwarderStub_AddRef(IUnknown* This)
    {
    return ForwardingInterfaceStub::From((const void*)This)->AddRef();
    }
extern "C" ULONG ForwarderStub_Release(IUnknown* This)
    {
    return ForwardingInterfaceStub::From((const void*)This)->Release();
    }


//
/////////////////////////////////////////////////////////////////////////
//

#ifdef _X86_

#undef  methname
#define methname(i) __ForwarderStub_meth##i

#undef  meth
#define meth(i)                                                         \
HRESULT __declspec(naked) methname(i)(void* this_, ...)                 \
    {                                                                   \
    __asm push i                                                        \
    __asm jmp ForwarderStubThunk                                        \
    }


void __declspec(naked) ForwarderStubThunk(ULONG iMethod, const void* This, ...)
    {
    // Manually establish a stack frame so that references to locals herein will work
    // 
    __asm 
        {
        push     ebp
        mov      ebp, esp
        }

    // Change 'this' pointer on stack to refer to server object
    // 
    This = ForwardingInterfaceStub::From(This)->m_punkServerObject;

    __asm {
        //
        // Get the method number into edx. In actuality, the return address
        // is where the compiler thinks iMethod is, and iMethod is where the
        // return address is:
        //
        //      12  this_
        //      8   return address
        //      4   iMethod
        //      0   saved ebp
        //      
        mov     edx, 4[ebp]
        // 
        // Pop the above established stack frame, and the extra iMethod pushed previously
        //
        pop     ebp
        pop     ecx
        //
        // Vector through delegatee's table
        //
        mov     ecx, [esp + 4]              // fetch delegatee's this pointer
        mov     ecx, [ecx]                  // get his vtable pointer
        mov     ecx, [eax + 4*edx]          // get iMethod's entry in that vtable
        jmp     ecx
        }
    }

//
/////////////////////////////////////////////////////////////////////////


#include "vtableimpl.h"

defineVtableMethods()

defineVtable(g_StubForwarderVtable, ForwarderStub_QueryInterface, ForwarderStub_AddRef, ForwarderStub_Release)

////////////////////////////////////////////////////////////////////////////////////////////


#endif // _X86_


#if defined(_AMD64_) || defined(_IA64_)

#include "vtableimpl.h"

#define methname(i) __ForwarderProxy_meth##i

#define meth(i)                                                         \
extern "C" HRESULT methname(i)(void* this_, ...);

defineVtableMethods()
defineVtable(g_ProxyForwarderVtable, N(ComPs_IUnknown_QueryInterface_Proxy), N(ComPs_IUnknown_AddRef_Proxy), N(ComPs_IUnknown_Release_Proxy))

#undef  methname
#define methname(i) __ForwarderStub_meth##i

#undef meth
#define meth(i) \
extern "C" HRESULT methname(i)(void* const this_, ...);

defineVtableMethods()
defineVtable(g_StubForwarderVtable, ForwarderStub_QueryInterface, ForwarderStub_AddRef, ForwarderStub_Release)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\interceptor.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Interceptor.h
//
#include "CallFrameImpl.h"

extern "C" const PFN_VTABLE_ENTRY g_InterceptorVtable[];

#ifndef KERNELMODE
struct TYPEINFOVTBL;
#endif

class Interceptor :
        ICallInterceptor,
        ICallUnmarshal,
        IInterfaceRelated,
        IInterceptorBase,
        IUnkInner
    {
friend class CallFrame;

public:
    ///////////////////////////////////////////////////////////////////
    //
    // Public instantiation
    //
    ///////////////////////////////////////////////////////////////////

    static HRESULT For               (REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor);
	static HRESULT ForTypeInfo		 (REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv);
    static HRESULT TryInterfaceHelper(REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor, BOOL* pfDisableTyplib);
    static HRESULT TryTypeLib        (REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor);

    // Versions of For and ForInterfaceHelper which honor different disable keys so ole32 can selectively
    // disable interceptors without affecting other components.
    static HRESULT ForOle32                  (REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor);
    static HRESULT TryInterfaceHelperForOle32(REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor, BOOL* pfDisableTyplib);
    

private:
	static HRESULT CreateFromTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv);

private:
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    ICallFrameEvents*               m_pCallSink;        // the sink who wants to hear of our calls, if any 

public:
    const PFN_VTABLE_ENTRY*         m_pvtbl;            // the intercepted vtable, the address of which is our interface pointer of interception

private:
    //
    MD_INTERFACE*                   m_pmdInterface;
    const CInterfaceStubHeader*     m_pHeader;          // meta data for our interface
    const ProxyFileInfo **          m_pProxyFileList;   // meta data for the whole proxy dll of which we are a part
    //
    LPCSTR                          m_szInterfaceName;  // the name of our interface: someone else owns the allocation, not us
    //
    // Support for typeinfo-based interceptors
    //
    BOOL                            m_fMdOwnsHeader;    // does our MD_INTERFACE own m_pHeader?
    #ifndef KERNELMODE
    BOOL                            m_fUsingTypelib;    // whether we're a typeinfo-based interceptor or not
    TYPEINFOVTBL*                   m_ptypeinfovtbl;    // our TYPEINFOVTBL if we are
    #endif
    //
    // Support for delegating to a 'base' interceptor. Necessary given how MIDL emits the meta data
    //
    unsigned int                    m_cMethodsBase;         // number of methods in the base interface
    ICallInterceptor*               m_pBaseInterceptor;     // the base interceptor, if we have to have one
    IUnknown*                       m_punkBaseInterceptor;  // controlling unknown on our base interceptor
    //
    // Support for being a base interceptor
    //
    MD_INTERFACE*                   m_pmdMostDerived;       // If we're a base, then the most derived interface that we actually service


    ///////////////////////////////////////////////////////////////////
    //
    // Construction / initialization
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<Interceptor>;
    friend class ComPsClassFactory;
    friend HRESULT STDMETHODCALLTYPE Interceptor_QueryInterface(IUnknown* This, REFIID riid, void** ppv);
    friend ULONG   STDMETHODCALLTYPE Interceptor_AddRef(IUnknown* This);
    friend ULONG   STDMETHODCALLTYPE Interceptor_Release(IUnknown* This);
    friend void                      InterceptorThunk(ULONG extraParam, IUnknown* This, ...);
    friend struct LEGACY_INTERCEPTOR;

    Interceptor(IUnknown* punkOuter = NULL)
        {
        m_refs              = 1;            // nb starts at one
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pCallSink         = NULL;
        m_pmdInterface      = NULL;
        m_pmdMostDerived    = NULL;
        m_pHeader           = NULL;
        m_pProxyFileList    = NULL;
        m_pvtbl             = g_InterceptorVtable;
        m_cMethodsBase      = 0;
        m_pBaseInterceptor  = NULL;
        m_punkBaseInterceptor = NULL;
        m_szInterfaceName   = NULL;

        m_fMdOwnsHeader     = FALSE;
        #ifndef KERNELMODE
        m_fUsingTypelib     = FALSE;
        m_ptypeinfovtbl     = NULL;
        #endif
        }

    virtual ~Interceptor();

    HRESULT Init()
        {
        return S_OK;
        }

    HRESULT InitUsingTypeInfo(REFIID i_riidIntercepted, ITypeInfo * i_pITypeInfo);

    HRESULT SetMetaData(TYPEINFOVTBL* pTypeInfoVtbl);

    ///////////////////////////////////////////////////////////////////
    //
    // IInterceptorBase
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetAsBaseFor(MD_INTERFACE* pmdMostDerived, BOOL* pfDerivesFromIDispatch)
        {
        HRESULT hr = S_OK;
        ASSERT(pmdMostDerived);
        // 
        // Remember this ourselves
        //
        ::Set(m_pmdMostDerived, pmdMostDerived);
        *pfDerivesFromIDispatch = FALSE;
        //
        // Let OUR base know the actual bottom level!
        //
        if (m_punkBaseInterceptor)
            {
            IInterceptorBase* pbase;
            hr = QI(m_punkBaseInterceptor, pbase);
            if (!hr)
                {
                pbase->SetAsBaseFor(pmdMostDerived, pfDerivesFromIDispatch);
                pbase->Release();
                }
            }
            
        return hr;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect / ICallInterceptor, IInterfaceRelated
    //
    ///////////////////////////////////////////////////////////////////
public:
    HRESULT STDCALL CallIndirect    (HRESULT* phrReturnValue, ULONG iMethod, void* pvArgs, ULONG* pcbArgs); 
private:
    HRESULT STDCALL GetStackSize    (ULONG iMethod, ULONG* pcbArgs);

    HRESULT STDCALL GetIID          (IID* piid, BOOL* pfDerivesFromIDispatch, ULONG* pcMethod, LPWSTR* pwszInterface)
        {
        HRESULT hr = S_OK;

        if (m_pHeader)
            {
            if (piid) 
                {
                if (m_pmdMostDerived)
                    {
                    *piid = *m_pmdMostDerived->m_pHeader->piid;
                    }
                else
                    {
                    *piid = *m_pHeader->piid;
                    }
                }
            if (pfDerivesFromIDispatch)
                {
                *pfDerivesFromIDispatch = m_pmdInterface->m_fDerivesFromIDispatch;
                }
            if (pcMethod) 
                {
                if (m_pmdMostDerived)
                    {
                    *pcMethod = m_pmdMostDerived->m_pHeader->DispatchTableCount;
                    }
                else
                    {
                    *pcMethod = m_pHeader->DispatchTableCount;
                    }
                }
            if (pwszInterface)
                {
                *pwszInterface = NULL;

                if (m_pmdMostDerived)
                    {
                    if (m_pmdMostDerived->m_szInterfaceName)
                        {
                        *pwszInterface = ToUnicode(m_pmdMostDerived->m_szInterfaceName);
                        if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
                        }
                    }
                else if (m_pmdInterface->m_szInterfaceName)
                    {
                    *pwszInterface = ToUnicode(m_pmdInterface->m_szInterfaceName);
                    if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
                    }
                }
            return S_OK;
            }
        else
            hr = E_UNEXPECTED;

        return hr;
        }

    HRESULT STDCALL GetMethodInfo   (ULONG, CALLFRAMEINFO*, LPWSTR* pwszMethod);

    HRESULT STDCALL GetIID          (IID* piid)
        {
        if (m_pHeader)
            {
            if (piid)     *piid     = *m_pHeader->piid;
            return S_OK;
            }
        else
            return E_UNEXPECTED;
        }

    HRESULT STDCALL SetIID          (REFIID);

    HRESULT STDCALL RegisterSink    (ICallFrameEvents* psink)
        {
        ::SetConcurrent(m_pCallSink, psink);
        if (m_pBaseInterceptor) m_pBaseInterceptor->RegisterSink(psink);
        return S_OK;
        }

    HRESULT STDCALL GetRegisteredSink(ICallFrameEvents** ppsink)
        {
        *ppsink = NULL; // set concurrent releases what was there, if anything was
        ::SetConcurrent(*ppsink, m_pCallSink);
        return *ppsink ? S_OK : CO_E_OBJNOTREG;
        }


    ///////////////////////////////////////////////////////////////////
    //
    // ICallUnmarshal
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL Unmarshal(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, BOOL fForceBufferCopy, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarshalled, ICallFrame** ppFrame);
    HRESULT STDCALL ReleaseMarshalData(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);

    // Xml Marshalling
    HRESULT STDCALL UnmarshalXml(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, BOOL fForceBufferCopy, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarshalled, ICallFrame** ppFrame);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    IUnknown* InnerUnknown()    { return (IUnknown*)(void*)(IUnkInner*)this; }
    };


////////////////////////////////////////////////////////////////////////////////////////////
//
// Channel object to help with marshalling and unmarshalling
//
////////////////////////////////////////////////////////////////////////////////////////////

struct MarshallingChannel : IRpcChannelBuffer, IMarshallingManager, IUnkInner
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    IMarshallingManager* m_pMarshaller;
    ULONG                m_dwDestContext;
    PVOID                m_pvDestContext;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    MarshallingChannel(IUnknown* punkOuter = NULL)
        {
        m_refs              = 1;    // nb starts at one. In stack alloc case, it remains there
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pMarshaller       = NULL;
        }
        
    ~MarshallingChannel()
        {
        ::Release(m_pMarshaller);
        }
        

    ///////////////////////////////////////////////////////////////////
    //
    // IMarshallingManager
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetMarshallerFor(REFIID iidToMarshal, void*pv, IMarshalSomeone** ppMarshal)
        {
        if (m_pMarshaller)
            return m_pMarshaller->GetMarshallerFor(iidToMarshal, pv, ppMarshal);
        else    
            {
            *ppMarshal = NULL;
            return E_UNEXPECTED;
            }
        }

    HRESULT STDCALL GetStandardMarshallerFor(REFIID iidToMarshal, PVOID pv, IUnknown* punkOuter, REFIID iid, void** ppv)
        {
        if (m_pMarshaller)
            return m_pMarshaller->GetStandardMarshallerFor(iidToMarshal, pv, punkOuter, iid, ppv);
        else    
            {
            *ppv= NULL;
            return E_UNEXPECTED;
            }
        }

    HRESULT STDCALL GetUnmarshaller(REFIID iidHint, IMarshalSomeone** ppMarshal)
        {
        if (m_pMarshaller)
            return m_pMarshaller->GetUnmarshaller(iidHint, ppMarshal);
        else
            {
            *ppMarshal = NULL;
            return E_UNEXPECTED;
            }
        }

    ///////////////////////////////////////////////////////////////////
    //
    // IRpcChannelBuffer. We implement only to be able to be stuck into a stub message
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetBuffer(RPCOLEMESSAGE *pMessage, REFIID riid)         { return E_NOTIMPL; }
    HRESULT STDCALL SendReceive(RPCOLEMESSAGE *pMessage, ULONG *pStatus)    { return E_NOTIMPL; }
    HRESULT STDCALL FreeBuffer(RPCOLEMESSAGE *pMessage)                     { return E_NOTIMPL; }
    HRESULT STDCALL GetDestCtx(DWORD *pdwDestContext,void **ppvDestContext) 
        { 
        *pdwDestContext = m_dwDestContext;
        *ppvDestContext = m_pvDestContext;
        return S_OK;
        }
    HRESULT STDCALL IsConnected()                                           { return E_NOTIMPL; }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv)
        {
        if (iid == IID_IRpcChannelBuffer)
            {
            *ppv = (IRpcChannelBuffer*)this;
            }
        else if (iid == __uuidof(IMarshallingManager))
            {
            *ppv = (IMarshallingManager*)this;
            }
        else if (iid == IID_IUnknown)
            {
            *ppv = (IUnkInner*)this;
            }
        else
            {
            *ppv = NULL;
            return E_NOINTERFACE;
            }
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
        }
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\interceptor.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Interceptor.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "typeinfo.h"
#include "tiutil.h"
#include "CLegInterface.H"

#include <debnot.h>

#include "cache.h"

extern CALLFRAME_CACHE<INTERFACE_HELPER_CLSID>* g_pihCache;

/////////////////////////////////////////////////////////////////////////////////
//
// Registry support for disabling interceptors works as follows:
//
//  HKCR/Interface/"InterfaceHelperDisableAll"      - disables all interceptors
//  HKCR/Interface/"InterfaceHelperDisableTypeLib"  - disables all typelib-based interceptors
//   
//  HKCR/Interface/{iid}/"InterfaceHelperDisableAll"      - disables all interceptors for this IID
//  HKCR/Interface/{iid}/"InterfaceHelperDisableTypeLib"  - disables typelib-based interceptor for this IID
//
#define CALLFRAME_E_DISABLE_INTERCEPTOR (HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED))

BOOL FDisableAssociatedInterceptor(HREG hkey, LPCWSTR wsz)
// Answer as to whether there's an indicatation that interceptors semantically
// related to this key should be disabled.
{
    HRESULT hr = S_OK;

    BOOL fDisable = FALSE;

    PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
    hr = GetRegistryValue(hkey, wsz, &pinfo, REG_SZ);
    Win4Assert(pinfo || FAILED(hr));
        if (!hr && pinfo)
        {
        // Disable if is not N or is non-zero
        //
        LPWSTR wsz = StringFromRegInfo(pinfo);
        if (wcslen(wsz) > 0)
                {
            LPWSTR wszEnd;
            LONG l = wcstol(wsz, &wszEnd, 10);
            if (wsz[0] == 'n' || wsz[0] == 'N' || l == 0)
                        {
                fDisable = FALSE;
                        }
            else
                        {
                fDisable = TRUE;
                        }
                }
        else
                {
            fDisable = TRUE;    // empty value
                }
        FreeMemory(pinfo);
        }
    else
        {
        // No disable key: leave enabled
        }

    return fDisable;
}


struct DISABLED_FEATURES
{
    BOOL    fDisableAll;
    BOOL    fDisableTypelibs;
    BOOL    fDisableDispatch;
    BOOL    fDisableAllForOle32;
    BOOL    fDisableDispatchForOle32;

    void INIT_DISABLED_FEATURES()
    {
        HRESULT hr = S_OK;
        HREG hkey;        
        hr = OpenRegistryKey(&hkey, HREG(), L"\\Registry\\Machine\\Software\\Classes\\Interface");
        if (!hr)
        {
            fDisableAll         = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME);
            fDisableAllForOle32 = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_FOR_OLE32_VALUE_NAME);
            fDisableTypelibs    = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_TYPELIB_VALUE_NAME);

            CloseRegistryKey(hkey);
        }
        hr = OpenRegistryKey(&hkey, HREG(), L"\\Registry\\Machine\\Software\\Classes\\Interface\\{00020400-0000-0000-C000-000000000046}");
        if (!hr)
        {
            fDisableDispatch         = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME);
            fDisableDispatchForOle32 = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_FOR_OLE32_VALUE_NAME);
            CloseRegistryKey(hkey);
        }
    }
} g_DISABLED_FEATURES;

BOOL InitDisabledFeatures(void)
{
        g_DISABLED_FEATURES.INIT_DISABLED_FEATURES();

        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Public API
//
/////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT STDCALL CoGetInterceptor(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppInterceptor)
{
    return Interceptor::For(iidIntercepted, punkOuter, iid, ppInterceptor);
}

extern "C" HRESULT STDCALL CoGetInterceptorFromTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* typeInfo, REFIID iid, void** ppInterceptor)
{
        return Interceptor::ForTypeInfo(iidIntercepted, punkOuter, typeInfo, iid, ppInterceptor);
}

extern "C" HRESULT STDCALL CoGetInterceptorForOle32(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppInterceptor)
{
    return Interceptor::ForOle32(iidIntercepted, punkOuter, iid, ppInterceptor);
}

/////////////////////////////////////////////////////////////////////////////////
//
// Constuction / destruction
//
/////////////////////////////////////////////////////////////////////////////////

Interceptor::~Interceptor()
{
    ::Release(m_pCallSink);
    ::Release(m_pBaseInterceptor);
    ::Release(m_punkBaseInterceptor);
    ::Release(m_pmdInterface);
    ::Release(m_pmdMostDerived);

    ::Release(m_ptypeinfovtbl);
    if (m_fUsingTypelib && !m_fMdOwnsHeader)
    {
        delete const_cast<CInterfaceStubHeader*>(m_pHeader); // See Interceptor::InitUsingTypeInfo
    }
}



HRESULT GetInterfaceHelperClsid(REFIID iid, CLSID* pClsid, BOOL* pfDisableTypelib)
// Answer the CLSID that should serve as the interceptor for the indicated interface. 
// This only looks for the "InterfaceHelper" override.
//
// Returns CALLFRAME_E_DISABLE_INTERCEPTOR if all interceptor functionality for this INTERFACE
// is to be disabled.
//
{
    HRESULT hr = S_OK, hrTemp;

    INTERFACE_HELPER_CLSID* pihCached, * pihInCache;

    // Give the cache a try
    if (!g_pihCache->FindExisting (iid, &pihCached))
    {
        ASSERT (pihCached);
        
        //
        // Imitate the logic below
        //
        
        // Disable typelib?
        *pfDisableTypelib = pihCached->m_fDisableTypeLib;

        // Disable all?
        if (pihCached->m_fDisableAll)
        {
            hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
        }
        else
        {
            if (pihCached->m_fFoundHelper)
            {
                *pClsid = pihCached->m_clsid;
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
            }
        }          

        // Release our reference
        pihCached->Release();

        return hr;
    }

    //
    // Cache miss
    //
    
    WCHAR wszKey[20 + GUID_CCH];
    wcscpy(wszKey, L"Interface\\");
    StringFromGuid(iid, &wszKey[wcslen(wszKey)]);

    HREG hkey;
    LPWSTR wszFullKeyName;

    BOOL bAddedToCache = FALSE;

    *pfDisableTypelib = FALSE;

    pihCached = new INTERFACE_HELPER_CLSID();   // Initializes everything to false
    if (!pihCached)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pihCached->m_guidkey = iid;

        hr = StringCat(&wszFullKeyName, L"\\Registry\\Machine\\Software\\Classes\\", wszKey, NULL);
        if (!hr)
        {
            hr = OpenRegistryKey(&hkey, HREG(), wszFullKeyName);
            if (!hr)
            {
                // See if we should avoid looking for interceptors 
                //
                if (FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_TYPELIB_VALUE_NAME))
                {
                    *pfDisableTypelib = TRUE;
                    pihCached->m_fDisableTypeLib = TRUE;
                }

                if (FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME))
                {
                    hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
                    pihCached->m_fDisableAll = TRUE;
                }
                else
                {
                    PKEY_VALUE_FULL_INFORMATION pinfo;
                    hr = GetRegistryValue(hkey, INTERFACE_HELPER_VALUE_NAME, &pinfo, REG_SZ);
                    if (!hr)
                    {
                        LPWSTR wszClsid = StringFromRegInfo(pinfo);
                        //
                        // Got the classid. Convert it!
                        //
                        hr = GuidFromString(&wszClsid[0], pClsid);

                        pihCached->m_fFoundHelper = TRUE;
                        pihCached->m_clsid = *pClsid;

                        FreeMemory(pinfo);
                    }
                }
                CloseRegistryKey(hkey);
            }
            FreeMemory(wszFullKeyName);

            // Add to cache
            hrTemp = pihCached->AddToCache (g_pihCache);
            if (!hrTemp)
            {
                bAddedToCache = TRUE;

                // Leave references at zero, because the cache shouldn't hold a reference
                // This allows us to time references out
                pihCached->Release();
            }
        }

        // Clean up entry if it didn't find its way to the cache
        if (!bAddedToCache)
        {
            delete pihCached;
        }
    }

    return hr;
}


HRESULT Interceptor::For(REFIID iidIntercepted, IUnknown *punkOuter, REFIID iid, void** ppv)
// Dynamically lookup and return the interceptor which services the given interface
//
{
    HRESULT hr = g_DISABLED_FEATURES.fDisableAll ? CALLFRAME_E_DISABLE_INTERCEPTOR : S_OK;

#if defined(_DEBUG) && 0
    //
    // Make sure our disabling support is not sensitive to load time.
    //
    DISABLED_FEATURES disabled;
    ASSERT(!!disabled.fDisableAll              ==  !!g_DISABLED_FEATURES.fDisableAll);
    ASSERT(!!disabled.fDisableAllForOle32      ==  !!g_DISABLED_FEATURES.fDisableAllForOle32);
    ASSERT(!!disabled.fDisableTypelibs         ==  !!g_DISABLED_FEATURES.fDisableTypelibs);
    ASSERT(!!disabled.fDisableDispatch         ==  !!g_DISABLED_FEATURES.fDisableDispatch);
    ASSERT(!!disabled.fDisableDispatchForOle32 ==  !!g_DISABLED_FEATURES.fDisableDispatchForOle32);
#endif

    *ppv = NULL;

    if (punkOuter && iid != IID_IUnknown)
    {
        // If aggregating, then you must ask for IUnknown
        //
        return E_INVALIDARG;
    }
    //
    // First attempt to create an interceptor using the InterfaceHelper key
    //
    BOOL fDisableTypelib = FALSE;
    if (!hr)
    {
        hr = Interceptor::TryInterfaceHelper(iidIntercepted, punkOuter, iid, ppv, &fDisableTypelib);
    }
    //
    //
    if (!hr)
    {
        // All is well
    }
    else if (fDisableTypelib)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    else if (hr != CALLFRAME_E_DISABLE_INTERCEPTOR)
    {
        // Can't get a MIDL-oriented interceptor; try something else.
        //
        if (ENABLE_INTERCEPTORS_TYPELIB)
        {
            //
            // There must not be an interfacehelper attribute for this iid, try the typelib path.
            // But not in kernel mode, as that causes linkages problems.
            //
            hr = Interceptor::TryTypeLib(iidIntercepted, punkOuter, iid, ppv);
        }
    }

    if (!hr)
    {
        ASSERT (*ppv);
    }

    return hr;
}

HRESULT Interceptor::ForOle32(REFIID iidIntercepted, IUnknown *punkOuter, REFIID iid, void** ppv)
// Dynamically lookup and return the interceptor which services the given interface
//
{
    HRESULT hr = g_DISABLED_FEATURES.fDisableAllForOle32 ? CALLFRAME_E_DISABLE_INTERCEPTOR : S_OK;

#if defined(_DEBUG) && 0
    //
    // Make sure our disabling support is not sensitive to load time.
    //
    DISABLED_FEATURES disabled;
    ASSERT(!!disabled.fDisableAll              ==  !!g_DISABLED_FEATURES.fDisableAll);
    ASSERT(!!disabled.fDisableAllForOle32      ==  !!g_DISABLED_FEATURES.fDisableAllForOle32);
    ASSERT(!!disabled.fDisableTypelibs         ==  !!g_DISABLED_FEATURES.fDisableTypelibs);
    ASSERT(!!disabled.fDisableDispatch         ==  !!g_DISABLED_FEATURES.fDisableDispatch);
    ASSERT(!!disabled.fDisableDispatchForOle32 ==  !!g_DISABLED_FEATURES.fDisableDispatchForOle32);
#endif

    *ppv = NULL;

    if (punkOuter && iid != IID_IUnknown)
    {
        // If aggregating, then you must ask for IUnknown
        //
        return E_INVALIDARG;
    }
    //
    // First attempt to create an interceptor using the InterfaceHelper key
    //
    BOOL fDisableTypelib = FALSE;
    if (!hr)
    {
        hr = Interceptor::TryInterfaceHelperForOle32(iidIntercepted, punkOuter, iid, ppv, &fDisableTypelib);
    }
    //
    //
    if (!hr)
    {
        // All is well
    }
    else if (fDisableTypelib)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    else if (hr != CALLFRAME_E_DISABLE_INTERCEPTOR)
    {
        // Can't get a MIDL-oriented interceptor; try something else.
        //
        if (ENABLE_INTERCEPTORS_TYPELIB)
        {
            //
            // There must not be an interfacehelper attribute for this iid, try the typelib path.
            // But not in kernel mode, as that causes linkages problems.
            //
            hr = Interceptor::TryTypeLib(iidIntercepted, punkOuter, iid, ppv);
        }
    }

    if (!hr)
    {
        ASSERT (*ppv);
    }

    return hr;
}

HRESULT Interceptor::ForTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv)
// Create an interceptor for a given ITypeInfo that describes iidIntercepted.
//
{
    HRESULT hr = g_DISABLED_FEATURES.fDisableAll ? CALLFRAME_E_DISABLE_INTERCEPTOR : S_OK;

#if defined(_DEBUG) && 0
    //
    // Make sure our disabling support is not sensitive to load time.
    //
    DISABLED_FEATURES disabled;
    ASSERT(!!disabled.fDisableAll      ==  !!g_DISABLED_FEATURES.fDisableAll);
    ASSERT(!!disabled.fDisableTypelibs ==  !!g_DISABLED_FEATURES.fDisableTypelibs);
    ASSERT(!!disabled.fDisableDispatch ==  !!g_DISABLED_FEATURES.fDisableDispatch);
#endif

    *ppv = NULL;

    if (punkOuter && iid != IID_IUnknown)
    {
        // If aggregating, then you must ask for IUnknown
        //
        return E_INVALIDARG;
    }

        // 
        // First, try an interface helper
        // 
    BOOL fDisableTypelib = FALSE;
    hr = Interceptor::TryInterfaceHelper(iidIntercepted, punkOuter, iid, ppv, &fDisableTypelib);
        if (!hr)
    {
                // All is well, the interface helper handled it.
    }
    else if (fDisableTypelib)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    else if (hr != CALLFRAME_E_DISABLE_INTERCEPTOR)
    {
        // Can't get a MIDL-oriented interceptor; try something else.
        //
        if (ENABLE_INTERCEPTORS_TYPELIB)
        {
            //
            // There must not be an interfacehelper attribute for this iid, use the
            // typeinfo.  But not in kernel mode, as that causes linkages problems.
            //
            hr = CreateFromTypeInfo(iidIntercepted, punkOuter, pITypeInfo, iid, ppv);
        }
    }

        return hr;
}

HRESULT Interceptor::TryInterfaceHelper(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppv, BOOL* pfDisableTypelib)
// Lookup and return the interceptor, if any, which services the given intercepted interface
//
// Returns CALLFRAME_E_DISABLE_INTERCEPTOR if all interceptor functionality for this INTERFACE
// is to be disabled.
//
{
    HRESULT hr = S_OK;
    CLSID   clsid;
    IUnknown* punk = NULL;
    //
    *ppv = NULL;
    *pfDisableTypelib = FALSE;
    //
    if (ENABLE_INTERCEPTORS_LEGACY && (iidIntercepted == IID_IDispatch))
    {
        // We have a special-case implementation for the requested iid. Always get the 
        // inner unknown on it.
        // 
        if (!g_DISABLED_FEATURES.fDisableDispatch)
        {
            hr = GenericInstantiator<DISPATCH_INTERCEPTOR>::CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
        }
        else
        {
            hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
            *pfDisableTypelib = TRUE;
        }
    }
    else
    {
        // We try to find dynamically installed helpers
        //
        hr = GetInterfaceHelperClsid(iidIntercepted, &clsid, pfDisableTypelib);
        if (!hr)
        {
            IClassFactory* pcf;

                        hr = CoGetClassObject(clsid, CLSCTX_PROXY_STUB, NULL, IID_IClassFactory, (void**)&pcf);

            if (!hr)
            {
                // Always ask for the inner unknown
                //
                hr = pcf->CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
                pcf->Release();
            }
        }
    }

    if (!hr)
    {
        ASSERT(punk);
        IInterfaceRelated* pSet;
        hr = punk->QueryInterface(__uuidof(IInterfaceRelated), (void**)&pSet);
        if (!hr)
        {
            hr = pSet->SetIID(iidIntercepted);
            if (!hr)
            {
                // Ask the inner unknown for the interface they guy wants
                //
                hr = punk->QueryInterface(iid, ppv);
            }
            pSet->Release();
        }
    }

    ::Release(punk);

    return hr;
}

HRESULT Interceptor::TryInterfaceHelperForOle32(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppv, BOOL* pfDisableTypelib)
// Lookup and return the interceptor, if any, which services the given intercepted interface
//
// Returns CALLFRAME_E_DISABLE_INTERCEPTOR if all interceptor functionality for this INTERFACE
// is to be disabled.
//
{
    HRESULT hr = S_OK;
    CLSID   clsid;
    IUnknown* punk = NULL;
    //
    *ppv = NULL;
    *pfDisableTypelib = FALSE;
    //
    if (ENABLE_INTERCEPTORS_LEGACY && (iidIntercepted == IID_IDispatch))
    {
        // We have a special-case implementation for the requested iid. Always get the 
        // inner unknown on it.
        // 
        if (!g_DISABLED_FEATURES.fDisableDispatchForOle32)
        {
            hr = GenericInstantiator<DISPATCH_INTERCEPTOR>::CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
        }
        else
        {
            hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
            *pfDisableTypelib = TRUE;
        }
    }
    else
    {
        // We try to find dynamically installed helpers
        //
        hr = GetInterfaceHelperClsid(iidIntercepted, &clsid, pfDisableTypelib);
        if (!hr)
        {
            IClassFactory* pcf;

                        hr = CoGetClassObject(clsid, CLSCTX_PROXY_STUB, NULL, IID_IClassFactory, (void**)&pcf);

            if (!hr)
            {
                // Always ask for the inner unknown
                //
                hr = pcf->CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
                pcf->Release();
            }
        }
    }

    if (!hr)
    {
        ASSERT(punk);
        IInterfaceRelated* pSet;
        hr = punk->QueryInterface(__uuidof(IInterfaceRelated), (void**)&pSet);
        if (!hr)
        {
            hr = pSet->SetIID(iidIntercepted);
            if (!hr)
            {
                // Ask the inner unknown for the interface they guy wants
                //
                hr = punk->QueryInterface(iid, ppv);
            }
            pSet->Release();
        }
    }

    ::Release(punk);

    return hr;
}


HRESULT Interceptor::TryTypeLib(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppv)
// Try to create a typelib-based interceptor for the indicated interface
//
{
    HRESULT         hr              = S_OK;
    CLSID           clsid           = CLSID_NULL;
    Interceptor *   pInterceptor    = NULL;

    if (g_DISABLED_FEATURES.fDisableTypelibs)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    
    if (!hr)
    {
        // Create a new interceptor from the ITypeInfo.
        //
                hr = CreateFromTypeInfo(iidIntercepted, punkOuter, NULL, iid, ppv);
    }

    return hr;
} //end TryTypeLib

HRESULT Interceptor::CreateFromTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv)
{
        HRESULT hr = S_OK;

        Interceptor* pInterceptor = new Interceptor(punkOuter);
        if (pInterceptor)
    {
                // Initialize the interceptor
                //
                hr = pInterceptor->InitUsingTypeInfo(iidIntercepted, pITypeInfo);
                if (!hr)    
        {
                        // Give caller his interface
                        //
                        hr = pInterceptor->InnerQueryInterface(iid, ppv);
        }
                //
                // Release the initial reference that 'new' gave us.
                //
                pInterceptor->InnerRelease();
    }
        else
                hr = E_OUTOFMEMORY;

        return hr;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Initialization
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT Interceptor::InitUsingTypeInfo(REFIID iidIntercepted, ITypeInfo * ptypeinfo)
// Initialize a typelib-based interceptor
//
{
    HRESULT                 hr              = S_OK;
    TYPEINFOVTBL *          pTypeInfoVtbl   = 0x0;  
    CInterfaceStubHeader *  pHeader         = 0x0;
        ITypeInfo*                              pBaseTypeInfo   = 0x0;
    //
    // Get the meta information regarding this interface. This gives us a new refcnt
    // 
    hr = GetVtbl(ptypeinfo, iidIntercepted, &pTypeInfoVtbl, &pBaseTypeInfo);
    if (!hr)
    {
        // Create a CInterfaceStubHeader object to store the information
        //
        pHeader = new CInterfaceStubHeader;
        if (pHeader)
        {
            // Remember that this uses the typelib to get the interface meta data
            //
            m_fUsingTypelib = TRUE;

            // initialize the structure
            //
            pHeader->piid               = &(pTypeInfoVtbl->m_guidkey);              
            pHeader->pServerInfo        = &(pTypeInfoVtbl->m_stubInfo); 
            pHeader->DispatchTableCount =  (pTypeInfoVtbl->m_stubVtbl.header.DispatchTableCount);
            pHeader->pDispatchTable     =  (pTypeInfoVtbl->m_stubVtbl.header.pDispatchTable);
            //
            // initialize our meta data therefrom
            //
            ASSERT(NULL == m_pHeader);
            m_pHeader       = pHeader;
            m_fMdOwnsHeader = FALSE;
            m_ptypeinfovtbl = pTypeInfoVtbl;
            m_ptypeinfovtbl->AddRef();
            //
            m_szInterfaceName = pTypeInfoVtbl->m_szInterfaceName; // share a ref, but we don't own it!
            //
            // Set our new meta data
            //
            hr = SetMetaData(pTypeInfoVtbl);

            if (!hr)
            {
                // Delegate base methods if appropriate
                //
                if (m_ptypeinfovtbl->m_iidBase != GUID_NULL && m_ptypeinfovtbl->m_iidBase != __uuidof(IUnknown))
                {
                    IID iidBase = m_ptypeinfovtbl->m_iidBase;
                    //
                    ASSERT(NULL == m_pBaseInterceptor);
                    ASSERT(NULL == m_punkBaseInterceptor);
                    //
                    hr = Interceptor::ForTypeInfo(iidBase, NULL, pBaseTypeInfo, IID_IUnknown, (void **) &m_punkBaseInterceptor);
                    if (!hr)
                    {
                        hr = m_punkBaseInterceptor->QueryInterface(__uuidof(ICallInterceptor), (void**)&m_pBaseInterceptor);
                        if (!hr)
                        {
                            // Ask the base interface how many methods he has
                            //
                            ULONG cMethodsBase;
                            hr = m_pBaseInterceptor->GetIID(NULL, NULL, &cMethodsBase, NULL);
                            if (!hr)
                            {
                                m_cMethodsBase = (unsigned int)cMethodsBase;
                                //ASSERT(m_cMethodsBase == m_pmdInterface->m_cMethodsInBaseInterface);
                            }
                        }
                    }
                    if (!hr)
                    {
                        // Tell the base interceptor that he is in fact a base!
                        //
                        IInterceptorBase* pbase;
                        hr = QI(m_punkBaseInterceptor, pbase);
                        if (!hr)
                        {
                            BOOL fDerivesFromIDispatch;
                            hr = pbase->SetAsBaseFor(m_pmdInterface, &fDerivesFromIDispatch);
                            if (!hr)
                            {
                                hr = m_pmdInterface->SetDerivesFromIDispatch(fDerivesFromIDispatch);
                            }
                            pbase->Release();
                        }
                    }
                }
            }
        }
        else
            hr = E_OUTOFMEMORY;

        pTypeInfoVtbl->Release();

                if (pBaseTypeInfo != NULL)
                        pBaseTypeInfo->Release();
    }

    return hr;
} //end InityUsingTypeInfo



HRESULT Interceptor::SetIID(REFIID iid)
// Set the interface ID for this interceptor. As a side effect, we set up our 
// meta data. This method should only be called once per interceptor. 
// Further, caller must control concurrency.
{
    ASSERT(NULL == m_pBaseInterceptor);
    ASSERT(NULL == m_pHeader);
    if (m_pBaseInterceptor || m_pHeader) return E_UNEXPECTED;

    HRESULT hr = S_OK;
    long j;
    const ProxyFileInfo *pProxyFileInfo;
    //
    // Is the requested interface something that this interceptor supports?
    //
    BOOL fFound = NdrpFindInterface(m_pProxyFileList, iid, &pProxyFileInfo, &j);
    if (fFound)
    {
        // Set our meta data
        //
        IRpcStubBufferVtbl* vptr = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
        m_pHeader = HeaderFromStub((IRpcStubBuffer*)&vptr);
        //
        // Remember our interface name if it's given to us
        //
        m_szInterfaceName = pProxyFileInfo->pNamesArray[j]; // share a ref, but we don't own it!
        //
        // Set our new meta data
        //
        hr = SetMetaData(NULL);
        if (!hr)
        {
            // Set up a delegation interceptor for our base interface if we have to. When MIDL expects us to do delegation, 
            // we have no choice but to do so, since in those cases it doesn't bother to emit the meta data for the base interface.
            //
            BOOL fDelegate = 
                (pProxyFileInfo->pDelegatedIIDs     != 0) && 
                (pProxyFileInfo->pDelegatedIIDs[j]  != 0) && 
                (*pProxyFileInfo->pDelegatedIIDs[j]) != IID_IUnknown;

            if (fDelegate)
            {
                ULONG cMethodsInInterface       = pProxyFileInfo->pStubVtblList[j]->header.DispatchTableCount;
                ULONG cMethodsInBaseInterface   = GetDelegatedMethodCount(m_pHeader);
            
                m_cMethodsBase = cMethodsInBaseInterface; ASSERT(m_cMethodsBase > 3); /* since fDelegate is true, there should actually be some */
                // 
                // Instantiate the interceptor for the base interface. Since we delegate explicitly to this guy, there's
                // no point in aggregating him into us.
                //
                IID iidBase = *pProxyFileInfo->pDelegatedIIDs[j];
                ASSERT(NULL == m_pBaseInterceptor);
                hr = Interceptor::For(iidBase, NULL, IID_IUnknown, (void **) &m_punkBaseInterceptor);
                if (!hr)
                {
                    hr = m_punkBaseInterceptor->QueryInterface(__uuidof(ICallInterceptor), (void**)&m_pBaseInterceptor);
                    if (!hr)
                    {
                        // Tell the base interceptor that he is in fact a base!
                        //
                        IInterceptorBase* pbase;
                        hr = QI(m_punkBaseInterceptor, pbase);
                        if (!hr)
                        {
                            BOOL fDerivesFromIDispatch;
                            hr = pbase->SetAsBaseFor(m_pmdInterface, &fDerivesFromIDispatch);
                            if (!hr)
                            {
                                m_pmdInterface->SetDerivesFromIDispatch(fDerivesFromIDispatch);
                            }
                            pbase->Release();
                        }
                    }
                }
            }
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Meta data manipulation
//
/////////////////////////////////////////////////////////////////////////////////

MD_INTERFACE_CACHE* g_pmdCache;

BOOL InitMetaDataCache()
{
    g_pmdCache = new MD_INTERFACE_CACHE();
    if (g_pmdCache)
    {
        if (g_pmdCache->FInit()==FALSE)
        {
            ASSERT(FALSE);
            delete g_pmdCache;
	    g_pmdCache = NULL;
	}
    }
    if (NULL == g_pmdCache)
    {
        return FALSE;
    }
    return TRUE;
}

void FreeMetaDataCache()
{
    if (g_pmdCache)
        {
        delete g_pmdCache;
        g_pmdCache = NULL;
        }
}


HRESULT Interceptor::SetMetaData(TYPEINFOVTBL* pTypeInfoVtbl)
// Set our meta data based on m_pHeader && m_pmdInterface
{
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);
    ASSERT(NULL == m_pmdInterface);

    HRESULT hr2 = g_pmdCache->FindExisting(*m_pHeader->piid, &m_pmdInterface);
    if (!hr2)
    {
        // Found it in the cache
    }
    else
    {
        // Not in the cache. Make a new one.
        //
        m_pmdInterface = new MD_INTERFACE;
        if (m_pmdInterface)
        {
            LPCSTR szInterfaceName = m_szInterfaceName;
            //
            // In typelib case, give the MD_INTERFACE a COPY of the string that it can own
            // so that it doesn't depend on the lifetime of the TYPEINFOVTBL.
            //
            if (pTypeInfoVtbl)
            {
                if (szInterfaceName)
                {
                    szInterfaceName = CopyString(szInterfaceName);
                    if (NULL == szInterfaceName)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            //
            // Actually initialize our meta data
            //
            if (!hr)
            {
                hr = m_pmdInterface->SetMetaData(pTypeInfoVtbl, m_pHeader, szInterfaceName);
                if (pTypeInfoVtbl)
                {
                    m_fMdOwnsHeader = TRUE;
                }
            }

            if (!hr)
            {
                // Put it in the table if not already there; if already there, we were racing 
                // with someone else, who won. We'll use this MD_INTERFACE that we already have,
                // but we'll be the only client. Redundant, but not worth worrying about.
                //
                g_pmdCache->LockExclusive();

                if (!g_pmdCache->IncludesKey(*m_pHeader->piid))
                {
                    // One isn't yet there in the cache. Store ours
                    //
                    hr = m_pmdInterface->AddToCache(g_pmdCache);
                }

                g_pmdCache->ReleaseLock();
            }
            else
            {
                ::Release(m_pmdInterface);
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
//
// COM plumbing
//
/////////////////////////////////////////////////////////////////////////////////


HRESULT Interceptor::InnerQueryInterface(REFIID iid, void**ppv)
{
    if (iid == IID_IUnknown)
    {
        *ppv = (IUnkInner*) this;
    }
    else if (m_pHeader && iid == *m_pHeader->piid) // REVIEW: Need to handle QI's for base interfaces correctly too
    {
        // Unfortunately, this violates the letter of the QI stability rules, in that
        // the interface set we service will change after we have been fully initialized.
        // But, then, we've always hedged on the law in that case.
        //
        *ppv = &m_pvtbl;
    }
    else if (iid == __uuidof(ICallIndirect) || iid == __uuidof(ICallInterceptor))
    {
        *ppv = (ICallInterceptor*) this;
    }
    else if (iid == __uuidof(IInterfaceRelated))
    {
        *ppv = (IInterfaceRelated*) this;
    }
    else if (iid == __uuidof(ICallUnmarshal))
    {
        *ppv = (ICallUnmarshal*) this;
    }
    else if (iid == __uuidof(IInterceptorBase))
    {
        *ppv = (IInterceptorBase*) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}




HRESULT STDCALL Interceptor::CallIndirect(HRESULT* phReturnValue, ULONG iMethod, void* pvArgs, ULONG* pcbArgs)
// Indirectly invoke the indicated method on the object to which we are connected
{
    // AddRef(); // stablize to guard against buggy callers. REVIEW: TEMPORARY HACK ONLY; PERF IMPLICATIONS!
        
    HRESULT hr = S_OK;
        
    if (phReturnValue)
        *phReturnValue = CALLFRAME_E_COULDNTMAKECALL;
        
    if (iMethod < m_cMethodsBase)
        {
        if (m_pBaseInterceptor)
                {
            // This method is one that our base interface will handle. Tell him to do so
            //
            hr = m_pBaseInterceptor->CallIndirect(phReturnValue, iMethod, pvArgs, pcbArgs);
                }
        else
            hr = E_UNEXPECTED;
        }
    else
        {
        hr = SanityCheck(m_pHeader, iMethod);
                
        if (!hr)
                {
            MD_METHOD* pmd = &m_pmdInterface->m_rgMethods[iMethod];
            //
            // OK! Do the work. Do we have a sink? If not, then it isn't worth doing much...
            //
            if (m_pCallSink)
                        {
                // Create a call frame and ping our sink.
                //
                CallFrame* pNewFrame = new CallFrame;   // reference count starts as one
                if (pNewFrame)
                                {
                                        // IMPORTANT:  YOU MUST NOT USE THE FLOATING POINT ARGUMENT 
                                        //             REGISTERS IN BETWEEN THE FIRST INTERCEPTION 
                                        //             AND THIS FUNCTION CALL (ON IA64).
                    pNewFrame->Init(pvArgs, pmd, this);
                    //
                    // Let our sink know that the call actually happened
                    //
                    hr = m_pCallSink->OnCall( static_cast<ICallFrame*>(pNewFrame) );
                    if (!hr && phReturnValue)
                                        {
                        *phReturnValue = pNewFrame->GetReturnValueFast();
                                        }
                                        
                    pNewFrame->Release();
                                }
                else
                    hr = E_OUTOFMEMORY;
                        }
            //
            // Figure out the size of the arguments that need popping
            //
            *pcbArgs = pmd->m_cbPushedByCaller;
                }
        }

    // Release(); // counter above stabilization

    return hr;
}

HRESULT STDCALL Interceptor::GetStackSize(ULONG iMethod, ULONG* pcbArgs)
// Answer the size of a stack frame of the indicated method in this interface
{
    HRESULT hr = S_OK;

    if (iMethod < m_cMethodsBase)
    {
        if (m_pBaseInterceptor)
        {
            // This method is one that our base interface will handle. Tell him to do so
            //
            hr = m_pBaseInterceptor->GetStackSize(iMethod, pcbArgs);
        }
        else
            hr = E_UNEXPECTED;
    }
    else
    {
        hr = SanityCheck(m_pHeader, iMethod);

        if (!hr)
        {
            MD_METHOD* pmd = &m_pmdInterface->m_rgMethods[iMethod];
            *pcbArgs = pmd->m_cbPushedByCaller;
        }
    }

    return hr;
}



////////////////////////////////////////////////////////////////////////////////////////////
//
// ICallUnmarshal implementation
//
////////////////////////////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif

HRESULT Interceptor::Unmarshal(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, BOOL fForceBufferCopy, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarshalled, ICallFrame** ppFrame)
// Unmarshal the in-values of a call and return the reconstructed ICallFrame*. This is modeled very much
// on the server side unmarshalling routines NdrStubCall2 / __ComPs_NdrStubCall2.
{
    HRESULT hr = S_OK;

    if (iMethod < m_cMethodsBase)
    {
        if (m_punkBaseInterceptor)
        {
            ICallUnmarshal* pUnmarshal;
            hr = QI(m_punkBaseInterceptor, pUnmarshal);
            if (!hr)
            {
                hr = pUnmarshal->Unmarshal(iMethod, pBuffer, cbBuffer, fForceBufferCopy, dataRep, pctx, pcbUnmarshalled, ppFrame);
                pUnmarshal->Release();
            }
        }
        else
            hr = E_UNEXPECTED;
        return hr;
    }
    
    *ppFrame = NULL;
    
    ASSERT(pctx && pctx->fIn); if (!(pctx && pctx->fIn)) return E_INVALIDARG;
    //
    // Initialize out parameters
    //
    if (pcbUnmarshalled) 
    {
        *pcbUnmarshalled = 0;
    }
    *ppFrame = NULL;
    //
    // Get some of the memory we need
    //
    CallFrame* pFrame = new CallFrame;
    if (pFrame)
    {
        pFrame->m_fIsUnmarshal = TRUE;

        if (fForceBufferCopy)
        {
            PVOID pv = AllocateMemory(cbBuffer);
            if (pv)
            {
                memcpy(pv, pBuffer, cbBuffer);
                pBuffer = pv;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        if (!hr)
        {
            pFrame->m_blobBuffer.pBlobData = (PBYTE)pBuffer;
            pFrame->m_blobBuffer.cbSize    = cbBuffer;
            pFrame->m_fWeOwnBlobBuffer     = fForceBufferCopy;
        }
    }
    else
        hr = E_OUTOFMEMORY;
    //
    if (!hr)
    {
        // Initialize the new frame on the indicated method and ask it to internally allocate and zero a new stack
        //
        pFrame->Init(NULL, &m_pmdInterface->m_rgMethods[iMethod], this);
        hr = pFrame->AllocStack(0, FALSE);
    }
    
    if (!hr)
    {
        //
        // Find out and remember the stack address
        //
        BYTE* pArgBuffer = (BYTE*)pFrame->m_pvArgs;
        //
        // Cons up an RPC_MESSAGE to look like an incoming call
        //
        RPC_MESSAGE rpcMsg; Zero(&rpcMsg);
        rpcMsg.Buffer               = pBuffer;
        rpcMsg.BufferLength         = cbBuffer;
        rpcMsg.ProcNum              = iMethod;      // REVIEW: Must we 'or'-in the funky bit?
        rpcMsg.DataRepresentation   = dataRep;
        //
        // Cons up a pseudo channel kinda object in order to have the act of unmarshalling interfaces
        // come on back to the passed-in-here IMarshallingManager.
        //
        MarshallingChannel channel;
        
        if (pctx->punkReserved)
        {
            IMarshallingManager *pMgr;
            hr = pctx->punkReserved->QueryInterface(IID_IMarshallingManager, (void **)&pMgr);
            if (SUCCEEDED(hr))
            {
                ::Set(channel.m_pMarshaller, pMgr);
                pMgr->Release();
            }
            hr = S_OK;
        }
        
        channel.m_dwDestContext = pctx->dwDestContext;
        channel.m_pvDestContext = pctx->pvDestContext;
        //
        // Initialize a stub message from that stuff
        //
        MIDL_STUB_MESSAGE stubMsg;
        NdrStubInitialize(&rpcMsg, &stubMsg, pFrame->GetStubDesc(), (IRpcChannelBuffer*)&channel);
        stubMsg.StackTop = pArgBuffer;
                
        //
        // Need to deal with things the extensions, if they exist.
        // Stolen from RPC.
        //
        if (pFrame->m_pmd->m_pHeaderExts)
        {
            stubMsg.fHasExtensions = 1;
            stubMsg.fHasNewCorrDesc = pFrame->m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;
            
            if (pFrame->m_pmd->m_pHeaderExts->Flags2.ServerCorrCheck)
            {
                void *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);
                
                if (!pCorrInfo)
                    RpcRaiseException (RPC_S_OUT_OF_MEMORY);
                
                NdrCorrelationInitialize( &stubMsg,
                                          (unsigned long *)pCorrInfo,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0 /* flags */ );
            }
        }
        else
        {
            stubMsg.fHasExtensions = 0;
            stubMsg.fHasNewCorrDesc = 0;
        }
        
        __try
        {
            // Unmarshal in [in] parameters
            //
            const MD_METHOD* pmd = pFrame->m_pmd;
            for (ULONG iparam = 0; iparam < pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                
                BYTE* pArg = pArgBuffer + param.StackOffset;
                
                if (paramAttr.IsIn)
                {
                    ASSERT(!paramAttr.IsPipe);
                    //
                    // Quick check for the common case
                    //
                    if (paramAttr.IsBasetype)
                    {
                        if (paramAttr.IsSimpleRef)
                        {
                            ALIGN(stubMsg.Buffer, SIMPLE_TYPE_ALIGNMENT(param.SimpleType.Type));
                            *(PBYTE*)pArg = stubMsg.Buffer;
                            stubMsg.Buffer += SIMPLE_TYPE_BUFSIZE(param.SimpleType.Type);
                        }
                        else
                        {
                            NdrUnmarshallBasetypeInline(&stubMsg, pArg, param.SimpleType.Type);
#ifdef _ALPHA_
                            if (FC_FLOAT == param.SimpleType.Type && (iparam < 5))
                            {
                                *(double*) pArg = *(float*)(pArg);    // manually promote to double 
                            }
#endif
                        }
                        continue;
                    }
                    //
                    // Initialize [in] and [in,out] ref pointers to pointers
                    //
                    if (paramAttr.ServerAllocSize != 0)
                    {
                        *(PVOID*)pArg = pFrame->AllocBuffer(paramAttr.ServerAllocSize * 8);
                        Zero( *(PVOID*)pArg, paramAttr.ServerAllocSize * 8);
                    }
                    //
                    // Actually carry out the unmarshal the long way
                    //
                    BYTE** ppArg = paramAttr.IsByValue ? &pArg : (BYTE**)pArg;
                    PFORMAT_STRING pFormatParam = pFrame->GetStubDesc()->pFormatTypes + param.TypeOffset;
                    NdrTypeUnmarshall(&stubMsg, ppArg, pFormatParam, FALSE);
                }
            }
            //
            // Initialize the out-parameters. Must be done AFTER unmarshalling the in parameters because
            // some of the conformance routines we encounter might need to refer in-parameter data.
            //
            for (iparam = 0; iparam < pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                
                BYTE* pArg = pArgBuffer + param.StackOffset;
                
                if (!paramAttr.IsIn)
                {
                    ASSERT(paramAttr.IsOut); ASSERT(!paramAttr.IsReturn && !paramAttr.IsPipe);
                    
                    if (paramAttr.ServerAllocSize != 0)
                    {
                        *(PVOID*)pArg = pFrame->AllocBuffer(paramAttr.ServerAllocSize * 8);
                        if (*(PVOID*)pArg == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        Zero( *(PVOID*)pArg, paramAttr.ServerAllocSize * 8);
                    }
                    else if (paramAttr.IsBasetype)
                    {
                        *(PVOID*)pArg = pFrame->AllocBuffer(8);
                        if (*(PVOID*)pArg == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        Zero( *(PVOID*)pArg, 8);
                    }
                    else
                    {
                        PFORMAT_STRING pFormatParam = pFrame->GetStubDesc()->pFormatTypes + param.TypeOffset;
                        NdrOutInit(&stubMsg, pFormatParam, (BYTE**)pArg);
                    }
                }
            }
            //
            // Return the newly unmarshalled frame to our caller
            //
            ASSERT(pFrame->m_refs == 1);
            *ppFrame = pFrame;  // Transfer ownership of the reference
        }
        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
        {
            // Unlike NDR, we choose to clean up if we happen to fail because of unmarshalling bad stub
            // data. In kernel mode, this is important in order that a malicious user mode guy who returns
            // bad data as out parameters to an up-call doesn't cause the kernel to fill up with wasted memory.
            //
            hr = HrNt(GetExceptionCode());
            //
            // REVIEW: But until we can figureout whether in all states we can in fact call this, we
            //         had better not actually do it
            // pFrame->Free(NULL, NULL, CALLFRAME_FREE_ALL, NULL, CALLFRAME_NULL_NONE);
            //
            delete pFrame;
            pFrame = NULL;
            *ppFrame = NULL;
        }
        //
        // Record how many bytes we unmarshalled. Do this even in error return cases.
        // Knowing this is important in order to be able to clean things up with ReleaseMarshalData
        //
        if (pcbUnmarshalled) *pcbUnmarshalled = PtrToUlong(stubMsg.Buffer) - PtrToUlong(pBuffer);
    }
    
    if (FAILED(hr))
    {
        delete pFrame;
        pFrame = NULL;
        *ppFrame = NULL;
    }
    
    return hr;
}

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

HRESULT Interceptor::ReleaseMarshalData(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx)
// Call release marshal data on all of the marshalled interface pointers contained herein
{ 
    HRESULT hr = S_OK;

    if (iMethod < m_cMethodsBase)
    {
        if (m_punkBaseInterceptor)
        {
            ICallUnmarshal* pUnmarshal;
            hr = QI(m_punkBaseInterceptor, pUnmarshal);
            if (!hr)
            {
                hr = pUnmarshal->ReleaseMarshalData(iMethod, pBuffer, cbBuffer, ibFirstRelease, dataRep, pctx);
                pUnmarshal->Release();
            }
        }
        else
            hr = E_UNEXPECTED;
        return hr;
    }

    CallFrame* pNewFrame = new CallFrame;
    if (pNewFrame)
    {
        pNewFrame->Init(NULL, &m_pmdInterface->m_rgMethods[iMethod], this);
        hr = pNewFrame->ReleaseMarshalData(pBuffer, cbBuffer, ibFirstRelease, dataRep, pctx);
        delete pNewFrame;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT Interceptor::GetMethodInfo(ULONG iMethod, CALLFRAMEINFO* pInfo, LPWSTR* pwszMethodName)
// Provide interesting per-method information
//
{
    if (iMethod < m_cMethodsBase)
    {
        if (m_pBaseInterceptor)
        {
            return m_pBaseInterceptor->GetMethodInfo(iMethod, pInfo, pwszMethodName);
        }
        else
            return E_UNEXPECTED;
    }
    else if ((iMethod < 3) || (iMethod >= m_pmdInterface->m_cMethods))
    {
        // These are either IUnknown methods, or invalid methods.
        return E_INVALIDARG;
    }
    else
    {
        *pInfo = m_pmdInterface->m_rgMethods[iMethod].m_info;
        if (pwszMethodName)
        {
            if (m_pmdInterface->m_rgMethods[iMethod].m_wszMethodName)
            {
                *pwszMethodName = CopyString(m_pmdInterface->m_rgMethods[iMethod].m_wszMethodName);
                if (NULL == *pwszMethodName)
                {
                    return E_OUTOFMEMORY;
                }
            }
            else
                *pwszMethodName = NULL;
        }
        return S_OK;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////
//
// Definition of the method thunks for the Interceptor. 
//
////////////////////////////////////////////////////////////////////////////////////////////

#define GetInterceptor(This) CONTAINING_RECORD(This, Interceptor, m_pvtbl)

HRESULT STDMETHODCALLTYPE Interceptor_QueryInterface(IUnknown* This, REFIID riid, void** ppv)
{
    return GetInterceptor(This)->QueryInterface(riid, ppv);
};
ULONG STDMETHODCALLTYPE Interceptor_AddRef(IUnknown* This)
{
    return GetInterceptor(This)->AddRef();
};
ULONG STDMETHODCALLTYPE Interceptor_Release(IUnknown* This)
{
    return GetInterceptor(This)->Release();
};

#define methname(i) __Interceptor_meth##i

//
/////////////////////////////////////////////////////////////////////////
//
#if defined(_X86_)

#define meth(i)                                                         \
HRESULT __declspec(naked) methname(i)(void* const this_, ...)           \
    {                                                                   \
    __asm mov eax, i                                                    \
    __asm jmp InterceptorThunk                                          \
    }

void __declspec(naked) InterceptorThunk(ULONG iMethod, IUnknown* This, ...)
    {
    // Manually establish a stack frame so that references to locals herein will work
    // 
    __asm {
        pop      ecx            // pop return address
        push     eax            // push iMethod
        push     ecx            // push return address
        push     ebp            // link the stack frame
        mov      ebp, esp       //      ...
        sub      esp, 8         // reserve space for cbArgs and hr
        }
    // 
    // Stack is now (numbers are offsets from ebp)
    //
    //      12  This
    //      8   iMethod         
    //      4   return address  
    //      0   saved ebp
    //
    // Do the actual interception
    //
        DWORD   cbArgs;
    HRESULT hr;
    GetInterceptor(This)->CallIndirect(&hr, iMethod, /*pvArgs*/&This, &cbArgs);
        //
        // Now deal with the return values, and return to the caller....
    _asm {
                mov     eax, hr         // get hr ready to return to our caller
                mov     ecx, cbArgs     // get cbArgs into ecx
                add     esp, 8          // de-alloc our stack variables
        pop     ebp             // unlink stack frame
        pop     edx             // get return address to edx
        add     ecx, 4          // account for our extra push of iMethod
        add     esp, ecx        // remove stack frame pushed by caller
        jmp     edx             // return to caller
        }
    }

#endif // _X86_

//
/////////////////////////////////////////////////////////////////////////
//
#if defined(_AMD64_)

#define meth(i)                                                                 \
HRESULT methname(i)(void* const This, ...)                                      \
    {                                                                           \
    DWORD cbArgs;                                                               \
    HRESULT hr;                                                                 \
    GetInterceptor((IUnknown*)This)->CallIndirect(&hr, i, (void *)&This, &cbArgs); \
    return hr;                                                                  \
    }

#endif // _AMD64_

//
/////////////////////////////////////////////////////////////////////////
#if defined(_IA64_)
#define meth(i)                                                         \
extern "C" HRESULT methname(i)(void* const this_, ...);
#endif
//
/////////////////////////////////////////////////////////////////////////

#include "vtableimpl.h"

defineVtableMethods()

defineVtable(g_InterceptorVtable, Interceptor_QueryInterface, Interceptor_AddRef, Interceptor_Release)

////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\interfaceproxy.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// interfaceproxy.cpp
//
#include "stdpch.h"
#include "common.h"

HRESULT InterfaceProxy::InnerQueryInterface(REFIID iid, void**ppv)
    {
    if (iid == IID_IUnknown || iid == IID_IRpcProxyBuffer)
        {
        *ppv = (IRpcProxyBufferInner*) this;
        }
    else if (iid == __uuidof(IInterfaceProxyInit))
        {
        *ppv = (IInterfaceProxyInit*) this;
        }
    else if (iid == *TxfNdrGetProxyIID(&m_pProxyVtbl) || iid == m_iidBase)
        {
        *ppv = &m_pProxyVtbl;
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }

    ASSERT(FIELD_OFFSET(ForwardingInterfaceProxy, m_pProxyVtbl) == ForwardingInterfaceProxy_m_pProxyVtbl);
    ASSERT(FIELD_OFFSET(ForwardingInterfaceProxy, m_pBaseProxy) == ForwardingInterfaceProxy_m_pBaseProxy);

    ASSERT(FIELD_OFFSET(ForwardingInterfaceStub, m_pStubVtbl)        == ForwardingInterfaceStub_m_pStubVtbl);
    ASSERT(FIELD_OFFSET(ForwardingInterfaceStub, m_punkServerObject) == ForwardingInterfaceStub_m_punkServerObject);
    ASSERT(FIELD_OFFSET(ForwardingInterfaceStub, m_lpForwardingVtbl) == ForwardingInterfaceStub_m_lpForwardingVtbl);

// an easy thing to do to get these constants in a listing file for examination
/*
    Print("%d %d", InterfaceProxy_m_pProxyVtbl_offset, FIELD_OFFSET(ForwardingInterfaceProxy, m_pProxyVtbl));
    Print("%d %d", InterfaceStub_m_pStubVtbl_offset,   FIELD_OFFSET(ForwardingInterfaceStub,  m_pStubVtbl));


    Print("0x%08x", ForwardingInterfaceProxy::From((void*)this)->m_pBaseProxy);
    Print("0x%08x", ForwardingInterfaceStub::From((const void*)this)->m_pStubVtbl);
*/
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
    }


HRESULT ForwardingInterfaceProxy::InnerQueryInterface(REFIID iid, void**ppv)
    {
    HRESULT hr = InterfaceProxy::InnerQueryInterface(iid, ppv);
    if (E_NOINTERFACE == hr)
        {
        if (m_pBaseProxyBuffer)
            {
            hr = m_pBaseProxyBuffer->QueryInterface(iid, ppv);
            }
        }
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\interfaceproxy.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// interfaceproxy.h
//

//////////////////////////////////////////////////////////////////////////////////
//
// We need an IUnkInner variation of this interface to get the overloading to work right
//
interface IRpcProxyBufferInner : public IUnkInner
    {
    virtual HRESULT STDMETHODCALLTYPE Connect(IRpcChannelBuffer *pRpcChannelBuffer) = 0;
    virtual void    STDMETHODCALLTYPE Disconnect(void) = 0;   
    };


//////////////////////////////////////////////////////////////////////////////////
//
// Non-forwarding interface proxy
//
// WARNING: If you add any more vtables (inherited interfaces) to this class, that
//          will probably shift the offset of m_pProxyVtbl, in which case you MUST
//          update InterfaceProxy_m_pProxyVtbl_offset found in forwarder.h.
//
//////////////////////////////////////////////////////////////////////////////////

class ForwardingInterfaceProxy;

class InterfaceProxy : 
    public IRpcProxyBufferInner,       
    public IInterfaceProxyInit
    {
public:
    inline static InterfaceProxy* From(void* This)
    // Given the 'this' pointer of our hooked interface, recover the InterfaceProxy
        {
        return CONTAINING_RECORD(This, InterfaceProxy, m_pProxyVtbl);
        }

    ///////////////////////////////////////////////////////////////////
    //
    // State
    // 
    // NOTE: See warning above regarding location of m_pProxyVtbl
    //
    ///////////////////////////////////////////////////////////////////
protected:
    const void *             m_pProxyVtbl;          // ptr to vtbl, not ptr to ptr to vtbl
    IID                      m_iidBase;             // immediate base IID, if we know it

public:
    IRpcChannelBuffer*       m_pChannel;            // needed by NdrProxyInitialize
    
protected:
    friend InterfaceProxy* NdrGetProxyBuffer(void *This);

    ///////////////////////////////////////////////////////////////////
    //
    // Construction / initialization
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<InterfaceProxy>;
    friend GenericInstantiator<ForwardingInterfaceProxy>;

    InterfaceProxy(IUnknown* punkOuter = NULL)
        {
        m_refs               = 1;    // nb starts at one
        m_punkOuter          = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pChannel           = 0;
        m_fShuttingDown      = FALSE;
        m_pProxyVtbl         = NULL;
        m_iidBase            = IID_NULL;
        m_guidTransferSyntax = GUID_NULL;
        }

    virtual ~InterfaceProxy()
        {
        ::Release(m_pChannel);
        }

    HRESULT Init()
        {
        return S_OK;
        }

    HRESULT STDCALL Initialize1(const void* pProxyVtbl)
        {
        m_pProxyVtbl = pProxyVtbl;
        return S_OK;
        }

    HRESULT STDCALL Initialize2(REFIID iidBase, IRpcProxyBuffer* pBaseProxyBuffer, void* pBaseProxy)
        {
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // IRpcProxyBufferInner
    //
    ///////////////////////////////////////////////////////////////////
protected:
    GUID    m_guidTransferSyntax; // REVIEW?: Make this a GUID* for space reasons since it's rarely used?

public:
    void STDCALL GetTransferSyntax(GUID *guidSyntax) 
        { 
        *guidSyntax = m_guidTransferSyntax; 
        }

    HRESULT STDCALL Connect(IRpcChannelBuffer * pChannel)
        {
        HRESULT hr = S_OK;
        //
        ::Set(m_pChannel, pChannel);

        return hr;
        }

    void STDCALL Disconnect()
        {
        ::Release(m_pChannel);
        }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;
    ULONG       m_fShuttingDown;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  
        { 
        long crefs = InterlockedDecrement(&m_refs); 
        if (crefs == 0 && !m_fShuttingDown) 
            {
            m_fShuttingDown = TRUE;     // protect ourselves from bouncing ref counts during destruction
            delete this; 
            }
        return crefs;
        }

public:
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }
    };


//////////////////////////////////////////////////////////////////////////////////
//
// Forwarding interface proxy
//
//////////////////////////////////////////////////////////////////////////////////

class ForwardingInterfaceProxy : public InterfaceProxy
    {
public:
    inline static ForwardingInterfaceProxy* From(void* This)
    // Given the 'this' pointer of our hooked interface, recover the ForwardingInterfaceProxy
        {
        return CONTAINING_RECORD(This, ForwardingInterfaceProxy, m_pProxyVtbl);
        }

    ///////////////////////////////////////////////////////////////////
    //
    // Additional State
    //
    ///////////////////////////////////////////////////////////////////
public:
    IUnknown *               m_pBaseProxy;
protected:
    IRpcProxyBuffer *        m_pBaseProxyBuffer;

    friend void ForwarderProxyThunk(ULONG iMethod, void* this_, ...);

    ///////////////////////////////////////////////////////////////////
    //
    // Construction / initialization
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<ForwardingInterfaceProxy>;

    ForwardingInterfaceProxy(IUnknown* punkOuter = NULL) : InterfaceProxy(punkOuter)
        {
        m_pBaseProxy        = NULL;
        m_pBaseProxyBuffer  = NULL;
        }

    virtual ~ForwardingInterfaceProxy()
        {
        ReleaseBaseProxy();
        ::Release(m_pBaseProxyBuffer);
        }

    HRESULT Init()
        {
        return S_OK;
        }

    HRESULT STDCALL Initialize2(REFIID iidBase, IRpcProxyBuffer* pBaseProxyBuffer, void* pBaseProxy)
        {
        m_iidBase = iidBase;

        ::Set(m_pBaseProxyBuffer, pBaseProxyBuffer);

        return S_OK;
        }

public:
    static IUnknown* PunkOuterForDelegatee(IUnknown* punkProxyLocalIdentity, IUnknown* punkOuterForProxy)
    // Return the controlling unknown that we should give to the base proxy that we delegate to.
    //
    // If you change this method, then you have to update the receiver of the AddRef() and Release()
    // calls marked with /* ### */ below.
    //
        {
        return punkProxyLocalIdentity;
        }

protected:
    void ReleaseBaseProxy()
    // Releases the base proxy, being sure to use the right reference counting rules for 
    // dealing with cached pointers from aggregatees
        {
        if (m_pBaseProxy)
            {
            InnerAddRef();                   /* ### */
            m_pBaseProxy->Release();
            m_pBaseProxy = NULL;
            }
        }

    HRESULT STDCALL Connect(IRpcChannelBuffer * pChannel)
    // Connect ourselves to the indicated channel
        {
        HRESULT     hr;
        IUnknown*   punkBaseInterface;
        //
        // Remember the channel
        //
        ::Set(m_pChannel, pChannel);
        //
        // Ask our base guy to remember it too
        //
        hr = m_pBaseProxyBuffer->Connect(pChannel);

        if (!hr)
            {
            // Now that the channel is connected, we can finally ask our base interface
            // for the interface to which we should delegate. That we have to delay asking
            // it for so long is a quirk (some would say bug) of the OLE-automation marshalling
            // engine, which might be what we're using here for a base.
            //
            hr = m_pBaseProxyBuffer->QueryInterface(m_iidBase, (void**)&punkBaseInterface);
            if (!hr)
                {
                // Remember that interface pointer in our state. 
                //
                ReleaseBaseProxy(); ASSERT(m_pBaseProxy == NULL);
                m_pBaseProxy = punkBaseInterface;   // transfer ownerwhip of the refcnt
                //
                // Note that m_pBaseProxy holds a public interface on an aggregatee of ours, 
                // so we have to adhere to the special reference counting rules for that situation.
                //
                InnerRelease();              /* ### */
                }
            }

        return hr;
        }

    void STDCALL Disconnect()
        {
        ReleaseBaseProxy();
        
        if (m_pBaseProxyBuffer)
            {
            m_pBaseProxyBuffer->Disconnect();
            }

        ::Release(m_pChannel);
        }



    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);

    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\midlver.h ===
#ifndef __MIDLVER_H__
#define __MIDLVER_H__

//
// The MIDL version is contained in the stub descriptor starting with
// MIDL version 2.00.96 (pre NT 3.51 Beta 2, 2/95) and can be used for a finer
// granularity of compatability checking.  The MIDL version was zero before
// MIDL version 2.00.96.  The MIDL version number is converted into
// an integer long using the following expression :
//     ((Major << 24) | (Minor << 16) | Revision)
//
#ifndef MIDL_NT_3_51
#define MIDL_NT_3_51           ((2UL << 24) | (0UL << 16) | 102UL)
#endif

#ifndef MIDL_VERSION_3_0_39
#define MIDL_VERSION_3_0_39    ((3UL << 24) | (0UL << 16) |  39UL)
#endif

#ifndef MIDL_VERSION_3_2_88
#define MIDL_VERSION_3_2_88    ((3UL << 24) | (2UL << 16) |  88UL)
#endif

#ifndef MIDL_VERSION_5_0_136
#define MIDL_VERSION_5_0_136   ((5UL << 24) | (0UL << 16) | 136UL)
#endif

#ifndef MIDL_VERSION_5_2_202
#define MIDL_VERSION_5_2_202   ((5UL << 24) | (2UL << 16) | 202UL)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\misc.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// misc.h
//
// REVIEW: Many of these are probably obsolete now that KOM is implemented elsewhere.
// 
#ifndef __MISC__H__
#define __MISC__H__
#pragma message("including misc.h")




////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous supporting definitions for this module
//

#ifdef KERNELMODE

HRESULT KoiShortServiceNameFromCLSID(REFCLSID clsid, UNICODE_STRING* pu);
HRESULT KoiLoadClassLibrary(UNICODE_STRING& u, COM_MODULE_INFO** ppInfo);

#endif


inline void Free(UNICODE_STRING& u) { if (u.Buffer)     ExFreePool(u.Buffer);    u.Buffer = NULL;    }
inline void Free(BLOB& b)           { if (b.pBlobData)  ExFreePool(b.pBlobData); b.pBlobData = NULL; }


#ifndef KERNELMODE

HRESULT HError();
HRESULT HError(DWORD);

#endif



////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// User mode callback routines. These are implemented by user mode COM
//

typedef void* PWND;

typedef void (__stdcall *PFN_USERMODECALLBACK)   (DWORD cbInputBuffer, void* pvInputBuffer, DWORD cbOutputBuffer, void* pvOutputBuffer, ULONG* pcbReturned);
typedef void (__stdcall *PFN_USERMODEENTRYPOINT) (PWND, UINT, DWORD, LONG, DWORD);

void UserModeEntryPoint(PWND pwnd, UINT msg, DWORD wParam, LONG lParam, DWORD xParam);




////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Definition of the DeviceIoControl codes used to communicate between user mode and kernel mode COM
//

#define FILE_DEVICE_KOM	29453


///////////////////////////////////////////////////////////////
//
// Generic DeviceIoCaller
//
#ifndef KERNELMODE

template <class IN_T, class OUT_T>
BOOL CallDevice(DWORD code, IN_T* pin, OUT_T* pout)
// Call the kernel mode side of KOM
    {
    HRESULT hr = S_OK;
    if (globals.hKom == NULL)
        {
        hr = globals.ConnectToKernelMode();
        }
    if (globals.hKom != NULL)
        {
        ULONG cbReturned;
        if (DeviceIoControl(globals.hKom, code, pin, sizeof(*pin), pout, sizeof(*pout), &cbReturned, NULL))
            {
            ASSERT(cbReturned == sizeof(*pout));
            return TRUE;
            }
        else
            return FALSE;
        }
    else
        {
        SetLastError(hr);
        return FALSE;
        }
    }

template <class IN_T, class OUT_T>
BOOL CallTxf(DWORD code, IN_T* pin, OUT_T* pout)
// Call the kernel mode TXF
    {
    HRESULT hr = S_OK;
    if (globals.hTxf == NULL)
        {
        hr = globals.ConnectToTxf();
        }
    if (globals.hKom != NULL)
        {
        ULONG cbReturned;
        if (DeviceIoControl(globals.hTxf, code, pin, sizeof(*pin), pout, sizeof(*pout), &cbReturned, NULL))
            {
            ASSERT(cbReturned == sizeof(*pout));
            return TRUE;
            }
        else
            return FALSE;
        }
    else
        {
        SetLastError(hr);
        return FALSE;
        }
    }
#endif


//////////////////////////////////////////////////////////////////
#endif // __MISC__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\interfacestub.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// InterfaceStub.h
//

//////////////////////////////////////////////////////////////////////////////////
//
// Workhorse vtables
//
//////////////////////////////////////////////////////////////////////////////////

extern const IRpcStubBufferVtbl CStdStubBufferVtbl;
extern const IRpcStubBufferVtbl CStdStubBuffer2Vtbl;




//////////////////////////////////////////////////////////////////////////////////
//
// Non-forwarding interface stub
//
// WARNING: If you add any more vtables (inherited interfaces) to this class, that
//          will probably shift the offset of m_pStubVtbl, in which case you MUST
//          update InterfaceStub_m_pStubVtbl_offset found in forwarder.h.
//
//////////////////////////////////////////////////////////////////////////////////

class InterfaceStub : 
        public IRpcStubBuffer,       
        public IInterfaceStubInit,
        public ITypeInfoStackHelper,
        public IUnkInner
    {
public:
    inline static InterfaceStub* From(IRpcStubBuffer* This)
    // Given the 'this' pointer of our IRpcStubBuffer interface, recover the InterfaceStub
        {
        return CONTAINING_RECORD(This, InterfaceStub, m_pStubVtbl);
        }

    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    // NOTE: See warning above regarding location of m_pStubVtbl
    //
    ///////////////////////////////////////////////////////////////////
public:

    const IRpcStubBufferVtbl* m_pStubVtbl;              // ptr to vtbl, not ptr to ptr to vtbl
    IUnknown*                 m_punkServerObject;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction / initialization
    //
    ///////////////////////////////////////////////////////////////////
protected:

    friend GenericInstantiator<InterfaceStub>;

    InterfaceStub(IUnknown* punkOuter = NULL)
        {
        m_refs              = 1;    // nb starts at one
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;

        m_punkServerObject  = NULL;
        m_pStubVtbl         = NULL;
        }

    virtual ~InterfaceStub()
        {
        ::Release(m_punkServerObject);
        }

    HRESULT Init()
        {
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // ITypeInfoStackHelper
    //
    ///////////////////////////////////////////////////////////////////

    ICallInterceptor* GetInterceptor();

    //////////////////////

    HRESULT STDCALL GetGuid(GUID* piid);

    HRESULT STDCALL GetMethodCount(ULONG* pcbMethod);

    HRESULT STDCALL GetStackSize(ULONG iMethod, BOOL fIncludeReturn, ULONG* pcbStack);

    HRESULT STDCALL WalkInterfacePointers(ULONG iMethod, LPVOID pvArgs, BOOL fIn, IStackFrameWalker* pWalker);

    HRESULT STDCALL NullOutParams(ULONG iMethod, LPVOID pvArgs, BOOL fIn);

    HRESULT STDCALL HasOutParams(ULONG iMethod, BOOL* pfHasOutParams);

    HRESULT STDCALL HasOutInterfaces(ULONG iMethod, BOOL* pfHasOutInterfaces);

    ///////////////////////////////////////////////////////////////////
    //
    // IInterfaceStubInit
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL Initialize1(const IRpcStubBufferVtbl* pStubVtbl)
        {
        m_pStubVtbl = pStubVtbl;
        return S_OK;
        }
    HRESULT STDCALL Initialize2(IRpcStubBuffer*, REFIID)
        {
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // IRpcStubBuffer
    //
    ///////////////////////////////////////////////////////////////////
public:
    HRESULT STDCALL Connect(IUnknown *punkServerAnyIid)
        {
        IUnknown* punkServer;
        HRESULT hr = punkServerAnyIid->QueryInterface(*NdrpGetStubIID(AsIRpcStubBuffer()), (void**)&punkServer);
        if (!hr)
            {
            ::SetConcurrent(m_punkServerObject, punkServer);
            punkServer->Release();
            }
        return hr;
        }

    void STDCALL Disconnect(void)
        {
        ::ReleaseConcurrent(m_punkServerObject);
        }
        
    HRESULT STDCALL Invoke(RPCOLEMESSAGE *_prpcmsg, IRpcChannelBuffer* _pRpcChannelBuffer);

    IRpcStubBuffer* STDCALL IsIIDSupported(REFIID riid)
        {
        if (riid == *NdrpGetStubIID(AsIRpcStubBuffer()))
            {
            IRpcStubBuffer* pStub = (IRpcStubBuffer*)(this);
            pStub->AddRef();
            return pStub;
            }
        else
            return NULL;
        }

    ULONG STDCALL CountRefs(void)
        {
        return m_punkServerObject ? 1 : 0;
        }

    HRESULT STDCALL DebugServerQueryInterface(void**ppv)
        {
        *ppv = m_punkServerObject;
        return *ppv ? S_OK : CO_E_OBJNOTCONNECTED;
        }

    void STDCALL DebugServerRelease(void *pv)
        {
        // Nothing to do
        }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

public:
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }


    ///////////////////////////////////////////////////////////////////
    //
    // Misc
    //
    ///////////////////////////////////////////////////////////////////

    IRpcStubBuffer* AsIRpcStubBuffer()              { return (IRpcStubBuffer*)&m_pStubVtbl; }
    const CInterfaceStubHeader* GetMetaData()       { return HeaderFromStub(AsIRpcStubBuffer()); }
    };




//////////////////////////////////////////////////////////////////////////////////
//
// Forwarding interface stub
//
//////////////////////////////////////////////////////////////////////////////////

class ForwardingInterfaceStub : public InterfaceStub
    {
public:
    inline static ForwardingInterfaceStub* From(IRpcStubBuffer* This)
    // For IRpcStubBuffer
        {
        return CONTAINING_RECORD(This, ForwardingInterfaceStub, m_pStubVtbl);
        }
    inline static ForwardingInterfaceStub* From(const void* This)
    // For the interface on the object
        {
        return CONTAINING_RECORD(This, ForwardingInterfaceStub, m_lpForwardingVtbl);
        }

    ///////////////////////////////////////////////////////////////////
    //
    // Additional State
    //
    ///////////////////////////////////////////////////////////////////
public:
    const void*         m_lpForwardingVtbl;

protected:
    IRpcStubBuffer*     m_pBaseStubBuffer;
    IID                 m_iidBase;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction / initialization
    //
    ///////////////////////////////////////////////////////////////////
protected:

    friend GenericInstantiator<ForwardingInterfaceStub>;

    ForwardingInterfaceStub(IUnknown* punkOuter = NULL) : InterfaceStub(punkOuter)
        {
        m_lpForwardingVtbl = g_StubForwarderVtable;
        m_pBaseStubBuffer  = NULL;
        }

    virtual ~ForwardingInterfaceStub()
        {
        ::Release(m_pBaseStubBuffer);
        }

    HRESULT Init()
        {
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // IInterfaceStubInit
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL Initialize2(IRpcStubBuffer* pBaseStubBuffer, REFIID iid)
        {
        ::Set(m_pBaseStubBuffer, pBaseStubBuffer);
        m_iidBase = iid;
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL CallIndirect    (ULONG iMethod, void* pvArgs, ULONG* pcbArgs); 

    ///////////////////////////////////////////////////////////////////
    //
    // IRpcStubBuffer
    //
    ///////////////////////////////////////////////////////////////////
public:

    HRESULT STDCALL Connect(IUnknown *punkServerAnyIid)
        {
        HRESULT hr = InterfaceStub::Connect(punkServerAnyIid);
        if (!hr)
            {
            if (m_pBaseStubBuffer)
                {
                // If we have a base guy, then we set him up to be connected to us
                // as his server object.
                //
                hr = m_pBaseStubBuffer->Connect( (IUnknown*) &m_lpForwardingVtbl );
                }
            }
        return hr;
        }

    void STDCALL Disconnect()
        {
        InterfaceStub::Disconnect();
        if (m_pBaseStubBuffer)
            {
            m_pBaseStubBuffer->Disconnect();
            }
        }

    ULONG STDCALL CountRefs()
        {
        ULONG count = InterfaceStub::CountRefs();
        if (m_pBaseStubBuffer)
            {
            count += m_pBaseStubBuffer->CountRefs();
            }
        return count;
        }

public:
    
    HRESULT ForwardingFunction(RPCOLEMESSAGE* pMsg, IRpcChannelBuffer* pChannel)
        {
        HRESULT hr = S_OK;
        if (m_pBaseStubBuffer)
            {
            hr = m_pBaseStubBuffer->Invoke(pMsg, pChannel);
            }
        else
            hr = CO_E_OBJNOTCONNECTED;

        return hr;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\interfacestub.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// interfacestub.cpp
//
#include "stdpch.h"
#include "common.h"

//
// OK to hard code this since it has already shipped in MTS2 and thus
// absolutely cannot change.
//
const IID IID_IStackFrameWalker     = {0xac2a6f41,0x7d06,0x11cf,{0xb1, 0xed, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6}};
const IID IID_ITypeInfoStackHelper  = {0x7ee46340,0x81ad,0x11cf,{0xb1, 0xf0, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6}};


HRESULT InterfaceStub::InnerQueryInterface(REFIID iid, void**ppv)
    {
    if (iid == IID_IUnknown)
        {
        *ppv = (IUnkInner*) this;
        }
    else if (iid == IID_IRpcStubBuffer && m_pStubVtbl) // see CStdPSFactoryBuffer_CreateStub, where we init this
        {
        *ppv = (void*) this->AsIRpcStubBuffer();
        }
    else if (iid == IID_ITypeInfoStackHelper)
        {
        *ppv = (ITypeInfoStackHelper*) this;
        }
    else if (iid == __uuidof(IInterfaceStubInit))
        {
        *ppv = (IInterfaceStubInit*) this;
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
    }

HRESULT ForwardingInterfaceStub::InnerQueryInterface(REFIID iid, void**ppv)
// The forwarder actually implements the interface that it invokes for. This is because
// we serve as the server object for the base interface.
    {
    HRESULT hr = InterfaceStub::InnerQueryInterface(iid, ppv);
    if (!!hr)
        {
        if (iid == m_iidBase)
            {
            *ppv = &m_lpForwardingVtbl;
            ((IUnknown*)*ppv)->AddRef();
            return S_OK;
            }
        }
    return hr;
    }

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// ITypeInfoStackHelper
//
// REVIEW: We certainly could make this stuff a bit more zippy to say the least. But as it's
// legacy code for MTS2 support, it's not clear that that matters enough to fix. I think they
// cache all the stuff they need to know anyway, so we only get each call once.

inline ICallInterceptor* InterfaceStub::GetInterceptor()
    {
    ICallInterceptor* pinterceptor = NULL;
    HRESULT hr = CoGetInterceptor(*NdrpGetStubIID(AsIRpcStubBuffer()), NULL, __uuidof(ICallInterceptor), (void**)&pinterceptor);
    return pinterceptor;
    }

HRESULT STDCALL InterfaceStub::GetGuid(GUID* piid)
    {
    *piid = *NdrpGetStubIID(AsIRpcStubBuffer());
    return S_OK;
    }

HRESULT STDCALL InterfaceStub::GetMethodCount(ULONG* pcbMethod)
    {
    *pcbMethod = HeaderFromStub(AsIRpcStubBuffer())->DispatchTableCount;
    return S_OK;
    }

HRESULT STDCALL InterfaceStub::GetStackSize(ULONG iMethod, BOOL fIncludeReturn, ULONG* pcbStack)
    {
    ICallInterceptor* pInterceptor = GetInterceptor();
    HRESULT hr = pInterceptor ? S_OK : E_OUTOFMEMORY;
    if (!hr)    
        {
        hr = pInterceptor->GetStackSize(iMethod, pcbStack);
        }
    ::Release(pInterceptor);
    return hr;
    }
        
HRESULT STDCALL InterfaceStub::WalkInterfacePointers(ULONG iMethod, LPVOID pvArgs, BOOL fIn, IStackFrameWalker* pWalker)
    {
    ICallInterceptor* pInterceptor = GetInterceptor();
    HRESULT hr = pInterceptor ? S_OK : E_OUTOFMEMORY;
    if (!hr)
        {
        // Define an object that can thunk the calls from new kind of interface
        // walker to the old kind of interface walker.
        //
        struct Helper : ICallFrameWalker, ICallFrameEvents
            {
            BOOL                fIn;
            IStackFrameWalker*  pWalker;
            HRESULT STDCALL QueryInterface(REFIID iid, void**ppv) 
                { 
                if (iid==IID_IUnknown || iid== __uuidof(ICallFrameWalker))  *ppv = (ICallFrameWalker*)this;
                else if (iid==__uuidof(ICallFrameEvents))                   *ppv = (ICallFrameEvents*)this;
                else { *ppv = NULL; return E_NOINTERFACE; }
                ((IUnknown*)*ppv)->AddRef(); return S_OK;
                }
            ULONG STDCALL AddRef()  { return 1; }
            ULONG STDCALL Release() { return 1; }

            HRESULT STDCALL OnCall(ICallFrame* pFrame)
            // Walk the newly created frame
                {
                return pFrame->WalkFrame(
                    fIn ? CALLFRAME_WALK_IN | CALLFRAME_WALK_INOUT : CALLFRAME_WALK_OUT | CALLFRAME_WALK_INOUT,
                    (ICallFrameWalker*)this);
                }

            HRESULT STDCALL OnWalkInterface(REFIID iid, void**ppv, BOOL fIn, BOOL fOut)
            // Thunk the walk call through the old style of walking callback
                {
                return pWalker->OnWalkInterface(iid, ppv);
                }

            };
        //
        // Instantiate the thunk
        //
        Helper helper;
        helper.fIn     = fIn;
        helper.pWalker = pWalker;
        //
        // Do the work in a callback created by our interceptor
        //
        hr = pInterceptor->RegisterSink(&helper);
        if (!hr) 
            {
            hr = pInterceptor->CallIndirect(NULL, iMethod, pvArgs, NULL);
            pInterceptor->RegisterSink(NULL);
            }
        }

    ::Release(pInterceptor);
    return hr;
    }

HRESULT STDCALL InterfaceStub::NullOutParams(ULONG iMethod, LPVOID pvArgs, BOOL fIn)
    {
    ICallInterceptor* pInterceptor = GetInterceptor();
    HRESULT hr = pInterceptor ? S_OK : E_OUTOFMEMORY;

    if (!hr)
        {
        struct Helper : ICallFrameEvents
            {
            BOOL fIn;
            HRESULT STDCALL QueryInterface(REFIID iid, void**ppv) 
                { 
                if (iid==IID_IUnknown || iid== __uuidof(ICallFrameEvents))  *ppv = (ICallFrameEvents*)this;
                else { *ppv = NULL; return E_NOINTERFACE; }
                ((IUnknown*)*ppv)->AddRef(); return S_OK;
                }
            ULONG STDCALL AddRef()  { return 1; }
            ULONG STDCALL Release() { return 1; }

            HRESULT STDCALL OnCall(ICallFrame* pFrame)
            // Null the out params
            //
            // REVIEW: Is it correct for us to be freeing here? What does MTS2 want?
            //
                {
                if (fIn)
                    {
                    return pFrame->Free(NULL, NULL, NULL, CALLFRAME_FREE_INOUT, NULL, CALLFRAME_NULL_ALL);
                    }
                else
                    return pFrame->Free(NULL, NULL, NULL, 0, NULL, CALLFRAME_NULL_ALL);
                }
            };

        Helper helper;
        helper.fIn = fIn;
        hr = pInterceptor->RegisterSink(&helper);
        if (!hr) 
            {
            hr = pInterceptor->CallIndirect(NULL, iMethod, pvArgs, NULL);
            pInterceptor->RegisterSink(NULL);
            }
        }
    
    ::Release(pInterceptor);
    return hr;
    }

HRESULT STDCALL InterfaceStub::HasOutParams(ULONG iMethod, BOOL* pfHasOutParams)
// Answer as to whether the indicated method would have any out parameters or not.
// REVIEW: 'nice to implement this more zippily, say with an interface on the 
// interceptor.
    {
    ICallInterceptor* pInterceptor = GetInterceptor();
    HRESULT hr = pInterceptor ? S_OK : E_OUTOFMEMORY;
    if (!hr)
        {
        CALLFRAMEINFO info;
        hr = pInterceptor->GetMethodInfo(iMethod, &info, NULL);
        if (!hr) 
            {
            *pfHasOutParams = (info.fHasInOutValues || info.fHasOutValues);
            }
        }

    ::Release(pInterceptor);
    return hr;
    }

HRESULT STDCALL InterfaceStub::HasOutInterfaces(ULONG iMethod, BOOL* pfHasOutInterfaces)
    {
    ICallInterceptor* pInterceptor = GetInterceptor();
    HRESULT hr = pInterceptor ? S_OK : E_OUTOFMEMORY;
    if (!hr)
        {
        CALLFRAMEINFO info;
        hr = pInterceptor->GetMethodInfo(iMethod, &info, NULL);
        if (!hr) 
            {
            *pfHasOutInterfaces = (info.cInOutInterfacesMax != 0 || info.cOutInterfacesMax != 0);
            }
        }
    ::Release(pInterceptor);
    return hr;
    }

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Invocation


int InterfaceStub_Invoke_ExceptionFilter(DWORD dwExceptionCode, DWORD dwServerPhase)
    {
    if (dwServerPhase == STUB_CALL_SERVER || dwExceptionCode == EXCEPTION_BREAKPOINT)
        return EXCEPTION_CONTINUE_SEARCH;
    return EXCEPTION_EXECUTE_HANDLER;
    }




HRESULT InterfaceStub::Invoke(RPCOLEMESSAGE *prpcmsg, IRpcChannelBuffer* pRpcChannelBuffer)
// Call the server object with the indicated method
//
    {
    HRESULT hr = S_OK;
    DWORD   dwServerPhase = STUB_UNMARSHAL;

    const CInterfaceStubHeader* pHeader = HeaderFromStub(AsIRpcStubBuffer());

    __try
        {
        if ((prpcmsg->iMethod >= pHeader->DispatchTableCount) || (prpcmsg->iMethod < 3))
            {
            Throw(RPC_E_INVALIDMETHOD);
            }
        //
        // Dispatch the call indirectly or do it right here
        //
        if (pHeader->pDispatchTable)
            {
            // Typically this pfn we call here will either be STUB_FORWARDING_FUNCTION or NdrStubCall2. 
            //
            // The former is actually NdrStubForwardingFunction, which calls ComPs_NdrStubForwardingFunction, 
            // which calls ForwardingInterfaceStub::ForwardingFunction. That, in turn simply calls Invoke on
            // the base stub. The base stub is plumbed up to our forwarding vtable as its server, and we trampoline 
            // on to the real object. Whew!
            //
            (pHeader->pDispatchTable[prpcmsg->iMethod])(AsIRpcStubBuffer(), pRpcChannelBuffer, (PRPC_MESSAGE)prpcmsg, &dwServerPhase);
            }
        else
            {
            PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) pHeader->pServerInfo;
            PMIDL_STUB_DESC   pStubDesc   = pServerInfo->pStubDesc;

            // Since MIDL 3.0.39 we have a proc flag that indicates
            // which interpeter to call. This is because the NDR version
            // may be bigger than 1.1 for other reasons.
            //
            ASSERT(MIDL_VERSION_3_0_39 <= pServerInfo->pStubDesc->MIDLVersion);

            unsigned short ProcOffset   = pServerInfo->FmtStringOffset[prpcmsg->iMethod];
            PFORMAT_STRING pProcFormat  = &pServerInfo->ProcString[ProcOffset];

            ASSERT(pProcFormat[1] & Oi_OBJ_USE_V2_INTERPRETER);
            NdrStubCall2(AsIRpcStubBuffer(), pRpcChannelBuffer, (PRPC_MESSAGE) prpcmsg, &dwServerPhase );
            }

        }

    __except(InterfaceStub_Invoke_ExceptionFilter(GetExceptionCode(), dwServerPhase))
        {
        hr = HrNt(GetExceptionCode());
        }

    return hr;
    }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Trampolining thunks that are exported from this DLL
//

HRESULT STDCALL N(ComPs_CStdStubBuffer_QueryInterface)(IRpcStubBuffer *This, REFIID iid, void** ppv)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->QueryInterface(iid, ppv);
    }
ULONG STDCALL N(ComPs_CStdStubBuffer_AddRef)(IRpcStubBuffer *This)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->AddRef();
    }
ULONG STDCALL N(ComPs_NdrCStdStubBuffer_Release)(IRpcStubBuffer *This, IPSFactoryBuffer* pPSF)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->Release();
    }
HRESULT STDCALL N(ComPs_CStdStubBuffer_Connect)(IRpcStubBuffer *This, IUnknown *punkServer)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->Connect(punkServer);
    }
void STDCALL N(ComPs_CStdStubBuffer_Disconnect)(IRpcStubBuffer *This)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    pStub->Disconnect();
    }
HRESULT STDCALL N(ComPs_CStdStubBuffer_Invoke)(IRpcStubBuffer *This, RPCOLEMESSAGE *pRpcMsg, IRpcChannelBuffer *pRpcChannelBuffer)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->Invoke(pRpcMsg, pRpcChannelBuffer);
    }
IRpcStubBuffer* STDCALL N(ComPs_CStdStubBuffer_IsIIDSupported)(IRpcStubBuffer *This, REFIID riid)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->IsIIDSupported(riid);
    }
ULONG   STDCALL N(ComPs_CStdStubBuffer_CountRefs)(IRpcStubBuffer *This)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->CountRefs();
    }
HRESULT STDCALL N(ComPs_CStdStubBuffer_DebugServerQueryInterface)(IRpcStubBuffer *This, void **ppv)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    return pStub->DebugServerQueryInterface(ppv);
    }
void    STDCALL N(ComPs_CStdStubBuffer_DebugServerRelease)(IRpcStubBuffer *This, void *pv)
    {
    InterfaceStub* pStub = InterfaceStub::From(This);
    pStub->DebugServerRelease(pv);
    }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// ForwardingInterfaceStub variations

ULONG STDCALL N(ComPs_NdrCStdStubBuffer2_Release)(IRpcStubBuffer *This, IPSFactoryBuffer* pPSF)
    {
    ForwardingInterfaceStub* pStub = ForwardingInterfaceStub::From(This);
    return pStub->Release();
    }

HRESULT STDCALL N(ComPs_CStdStubBuffer2_Connect)(IRpcStubBuffer *This, IUnknown* punkServer)
    {
    ForwardingInterfaceStub* pStub = ForwardingInterfaceStub::From(This);
    return pStub->Connect(punkServer);
    }
void STDCALL N(ComPs_CStdStubBuffer2_Disconnect)(IRpcStubBuffer *This)
    {
    ForwardingInterfaceStub* pStub = ForwardingInterfaceStub::From(This);
    pStub->Disconnect();
    }
ULONG STDCALL N(ComPs_CStdStubBuffer2_CountRefs)(IRpcStubBuffer *This)
    {
    ForwardingInterfaceStub* pStub = ForwardingInterfaceStub::From(This);
    return pStub->CountRefs();
    }

void __stdcall N(ComPs_NdrStubForwardingFunction)(
// Forwards a call to the stub for the base interface.
//
        IN  IRpcStubBuffer *    This,
        IN  IRpcChannelBuffer * pChannel,
        IN  PRPC_MESSAGE        pmsg,
        OUT DWORD __RPC_FAR *   pdwStubPhase
        )
    {
    ForwardingInterfaceStub* pStub = ForwardingInterfaceStub::From(This);
    HRESULT hr = pStub->ForwardingFunction((RPCOLEMESSAGE *) pmsg, pChannel);

    if (!!hr)
        {
        // We are guaranteed to have an exception handler above us, such as the one
        // in InterfaceStub::Invoke, that will catch this.
        //
        Throw(hr);
        }
    }


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IRpcStubBuffer vtables for InterfaceStub and ForwardingInterfaceStub
//

const IRpcStubBufferVtbl CStdStubBufferVtbl= 
    {
    N(ComPs_CStdStubBuffer_QueryInterface),
    N(ComPs_CStdStubBuffer_AddRef),
    0,
    N(ComPs_CStdStubBuffer_Connect),
    N(ComPs_CStdStubBuffer_Disconnect),
    N(ComPs_CStdStubBuffer_Invoke),
    N(ComPs_CStdStubBuffer_IsIIDSupported),
    N(ComPs_CStdStubBuffer_CountRefs),
    N(ComPs_CStdStubBuffer_DebugServerQueryInterface),
    N(ComPs_CStdStubBuffer_DebugServerRelease)
    };

const IRpcStubBufferVtbl CStdStubBuffer2Vtbl= 
    {
    N(ComPs_CStdStubBuffer_QueryInterface),
    N(ComPs_CStdStubBuffer_AddRef),
    0,
    N(ComPs_CStdStubBuffer2_Connect),
    N(ComPs_CStdStubBuffer2_Disconnect),
    N(ComPs_CStdStubBuffer_Invoke),
    N(ComPs_CStdStubBuffer_IsIIDSupported),
    N(ComPs_CStdStubBuffer2_CountRefs),
    N(ComPs_CStdStubBuffer_DebugServerQueryInterface),
    N(ComPs_CStdStubBuffer_DebugServerRelease)
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\oautil.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// oautil.cpp
//
#include "stdpch.h"
#include "common.h"

#include "ndrclassic.h"
#include "txfrpcproxy.h"
#include "typeinfo.h"
#include "tiutil.h"

#include <debnot.h>

OAUTIL g_oaUtil(FALSE, FALSE, NULL, NULL, NULL, FALSE, FALSE);

/////////////////////////////////////////////////////////////////////////////////////
//
// REVIEW:
//
// Probing support in the copy and free routines has yet to be implemented. In its
// absence, we have a security hole, but aside from that things should function
// correctly. This is a kernel-mode-only issue, of course.
//
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
//
// Stubs for the non-qualified APIs

BSTR SysAllocString(LPCWSTR psz)
{
    return g_oaUtil.SysAllocString(psz);
}

BSTR SysAllocStringLen(LPCWSTR wsz, UINT cch)
{
    return g_oaUtil.SysAllocStringLen(wsz, cch);
}

BSTR SysAllocStringByteLen(LPCSTR sz, UINT cb)
{
    return g_oaUtil.SysAllocStringByteLen(sz, cb);
}

void SysFreeString(BSTR bstr)
{
    g_oaUtil.SysFreeString(bstr);
}

UINT SysStringByteLen(BSTR bstr)
{
    return g_oaUtil.SysStringByteLen(bstr);
}

INT SysReAllocStringLen(BSTR* pbstr, LPCWSTR wsz, UINT ui)
{
    return g_oaUtil.SysReAllocStringLen(pbstr, wsz, ui);
}

HRESULT SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut)
{
    return g_oaUtil.SafeArrayCopy(psa, ppsaOut);
}

HRESULT VariantClear(VARIANTARG* pv)
{
    return g_oaUtil.VariantClear(pv);
}

HRESULT VariantCopy(VARIANTARG* pv1, VARIANTARG* pv2)
{
    return g_oaUtil.VariantCopy(pv1, pv2);
}

HRESULT LoadRegTypeLib(REFGUID libId, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib** pptlib)
{
    return (g_oa.get_pfnLoadRegTypeLib())(libId, wVerMajor, wVerMinor, lcid, pptlib);
}

HRESULT LoadTypeLibEx(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib)
{
    return (g_oa.get_pfnLoadTypeLibEx())(szFile, regkind, pptlib);
}


/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////


BSTR OAUTIL::SysAllocString(LPCWSTR psz)
{
    return (g_oa.get_SysAllocString())(psz);
}


BSTR OAUTIL::SysAllocStringLen(LPCWSTR psz, UINT cch)
{
    return (g_oa.get_SysAllocStringLen())(psz, cch);
}

BSTR OAUTIL::SysAllocStringByteLen(LPCSTR psz, UINT cb)
{
    return (g_oa.get_SysAllocStringByteLen())(psz, cb);
}

void OAUTIL::SysFreeString(BSTR bstr)
{
    (g_oa.get_SysFreeString())(bstr);
}


INT OAUTIL::SysReAllocString(BSTR* pbstr, LPCWSTR psz)
{
    return (g_oa.get_SysReAllocString())(pbstr, psz);
}

INT OAUTIL::SysReAllocStringLen(BSTR* pbstr, LPCWSTR psz, UINT cch)
{
    return (g_oa.get_SysReAllocStringLen())(pbstr, psz, cch);
}

UINT OAUTIL::SysStringLen(BSTR bstr)
{
    return bstr ? BSTR_INTERNAL::From(bstr)->Cch() : 0; // Works user or kernel mode
}

UINT OAUTIL::SysStringByteLen(BSTR bstr)
{
    return bstr ? BSTR_INTERNAL::From(bstr)->Cb()  : 0; // Works user or kernel mode
}

/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

#if _DEBUG
struct CFTaggedPunk
{
    PVOID pv;
    ULONG tag;
};

struct CFTaggedVariant
{
    VARIANT variant;
    ULONG tag;
};
#endif


//
// Walk a SAFEARRAY, calling our version of VariantClear on the contained
// variants, if necessary.  This makes sure we clean up any memory we might
// have allocated within.
//
HRESULT OAUTIL::SafeArrayClear(SAFEARRAY *psa, BOOL fWeOwnByRefs)
{
    if ((psa == NULL) || !(psa->fFeatures & FADF_VARIANT))
        return S_OK;

    Win4Assert(psa->cDims > 0);

    //
    // Existing array-- number of elements is not going to be larger
    // than a ulong or we wouldn't have been able to copy it. (Would
    // have got SAFEARRAYOVERFLOW in the copy.  Count the number of
    // elements by multiplying the number of elements in each dimension.
    //  
    ULONG i;
    ULONG cElementsTotal = psa->rgsabound[0].cElements; // First dim...
    for (i=1; i < psa->cDims; i++)
    {
        cElementsTotal *= psa->rgsabound[i].cElements;  // * next dim...
    }

    HRESULT hr = S_OK;
    BYTE *pbData = (BYTE *)psa->pvData;
    for (i=0; SUCCEEDED(hr) && (i < cElementsTotal); i++)
    {
        VARIANT *pv = (VARIANT *)pbData;

        hr = VariantClear(pv, fWeOwnByRefs);

        pbData += psa->cbElements;
    }

    return hr;
}


//
// Our version of VariantClear can't simply defer to oleaut, because:
//
// 1. It needs to interact correctly with the walker.
// 2. We might need to free the stuff we allocated in VariantCopy.
//
// Expanding on point number 2:  The problem is that if the byref
// bit is set on a variant, oleaut will just set the vt to VT_EMPTY
// and be done with it.  But when we have copied a byref variant, 
// we might have allocated all kinds of extra memory.  We actually
// want that memory to be free'd, so we need to do special things to 
// free it.
//
// VariantCopy allocates memory for the following things:
//    VT_VARIANT  | VT_BYREF
//    VT_UNKNOWN  | VT_BYREF
//    VT_DISPATCH | VT_BYREF
//
// We also need to walk into embedded safearrays because we copy them 
// with our version of VariantCopy.
//
HRESULT OAUTIL::VariantClear (VARIANT *pvarg, BOOL fWeOwnByRefs)
{
    HRESULT hr = S_OK;

    if (pvarg == NULL)
        return E_POINTER;

    if (m_pWalkerFree)
    {
        InterfaceWalkerFree walkerFree(m_pWalkerFree);
        ICallFrameWalker* pWalkerPrev = m_pWalkerWalk;
        m_pWalkerWalk = &walkerFree;
        hr = Walk(pvarg);
        m_pWalkerWalk = pWalkerPrev;
    }

    if (FAILED(hr))
        return hr;

    VARTYPE vt = pvarg->vt;

    if (fWeOwnByRefs && (vt & VT_BYREF))
    {
        vt &= ~VT_BYREF;

        // Free all the extra stuff that we allocate specially.
        // Everything else here is copied.
        if (vt & VT_ARRAY)
        {
            SAFEARRAY **ppSA = V_ARRAYREF(pvarg);
            if (ppSA)
            {
                // First of all, we need to "clear" it, because
                // it might be a SA of variants, which means we
                // did some funny allocations.
                //
                hr = SafeArrayClear(*ppSA, TRUE);
                //
                // Now we need to free up all of the memory
                // taken by the safearray.  This will clear
                // more conventional resources.
                //
                if (SUCCEEDED(hr) && (*ppSA))
                    hr = (g_oa.get_SafeArrayDestroy())(*ppSA);
                //
                // Now we free the extra 4 or 8 bytes allocated
                // for the pointer, and NULL everything out.
                //
                if (SUCCEEDED(hr))
                {
                    // Free the pointer we allocated.
                    FreeMemory(ppSA);
                    V_ARRAYREF(pvarg) = NULL;
                }                
            }
        }
        else
        {
            switch (vt)
            {
            case VT_VARIANT:
                // We are saved pain by the fact that VT_VARIANT must be VT_BYREF.
                // That's just the way it is.  Recurse.
                if (pvarg->pvarVal)
                {
                    hr = VariantClear(pvarg->pvarVal, TRUE);
                    FreeMemory(pvarg->pvarVal);
                }
                break;
                
            case VT_UNKNOWN:
            case VT_DISPATCH:
                // Should be already walked, so don't need to release.
                if (pvarg->ppunkVal)
                    FreeMemory(pvarg->ppunkVal);
                
            default:
                // Don't need to do anything special here.
                // Nothing allocated, nothing to free.
                break;
            }
        }
    }
    else
    {
        //
        // Not byref, or byref but not ours.
        //
        // What are all the reasons we could get here?
        //  1. Copying in or in,out parameter over, clearing the destination.
        //     In this case the destination is empty, and this does the right thing.
        //
        //  2. Copy out or in,out parameter over, clearing the source.
        //     In this case, we don't own byrefs.  If the variant is ByRef, then it
        //     is VariantCopy's job to deal with freeing memory.  If the variant is
        //     NOT ByRef, then oleaut will clear everything it's supposed to.
        //
        //  We don't get here when clearing out the used destination, after the call.
        //  In that case, we'll own the byrefs.
        //
        //  Why do I say all this?  To prove that we don't have to call 
        //  SafeArrayClear in this code path.
        //
        hr = (g_oa.get_VariantClear())(pvarg);
    }

    pvarg->vt = VT_EMPTY;

    return hr;
}

//
// Copy the variant. We don't defer to OLEAUT32 in order to interact
// correctly with m_pWalker
//
// At one time this code was horribly broken.  I'm working on trying to make it cleaner
// every time I go through it.  The implicit assumption is that we're just copying data
// and we try to share memory whenever possible.
//
HRESULT OAUTIL::VariantCopy(VARIANTARG* pvargDest, VARIANTARG * pvargSrc, BOOL fNewFrame)
{
    HRESULT hr = S_OK;
    BSTR bstr;

    if (pvargDest == pvargSrc)
    {
        // Copying to yourself is a no-op
    }
    else
    {
        const VARTYPE vt = V_VT(pvargSrc);
        
        //
        // free up strings or objects pvargDest is currently referencing.
        //
        void *pvTemp = pvargDest->ppunkVal;

        hr = VariantClear(pvargDest);

        pvargDest->ppunkVal = (IUnknown**)pvTemp;
        
        if (!hr)
        {
            if ((vt & (VT_ARRAY | VT_BYREF)) == VT_ARRAY)
            {
                hr = SafeArrayCopy(V_ARRAY(pvargSrc), &V_ARRAY(pvargDest));
                V_VT(pvargDest) = vt;
            }
            else if (vt == VT_BSTR) 
            {
                bstr = V_BSTR(pvargSrc);

                if(bstr)
                {
                    // Make the string copy first, so if it fails, the destination
                    // variant still is VT_EMPTY.
                    V_BSTR(pvargDest) = Copy(bstr);
                    if (V_BSTR(pvargDest))
                        V_VT(pvargDest) = VT_BSTR;
                    else
                        hr = E_OUTOFMEMORY;
                }
                else
                {
                    V_VT(pvargDest) = VT_BSTR;
                    V_BSTR(pvargDest) = NULL;
                }
            } 
            else if ((vt & ~VT_BYREF) == VT_RECORD) 
            {
                // User mode: defer to OLEAUT32 so as to get the right mem allocator involved
                //
                hr = (g_oa.get_VariantCopy())(pvargDest, pvargSrc);
            } 
            else
            {                
                if (vt & VT_BYREF)
                {
#if _DEBUG
                    CFTaggedPunk *pCFTaggedPunk = NULL;
                    CFTaggedVariant* pCFTaggedVariant = NULL;
#endif                    
                    if (vt & VT_ARRAY)
                    {
                        // Byref array of something.
                        // 
                        hr = S_OK;
                        if (fNewFrame)
                        {
                            // Need to allocate a pointer size thing because we can't re-use any memory.
                            *pvargDest = *pvargSrc;
                            V_ARRAYREF(pvargDest) = (SAFEARRAY **)AllocateMemory(sizeof(SAFEARRAY *));
                            if (V_ARRAYREF(pvargDest))
                                *V_ARRAYREF(pvargDest) = NULL;
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            // Re-use the array pointer.
                            // Take care to save the ppSA, because we'll refer to it later.
                            SAFEARRAY **ppSA = V_ARRAYREF(pvargDest);
                            *pvargDest = *pvargSrc;
                            V_ARRAYREF(pvargDest) = ppSA;
                        }

                        if (SUCCEEDED(hr))
                        {
                            SAFEARRAY **ppaSrc = V_ARRAYREF(pvargSrc);
                            SAFEARRAY *paSrc   = *ppaSrc;
                            SAFEARRAY **ppaDst = V_ARRAYREF(pvargDest);
                            SAFEARRAY *paDst   = *ppaDst;
                            
                            // These rules were taken out of the marshalling code from oleaut.
                            // There is one optimization, though-- marshalling only allocs if
                            // necessary.  We're allocating always, to make life simple.
                            //
                            // Note: that we took great care (above) to make sure paDst stays 
                            //       the same if we're not going to a new frame.
                            BOOL fDestResizeable = fNewFrame || 
                                                   (paDst == NULL) || 
                                                   (!(paDst->fFeatures & (FADF_AUTO|FADF_STATIC|FADF_EMBEDDED|FADF_FIXEDSIZE)));

                            if (fDestResizeable)
                            {
                                if (paDst)
                                    hr = SafeArrayDestroy(paDst);

                                if (SUCCEEDED(hr))
                                {
                                    if (paSrc)
                                        hr = SafeArrayCopy(paSrc, ppaDst);
                                    else
                                        *ppaDst = NULL;
                                }
                            }
                            else
                            {
                                hr = SafeArrayCopyData(paSrc, paDst);
                                
                                // Not resizeable.... 
                                if (hr == E_INVALIDARG)
                                    hr = DISP_E_BADCALLEE;
                            }
                        }
                    }
                    else // vt & VT_ARRAY
                    {
                        switch (vt & ~VT_BYREF)
                        {
                        case VT_VARIANT:
                            // BYREF VARIANTs must be checked to see if the VARIANT pointed to by
                            // pvarVal is a DISPATCH or UNKNOWN interface.  If it is, a copy of
                            // the VARIANT at this level must be made so the original interface
                            // pointer and the copy do note share the same address.  If they share
                            // the same address, the original will be overwritten if a walker
                            // marshals the interface pointer in place.
                            
                            // In any case, we need to see about space for the VARIANT we point to.
                            if (fNewFrame)
                            {
                                *pvargDest = *pvargSrc;
#if _DEBUG                            
                                pCFTaggedVariant = (CFTaggedVariant*) AllocateMemory(sizeof(CFTaggedVariant));
                                pCFTaggedVariant->tag = 0xF000BAAA;
                                
                                pvargDest->pvarVal = (VARIANT*) &pCFTaggedVariant->variant;
#else
                                pvargDest->pvarVal = (VARIANT*) AllocateMemory(sizeof(VARIANT));
#endif                            
                                // "VariantInit".
                                pvargDest->pvarVal->vt = VT_EMPTY;
                            }
                            else
                            {
                                // If we are copying back to an existing callframe,
                                // we want to copy use the existing memory.
                                VARIANT *pvar = pvargDest->pvarVal;
                                *pvargDest = *pvargSrc;
                                pvargDest->pvarVal = pvar;
                            }
                            
                            if (pvargDest->pvarVal)
                            {
                                // Simple recursion... copy the underlying variant
                                OAUTIL::VariantCopy(pvargDest->pvarVal, pvargSrc->pvarVal, fNewFrame); 
                            }
                            else
                                hr = E_OUTOFMEMORY;                            

                            break;
                        
                        case VT_UNKNOWN:
                        case VT_DISPATCH:
                            // If we are copying to a new callframe, we must 
                            // allocate wrappers for BYVAL interface pointers
                            // because they cannot be shared between callframes.
                            if (fNewFrame)
                            {
                                *pvargDest = *pvargSrc;
#if _DEBUG                            
                                pCFTaggedPunk = (CFTaggedPunk*) AllocateMemory(sizeof(CFTaggedPunk));
                                pCFTaggedPunk->tag = 0xF000BAAA;
                                
                                pvargDest->ppunkVal = (LPUNKNOWN*) &pCFTaggedPunk->pv;
#else
                                pvargDest->ppunkVal = (LPUNKNOWN*) AllocateMemory(sizeof(LPUNKNOWN));
#endif                            
                            }
                            else
                            {
                                // If we are copying back to an existing callframe,
                                // we want to copy use the existing memory.
                                LPUNKNOWN *ppunk = pvargDest->ppunkVal;
                                *pvargDest = *pvargSrc;
                                pvargDest->ppunkVal = ppunk;
                            }
                                                    
                            if (pvargDest->ppunkVal)
                            {
                                // Copy the interface pointer from the source
                                // into our wrapper.
                                *pvargDest->ppunkVal = *pvargSrc->ppunkVal;
                                
                                // AddRef the interface appropriately.  If the
                                // caller supplied a walker, this will cause
                                // the walker to get called.
                                if (*V_UNKNOWNREF(pvargDest) && WalkInterfaces())
                                    AddRefInterface(*V_UNKNOWNREF(pvargDest));
                            }
                            else
                            {
                                if (fNewFrame)
                                    hr = E_OUTOFMEMORY;
                            }
                            break;

                        default:
                            // Byref something else.
                            *pvargDest = *pvargSrc;
                            
                            break;
                        };
                    } // if not vt & VT_ARRAY
                }
                else // if (vt & VT_BYREF)
                {                    
                    // We begin by just copying the source into the destination
                    // by value.  We will fixup any pieces appropriately below.
                    *pvargDest = *pvargSrc;
                
                    switch(vt)
                    {
                    case VT_UNKNOWN:
                        if (WalkInterfaces())
                            AddRefInterface(V_UNKNOWN(pvargDest));
                        else
                            pvargDest->punkVal->AddRef();
                        break;

                    case VT_DISPATCH:
                        if (WalkInterfaces())
                            AddRefInterface(V_DISPATCH(pvargDest));
                        else
                            pvargDest->pdispVal->AddRef();
                        break;
                    default:
                        break;
                    }      
                }
            }
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////


//
// From oa/src/dispatch/sarray.cpp
//

#define SAFEARRAYOVERFLOW   0xffffffff

#if 0
#define PVTELEM(psa)        ((LONG *)(psa) - 1)
#define PIIDELEM(psa)       ((BYTE *)(psa) - sizeof(GUID))
#define PPIRIELEM(psa)      ((IRecordInfo **)(psa) - 1)
#else
#define PVTELEM(psa)                (&SAFEARRAY_INTERNAL::From(psa)->vt)
#define PIIDELEM(psa)       ((BYTE*)(&SAFEARRAY_INTERNAL::From(psa)->iid))
#define PPIRIELEM(psa)              (&SAFEARRAY_INTERNAL::From(psa)->piri)
#endif


HRESULT OAUTIL::SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut)
{
    HRESULT hr        = S_OK;
    SAFEARRAY* psaNew = NULL;

    if (NULL == ppsaOut)
        hr = E_INVALIDARG;
    else
    {
        *ppsaOut = NULL;

        if (psa)
        {
            SAFEARRAY_INTERNAL* psaInt = SAFEARRAY_INTERNAL::From(psa);
            //
            // Allocate the descriptor first
            //
            if (psa->fFeatures & (FADF_RECORD | FADF_HAVEIID | FADF_HAVEVARTYPE)) 
            {
                if (psa->fFeatures & FADF_RECORD) 
                {
                    hr = SafeArrayAllocDescriptorEx(VT_RECORD, psa->cDims, &psaNew);
                    if (!hr)
                    {
                        SAFEARRAY_INTERNAL::From(psaNew)->piri = psaInt->piri;

                        // We do not walk the IRecordInfo-- it must be context agnostic.
                        //AddRefInterface(SAFEARRAY_INTERNAL::From(psaNew)->piri);
                        if (psaInt->piri)
                            psaInt->piri->AddRef();
                    }
                } 
                else if (psa->fFeatures & FADF_HAVEIID) 
                {
                    hr = SafeArrayAllocDescriptorEx(VT_UNKNOWN, psa->cDims, &psaNew);
                    if (!hr)
                    {
                        SAFEARRAY_INTERNAL::From(psaNew)->iid = psaInt->iid;
                    }
                } 
                else if (psa->fFeatures & FADF_HAVEVARTYPE)
                {
                    hr = SafeArrayAllocDescriptorEx((VARTYPE)*PVTELEM(psa), psa->cDims, &psaNew);
                }
            } 
            else
            {
                hr = SafeArrayAllocDescriptor(psa->cDims, &psaNew);
            }

            if (!hr)
            {
                psaNew->cLocks     = 0;
                psaNew->cDims      = psa->cDims;
                psaNew->fFeatures  = psa->fFeatures & ~(FADF_AUTO | FADF_STATIC | FADF_EMBEDDED | FADF_FORCEFREE | FADF_FIXEDSIZE);
                psaNew->cbElements = psa->cbElements;

                memcpy(psaNew->rgsabound, psa->rgsabound, sizeof(SAFEARRAYBOUND) * psa->cDims);

                hr = SafeArrayAllocData(psaNew);
                if (!hr)
                {
                    hr = SafeArrayCopyData(psa, psaNew);
                    if (!hr)
                    {
                        *ppsaOut = psaNew;
                        psaNew = NULL;
                    }
                }
            }
        }
    }

    if (psaNew)
    {
        // Error case
        //
        SafeArrayDestroy(psaNew);
    }
   
    return hr;
}

ULONG SafeArraySize(USHORT cDims, ULONG cbElements, SAFEARRAYBOUND* psabound)
{
    ULONG cb = 0;
    if (cDims)
    {
        cb = cbElements;
        for (USHORT us = 0; us < cDims; ++us)
        {
            // Do a 32x32 multiply, with overflow checking
            //
            LONGLONG dw1 = cb;
            LONGLONG dw2 = psabound->cElements;

            LARGE_INTEGER product;
            product.QuadPart = dw1 * dw2;
            if (product.HighPart == 0)
            {
                cb = product.LowPart;
            }
            else
            {
                return SAFEARRAYOVERFLOW;
            }
            ++psabound;
        }
    }
    return cb;
}

ULONG SafeArraySize(SAFEARRAY * psa)
{
    return SafeArraySize(psa->cDims, psa->cbElements, psa->rgsabound);
}

HRESULT OAUTIL::SafeArrayDestroyData(SAFEARRAY * psa)
{
    HRESULT hr = S_OK;

    if (m_pWalkerFree)
    {
        // Release & NULL the interface pointers first by doing a walk.
        //
        InterfaceWalkerFree walkerFree(m_pWalkerFree);
        ICallFrameWalker* pWalkerPrev = m_pWalkerWalk;
        m_pWalkerWalk = &walkerFree;
        hr = Walk(psa);
        m_pWalkerWalk = pWalkerPrev;
    }
    
    if (!hr)
    {
        // Then call OleAut32 to do the real work
        //
        hr = (g_oa.get_SafeArrayDestroyData())(psa);
    }
    
    return hr;
}

HRESULT OAUTIL::SafeArrayDestroy(SAFEARRAY * psa)
{
    HRESULT hr = S_OK;

    if (m_pWalkerFree)
    {
        // Release & NULL the interface pointers first
        //
        InterfaceWalkerFree walkerFree(m_pWalkerFree);
        ICallFrameWalker* pWalkerPrev = m_pWalkerWalk;
        m_pWalkerWalk = &walkerFree;
        hr = Walk(psa);
        m_pWalkerWalk = pWalkerPrev;
    }
    
    if (!hr)
    {
        // Then call OleAut32 to do the real work
        //
        hr = (g_oa.get_SafeArrayDestroy())(psa);
    }

    return hr;
}

HRESULT SafeArrayAllocDescriptor(UINT cDims, SAFEARRAY** ppsaOut)
// Alloc a new array descriptor for the indicated number of dimensions,
// We may or may not have the extra 16 bytes at the start, depending on
// what version of OLEAUT32 we're talking to.
{
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayAllocDescriptor())(cDims, ppsaOut);

    return hr;
}

HRESULT SafeArrayAllocDescriptorEx(VARTYPE vt, UINT cDims, SAFEARRAY** ppsaOut)
{       
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayAllocDescriptorEx())(vt, cDims, ppsaOut);
   
    return hr;
}

HRESULT SafeArrayAllocData(SAFEARRAY* psa)
{
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayAllocData())(psa);

    return hr;
}

HRESULT SafeArrayDestroyDescriptor(SAFEARRAY* psa)
{
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayDestroyDescriptor())(psa);

    return hr;
}

HRESULT OAUTIL::SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget)
// Copy over the the body of a safe array. We do NOT defer to OLEAUT32 because
// we want to ensure that we interact with m_pWalker appropriately.
//
{
    HRESULT hr = S_OK;

    if (NULL == psaSource || NULL == psaTarget || psaSource->cbElements == 0 || psaSource->cDims != psaTarget->cDims)
        hr = E_INVALIDARG;

    for (UINT i = 0; !hr && i < psaSource->cDims; i++)
    {
        if (psaSource->rgsabound[i].cElements != psaTarget->rgsabound[i].cElements)
            hr = E_INVALIDARG;
    }

    if (!hr) 
    {
        hr = SafeArrayLock(psaSource);
        if (!hr)
        {
            hr = SafeArrayLock(psaTarget);
            if (!hr)
            {
                ULONG cbSize    = SafeArraySize(psaSource);
                ULONG cElements = cbSize / psaSource->cbElements;

                if (psaSource->fFeatures & FADF_BSTR)
                {
                    BSTR* pbstrDst, *pbstrSrc;
                    pbstrSrc = (BSTR*)psaSource->pvData;
                    pbstrDst = (BSTR*)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        if (NULL != *pbstrDst)
                        {
                            SysFreeString(*pbstrDst);
                        }
                        *pbstrDst = Copy(*pbstrSrc);
                        if (NULL == *pbstrDst)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        ++pbstrDst, ++pbstrSrc; 
                    }
                }
                else if (psaSource->fFeatures & FADF_UNKNOWN)
                {
                    IUnknown** ppunkDst, ** ppunkSrc;
                    ppunkSrc = (IUnknown**)psaSource->pvData;
                    ppunkDst = (IUnknown**)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        IUnknown* punkDst = *ppunkDst;
                        //
                        *ppunkDst = *ppunkSrc;
                        AddRefInterface(*ppunkDst);
                        //
                        if (m_pWalkerFree)
                            ReleaseInterface(punkDst);
                        //
                        ++ppunkDst, ++ppunkSrc;
                    }
                }
                else if (psaSource->fFeatures & FADF_DISPATCH)
                {
                    IDispatch** ppdispDst, ** ppdispSrc;
                    ppdispSrc = (IDispatch**)psaSource->pvData;
                    ppdispDst = (IDispatch**)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        IDispatch* pdispDst = *ppdispDst;
                        //
                        *ppdispDst = *ppdispSrc;
                        AddRefInterface(*ppdispDst);
                        //
                        if (m_pWalkerFree)
                            ReleaseInterface(pdispDst);
                        //
                        ++ppdispDst, ++ppdispSrc;
                    }
                }
                else if(psaSource->fFeatures & FADF_VARIANT)
                {
                    VARIANT * pvarDst, * pvarSrc;
                    pvarSrc = (VARIANT *)psaSource->pvData;
                    pvarDst = (VARIANT *)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        hr = VariantCopy(pvarDst, pvarSrc, TRUE);
                        ++pvarDst, ++pvarSrc;
                    }

                }
                else if (psaSource->fFeatures & FADF_RECORD)
                {
                    PBYTE pbSrc, pbDst;
                    pbSrc = (PBYTE)psaSource->pvData;
                    pbDst = (PBYTE)psaTarget->pvData;

                    IRecordInfo*priSource = *PPIRIELEM(psaSource);

                    if (priSource != NULL) 
                    {
                        for (i = 0; !hr && i < cElements; ++i)
                        {
                            hr = (*PPIRIELEM(psaSource))->RecordCopy(pbSrc, pbDst);
                            pbSrc += psaSource->cbElements;
                            pbDst += psaSource->cbElements;
                        }
                    }
                }
                else
                {
                    if (0 < cbSize)
                    {
                        memcpy(psaTarget->pvData, psaSource->pvData, cbSize);
                    }
                }
                SafeArrayUnlock(psaTarget);
            }
            SafeArrayUnlock(psaSource);
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Walking
//

HRESULT OAUTIL::Walk(SAFEARRAY* psa, IRecordInfo* pinfo, ULONG iDim, PVOID pvData, PVOID* ppvDataOut)
// Walk the safe array for interface pointers. Walk the indicated dimension,
// recursing to higher numbered dimensions
{
    HRESULT hr = S_OK;

    // This is technically a mal-formed SAFEARRAY, but I'm not going to complain about it.
    // There's certainly nothing to walk here.
    if (psa->cDims == 0)
        return S_OK;

    //
    // FYI: The bounds are stored in the array descriptor in reverse-textual order
    //
    const SAFEARRAYBOUND bound = psa->rgsabound[psa->cDims-1 - iDim];

    if (iDim + 1 == psa->cDims)
    {
        // We're at the innermost dimension. 
        //
        for (ULONG iElement = 0; !hr && iElement < bound.cElements; iElement++)
        {
            // Process the one element
            //
            if (psa->fFeatures & FADF_UNKNOWN)
            {
                IUnknown** punk = (IUnknown**)pvData;
                hr = WalkInterface(punk);
            }
            else if (psa->fFeatures & FADF_DISPATCH)
            {
                IDispatch** pdisp = (IDispatch**)pvData;
                hr = WalkInterface(pdisp);
            }
            else if (psa->fFeatures & FADF_VARIANT)
            {
                VARIANT* pv = (VARIANT*)pvData;
                hr = Walk(pv);
            }
            else if (psa->fFeatures & FADF_RECORD)
            {
                hr = Walk(pinfo, pvData);
            }
            //
            // Point to the next element
            //
            pvData = (BYTE*)pvData + psa->cbElements;
        }
    }
    else
    {
        // We're not at the innermost dimension. Walk that dimension
        //
        for (ULONG iElement = 0; !hr && iElement < bound.cElements; iElement++)
        {
            // Recurse for the next dimension
            //
            hr = Walk(psa, pinfo, iDim+1, pvData, &pvData);
        }
    }

    if (ppvDataOut)
    {
        *ppvDataOut = pvData;
    }

    return hr;
}

HRESULT OAUTIL::Walk(SAFEARRAY* psa)
{
    if (psa)
    {
        return Walk(psa, psa->pvData);
    }
    else
        return S_OK;
}

HRESULT OAUTIL::Walk(SAFEARRAY* psa, PVOID pvData)
// Walk the safe array for interface pointers. Walk the indicated dimension,
// recursing to higher numbered dimensions
{
    HRESULT hr = S_OK;

    if (psa)
    {
        if (psa->fFeatures & (FADF_UNKNOWN | FADF_DISPATCH | FADF_VARIANT))
        {
            if (pvData)
            {
                hr = Walk(psa, NULL, 0, pvData, NULL);
            }
        }
        else if (psa->fFeatures & FADF_RECORD)
        {
            // Hold the record info ourselves so no one stomps on it
            //
            IRecordInfo* pinfo = SAFEARRAY_INTERNAL::From(psa)->piri;
            pinfo->AddRef();

#if 0
            // [a-sergiv, 5/21/99] I believe, and numberous experiments confirm,
            // that IRecordInfo MUST NOT be walked. IRecordInfo must be context-agnostic.
            //
            // Therefore, this call is commented out as part of the fix for COM+ #13619.


            //
            // Walk the record info itself
            //
            hr = WalkInterface(&SAFEARRAY_INTERNAL::From(psa)->piri);
#endif

            //    
            // Walk the data.
            //
            if (!hr)
            {
                if (pvData)
                {
                    hr = Walk(psa, pinfo, 0, pvData, NULL);
                }
            }

            ::Release(pinfo);
        }
    }

    return hr;
}

HRESULT OAUTIL::Walk(VARIANTARG* pvar)
// Walk the variant for interface pointers
{
    HRESULT hr = S_OK;

    if (pvar)
    {
        VARTYPE vt = pvar->vt;
        BOOL fByRef = (vt & VT_BYREF);

        switch (vt & (~VT_BYREF))
        {
        case VT_DISPATCH:
            if (fByRef) { hr = WalkInterface(pvar->ppdispVal); }
            else        { hr = WalkInterface(&pvar->pdispVal); }
            break;
        
        case VT_UNKNOWN:
            if (fByRef) { hr = WalkInterface(pvar->ppunkVal); }
            else        { hr = WalkInterface(&pvar->punkVal); }
            break;

        case VT_VARIANT:
            if (fByRef) { hr = Walk(pvar->pvarVal);  }
            else        { /* caller error: ignore */ }
            break;

        case VT_RECORD:
            hr = Walk(pvar->pRecInfo, pvar->pvRecord);
            break;

        default:        
        { 
            if (vt & VT_ARRAY)
            {
                if (fByRef) { hr = Walk(*pvar->pparray);   }
                else        { hr = Walk(pvar->parray); }
            }
            else
            {
                /* nothing to walk */
            }
        }
            break;

            /* end switch */
        }
    }

    return hr;
}

BOOL VARIANT_ContainsByRefInterfacePointer(VARIANT* pVar);

HRESULT OAUTIL::Walk(DWORD walkWhat, DISPPARAMS* pdispParams)
// Walk the list of DISPARAMS for interface pointers
{
    HRESULT hr = S_OK;

    if (pdispParams)
    {
        const UINT cArgs = pdispParams->cArgs;

        BOOL fOldIn  = m_fWorkingOnInParam;
        BOOL fOldOut = m_fWorkingOnOutParam;

        m_fWorkingOnInParam = TRUE;
        for (UINT iarg = 0; !hr && iarg < cArgs; iarg++)
        {
            // Parameters are in reverse order inside the DISPARAMS. We iterate 
            // in forward order as a matter of style and for consistency with 
            // the CallFrame implementation.
            //
            VARIANTARG* pvar = &pdispParams->rgvarg[cArgs-1 - iarg];
            //
            // References are logically in-out, others are just in.
            //
//          if (VARIANT_ContainsByRefInterfacePointer(pvar))
            if (pvar->vt & VT_BYREF)
            {
                m_fWorkingOnOutParam = TRUE;
                if (walkWhat & CALLFRAME_WALK_INOUT)
                {
                    hr = Walk(pvar);
                }
            }
            else
            {
                m_fWorkingOnOutParam = FALSE;
                if (walkWhat & CALLFRAME_WALK_IN)
                {
                    hr = Walk(pvar);
                }
            }

            m_fWorkingOnInParam  = fOldIn;
            m_fWorkingOnOutParam = fOldOut;
        }
    }

    return hr;
}

HRESULT GetFieldCount(IRecordInfo* pinfo, ULONG* pcFields)
// Answer the number of fields in this record info
//
{
    HRESULT hr = S_OK;

    ITypeInfo* ptinfo;

    hr = pinfo->GetTypeInfo(&ptinfo);
    if (!hr)
    {
        TYPEATTR* pattr;
        hr = ptinfo->GetTypeAttr(&pattr);
        if (!hr)
        {
            *pcFields = pattr->cVars;
            ptinfo->ReleaseTypeAttr(pattr);
        }

        ::Release(ptinfo);
    }

    return hr;
}

HRESULT OAUTIL::Walk(IRecordInfo* pinfo, PVOID pvData)
// Walk the record data as described by this record info
//
{
    HRESULT hr = S_OK;

    ULONG cFields, iField;
    hr = GetFieldCount(pinfo, &cFields);
    if (!hr)
    {
        // Allocate and fetch the names of the fields
        //
        BSTR* rgbstr = new BSTR[cFields];
        if (rgbstr)
        {
            Zero(rgbstr, cFields*sizeof(BSTR));
            //
            ULONG cf = cFields;
            hr = pinfo->GetFieldNames(&cf, rgbstr);
            if (!hr)
            {
                ASSERT(cf == cFields);
                //
                // Get a copy of the record data. We'll use this to see if any of the IRecordInfo
                // fn's we call end up stomping on the data, as GetFieldNoCopy is suspected of doing.
                // Making a copy both allows us to detect this and avoids stomping on memory that we
                // probably aren't allowed to stomp on in the original actual frame.
                //
                ULONG cbRecord;
                hr = pinfo->GetSize(&cbRecord);
                if (!hr)
                {
                    BYTE* pbRecordCopy = (BYTE*)AllocateMemory(cbRecord);
                    if (pbRecordCopy)
                    {
                        memcpy(pbRecordCopy, pvData, cbRecord);
                        //
                        // Iterate over the fields, walking each one
                        //
                        for (iField = 0; !hr && iField < cFields; iField++)
                        {
                            VARIANT v; VariantInit(&v);
                            PVOID pvDataCArray;
                            //
                            // Use IRecordInfo::GetFieldNoCopy to find location and type of field.
                            // 
                            hr = pinfo->GetFieldNoCopy(pbRecordCopy, rgbstr[iField], &v, &pvDataCArray);
                            //
                            if (!hr)
                            {
                                VARTYPE vt = v.vt; ASSERT(vt & VT_BYREF);
                                //
                                if (vt & VT_ARRAY)
                                {
                                    // Either a VT_SAFEARRAY or a VT_CARRAY
                                    //
                                    if (pvDataCArray)
                                    {
                                        ASSERT( (vt & ~(VT_BYREF|VT_ARRAY)) == VT_CARRAY );
                                        //
                                        // pvDataCArray is the actual data to walk. A descriptor for it exists
                                        // in the variant; this descriptor is managed by the IRecordInfo, not us.
                                        // 
                                        SAFEARRAY* psa = *v.pparray;
                                        ASSERT( psa->pvData == NULL );
                                        //
                                        hr = Walk(psa, pvDataCArray);
                                        //
                                    }
                                    else
                                    {

                                        // [a-sergiv, 5/21/99] SafeArrays of VT_RECORD are designated as
                                        // VT_ARRAY|VT_RECORD. Therefore, checking for VT_SAFEARRAY only is not sufficient.
                                        // COM+ #13619

                                        ASSERT( (vt & ~(VT_BYREF|VT_ARRAY)) == VT_SAFEARRAY
                                                || (vt & ~(VT_BYREF|VT_ARRAY)) == VT_RECORD);
                                        //
                                        // GetFieldNoCopy might have allocated a descriptor on us. We want to detect this
                                        //
                                        SAFEARRAY** ppsaNew = v.pparray;
                                        SAFEARRAY** ppsaOld = (SAFEARRAY**)((PBYTE(ppsaNew) - pbRecordCopy) + PBYTE(pvData));
                                        //
                                        SAFEARRAY* psaNew = *ppsaNew;
                                        SAFEARRAY* psaOld = *ppsaOld;
                                        //
                                        ASSERT(psaNew); // would get error hr if not so
                                        //
                                        if (psaOld)
                                        {
                                            // GetFieldNoCopy did no allocations. Just walk what we had in the first place.
                                            //
                                            hr = Walk(psaOld);
                                        }
                                        else
                                        {
                                            // GetFieldNoCopy did an allocation of an array descriptor. There was nothing
                                            // to walk in the first place. Just free that descriptor now.
                                            //
                                            SafeArrayDestroyDescriptor(psaNew);
                                        }
                                    }
                                }
                                else
                                {
                                    // Not an array. Just a simple by-ref. Use variant helper to walk.
                                    // First translate the addresses, though, to point to the actual data.
                                    //
                                    v.pbVal = (v.pbVal - pbRecordCopy) + PBYTE(pvData);
                                    //
                                    hr = Walk(&v);
                                }
                            }
                        }

                        FreeMemory(pbRecordCopy);
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
            }
            //
            // Free the fetched names
            //
            for (iField = 0; iField < cFields; iField++) 
            {
                SysFreeString(rgbstr[iField]);
            }
            delete [] rgbstr;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


HRESULT OLEAUTOMATION_FUNCTIONS::GetProc(HRESULT hr, LPCSTR szProcName, PVOID* ppfn)
{
    if (!hr)
    {
        PVOID pfnTemp = GetProcAddress(hOleAut32, szProcName);
        if (pfnTemp)
        {
            InterlockedExchangePointer(ppfn, pfnTemp);
        }
        else
            hr = HError();
    }
    return hr;
}

HRESULT OLEAUTOMATION_FUNCTIONS::LoadOleAut32()
// Load OLEAUT32 if it hasn't already been loaded
{
    HRESULT hr = S_OK;

    if (0 == hOleAut32)
    {
        HINSTANCE hinst = LoadLibraryA("OLEAUT32");
        if (hinst)
        {
            if (NULL == InterlockedCompareExchangePointer((PVOID*)&hOleAut32, hinst, NULL))
            {
                // We were the first one in, so our LoadLibrary counts!
            }
            else
            {
                // Someone else got in there. Free our LoadLibrary ref
                //
                FreeLibrary(hinst);
            }
        }
        else
            hr = HError();
    }

    return hr;
}

void OLEAUTOMATION_FUNCTIONS::Load()
{
    HRESULT hr = S_OK;

    if (!fProcAddressesLoaded)
    {
        hr = LoadOleAut32();
        if (!hr)
        {
            hr = GetProc(hr, "BSTR_UserSize",               (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnBufferSize);
            hr = GetProc(hr, "BSTR_UserMarshal",            (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnMarshall);
            hr = GetProc(hr, "BSTR_UserUnmarshal",          (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnUnmarshall);
            hr = GetProc(hr, "BSTR_UserFree",               (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnFree);
            hr = GetProc(hr, "VARIANT_UserSize",            (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnBufferSize);
            hr = GetProc(hr, "VARIANT_UserMarshal",         (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnMarshall);
            hr = GetProc(hr, "VARIANT_UserUnmarshal",       (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnUnmarshall);
            hr = GetProc(hr, "VARIANT_UserFree",            (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnFree);
            hr = GetProc(hr, "LPSAFEARRAY_UserSize",        (PVOID*)& pfnLPSAFEARRAY_UserSize);
            hr = GetProc(hr, "LPSAFEARRAY_UserMarshal",     (PVOID*)& pfnLPSAFEARRAY_UserMarshal);
            hr = GetProc(hr, "LPSAFEARRAY_UserUnmarshal",   (PVOID*)& pfnLPSAFEARRAY_UserUnmarshal);
            hr = GetProc(hr, "LPSAFEARRAY_UserFree",        (PVOID*)& UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnFree);

            hr = GetProc(hr, "LPSAFEARRAY_Size",            (PVOID*)& pfnLPSAFEARRAY_Size);
            hr = GetProc(hr, "LPSAFEARRAY_Marshal",         (PVOID*)& pfnLPSAFEARRAY_Marshal);
            hr = GetProc(hr, "LPSAFEARRAY_Unmarshal",       (PVOID*)& pfnLPSAFEARRAY_Unmarshal);
            
            hr = GetProc(hr, "LoadTypeLib",                 (PVOID*)& pfnLoadTypeLib);
            hr = GetProc(hr, "LoadTypeLibEx",               (PVOID*)& pfnLoadTypeLibEx);
            hr = GetProc(hr, "LoadRegTypeLib",              (PVOID*)& pfnLoadRegTypeLib);
            
            hr = GetProc(hr, "SysAllocString",              (PVOID*)& pfnSysAllocString);
            hr = GetProc(hr, "SysAllocStringLen",           (PVOID*)& pfnSysAllocStringLen);
            hr = GetProc(hr, "SysAllocStringByteLen",       (PVOID*)& pfnSysAllocStringByteLen);
            hr = GetProc(hr, "SysReAllocString",            (PVOID*)& pfnSysReAllocString);
            hr = GetProc(hr, "SysReAllocStringLen",         (PVOID*)& pfnSysReAllocStringLen);
            hr = GetProc(hr, "SysFreeString",               (PVOID*)& pfnSysFreeString);
            hr = GetProc(hr, "SysStringByteLen",            (PVOID*)& pfnSysStringByteLen);
            
            hr = GetProc(hr, "VariantClear",                (PVOID*)& pfnVariantClear);
            hr = GetProc(hr, "VariantCopy",                 (PVOID*)& pfnVariantCopy);

            hr = GetProc(hr, "SafeArrayDestroy",            (PVOID*)& pfnSafeArrayDestroy);
            hr = GetProc(hr, "SafeArrayDestroyData",        (PVOID*)& pfnSafeArrayDestroyData);
            hr = GetProc(hr, "SafeArrayDestroyDescriptor",  (PVOID*)& pfnSafeArrayDestroyDescriptor);
            hr = GetProc(hr, "SafeArrayAllocDescriptor",    (PVOID*)& pfnSafeArrayAllocDescriptor);
            hr = GetProc(hr, "SafeArrayAllocDescriptorEx",  (PVOID*)& pfnSafeArrayAllocDescriptorEx);
            hr = GetProc(hr, "SafeArrayAllocData",          (PVOID*)& pfnSafeArrayAllocData);
            hr = GetProc(hr, "SafeArrayCopyData",           (PVOID*)& pfnSafeArrayCopyData);

            if (!hr)
            {
                fProcAddressesLoaded = TRUE;
            }
        }
    }

    if (!!hr)
    {
        Throw(hr);
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

OLEAUTOMATION_FUNCTIONS g_oa;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\metadata.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Metadata.h
//
struct MD_INTERFACE;
struct MD_METHOD;
struct MD_PARAM;
struct MD_INTERFACE_CACHE;

#include "typeinfo.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//
// A structure to keep track of whether in a given type we have any interface pointers, 
// and, if so whether we have an upper bound on them
// 

inline BOOL IsUnbounded(LONG l)
    {
    return l < 0;
    }
inline void MakeUnbounded(LONG& l)
    {
    l = -1;
    ASSERT(IsUnbounded(l));
    }


struct HAS_INTERFACES
    {
    LONG m_cInterfaces;
    
    HAS_INTERFACES()
        {
        m_cInterfaces = 0;
        }

    void MakeUnbounded()
        {
        ::MakeUnbounded(m_cInterfaces);
        ASSERT(IsUnbounded());
        }

    BOOL IsUnbounded() const
        {
        return ::IsUnbounded(m_cInterfaces);
        }

    BOOL HasAnyInterfaces() const
        {
        return m_cInterfaces != 0;
        }

    void Add(const HAS_INTERFACES& him)
        {
        if (!IsUnbounded())
            {
            if (him.IsUnbounded())
                MakeUnbounded();
            else
                m_cInterfaces += him.m_cInterfaces;
            }
        } 

    void Update(LONG& cInterfaces) const
    // Update external state variables based on our contents
        {
        if (!::IsUnbounded(cInterfaces))
            {
            if (this->IsUnbounded())
                ::MakeUnbounded(cInterfaces);
            else
                cInterfaces += m_cInterfaces;
            }
        }

    };

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

HAS_INTERFACES IsShareableType(PFORMAT_STRING pFormat);

inline BOOL IsPointer(PFORMAT_STRING pFormat)
    {
    // FC_RP, FC_UP, FC_OP, and FC_FP are contiguous
    return (FC_RP <= *pFormat && *pFormat <= FC_FP);
    }

inline HAS_INTERFACES IsSharableEmbeddedRepeatPointers(PFORMAT_STRING& pFormat)
    {
    HAS_INTERFACES me;

    LONG repeatCount;

    if (*pFormat == FC_FIXED_REPEAT)
        {
        pFormat += 2;                       
        repeatCount = *(ushort*)pFormat;
        }
    else
        {
        repeatCount = 0;                    // a variable repeat count: treat as unbounded if we get any interfaces at all
        }

    pFormat += 2;                           // increment to increment field
    pFormat += sizeof(ushort);              // skip that 
    pFormat += 2;                           // ignore the 'array offset'

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;
    ULONG          cPointers   = cPointersSave;
    //
    // Loop over the number of pointers per array element. Can be more than one for an array of structures
    //
    for ( ; cPointers--; )
        {
        pFormat += 4;
        ASSERT(IsPointer(pFormat));         // recurse to check the pointer

        HAS_INTERFACES him = IsShareableType(pFormat);
        if (repeatCount == 0 && him.HasAnyInterfaces())
            {
            me.MakeUnbounded();             // A variable repeat count of any interfaces is out of here!
            }
        else
            {
            him.m_cInterfaces *= repeatCount; // Scale his interface count by our array size
            me.Add(him);                      // fold in his contribution
            }

        pFormat += 4;                       // increment to the next pointer description
        }

    // return location of format string after the array's pointer description
    pFormat = pFormatSave + cPointersSave * 8;
    return me;
    }

///////////////////////////////////////////////////////////////////////

inline HAS_INTERFACES IsSharableEmbeddedPointers(PFORMAT_STRING pFormat)
    {
    HAS_INTERFACES me;

    pFormat += 2;   // Skip FC_PP and FC_PAD
    while (FC_END != *pFormat)
        {
        if (FC_NO_REPEAT == *pFormat)
            {
            pFormat += 6;                   // increment to the pointer description

            ASSERT(IsPointer(pFormat));     // recurse to check the pointer
            me.Add(IsShareableType(pFormat));

            pFormat += 4;                   // increment to the next pointer description
            }
        else
            {
            me.Add(IsSharableEmbeddedRepeatPointers(pFormat));
            }
        }
    return me;
    }

///////////////////////////////////////////////////////////////////////

inline HAS_INTERFACES IsShareableType(PFORMAT_STRING pFormat)
// We don't want to spend too much time figuring this out, as the whole point of asking is to save
// time in the copying process. Err on the conservative side if we have to and answer FALSE.
    {
    HAS_INTERFACES me;

    switch(*pFormat)
        {
    case FC_STRUCT:     case FC_CSTRUCT:        case FC_C_CSTRING:      case FC_C_BSTRING:
    case FC_C_SSTRING:  case FC_C_WSTRING:      case FC_CSTRING:        case FC_BSTRING:
    case FC_SSTRING:    case FC_WSTRING:   
    case FC_CHAR:       case FC_BYTE:           case FC_SMALL:          case FC_WCHAR:
    case FC_SHORT:      case FC_LONG:           case FC_HYPER:          case FC_ENUM16:
    case FC_ENUM32:     case FC_DOUBLE:         case FC_FLOAT:
        //
        // No interfaces here!
        //     
        break;

    case FC_IP:
        me.m_cInterfaces = 1;
        break;

    case FC_RP:         case FC_UP:             case FC_OP:
        {
        if (SIMPLE_POINTER(pFormat[1]))
            {
            // No interface pointers 
            }
        else
            {
            PFORMAT_STRING pFormatPointee = pFormat + 2;
            pFormatPointee += *((signed short *)pFormatPointee);
            me.Add(IsShareableType(pFormatPointee));
            }
        }
        break;

    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
        {
        if (pFormat[0] == FC_SMFARRAY)
            pFormat += 2 + sizeof(ushort);
        else
            pFormat += 2 + sizeof(ulong);

        if (pFormat[0] == FC_PP)
            {
            me.Add(IsSharableEmbeddedPointers(pFormat));
            }
        break;
        }

    case FC_CARRAY:     // conformant array
        {
        pFormat += 8;
        if (pFormat[0] == FC_PP)
            {
            if (IsSharableEmbeddedPointers(pFormat).HasAnyInterfaces())
                {
                // Ignore the count: any interfaces means no fixed upper bound since we're conformant
                //
                me.MakeUnbounded();
                }
            }
        break;
        }

    case FC_PSTRUCT:
        {
        pFormat += 4;
        me.Add(IsSharableEmbeddedPointers(pFormat));
        break;
        }

    case FC_BOGUS_ARRAY:  // NYI
    case FC_BOGUS_STRUCT: // NYI
    case FC_USER_MARSHAL: // NYI

    default:
        me.MakeUnbounded();
        break;
        }

    return me;
    }


///////////////////////////////////////////////////////////////////////


inline HAS_INTERFACES CanShareParameter(PMIDL_STUB_DESC pStubDesc, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES& paramAttr)
// Answer whether this parameter is the kind of parameter which can be shared by a child
// frame with its parent. We answer based on the parameter type only; caller is responsible for,
// e.g., checking whether any sort of sharing is allowed at all.
//
// REVIEW: There are probably more cases that can legitimately be shared beyond
// those which we presently call out.
//
    {
    if (paramAttr.IsBasetype)   // Covers simple refs thereto too. All cases are shareable.
        {
        return HAS_INTERFACES();
        }
    else
        {
        PFORMAT_STRING pFormat = pStubDesc->pFormatTypes + param.TypeOffset;
        return IsShareableType(pFormat);
        }
    }

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

struct MD_PARAM
    {
    BOOL                        m_fCanShare;
    BOOL                        m_fMayHaveInterfacePointers;
    };

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

struct MD_METHOD
{
    ///////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////

    ULONG                       m_numberOfParams;       // number of parameters, not counting the receiver
    PPARAM_DESCRIPTION          m_params;
    INTERPRETER_OPT_FLAGS       m_optFlags;
    ULONG                       m_rpcFlags;
    PMIDL_STUB_DESC             m_pStubDesc;
    ULONG                       m_cbPushedByCaller;
    USHORT                      m_cbClientBuffer;
    USHORT                      m_cbServerBuffer;
    ULONG                       m_cbStackInclRet;

    ///////////////////////////////////////

    CALLFRAMEINFO               m_info;
    BOOL                        m_fCanShareAllParameters;

    ///////////////////////////////////////

    const CInterfaceStubHeader* m_pHeader;
    ULONG                       m_iMethod;
    struct MD_INTERFACE*        m_pmdInterface;
    MD_PARAM*                   m_rgParams;
    LPWSTR                      m_wszMethodName;
	PNDR_PROC_HEADER_EXTS       m_pHeaderExts;

    ///////////////////////////////////////////////////////////////
    //
    // Meta data setting
    //
    ///////////////////////////////////////////////////////////////

    void SetMetaData(const CInterfaceStubHeader* pHeader, ULONG iMethod, struct MD_INTERFACE* pmdInterface, TYPEINFOVTBL* pTypeInfoVtbl)
    // Initialize our meta data that has other than to do with parameters
	{
        // Set up the key pieces of base information
        //
        m_pHeader       = pHeader;
        m_iMethod       = iMethod;
        m_pmdInterface  = pmdInterface;
        //
        // Extract the key information from the format string
        //
        PMIDL_SERVER_INFO   pServerInfo      = (PMIDL_SERVER_INFO) m_pHeader->pServerInfo;
                          m_pStubDesc        = pServerInfo->pStubDesc;
        ushort              formatOffset     = pServerInfo->FmtStringOffset[m_iMethod];

        m_numberOfParams = 0;

        if (formatOffset != 0xffff)
            {
            PFORMAT_STRING pFormat;
            INTERPRETER_FLAGS interpreterFlags;
            ULONG procNum;
            PFORMAT_STRING pNewProcDescr;
            ULONG numberOfParamsInclRet;
            
            pFormat = &pServerInfo->ProcString[formatOffset];
            ASSERT(pFormat[0] != 0);  // no explicit handle is permitted, must be implicit

            interpreterFlags = *((PINTERPRETER_FLAGS)&pFormat[1]);
    
            if (interpreterFlags.HasRpcFlags) 
                {
                m_rpcFlags = *(ulong UNALIGNED *)pFormat;
                pFormat += sizeof(ulong);
                }
            else
                m_rpcFlags = 0;

            procNum = *(USHORT*)(&pFormat[2]); ASSERT(procNum == m_iMethod);
            m_cbStackInclRet = *(USHORT*)(&pFormat[4]);

            pNewProcDescr = &pFormat[6]; // additional procedure descriptor info provided in the 'new' interprater
            m_cbClientBuffer = *(USHORT*)&pNewProcDescr[0];
            m_cbServerBuffer = *(USHORT*)&pNewProcDescr[2];
            m_optFlags = *((INTERPRETER_OPT_FLAGS*)&pNewProcDescr[4]);
            numberOfParamsInclRet = pNewProcDescr[5];     // includes return value
            m_params = (PPARAM_DESCRIPTION)(&pNewProcDescr[6]);

			if ( m_optFlags.HasExtensions )
			{
				m_pHeaderExts = (NDR_PROC_HEADER_EXTS *)m_params;
				m_params = (PPARAM_DESCRIPTION)(((uchar*)m_params) + (m_pHeaderExts->Size));
			}
			else 
			{
				m_pHeaderExts = NULL;
			}

            m_numberOfParams = m_optFlags.HasReturn ? numberOfParamsInclRet-1 : numberOfParamsInclRet;
			m_cbPushedByCaller = m_optFlags.HasReturn ? m_params[numberOfParamsInclRet-1].StackOffset : m_cbStackInclRet; // See ::GetStackSize
            }
            
        //
        // And some of the supplementary information
        //
        m_info.iid                      = *m_pHeader->piid;
        m_info.cMethod                  = m_pHeader->DispatchTableCount;
        m_info.iMethod                  = m_iMethod;
        m_info.cParams                  = m_numberOfParams;
        m_info.fHasInValues             = FALSE;
        m_info.fHasInOutValues          = FALSE;
        m_info.fHasOutValues            = FALSE;
        m_info.fDerivesFromIDispatch    = FALSE;
        m_info.cInInterfacesMax         = 0;
        m_info.cInOutInterfacesMax      = 0;
        m_info.cOutInterfacesMax        = 0;
        m_info.cTopLevelInInterfaces    = 0;
        //
        m_fCanShareAllParameters        = TRUE;     // until proven otherwise
        //
        if (pTypeInfoVtbl && pTypeInfoVtbl->m_rgMethodDescs[m_iMethod].m_szMethodName)
            {
            m_wszMethodName = CopyString(pTypeInfoVtbl->m_rgMethodDescs[m_iMethod].m_szMethodName);
            }
        else
            m_wszMethodName = NULL;
	}

    MD_METHOD()
        {
        m_wszMethodName = NULL;
        }

    ~MD_METHOD()
        {
        FreeMemory(m_wszMethodName);
        }

    void SetParamMetaData(MD_PARAM* rgParams)
    // Set our parameter-based meta data. Caller is giving a big-enough array of parameter meta data.
        {
        m_rgParams = rgParams;
        //
        // Iterate through each parameter
        //
        for (ULONG iparam = 0; iparam < m_numberOfParams; iparam++)
            {
            const PARAM_DESCRIPTION& param   = m_params[iparam];
            const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
            //
            const HAS_INTERFACES me = CanShareParameter(m_pStubDesc, param, paramAttr);
            const BOOL fShare = !me.HasAnyInterfaces();
            //
            m_rgParams[iparam].m_fMayHaveInterfacePointers = me.HasAnyInterfaces();
            //
            m_rgParams[iparam].m_fCanShare = fShare;
            m_fCanShareAllParameters = (m_fCanShareAllParameters && fShare);
            //
            if (!!paramAttr.IsIn)        
                {
                if (!!paramAttr.IsOut)
                    {
                    m_info.fHasInOutValues  = TRUE;
                    me.Update(m_info.cInOutInterfacesMax);
                    }
                else
                    {
                    m_info.fHasInValues  = TRUE;
                    me.Update(m_info.cInInterfacesMax);
                    //
                    // Update the top-level in-interface count
                    //
                    PFORMAT_STRING pFormatParam = m_pHeader->pServerInfo->pStubDesc->pFormatTypes + param.TypeOffset;
                    BOOL fIsInterfacePointer = (*pFormatParam == FC_IP);
                    if (fIsInterfacePointer)
                        {
                        m_info.cTopLevelInInterfaces++;
                        }
                    }
                }
            else if (!!paramAttr.IsOut)
                {
                m_info.fHasOutValues  = TRUE;
                me.Update(m_info.cOutInterfacesMax);
                }
            }
        }

    };

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

struct MD_INTERFACE
    {
    ///////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////

    LONG                        m_refs;

    ULONG                       m_cMethods;
    ULONG                       m_cMethodsInBaseInterface;

    MD_METHOD*                  m_rgMethodsAlloc;
    MD_METHOD*                  m_rgMethods;
    MD_PARAM*                   m_rgParams;

    BOOL                        m_fFreeInfoOnRelease;
    BOOL                        m_fDerivesFromIDispatch;
    const CInterfaceStubHeader* m_pHeader;
    LPCSTR                      m_szInterfaceName;

    struct MD_INTERFACE_CACHE*  m_pcache;

    ///////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////

    MD_INTERFACE()
        {
        m_rgMethodsAlloc = NULL;
        m_rgParams       = NULL;
        m_pcache         = NULL;
        
        m_fFreeInfoOnRelease = FALSE;

        m_refs           = 1;
        }

    ULONG AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG Release();

    HRESULT AddToCache(MD_INTERFACE_CACHE* pcache);

private:

    ~MD_INTERFACE()
        {
        delete [] m_rgMethodsAlloc;
        delete [] m_rgParams;

        if (m_fFreeInfoOnRelease)
            {
            delete const_cast<CInterfaceStubHeader*>(m_pHeader);
            FreeMemory(*const_cast<LPSTR*>(&m_szInterfaceName));
            }
        }

public:

    ///////////////////////////////////////////////////////////////
    //
    // Meta data setting
    //
    ///////////////////////////////////////////////////////////////

    HRESULT SetMetaData(TYPEINFOVTBL* pTypeInfoVtbl, const CInterfaceStubHeader* pHeader, LPCSTR szInterfaceName)
    // Set the meta data of this interface given a reference to the header
        {
        HRESULT hr = S_OK;
        //
        m_fFreeInfoOnRelease = (pTypeInfoVtbl != NULL);
        m_pHeader            = pHeader;
        m_szInterfaceName    = szInterfaceName;
        m_fDerivesFromIDispatch = FALSE;
        //
        m_cMethods = m_pHeader->DispatchTableCount;
        
        //
        // Figure out how many methods are in the base interface.
        //
        if (pTypeInfoVtbl)
            {
            if (pTypeInfoVtbl->m_iidBase == IID_IUnknown)
                {
                m_cMethodsInBaseInterface = 3;
                }
            else if (pTypeInfoVtbl->m_iidBase == IID_IDispatch)
                {
                m_cMethodsInBaseInterface = 7;
                }
            else
                {
                m_cMethodsInBaseInterface = 3;
                }
            }
        else
            {
            m_cMethodsInBaseInterface = 3;
            }
        ASSERT(m_cMethodsInBaseInterface >= 3);

        //
        // Allocate and initialize the md for each method
        //
        ULONG cMethods = m_cMethods - m_cMethodsInBaseInterface;
        m_rgMethodsAlloc = new MD_METHOD[cMethods];
        if (m_rgMethodsAlloc)
            {
            m_rgMethods = &m_rgMethodsAlloc[-(LONG)m_cMethodsInBaseInterface];
            for (ULONG iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
                {
                m_rgMethods[iMethod].SetMetaData(m_pHeader, iMethod, this, pTypeInfoVtbl);
                }
            //
            // How many parameters are there, total?
            //
            ULONG cParam = 0;
            for (iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
                {
                cParam += m_rgMethods[iMethod].m_numberOfParams;
                }
            //
            // Allocate and initialize the parameter information
            //
            m_rgParams = new MD_PARAM[cParam];
            if (m_rgParams)
                {
                cParam = 0;
                for (iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
                    {
                    m_rgMethods[iMethod].SetParamMetaData(&m_rgParams[cParam]);
                    cParam += m_rgMethods[iMethod].m_numberOfParams;
                    }
                }
            else
                hr = E_OUTOFMEMORY;
            }
        else
            hr = E_OUTOFMEMORY;

        return hr;
        }

    HRESULT SetDerivesFromIDispatch(BOOL fDerivesFromIDispatch)
        {
        m_fDerivesFromIDispatch = fDerivesFromIDispatch;

        for (ULONG iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
            {
            m_rgMethods[iMethod].m_info.fDerivesFromIDispatch = fDerivesFromIDispatch;
            }
        return S_OK;
        }
    };


///////////////////////////////////////////////////////////////////////////
//
// MD_INTERFACE_CACHE
//
///////////////////////////////////////////////////////////////////////////

//
// NOTE: The constructor of this object can throw an exception, because
//       MAP_SHARED contains an XSLOCK, and, well.... look at the comment
//       on MAP_SHARED in lookaside.h.
//
struct MD_INTERFACE_CACHE : MAP_SHARED<PagedPool, MAP_KEY_GUID, MD_INTERFACE*>
    {
    /////////////////////////////////////////////////
    //
    // Construction & destruction
    //
    /////////////////////////////////////////////////

    MD_INTERFACE_CACHE()
        {
        }

    ~MD_INTERFACE_CACHE()
        {
		//
        // Before the cache is destroyed, all interceptors therein should be
        // too, which will remove themselves from us.
        //
		// ASSERT(0 == Size() && "likely leak: interceptor support dll unloading while interceptors still exist");
        }

    /////////////////////////////////////////////////
    //
    // Operations
    //
    /////////////////////////////////////////////////

    HRESULT FindExisting(REFIID iid, MD_INTERFACE** ppmdInterface)
        {
        HRESULT hr = S_OK;
        *ppmdInterface = NULL;
        
        LockShared();

        if (Lookup(iid, ppmdInterface))
            {
            (*ppmdInterface)->AddRef(); // give caller his own reference
            }
        else
            hr = E_NOINTERFACE;

        ReleaseLock();

        return hr;
        }

    };

inline HRESULT MD_INTERFACE::AddToCache(MD_INTERFACE_CACHE* pcache)
// Add us into the indicated cache. We'd better not already be in one
    {
    HRESULT hr = S_OK;
    ASSERT(NULL == m_pcache);
    ASSERT(pcache);

    pcache->LockExclusive();

    const IID& iid = *m_pHeader->piid;
    ASSERT(iid != GUID_NULL);
    ASSERT(!pcache->IncludesKey(iid));

    if (pcache->SetAt(iid, this))
        {
        m_pcache = pcache;
        }
    else
        hr = E_OUTOFMEMORY;

    pcache->ReleaseLock();
    return hr;
    }

inline ULONG MD_INTERFACE::Release()  
// Release a MD_INTERFACE. Careful: if we're in the cache, then we could be dug out 
// from the cache to get more references.
    {
    // NOTE:
    //
    // This code is WRONG if m_pcache can change out from underneath us. But it can't
    // in current usage because the cache/no-cache decision is always made as part of
    // the creation logic, which is before another independent thread can get a handle
    // on us.
    //
    // If this ceases to be true, then we can deal with it by stealing a bit from the ref count word 
    // for the 'am in cache' decistion and interlocked operations to update the ref count and this 
    // bit together.
    //
    if (m_pcache)
        {
        // We're in a cache. Get us out of there carefully.
        //
        LONG crefs;
        //
        for (;;)
            {
            crefs = m_refs;
            //
            if (crefs > 1)
                {
                // There is at least one non-cache reference out there. We definitely won't
                // be poofing if we release with that condition holding
                //
                if (crefs == InterlockedCompareExchange(&m_refs, (crefs - 1), crefs))
                    {
				    return crefs - 1;
                    }
                else
                    {
                    // Someone diddled with the ref count while we weren't looking. Go around and try again
                    }
                }
            else
                {
                MD_INTERFACE_CACHE* pcache = m_pcache;  ASSERT(pcache);
                //
                pcache->LockExclusive();
                //
                crefs = InterlockedDecrement(&m_refs);
                if (0 == crefs)
                    {
                    // The last public reference just went away, and, because the cache is locked, no
                    // more can appear. Nuke us!
                    //
                    const IID& iid = *m_pHeader->piid;
                    ASSERT(pcache->IncludesKey(iid));
                    //
                    pcache->RemoveKey(iid);
                    m_pcache = NULL;
                    //
                    delete this;
                    }
                //
                pcache->ReleaseLock();
                //
                return crefs;
                }
			#ifdef _X86_
    	        _asm 
        	    {
            	    _emit 0xF3
	                _emit 0x90
    	        };
			#endif
            }
        }
    else
        {
        // We are getting released, yet we have yet to ever be put into the cache. Just
        // the normal, simple case. 
        //
        long crefs = InterlockedDecrement(&m_refs); 
        if (crefs == 0)
            {
            delete this;
            }
        return crefs;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\invoke.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Invoke.h
//

//+---------------------------------------------------------------------------
//
//  Function:   REGISTER_TYPE Invoke(MANAGER_FUNCTION pFunction, 
//                                   REGISTER_TYPE   *pArgumentList,
//                                   ULONG            cArguments);
//
//  Synopsis:   Given a function pointer and an argument list, Invoke builds 
//              a stack frame and calls the function.
//
//  Arguments:  pFunction     = Pointer to the function to be called.
//
//              pArgumentList = Pointer to the buffer containing the function 
//                              parameters.
//
//              cArguments    = The size of the argument list in REGISTER_TYPEs.
//
//----------------------------------------------------------------------------

typedef _int64 (__RPC_API * MANAGER_FUNCTION)(void);

#if defined(_X86_)

inline REGISTER_TYPE Invoke(MANAGER_FUNCTION pFunction, REGISTER_TYPE *pArgumentList, ULONG cArguments)
    {
    // Figure out the function which is to be invoked
    //
    typedef HRESULT (__stdcall* PFN)(void);
    PFN pfnToCall = (PFN)pFunction;
    //
    // Allocate space for the callee's stack frame
    //
    ULONG cbPushedByCaller = cArguments * sizeof(REGISTER_TYPE);
    PVOID pvArgsCopy = _alloca(cbPushedByCaller);
    //
    // Copy the caller stack frame to the top of the current stack.
    // This code assumes (dangerously) that the alloca'd copy of the
    // actual arguments is at [esp].
    //
    memcpy(pvArgsCopy, pArgumentList, cbPushedByCaller);
    //
    // Receiver is already pushed. Carry out the call!
    //
    HRESULT hrReturnValue = (*pfnToCall)();

    return (REGISTER_TYPE)hrReturnValue;
    }

#endif

#if defined(_AMD64_)

extern "C"
REGISTER_TYPE Invoke(MANAGER_FUNCTION pFunction, REGISTER_TYPE *pvArgs, ULONG cArguments);

#endif

#ifdef IA64

inline REGISTER_TYPE Invoke(MANAGER_FUNCTION pFunction, REGISTER_TYPE *pvArgs, ULONG cArguments)
    {
    // Figure out the function which is to be invoked
    //
    typedef HRESULT (*const PFN)      (__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
    typedef HRESULT (***INTERFACE_PFN)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
    PFN pfnToCall = (PFN)pFunction;

    const ULONG cbPushedByCaller = cArguments * sizeof(REGISTER_TYPE);
        const DWORD cqArgs = cbPushedByCaller / 8; // no. of arguments (each a quadword)

        // Initialize fp[] to address the six floating point argument registers
        // and a[] to address the six integer argument registers passed
    //
        double *const fp = (double*)((__int64*)pvArgs - 8);
        __int64 *const a = (__int64*)pvArgs;

        // Ensure there is space for any args past the eigth arg.
    //
        DWORD cbExtra = cbPushedByCaller > 64 ? cbPushedByCaller - 64 : 0;
        pvGlobalSideEffect = alloca(cbExtra);

        // Copy args [8..] to the stack, at 0(sp), 8(sp), ... . Note we copy them in first 
    // to last order so that stack faults (if any) occur in the right order.
    //
	__int64 *const sp = (__int64*)getSP (0, 0, 0, 0, 0, 0, 0, 0);
	for (DWORD iarg = cqArgs - 1; iarg >= 8; --iarg)
        {
                sp[iarg - 8] = a[iarg];
        }

        // Establish F8-F15 with the original caller's fp arguments
    //
        establishF8_15(fp[0], fp[1], fp[2], fp[3], fp[4], fp[5], fp[6], fp[7]);

        // Call method, establishing first 8 regs with the original caller's integer arguments.
    //
    HRESULT hrReturnValue = (*pfnToCall)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);

    return (REGISTER_TYPE)hrReturnValue;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//
#ifndef __STDPCH_H__
#define __STDPCH_H__

//JohnDoty:  Pulled out KernelMode stuff... 

//
// All routines we need that would normally be found in oleaut32.dll
// need to be implemented locally here, either in full or in such a
// way so as to dyna-load OLEAUT32.DLL
//
#define _OLEAUT32_


#include <stdio.h>
#include <stdarg.h>
#include <memory.h>
#include <malloc.h>

//JohnDoty:  We actually WANT to be WIN32_LEAN_AND_MEAN.  If we don't
//           then windows.h pulls in rpcndr.h from the publics.  This would
//           be fine if we weren't dependent on an old and brittle copy of
//           the same.
//#undef WIN32_LEAN_AND_MEAN

extern "C" {

//JohnDoty:  Removed dependency on kernel headers
//#include "ntos.h"
//#include "fsrtl.h"

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#define NT_INCLUDED

#include "windows.h"
#include "objbase.h"

#include "rpcndr.h"

#include "imagehlp.h"
#include "ocidl.h"
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\stdpch.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.cpp
//
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\oleautglue.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// oleautglue.h
//

#ifndef __OLEAUTGLUE_H__
#define __OLEAUTGLUE_H__

typedef HRESULT (STDCALL* LOADTYPELIB_ROUTINE)(LPCWSTR szFile, ITypeLib** pptlib);
typedef HRESULT (STDCALL* LOADTYPELIBEX_ROUTINE)(LPCWSTR szFile, REGKIND, ITypeLib** pptlib);
typedef HRESULT (STDCALL* LOADREGTYPELIB_ROUTINE)(REFGUID libId, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib** pptlib);

typedef ULONG (STDCALL* PFNSAFEARRAY_SIZE)      (ULONG* pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray, const IID *piid);
typedef BYTE* (STDCALL* PFNSAFEARRAY_MARSHAL)   (ULONG* pFlags, BYTE* pBuffer, LPSAFEARRAY * ppSafeArray,const IID *piid);
typedef BYTE* (STDCALL* PFNSAFEARRAY_UNMARSHAL) (ULONG * pFlags,BYTE * pBuffer,LPSAFEARRAY * ppSafeArray,const IID *piid);
    
typedef BSTR    (STDCALL* PFNSYSALLOCSTRING)           (LPCWSTR);
typedef BSTR    (STDCALL* PFNSYSALLOCSTRINGLEN)        (LPCWSTR wsz, UINT);
typedef BSTR    (STDCALL* PFNSYSALLOCSTRINGBYTELEN)    (LPCSTR psz, UINT len);
typedef INT     (STDCALL* PFNSYSREALLOCSTRING)         (BSTR*, LPCWSTR);
typedef INT     (STDCALL* PFNSYSREALLOCSTRINGLEN)      (BSTR*, LPCWSTR, UINT);
typedef void    (STDCALL* PFNSYSFREESTRING)            (LPWSTR);
typedef UINT    (STDCALL* PFNSYSSTRINGBYTELEN)         (BSTR);

typedef HRESULT (STDCALL* PFNSAFEARRAYDESTROY)         (SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYDESTROYDATA)     (SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYDESTROYDESCRIPTOR)(SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYALLOCDATA)       (SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYALLOCDESCRIPTOR) (UINT, SAFEARRAY**);
typedef HRESULT (STDCALL* PFNSAFEARRAYALLOCDESCRIPTOREX)(VARTYPE, UINT, SAFEARRAY**);
typedef HRESULT (STDCALL* PFNSAFEARRAYCOPYDATA)        (SAFEARRAY*, SAFEARRAY*);

typedef HRESULT (STDCALL* PFNVARIANTCLEAR)             (VARIANTARG*);
typedef HRESULT (STDCALL* PFNVARIANTCOPY)              (VARIANTARG*, VARIANTARG*);


struct OLEAUTOMATION_FUNCTIONS
{
#ifndef KERNELMODE
    //////////////////////////////////////////////////////////////////////
    //
    // User mode OLEAUTOMATION_FUNCTIONS
    //
  private:
    HINSTANCE                          hOleAut32;
    BOOL                               fProcAddressesLoaded;
    
    USER_MARSHAL_SIZING_ROUTINE        pfnLPSAFEARRAY_UserSize;
    USER_MARSHAL_MARSHALLING_ROUTINE   pfnLPSAFEARRAY_UserMarshal;
    USER_MARSHAL_UNMARSHALLING_ROUTINE pfnLPSAFEARRAY_UserUnmarshal;
    LOADTYPELIB_ROUTINE                pfnLoadTypeLib;
    LOADTYPELIBEX_ROUTINE              pfnLoadTypeLibEx;
    LOADREGTYPELIB_ROUTINE             pfnLoadRegTypeLib;
    PFNSAFEARRAY_SIZE                  pfnLPSAFEARRAY_Size;
    PFNSAFEARRAY_MARSHAL               pfnLPSAFEARRAY_Marshal;
    PFNSAFEARRAY_UNMARSHAL             pfnLPSAFEARRAY_Unmarshal;
    PFNSYSALLOCSTRING                  pfnSysAllocString;
    PFNSYSALLOCSTRINGLEN               pfnSysAllocStringLen;
    PFNSYSALLOCSTRINGBYTELEN           pfnSysAllocStringByteLen;
    PFNSYSREALLOCSTRING                pfnSysReAllocString;
    PFNSYSREALLOCSTRINGLEN             pfnSysReAllocStringLen;
    PFNSYSFREESTRING                   pfnSysFreeString;
    PFNSYSSTRINGBYTELEN                pfnSysStringByteLen;
    
    PFNSAFEARRAYDESTROY                pfnSafeArrayDestroy;
    PFNSAFEARRAYDESTROYDATA            pfnSafeArrayDestroyData;
    PFNSAFEARRAYDESTROYDESCRIPTOR      pfnSafeArrayDestroyDescriptor;
    PFNSAFEARRAYALLOCDATA              pfnSafeArrayAllocData;
    PFNSAFEARRAYALLOCDESCRIPTOR        pfnSafeArrayAllocDescriptor;
    PFNSAFEARRAYALLOCDESCRIPTOREX      pfnSafeArrayAllocDescriptorEx;
    PFNSAFEARRAYCOPYDATA               pfnSafeArrayCopyData;

    PFNVARIANTCLEAR                    pfnVariantClear;
    PFNVARIANTCOPY                     pfnVariantCopy;

    USER_MARSHAL_ROUTINE_QUADRUPLE     UserMarshalRoutines[3];

    enum {
        UserMarshal_Index_BSTR = 0,
        UserMarshal_Index_VARIANT,
        UserMarshal_Index_SafeArray,
    };

    void    Load();
    HRESULT GetProc(HRESULT hr, LPCSTR szProcName, PVOID* ppfn);
    HRESULT LoadOleAut32();

    static ULONG SafeArraySize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray);
    static BYTE* SafeArrayMarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray);
    static BYTE* SafeArrayUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray);

  public:

    USER_MARSHAL_SIZING_ROUTINE         get_pfnLPSAFEARRAY_UserSize()       { Load(); return pfnLPSAFEARRAY_UserSize;       }
    USER_MARSHAL_MARSHALLING_ROUTINE    get_pfnLPSAFEARRAY_UserMarshal()    { Load(); return pfnLPSAFEARRAY_UserMarshal;    }
    USER_MARSHAL_UNMARSHALLING_ROUTINE  get_pfnLPSAFEARRAY_UserUnmarshal()  { Load(); return pfnLPSAFEARRAY_UserUnmarshal;  }
    LOADTYPELIB_ROUTINE                 get_pfnLoadTypeLib()                { Load(); return pfnLoadTypeLib;                }
    LOADTYPELIBEX_ROUTINE               get_pfnLoadTypeLibEx()              { Load(); return pfnLoadTypeLibEx;              }
    LOADREGTYPELIB_ROUTINE              get_pfnLoadRegTypeLib()             { Load(); return pfnLoadRegTypeLib;             }
    PFNSAFEARRAY_SIZE                   get_pfnLPSAFEARRAY_Size()           { Load(); return pfnLPSAFEARRAY_Size;           }
    PFNSAFEARRAY_MARSHAL                get_pfnLPSAFEARRAY_Marshal()        { Load(); return pfnLPSAFEARRAY_Marshal;        }
    PFNSAFEARRAY_UNMARSHAL              get_pfnLPSAFEARRAY_Unmarshal()      { Load(); return pfnLPSAFEARRAY_Unmarshal;      }

    USER_MARSHAL_SIZING_ROUTINE         get_BSTR_UserSize()                 { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnBufferSize; }
    USER_MARSHAL_MARSHALLING_ROUTINE    get_BSTR_UserMarshal()              { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnMarshall;   }    
    USER_MARSHAL_UNMARSHALLING_ROUTINE  get_BSTR_UserUnmarshal()            { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnUnmarshall; }
    USER_MARSHAL_FREEING_ROUTINE        get_BSTR_UserFree()                 { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnFree;       }

    USER_MARSHAL_SIZING_ROUTINE         get_VARIANT_UserSize()              { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnBufferSize; }
    USER_MARSHAL_MARSHALLING_ROUTINE    get_VARIANT_UserMarshal()           { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnMarshall;   }    
    USER_MARSHAL_UNMARSHALLING_ROUTINE  get_VARIANT_UserUnmarshal()         { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnUnmarshall; }
    USER_MARSHAL_FREEING_ROUTINE        get_VARIANT_UserFree()              { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnFree;       }

    USER_MARSHAL_FREEING_ROUTINE        get_LPSAFEARRAY_UserFree()          { Load(); return UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnFree;     }

    USER_MARSHAL_ROUTINE_QUADRUPLE*     get_UserMarshalRoutines()           { Load(); return &UserMarshalRoutines[0]; }

    PFNSYSALLOCSTRING                   get_SysAllocString()                { Load(); return pfnSysAllocString;        }
    PFNSYSALLOCSTRINGLEN                get_SysAllocStringLen()             { Load(); return pfnSysAllocStringLen;     }
    PFNSYSALLOCSTRINGBYTELEN            get_SysAllocStringByteLen()         { Load(); return pfnSysAllocStringByteLen; }
    PFNSYSREALLOCSTRING                 get_SysReAllocString()              { Load(); return pfnSysReAllocString;      }
    PFNSYSREALLOCSTRINGLEN              get_SysReAllocStringLen()           { Load(); return pfnSysReAllocStringLen;   }
    PFNSYSFREESTRING                    get_SysFreeString()                 { Load(); return pfnSysFreeString;         }
    PFNSYSSTRINGBYTELEN                 get_SysStringByteLen()              { Load(); return pfnSysStringByteLen;      }

    PFNSAFEARRAYDESTROY                 get_SafeArrayDestroy()              { Load(); return pfnSafeArrayDestroy;      }
    PFNSAFEARRAYDESTROYDATA             get_SafeArrayDestroyData()          { Load(); return pfnSafeArrayDestroyData;  }
    PFNSAFEARRAYDESTROYDESCRIPTOR       get_SafeArrayDestroyDescriptor()    { Load(); return pfnSafeArrayDestroyDescriptor; }
    PFNSAFEARRAYALLOCDESCRIPTOR         get_SafeArrayAllocDescriptor()      { Load(); return pfnSafeArrayAllocDescriptor; }
    PFNSAFEARRAYALLOCDESCRIPTOREX       get_SafeArrayAllocDescriptorEx()    { Load(); return pfnSafeArrayAllocDescriptorEx; }
    PFNSAFEARRAYALLOCDATA               get_SafeArrayAllocData()            { Load(); return pfnSafeArrayAllocData;    }
    PFNSAFEARRAYCOPYDATA                get_SafeArrayCopyData()             { Load(); return pfnSafeArrayCopyData;     }

    PFNVARIANTCLEAR                     get_VariantClear()                  { Load(); return pfnVariantClear;          }
    PFNVARIANTCOPY                      get_VariantCopy()                   { Load(); return pfnVariantCopy;           }

    OLEAUTOMATION_FUNCTIONS()
    {
        Zero(this); // no vtables, so this is ok
        UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnBufferSize = (USER_MARSHAL_SIZING_ROUTINE)SafeArraySize;
        UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnMarshall   = (USER_MARSHAL_MARSHALLING_ROUTINE)SafeArrayMarshal;
        UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnUnmarshall = (USER_MARSHAL_UNMARSHALLING_ROUTINE)SafeArrayUnmarshal;
    }

    ~OLEAUTOMATION_FUNCTIONS()
    {
        if (hOleAut32)
        {
            FreeLibrary(hOleAut32);
            hOleAut32 = NULL;
        }
    }

#else
    //////////////////////////////////////////////////////////////////////
    //
    // Kernel mode OLEAUTOMATION_FUNCTIONS

    void Load() { }

    USER_MARSHAL_FREEING_ROUTINE get_VARIANT_UserFree()      { return (USER_MARSHAL_FREEING_ROUTINE) VARIANT_UserFree;        }
    USER_MARSHAL_FREEING_ROUTINE get_BSTR_UserFree()         { return (USER_MARSHAL_FREEING_ROUTINE) BSTR_UserFree;           }
    USER_MARSHAL_FREEING_ROUTINE get_LPSAFEARRAY_UserFree()  { return (USER_MARSHAL_FREEING_ROUTINE) LPSAFEARRAY_UserFree;    }

    PFNSYSALLOCSTRING                   get_SysAllocString()                { return SysAllocString;                          }
    PFNSYSALLOCSTRINGLEN                get_SysAllocStringLen()             { return SysAllocStringLen;                       }
    PFNSYSALLOCSTRINGBYTELEN            get_SysAllocStringByteLen()         { return SysAllocStringByteLen;                   }
    PFNSYSFREESTRING                    get_SysFreeString()                 { return SysFreeString;                           }
    PFNSYSSTRINGBYTELEN                 get_SysStringByteLen()              { return SysStringByteLen;                        }
    PFNVARIANTCLEAR                     get_VariantClear()                  { return VariantClear;                            }
    PFNSAFEARRAYDESTROYDESCRIPTOR       get_SafeArrayDestroyDescriptor()    { return SafeArrayDestroyDescriptor;              }

#endif // #ifndef KERNELMODE

    //////////////////////////////////////////////////////////////////////
    //
    // OLEAUTOMATION_FUNCTIONS - both modes
  private:

    BOOL IsEqualPfn(PVOID pfnImported, PVOID pfnReal)
        // Answer as to whether these two PFNs are equal. pfnReal is known to be the
        // actual start of the routine (since it came from a GetProcAddress). pfnImported
        // may be the real start of the routine, or it may be the address of an import
        // descriptor to the routine.
        //
        // For example, in x86, pfnImported may be &BSTR_UserFree, where that's actually:
        //
        // _BSTR_UserFree@8:
        // 00C92E42 FF 25 80 20 C9 00    jmp         dword ptr [__imp__BSTR_UserFree@8(0x00c92080)]
        //
        // On ALPHA, the code sequence looks something like:
        //
        //  BSTR_UserFree:
        //  00000000: 277F0000 ldah          t12,0
        //  00000004: A37B0000 ldl           t12,0(t12)
        //  00000008: 6BFB0000 jmp           zero,(t12),0
        //
    {
        if (pfnImported == pfnReal)
            return TRUE;
        else
        {
            __try
                {
                    typedef void (__stdcall*PFN)(void*);
#pragma pack(push, 1)
#if defined(_X86_)
      
                    struct THUNK
                    {
                        BYTE jmp[2]; PFN* ppfn;                    
                    };

                    THUNK* pThunk = (THUNK*)pfnImported;

                    if (pThunk->jmp[0] == 0xFF) // avoid AVs in debugger (harmless, but annoying)
                    {
                        return *pThunk->ppfn == (PFN)pfnReal;
                    }
                    else
                    {
                        return FALSE;
                    }

#elif defined(_AMD64_)

                    struct THUNK
                    {
                        BYTE jmp[2]; PFN* ppfn;                    
                    };

                    THUNK* pThunk = (THUNK*)pfnImported;

                    // BUGBUG this won't be correct for amd64

                    if (pThunk->jmp[0] == 0xFF) // avoid AVs in debugger (harmless, but annoying)
                    {
                        return *pThunk->ppfn == (PFN)pfnReal;
                    }
                    else
                    {
                        return FALSE;
                    }
                    return FALSE;
                
#elif defined(IA64)
                    
                    // BUGBUG needs to be implemented
                    return FALSE;

#else
#error Unknown processor
                    return FALSE;

#endif
#pragma pack(pop)
                }

            __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return FALSE;
                }
        }
    }

  public:

    BOOL IsVariant(const USER_MARSHAL_ROUTINE_QUADRUPLE& quad)
    {
        if (quad.pfnFree == (USER_MARSHAL_FREEING_ROUTINE)VARIANT_UserFree)
        {
            return TRUE;
        }
#ifndef KERNELMODE
        else
        {
            PVOID pfnInOleAut = get_VARIANT_UserFree();
            return IsEqualPfn(quad.pfnFree, pfnInOleAut);
        }
#endif
        return FALSE;
    }
    BOOL IsBSTR(const USER_MARSHAL_ROUTINE_QUADRUPLE& quad)
    {
        if (quad.pfnFree == (USER_MARSHAL_FREEING_ROUTINE)BSTR_UserFree)
        {
            return TRUE;
        }
#ifndef KERNELMODE
        else
        {
            PVOID pfnInOleAut = get_BSTR_UserFree();
            return IsEqualPfn(quad.pfnFree, pfnInOleAut);
        }
#endif
        return FALSE;
    }
    BOOL IsSAFEARRAY(const USER_MARSHAL_ROUTINE_QUADRUPLE& quad)
    {
        if (quad.pfnFree == (USER_MARSHAL_FREEING_ROUTINE)LPSAFEARRAY_UserFree)
        {
            return TRUE;
        }
#ifndef KERNELMODE
        else
        {
            PVOID pfnInOleAut = get_LPSAFEARRAY_UserFree();
            return IsEqualPfn(quad.pfnFree, pfnInOleAut);
        }
#endif
        return FALSE;
    }

    
};


extern OLEAUTOMATION_FUNCTIONS g_oa;


/////////////////////////////////////////////////////////////////////////////////////
//
// Functions that do some type-specific walking.
//
// REVIEW: The probing behaviour implied by this class has yet to be fully implemented.
//
/////////////////////////////////////////////////////////////////////////////////////




inline void VariantInit(VARIANT* pvar)
{
    V_VT(pvar) = VT_EMPTY;
}


struct OAUTIL
{
#ifdef KERNELMODE
    BOOL   m_fProbeRead;
    BOOL   m_fProbeWrite;
    enum { m_fKernelMode = TRUE  };
#else
    enum { m_fProbeRead  = FALSE, m_fProbeWrite = FALSE };
    enum { m_fKernelMode = FALSE };
#endif

    ICallFrameWalker* m_pWalkerCopy;
    ICallFrameWalker* m_pWalkerFree;
    ICallFrameWalker* m_pWalkerWalk;
    BOOL              m_fWorkingOnInParam;
    BOOL              m_fWorkingOnOutParam;
        BOOL              m_fDoNotWalkInterfaces;


    ///////////////////////////////////////////////////////////////////

    OAUTIL(BOOL fProbeRead, BOOL fProbeWrite, 
           ICallFrameWalker* pWalkerCopy, ICallFrameWalker* pWalkerFree, ICallFrameWalker* pWalkerWalk, 
           BOOL fIn, BOOL fOut)
    {
#ifdef KERNELMODE
        m_fProbeRead  = fProbeRead;
        m_fProbeWrite = fProbeRead;
#endif

        m_pWalkerWalk = pWalkerWalk; if (m_pWalkerWalk) m_pWalkerWalk->AddRef();
        m_pWalkerFree = pWalkerFree; if (m_pWalkerFree) m_pWalkerFree->AddRef();
        m_pWalkerCopy = pWalkerCopy; if (m_pWalkerCopy) m_pWalkerCopy->AddRef();
        m_fWorkingOnInParam  = fIn;
        m_fWorkingOnOutParam = fOut;
        m_fDoNotWalkInterfaces = FALSE;
    }

    ~OAUTIL()
    {
        ::Release(m_pWalkerCopy);
        ::Release(m_pWalkerFree);
        ::Release(m_pWalkerWalk);
    }

    HRESULT Walk(DWORD walkWhat, DISPPARAMS* pdispParams);
    HRESULT Walk(VARIANTARG* pv);
    HRESULT Walk(SAFEARRAY* psa);
    HRESULT Walk(IRecordInfo* pinfo, PVOID pvData);

    ///////////////////////////////////////////////////////////////////

        HRESULT SafeArrayClear (SAFEARRAY *psa, BOOL fWeOwnByRefs);

    HRESULT VariantClear(VARIANTARG * pvarg, BOOL fWeOwnByrefs = FALSE);
    HRESULT VariantCopy (VARIANTARG * pvargDest, VARIANTARG * pvargSrc, BOOL fNewFrame = FALSE);

    ///////////////////////////////////////////////////////////////////

    BSTR  SysAllocString(LPCWSTR);
    BSTR  SysAllocStringLen(LPCWSTR, UINT);
    BSTR  SysAllocStringByteLen(LPCSTR psz, UINT cb);
    INT   SysReAllocString(BSTR *, LPCWSTR);
    INT   SysReAllocStringLen(BSTR *, LPCWSTR, UINT);
    void  SysFreeString(BSTR);
    UINT  SysStringLen(BSTR);

    UINT  SysStringByteLen(BSTR bstr);

    BSTR  Copy(BSTR bstr)
    {
        return SysAllocStringByteLen((LPCSTR)bstr, SysStringByteLen(bstr));
    }

    void SetWalkInterfaces(BOOL fWalkInterfaces)
    {
        m_fDoNotWalkInterfaces = !fWalkInterfaces;
    }

    BOOL WalkInterfaces()
    {
        return !m_fDoNotWalkInterfaces;
    }


    void SetWorkingOnIn(BOOL fIn)
    {
        m_fWorkingOnInParam = fIn;
    }

    void SetWorkingOnOut(BOOL fOut)
    {
        m_fWorkingOnOutParam = fOut;
    }

    ///////////////////////////////////////////////////////////////////

    template <class INTERFACE_TYPE> HRESULT WalkInterface(INTERFACE_TYPE** ppt, ICallFrameWalker* pWalker)
    {
        if (pWalker)
        {
            return pWalker->OnWalkInterface(__uuidof(INTERFACE_TYPE), (void**)ppt, m_fWorkingOnInParam, m_fWorkingOnOutParam);
        }
        return S_OK;
    }

    template <class INTERFACE_TYPE> HRESULT WalkInterface(INTERFACE_TYPE** ppt)
    {
        return WalkInterface(ppt, m_pWalkerWalk);
    }

    template <class INTERFACE_TYPE> HRESULT AddRefInterface(INTERFACE_TYPE*& refpt)
    {
        if (m_pWalkerCopy)
        {
            return WalkInterface(&refpt, m_pWalkerCopy);
        }
        else
        {
            if (refpt) 
            {
                refpt->AddRef();
            }
            return S_OK;
        }
    }
    template <class INTERFACE_TYPE> HRESULT ReleaseInterface(INTERFACE_TYPE*& refpt)
    {
        if (m_pWalkerFree)
        {
            return WalkInterface(&refpt, m_pWalkerFree);
        }
        else
        {
            if (refpt) 
            { 
                refpt->Release();
            }
            return S_OK; 
        }
        refpt = NULL;
    }


    ///////////////////////////////////////////////////////////////////

    HRESULT SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut);
    HRESULT SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget);
    HRESULT SafeArrayDestroyData(SAFEARRAY * psa);
    HRESULT SafeArrayDestroy(SAFEARRAY* psa);

#ifdef KERNELMODE
    HRESULT SafeArrayDestroyData(SAFEARRAY* psa, BOOL fRelease);
    HRESULT SafeArrayDestroy(SAFEARRAY* psa, BOOL fRelease);
    void    ReleaseResources(SAFEARRAY* psa, void* pv, ULONG cbSize, USHORT fFeatures, ULONG cbElement);
#endif

    HRESULT SafeArrayLock(SAFEARRAY* psa)
    {
        if (psa)
        {
            ++psa->cLocks;
            if (psa->cLocks == 0)
            {
                --psa->cLocks;
                return E_UNEXPECTED;
            }
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT SafeArrayUnlock(SAFEARRAY* psa)
    {
        if (psa)
        {
            if (psa->cLocks == 0)
            {
                return E_UNEXPECTED;
            }
            --psa->cLocks;
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

  private:

    HRESULT Walk(SAFEARRAY* psa, PVOID pvData);
    HRESULT Walk(SAFEARRAY* psa, IRecordInfo*, ULONG iDim, PVOID pvDataIn, PVOID* ppvDataOut);
};

extern OAUTIL g_oaUtil;


#endif // #ifndef __OLEAUTGLUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\sources.inc ===
#
# Sources that build CallFrame{Dll,Sys,Static}.Lib
#

!include ..\..\sources.txf

TARGETPATH=$(TARGETVIPBIN)

PRECOMPILED_INCLUDE         =..\stdpch.h
PRECOMPILED_CXX             =1
PRECOMPILED_SOURCEFILE      =..\stdpch.cpp
VIPPERFLIBS                 =
VIPTHUNKLIBS                =
EXCEPTION_HANDLING          =$(SEHONLY)
VIPER_MIDL_FLAGS            =$(MIDL_EVERYTHING)
PASS0_HEADERDIR             =..
PASS0_SOURCEDIR             =..
MIDL_UUIDDIR                =..

!undef USE_INCREMENTAL_COMPILING

SOURCES=                        \
    ..\Interceptor.cpp          \
    ..\CallFrame.cpp            \
    ..\CallFrameworker.cpp      \
    ..\oautil.cpp               \
    ..\cLegInterface.cpp        \
    ..\callframeinternal.c      \
    ..\rpcallas.cpp             \
    ..\typeinfo.cpp             \
    ..\InterfaceStub.cpp        \
    ..\InterfaceProxy.cpp       \
    ..\StublessClient.cpp       \
    ..\Forwarder.cpp            \
    ..\ComPsRegistration.cpp    \
    ..\ComPs.cpp                \
    ..\cltcall.cpp              \
    ..\srvcall.cpp              \



AMD64_SOURCES=                  \
     ..\amd64\forwardamd64.asm  \
     ..\amd64\stubless.asm      \
     ..\getsp.cpp

IA64_SOURCES=                   \
    ..\IA64\extract.s           \
    ..\IA64\forwarderIA64.s     \
    ..\getsp.cpp

USER_INCLUDES=..;..\inc;..\..;..\..\inc;..\..\..;..\..\..\inc; \
              $(PROJECT_ROOT)\inc\ndrshared;..\idl\$(O);..\

USER_C_FLAGS = $(USER_C_FLAGS) -DNTENV /DENTRY_PREFIX=CallFrameInternal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\rpcallas.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/*** 
*rpcallas.cpp
*
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*  [call_as] wrapper functions for OA interfaces
*
*Revision History:
*
* [00]  18-Jan-96 Rong Chen    (rongc):  Created
* [01]  21-Jul-98 Bob Atkinson (bobatk): Stole from Ole Automation tree & adapted
*
*****************************************************************************/

#include "stdpch.h"
#include "common.h"

#include "ndrclassic.h"
#include "txfrpcproxy.h"
#include "typeinfo.h"
#include "tiutil.h"

#ifndef PLONG_LV_CAST
#define PLONG_LV_CAST        *(long __RPC_FAR * __RPC_FAR *)&
#endif

#ifndef PULONG_LV_CAST
#define PULONG_LV_CAST       *(ulong __RPC_FAR * __RPC_FAR *)&
#endif

//+-------------------------------------------------------------------------
//
//  Functions: Local helper routines
//
//--------------------------------------------------------------------------

HRESULT InvokeProxyPreCheck(DWORD * pFlags, DISPPARAMS * pDispParams,
                            VARIANT * rgVarArg, UINT * pcVarRef,
                            UINT ** prgVarRefIdx, VARIANT ** prgVarRef,
                            VARIANT ** ppVarResult)
    {
    *pcVarRef = 0;

    if (pDispParams == NULL || pDispParams->cNamedArgs > pDispParams->cArgs)
        return E_INVALIDARG;

    *pFlags &= (DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF);

    UINT cArgs = pDispParams->cArgs;
    if (cArgs == 0) 
        {
        if (*pFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
            return E_INVALIDARG;
        }
    else 
        {
        if (pDispParams->rgvarg == NULL)
            return E_INVALIDARG;

        if (pDispParams->cNamedArgs != 0 && pDispParams->rgdispidNamedArgs == NULL)
            return E_INVALIDARG;

        if (*pFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) 
            {
            *ppVarResult = NULL;    // ignore VARIANT result parameter
            }

        VARIANT * pVariant = pDispParams->rgvarg;
        ULONG cVarRef = 0;

        // count how many out parameters we have
        //
        for (UINT i = 0; i < cArgs; i++) 
            {
            if ((V_VT(pVariant) & VT_BYREF) != 0) 
                {
                cVarRef++;
                #if 0
                    // NOTE: we only allow one level of variants
                    //
                    if (V_VT(pVariant) == (VT_BYREF | VT_VARIANT) && V_VT(V_VARIANTREF(pVariant)) == (VT_BYREF | VT_VARIANT))
                        return E_INVALIDARG;
                #endif
                }
            pVariant++;
            }

        if (cVarRef != 0) 
            {
            UINT * rgVarRefIdx = *prgVarRefIdx;
            VARIANT * rgVarRef = *prgVarRef;
            //
            // Make sure we have enough space for the out array that holds pointers to VARIANT
            // Caller gave us some, but we might need more
            //
            if (cArgs > PREALLOCATE_PARAMS) 
                {
                UINT cbBufSize = (cArgs * sizeof(VARIANT))   +   (cVarRef * (sizeof(UINT) + sizeof(VARIANT)));

                BYTE * pBuf = new BYTE[cbBufSize];
                if (pBuf == NULL)
                    return E_OUTOFMEMORY;

                rgVarArg = (VARIANT*)pBuf;
                rgVarRef = (VARIANT*)(rgVarArg + cArgs);
                rgVarRefIdx = (UINT*)(rgVarRef + cVarRef);

                *prgVarRef = rgVarRef;
                *prgVarRefIdx = rgVarRefIdx;
                }

            pVariant = pDispParams->rgvarg;
            pDispParams->rgvarg = rgVarArg;
            //
            // Create a copy of all the [in,out] parameters so that marshalling will be happy 
            //
            for (i = 0; i < cArgs; i++) 
                {
                if ((V_VT(pVariant) & VT_BYREF) != 0) 
                    {
                    *rgVarRef++ = *pVariant;    // marshaling as [in, out]
                    *rgVarRefIdx++ = i;         // remember the index
                    V_VT(rgVarArg) = VT_EMPTY;  // not marshaling dup entry
                    }
                else 
                    {
                    *rgVarArg = *pVariant;      // marshaling as [in] only
                    }
                rgVarArg++;
                pVariant++;
                }

            *pcVarRef = cVarRef;
            }
        }
    return S_OK;
    }


void InvokeProxyPostCheck(DISPPARAMS *pDispParams, VARIANT * rgVargSave)
    {
    if (pDispParams->cArgs > PREALLOCATE_PARAMS) 
        {
        BYTE * pBuf = (BYTE *)pDispParams->rgvarg;
        delete pBuf;
        }
    pDispParams->rgvarg = rgVargSave;       // put back what was there before
    }

////////////////////////

HRESULT InvokeStubPreCheck(DISPPARAMS * pDispParams, VARTYPE ** pRgVt,
                    DWORD dwFlags, VARIANT ** ppVarResult,
                    EXCEPINFO ** ppExcepInfo, UINT ** ppuArgErr,
                    UINT cVarRef, UINT * rgVarRefIdx, VARIANTARG * rgVarRef)
    {
    UINT cArgs = pDispParams->cArgs;

    if (cArgs == 0) 
        {
        pDispParams->cNamedArgs = 0;
        *pRgVt = NULL;
        }
    else 
        {
        if (pDispParams->rgvarg == NULL || (pDispParams->cNamedArgs != 0 && pDispParams->rgdispidNamedArgs == NULL))
            return E_INVALIDARG;

        VARTYPE* rgvt = new VARTYPE[cArgs];
        if (rgvt == NULL)
            return E_OUTOFMEMORY;

        // restore what should be in the pDispParams->rgvarg array
        //
        VARIANT * pVariant = &pDispParams->rgvarg[0];
        for (UINT i = 0; i < cVarRef; i++)  
            {
            pVariant[rgVarRefIdx[i]] = *rgVarRef++;
            }

        pVariant = &pDispParams->rgvarg[0];
        for (i = 0; i < cArgs; i++) 
            {
            // stash away the passed-in vartype so we can verify later
            // that the callee did not hammer the rgvarg arrary.
            //
            rgvt[i] = V_VT(pVariant);
            pVariant++;
            }

        *pRgVt = rgvt;
        }

    if ((dwFlags & MARSHAL_INVOKE_fakeVarResult) != 0)
        *ppVarResult = NULL;    // was NULL in the first place, so set it back

    if ((dwFlags & MARSHAL_INVOKE_fakeExcepInfo) != 0)
        *ppExcepInfo = NULL;    // was NULL in the first place, so set it back
    else
        (*ppExcepInfo)->pfnDeferredFillIn = NULL;

    if ((dwFlags & MARSHAL_INVOKE_fakeArgErr) != 0)
        *ppuArgErr = NULL;      // was NULL in the first place, so set it back

    return S_OK;
    }


HRESULT InvokeStubPostCheck(HRESULT hr, DISPPARAMS * pDispParams,
                    EXCEPINFO * pExcepInfo, VARTYPE * rgvt,
                    UINT cVarRef, UINT * rgVarRefIdx, VARIANTARG * rgVarRef)
    {
    VARIANT * pVariant;
    UINT cArgs = pDispParams->cArgs;
    UINT i;

    if (SUCCEEDED(hr)) 
        {
        if (cArgs != 0 && cVarRef != 0) 
            {
            pVariant = &pDispParams->rgvarg[0];

            if (cArgs != 0 && rgvt == NULL)
            {
                hr = DISP_E_BADCALLEE;
                cArgs = 0;
            }

            for (i = 0; i < cArgs; i++, pVariant++) 
                {
                // verify that the callee did not hammer the rgvarg array.
                //
                if (V_VT(pVariant) != rgvt[i]) 
                    {
                    hr = DISP_E_BADCALLEE;
                    break;
                    }
                }
            }
        }
    else if (hr == DISP_E_EXCEPTION) 
        {
        if (pExcepInfo != NULL && pExcepInfo->pfnDeferredFillIn != NULL) 
            {
            // since we are going to cross address space, fill in ExcepInfo now
            //
            (*pExcepInfo->pfnDeferredFillIn)(pExcepInfo);
            pExcepInfo->pfnDeferredFillIn = NULL;
            }
        }

    pVariant = pDispParams->rgvarg;
    for (i = 0; i < cVarRef; i++) 
        {
        V_VT(&pVariant[rgVarRefIdx[i]]) = VT_EMPTY;
        }

    if (rgvt != NULL) 
        {
        delete rgvt;
        }
    return hr;
    }


//+-------------------------------------------------------------------------
//
//  Function:   IDispatch_Invoke_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              IDispatch::Invoke().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDispatch_Invoke_Proxy(
        IDispatch * This, DISPID dispIdMember, REFIID riid, LCID lcid,
        WORD wFlags, DISPPARAMS *pDispParams,
        VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    {
    if (!IsEqualIID(riid, IID_NULL))
        return DISP_E_UNKNOWNINTERFACE;

    DWORD dwFlags = (DWORD) wFlags; // Low word is wFlags
    VARIANT * rgVargSave = pDispParams->rgvarg;

    UINT cVarRef;                   // # of [in,out] parameters in DISPPARAMS
    VARIANT rgVarArg[PREALLOCATE_PARAMS];

    VARIANT VarRef[PREALLOCATE_PARAMS];
    VARIANT * rgVarRef = VarRef;    // making it ref pointer is more efficient

    UINT VarRefIdx[PREALLOCATE_PARAMS];
    UINT * rgVarRefIdx = VarRefIdx;

    HRESULT hr = InvokeProxyPreCheck(&dwFlags, pDispParams, rgVarArg, &cVarRef, &rgVarRefIdx, &rgVarRef, &pVarResult);

    VARIANT VarResult;
    EXCEPINFO ExcepInfo;
    UINT uArgErr;

    if (pVarResult == NULL) 
        {
        dwFlags |= MARSHAL_INVOKE_fakeVarResult;
        pVarResult = &VarResult;    // always points to valid address
        }
    if (pExcepInfo == NULL) 
        {
        dwFlags |= MARSHAL_INVOKE_fakeExcepInfo;
        pExcepInfo = &ExcepInfo;    // always points to valid address
        }
    if (puArgErr == NULL) 
        {
        dwFlags |= MARSHAL_INVOKE_fakeArgErr;
        puArgErr = &uArgErr;        // always points to valid address
        }

    if (SUCCEEDED(hr)) 
        {
        // Actually make the remote call
        //
        hr = IDispatch_RemoteInvoke_Proxy(
                            This, dispIdMember, riid, lcid, dwFlags,
                            pDispParams, pVarResult, pExcepInfo, puArgErr,
                            cVarRef, rgVarRefIdx, rgVarRef);

        if (cVarRef > 0)
            {
            // there are [in, out] parameters, clean up
            InvokeProxyPostCheck(pDispParams, rgVargSave);
            }
        }
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:   IDispatch_Invoke_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              IDispatch::Invoke().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDispatch_Invoke_Stub(
        IDispatch * This, DISPID dispIdMember,
        REFIID riid, LCID lcid, DWORD dwFlags, DISPPARAMS * pDispParams,
        VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr,
        UINT cVarRef, UINT * rgVarRefIdx, VARIANTARG * rgVarRef)
    {
    VARTYPE * rgvt;
    HRESULT hr = InvokeStubPreCheck(pDispParams, &rgvt, dwFlags, &pVarResult, &pExcepInfo, &puArgErr, cVarRef, rgVarRefIdx, rgVarRef);
    WORD wFlags = (WORD)(dwFlags & 0xFFFF);
    if (SUCCEEDED(hr)) 
        {
        hr = This->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        hr = InvokeStubPostCheck(hr, pDispParams, pExcepInfo, rgvt, cVarRef, rgVarRefIdx, rgVarRef);
        }
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_CreateInstance_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::CreateInstance().
//
//  Returns:    CLASS_E_NO_AGGREGREGRATION - if punkOuter != 0.
//              Any errors returned by Remote_CreateInstance_Proxy.
//
//  Notes:      We don't support remote aggregation. punkOuter must be zero.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_CreateInstance_Proxy(ITypeInfo * This, IUnknown *pUnkOuter, REFIID riid, PVOID *ppv)
    {
    if (ppv == NULL)
        return E_INVALIDARG;
    *ppv = NULL;
    HRESULT hr;
    if (pUnkOuter != NULL)
        hr = CLASS_E_NOAGGREGATION;
    else
        hr = ITypeInfo_RemoteCreateInstance_Proxy(This, riid, (IUnknown**)ppv);
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_CreateInstance_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeInfo::CreateInstance().
//
//  Returns:    Any errors returned by CreateInstance.
//
//  Notes:      We don't support remote aggregation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_CreateInstance_Stub(
        ITypeInfo * This, REFIID riid, IUnknown **ppv)
    {
    HRESULT hr = This->CreateInstance(0, riid, (void **)ppv);
    if (FAILED(hr)) 
        {
        *ppv = NULL;    // zero it, in case we have a badly behaved server.
        }
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetTypeAttr_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::GetTypeAttr().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetTypeAttr_Proxy(ITypeInfo * This, TYPEATTR ** ppTypeAttr)
    {
    if (ppTypeAttr == NULL)
        return E_INVALIDARG;

    *ppTypeAttr = NULL;         // in case of error

    CLEANLOCALSTORAGE Dummy;
    HRESULT hr = ITypeInfo_RemoteGetTypeAttr_Proxy(This, ppTypeAttr, &Dummy);
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetTypeAttr_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeInfo::GetTypeAttr().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetTypeAttr_Stub(ITypeInfo* This, TYPEATTR** ppTypeAttr, CLEANLOCALSTORAGE* pDummy)
    {
    *ppTypeAttr = NULL;
    pDummy->pInterface = NULL;      // in case of error

    LPTYPEATTR pTypeAttr = NULL;
    HRESULT hr = This->GetTypeAttr(&pTypeAttr);
    if (FAILED(hr) || pTypeAttr == NULL)
        return hr;

    /* Secure reserved fields for RPC
     */
    pTypeAttr->dwReserved = 0;
    pTypeAttr->lpstrSchema = NULL;

    /* OLE/RPC requires that all pointers being allocated by
     * CoGetMalloc()::IMalloc.  But there is no guarantee about
     * who manages *ppTypeAttr, all we know is ITypeInfo::ReleaseTypeAttr()
     * will clean it up, so we must keep necessary info after *ppTypeAttr
     * being marshaled, and then we can clean it up correctly.
     */
    This->AddRef();
    pDummy->pInterface = This;
    pDummy->pStorage = ppTypeAttr;
    pDummy->flags = 't';        // for TypeAttr

    *ppTypeAttr = pTypeAttr;
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:  ITypeInfo_GetContainingTypeLib_Proxy
//
//  Synopsis:  Client-side wrapper function for ITypeInfo::GetContainingTypeLib
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetContainingTypeLib_Proxy(
        ITypeInfo * This, ITypeLib ** ppTLib, UINT * pIndex)
    {
    ITypeLib * pTLib = NULL;
    UINT Index = 0;

    HRESULT hr = ITypeInfo_RemoteGetContainingTypeLib_Proxy(This, &pTLib, &Index);

    if (ppTLib != NULL)
        {
        *ppTLib = pTLib;
        }
    else if (SUCCEEDED(hr))
        {
        pTLib->Release();       // didn't need it after all
        }

    if (pIndex != 0)
        *pIndex = Index;

    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:  ITypeInfo_GetContainingTypeLib_Stub
//
//  Synopsis:  Server-side wrapper function for ITypeInfo::GetContainingTypeLib
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetContainingTypeLib_Stub(
        ITypeInfo * This, ITypeLib ** ppTLib, UINT * pIndex)
    {
    HRESULT hr = This->GetContainingTypeLib(ppTLib, pIndex);
    return hr;
    }

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_ReleaseTypeAttr_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::ReleaseTypeAttr().  It's a local call.
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE ITypeInfo_ReleaseTypeAttr_Proxy(
        ITypeInfo * This, TYPEATTR *pTypeAttr)
{
    void __stdcall DoReleaseTypeAttr(TYPEATTR *pTypeAttr);
    DoReleaseTypeAttr(pTypeAttr);
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetFuncDesc_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::GetFuncDesc().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetFuncDesc_Proxy(
        ITypeInfo * This, UINT index, FUNCDESC ** ppFuncDesc)
{
    if (ppFuncDesc == NULL)
        return E_INVALIDARG;

    *ppFuncDesc = NULL;         // in case of error

    CLEANLOCALSTORAGE Dummy;
    HRESULT hr = ITypeInfo_RemoteGetFuncDesc_Proxy(
                                This, index, ppFuncDesc, &Dummy);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetFuncDesc_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeInfo::GetFuncDesc().
//
//--------------------------------------------------------------------------
void SecureElemDesc(ELEMDESC * pElemDesc)
{
    PARAMDESC * pParamDesc = &pElemDesc->paramdesc;
    if ((pParamDesc->wParamFlags & PARAMFLAG_FHASDEFAULT) == 0)
        pParamDesc->pparamdescex = NULL;
}

void SecureFuncDesc(FUNCDESC * pFuncDesc)
{
    /* Secure reserved fields for RPC
     */
    pFuncDesc->lprgscode = NULL;
    pFuncDesc->cScodes = 0;

    SHORT cParams = pFuncDesc->cParams;
    if (cParams > 0) {
        ELEMDESC * pElemDesc = pFuncDesc->lprgelemdescParam;

        while (cParams-- > 0) {
            SecureElemDesc(pElemDesc);
            pElemDesc++;
        }
    }
    else
        pFuncDesc->lprgelemdescParam = NULL;

    SecureElemDesc(&pFuncDesc->elemdescFunc);
}

HRESULT STDMETHODCALLTYPE ITypeInfo_GetFuncDesc_Stub(
        ITypeInfo * This, UINT index, FUNCDESC ** ppFuncDesc,
        CLEANLOCALSTORAGE * pDummy)
{
    *ppFuncDesc = NULL;
    pDummy->pInterface = NULL;      // in case of error

    LPFUNCDESC pFuncDesc = NULL;
    HRESULT hr = This->GetFuncDesc(index, &pFuncDesc);
    if (FAILED(hr) || pFuncDesc == NULL)
        return hr;

    SecureFuncDesc(pFuncDesc);      // secure reserved fields for RPC

    /* OLE/RPC requires that all pointers being allocated by
     * CoGetMalloc()::IMalloc.  But there is no guarantee about
     * who manages *ppFuncDesc, all we know is ITypeInfo::ReleaseFuncDesc()
     * will clean it up, so we must keep necessary info after *ppFuncDesc
     * being marshaled, and then we can clean it up correctly.
     */
    This->AddRef();
    pDummy->pInterface = This;
    pDummy->pStorage = ppFuncDesc;
    pDummy->flags = 'f';            // shorthand for FuncDesc

    *ppFuncDesc = pFuncDesc;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_ReleaseFuncDesc_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::ReleaseFuncDesc().  It's a local call.
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE ITypeInfo_ReleaseFuncDesc_Proxy(
        ITypeInfo * This, FUNCDESC * pFuncDesc)
{
    void __stdcall DoReleaseFuncDesc(FUNCDESC * pFuncDesc);
    DoReleaseFuncDesc(pFuncDesc);
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetVarDesc_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::GetVarDesc().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetVarDesc_Proxy(
        ITypeInfo * This, UINT index, VARDESC **ppVarDesc)
{
    if (ppVarDesc == NULL)
        return E_INVALIDARG;

    *ppVarDesc = NULL;         // in case of error

    CLEANLOCALSTORAGE Dummy;
    HRESULT hr = ITypeInfo_RemoteGetVarDesc_Proxy(
                                This, index, ppVarDesc, &Dummy);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetVarDesc_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeInfo::GetVarDesc().
//
//--------------------------------------------------------------------------
void SecureVarDesc(VARDESC * pVarDesc)
{
    /* Secure reserved fields for RPC
     */
    pVarDesc->lpstrSchema = NULL;
    SecureElemDesc(&pVarDesc->elemdescVar);
}

HRESULT STDMETHODCALLTYPE ITypeInfo_GetVarDesc_Stub(
        ITypeInfo * This, UINT index, VARDESC ** ppVarDesc,
        CLEANLOCALSTORAGE * pDummy)
{
    *ppVarDesc = NULL;
    pDummy->pInterface = NULL;      // in case of error

    LPVARDESC pVarDesc = NULL;
    HRESULT hr = This->GetVarDesc(index, &pVarDesc);
    if (FAILED(hr) || pVarDesc == NULL)
        return hr;

    SecureVarDesc(pVarDesc);        // secure reserved fields for RPC

    /* OLE/RPC requires that all pointers being allocated by
     * CoGetMalloc()::IMalloc.  But there is no guarantee about
     * who manages *ppVarDesc, all we know is ITypeInfo::ReleaseVarDesc()
     * will clean it up, so we must keep necessary info after *ppVarDesc
     * being marshaled, and then we can clean it up correctly.
     */
    This->AddRef();
    pDummy->pInterface = This;
    pDummy->pStorage = ppVarDesc;
    pDummy->flags = 'v';            // shorthand for VarDesc

    *ppVarDesc = pVarDesc;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_ReleaseVarDesc_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::ReleaseVarDesc().  It's a local call.
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE ITypeInfo_ReleaseVarDesc_Proxy(
        ITypeInfo * This, VARDESC * pVarDesc)
{
    void __stdcall DoReleaseVarDesc(VARDESC * pVarDesc);
    DoReleaseVarDesc(pVarDesc);
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetNames_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeInfo::GetNames
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetNames_Proxy(
        ITypeInfo * This, MEMBERID memid, BSTR * rgBstrNames,
        UINT cMaxNames, UINT * pcNames)
{
    if (rgBstrNames == NULL || pcNames == NULL)
        return E_INVALIDARG;

    HRESULT hr = ITypeInfo_RemoteGetNames_Proxy(
                    This, memid, rgBstrNames, cMaxNames, pcNames);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetNames_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeInfo::GetNames
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetNames_Stub(
        ITypeInfo * This, MEMBERID memid, BSTR * rgBstrNames,
        UINT cMaxNames, UINT * pcNames)
{
    HRESULT hr = This->GetNames(memid, rgBstrNames, cMaxNames, pcNames);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetIDsOfNames_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeInfo::GetIDsOfNames
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetIDsOfNames_Proxy(
        ITypeInfo * This, LPOLESTR * rgszNames,
        UINT cNames, MEMBERID * pMemId)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_Invoke_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::Invoke().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_Invoke_Proxy(
        ITypeInfo * This, PVOID pvInstance, MEMBERID memid, WORD wFlags,
        DISPPARAMS *pDispParams, VARIANT *pVarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    return E_NOTIMPL;
}

#if 0  // Buggy code, need to attach IID to pvInstance, and QI on server side
{
    DWORD dwFlags = (DWORD) wFlags; // Low word is wFlags
    VARIANT * rgVargSave = pDispParams->rgvarg;

    UINT cVarRef;                   // # of [in,out] parameters in DISPPARAMS
    VARIANT rgVarArg[PREALLOCATE_PARAMS];

    VARIANT VarRef[PREALLOCATE_PARAMS];
    VARIANT * rgVarRef = VarRef;    // making it ref pointer is more efficient

    UINT VarRefIdx[PREALLOCATE_PARAMS];
    UINT * rgVarRefIdx = VarRefIdx;

    HRESULT hr = InvokeProxyPreCheck(&dwFlags, pDispParams, rgVarArg,
                            &cVarRef, &rgVarRefIdx, &rgVarRef, &pVarResult);

    VARIANT VarResult;
    EXCEPINFO ExcepInfo;
    UINT uArgErr;

    if (pVarResult == NULL) {
        dwFlags |= MARSHAL_INVOKE_fakeVarResult;
        pVarResult = &VarResult;    // always points to valid address
    }
    if (pExcepInfo == NULL) {
        dwFlags |= MARSHAL_INVOKE_fakeExcepInfo;
        pExcepInfo = &ExcepInfo;    // always points to valid address
    }
    if (puArgErr == NULL) {
        dwFlags |= MARSHAL_INVOKE_fakeArgErr;
        puArgErr = &uArgErr;        // always points to valid address
    }

    if (SUCCEEDED(hr)) {
        hr = ITypeInfo_RemoteInvoke_Proxy(
                            This, (IUnknown *) pvInstance, memid, dwFlags,
                            pDispParams, pVarResult, pExcepInfo, puArgErr,
                            cVarRef, rgVarRefIdx, rgVarRef);

        if (cVarRef > 0)            // there are [in, out] parameters, clean up
            InvokeProxyPostCheck(pDispParams, rgVargSave, cVarRef);
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_Invoke_Stub 
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeInfo::Invoke().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_Invoke_Stub(
        ITypeInfo * This, IUnknown * pIUnk,
        MEMBERID memid, DWORD dwFlags, DISPPARAMS * pDispParams,
        VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr,
        UINT cVarRef, UINT * rgVarRefIdx, VARIANTARG * rgVarRef)
{
    VARTYPE * rgvt;
    HRESULT hr = InvokeStubPreCheck(pDispParams, &rgvt, dwFlags,
                        &pVarResult, &pExcepInfo, &puArgErr,
                        cVarRef, rgVarRefIdx, rgVarRef);

    WORD wFlags = (WORD)(dwFlags & 0xFFFF);
    if (SUCCEEDED(hr)) {
        hr = This->Invoke((void *) pIUnk, memid, wFlags, pDispParams,
                          pVarResult, pExcepInfo, puArgErr);

        hr = InvokeStubPostCheck(hr, pDispParams, pExcepInfo, rgvt,
                        cVarRef, rgVarRefIdx, rgVarRef);
    }
    return hr;
}

#endif // Buggy code

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetDocumentation_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeInfo::GetDocumentation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetDocumentation_Proxy(
        ITypeInfo * This, MEMBERID memid, BSTR *pBstrName,
        BSTR *pBstrDocString, DWORD *pdwHelpContext, BSTR *pBstrHelpFile)
{
    DWORD refPtrFlags = 0x0F;               // four 1's assuming ptrs not NULL
    BSTR BstrName;
    BSTR BstrDocString;
    DWORD dwHelpContext;
    BSTR BstrHelpFile;

    if (pBstrName == NULL) {
        refPtrFlags ^= 0x01;
        pBstrName = &BstrName;              // always points to valid address
    }
    if (pBstrDocString == NULL) {
        refPtrFlags ^= 0x02;
        pBstrDocString = &BstrDocString;    // always points to valid address
    }
    if (pdwHelpContext == NULL) {
        refPtrFlags ^= 0x04;
        pdwHelpContext = &dwHelpContext;    // always points to valid address
    }
    if (pBstrHelpFile == NULL) {
        refPtrFlags ^= 0x08;
        pBstrHelpFile = &BstrHelpFile;      // always points to valid address
    }

    HRESULT hr = ITypeInfo_RemoteGetDocumentation_Proxy(
                        This, memid, refPtrFlags, pBstrName,
                        pBstrDocString, pdwHelpContext, pBstrHelpFile);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetDocumentation_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeInfo::GetDocumentation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetDocumentation_Stub(
        ITypeInfo * This, MEMBERID memid, DWORD refPtrFlags,
        BSTR *pBstrName, BSTR *pBstrDocString, DWORD *pdwHelpContext,
        BSTR *pBstrHelpFile)
{
    if ((refPtrFlags & 0x01) == 0)
        pBstrName = NULL;       // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x02) == 0)
        pBstrDocString = NULL;  // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x04) == 0)
        pdwHelpContext = 0;     // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x08) == 0)
        pBstrHelpFile = NULL;   // was NULL in the first place, so set it back

    HRESULT hr = This->GetDocumentation(memid, pBstrName,
                        pBstrDocString, pdwHelpContext, pBstrHelpFile);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetDllEntry_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeInfo::GetDllEntry.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetDllEntry_Proxy(
        ITypeInfo * This, MEMBERID memid, INVOKEKIND invKind,
        BSTR *pBstrDllName, BSTR *pBstrName, WORD *pwOrdinal)
{
    DWORD refPtrFlags = 0x07;               // three 1's assuming ptrs not NULL
    BSTR BstrDllName;
    BSTR BstrName;
    WORD wOrdinal;

    if (pBstrDllName == NULL) {
        refPtrFlags ^= 0x01;
        pBstrDllName = &BstrDllName;        // always points to valid address
    }
    if (pBstrName == NULL) {
        refPtrFlags ^= 0x02;
        pBstrName = &BstrName;              // always points to valid address
    }
    if (pwOrdinal == NULL) {
        refPtrFlags ^= 0x04;
        pwOrdinal = &wOrdinal;              // always points to valid address
    }

    HRESULT hr = ITypeInfo_RemoteGetDllEntry_Proxy(
                        This, memid, invKind, refPtrFlags,
                        pBstrDllName, pBstrName, pwOrdinal);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_GetDllEntry_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeInfo::GetDllEntry.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_GetDllEntry_Stub(
        ITypeInfo * This, MEMBERID memid, INVOKEKIND invKind,
        DWORD refPtrFlags,
        BSTR *pBstrDllName, BSTR *pBstrName, WORD *pwOrdinal)
{
    if ((refPtrFlags & 0x01) == 0)
        pBstrDllName = NULL;    // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x02) == 0)
        pBstrName = NULL;       // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x04) == 0)
        pwOrdinal = 0;          // was NULL in the first place, so set it back

    HRESULT hr = This->GetDllEntry(memid, invKind,
                                   pBstrDllName, pBstrName, pwOrdinal);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo_AddressOfMember_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeInfo::AddressOfMember().  It's a local call.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo_AddressOfMember_Proxy(
        ITypeInfo * This, MEMBERID memid, INVOKEKIND invKind, PVOID * ppv)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo2_GetDocumentation2_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeInfo2::GetDocumentation2.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo2_GetDocumentation2_Proxy(
        ITypeInfo2 * This, MEMBERID memid, LCID lcid,
        BSTR *pbstrHelpString, DWORD *pdwHelpStringContext,
        BSTR *pbstrHelpStringDll)
{
    DWORD refPtrFlags = 0x07;               // three 1's assuming ptrs not NULL
    BSTR bstrHelpString;
    DWORD dwHelpStringContext;
    BSTR bstrHelpStringDll;

    if (pbstrHelpString == NULL) {
        refPtrFlags ^= 0x01;
        pbstrHelpString = &bstrHelpString;  // always points to valid address
    }
    if (pdwHelpStringContext == NULL) {
        refPtrFlags ^= 0x02;                // always points to valid address
        pdwHelpStringContext = &dwHelpStringContext;
    }
    if (pbstrHelpStringDll == NULL) {
        refPtrFlags ^= 0x04;                // always points to valid address
        pbstrHelpStringDll = &bstrHelpStringDll;
    }

    HRESULT hr = ITypeInfo2_RemoteGetDocumentation2_Proxy(
                        This, memid, lcid, refPtrFlags, pbstrHelpString,
                        pdwHelpStringContext, pbstrHelpStringDll);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeInfo2_GetDocumentation2_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeInfo2::GetDocumentation2.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeInfo2_GetDocumentation2_Stub(
        ITypeInfo2 * This, MEMBERID memid, LCID lcid, DWORD refPtrFlags,
        BSTR *pbstrHelpString, DWORD *pdwHelpStringContext,
        BSTR *pbstrHelpStringDll)
{
    if ((refPtrFlags & 0x01) == 0)
        pbstrHelpString = NULL;     // was NULL, so set it back

    if ((refPtrFlags & 0x02) == 0)
        pdwHelpStringContext = 0;   // was NULL, so set it back

    if ((refPtrFlags & 0x04) == 0)
        pbstrHelpStringDll = NULL;  // was NULL, so set it back

    HRESULT hr = This->GetDocumentation2(memid, lcid, pbstrHelpString,
                        pdwHelpStringContext, pbstrHelpStringDll);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_GetTypeInfoCount_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeLib::GetTypeInfoCount().
//
//--------------------------------------------------------------------------
UINT STDMETHODCALLTYPE ITypeLib_GetTypeInfoCount_Proxy(ITypeLib *This)
{
    UINT cTInfo;
    HRESULT hr = ITypeLib_RemoteGetTypeInfoCount_Proxy(This, &cTInfo);
    if (FAILED(hr))
        return 0;
    return cTInfo;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_GetTypeInfoCount_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeLib::GetTypeInfoCount().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_GetTypeInfoCount_Stub(
        ITypeLib *This, UINT *pcTInfo)
{
    *pcTInfo = This->GetTypeInfoCount();
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_GetDocumentation_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeLib::GetDocumentation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_GetDocumentation_Proxy(
        ITypeLib * This, INT index, BSTR *pBstrName,
        BSTR *pBstrDocString, DWORD *pdwHelpContext, BSTR *pBstrHelpFile)
{
    DWORD refPtrFlags = 0x0F;               // four 1's assuming ptrs not NULL
    BSTR BstrName = NULL;
    BSTR BstrDocString = NULL;
    DWORD dwHelpContext = 0;
    BSTR BstrHelpFile = NULL;

    if (pBstrName == NULL) {
        refPtrFlags ^= 0x01;
        pBstrName = &BstrName;              // always points to valid address
    }
    if (pBstrDocString == NULL) {
        refPtrFlags ^= 0x02;
        pBstrDocString = &BstrDocString;    // always points to valid address
    }
    if (pdwHelpContext == NULL) {
        refPtrFlags ^= 0x04;
        pdwHelpContext = &dwHelpContext;    // always points to valid address
    }
    if (pBstrHelpFile == NULL) {
        refPtrFlags ^= 0x08;
        pBstrHelpFile = &BstrHelpFile;      // always points to valid address
    }

    HRESULT hr = ITypeLib_RemoteGetDocumentation_Proxy(
                        This, index, refPtrFlags, pBstrName,
                        pBstrDocString, pdwHelpContext, pBstrHelpFile);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_GetDocumentation_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeLib::GetDocumentation.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_GetDocumentation_Stub(
        ITypeLib * This, INT index, DWORD refPtrFlags,
        BSTR *pBstrName, BSTR *pBstrDocString, DWORD *pdwHelpContext,
        BSTR *pBstrHelpFile)
{
    if ((refPtrFlags & 0x01) == 0)
        pBstrName = NULL;       // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x02) == 0)
        pBstrDocString = NULL;  // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x04) == 0)
        pdwHelpContext = 0;     // was NULL in the first place, so set it back

    if ((refPtrFlags & 0x08) == 0)
        pBstrHelpFile = NULL;   // was NULL in the first place, so set it back

    HRESULT hr = This->GetDocumentation(index, pBstrName,
                        pBstrDocString, pdwHelpContext, pBstrHelpFile);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib2_GetLibStatistics_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeLib2::GetLibStatistics.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib2_GetLibStatistics_Proxy(
        ITypeLib2 * This, ULONG * pcUniqueNames, ULONG * pcchUniqueNames)
{
    ULONG cUniqueNames;
    ULONG cchUniqueNames;

    if (pcUniqueNames == NULL)              // NULL allowed
        pcUniqueNames = &cUniqueNames;

    if (pcchUniqueNames == NULL)            // NULL allowed
        pcchUniqueNames = &cchUniqueNames;

    HRESULT hr = ITypeLib2_RemoteGetLibStatistics_Proxy(This,
                                        pcUniqueNames, pcchUniqueNames);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib2_GetLibStatistics_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeLib2::GetLibStatistics.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib2_GetLibStatistics_Stub(
        ITypeLib2 * This, ULONG * pcUniqueNames, ULONG * pcchUniqueNames)
{
    HRESULT hr = This->GetLibStatistics(pcUniqueNames, pcchUniqueNames);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib2_GetDocumentation2_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeLib2::GetDocumentation2.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib2_GetDocumentation2_Proxy(
        ITypeLib2 * This, int index, LCID lcid,
        BSTR *pbstrHelpString, DWORD *pdwHelpStringContext,
        BSTR *pbstrHelpStringDll)
{
    DWORD refPtrFlags = 0x07;               // three 1's assuming ptrs not NULL
    BSTR bstrHelpString;
    DWORD dwHelpStringContext;
    BSTR bstrHelpStringDll;

    if (pbstrHelpString == NULL) {
        refPtrFlags ^= 0x01;
        pbstrHelpString = &bstrHelpString;  // always points to valid address
    }
    if (pdwHelpStringContext == NULL) {
        refPtrFlags ^= 0x02;                // always points to valid address
        pdwHelpStringContext = &dwHelpStringContext;
    }
    if (pbstrHelpStringDll == NULL) {
        refPtrFlags ^= 0x04;                // always points to valid address
        pbstrHelpStringDll = &bstrHelpStringDll;
    }

    HRESULT hr = ITypeLib2_RemoteGetDocumentation2_Proxy(
                        This, index, lcid, refPtrFlags, pbstrHelpString,
                        pdwHelpStringContext, pbstrHelpStringDll);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib2_GetDocumentation2_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeLib2::GetDocumentation2.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib2_GetDocumentation2_Stub(
        ITypeLib2 * This, int index, LCID lcid, DWORD refPtrFlags,
        BSTR *pbstrHelpString, DWORD *pdwHelpStringContext,
        BSTR *pbstrHelpStringDll)
{
    if ((refPtrFlags & 0x01) == 0)
        pbstrHelpString = NULL;         // was NULL, so set it back

    if ((refPtrFlags & 0x02) == 0)
        pdwHelpStringContext = 0;       // was NULL, so set it back

    if ((refPtrFlags & 0x04) == 0)
        pbstrHelpStringDll = NULL;      // was NULL, so set it back

    HRESULT hr = This->GetDocumentation2(index, lcid, pbstrHelpString,
                        pdwHelpStringContext, pbstrHelpStringDll);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_GetLibAttr_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeLib::GetLibAttr().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_GetLibAttr_Proxy(
        ITypeLib * This, TLIBATTR **ppTLibAttr)
{
    if (ppTLibAttr == NULL)
        return E_INVALIDARG;

    *ppTLibAttr = NULL;         // in case of error

    CLEANLOCALSTORAGE Dummy;
    HRESULT hr = ITypeLib_RemoteGetLibAttr_Proxy(This, ppTLibAttr, &Dummy);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_GetLibAttr_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for
//              ITypeLib::GetLibAttr().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_GetLibAttr_Stub(
        ITypeLib * This, TLIBATTR ** ppTLibAttr, CLEANLOCALSTORAGE * pDummy)
{
    *ppTLibAttr = NULL;
    pDummy->pInterface = NULL;      // in case of error

    LPTLIBATTR pTLibAttr = NULL;
    HRESULT hr = This->GetLibAttr(&pTLibAttr);
    if (FAILED(hr) || pTLibAttr == NULL)
        return hr;

    /* OLE/RPC requires that all pointers being allocated by
     * CoGetMalloc()::IMalloc.  But there is no guarantee about
     * who manages *ppTLibAttr, all we know is ITypeInfo::ReleaseTLibAttr()
     * will clean it up, so we must keep necessary info after *ppTLibAttr
     * being marshaled, and then we can clean it up correctly.
     */
    This->AddRef();
    pDummy->pInterface = This;
    pDummy->pStorage = ppTLibAttr;
    pDummy->flags = 'l';        // for TLibAttr

    *ppTLibAttr = pTLibAttr;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_IsName_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for ITypeLib::IsName().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_IsName_Proxy(
        ITypeLib * This, LPOLESTR szNameBuf, ULONG lHashVal, BOOL * pfName)
{
    if (szNameBuf == NULL || pfName == NULL)
        return E_INVALIDARG;

    BSTR bstrName = NULL;
    HRESULT hr = ITypeLib_RemoteIsName_Proxy(This, szNameBuf, lHashVal, pfName,
                                             &bstrName);
    if (SUCCEEDED(hr) && *pfName) {
        memcpy(szNameBuf, bstrName, g_oaUtil.SysStringByteLen(bstrName));
        g_oaUtil.SysFreeString(bstrName);
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_IsName_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for ITypeLib::IsName().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_IsName_Stub(
        ITypeLib * This, LPOLESTR szNameBuf, ULONG lHashVal,
        BOOL * pfName, BSTR * pBstrLibName)
{
    *pBstrLibName = NULL;
    HRESULT hr = This->IsName(szNameBuf, lHashVal, pfName);
    if (SUCCEEDED(hr) && *pfName) {
        *pBstrLibName = (g_oa.get_SysAllocString())(szNameBuf);
        if (*pBstrLibName == NULL)
            return E_OUTOFMEMORY;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_FindName_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for ITypeLib::FindName()
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_FindName_Proxy(
        ITypeLib * This, LPOLESTR szNameBuf, ULONG lHashVal,
        ITypeInfo ** ppTInfo, MEMBERID * rgMemId, USHORT * pcFound)
{
    if (szNameBuf == NULL || ppTInfo == NULL ||
            rgMemId == NULL || pcFound == NULL)
        return E_INVALIDARG;

    BSTR bstrName = NULL;
    HRESULT hr = ITypeLib_RemoteFindName_Proxy(This, szNameBuf, lHashVal,
                                    ppTInfo, rgMemId, pcFound, &bstrName);
    if (SUCCEEDED(hr)) {
        memcpy(szNameBuf, bstrName, g_oaUtil.SysStringByteLen(bstrName));
        g_oaUtil.SysFreeString(bstrName);
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_FindName_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for ITypeLib::FindName()
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeLib_FindName_Stub(
        ITypeLib * This, LPOLESTR szNameBuf, ULONG lHashVal,
        ITypeInfo ** ppTInfo, MEMBERID * rgMemId, USHORT * pcFound,
        BSTR * pBstrLibName)
{
    *pBstrLibName = NULL;
    HRESULT hr = This->FindName(szNameBuf,lHashVal,ppTInfo,rgMemId,pcFound);
    if (SUCCEEDED(hr)) {
        *pBstrLibName = (g_oa.get_SysAllocString())(szNameBuf);
        if (*pBstrLibName == NULL)
            return E_OUTOFMEMORY;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeLib_ReleaseTLibAttr_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for
//              ITypeLib::ReleaseTLibAttr().  It's a local call.
//
//--------------------------------------------------------------------------
void STDMETHODCALLTYPE ITypeLib_ReleaseTLibAttr_Proxy(
        ITypeLib * This, TLIBATTR * pTLibAttr)
{
    if (pTLibAttr != NULL) {
            FreeMemory(pTLibAttr);
    }
}

// //+-------------------------------------------------------------------------
// //
// //  Function:   IClassFactory2_CreateInstanceLic_Proxy
// //
// //  Synopsis:   Client-side [call_as] wrapper function for
// //              IClassFactory2::CreateInstanceLic().
// //
// //  Returns:    CLASS_E_NO_AGGREGREGRATION - if punkOuter != 0.
// //              Any errors returned by RemoteCreateInstanceLic_Proxy.
// //
// //  Notes:      We don't support remote aggregation. punkOuter must be zero.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IClassFactory2_CreateInstanceLic_Proxy(
//         IClassFactory2 * This, IUnknown *pUnkOuter, IUnknown *pUnkReserved,
//         REFIID riid, BSTR bstrKey, PVOID *ppv)
// {
//     if (ppv == NULL)
//         return E_INVALIDARG;
// 
//     *ppv = NULL;
// 
//     HRESULT hr;
//     if (pUnkOuter != NULL)
//         hr = CLASS_E_NOAGGREGATION;
//     else
//         hr = IClassFactory2_RemoteCreateInstanceLic_Proxy(
//                     This, riid, bstrKey, (IUnknown**)ppv);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IClassFactory2_CreateInstanceLic_Stub
// //
// //  Synopsis:   Server-side [call_as] wrapper function for
// //              IClassFactory2::CreateInstanceLic().
// //
// //  Returns:    Any errors returned by CreateInstanceLic.
// //
// //  Notes:      We don't support remote aggregation.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IClassFactory2_CreateInstanceLic_Stub(
//         IClassFactory2 * This, REFIID riid, BSTR bstrKey, IUnknown ** ppv)
// {
//     HRESULT hr = This->CreateInstanceLic(0, 0, riid, bstrKey, (void **)ppv);
//     if (FAILED(hr))
//         *ppv = 0;   // zero it, in case we have a badly behaved server.
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IEnumConnectionPoints_Next_Proxy
// //
// //  Synopsis:   Client-side [call_as] wrapper function for
// //              IEnumConnectionPoints::Next.  This wrapper function handles the
// //              case where pcFetched is NULL.
// //
// //  Notes:      If pcFetched != 0, then the number of elements
// //              fetched will be returned in *pcFetched.  If an error
// //              occurs, then *pcFetched is set to zero.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IEnumConnectionPoints_Next_Proxy(
//         IEnumConnectionPoints * This, ULONG cConnections,
//         IConnectionPoint ** rgpcn, ULONG *pcFetched)
// {
//     if (cConnections > 1 && pcFetched == NULL)
//         return E_INVALIDARG;
// 
//     ULONG cFetched = 0;
//     HRESULT hr = IEnumConnectionPoints_RemoteNext_Proxy(
//                             This, cConnections, rgpcn, &cFetched);
//     if (pcFetched != NULL)
//         *pcFetched = cFetched;
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IEnumConnectionPoints_Next_Stub
// //
// //  Synopsis:   Server-side [call_as] wrapper function for
// //              IEnumConnectionPoints::Next.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IEnumConnectionPoints_Next_Stub(
//         IEnumConnectionPoints * This, ULONG cConnections,
//         IConnectionPoint ** rgpcn, ULONG * pcFetched)
// {
//     HRESULT hr = This->Next(cConnections, rgpcn, pcFetched);
//     if (FAILED(hr))
//         *pcFetched = 0; // zero it, in case we have a badly behaved server.
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IEnumConnections_Next_Proxy
// //
// //  Synopsis:   Client-side [call_as] wrapper function for
// //              IEnumConnections::Next.  This wrapper function handles the
// //              case where pcFetched is NULL.
// //
// //  Notes:      If pcFetched != 0, then the number of elements
// //              fetched will be returned in *pcFetched.  If an error
// //              occurs, then *pcFetched is set to zero.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IEnumConnections_Next_Proxy(
//         IEnumConnections * This, ULONG cConnections,
//         CONNECTDATA *rgpunk, ULONG *pcFetched)
// {
//     if ((cConnections > 1) && (pcFetched == NULL))
//         return E_INVALIDARG;
// 
//     ULONG cFetched = 0;
//     HRESULT hr = IEnumConnections_RemoteNext_Proxy(
//                         This, cConnections, rgpunk, &cFetched);
//     if (pcFetched != NULL)
//         *pcFetched = cFetched;
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IEnumConnections_Next_Stub
// //
// //  Synopsis:   Server-side [call_as] wrapper function for
// //              IEnumConnections::Next.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IEnumConnections_Next_Stub(
//         IEnumConnections * This, ULONG cConnections,
//         CONNECTDATA *rgpunk, ULONG *pcFetched)
// {
//     HRESULT hr = This->Next(cConnections, rgpunk, pcFetched);
//     if (FAILED(hr))
//         *pcFetched = 0; // zero it, in case we have a badly behaved server.
//     return hr;
// }
// 
//+-------------------------------------------------------------------------
//
//  Function:   IEnumVARIANT_Next_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for IEnumVARIANT::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumVARIANT_Next_Proxy(
        IEnumVARIANT * This, ULONG cElt, VARIANT *rgVar, ULONG *pcEltFetched)
{
    ULONG cFetched = 0;
    HRESULT hr = IEnumVARIANT_RemoteNext_Proxy(This, cElt, rgVar, &cFetched);
    if (pcEltFetched != NULL)
        *pcEltFetched = cFetched;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IEnumVARIANT_Next_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for IEnumVARIANT::Next.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IEnumVARIANT_Next_Stub(
        IEnumVARIANT * This, ULONG cElt, VARIANT *rgVar, ULONG *pcEltFetched)
{
    HRESULT hr = This->Next(cElt, rgVar, pcEltFetched);
    if (FAILED(hr))
        *pcEltFetched = 0; // zero it, in case we have a badly behaved server.
    return hr;
}

// //+-------------------------------------------------------------------------
// //
// //  Function:   IEnumOleUndoUnits_Next_Proxy
// //
// //  Synopsis:   Client-side wrapper function for IEnumOleUndoUnits::Next.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IEnumOleUndoUnits_Next_Proxy(
//         IEnumOleUndoUnits * This, ULONG cElt,
//         IOleUndoUnit **rgElt, ULONG *pcEltFetched)
// {
//     ULONG cFetched = 0;
//     HRESULT hr = IEnumOleUndoUnits_RemoteNext_Proxy(
//                             This, cElt, rgElt, &cFetched);
//     if (pcEltFetched != NULL)
//         *pcEltFetched = cFetched;
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IEnumOleUndoUnits_Next_Stub
// //
// //  Synopsis:   Server-side wrapper function for IEnumOleUndoUnits::Next.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IEnumOleUndoUnits_Next_Stub(
//         IEnumOleUndoUnits * This, ULONG cElt,
//         IOleUndoUnit **rgElt, ULONG *pcEltFetched)
// {
//     HRESULT hr = This->Next(cElt, rgElt, pcEltFetched);
//     if (FAILED(hr))
//         *pcEltFetched = 0; // zero it, in case we have a badly behaved server.
//     return hr;
// }
// 
//+-------------------------------------------------------------------------
//
//  Function:   ITypeComp_Bind_Proxy
//
//  Synopsis:   Client-side [call_as] wrapper function for ITypeComp::Bind().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeComp_Bind_Proxy(
        ITypeComp * This, LPOLESTR szName, ULONG lHashVal, WORD wFlags,
        ITypeInfo ** ppTInfo, DESCKIND * pDescKind, BINDPTR * pBindPtr)
{
    if (szName == NULL || ppTInfo == NULL ||
            pDescKind == NULL || pBindPtr == NULL)
        return E_INVALIDARG;

    *ppTInfo = NULL;
    *pDescKind = DESCKIND_NONE;
    pBindPtr->lpvardesc = NULL;

    ITypeInfo * pTypeInfo;
    DESCKIND DescKind;
    FUNCDESC * pFuncDesc;
    VARDESC * pVarDesc;
    ITypeComp * pTypeComp;
    CLEANLOCALSTORAGE Dummy;

    HRESULT hr = ITypeComp_RemoteBind_Proxy(This, szName,
                                lHashVal, wFlags, &pTypeInfo, &DescKind,
                                &pFuncDesc, &pVarDesc, &pTypeComp, &Dummy);
    if (SUCCEEDED(hr)) {
        switch(DescKind) {

        case DESCKIND_VARDESC:
        case DESCKIND_IMPLICITAPPOBJ:
            *ppTInfo = pTypeInfo;
            pBindPtr->lpvardesc = pVarDesc;
            break;

        case DESCKIND_FUNCDESC:
            *ppTInfo = pTypeInfo;
            pBindPtr->lpfuncdesc = pFuncDesc;
            break;

        case DESCKIND_TYPECOMP:
            pBindPtr->lptcomp = pTypeComp;
            break;

        default:
            DescKind = DESCKIND_NONE;
            break;
        }

        *pDescKind = DescKind;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeComp_Bind_Stub
//
//  Synopsis:   Server-side [call_as] wrapper function for ITypeComp::Bind().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeComp_Bind_Stub(
        ITypeComp * This, LPOLESTR szName, ULONG lHashVal, WORD wFlags,
        ITypeInfo ** ppTInfo, DESCKIND * pDescKind,
        FUNCDESC ** ppFuncDesc, VARDESC ** ppVarDesc, ITypeComp ** ppTypeComp,
        CLEANLOCALSTORAGE * pDummy)
{
    pDummy->pInterface = NULL;      // in case of error
    *ppTInfo = NULL;
    *pDescKind = DESCKIND_NONE;
    *ppFuncDesc = NULL;
    *ppVarDesc = NULL;
    *ppTypeComp = NULL;

    ITypeInfo * pTypeInfo;
    DESCKIND DescKind;
    BINDPTR BindPtr;
    HRESULT hr = This->Bind(szName, lHashVal, wFlags,
                            &pTypeInfo, &DescKind, &BindPtr);
    if (FAILED(hr))
        return hr;

    /* OLE/RPC requires that all pointers being allocated by
     * CoGetMalloc()::IMalloc.  But there is no guarantee about
     * who manages what is in pBindPtr, so we must keep necessary
     * info after pBindPtr being marshaled, then to clean it up correctly.
     */
    switch (DescKind) {
    case DESCKIND_VARDESC:
    case DESCKIND_IMPLICITAPPOBJ:
        *ppTInfo = pTypeInfo;
        *ppVarDesc = BindPtr.lpvardesc;
        SecureVarDesc(*ppVarDesc);      // secure reserved fields for RPC

        pTypeInfo->AddRef();
        pDummy->pInterface = pTypeInfo;
        pDummy->pStorage = ppVarDesc;
        pDummy->flags = 'v';            // shorthand for VarDesc
        break;

    case DESCKIND_FUNCDESC:
        *ppTInfo = pTypeInfo;
        *ppFuncDesc = BindPtr.lpfuncdesc;
        SecureFuncDesc(*ppFuncDesc);    // secure reserved fields for RPC

        pTypeInfo->AddRef();
        pDummy->pInterface = pTypeInfo;
        pDummy->pStorage = ppFuncDesc;
        pDummy->flags = 'f';            // shorthand for FuncDesc
        break;

    case DESCKIND_TYPECOMP:
        *ppTypeComp = BindPtr.lptcomp;
        break;

    default:
        DescKind = DESCKIND_NONE;
        break;
    }

    *pDescKind = DescKind;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeComp_BindType_Proxy
//
//  Synopsis:   Client-side wrapper function for ITypeComp::BindType().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeComp_BindType_Proxy(
        ITypeComp * This, LPOLESTR szName, ULONG lHashVal,
        ITypeInfo ** ppTInfo, ITypeComp ** ppTComp)
{
    if (szName == NULL || ppTInfo == NULL)
        return E_INVALIDARG;

    if (ppTComp != NULL)
        *ppTComp = NULL;

    *ppTInfo = NULL;

    HRESULT hr;
    hr = ITypeComp_RemoteBindType_Proxy(This, szName, lHashVal, ppTInfo);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ITypeComp_BindType_Stub
//
//  Synopsis:   Server-side wrapper function for ITypeComp::BindType().
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ITypeComp_BindType_Stub(
        ITypeComp * This, LPOLESTR szName, ULONG lHashVal, ITypeInfo** ppTInfo)
{
    ITypeComp * pTComp = NULL;
    HRESULT hr = This->BindType(szName, lHashVal, ppTInfo, &pTComp);
    if (FAILED(hr)) {
        *ppTInfo = 0;   // zero it, in case we have a badly behaved server.
    }
    return hr;
}

// //+-------------------------------------------------------------------------
// //
// //  Function:   IAdviseSinkEx_OnViewStatusChange_Proxy
// //
// //  Synopsis:   Client-side wrapper for IAdviseSinkEx::OnViewStatusChange()
// //
// //--------------------------------------------------------------------------
// void STDMETHODCALLTYPE IAdviseSinkEx_OnViewStatusChange_Proxy(
//         IAdviseSinkEx * This, DWORD dwViewStatus)
// {
//     HRESULT hr;
// #if 1
//     hr = IAdviseSinkEx_RemoteOnViewStatusChange_Proxy(This, dwViewStatus);
// #else
//     __try {
//         hr = IAdviseSinkEx_RemoteOnViewStatusChange_Proxy(This, dwViewStatus);
//         // Just drop the return value
//     }
//     __except(EXCEPTION_EXECUTE_HANDLER) {
//         //Just ignore the exception.
//         hr = HRESULT_FROM_WIN32(GetExceptionCode());
//     }
// #endif
// }
// 
//+-------------------------------------------------------------------------
// //
// //  Function:   IAdviseSinkEx_OnViewStatusChange_Stub
// //
// //  Synopsis:   Server-side wrapper for IAdviseSinkEx::OnViewStatusChange()
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IAdviseSinkEx_OnViewStatusChange_Stub(
//         IAdviseSinkEx * This, DWORD dwViewStatus)
// {
//     This->OnViewStatusChange(dwViewStatus);
//     return S_OK;
// }
// 
// /* [local] */ void STDMETHODCALLTYPE IAdviseSinkEx_OnDataChange_Proxy( 
//     IAdviseSinkEx __RPC_FAR * This,
//     /* [in] */ FORMATETC __RPC_FAR *pFormatetc,
//     /* [in] */ STGMEDIUM __RPC_FAR *pStgmed)
// {
//     HRESULT hr;
//     hr = IAdviseSinkEx_RemoteOnDataChange_Proxy(This, pFormatetc, pStgmed);
// }
// 
// /* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSinkEx_OnDataChange_Stub( 
//     IAdviseSinkEx __RPC_FAR * This,
//     /* [in] */ FORMATETC __RPC_FAR *pFormatetc,
//     /* [in] */ ASYNC_STGMEDIUM __RPC_FAR *pStgmed)
// {
//     This->OnDataChange(pFormatetc, pStgmed);
//     return S_OK;
// }
// 
// /* [local] */ void STDMETHODCALLTYPE IAdviseSinkEx_OnViewChange_Proxy( 
//     IAdviseSinkEx __RPC_FAR * This,
//     /* [in] */ DWORD dwAspect,
//     /* [in] */ LONG lindex)
// {
//     HRESULT hr;
//     hr = IAdviseSinkEx_RemoteOnViewChange_Proxy(This, dwAspect, lindex);
// }
// 
// /* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSinkEx_OnViewChange_Stub( 
//     IAdviseSinkEx __RPC_FAR * This,
//     /* [in] */ DWORD dwAspect,
//     /* [in] */ LONG lindex)
// {
//     This->OnViewChange(dwAspect, lindex);
//     return S_OK;
// }
// 
// /* [local] */ void STDMETHODCALLTYPE IAdviseSinkEx_OnRename_Proxy( 
//     IAdviseSinkEx __RPC_FAR * This,
//     /* [in] */ IMoniker __RPC_FAR *pmk)
// {
//     HRESULT hr;
//     hr = IAdviseSinkEx_RemoteOnRename_Proxy(This, pmk);
// }
// 
// /* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSinkEx_OnRename_Stub( 
//     IAdviseSinkEx __RPC_FAR * This,
//     /* [in] */ IMoniker __RPC_FAR *pmk)
// {
//     This->OnRename(pmk);
//     return S_OK;
// }
// 
// /* [local] */ void STDMETHODCALLTYPE IAdviseSinkEx_OnSave_Proxy( 
//     IAdviseSinkEx __RPC_FAR * This)
// {
//     HRESULT hr;
//     hr = IAdviseSinkEx_RemoteOnSave_Proxy(This);
// }
// 
// /* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSinkEx_OnSave_Stub( 
//     IAdviseSinkEx __RPC_FAR * This)
// {
//     This->OnSave();
//     return S_OK;
// }
// 
// /* [local] */ void STDMETHODCALLTYPE IAdviseSinkEx_OnClose_Proxy( 
//     IAdviseSinkEx __RPC_FAR * This)
// {
//     HRESULT hr;
//     hr = IAdviseSinkEx_RemoteOnClose_Proxy(This);
// }
// 
// /* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSinkEx_OnClose_Stub( 
//     IAdviseSinkEx __RPC_FAR * This)
// {
//     This->OnClose();
//     return S_OK;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IPersistMemory_Load_Proxy
// //
// //  Synopsis:   Client-side wrapper for IPersistMemory::Load()
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IPersistMemory_Load_Proxy(
//         IPersistMemory * This, LPVOID pMem, ULONG cbSize)
// {
//     HRESULT hr;
//     hr = IPersistMemory_RemoteLoad_Proxy(This, (BYTE *)pMem, cbSize);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IPersistMemory_Load_Stub
// //
// //  Synopsis:   Server-side wrapper for IPersistMemory::Load()
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IPersistMemory_Load_Stub(
//         IPersistMemory * This, BYTE * pMem, ULONG cbSize)
// {
//     HRESULT hr;
//     hr = This->Load((LPVOID) pMem, cbSize);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IPersistMemory_Save_Proxy
// //
// //  Synopsis:   Client-side wrapper for IPersistMemory::Save()
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IPersistMemory_Save_Proxy(
//         IPersistMemory * This, LPVOID pMem, BOOL fClearDirty, ULONG cbSize)
// {
//     HRESULT hr;
//     hr = IPersistMemory_RemoteSave_Proxy(This,(BYTE*)pMem,fClearDirty,cbSize);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IPersistMemory_Save_Stub
// //
// //  Synopsis:   Server-side wrapper for IPersistMemory::Save()
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IPersistMemory_Save_Stub(
//         IPersistMemory * This, BYTE * pMem, BOOL fClearDirty, ULONG cbSize)
// {
//     HRESULT hr;
//     hr = This->Save((LPVOID) pMem, fClearDirty, cbSize);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IPropertyBag_Read_Proxy (for both DCOM and non-DCOM)
// //
// //  Synopsis:   Client-side wrapper function for IPropertyBag::Read.
// //
// //--------------------------------------------------------------------------
// EXTERN_C FARPROC pNdrClientCall2;
// 
// HRESULT STDMETHODCALLTYPE IPropertyBag_Read_Proxy(
//         IPropertyBag * This, LPCOLESTR pszPropName,
//         VARIANT * pVar, IErrorLog * pErrorLog)
// {
//     DWORD varType = (DWORD) V_VT(pVar);
//     IUnknown * pUnkObj = NULL;
// 
//     if ((varType & VT_BYREF) != 0 ||    // don't allow byref VARIANT
//         (varType == VT_DISPATCH && V_UNKNOWN(pVar) != NULL)) // no VT_DISPATCH
//         return E_INVALIDARG;
// 
//     if (varType == VT_UNKNOWN)
//         pUnkObj = V_UNKNOWN(pVar);
// 
//     HRESULT hr;
//     if (pNdrClientCall2 == NULL) {  // non-DCOM
//         hr = IPropertyBag_RemoteRead_Proxy(
//                         This, pszPropName, pVar, pErrorLog, varType, pUnkObj);
//     }
//     else {  // DCOM
//         hr = _IPropertyBag_RemoteRead_Proxy(
//                         (_IPropertyBag *)This, pszPropName, pVar,
//                         (_IErrorLog *)pErrorLog, varType, pUnkObj);
//     }
// 
//     /* Restore what it was before, see also comments below
//      */
//     if (V_VT(pVar) == VT_EMPTY && pUnkObj != NULL) {
//         V_VT(pVar) = (VARTYPE) varType;
//         V_UNKNOWN(pVar) = pUnkObj;
//     }
// 
//     return hr;
// }
// 
// 
// HRESULT STDMETHODCALLTYPE _IPropertyBag_Read_Proxy(
//         _IPropertyBag * This, LPCOLESTR pszPropName,
//         VARIANT * pVar, _IErrorLog * pErrorLog)
// {
//     HRESULT hr;
//     hr = IPropertyBag_Read_Proxy(
//             (IPropertyBag *)This, pszPropName, pVar, (IErrorLog *)pErrorLog);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IPropertyBag_Read_Stub (for both DCOM and non-DCOM)
// //
// //  Synopsis:   Server-side wrapper function for IPropertyBag::Read.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IPropertyBag_Read_Stub(
//         IPropertyBag * This, LPCOLESTR pszPropName, VARIANT * pVar,
//         IErrorLog * pErrorLog, DWORD varType, IUnknown * pUnkObj)
// {
//     V_VT(pVar) = (VARTYPE) varType;
//     V_BYREF(pVar) = NULL;
// 
//     if (varType == VT_UNKNOWN)
//         V_UNKNOWN(pVar) = pUnkObj;
// 
//     HRESULT hr = This->Read(pszPropName, pVar, pErrorLog);
// 
//     /* Don't want to ref count the same object twice
//      */
//     if (pUnkObj != NULL && pUnkObj == V_UNKNOWN(pVar) && varType==V_VT(pVar)) {
//         V_VT(pVar) = VT_EMPTY;
//         V_UNKNOWN(pVar) = NULL;
//     }
// 
//     return hr;
// }
// 
// HRESULT STDMETHODCALLTYPE _IPropertyBag_Read_Stub(
//         _IPropertyBag * This, LPCOLESTR pszPropName, VARIANT * pVar,
//         _IErrorLog * pErrorLog, DWORD varType, IUnknown * pUnkObj)
// {
//     HRESULT hr;
//     hr = IPropertyBag_Read_Stub(
//             (IPropertyBag *)This, pszPropName, pVar,
//             (IErrorLog *)pErrorLog, varType, pUnkObj);
//     return hr;
// }
// 
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IQuickActivate_QuickActivate_Proxy
// //
// //  Synopsis:   Client-side wrapper function for IQuickActivate::QuickActivate.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IQuickActivate_QuickActivate_Proxy(
//         IQuickActivate * This, QACONTAINER * pQaContainer,
//         QACONTROL * pQaControl)
// {
//     QACONTAINER QaContainer;
// 
//     if (pQaControl->cbSize != sizeof(QACONTROL))
//         return E_INVALIDARG;
// 
//     if (pQaContainer->cbSize < sizeof(QACONTAINER)) {   // older version
//         DWORD * p = (DWORD *) pQaContainer;
//         DWORD * q = (DWORD *) &QaContainer;
//         DWORD i = 0;
// 
//         while (i < pQaContainer->cbSize) {  // copy old struct
//             *q++ = *p++;
//             i += sizeof(DWORD);
//         }
//         while (i < sizeof(QACONTAINER)) {   // NULL the rest
//             *q++ = 0;
//             i += sizeof(DWORD);
//         }
// 
//         pQaContainer = &QaContainer;        // points to local struct
//     }
// 
//     HRESULT hr;
//     hr = IQuickActivate_RemoteQuickActivate_Proxy(
//                 This, pQaContainer, pQaControl);
//     return hr;
// }
// 
// //+-------------------------------------------------------------------------
// //
// //  Function:   IQuickActivate_QuickActivate_Stub
// //
// //  Synopsis:   Server-side wrapper function for IQuickActivate::QuickActivate.
// //
// //--------------------------------------------------------------------------
// HRESULT STDMETHODCALLTYPE IQuickActivate_QuickActivate_Stub(
//         IQuickActivate * This, QACONTAINER * pQaContainer,
//         QACONTROL * pQaControl)
// {
//     HRESULT hr;
//     pQaControl->cbSize = sizeof(QACONTROL);
//     hr = This->QuickActivate(pQaContainer, pQaControl);
//     return hr;
// }
// 


///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//
// The following appear not to have been implemented in OleAutomation either
//
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT STDCALL ITypeInfo_GetIDsOfNames_Stub(ITypeInfo*)
    {
    return E_NOTIMPL;
    }
extern "C" HRESULT STDCALL ITypeInfo_Invoke_Stub(ITypeInfo*)
    {
    return E_NOTIMPL;
    }
extern "C" HRESULT STDCALL ITypeInfo_AddressOfMember_Stub(ITypeInfo*)
    {
    return E_NOTIMPL;
    }
extern "C" HRESULT STDCALL ITypeInfo_ReleaseTypeAttr_Stub(ITypeInfo*)
    {
    return E_NOTIMPL;
    }
extern "C" HRESULT STDCALL ITypeInfo_ReleaseFuncDesc_Stub(ITypeInfo*)
    {
    return E_NOTIMPL;
    }
extern "C" HRESULT STDCALL ITypeInfo_ReleaseVarDesc_Stub(ITypeInfo*)
    {
    return E_NOTIMPL;
    }
extern "C" HRESULT STDCALL ITypeLib_ReleaseTLibAttr_Stub(ITypeLib*)
    {
    return E_NOTIMPL;
    }


///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//
// From rpcoadt.cpp
//
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

// #########################################################################
//
//      Macros
//
// #########################################################################

#define USER_MARSHAL_MARKER     0x72657355
#define WDT_HANDLE_MARKER       WDT_INPROC_CALL

#define WdtpMemoryCopy(Destination, Source, Length) \
    RtlCopyMemory(Destination, Source, Length)
#define WdtpMemorySet(Destination, Source, Fill) \
    RtlFillMemory(Destination, Length, Fill)
#define WdtpZeroMemory(Destination, Length) \
    RtlZeroMemory(Destination, Length)


// #########################################################################
//
//      CLEANLOCALSTORAGE
//
// #########################################################################
ULONG CLEANLOCALSTORAGE_UserSize(ULONG * pFlags, ULONG Offset, CLEANLOCALSTORAGE * pCleanLocalStorage)
    {
    LENGTH_ALIGN(Offset, 3);
    return Offset + 4;
    }

BYTE * CLEANLOCALSTORAGE_UserMarshal(ULONG * pFlags, BYTE * pBuffer, CLEANLOCALSTORAGE * pCleanLocalStorage)
    {
    /* OLE/RPC requires that all pointers being allocated by
     * CoGetMalloc()::IMallocSince.  But there is no guarantee about
     * who manages memory in ITypeInfo::GetTypeAttr(),
     * ITypeInfo::GetFuncDesc(), ITypeInfo::GetVarDesc(), and
     * ITypeLib::GetTLibAttr().  All we know is corresponding Release*()
     * will clean them up, so here is the trick to release memories.
     */
    IUnknown * pUnk = pCleanLocalStorage->pInterface;
    if (pUnk != NULL) 
        {
        PVOID * ppv = (PVOID *)pCleanLocalStorage->pStorage;
        PVOID pv = *ppv;

        if (pv != NULL) 
            {
            switch (pCleanLocalStorage->flags) 
                {
            case 't':
                ((ITypeInfo *)pUnk)->ReleaseTypeAttr((TYPEATTR *)pv);
                break;
            case 'f':
                ((ITypeInfo *)pUnk)->ReleaseFuncDesc((FUNCDESC *)pv);
                break;
            case 'v':
                ((ITypeInfo *)pUnk)->ReleaseVarDesc((VARDESC *)pv);
                break;
            case 'l':
                ((ITypeLib *)pUnk)->ReleaseTLibAttr((TLIBATTR *)pv);
                break;
            default:
                break;
                }

            /* Data has been freed, so don't let DCOM do it again
             * in the UserFree'ing pass
             */
            *ppv = NULL;
            }
        pUnk->Release();
        }

    /* Feed something, anything, to the wire, so DCOM is happy
     */
    ALIGN(pBuffer, 3);
    *(PULONG_LV_CAST pBuffer)++ = 0;
    return pBuffer;
    }

BYTE * CLEANLOCALSTORAGE_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, CLEANLOCALSTORAGE * pCleanLocalStorage)
    {
    ALIGN(pBuffer, 3);
    pCleanLocalStorage->flags = *(PULONG_LV_CAST pBuffer)++;
    return pBuffer;
    }

void CLEANLOCALSTORAGE_UserFree(ULONG * pFlags, CLEANLOCALSTORAGE * pCleanLocalStorage)
    {
    }

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//
// From tiprox.cpp
//
// What's going on here is that in the remote case, a TYPEATTR is in fact
// actually marshalled using the normal NDR engine mechanisms, making a complete
// copy using the task allocator, etc. 
//
// On the stub side, we used a dummy  CLEANLOCALSTORAGE parameter so that it's 
// CLEANLOCALSTORAGE_UserMarshal routine, called on the stub side after the actual 
// TYPEATTR has been marshalled, can do the freeing.
//
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

void DoReleaseDanglingParamDesc(PARAMDESC * pParamdesc)
// Release any PARAMDESCs that are 'dangling' off of the current one.
    {
    if ((pParamdesc->wParamFlags & PARAMFLAG_FHASDEFAULT) != 0) 
        {
        PARAMDESCEX * px = pParamdesc->pparamdescex;
        if (px != NULL) 
            {
            g_oaUtil.VariantClear(&px->varDefaultValue);
            delete px;
            }
        }
    }

void DoReleaseDanglingTypeDesc(TYPEDESC * ptypedesc)
// Release any typedescs that are 'dangling' off of the current one.
    {
    TYPEDESC * ptypedescPrev;
    short iType = 0;
    if (ptypedesc->vt == VT_SAFEARRAY || ptypedesc->vt == VT_PTR || ptypedesc->vt == VT_CARRAY) 
        {
        do  {
            if (ptypedesc->vt == VT_SAFEARRAY || ptypedesc->vt == VT_PTR) 
                {
                ptypedescPrev = ptypedesc;
                ptypedesc = ptypedesc->lptdesc;
                }
            else 
                {
                if (ptypedesc->vt == VT_CARRAY) 
                    {
                    DoReleaseDanglingTypeDesc(&ptypedesc->lpadesc->tdescElem);
                    delete ptypedesc->lpadesc;
                    }
                ptypedescPrev = ptypedesc;
                ptypedesc = NULL;
                }

            if (iType++) 
                {
                delete ptypedescPrev;
                }

            } while (ptypedesc != NULL);
        }
    }

void DoReleaseTypeAttr(TYPEATTR * ptypeattr)
    {
    if (ptypeattr == NULL) 
        {
        return;
        }
    if (ptypeattr->typekind == TKIND_ALIAS) 
        {
        DoReleaseDanglingTypeDesc(&ptypeattr->tdescAlias);
        }
    delete ptypeattr;
    }

void DoReleaseFuncDesc(FUNCDESC * pfuncdesc)
    {
    if (pfuncdesc == NULL) 
        {
        return;
        }
    short iParam;       

    for(iParam = 0; iParam < pfuncdesc->cParams; ++iParam) 
        {
        DoReleaseDanglingTypeDesc(&pfuncdesc->lprgelemdescParam[iParam].tdesc);
        DoReleaseDanglingParamDesc(&pfuncdesc->lprgelemdescParam[iParam].paramdesc);
        }

    delete pfuncdesc->lprgelemdescParam;

    DoReleaseDanglingTypeDesc(&pfuncdesc->elemdescFunc.tdesc);
    DoReleaseDanglingParamDesc(&pfuncdesc->elemdescFunc.paramdesc);
    delete pfuncdesc;
    }

void DoReleaseVarDesc(VARDESC * pvardesc)
    {
    if (pvardesc == NULL) 
        {
        return;
        }
    DoReleaseDanglingTypeDesc(&pvardesc->elemdescVar.tdesc);
    DoReleaseDanglingParamDesc(&pvardesc->elemdescVar.paramdesc);

    if (pvardesc->varkind == VAR_CONST) 
        {
        g_oaUtil.VariantClear(pvardesc->lpvarValue);
        delete pvardesc->lpvarValue;
        }
    delete pvardesc;
    }


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Marshalling engines for various OLE Automation data types
//
// In user mode, we demand load OleAut32.dll and delegate to the routines
// found therein.
//
// In kernel mode, we have our own implementations, cloned from those found
// in OleAut32.  But this code don't run in kernel mode no more.
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ULONG BSTR_UserSize(ULONG * pFlags, ULONG Offset, BSTR * pBstr)
    {
        return (g_oa.get_BSTR_UserSize())(pFlags, Offset, pBstr);
    }

BYTE * BSTR_UserMarshal (ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
    {
        return (g_oa.get_BSTR_UserMarshal())(pFlags, pBuffer, pBstr);
    }

BYTE * BSTR_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
    {
        return (g_oa.get_BSTR_UserUnmarshal())(pFlags, pBuffer, pBstr);
    }

void  BSTR_UserFree(ULONG * pFlags, BSTR * pBstr)
    {
        (g_oa.get_BSTR_UserFree())(pFlags, pBstr);
    }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


ULONG VARIANT_UserSize(ULONG * pFlags, ULONG Offset, VARIANT * pVariant)
    {
        return (g_oa.get_VARIANT_UserSize())(pFlags, Offset, pVariant);
    }

BYTE* VARIANT_UserMarshal (ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
    {
        return (g_oa.get_VARIANT_UserMarshal())(pFlags, pBuffer, pVariant);
    }

BYTE* VARIANT_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
    {
        return (g_oa.get_VARIANT_UserUnmarshal())(pFlags, pBuffer, pVariant);
    }

void VARIANT_UserFree(ULONG * pFlags, VARIANT * pVariant)
    {
        (g_oa.get_VARIANT_UserFree())(pFlags, pVariant);
    }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ULONG OLEAUTOMATION_FUNCTIONS::SafeArraySize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray)
    {
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;
    if (pUserMarshal->pReserve != 0)
        {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (g_oa.get_pfnLPSAFEARRAY_Size())(pFlags, Offset, ppSafeArray, &iid);
        }
    else
        {
        return (g_oa.get_pfnLPSAFEARRAY_UserSize())(pFlags, Offset, ppSafeArray);
        }
    }

BYTE * OLEAUTOMATION_FUNCTIONS::SafeArrayMarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
    {
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;
    if(pUserMarshal->pReserve != 0)
        {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (g_oa.get_pfnLPSAFEARRAY_Marshal())(pFlags, pBuffer, ppSafeArray, &iid);
        }
    else
        {
        return (g_oa.get_pfnLPSAFEARRAY_UserMarshal())(pFlags, pBuffer, ppSafeArray);
        }
    }

BYTE * OLEAUTOMATION_FUNCTIONS::SafeArrayUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
    {
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;
    if(pUserMarshal->pReserve != 0)
        {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (g_oa.get_pfnLPSAFEARRAY_Unmarshal())(pFlags, pBuffer, ppSafeArray, &iid);
        }
    else
        {
        return (g_oa.get_pfnLPSAFEARRAY_UserUnmarshal())(pFlags, pBuffer, ppSafeArray);
        }
    }

void LPSAFEARRAY_UserFree(ULONG * pFlags, LPSAFEARRAY * ppSafeArray)
    {
    (g_oa.get_LPSAFEARRAY_UserFree())(pFlags, ppSafeArray);
    }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\srvcall.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// srvcall.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "invoke.h"

#include <debnot.h>

#define Oi_IGNORE_OBJECT_EXCEPTION_HANDLING     0x10

//////////////////////////////////////////////////////////////////////////
//
// TODO: Make this more fully use the RPC code base.
//
//////////////////////////////////////////////////////////////////////////

long __stdcall N(ComPs_NdrStubCall2)(
// Invoke a server side call
        struct IRpcStubBuffer __RPC_FAR *    pThis,
        struct IRpcChannelBuffer __RPC_FAR * pChannel,
        PRPC_MESSAGE                         pRpcMsg,
        unsigned long __RPC_FAR *            pdwStubPhase
        )
{
#ifdef _PPC_
    double aDouble[13];
    long iDouble = 0;
#endif //_PPC_

    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    ushort                  ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pFormatParam;

    ushort                  StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    uchar *                 pArgBuffer;
    uchar *                 pArg;
    uchar **                ppArg;

    PPARAM_DESCRIPTION      Params;
    INTERPRETER_FLAGS       InterpreterFlags;
    INTERPRETER_OPT_FLAGS   OptFlags;
    long                    NumberParams;

    double                  OutSpace[16];
    double *                OutSpaceCurrent = &OutSpace[16];

    ushort                  ConstantBufferSize;
    BOOL                    HasExplicitHandle;
    BOOL                    fBadStubDataException = FALSE;
    long                    n;

//  NDR_PIPE_DESC           PipeDesc;
//  NDR_PIPE_MESSAGE        PipeMsg[ PIPE_MESSAGE_MAX ];

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
//  NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ProcNum = (USHORT)(pRpcMsg->ProcNum);

#ifndef _WIN64
    Win4Assert( ! ((unsigned long)pRpcMsg->Buffer & 0x7) &&
                "marshaling buffer misaligned at server" );
#else
    Win4Assert( ! (PtrToUlong(pRpcMsg->Buffer) & 0x7) &&
                "marshaling buffer misaligned at server" );
#endif

    //
    // If OLE, Get a pointer to the stub vtbl and pServerInfo. Else
    // just get the pServerInfo the usual way.
    //
/*  if ( pThis ) */
    { 
        //
        // pThis is (in unison now!) a pointer to a pointer to a vtable.
        // We want some information in this header, so dereference pThis
        // and assign that to a pointer to a vtable. Then use the result
        // of that assignment to get at the information in the header.
        //
        IUnknown *              pSrvObj;
        CInterfaceStubVtbl *    pStubVTable;

        pSrvObj = InterfaceStub::From(pThis)->m_punkServerObject;

        DispatchTable = * (SERVER_ROUTINE **) (pSrvObj);

        pStubVTable = (CInterfaceStubVtbl *)
                      (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;
    }
/*  else
    {
        pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
        pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
        DispatchTable = pServerInfo->DispatchTable;
    } */

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);

    HasExplicitHandle = ! pFormat[0];
    InterpreterFlags = *((PINTERPRETER_FLAGS)&pFormat[1]);
    pFormat += InterpreterFlags.HasRpcFlags ? 8 : 4;
    StackSize = *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    pArgBuffer = (BYTE*)alloca(StackSize);

    //StubMsg.FullPtrXlatTables = 0;

    //
    // Yes, do this here outside of our RpcTryFinally block.  If we
    // can't allocate the arg buffer there's nothing more to do, so
    // raise an exception and return control to the RPC runtime.
    //
    if ( ! pArgBuffer )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    //
    // Zero out the arg buffer.  We must do this so that parameters
    // are properly zeroed before we start unmarshalling.  If we catch
    // an exception before finishing the unmarshalling we can not leave
    // parameters in an unitialized state since we have to do a freeing
    // pass.
    //
    MIDL_memset( pArgBuffer,
                 0,
                 StackSize );
/*
    if ( HasExplicitHandle )
    {
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        if ( *pFormat == FC_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + *((ushort *)&pFormat[2]);

            if ( IS_HANDLE_PTR(pFormat[1]) )
                {
                pArg = (BYTE*)(*((void **)pArg));
                }

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }

        pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 : 6;
    }
*/
    //
    // Get new interpreter info.
    //
    ConstantBufferSize = *((ushort *)&pFormat[2]);
    OptFlags = *((PINTERPRETER_OPT_FLAGS)&pFormat[4]);
    NumberParams = (long) pFormat[5];

    Params = (PPARAM_DESCRIPTION) &pFormat[6];

    //
    // Set up for context handle management.
    //
    //StubMsg.SavedContextHandles = CtxtHndl;

    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
    {
        //
        // If OLE, put pThis in first dword of stack.
        //
/*      if ( pThis ) */
        {
            *((void **)pArgBuffer) = (void *)InterfaceStub::From(pThis)->m_punkServerObject;
        }

        //
        // Initialize the Stub message.
        //
/*      if ( ! pChannel )
        {
            if ( OptFlags.HasPipes )
            {
                NdrServerInitializePartial( pRpcMsg,
                                            &StubMsg,
                                            pStubDesc,
                                            ConstantBufferSize );
            }
            else
            {
                NdrServerInitializeNew( pRpcMsg,
                                        &StubMsg,
                                        pStubDesc );
            }
        }
        else
        { */
            NdrStubInitialize( pRpcMsg,
                               &StubMsg,
                               pStubDesc,
                               pChannel );
            SetMarshalFlags(&StubMsg, MSHLFLAGS_NORMAL);

/*      } */

        // Raise exceptions after initializing the stub.

//      if ( InterpreterFlags.FullPtrUsed )
//          StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

//      if ( OptFlags.ServerMustSize & OptFlags.HasPipes )
//          RpcRaiseException( RPC_X_WRONG_PIPE_VERSION );

        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        StubMsg.StackTop = pArgBuffer;

/*
        if ( OptFlags.HasPipes )
            NdrPipesInitialize(  & StubMsg,
                                (PFORMAT_STRING) Params,
                                & PipeDesc,
                                & PipeMsg[0],
                                pArgBuffer,
                                NumberParams );
*/
        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
//      if ( InterpreterFlags.RpcSsAllocUsed )
//          NdrRpcSsEnableAllocate( &StubMsg );

        RpcTryExcept
        {
            //
            // Do endian/floating point conversions if needed.
            //
            if ( (pRpcMsg->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            {
                NdrConvert2( &StubMsg,
                             (PFORMAT_STRING) Params,
                             (long) NumberParams );
            }

            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------

            for ( n = 0; n < NumberParams; n++ )
                {
                if ( ! Params[n].ParamAttr.IsIn  ||
                     Params[n].ParamAttr.IsPipe )
                    continue;

                pArg = pArgBuffer + Params[n].StackOffset;

                if ( Params[n].ParamAttr.IsBasetype )
                    {
                    //
                    // Check for a pointer to a basetype.  Set the arg pointer
                    // at the correct buffer location and you're done.
                    //
                    if ( Params[n].ParamAttr.IsSimpleRef )
                        {
                        ALIGN( StubMsg.Buffer,
                               SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

                        *((uchar **)pArg) = StubMsg.Buffer;

                        StubMsg.Buffer +=
                            SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );
                        }
                    else
                        {
                        NdrUnmarshallBasetypeInline(
                            &StubMsg,
                            pArg,
                            Params[n].SimpleType.Type );
#ifdef _ALPHA_
                        if((FC_FLOAT == Params[n].SimpleType.Type) &&
                           (n < 5))
                            {
                            //Special case for top-level float on Alpha.
                            //Promote float to double.
                            *((double *) pArg) = *((float *)(pArg));
                            }
#endif //_ALPHA_
#ifdef _PPC_
                        //PowerPC support for top-level float and double.
                        if(FC_FLOAT == Params[n].SimpleType.Type &&
                           iDouble < 13)
                            {
                            aDouble[iDouble] = *((float *) pArg);
                            iDouble++;
                            }
                        else if(FC_DOUBLE == Params[n].SimpleType.Type &&
                                iDouble < 13)
                            {
                            aDouble[iDouble] = *((double *) pArg);
                            iDouble++;
                            }
#endif //_PPC_
                        }

                    continue;
                    } // IsBasetype

                //
                // This is an initialization of [in] and [in,out] ref pointers
                // to pointers.  These can not be initialized to point into the
                // rpc buffer and we want to avoid doing a malloc of 4 bytes!
                //
                if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                    {                      
                    if(OutSpaceCurrent - Params[n].ParamAttr.ServerAllocSize >= OutSpace)
                        {
                        OutSpaceCurrent -= Params[n].ParamAttr.ServerAllocSize;
                        *((void **)pArg) = OutSpaceCurrent;
                        }
                    else
                        {
                        *((void **)pArg) = alloca(Params[n].ParamAttr.ServerAllocSize * 8);
                        }

                    // Triple indirection - cool!
                    **((void ***)pArg) = 0;
                    }

                ppArg = Params[n].ParamAttr.IsByValue ? &pArg : (uchar **)pArg;

                pFormatParam = pStubDesc->pFormatTypes +
                               Params[n].TypeOffset;

				NdrTypeUnmarshall( &StubMsg,
								   ppArg,
								   pFormatParam,
								   FALSE );
                }
            }
        RpcExcept( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
            {
            // Filter set in rpcndr.h to catch one of the following
            //     STATUS_ACCESS_VIOLATION
            //     STATUS_DATATYPE_MISALIGNMENT
            //     RPC_X_BAD_STUB_DATA

            fBadStubDataException = TRUE;
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }
        RpcEndExcept

        //
        // Do [out] initialization.
        //
        for ( n = 0; n < NumberParams; n++ )
            {
            if ( Params[n].ParamAttr.IsIn     ||
                 Params[n].ParamAttr.IsReturn ||
                 Params[n].ParamAttr.IsPipe  )
                continue;

            pArg = pArgBuffer + Params[n].StackOffset;

            //
            // Check if we can initialize this parameter using some of our
            // stack.
            //
            if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                {
                    if(OutSpaceCurrent - Params[n].ParamAttr.ServerAllocSize >= OutSpace)
                        {
                        OutSpaceCurrent -= Params[n].ParamAttr.ServerAllocSize;
                        *((void **)pArg) = OutSpaceCurrent;
                        }
                    else
                        {
                        *((void **)pArg) = alloca(Params[n].ParamAttr.ServerAllocSize * 8);
                        }

                MIDL_memset( *((void **)pArg),
                             0,
                             Params[n].ParamAttr.ServerAllocSize * 8 );
                continue;
                }
            else if ( Params[n].ParamAttr.IsBasetype )
                {
                *((void **)pArg) = alloca(8);
                continue;
                };

            pFormatParam = pStubDesc->pFormatTypes + Params[n].TypeOffset;

            NdrOutInit( &StubMsg,
                        pFormatParam,
                        (uchar **)pArg );
            }

        if ( pRpcMsg->BufferLength  <
             (uint)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
            {
            Win4Assert( 0 && "NdrStubCall2 unmarshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

        //
        // Unblock the first pipe; this needs to be after unmarshalling
        // because the buffer may need to be changed to the secondary one.
        // In the out only pipes case this happens immediately.
        //

//      if ( OptFlags.HasPipes )
//          NdrMarkNextActivePipe( & PipeDesc, NDR_IN_PIPE );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        if( pFormat[1] & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING )
            *pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;
        else
            *pdwStubPhase = STUB_CALL_SERVER;

        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       returnValue;

/*          if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else */
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);
           
            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && OptFlags.HasReturn )
                ArgNum--;

            returnValue = Invoke(pFunc, 
                                 (REGISTER_TYPE *)pArgBuffer,
#ifdef _PPC_
                                aDouble,
#endif //_PPC_
                                ArgNum);

            if(OptFlags.HasReturn)            
                ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = returnValue;
            }

        *pdwStubPhase = STUB_MARSHAL;

/*      if ( OptFlags.HasPipes )
            {
            NdrIsAppDoneWithPipes( & PipeDesc );
            StubMsg.BufferLength += ConstantBufferSize;
            }
        else */
            StubMsg.BufferLength = ConstantBufferSize;

        if ( ! OptFlags.ServerMustSize )
            goto DoGetBuffer;

//      if ( OptFlags.HasPipes )
//          RpcRaiseException( RPC_X_WRONG_PIPE_VERSION );

        //
        // Buffer size pass.
        //
        for ( n = 0; n < NumberParams; n++ )
            {
            if ( ! Params[n].ParamAttr.IsOut || ! Params[n].ParamAttr.MustSize )
                continue;

            pArg = pArgBuffer + Params[n].StackOffset;

            if ( ! Params[n].ParamAttr.IsByValue )
                pArg = (BYTE*)(*((void **)pArg));

            pFormatParam = pStubDesc->pFormatTypes +
                           Params[n].TypeOffset;

			NdrTypeSize( &StubMsg,
						 pArg,
						 pFormatParam );
            }

DoGetBuffer :

/*      if ( ! pChannel )
            {
            if ( OptFlags.HasPipes && PipeDesc.OutPipes )
                {
                NdrGetPartialBuffer( & StubMsg );
                StubMsg.RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
                }
            else
                NdrGetBuffer( &StubMsg,
                              StubMsg.BufferLength,
                              0 );
            }
        else */
            NdrStubGetBuffer( pThis,
                              pChannel,
                              &StubMsg );

        //
        // Marshall pass.
        //
        for ( n = 0; n < NumberParams; n++ )
            {
            if ( ! Params[n].ParamAttr.IsOut  ||
                 Params[n].ParamAttr.IsPipe )
                continue;

            pArg = pArgBuffer + Params[n].StackOffset;

            if ( Params[n].ParamAttr.IsBasetype )
                {
                //
                // For pointers to basetype, simply deref the arg pointer and
                // continue.
                //
                if ( Params[n].ParamAttr.IsSimpleRef )
                    pArg = *((uchar **)pArg);

                ALIGN( StubMsg.Buffer,
                       SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

                RtlCopyMemory(
                    StubMsg.Buffer,
                    pArg,
                    (uint)SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type ) );

                StubMsg.Buffer +=
                    SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

                continue;
                }

            if ( ! Params[n].ParamAttr.IsByValue )
                pArg = (BYTE*)(*((void **)pArg));

            pFormatParam = pStubDesc->pFormatTypes +
                           Params[n].TypeOffset;

			NdrTypeMarshall( &StubMsg,
							 pArg,
							 pFormatParam );
            }

        if ( pRpcMsg->BufferLength <
                 (uint)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
            {
            Win4Assert( 0 && "NdrStubCall2 marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

        pRpcMsg->BufferLength = PtrToUlong(StubMsg.Buffer) - PtrToUlong(pRpcMsg->Buffer);
        }
    RpcFinally
        {
        // Don't free the params if we died because of bad stub data
        // when unmarshaling.

        if ( ! (fBadStubDataException  &&  *pdwStubPhase == STUB_UNMARSHAL) )
            {
            //
            // Free pass.
            //
            for ( n = 0; n < NumberParams; n++ )
			    {
                if ( ! Params[n].ParamAttr.MustFree )
                    continue;
    
                pArg = pArgBuffer + Params[n].StackOffset;
    
                if ( ! Params[n].ParamAttr.IsByValue )
                    pArg = (BYTE*)(*((void **)pArg));
    
                pFormatParam = pStubDesc->pFormatTypes +
                               Params[n].TypeOffset;
    				
				if (pArg)
				{
					StubMsg.fDontCallFreeInst =
						Params[n].ParamAttr.IsDontCallFreeInst;					

					NdrTypeFree(&StubMsg, pArg,	pFormatParam );
				}
    
                //
                // We have to check if we need to free any simple ref pointer,
                // since we skipped it's NdrPointerFree call.  We also have
                // to explicitly free arrays and strings.  But make sure it's
                // non-null and not sitting in the buffer.
                //
                if ( Params[n].ParamAttr.IsSimpleRef ||
                     IS_ARRAY_OR_STRING(*pFormatParam) )
                    {
                    //
                    // Don't free [out] params that we're allocated on the
                    // interpreter's stack.
                    //
                    if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                        continue;
    
                    //
                    // We have to make sure the array/string is non-null in case we
                    // get an exception before finishing our unmarshalling.
                    //
                    if ( pArg &&
                         ( (pArg < StubMsg.BufferStart) ||
                           (pArg > StubMsg.BufferEnd) ) )
                        (*StubMsg.pfnFree)( pArg );
                    }
                } // for
            } // if !fBadStubData

        //
        // Deferred frees.  Actually, this should only be necessary if you
        // had a pointer to enum16 in a *_is expression.
        //

        //
        // Free any full pointer resources.
        //
//      if ( StubMsg.FullPtrXlatTables )
//          NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        //
        // Disable rpcss allocate package if needed.
        //
//      if ( InterpreterFlags.RpcSsAllocUsed )
//          NdrRpcSsDisableAllocate( &StubMsg );

        //
        // Clean up pipe objects
        //

//      if ( OptFlags.HasPipes )
//          NdrPipesDone( & StubMsg );

        }
    RpcEndFinally

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\stublessclient.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stublessclient.h
//

extern "C" const PFN_VTABLE_ENTRY g_StublessProxyVtable[];

#include "midlver.h"

inline const CInterfaceProxyHeader* HeaderFromProxy(const void* This)
// Given the This pointer of the hooked interface of a stubless proxy, return
// a pointer to the CInterfaceProxyHeader info at the start of its vtable
//
    {
    // struct CINTERFACE_PROXY_VTABLE( n )
    //     {
    //     CInterfaceProxyHeader header;
    //     void* vtbl[ n ];                         <= *This points to here
    //     }
    //
    return &(*((const CInterfaceProxyHeader**)This))[-1];
    }

inline const CInterfaceStubHeader* HeaderFromStub(IRpcStubBuffer* This)
    {
    // struct CInterfaceStubVtbl
    //  {
    //  CInterfaceStubHeader header;
    //  IRpcStubBufferVtbl Vtbl;                    <= *This points to here
    //  };
    //
    return &(*((const CInterfaceStubHeader**)This))[-1];
    }


inline unsigned short GetDibProcFormat(const CInterfaceProxyHeader* ProxyHeader, int iMethod)
// Given the midl meta data for a particular interface, return the offset into the format string for a given iMethod
    {
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo        = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;
    unsigned short              ProcFormatOffset = ProxyInfo->FormatStringOffset[iMethod];
    return ProcFormatOffset;
    }
inline unsigned short GetDibProcFormat(const ProxyFileInfo *pProxyFileInfo, long j, int iMethod)
// Given the midl meta data for a whole IDL file, return the offset into the format string of interface j, method iMethod
    {
    const CInterfaceProxyHeader* ProxyHeader = &pProxyFileInfo->pProxyVtblList[j]->header;
    return GetDibProcFormat(ProxyHeader, iMethod);
    }



inline PFORMAT_STRING GetFormatString(const CInterfaceProxyHeader* ProxyHeader, int iMethod)
    {
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo        = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;
    unsigned short              ProcFormatOffset = ProxyInfo->FormatStringOffset[iMethod];
    return &ProxyInfo->ProcFormatString[ProcFormatOffset];
    }
inline PFORMAT_STRING GetFormatString(const ProxyFileInfo *pProxyFileInfo, long j, int iMethod)
    {
    const CInterfaceProxyHeader* ProxyHeader = &pProxyFileInfo->pProxyVtblList[j]->header;
    return GetFormatString(ProxyHeader, iMethod);
    }


inline const IID* TxfNdrGetProxyIID(const void* This)
// Given a pointer to a stubless proxy vtable, return the IID that it services
//
    {
    return HeaderFromProxy(This)->piid;
    }


inline const IID* NdrpGetStubIID(IRpcStubBuffer *This)
// Given a pointer to the public interface of a stub, return the IID that it services
//
    {
    return HeaderFromStub(This)->piid;
    }

inline void GetStackSize(PFORMAT_STRING pFormat, ULONG* pcbArgs)
// Given the format string for a method, figure out the number of bytes that must be 
// popped from the stack to return from a call to such a method
//
    {
    INTERPRETER_FLAGS   interpreterFlags = *((PINTERPRETER_FLAGS)&pFormat[1]);
    if (interpreterFlags.HasRpcFlags) pFormat += 4;
    ULONG               totalStackSize   = *(USHORT*)(&pFormat[4]);
    PFORMAT_STRING      pNewProcDescr    = &pFormat[6];
    INTERPRETER_OPT_FLAGS optFlags       = *((INTERPRETER_OPT_FLAGS*)&pNewProcDescr[4]);
    ULONG               numberParamsRet  =                            pNewProcDescr[5];     // includes return value
    PPARAM_DESCRIPTION  params           =      (PPARAM_DESCRIPTION)(&pNewProcDescr[6]);
    //
    // Figure out how many bytes caller has to pop from stack if he's responsible therefore.
    // 
    if (optFlags.HasReturn)
        {
        // The stack offset of the return value tells us how many bytes are on the stack.
        //
        *pcbArgs = params[numberParamsRet-1].StackOffset;
        }
    else
        {
        // There was no return value. Never happens with today's interfaces, since MIDL enforces
        // a return value of HRESULT. However, we do make a good guess at it here.
        //
        *pcbArgs = totalStackSize;
        }
    }

inline HRESULT SanityCheck(const CInterfaceStubHeader* pHeader, ULONG iMethod)
// Make sure that the meta data we have for this method at least smells somewhat pretty
//
{
#ifdef _DEBUG

        // Check the method number for sanity before we try to use it to index into the meta data
        //
        if ((iMethod >= pHeader->DispatchTableCount) || (iMethod < 3))          return RPC_E_INVALIDMETHOD;

        PMIDL_SERVER_INFO pServerInfo  = (PMIDL_SERVER_INFO) pHeader->pServerInfo;
        PMIDL_STUB_DESC   pStubDesc    = pServerInfo->pStubDesc;
        unsigned short    formatOffset = pServerInfo->FmtStringOffset[iMethod];
        PFORMAT_STRING    pFormat      = &pServerInfo->ProcString[formatOffset];
        //
        // Since MIDL 3.0.39 there has been an explicit proc flag that indicates which interpeter to 
        // call. Earlier versions used some other means that we don't support.
        //
        if ( !(MIDL_VERSION_3_0_39 <= pServerInfo->pStubDesc->MIDLVersion) )    return RPC_E_VERSION_MISMATCH;
        //
        // Our code will assume elsewhere that the format string of a procedure descriptor
        // doesn't have an explicit_handle_description. It's presence is signified by a
        // handle_type of 0. handle_type is the first element in the format string
        //
        if (0 == pFormat[0])                                                    return RPC_E_VERSION_MISMATCH;
    
#endif

    return S_OK;
}

inline unsigned GetDelegatedMethodCount(const CInterfaceStubHeader* pHeader)
// Return the number of methods, which is always at least three, which are not herein defined.
//
    {
    PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) pHeader->pServerInfo;
    //
    const unsigned cMethod = pHeader->DispatchTableCount;
    //
    for (unsigned iMethod = cMethod - 1; iMethod >= 3; iMethod--)
        {
        if ( (unsigned short)(-1) == pServerInfo->FmtStringOffset[iMethod] )
            return iMethod + 1;
        }
    return 3;
    }



#ifdef KERNELMODE
    #define CLSCTX_PROXY_STUB   (CLSCTX_KERNEL_SERVER | CLSCTX_PS_DLL)
#else
    #define CLSCTX_PROXY_STUB   (CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL)
#endif


BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList, 
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\stublessclient.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stublessclient.cpp
//
// Declaration of the stubless client implementation: vtable, etc
//
#include "stdpch.h"
#include "common.h"



inline InterfaceProxy* NdrGetProxyBuffer(IN void *pThis)
// The "this" pointer points to the m_pProxyVtbl field in the InterfaceProxy structure. The
// NdrGetProxyBuffer function returns a pointer to the top of the CStdProxyBuffer structure.
//
    {
    return CONTAINING_RECORD(pThis, InterfaceProxy, m_pProxyVtbl);
    }



HRESULT STDMETHODCALLTYPE N(ComPs_IUnknown_QueryInterface_Proxy)(IUnknown* This, REFIID riid, void** ppv)
    {
    return NdrGetProxyBuffer(This)->QueryInterface(riid, ppv);
    };
ULONG STDMETHODCALLTYPE N(ComPs_IUnknown_AddRef_Proxy)(IUnknown* This)
    {
    return NdrGetProxyBuffer(This)->AddRef();
    };
ULONG STDMETHODCALLTYPE N(ComPs_IUnknown_Release_Proxy)(IUnknown* This)
    {
    return NdrGetProxyBuffer(This)->Release();
    };


HRESULT STDCALL StublessClient_OnCall(void* This, ULONG iMethod, void* pvArgs, OUT ULONG* pcbArgs)
    {
    // The header immediately precedes the vtable pointer. It's the root of all access to the
    // information we have about the proxy.
    // 
    // struct CINTERFACE_PROXY_VTABLE( n )
    //     {
    //     CInterfaceProxyHeader header;
    //     void* vtbl[ n ];                         <= *This points to here
    //     }
    //
    const CInterfaceProxyHeader*ProxyHeader     = HeaderFromProxy(This);
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo       = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;
    PFORMAT_STRING              ProcFormat      = GetFormatString(ProxyHeader, iMethod);
    //
    // We don't support the older style MIDL compilers
    //
    ASSERT(ProxyInfo->pStubDesc->MIDLVersion >= MIDL_VERSION_3_0_39);

    CLIENT_CALL_RETURN Return; Return.Simple = E_UNEXPECTED;
    //
    // Since MIDL 3.0.39 we have a proc flag that indicates
    // which interpeter to call. This is because the NDR version
    // may be bigger than 1.1 for other reasons.
    //
    if (ProcFormat[1] & Oi_OBJ_USE_V2_INTERPRETER)
        {
        Return = NdrClientCall2(ProxyInfo->pStubDesc, ProcFormat, pvArgs);
        }
    else
        {
        // REVIEW: Probably will never see this one
        //
        // Return = NdrClientCall(ProxyInfo->pStubDesc, ProcFormat, pvArgs);
        Return.Simple = RPC_E_UNEXPECTED;
        }
    //
    // Figure out how many bytes client needs to pop
    //
    GetStackSize(ProcFormat, pcbArgs);

    return (HRESULT)Return.Simple;
    }

////////////////////////////////////////////////////////////////////////////////////////////
//
// Definition of the method thunks for StublessClient. There are 1024 of them, which imposes
// an upper limit number of methods in an interface, the same as is currently the case in MTS.
//
// Kudos to the original MTS implementors, from whom this technology is lifted.
//
////////////////////////////////////////////////////////////////////////////////////////////

#define methname(i) __StublessClient_meth##i

//
/////////////////////////////////////////////////////////////////////////
//
#ifdef _X86_

#define meth(i)                                                         \
HRESULT __declspec(naked) methname(i)(void* const this_, ...)           \
    {                                                                   \
    __asm mov eax,i                                                     \
    __asm jmp StublessClientThunk                                       \
    }


void __declspec(naked) StublessClientThunk(void* const this_, ...)
    {
    __asm {
        // link the stack frame (for debug-ability mostly)
        push     ebp            // link the stack frame
        mov      ebp, esp       //      ...

        // call this->OnCall(imeth, pvArgs, &cbArgs);
        sub     esp,4           // reserve space for cbArgs
        lea     ecx,[esp]
        push    ecx             // push &cbArgs
        
        // stack is: [esp+0]=&cbArgs [esp+4]=cbArgs [esp+8]=frame pointer [esp+12]=retaddr [esp+16]=this
        lea     ecx,[esp+16]    // &this
        push    ecx             // push pvArgs
        push    eax             // push imeth
        mov     ecx,[ecx]       // fetch this
        push    ecx             // push this
        call    StublessClient_OnCall
        
        // upon return from this->OnCall(),
        //
        //  eax     == HRESULT
        //  [esp]   == cbArgs: we reserved space for it just above
        //
        // Pop argument size, then pop arguments, then return.
        //
        pop edx                 // pop cbArgs, the argument size out parameter set by this->OnCall(imeth, &cbArgs)
        pop ebp                 // unlink stack frame
        pop ecx                 // caller return address
        add esp,edx             // pop caller arguments (including 'this', the argument #0)
        jmp ecx                 // return to caller
        }
    }

#endif // _X86_

//
/////////////////////////////////////////////////////////////////////////
//
//

#if defined(_AMD64_)
#define meth(i)                                                         \
HRESULT methname(i)(void * const this_, ...)                            \
    {                                                                   \
    DWORD cbArgs;                                                       \
    return StublessClient_OnCall(this_, i, (void *)&this_, &cbArgs);    \
    }
#endif

/////////////////////////////////////////////////////////////////////////
#if defined(_IA64_)
//BUGBUG this isn't defined right yet
// neither __declspec(naked) nor _asm supported on IA64
#define meth(i)                                                         \
HRESULT methname(i)(void* const this_, ...)                             \
    {                                                                   \
        return (S_OK);                                                  \
    }
#endif
//
/////////////////////////////////////////////////////////////////////////


#include "vtableimpl.h"

defineVtableMethods()

defineVtable(g_StublessProxyVtable, N(ComPs_IUnknown_QueryInterface_Proxy), N(ComPs_IUnknown_AddRef_Proxy), N(ComPs_IUnknown_Release_Proxy))

////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\tiutil.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// tiutil.h
//
// Utility stuff for typeinfo.cpp etc.


////////////////////////////////////////////////////////////////////////////
//
// From oa\src\dispatch\oledisp.h
//
// VT_VMAX is the first VARENUM value that is *not* legal in a VARIANT.
// REVIEW -rga: Is this the current and correct value?
//
#define VT_VMAX     VT_DECIMAL+1
//
// The largest unused value in VARENUM enumeration
//
#define VT_MAX      (VT_CLSID+1)
//
// This is a special value that is used internally for marshaling interfaces.
//
// REVIEW -rga: Does this ever go on the wire? If so, then we're ****ed, since 
// VT_VERSIONED_STREAM has been added beyond VT_CLSID.
//
#define VT_INTERFACE VT_MAX
#if defined(_WIN64)
#define VT_MULTIINDIRECTIONS (VT_TYPEMASK - 1)
#endif
//
// Following is the internal definition of a VARIANT of type VT_INTERFACE.
// This contains an IUnknown*, and its IID. If a VARIANT is of type
// VT_INTERFACE, it can be cast to this type and the appropriate components
// extracted.
//
// Note: the following struct must correctly overlay a VARIANT
//
struct VARIANTX
    {
    VARTYPE vt;
    unsigned short wReserved3;	    // assumes sizeof(piid) == 4
    IID* piid;		                // ptr to IMalloc allocated IID
    union
        {
        IUnknown*  punk;	        // VT_INTERFACE
        IUnknown** ppunk;	        // VT_BYREF | VT_INTERFACE
        };
    unsigned long dwReserved;	    // assumes sizeof(punk) == 4
    };

////////////////////////////////////////////////////////////////////////////
//
// From oa\src\dispatch\oautil.h

#define FADF_FORCEFREE  0x1000  /* SafeArrayFree() ignores FADF_STATIC and frees anyway */

////////////////////////////////////////////////////////////////////////////

#define IfFailGo(expression, label)	\
    { hresult = (expression);		\
      if(FAILED(hresult))	        \
	goto label;         		    \
    }

#define IfFailRet(expression)		    \
    { HRESULT hresult = (expression);	\
      if(FAILED(hresult))	            \
	return hresult;			            \
    }

////////////////////////////////////////////////////////////////////////////
//
// From oa\src\dispatch\rpcallas.cpp

#define PREALLOCATE_PARAMS           16         // prefer stack to malloc
#define MARSHAL_INVOKE_fakeVarResult 0x020000   // private flags in HI word
#define MARSHAL_INVOKE_fakeExcepInfo 0x040000
#define MARSHAL_INVOKE_fakeArgErr    0x080000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\typeinfo.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft Transaction Server (Microsoft Confidential)

 @doc
 @module typeinfo.H : Provides meta table info for an IID given it's ITypeInfo
                      Borrowed from \\kernel\razzle3\rpc\ndr20
 
 Description:<nl>
        Generates -Oi2 proxies and stubs from an ITypeInfo. 
-------------------------------------------------------------------------------
Revision History:

 @rev 0     | 04/16/98 | Gaganc  | Created
 @rev 1     | 07/16/98 | BobAtk  | Cleaned, fixed leaks etc
---------------------------------------------------------------------------- */

#ifndef _TYPEINFO_H_
#define _TYPEINFO_H_

#include "cache.h"
#include <debnot.h>

//extern "C" {
//#include "ndrp.h"
//#include "ndrole.h"
//#include "rpcproxy.h"
//}

#include <ndrtoken.h>
#include <ndrtypegen.h>

/////////////////////////////////////////////////////////////////////////////////////
//
// 
//
/////////////////////////////////////////////////////////////////////////////////////

struct METHOD_DESCRIPTOR
{
	LPWSTR		m_szMethodName;
	short		m_cParams;
	VARTYPE*	m_paramVTs;
};

/////////////////////////////////////////////////////////////////////////////////////
//
// A vtable for a type-info-based interceptor, and a cache thereof
//
/////////////////////////////////////////////////////////////////////////////////////

struct TYPEINFOVTBL : CALLFRAME_CACHE_ENTRY<TYPEINFOVTBL>
    {
    ////////////////////////////////////////////////////////
    //
    // State
    //
    ////////////////////////////////////////////////////////

    LPSTR                    m_szInterfaceName; // our (allocated and owned by us) interface name
    METHOD_DESCRIPTOR*	     m_rgMethodDescs;	// an array, indexed by iMethod of method name/TDESC pairs
    IID                      m_iidBase;         // the iid of our base interface, if any (other than IUnknown)
    MIDL_STUB_DESC           m_stubDesc;
    MIDL_SERVER_INFO         m_stubInfo;
    CInterfaceStubVtbl       m_stubVtbl;
    MIDL_STUBLESS_PROXY_INFO m_proxyInfo;
    CInterfaceProxyVtbl      m_proxyVtbl;

    //
    // Other data adjacent in RAM. See CreateVtblFromTypeInfo
    //

    ////////////////////////////////////////////////////////
    //
    // Construction & destruction
    //
    ////////////////////////////////////////////////////////

    TYPEINFOVTBL()
        {
        m_iidBase         = GUID_NULL;
        m_szInterfaceName = NULL;
        m_rgMethodDescs = NULL;
        m_dwReleaseTime = TYPEINFO_RELEASE_TIME_NEVER;
        Zero(&m_stubDesc);
        Zero(&m_stubInfo);
        Zero(&m_stubVtbl);
        Zero(&m_proxyInfo);
        Zero(&m_proxyVtbl);
        }

private:

    ~TYPEINFOVTBL()
        {
        if (m_rgMethodDescs)
            {
            for (ULONG iMethod = 0; iMethod < MethodCount(); iMethod++)
                {
				METHOD_DESCRIPTOR& descriptor = m_rgMethodDescs[iMethod];
                FreeMemory(descriptor.m_szMethodName);
				if (descriptor.m_paramVTs)
					FreeMemory(m_rgMethodDescs[iMethod].m_paramVTs);
                }
            FreeMemory(m_rgMethodDescs);
            }

        FreeMemory(m_szInterfaceName);

		NdrpReleaseTypeFormatString(m_stubDesc.pFormatTypes);
        }

public:

    ULONG MethodCount()
    // Answer the number of methods in this interface
        {
        return m_stubVtbl.header.DispatchTableCount;
        }

    ////////////////////////////////////////////////////////
    //
    // Memory management: supports dynamically sized structures
    //
    ////////////////////////////////////////////////////////

    static void NotifyLeaked (TYPEINFOVTBL* pThis)
        {
        DebugTrace (
                   TRACE_TYPEGEN,
                   TAG,
                   "A TYPEINFOVTBL at address %p of type %s still has a reference on shutdown\n",
                   pThis,
                   pThis->m_szInterfaceName
                   );
        Win4Assert (!"An interceptor still has a reference on shutdown. Someone leaked an interface pointer.");
        }
public:

    #ifdef _DEBUG
        void* __stdcall operator new(size_t cbCore, size_t cbTotal, POOL_TYPE poolType, void* retAddr)
            {
            ASSERT(cbCore == sizeof(TYPEINFOVTBL));
            return AllocateMemory_(cbTotal+cbCore, poolType, retAddr);
            }
        void* __stdcall operator new(size_t cbCore, size_t cbTotal, POOL_TYPE poolType=PagedPool)
            {
            ASSERT(cbCore == sizeof(TYPEINFOVTBL));
            return AllocateMemory_(cbTotal+cbCore, poolType, _ReturnAddress());
            }
    #else
        void* __stdcall operator new(size_t cbCore, size_t cbTotal, POOL_TYPE poolType=PagedPool)
            {
            return AllocateMemory(cbTotal+cbCore, poolType);
            }
    #endif

    }; 

/////////////////////////////////////////////////////////////////////////////////////
//
// A structure that stores cached GetInterfaceHelperClsid lookups
//
/////////////////////////////////////////////////////////////////////////////////////

struct INTERFACE_HELPER_CLSID : CALLFRAME_CACHE_ENTRY<INTERFACE_HELPER_CLSID>
    {
    CLSID m_clsid;
    BOOL m_fDisableTypeLib;
    BOOL m_fDisableAll;
    BOOL m_fFoundHelper;

    INTERFACE_HELPER_CLSID()
    {
        m_clsid = GUID_NULL;
        m_fDisableTypeLib = FALSE;
        m_fDisableAll = FALSE;
        m_fFoundHelper = FALSE;
    }

    ////////////////////////////////////////////////////////
    //
    // Operations
    //
    ////////////////////////////////////////////////////////

    static void NotifyLeaked (INTERFACE_HELPER_CLSID* pThis)
        {

#ifdef _DEBUG

        WCHAR wszClsid [sizeof ("{00000101-0000-0010-8000-00AA006D2EA4}") + 1] = L"";
        CHAR szClsid [sizeof ("{00000101-0000-0010-8000-00AA006D2EA4}") + 1] = "";

        if (StringFromGUID2 (pThis->m_clsid, wszClsid, sizeof (wszClsid) / sizeof (WCHAR)) != 0 &&
           WideCharToMultiByte (
                CP_THREAD_ACP,
                WC_DEFAULTCHAR,
                wszClsid,
                -1,
                szClsid,
                sizeof (szClsid),
                NULL,
                NULL
                )
                )
            {

            DebugTrace (
                       TRACE_TYPEGEN,
                       TAG,
                       "An INTERFACE_HELPER_CLSID at address %p of with clsid %s still has a reference on shutdown\n",
                       pThis,
                       szClsid
                       );
            Win4Assert (!"An INTERFACE_HELPER_CLSID still has a reference on shutdown.");

            }
#endif
        }

    };

typedef struct tagMethodInfo 
    {
    FUNCDESC  * pFuncDesc;
    ITypeInfo * pTypeInfo;

    void Destroy()
        {
        if (pFuncDesc)
            {
            // Release the funcdesc
            //
            pTypeInfo->ReleaseFuncDesc(pFuncDesc);
            pFuncDesc = NULL;
            }
        if (pTypeInfo)
            {
            // Release the type info
            //
            pTypeInfo->Release();
            pTypeInfo = NULL;
            }
        }

    } MethodInfo;

HRESULT GetVtbl(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT TYPEINFOVTBL **     ppVtbl,
	OUT ITypeInfo **		ppBaseTypeInfo);

HRESULT CreateVtblFromTypeInfo(
    IN  ITypeInfo*          ptinfoInterface,
    IN  ITypeInfo*          ptinfoDoc,
    IN  REFIID              riid,
    IN  REFIID              iidBase,
    IN  BOOL                fIsDual,
    IN  USHORT              numMethods,
    IN  MethodInfo   *      rgMethodInfo,
    OUT TYPEINFOVTBL **     ppVtbl);

HRESULT GetFuncDescs        (ITypeInfo *pTypeInfo, MethodInfo *pMethodInfo);
HRESULT ReleaseFuncDescs    (USHORT cMethods, MethodInfo *pMethodInfo);
HRESULT CountMethods        (ITypeInfo * pTypeInfo, USHORT* pNumMethods);

EXTERN_C HRESULT NdrpCreateProxy(
    IN  REFIID              riid, 
    IN  IUnknown *          punkOuter, 
    OUT IRpcProxyBuffer **  ppProxy, 
    OUT void **             ppv);

EXTERN_C HRESULT NdrpCreateStub(REFIID riid, IUnknown* punkServer, IRpcStubBuffer **ppStub);

EXTERN_C void * StublessClientVtbl[];
EXTERN_C const IRpcStubBufferVtbl CStdStubBuffer2Vtbl;

/////////////////////////////////////////////////////////////////

#define rmj 3
#define rmm 0
#define rup 44
#define MIDLVERSION (rmj<<24 | rmm << 16 | rup)

#include "OleAutGlue.h"

/////////////////////////////////////////////////////////////////

#define VTABLE_BASE 0


#endif // _TYPEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\typeinfo.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
   Microsoft Transaction Server (Microsoft Confidential)

   @doc
   @module typeinfo.Cpp : Provides meta table info for an IID given it's ITypeInfo
   Borrowed from \\kernel\razzle3\src\rpc\ndr20\typeinfo.cxx
   and \\kernel\razzle3\src\rpc\ndr20\tiutil.cxx
 
   Description:<nl>
   Generates -Oi2 proxies and stubs from an ITypeInfo. 
   -------------------------------------------------------------------------------
   Revision History:

   @rev 0     | 04/16/98 | Gaganc  | Created
   @rev 1     | 07/16/98 | BobAtk  | Cleaned, fixed leaks etc
   @ref 2     | 09/28/99 | JohnStra| Updated, made Win64 capable
   ---------------------------------------------------------------------------- */

#include "stdpch.h"
#include "common.h"

#include "ndrclassic.h"
#include "txfrpcproxy.h"
#include "typeinfo.h"
#include "tiutil.h"

//////////////////////////////////////////////////////////////////////////////
//
// Miscellany
//
//////////////////////////////////////////////////////////////////////////////

void * __stdcall _LocalAlloc (size_t size)
{
#ifdef _DEBUG
	return TracedAlloc_(size, _ReturnAddress());
#else
	return TracedAlloc(size);
#endif
}

void __stdcall _LocalFree (void * pv)
{
    TracedFree(pv);
}

//////////////////////////////////////////////////////////////////////////////
//
// Globals 
//
//////////////////////////////////////////////////////////////////////////////

CALLFRAME_CACHE<TYPEINFOVTBL>* g_ptiCache = NULL;
CALLFRAME_CACHE<INTERFACE_HELPER_CLSID>* g_pihCache = NULL;

BOOL InitTypeInfoCache()
{
	__try
	{
		// NOTE: The constructors here can throw exceptions because they
		//       contains an XSLOCK. (See concurrent.h)  When this happens,
		//       block the DLL load.
		g_ptiCache = new CALLFRAME_CACHE<TYPEINFOVTBL>();
		g_pihCache = new CALLFRAME_CACHE<INTERFACE_HELPER_CLSID>();
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		g_ptiCache = NULL;
		g_pihCache = NULL;

		return FALSE;
	}

	if(g_ptiCache != NULL && g_pihCache != NULL)
	{

    	if (g_ptiCache->FInit() == FALSE)
    	{
    	    delete g_ptiCache;
    	    g_ptiCache = NULL;
    	}

    	if (g_pihCache->FInit() == FALSE)
    	{
    	    delete g_pihCache;
    	    g_pihCache = NULL;
    	}
    }
	
	if (NULL == g_ptiCache || NULL == g_pihCache)
	{

	    if (g_ptiCache)
	    {
	        delete g_ptiCache;
	        g_ptiCache = NULL;
	    }
	        
	    if (g_pihCache)
	    {
	        delete g_pihCache;
	        g_pihCache = NULL;
	    }
	
	    return FALSE;
	}

	return TRUE;
}

void FreeTypeInfoCache()
{
    if (g_ptiCache)
	{
        g_ptiCache->Shutdown();
        delete g_ptiCache;
        g_ptiCache = NULL;
	}

    if (g_pihCache)
	{
        g_pihCache->Shutdown();
        delete g_pihCache;
        g_pihCache = NULL;
	}
}


//////////////////////////////////////////////////////////////////////////////
//
// Utilities
//
//////////////////////////////////////////////////////////////////////////////

HRESULT GetBaseInterfaceIID(ITypeInfo* ptinfo, IID* piidBase, ITypeInfo** ppBaseTypeInfo)
// Return the IID of the interface from which this typeinfo inherits, if any
{
    HRESULT hr = S_OK;
    *piidBase = GUID_NULL;
    *ppBaseTypeInfo = NULL;

    TYPEATTR* pattr;
    hr = ptinfo->GetTypeAttr(&pattr);
    if (!hr)
	{
        if (pattr->cImplTypes == 1)
		{
            // It inherits from something
            //
            HREFTYPE href;
            hr = ptinfo->GetRefTypeOfImplType(0, &href);
            if (!hr)
			{
                ITypeInfo* ptinfoBase;
                hr = ptinfo->GetRefTypeInfo(href, &ptinfoBase);
                if (!hr)
				{
                    TYPEATTR* pattrBase;
                    hr = ptinfoBase->GetTypeAttr(&pattrBase);
                    if (!hr)
					{
                        //
                        *piidBase = pattrBase->guid;
                        //
                        ptinfoBase->ReleaseTypeAttr(pattrBase);
					}

					// Pass the base typeinfo back
					*ppBaseTypeInfo = ptinfoBase;
				}
			}
		}
        ptinfo->ReleaseTypeAttr(pattr);
	}

    return hr;
}



HRESULT CheckTypeInfo(ITypeInfo *pTypeInfo, ITypeInfo **pptinfoProxy, ITypeInfo** pptinfoDoc, USHORT *pcMethods, BOOL *pfDerivesFromExternal, IID* piidBase, ITypeInfo** ppBaseTypeInfo)
// Check the indicated typeinfo and determine some basic information about it
{
    HRESULT    hr = S_OK;
    TYPEATTR*    pTypeAttr;
    HREFTYPE     hRefType;
    UINT         cbSizeVft = 0;
    ITypeInfo*   ptinfoProxy = NULL;
    ITypeInfo*   ptinfoDoc   = NULL;
    USHORT       cMethods;

    *pfDerivesFromExternal = FALSE;
    *piidBase = __uuidof(IUnknown);
	*ppBaseTypeInfo = NULL;

    hr = pTypeInfo->GetTypeAttr(&pTypeAttr);

    if (!hr)
	{
        if (pTypeAttr->wTypeFlags & TYPEFLAG_FDUAL)
		{
            // A dual interface. By definition it is OA compatible
            //
            *pfDerivesFromExternal = TRUE;

            if (TKIND_DISPATCH == pTypeAttr->typekind)
			{
                // Get the TKIND_INTERFACE type info
                //
                hr = pTypeInfo->GetRefTypeOfImplType((UINT) -1, &hRefType);
                if (!hr)
				{
                    hr = pTypeInfo->GetRefTypeInfo(hRefType, &ptinfoProxy);
                    if (!hr)
					{
                        TYPEATTR * ptattrProxy;
                        hr = ptinfoProxy->GetTypeAttr(&ptattrProxy);
                        if (!hr)
						{
                            ASSERT((TKIND_INTERFACE == ptattrProxy->typekind) && "disp interface has associated non-dual interface with bogus type kind");
                            //
                            cbSizeVft = ptattrProxy->cbSizeVft;
                            //
                            ptinfoProxy->ReleaseTypeAttr(ptattrProxy);
						}
					}
				}
			}
            else if (TKIND_INTERFACE == pTypeAttr->typekind)
			{
                pTypeInfo->AddRef();
                ptinfoProxy = pTypeInfo;
                cbSizeVft = pTypeAttr->cbSizeVft;
			}
            else
			{
                hr = E_FAIL;
			}

            if (!hr) hr = GetBaseInterfaceIID(ptinfoProxy, piidBase, ppBaseTypeInfo);
            if (!hr)
			{
                ptinfoDoc = ptinfoProxy;
                ptinfoDoc->AddRef();
			}
		}
        else if (TKIND_INTERFACE == pTypeAttr->typekind)
		{
            // A non-dual interface
            //
            ptinfoProxy = pTypeInfo;
            ptinfoProxy->AddRef();
            cbSizeVft = pTypeAttr->cbSizeVft;
            //
            if (!hr) hr = GetBaseInterfaceIID(ptinfoProxy, piidBase, ppBaseTypeInfo);
            if (!hr)
			{
                ptinfoDoc = ptinfoProxy;
                ptinfoDoc->AddRef();
			}
		}
        else if (TKIND_DISPATCH == pTypeAttr->typekind)
		{
            // A non-dual disp interface
            //
            // Get the typeinfo of the base interface, which should be IDispatch. Note that dispinterfaces
            // are not (for some strange reason) allowed to inherit from each other, so we don't have to loop.
            //
            ASSERT(pTypeAttr->cImplTypes >= 1);

            HREFTYPE hrefBase;
            hr = pTypeInfo->GetRefTypeOfImplType(0, &hrefBase);
            if (!hr)
			{
                ITypeInfo* ptinfoBase;
                hr = pTypeInfo->GetRefTypeInfo(hrefBase, &ptinfoBase);
                if (!hr)
				{
                    TYPEATTR* pTypeAttrBase;
                    hr = ptinfoBase->GetTypeAttr(&pTypeAttrBase);
                    if (!hr)
					{
                        ASSERT(pTypeAttrBase->guid      == __uuidof(IDispatch));
                        ASSERT(pTypeAttrBase->typekind  == TKIND_INTERFACE);
                        //
                        *piidBase          = pTypeAttrBase->guid;
                        ptinfoProxy        = ptinfoBase;    ptinfoProxy->AddRef();
                        ptinfoDoc          = pTypeInfo;     ptinfoDoc->AddRef();
                        cbSizeVft          = pTypeAttrBase->cbSizeVft;
                        *pfDerivesFromExternal = TRUE;
                        //
                        ptinfoBase->ReleaseTypeAttr(pTypeAttrBase);
					}

					// Pass the base interface back.
					*ppBaseTypeInfo = ptinfoBase;
				}
			}
		}
        else
		{
            hr = E_FAIL;
		}
        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
	}

    cMethods = (USHORT) (cbSizeVft - VTABLE_BASE) / sizeof(void *);

    if (!hr && *pfDerivesFromExternal)
	{
        ASSERT(cMethods >= 7 && "A derived-from-dispatch interface should have at least as many methods as does IDispatch");
	}

    if (cMethods > 1024)
	{
        hr = RPC_E_INVALIDMETHOD; // There are too many methods in the vtable.
	}

    if (!hr)
	{
        *pptinfoProxy = ptinfoProxy;
        *pptinfoDoc   = ptinfoDoc;
        *pcMethods    = cMethods;
	}
    else
	{
        *pptinfoProxy = NULL;
        *pptinfoDoc   = NULL;
        *pcMethods    = 0;
        ::Release(ptinfoProxy);
	}    

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// If you have any problems with the functions below, it may be instructive
// to look at how RPC does it.  We can't use their code directly, but much of
// this code is based on theirs.
//
///////////////////////////////////////////////////////////////////////////////


BOOL FIsLCID(LPWSTR wszLcid)
// Is the given string a valid stringized LCID?
{
    LPWSTR wszEnd;
    LCID lcid = (LCID)wcstoul(wszLcid, &wszEnd, 16);
    //
    // if converting to LCID consumed all characters..
    //
    if (*wszEnd == 0)
    {
        // and its a number the system claims to know about...
        //
        char rgch[32];
        if (GetLocaleInfoA(lcid, LOCALE_NOUSEROVERRIDE | LOCALE_ILANGUAGE, rgch, sizeof(rgch)) > 0)
        {
            // then assume its a valid stringized LCID
            //
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT SzLibIdOfIID(HREG hregTlb, GUID* plibid, WORD* pwMaj, WORD* pwMin, BOOL *pfHasVersion)
{
    HRESULT hr = S_OK;
    //
    // Default value of the TypeLib key is the string form of the LIBID
    //
    PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
    if (!hr)
	{
        hr = GetRegistryValue(hregTlb, L"", &pinfo, REG_SZ);
		Win4Assert(pinfo || FAILED(hr));
        if (!hr && pinfo)
		{
            hr = GuidFromString(StringFromRegInfo(pinfo), plibid);
            FreeMemory(pinfo);
            pinfo = NULL;
		}
	}
    if (!hr)
	{
        *pfHasVersion = FALSE;
        pinfo = NULL;
        hr = GetRegistryValue(hregTlb, L"Version", &pinfo, REG_SZ);
        Win4Assert(pinfo || FAILED(hr));
        if (!hr && pinfo)
		{
			LPWSTR wszVer = StringFromRegInfo(pinfo);
            LPWSTR wszEnd;
            WORD wMaj = (WORD)wcstoul(wszVer, &wszEnd, 16);
            if (*wszEnd == '.') 
			{
                *pwMaj = wMaj;
                *pwMin = (WORD)wcstoul(wszEnd+1, NULL, 16);
                *pfHasVersion = TRUE;
			}
            FreeMemory(pinfo);
		}
        else
            hr = S_OK;
	}

    return hr;
}

HRESULT GetTypeInfoFromIID (REFIID iidIntercepted, ITypeInfo** pptypeinfo)
// Find and return the typeinfo for the indicated IID
//
{
    HRESULT hr = S_OK;
    *pptypeinfo = NULL;

    WCHAR wszKey[MAX_PATH];

    WCHAR wsziid[50];
    StringFromGuid(iidIntercepted, wsziid);
    //
    // Is there a forward entry for this interface?
    //
    BOOL fFound = FALSE;
    HREG hregForward;
    wsprintfW(wszKey, L"\\Registry\\Machine\\Software\\Classes\\Interface\\%s\\Forward", wsziid);
    hr = OpenRegistryKey(&hregForward, HREG(), wszKey);
    if (!hr)
	{
        PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
        hr = GetRegistryValue(hregForward, L"", &pinfo, REG_SZ);
		Win4Assert(pinfo || FAILED(hr));
		if (!hr && pinfo)
		{
            LPWSTR wsz = StringFromRegInfo(pinfo);
            IID iidNew;
            hr = GuidFromString(wsz, &iidNew);
            if (!hr)
			{
                // Recurse on the new entry
                //
                hr = GetTypeInfoFromIID(iidNew, pptypeinfo);
                if (!hr)
				{
                    fFound = TRUE;
				}
			}
            FreeMemory(pinfo);
		}
        CloseRegistryKey(hregForward);
	}
    //
    if (!fFound)
	{
        hr = S_OK;
        //
        // Didn't find it through a forward entry. Find the LibId (and possibly the version #) of 
        // TypeLib containing the definition of the given IID
        //
        wsprintfW(wszKey, L"\\Registry\\Machine\\Software\\Classes\\Interface\\%s\\TypeLib", wsziid);
        HREG hregTlbId;
        hr = OpenRegistryKey(&hregTlbId, HREG(), wszKey);
        if (!hr)
		{
            GUID libId;
            WORD wMajBest, wMinBest;
            WCHAR wszBest[MAX_PATH];
            BOOL fHasVersion;
            //
            // Get the version of the tlb that we seek.
            //
            wMajBest = wMinBest = 0;
            hr = SzLibIdOfIID(hregTlbId, &libId, &wMajBest, &wMinBest, &fHasVersion);
            if (!hr)
			{
                WCHAR wszLibId[39];
                StringFromGuid(libId, &wszLibId[0]);
                //
                // Open the key of the typelib itself
                //
                HREG hregTlb;
                wsprintfW(wszKey, L"\\Registry\\Machine\\Software\\Classes\\TypeLib\\%s", wszLibId);
                hr = OpenRegistryKey(&hregTlb, HREG(), wszKey);
                if (!hr)
				{
                    // Enumerate children of tlb key, looking for the largest sufficient entry
                    //
                    ULONG index = 0;
                    BOOL fStop = FALSE;
                    wszBest[0] = 0;
                    while (!hr && !fStop)
					{
                        LPWSTR wszSubKey;
                        hr = EnumerateRegistryKeys(hregTlb, index, &wszSubKey);
                        if (!hr)
						{
                            if (wszSubKey)
							{
                                LPWSTR wszEnd;
                                WORD wMaj = (WORD)wcstoul(wszSubKey, &wszEnd, 16);
                                if (*wszEnd == '.') 
								{
                                    WORD wMin = (WORD)wcstoul(wszEnd+1, NULL, 16);
                                    //
                                    // If the typelib's iid had a version # associated with it, then we
                                    // want to find the typelib with the same major version #, and a
                                    // minor version # >= the registered one.
                                    // If no version # was specified, then we just try the biggest version
                                    // # we can find, and hope for the best.
                                    //
                                    if ((!fHasVersion && wMaj > wMajBest) || (wMaj == wMajBest && wMin >= wMinBest))
									{
                                        wMajBest = wMaj;
                                        wMinBest = wMin;
                                        wcscpy(wszBest, wszSubKey);
									}
								}
                                FreeMemory(wszSubKey);
							}
                            else
							{
                                fStop = TRUE; // No more entries
							}
						}
                        index++;
					}
					
                    if (!hr)
					{
                        // Open the version we found
                        //
                        HREG hregVersion;
                        hr = OpenRegistryKey(&hregVersion, hregTlb, wszBest);
                        if (!hr)
						{
                            // Grab the first language subkey under the version.
                            // Need to possibly skip over FLAGS and HELPDIR subkeys
                            //
                            ULONG index = 0;
                            BOOL fStop = FALSE;
                            while (!hr && !fStop)
							{
                                LPWSTR wszSubKey;
                                hr = EnumerateRegistryKeys(hregVersion, index, &wszSubKey);
                                if (!hr)
								{
                                    if (wszSubKey)
									{
                                        if (FIsLCID(wszSubKey))
										{
                                            fStop = TRUE;
                                            //
                                            HREG hregLang;
                                            hr = OpenRegistryKey(&hregLang, hregVersion, wszSubKey);
                                            if (!hr)
											{
                                                // First attempt to find the current platform's typelib. If that
                                                // doesn't work, then grab the first platform subkey under the language.
                                                //
                                                HREG hregPlatform;
                                                hr = OpenRegistryKey(&hregPlatform, hregLang, L"win32");
                                                if (!!hr)
												{
                                                    LPWSTR wszPlatform;
                                                    hr = EnumerateRegistryKeys(hregLang, 0, &wszPlatform);
                                                    if (!hr)
													{
                                                        if (wszPlatform)
														{
                                                            hr = OpenRegistryKey(&hregPlatform, hregLang, wszPlatform);
                                                            FreeMemory(wszPlatform);
														}
                                                        else
                                                            hr = TYPE_E_LIBNOTREGISTERED;
													}
												}
                                                if (!hr)
												{
                                                    // The value of the platform key is the path to the typelib!
                                                    //
                                                    PKEY_VALUE_FULL_INFORMATION pinfo;
                                                    hr = GetRegistryValue(hregPlatform, L"", &pinfo, REG_SZ);
                                                    if (!hr)
													{
                                                        LPWSTR wszPath = StringFromRegInfo(pinfo);
                                                        //
                                                        //
                                                        //
                                                        ITypeLib* ptlb;
                                                        hr = LoadTypeLibEx(wszPath, REGKIND_NONE, &ptlb);
                                                        if (!hr)    
														{
                                                            hr = ptlb->GetTypeInfoOfGuid(iidIntercepted, pptypeinfo);
                                                            ::Release(ptlb);
														}
                                                        //
                                                        //
                                                        //
                                                        FreeMemory(pinfo);
													}
                                                    CloseRegistryKey(hregPlatform);
												}
                                                CloseRegistryKey(hregLang);
											}
										}
                                        FreeMemory(wszSubKey);
									}
                                    else
									{
                                        fStop = TRUE; // No more entries
                                        hr = TYPE_E_LIBNOTREGISTERED;
									}
								}
                                index++;
							}
                            CloseRegistryKey(hregVersion);
						}
					}
                    CloseRegistryKey(hregTlb);
				}
			}
            CloseRegistryKey(hregTlbId);
		}
	}
	
    return hr;
} //end GetTypeInfoFromIID


HRESULT GetVtbl(IN ITypeInfo* pTypeInfo, IN REFIID riid, OUT TYPEINFOVTBL ** ppvtbl, OUT ITypeInfo** ppBaseTypeInfo)
// Find or create a TYPEINFOVTBL for the given typeinfo, and return a new refcnt thereon.
// 
{
    HRESULT    hr = S_OK;
    USHORT       numMethods;
    MethodInfo * aMethodInfo;
    BOOL         fDerivesFromExternal = FALSE;
    ITypeInfo  * ptinfoProxy = NULL;
    ITypeInfo  * ptinfoDoc   = NULL;
    BOOL         bWeGotTypeInfo = FALSE;

    *ppvtbl = NULL;
	*ppBaseTypeInfo = NULL;

    // Check the cache.
    //
    HRESULT hr2 = g_ptiCache->FindExisting(riid, ppvtbl);
    if (!hr2)
	{
        // Found it in the cache
	}
    else
        {
    
	    //
	    // Find the typeinfo for the requested interface
	    //
	    if (!pTypeInfo)
	    {
	    	bWeGotTypeInfo = TRUE;
	        hr = GetTypeInfoFromIID (riid, &pTypeInfo);
	    }

	    if (!hr)
	    {    
	        // We didn't find the interface in the cache.
	        // Create a vtbl from the ITypeInfo.
	        //
	        IID iidBase = IID_NULL;
	        //
	        hr = CheckTypeInfo(pTypeInfo, &ptinfoProxy, &ptinfoDoc, &numMethods, &fDerivesFromExternal, &iidBase, ppBaseTypeInfo);
	        if (!hr)
	            {
	            // Get the per-method data
	            //
	            __try
	                {
	                aMethodInfo = (MethodInfo *) alloca(numMethods * sizeof(MethodInfo));
	                }
	            __except(EXCEPTION_EXECUTE_HANDLER)
	                {
	                hr = E_OUTOFMEMORY;
	                }
	            if (!hr)
	                {
	                Zero(aMethodInfo, numMethods * sizeof(MethodInfo));
	                hr = GetFuncDescs(ptinfoProxy, aMethodInfo);
	                if (!hr)
	                    {
	                    // Got the per-method data. Make a new vtable.
	                    //
	                    TYPEINFOVTBL* pvtbl;
	                    hr = CreateVtblFromTypeInfo(ptinfoProxy, ptinfoDoc, riid, iidBase, fDerivesFromExternal, numMethods, aMethodInfo, &pvtbl);
	                    if (!hr)
	                        {
	                        // Try to remember the vtable in the cache. But first we have to check
	                        // that we aren't going to create a duplicate because of a race.
	                        //
	                        g_ptiCache->LockExclusive();

	                        HRESULT hr3 = g_ptiCache->FindExisting(riid, ppvtbl);
	                        if (!hr3)
	                            {
	                            // Someone else won the race. Release what we've built so far
	                            // and return on out of here.
	                            }
	                        else
	                            {
	                            // Still not there, so register the one we've got
	                            //
	                            hr = pvtbl->AddToCache (g_ptiCache); 	                            
	                            if (!hr)
	                                {
	                                // Give caller back his reference
	                                //
	                                *ppvtbl = pvtbl;
	                                pvtbl->AddRef();
	                                }
	                            }

	                        g_ptiCache->ReleaseLock();
	                        pvtbl->Release();
	                        }
	                    }
	                ReleaseFuncDescs(numMethods, aMethodInfo);
	                }
	            else
	                hr = E_OUTOFMEMORY;
	            }
	        }

		    if (bWeGotTypeInfo)
	        {
	        	::Release(pTypeInfo);
	        }
    	}

    ::Release(ptinfoDoc);
    ::Release(ptinfoProxy);

    return hr;
}

HRESULT CreateVtblFromTypeInfo(
	ITypeInfo* ptinfoInterface, 
	ITypeInfo*ptinfoDoc, 
	REFIID riid, 
	REFIID riidBase, 
	BOOL fDerivesFromExternal, 
	USHORT numMethods, 
	MethodInfo* rgMethodInfo, 
	TYPEINFOVTBL** ppvtbl)
// Create a vtable structure from type information. Return to caller
// a new refcnt on the the (new) TYPEINFOVTBL structure.
//
{
    HRESULT           hr                          = S_OK;
    USHORT              iMethod;
    ULONG               cbVtbl;
    ULONG               cbOffsetTable;
    USHORT              cbProcFormatString          = 0;
    ULONG               cbSize;
    TYPEINFOVTBL *      pInfo;
    byte *              pTemp;
    PFORMAT_STRING      pTypeFormatString           = NULL;
    PFORMAT_STRING      pProcFormatString;
    unsigned short *    pFormatStringOffsetTable;
	void *              pvTypeGenCookie             = NULL;
    USHORT              cbFormat;
    USHORT              offset                      = 0;
    ULONG               cbDelegationTable;
    void **             pDispatchTable              = NULL;

    //-------------------------------------------------------------------------

    *ppvtbl = NULL;

    //-------------------------------------------------------------------------
    //
    // Compute the total size of the TYPEINFOVTBL structure
    //
    // Compute the size of the vtbl structure;
    //
    cbVtbl = numMethods * sizeof(void *);

    if (fDerivesFromExternal)
	{
        cbDelegationTable = cbVtbl;
	}
    else
	{
        cbDelegationTable = 0;
	}

    cbOffsetTable = numMethods * sizeof(USHORT);
    //
    // Compute the size of the proc format string.
    //
    for (iMethod = 3; iMethod < numMethods; iMethod++)
	{
        if (rgMethodInfo[iMethod].pFuncDesc != NULL)
		{
#ifndef _WIN64
            cbProcFormatString += 22;
#else
            cbProcFormatString += 22 + sizeof(NDR_PROC_HEADER_EXTS64);
#endif            
            cbProcFormatString += rgMethodInfo[iMethod].pFuncDesc->cParams * 6;
		}
	}

    cbSize = cbVtbl + cbDelegationTable + cbOffsetTable + cbProcFormatString;
    //
    // Allocate and initialize the structure
    //                                        
    pInfo = new(cbSize) TYPEINFOVTBL;
    if (pInfo)
    {
        //ASSERT(pInfo->m_refs == 1);
        //
        // Determine the start of the dispatch table in the total allocated space
        //
        pTemp = (byte *) pInfo->m_proxyVtbl.Vtbl + cbVtbl;

        if (cbDelegationTable != 0)
		{
            pDispatchTable = (void **) pTemp;
            pInfo->m_stubVtbl.header.pDispatchTable = (const PRPC_STUB_FUNCTION *) pDispatchTable;
            pTemp += cbDelegationTable;
		}
        //
        // determine the start of the format string offset
        //
        pFormatStringOffsetTable = (unsigned short *) pTemp;
        pTemp += cbOffsetTable;
        //
        // determine the start of the ProcFormatString
        //
        pProcFormatString = (PFORMAT_STRING) pTemp;
        //
        // Initialize the proxyvtbl
        //
        pInfo->m_proxyVtbl.Vtbl[0] = N(ComPs_IUnknown_QueryInterface_Proxy);
        pInfo->m_proxyVtbl.Vtbl[1] = N(ComPs_IUnknown_AddRef_Proxy);
        pInfo->m_proxyVtbl.Vtbl[2] = N(ComPs_IUnknown_Release_Proxy);
        //
        // Get the format strings. Generate -Oi2 proc format string from the ITypeInfo.
        //
		hr = NdrpGetTypeGenCookie(&pvTypeGenCookie);

        for (iMethod = 3; !hr && iMethod < numMethods; iMethod++)
		{
            if (rgMethodInfo[iMethod].pFuncDesc != NULL)
			{
                pFormatStringOffsetTable[iMethod] = offset;
                hr = NdrpGetProcFormatString(pvTypeGenCookie, 
											 rgMethodInfo[iMethod].pTypeInfo, 
											 rgMethodInfo[iMethod].pFuncDesc, 
											 iMethod, 
											 (PFORMAT_STRING)pTemp, 
											 &cbFormat);
                if (!hr)
				{
                    pTemp += cbFormat;
                    offset += cbFormat;

                    // Stubless client function.
                    pInfo->m_proxyVtbl.Vtbl[iMethod] = g_StublessProxyVtable[iMethod];

                    if (pDispatchTable != NULL)
					{
                        // Interpreted server function.
                        pDispatchTable[iMethod] = NdrStubCall2;
					}
				}
			}
            else
			{
                pFormatStringOffsetTable[iMethod] = (USHORT) -1;

                // Proxy delegation forwarding function.
                pInfo->m_proxyVtbl.Vtbl[iMethod] = g_ProxyForwarderVtable[iMethod];

                if (pDispatchTable != NULL)
				{
                    //Stub delegation forwarding function.
                    pDispatchTable[iMethod] = g_StubForwarderVtable[iMethod];
				}
			}
		}

        if (!hr)
		{
            // Get type format string and initialize the TYPEINFOVTBL
            //
            USHORT length;
			hr = NdrpGetTypeFormatString(pvTypeGenCookie, 
										 &pTypeFormatString, 
										 &length);
            
            if (!hr)
			{
                //---------------------------------------------------------------------
                // Initialize the iid.
                pInfo->m_guidkey = riid;
                pInfo->m_iidBase = riidBase;

                // Initialize the MIDL_STUB_DESC.
                pInfo->m_stubDesc.pfnAllocate     = _LocalAlloc;
                pInfo->m_stubDesc.pfnFree         = _LocalFree;
                pInfo->m_stubDesc.pFormatTypes    = pTypeFormatString;
#if !defined(_WIN64)                
                pInfo->m_stubDesc.Version         = 0x20000;      // Ndr library version 
#else
                pInfo->m_stubDesc.Version         = 0x50002;      // Ndr library version 
#endif
                pInfo->m_stubDesc.MIDLVersion     = MIDLVERSION;
                pInfo->m_stubDesc.aUserMarshalQuadruple = g_oa.get_UserMarshalRoutines();

                // Initialize the MIDL_SERVER_INFO.
                pInfo->m_stubInfo.pStubDesc       = &pInfo->m_stubDesc;
                pInfo->m_stubInfo.ProcString      = pProcFormatString;
                pInfo->m_stubInfo.FmtStringOffset = pFormatStringOffsetTable;

                // Initialize the stub vtbl.
                pInfo->m_stubVtbl.header.piid                 = &pInfo->m_guidkey;
                pInfo->m_stubVtbl.header.pServerInfo          = &pInfo->m_stubInfo;
                pInfo->m_stubVtbl.header.DispatchTableCount   = numMethods;

                // Initialize stub methods.
                memcpy(&pInfo->m_stubVtbl.Vtbl, &CStdStubBuffer2Vtbl, sizeof(CStdStubBuffer2Vtbl));

                // NOTE -- gaganc setting the release function pointer to null.
                // this is not expected to be called.
                pInfo->m_stubVtbl.Vtbl.Release = 0x0;

                // Initialize the proxy info.
                pInfo->m_proxyInfo.pStubDesc          = &pInfo->m_stubDesc;
                pInfo->m_proxyInfo.ProcFormatString   = pProcFormatString;
                pInfo->m_proxyInfo.FormatStringOffset = pFormatStringOffsetTable;

                // Initialize the proxy vtbl.
                pInfo->m_proxyVtbl.header.pStublessProxyInfo  = &pInfo->m_proxyInfo;
                pInfo->m_proxyVtbl.header.piid                = &pInfo->m_guidkey;
            }
        }

        if (!hr)
		{
            // Dig out the name of the interface
            //
            BSTR bstrInterfaceName;
            hr = ptinfoDoc->GetDocumentation(MEMBERID_NIL, &bstrInterfaceName, NULL, NULL, NULL);
            if (!hr)
			{
                // Convert to ANSI in order to store. Memory version is ANSI instead of Unicode 'cause
                // MIDL-generated interceptors emit ANSI names (see pProxyFileInfo->pNamesArray) as 
                // const data, and it doesn't seem worthwhile doing another alloc for those just to
                // fix that.
                //
                pInfo->m_szInterfaceName = ToUtf8(bstrInterfaceName);
                if (pInfo->m_szInterfaceName)   
				{
					// all is swell
				}
                else
                    hr = E_OUTOFMEMORY;
                //
                SysFreeString(bstrInterfaceName);
			}
		}

        if (!hr)
		{
            // Initialize the method descriptors
            //
            ULONG cb = numMethods * sizeof pInfo->m_rgMethodDescs[0];
			pInfo->m_rgMethodDescs = (METHOD_DESCRIPTOR*)AllocateMemory(cb);
			if (pInfo->m_rgMethodDescs)
			{
				Zero(pInfo->m_rgMethodDescs, cb);
			}
			else
				hr = E_OUTOFMEMORY;

            for (iMethod = 3; !hr && iMethod < numMethods; iMethod++)
			{
                FUNCDESC* pFuncDesc     = rgMethodInfo[iMethod].pFuncDesc;
                ITypeInfo *ptinfoMethod = rgMethodInfo[iMethod].pTypeInfo;
                if (pFuncDesc != NULL)
				{
                    // Find out the method name and remember it
                    //
                    METHOD_DESCRIPTOR& methodDesc = pInfo->m_rgMethodDescs[iMethod];
                    BSTR bstrMethodName;
                    unsigned int cNames;
                    hr = rgMethodInfo[iMethod].pTypeInfo->GetNames(rgMethodInfo[iMethod].pFuncDesc->memid, &bstrMethodName, 1, &cNames);
                    if (!hr)
					{
                        methodDesc.m_szMethodName = CopyString(bstrMethodName);
                        if (NULL == methodDesc.m_szMethodName)
						{
                            hr = E_OUTOFMEMORY;
						}
                        SysFreeString(bstrMethodName);
					}

                    if (!hr)
					{
                    	methodDesc.m_cParams = pFuncDesc->cParams;
                    	if (methodDesc.m_cParams != 0)
						{
							methodDesc.m_paramVTs = (VARTYPE*)AllocateMemory(methodDesc.m_cParams * sizeof(VARTYPE));
                    		for (short iParam = 0; iParam < methodDesc.m_cParams; ++iParam)								
							{
								VARTYPE vt;

                                hr = NdrpVarVtOfTypeDesc(ptinfoMethod, 
														 &pFuncDesc->lprgelemdescParam[iParam].tdesc, 
														 &vt);

                                if (!hr)
                                    methodDesc.m_paramVTs[iParam] = vt;
							}
						}
					}
				}
			}
		}

        if (!hr)
		{
            // Return a ref on the object to our caller
            *ppvtbl = pInfo;
            pInfo->AddRef();
		}

        pInfo->Release();
	}
    else
        hr = E_OUTOFMEMORY;

	if (pvTypeGenCookie)
		NdrpReleaseTypeGenCookie(pvTypeGenCookie);

    return hr;
} //end CreateVtblFromTypeInfo




HRESULT GetFuncDescs(IN ITypeInfo *pTypeInfo, OUT MethodInfo *pMethodInfo)
// Get the FUNCDESCs of each method in the TypeInfo
//
{
    HRESULT hr = S_OK;
    TYPEATTR *pTypeAttr;

    hr = pTypeInfo->GetTypeAttr(&pTypeAttr);

    if (!hr)
	{
        if (IID_IUnknown == pTypeAttr->guid)
		{
            hr = S_OK;
		}
        else if (IID_IDispatch == pTypeAttr->guid)
		{
            hr = S_OK;
		}
        else
		{
            // This is an oleautomation interface.
            //
            ULONG i, iMethod;
            FUNCDESC *pFuncDesc;

            if (pTypeAttr->cImplTypes)
			{
                // Recursively get the inherited member functions. The recursion
                // will fill in a prefix of the MethodInfo array.
                //
                HREFTYPE hRefType;
                hr = pTypeInfo->GetRefTypeOfImplType(0, &hRefType);
                if (!hr)
				{
                    ITypeInfo *pRefTypeInfo;
                    hr = pTypeInfo->GetRefTypeInfo(hRefType, &pRefTypeInfo);
                    if (!hr)
					{
						hr = GetFuncDescs(pRefTypeInfo, pMethodInfo);
                        ::Release(pRefTypeInfo);
					}
				}
			}

            // Get the member functions.
            //
            for(i = 0; !hr && i < pTypeAttr->cFuncs; i++)
			{
                hr = pTypeInfo->GetFuncDesc(i, &pFuncDesc);
                if (!hr)
				{
                    iMethod = (pFuncDesc->oVft - VTABLE_BASE) / sizeof(PVOID);
                    pMethodInfo[iMethod].pFuncDesc = pFuncDesc;
                    pMethodInfo[iMethod].pTypeInfo = pTypeInfo;
                    pTypeInfo->AddRef();
				}
			}
		}

        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
	}

    return hr;
}


HRESULT ReleaseFuncDescs(USHORT numMethods, MethodInfo *pMethodInfo)
{
    USHORT iMethod;
    //
    // Release the funcdescs.
    //
    if (pMethodInfo != NULL)
	{
        for(iMethod = 0;
            iMethod < numMethods;
            iMethod++)
		{
            pMethodInfo[iMethod].Destroy();
		}
	}
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\amd64\forwardamd64.asm ===
title   "Proxy and Stub Forwarding Functions"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   forward.asm
;
; Abstract:
;
;   This module implements the proxy and stub forwarding functions for the
;   AMD64 platform.
;
; Author:
;
;   David N. Cutler 30-Dec-2000
;
; Environment:
;
;   Any mode.
;
;-

include ksamd64.inc

        subttl  "Proxy Forwarding Functions"
;++
;
; VOID
;  __ForwarderProxy_meth<nnn>(
;    IN IUnknown *This,
;    ...
;    )
;
; Routine Description:
;
;   This function forwards a call to the proxy for the base interface.
;
; Arguments:
;
;   This (rcx) - Supplies a pointer to the interface proxy.
;
; Return Value:
;
;   None.
;
;--

;
; Define macro to generate forwarder functions.
;

Proxy_m_pBaseProxy equ 80
Proxy_m_pProxyVtbl equ 16

FORWARDER_PROXY macro Method

        LEAF_ENTRY __ForwarderProxy_meth&Method, _TEXT$00

        mov     rcx, (Proxy_m_pBaseProxy - Proxy_m_pProxyVtbl)[rcx] ; get proxy object address
        mov     r10, [rcx]              ; get vtable address
        jmp     qword ptr (&Method * 8)[r10] ; transfer to method

        LEAF_END __ForwarderProxy_meth&Method, _TEXT$00

        endm

;
; Generate forwarder functions.
;

index = 3

        rept    (1023 - 3 + 1)

        FORWARDER_PROXY %index

index = index + 1

        endm

        subttl  "Stub Forwarding Functions"
;++
;
; VOID
;  __ForwarderStub_meth<nnn>(
;    IN IUnknown *This,
;    ...
;    )
;
; Routine Description:
;
;   This function forwards a call to the stub for the base interface.
;
; Arguments:
;
;   This (rcx) - Supplies a pointer to the interface proxy.
;
; Return Value:
;
;   None.
;
;--

;
; Define macro to generate forwarder functions.
;

Stub_m_punkServerObject equ 40
Stub_m_lpForwardingVtbl equ 64

FORWARDER_STUB macro Method

        LEAF_ENTRY __ForwarderStub_meth&Method, _TEXT$00

        mov     rcx, (Stub_m_punkServerObject - Stub_m_lpForwardingVtbl)[rcx] ; get stub object address
        mov     r10, [rcx]              ; get vtable address
        jmp     qword ptr (&Method * 8)[r10] ; transfer to method

        LEAF_END __ForwarderStub_meth&Method, _TEXT$00

        endm

;
; Generate forwarder functions.
;

index = 3

        rept    (1023 - 3 + 1)

        FORWARDER_STUB %index

index = index + 1

        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\ia64\extract.s ===
//****************************************************************************
//
//  Copyright (C) 1995-2000 Microsoft Corporation.  All rights reserved.
//
// extract.s - IA64 generic thunks for callframe interceptors.
//
// Purpose:
//
//   This module implements the IA64-specific generic thunks for intercepted.
//   COM method calls.
//
// Revision Histor:
//
//    Created           1-17-2000               JohnStra
//
//****************************************************************************        

        .file "extract.s"
        .section .text

#include "ksia64.h"		
				        
//++
//
// ExtractParams
//
// Routine Description:
//
//     Common handler code for making an indirect IA64 call through an
//     interceptor.  Homes all the arguments to the call to the memory
//     stack and dispatches the call on to Interceptor::CallIndirect.
//
// On Entry:
// 
//     All of the arguments to the interface method are their proper
//     place as defined by the IA64 calling standard: ints in general
//     registers, floats in float registers, etc.
//
// Arguments:  
//
//     r31 - index of the method to call
//
// Note:
//
//     The only way this routine is executed is by way of an unconditional
//     branch from one of our own generic thunks.  When this routine
//     returns, it returns to the original caller of the interface method.
//
//		When we get the stack, it looks like this:
//		sp-> STACK_SCRATCH_AREA
//				...
//		     remainder of parameters
//
//		We're going to set up the stack to relocate the scratch area and
//		make it look like (upon calling):
//
//		 offset*		what
//		-SCRATCH_AREA	Scratch Area Proper
//		0				cbArgs
//		4				hr
//		...				Padding to Align with 16
//      16              farg0
//      32              farg1
//      48              farg2
//      64              farg3
//      80              farg4
//      96              farg5
//      112             farg6
//      128             farg7
//		144				in0
//		152				in1
//		160				in2
//		168				in3
//		176				in4
//		184				in5
//		192				in6
//		200				in7
//		208				remainder of parameters
//
//		(* for brevity, offset is offset from sp+STACK_SCRATCH_AREA)
//       
//
//--
        .proc ExtractParams#
        .align 32
        
		//
        // Stack based locals
        //
		cbArgs$ =   0+STACK_SCRATCH_AREA
		hr$     =   4+STACK_SCRATCH_AREA
        //
        // Other useful stack locations
        //
        fargs$  =  16+STACK_SCRATCH_AREA
        this_$  = 144+STACK_SCRATCH_AREA
        		        
		.global ExtractParams#
        .type ExtractParams#, @function
        .align 32
        
ExtractParams:
        .regstk 8, 6, 8, 0
        .prologue 0xE, loc0
        
        //
        // Allocate a frame.  We want 8 input slots, 6 locals, and 8
        // output slots.  We're not using the rotating registers feature.
        //
        
        alloc loc0=ar.pfs, 8, 6, 8, 0
        
        //
        // Register based local variables.
        //
         
        saved_ar                 =loc0          // r40
        saved_return_address     =loc1          // r41
        psp                      =loc2          // r42
        saved_gp                 =loc3          // r43
        saved_pr                 =loc4          // r44
        saved_unat               =loc5          // r45

        //
        // Prologue-- save registers.
        //
        
        mov     psp=sp                          // save stack pointer
        mov     saved_return_address=b0         // save return address
        mov     saved_gp=gp;;                   // save gp
        mov.m   saved_unat=ar.unat              // save ar.unat
        mov     saved_pr=pr;;                   // save pr
        
        //
        // Allocate some stack.  We need enough to hold stack-based
        // locals plus space to spill all the integer and FP arguments.
		//
		// Remember that although we're going to be eating space in
		// the scratch area, we need another one because we're calling
		// a function.
        //
		// 208 bytes needed (see diagram above)
		//
        
        adds    sp=-208, sp ;;

        //
        // Init a pointer into the stack where the floating point args are to
        // be placed.
        //

        adds    r14=fargs$, sp ;;
        adds    r15=16, r14

        //
        // Spill all the FP args onto the stack...
        //
        
        stf.spill [r14]=farg0, 32 ;; 
        stf.spill [r15]=farg1, 32 ;;
        stf.spill [r14]=farg2, 32
        stf.spill [r15]=farg3, 32 ;; 
        stf.spill [r14]=farg4, 32        
        stf.spill [r15]=farg5, 32 ;;
        stf.spill [r14]=farg6
        stf.spill [r15]=farg7     ;; 
                        
        //
        // Init a pointer into the stack where integer params are to be placed.
        //

        adds    r14=this_$, sp ;;
        adds    r15=8, r14
        
        //
        // Move all the integer arguments out of registers onto the stack.
        //

        st8.spill [r14]=in0, 16 ;;
        st8.spill [r15]=in1, 16 ;;
        st8.spill [r14]=in2, 16 ;;
        st8.spill [r15]=in3, 16 ;;
        st8.spill [r14]=in4, 16 ;;
        st8.spill [r15]=in5, 16 ;;
        st8.spill [r14]=in6 ;;
        st8.spill [r15]=in7 ;;
        
        //
        // Setup arguments to Interceptor::CallIndirect
        //

        adds    r19=this_$, sp ;;
        ld8     r18=[r19] ;;
        adds    out0=-48, r18                   // 'this'
		
        adds    out1=hr$, sp                    // &hr
		
        mov     out2=r31                        // i
		
        adds    out3=this_$, sp                 // pvArgs
		
        adds    out4=cbArgs$, sp                // &cbArgs
        
        //
        // Calculate the address Interceptor::CallIndirect
        //
	
        adds	r22=this_$, sp ;;               // this_ in r22
		ld8		r21=[r22] ;;                    // address of pVtbl in r21
		adds	r20=-48, r21;;                  // get containing pInterceptor in r20
		ld8		r17=[r20] ;;                    // address of pVtbl in r17
		adds	r16=24, r17;;                   // address of label for CallIndirect in r16
		ld8		r15=[r16] ;;                    // address of function ptr in r15
		ld8		r14=[r15], 8;;                  // address of function in r14
        mov		b6=r14                          // address of function in b6

        //
        // Make the call
        //
        
        br.call.sptk.few b0=b6;;

        //
        // Epilogue
        //        

		adds	r22=hr$,sp ;;					// calculate address of hr to return...
		ld4		r23=[r22]  ;;					// load hr into ret0
		sxt4	ret0=r23   ;;					// make sure it's sign extended		
		        
        mov     sp=psp                          // restore stack pointer
        mov     b0=saved_return_address         // restore return address
        mov.m   ar.unat=saved_unat              // restore ar.unat
        mov     pr=saved_pr, -1;;               // restore pr
        mov     ar.pfs=saved_ar;;               // restore previous function state

        //
        // Return to caller
        //
        
        br.ret.dpnt     b0
        
        .endp ExtractParams#
		
//++
//
//  Function:   void __stdcall SpillFPRegsForIA64(
//                                 REGISTER_TYPE* pStack, 
//                                 ULONG          FloatMask
//                                 );
//
//  Synopsis:   Given a pointer to the virtual stack and floating-point mask,
//              SpillFPRegsForIA64 copies the contents of the floating-point 
//              registers to the appropriate slots in pStack.
//
//				This was adapted from the RPC NDR function that does a similar
//				thing.
//
//              EXCEPT:  the fargs are actually stored a pStack - (32 * 8).
//                       This is because we cannot count on the fargs params
//                       being maintained in between the call to ExtractParams
//                       above and this method call.
//
//  Arguments:  pStack - Pointer to the virtual stack in memory.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float.
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//        
//                          A bit in an F* position represents a float (4 bytes).  A bit in a D*
//                          position represents a double (8 bytes).  Both bits set indicates two
//                          floats side by side (in an 8 byte slot in memory, but in 2 regs.)
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(SpillFPRegsForIA64)
        NESTED_SETUP(4,4,8,0)

        savedSP         = loc2                  // savedSP aliased to loc2
        savedLC         = loc3
        pStack          = a0                    // pStack  aliased to first param passed in
        FloatMask       = a1                    // FloatMask  aliased to second param passed in

        mov             savedSP = sp            // save sp
        mov             savedLC = ar.lc         // save lc

        PROLOGUE_END

        ARGPTR          (a0)                    // sign-extend pStack for WIN32

        //----------------------------------------------------------------
        // start of main algorithm
        //----------------------------------------------------------------
        mov             t0 = FloatMask;;        // FloatMask copied to t0
        mov             t1 = pStack             // pStack copied to t1
        
        popcnt          t4 = t0;;               // count number of bits in FloatMask; i.e. how many
                                                // active slots
        //
        // Load the fp regs from the stack up into real registers.
        //
        // Rotating registers rotate downward. because of this we
        // reverse the order of the fp regs fp8 - fp15 to 
        // fp47 - fp40.  This is so we can use the rotating registers
        // feature of the IA64.
        //
        
        adds            t2 = -16, t1            // t2 is the start of the fargs
        cmp.eq          pt0 = 8, t4             // look at the number of parameters and branch accordingly.
(pt0)   br.cond.sptk    ReverseFP8;;            
        adds            t2 = -16, t2
        cmp.eq          pt0 = 7, t4             // the fp args are ordered by their arguement order; i.e.
(pt0)   br.cond.sptk    ReverseFP7;;            // fp32 contains the first fp arg, fp32 contains the next
        adds            t2 = -16, t2
        cmp.eq          pt0 = 6, t4             // fp arg...etc. 
(pt0)   br.cond.sptk    ReverseFP6;;              
        adds            t2 = -16, t2
        cmp.eq          pt0 = 5, t4
(pt0)   br.cond.sptk    ReverseFP5;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 4, t4
(pt0)   br.cond.sptk    ReverseFP4;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 3, t4
(pt0)   br.cond.sptk    ReverseFP3;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 2, t4
(pt0)   br.cond.sptk    ReverseFP2;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 1, t4
(pt0)   br.cond.sptk    ReverseFP1;;


ReverseFP8:                                     // reverse fp reg order from the load
        ldf.fill       f40 = [t2], -16 ;; 
ReverseFP7:                                     
        ldf.fill       f41 = [t2], -16 ;; 
ReverseFP6:
        ldf.fill       f42 = [t2], -16 ;; 
ReverseFP5:
        ldf.fill       f43 = [t2], -16 ;; 
ReverseFP4:
        ldf.fill       f44 = [t2], -16 ;; 
ReverseFP3:
        ldf.fill       f45 = [t2], -16 ;; 
ReverseFP2:
        ldf.fill       f46 = [t2], -16 ;; 
ReverseFP1:
        ldf.fill       f47 = [t2]
     

StartSpill:
        mov             ar.lc  = 8              // the maximum loop count is total slots in FloatMask


ProcessNextSlot:
        extr.u          t10 = t0, 0, 2          // extract the two FP slot nibbles into t10
        shr.u           t0  = t0, 2;;           // shift FloatMask, since we've extracted the slot

        cmp.eq          pt0 = 0, t0             // check if FloatMask is zero; if so, we are done.
        cmp.eq          pt1 = 0, t10            // check if slot is 0; i.e. not a float or double
        cmp.eq          pt2 = 1, t10            // check if slot is 1: float
        cmp.eq          pt3 = 2, t10            // check if slot is 2: double
        cmp.ne          pt4 = 3, t10;;          // check if slot is 3: double-float
        
(pt2)   stfs            [t1] = f47;;            // store float at pStack
(pt3)   stfd            [t1] = f47;;            // store double at pStack        
(pt4)   br.cond.sptk    SpillDualFloatRegBump;; // CAN'T PREDICATE THROUGH THIS!!!
        
        stfs            [t1] = f47, 4;;         // store double-float.
        stfs            [t1] = f46, -4;; 
        br.ctop.sptk    SpillDualFloatRegBump;; // jump to next line to force reg rotate
SpillDualFloatRegBump:        

        adds            t1 = 8, t1              // advance to next stack slot
                        
(pt0)   br.cond.sptk    Done                    // FloatMask is zero, so we are done
(pt1)   br.cond.sptk    ProcessNextSlot         // a zero slot pays a branch penality; but it does not 
                                                // rotate the fp & pr registers
        br.ctop.sptk    ProcessNextSlot;;       // counted loop no penalty for branch rotate f32&pr16 


        //----------------------------------------------------------------
        // done, restore sp and exit
        //----------------------------------------------------------------
Done:
		mov             ar.lc = savedLC         // restore loop count register
        .restore
        mov             sp = savedSP            // restore sp

        NESTED_RETURN
     
        NESTED_EXIT(SpillFPRegsForIA64)		

//++
//		
//  Function:   void __stdcall FillFPRegsForIA64(
//                                 REGISTER_TYPE* pStack, 
//                                 ULONG          FloatMask
//                                 );
//
//  Synopsis:   Given a pointer to the virtual stack and floating-point mask,
//              FillFPRegsForIA64 copies the floating point contents of the stack
//              back to the appropriate registers.
//
//				This was adapted from the RPC NDR function that does a similar
//				thing, only backwards.
//
//  Arguments:  pStack - Pointer to the virtual stack in memory.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//
//                          A bit in an F* position represents a float (4 bytes).  A bit in a D*
//                          position represents a double (8 bytes).  Both bits set indicates two
//                          floats side by side (in an 8 byte slot in memory, but in 2 regs.)
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(FillFPRegsForIA64)
        NESTED_SETUP(4,4,8,0)

        savedSP         = loc2                  // savedSP aliased to loc2
        savedLC         = loc3
        pStack          = a0                    // pStack  aliased to first param passed in
        FloatMask       = a1                    // FloatMask  aliased to second param passed in

        mov             savedSP = sp            // save sp
        mov             savedLC = ar.lc         // save lc

        PROLOGUE_END

        ARGPTR          (a0)                    // sign-extend pStack for WIN32

        //----------------------------------------------------------------
        // start of main algorithm
        //----------------------------------------------------------------
        mov             t0 = FloatMask;;        // FloatMask copied to t0
        mov             t1 = pStack             // pStack copied to t1

        popcnt          t4 = t0;;               // count number of bits in FloatMask; i.e. how many
                                                // active slots
		
StartFill:
        mov             ar.lc  = 8              // the maximum loop count is total slots in FloatMask


FillNextSlot:
        extr.u          t10 = t0, 0, 2          // extract the two FP slot nibbles into t10
        shr.u           t0  = t0, 2;;           // shift FloatMask, since we've extracted the slot

        cmp.eq          pt0 = 0, t0             // check if FloatMask is zero; if so, we are done.
        cmp.eq          pt1 = 0, t10            // check if slot is 0; i.e. not a float or double
        cmp.eq          pt2 = 1, t10            // check first nibble of extracted slot is float
        cmp.eq          pt3 = 2, t10            // check second nibble of extracted slot is double
        cmp.ne          pt4 = 3, t10;;          // check for dual-floats. 

        //
        // For all of these, f40 is the current "working" floating point register.
        // f41 is the "previous" register, f39 is the "next" register.
        //
(pt2)   ldfs            f40 = [t1];;             // load float from pStack
(pt3)   ldfd            f40 = [t1];;             // load double from pStack
(pt4)   br.cond.sptk    FillDualFloatRegBump;;   // CAN'T PREDICATE THROUGH THIS!! ARGH!!!
        
        // Dual float section.
        ldfps           f40,f39 = [t1];; 
        br.ctop.sptk    FillDualFloatRegBump;;   // jump to next line, but forces a reg. rotate.
FillDualFloatRegBump:

        adds            t1 = 8, t1              // move to next slot
                        
(pt0)   br.cond.sptk    FillDone                // FloatMask is zero, so we are done
(pt1)   br.cond.sptk    FillNextSlot            // a zero slot pays a branch penality; but it does not 
                                                // rotate the fp & pr registers
        br.ctop.sptk    FillNextSlot;;          // counted loop no penalty for branch rotate f32&pr16 


FillDone:										
		cmp.eq          pt0 = 8, t4             // look at the number of parameters and branch accordingly.
(pt0)   br.cond.sptk    FillEight;;				// At this point f40 contains the last fp arg, f41 the next
        cmp.eq          pt0 = 7, t4             // to last, etc.  A rather unfortunate situation, since we
(pt0)   br.cond.sptk    FillSeven;;				// need to put the FIRST one in f8, the second in f9, etc.
        cmp.eq          pt0 = 6, t4             // So, for each potential count of fp args, we go to a special
(pt0)   br.cond.sptk    FillSix;;               // block of code, to shuffle the values correctly.
        cmp.eq          pt0 = 5, t4             
(pt0)   br.cond.sptk    FillFive;;				
        cmp.eq          pt0 = 4, t4             
(pt0)   br.cond.sptk    FillFour;;
        cmp.eq          pt0 = 3, t4             
(pt0)   br.cond.sptk    FillThree;;
        cmp.eq          pt0 = 2, t4
(pt0)   br.cond.sptk    FillTwo;;
        cmp.eq          pt0 = 1, t4
(pt0)   br.cond.sptk    FillOne

		br.cond.sptk    DoneFillFloats;;		// Shouldn't ever get here, but just in case...
		
FillOne:
		mov				f8  = f40				// Move the floating values from their temporary positions
		br.cond.sptk DoneFillFloats;;			// into the floating point argument registers.

FillTwo:
		mov				f8  = f41
		mov				f9  = f40
		br.cond.sptk DoneFillFloats;;

FillThree:
		mov				f8  = f42
		mov				f9  = f41
		mov				f10 = f40
		br.cond.sptk DoneFillFloats;;

FillFour:
		mov				f8  = f43
		mov				f9  = f42
		mov				f10 = f41
		mov				f11 = f40
		br.cond.sptk DoneFillFloats;;

FillFive:
		mov				f8  = f44
		mov				f9  = f43
		mov				f10 = f42
		mov				f11 = f41
		mov				f12 = f40
		br.cond.sptk DoneFillFloats;;

FillSix:
		mov				f8  = f45
		mov				f9  = f44
		mov				f10 = f43
		mov				f11 = f42
		mov				f12 = f41
		mov				f13 = f40
		br.cond.sptk DoneFillFloats;; 

FillSeven:
		mov				f8  = f46
		mov				f9  = f45
		mov				f10 = f44
		mov				f11 = f43
		mov				f12 = f42
		mov				f13 = f41
		mov				f14 = f40
		br.cond.sptk DoneFillFloats;;

FillEight:
		mov				f8  = f47
		mov				f9  = f46
		mov				f10 = f45
		mov				f11 = f44
		mov				f12 = f43
		mov				f13 = f42
		mov				f14 = f41
		mov				f15 = f40

DoneFillFloats:

		rum				1 << PSR_MFH			// restore user mask for
												// floats.  I don't know
												// if this is strictly
												// necessary, but RPC does
												// it before invoking, so
												// I guess I should too.
     
        //----------------------------------------------------------------
        // done, restore sp and exit
        //----------------------------------------------------------------
		mov             ar.lc = savedLC         // restore loop count register
        .restore
        mov             sp = savedSP            // restore sp

        NESTED_RETURN
     
        NESTED_EXIT(FillFPRegsForIA64)		
		

		
//****************************************************************************
//
// The following macros are used to create the generic thunks with which
// we populate the interceptor vtbls.  The thunk simply saves away the
// the method index in saved register r31 and jumps to the ExtractParams
// routine.
//
//****************************************************************************
#define meth10IA64(i)  \
	methIA64(i##0) \
	methIA64(i##1) \
	methIA64(i##2) \
	methIA64(i##3) \
	methIA64(i##4) \
	methIA64(i##5) \
	methIA64(i##6) \
	methIA64(i##7) \
	methIA64(i##8) \
	methIA64(i##9)

#define meth100IA64(i)   \
	meth10IA64(i##0) \
	meth10IA64(i##1) \
	meth10IA64(i##2) \
	meth10IA64(i##3) \
	meth10IA64(i##4) \
	meth10IA64(i##5) \
	meth10IA64(i##6) \
	meth10IA64(i##7) \
	meth10IA64(i##8) \
	meth10IA64(i##9)       

#define methIA64(i)                             \
        .##global __Interceptor_meth##i;        \
        .##proc   __Interceptor_meth##i;        \
__Interceptor_meth##i::                         \
        mov r31=i;                               \
        br ExtractParams;                       \
        .##endp __Interceptor_meth##i;
        

        
//****************************************************************************
//
// The following statements expand, using the macros defined above, into
// the methods used in interceptor vtbls. 
//
//****************************************************************************
    methIA64(3)
    methIA64(4)
    methIA64(5)
    methIA64(6)
    methIA64(7)
    methIA64(8)
    methIA64(9)
    meth10IA64(1)
    meth10IA64(2)
    meth10IA64(3)
    meth10IA64(4)
    meth10IA64(5)
    meth10IA64(6)
    meth10IA64(7)
    meth10IA64(8)
    meth10IA64(9)
    meth100IA64(1)
    meth100IA64(2)
    meth100IA64(3)
    meth100IA64(4)
    meth100IA64(5)
    meth100IA64(6)
    meth100IA64(7)
    meth100IA64(8)
    meth100IA64(9)
    meth10IA64(100)
    meth10IA64(101)
    methIA64(1020)
    methIA64(1021)
    methIA64(1022)
    methIA64(1023)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\amd64\stubless.asm ===
title   "Stubless Support"
;++
;
; Copyright (C) 2001  Microsoft Corporation
;
; Module Name:
;
;   stubless.asm
;
; Abstract:
;
;   This module contain the routine neceeary to invoke a function with a
;   given parameter list.
;
; Author:
;
;   David N. Cutler 26-Jan-2001
;
; Environment:
;
;   User mode.
;
;--

include ksamd64.inc

        extern  __chkstk:proc

        subttl  "Invoke Function with Parameter List"
;++
;
; REGISTER_TYPE
; Invoke (
;     MANAGER_FUNCTION Function,
;     REGISTER_TYPE *ArgumentList,
;     ULONG Arguments
;     )
;
; Routine description:
;
;   This function builds an appropriate argument list and calls the specified
;   function.
;
; Arguments:
;
;   Function (rcx) - Supplies a pointer to the target function.
;
;   ArgumentList (rdx) - Supplies a pointer to the argument list.
;
;   Arguments (r8d) - Supplies the number of arguments.
;
; Return Value:
;
;   The value as returned by the target function.
;
;--

        NESTED_ENTRY Invoke, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rbp                    ;
        set_frame rbp, 0                ; set frame pointer

        END_PROLOGUE

        mov     eax, r8d                ; round to even argument count
        inc     eax                     ;
        and     al, 0feh                ;
        shl     eax, 3                  ; compute number of bytes
        call    __chkstk                ; check stack allocation
        sub     rsp, rax                ; allocate argument list
        mov     r10, rcx                ; save address of function
        mov     rsi, rdx                ; set source argument list address
        mov     rdi, rsp                ; set destination argument list address
        mov     ecx, r8d                ; set number of arguments
    rep movsq                           ; copy arguments to the stack

;
; N.B. All four argument registers are loaded regardless of the actual number
;      of arguments.
;
; N.B. The first argument cannot be in a floating point register and therefore
;      xmm0 is not loaded.
;

        mov     rcx, 0[rsp]             ; load first four argument registers
        mov     rdx, 8[rsp]             ;
        movq    xmm1, 8[rsp]            ;
        mov     r8, 16[rsp]             ;
        movq    xmm2, 16[rsp]           ;
        mov     r9, 24[rsp]             ;
        movq    xmm3, 24[rsp]           ;
        call    r10                     ; call target function
        mov     rsp, rbp                ; deallocate argument list
        pop     rbp                     ; restore nonvolatile register
        pop     rsi                     ;
        pop     rdi                     ;
        ret                             ;

        NESTED_END Invoke, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\ia64\forwarderia64.s ===
.file "forwarderia64.s"
        .section .text

#define ForwardingInterfaceProxy_m_pProxyVtbl       (16)
#define ForwardingInterfaceProxy_m_pBaseProxy       (80)
#define ForwardingInterfaceStub_m_pStubVtbl         (32)
#define ForwardingInterfaceStub_m_punkServerObject  (40)
#define ForwardingInterfaceStub_m_lpForwardingVtbl  (64)

//****************************************************************************
//
// The following macros are used to create the generic thunks with which
// we populate the interceptor vtbls.  The thunk simply saves away the
// the method index in saved register r4 and jumps to the ExtractParams
// routine.
//
//****************************************************************************
#define meth10IA64(i)  \
	methIA64(i##0) \
	methIA64(i##1) \
	methIA64(i##2) \
	methIA64(i##3) \
	methIA64(i##4) \
	methIA64(i##5) \
	methIA64(i##6) \
	methIA64(i##7) \
	methIA64(i##8) \
	methIA64(i##9)

#define meth100IA64(i)   \
	meth10IA64(i##0) \
	meth10IA64(i##1) \
	meth10IA64(i##2) \
	meth10IA64(i##3) \
	meth10IA64(i##4) \
	meth10IA64(i##5) \
	meth10IA64(i##6) \
	meth10IA64(i##7) \
	meth10IA64(i##8) \
	meth10IA64(i##9)       



#undef  methIA64
#define methIA64(i)                                                                                     \
        .##global __ForwarderProxy_meth##i;                                                             \
        .##proc   __ForwarderProxy_meth##i;                                                             \
__ForwarderProxy_meth##i::                                                                              \
        adds r19 = -ForwardingInterfaceProxy_m_pProxyVtbl+ForwardingInterfaceProxy_m_pBaseProxy, r32;;  \
        ld8  r19 = [r19];;                                                                              \
        adds r19 = i*8, r19;;                                                                           \
        ld8  r18 = [r19];;                                                                              \
        mov  b2  = r18;;                                                                                \
        br   b2;;                                                                                       \
        .##endp __ForwarderProxy_meth##i;    

        
//****************************************************************************
//
// The following statements expand, using the macros defined above, into
// the methods used in interceptor vtbls. 
//
//****************************************************************************
    methIA64(3)
    methIA64(4)
    methIA64(5)
    methIA64(6)
    methIA64(7)
    methIA64(8)
    methIA64(9)
    meth10IA64(1)
    meth10IA64(2)
    meth10IA64(3)
    meth10IA64(4)
    meth10IA64(5)
    meth10IA64(6)
    meth10IA64(7)
    meth10IA64(8)
    meth10IA64(9)
    meth100IA64(1)
    meth100IA64(2)
    meth100IA64(3)
    meth100IA64(4)
    meth100IA64(5)
    meth100IA64(6)
    meth100IA64(7)
    meth100IA64(8)
    meth100IA64(9)
    meth10IA64(100)
    meth10IA64(101)
    methIA64(1020)
    methIA64(1021)
    methIA64(1022)
    methIA64(1023)


#undef  methIA64
#define methIA64(i)                                                                                              \
        .##global __ForwarderStub_meth##i;                                                                       \
        .##proc   __ForwarderStub_meth##i;                                                                       \
__ForwarderStub_meth##i::                                                                                        \
        adds r19 = -ForwardingInterfaceStub_m_lpForwardingVtbl+ForwardingInterfaceStub_m_punkServerObject, r32;; \
        ld8  r19 = [r19];;                                                                                       \
        adds r19 = i*8, r19;;                                                                                    \
        ld8  r18 = [r19];;                                                                                       \
        mov  b2  = r18;;                                                                                         \
        br   b2;;                                                                                                \
        .##endp __ForwarderStub_meth##i;    

//****************************************************************************
//
// The following statements expand, using the macros defined above, into
// the methods used in interceptor vtbls. 
//
//****************************************************************************
    methIA64(3)
    methIA64(4)
    methIA64(5)
    methIA64(6)
    methIA64(7)
    methIA64(8)
    methIA64(9)
    meth10IA64(1)
    meth10IA64(2)
    meth10IA64(3)
    meth10IA64(4)
    meth10IA64(5)
    meth10IA64(6)
    meth10IA64(7)
    meth10IA64(8)
    meth10IA64(9)
    meth100IA64(1)
    meth100IA64(2)
    meth100IA64(3)
    meth100IA64(4)
    meth100IA64(5)
    meth100IA64(6)
    meth100IA64(7)
    meth100IA64(8)
    meth100IA64(9)
    meth10IA64(100)
    meth10IA64(101)
    methIA64(1020)
    methIA64(1021)
    methIA64(1022)
    methIA64(1023)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\inc\ndrclassic.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ndrclassic.h
//
#ifndef __NDRCLASSIC_H__
#define __NDRCLASSIC_H__

#define NDR_SERVER_SUPPORT
#define NDR_IMPORT_NDRP

//extern "C"
//    {
//    #include "interp.h"
//    #include "bufsizep.h"
//    #include "mrshlp.h"
//    #include "unmrshlp.h"
//    #include "freep.h"
//    #include "memsizep.h"
//    #include "endianp.h"
//    }

#define NdrAllocate( pStubMsg, AllocSize )  ((PBYTE)NdrInternalAlloc(AllocSize))
#define IGNORED(x)                          
#define RpcRaiseException(dw)               Throw(dw)
#define MIDL_wchar_strlen(wsz)              wcslen(wsz)

inline size_t MIDL_ascii_strlen(const unsigned char* sz)
    {
    return strlen((const char*) sz);
    }

HRESULT ChannelGetMarshalSizeMax (PMIDL_STUB_MESSAGE pStubMsg, ULONG *pulSize, REFIID riid, LPUNKNOWN pUnk, DWORD mshlflags);
HRESULT ChannelMarshalInterface  (PMIDL_STUB_MESSAGE pStubMsg, IStream* pstm, REFIID riid, LPUNKNOWN pUnk, DWORD mshlflags);
HRESULT ChannelUnmarshalInterface(PMIDL_STUB_MESSAGE pStubMsg, IStream* pstm, REFIID iid, void**ppv);

inline void SetMarshalFlags(PMIDL_STUB_MESSAGE pStubMsg, MSHLFLAGS mshlflags)
// Record the marshal flags somewhere in the stub message so we can dig it out later. We use
// one of the fields that our version of the NDR runtime doesn't support.
    {
    pStubMsg->SavedHandle = (handle_t)mshlflags;
    }

inline MSHLFLAGS GetMarshalFlags(PMIDL_STUB_MESSAGE pStubMsg)
    {
    return (MSHLFLAGS)(ULONG)PtrToUlong(pStubMsg->SavedHandle);
    }

////////////////////////////////////////////////////////////////////////////////////////////
//
// Inline routines. Here for visibility to all necessary clients
//
////////////////////////////////////////////////////////////////////////////////////////////

__inline void
NdrClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar *             pArg
    )
{
    long    Size;

    //
    // In an object proc, we must zero all [out] unique and interface
    // pointers which occur as the referent of a ref pointer or embedded in a
    // structure or union.
    //

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    //
    // The only top level [out] type allowed is a ref pointer or an array.
    //
    if ( *pFormat == FC_RP )
        {
        // Double pointer.
        if ( POINTER_DEREF(pFormat[1]) )
            {
            *((void **)pArg) = 0;
            return;
            }

        // Do we really need to zero out the basetype?
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            MIDL_memset( pArg, 0, (uint) SIMPLE_TYPE_MEMSIZE(pFormat[2]) );
            return;
            }

        // Pointer to struct, union, or array.
        pFormat += 2;
        pFormat += *((short *)pFormat);
        }

    Size = PtrToUlong(NdrpMemoryIncrement( pStubMsg,
                                       0,
                                       pFormat ));
    MIDL_memset( pArg, 0, (uint) Size );
}



PVOID NdrInternalAlloc(size_t cb);
void  NdrInternalFree(PVOID pv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\stdpch.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.cpp
//
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\iidndrmarshal.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// iidNdrMarshal.cpp
//
// Must be in a separate compilation unit, so that it gets put in it's own .obj
// and so gets pulled in independently by the linker, if and only if it is needed.
//
#include "stdpch.h"
// #include "common.h"

extern "C" const IID* iidsDontRegisterProxyStub[] =
    {
    NULL
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\compsinit.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// init.cpp
//
#include "stdpch.h"
#include "common.h"

// #pragma code_seg("INIT")

////////////////////////////////////////////////////
//
// COM Registration, etc
//

extern "C" HRESULT RPC_ENTRY thkNdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid)
    {
    return ComPs_NdrDllRegisterProxy(hDll, pProxyFileList, pclsid, iidsDontRegisterInterceptor, iidsDontRegisterProxyStub);
    }

extern "C" HRESULT RPC_ENTRY thkNdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid)
    {
    return ComPs_NdrDllUnregisterProxy(hDll, pProxyFileList, pclsid, iidsDontRegisterInterceptor, iidsDontRegisterProxyStub);
    }


//JohnDoty:  Removed KERNELMODE code here.
//           Lots of driver stuff.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\compsdriverentry.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// DriverEntry.cpp
//
// Must contain only the DriverEntry routine, so that it gets put in it's own .obj
// and so gets pulled in independently by the linker, if and only if it is needed.
//
#include "stdpch.h"
#include "common.h"

#pragma code_seg("INIT")

#ifdef KERNELMODE

extern "C" NTSTATUS __stdcall
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,     // our driver object
    IN PUNICODE_STRING RegistryPath     // our registry entry:  \Registry\Machine\System\ControlSet001\Services\"DriverName"
    )
    {
    return ComPs_DriverEntry(DriverObject, RegistryPath);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\common.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// common.h
//

#ifdef _DEBUG
#include "txfcommon.h"
#endif

#include "TxfRpcProxy.h"
#include "kom.h"

#define COMPSLIB
#include "ComPs.h"



extern "C" 
    { 
	//JohnDoty: We don't use these... they're for KERNELMODE stuff.
	//NTSTATUS __stdcall DriverEntry      (PDRIVER_OBJECT, PUNICODE_STRING);
	//NTSTATUS __stdcall ComPs_DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING);
	//void     __stdcall ComPs_DriverExit (IN PDRIVER_OBJECT DriverObject);
    //
    // These will be implemented by the proxy-stub itself
    //
    HRESULT __stdcall DllRegisterServer(void);
    HRESULT __stdcall DllUnregisterServer(void);
    //
    // This is implemented by rpcproxy.h, and so gets built into every proxy-stub.
    //
    void    __stdcall GetProxyDllInfo(const ProxyFileInfo*** pInfo, const CLSID ** pId);

    extern const IID* iidsDontRegisterInterceptor[];
    extern const IID* iidsDontRegisterProxyStub[];
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\sources.inc ===
#
# Viper build instructions for ComPs
#
#   Bob Atkinson
#   December 1997

!include ..\..\sources.txf

#TARGETNAME is defined in child sources
TARGETPATH=$(TARGETVIPBIN)
TARGETTYPE=LIBRARY

PRECOMPILED_INCLUDE         =..\stdpch.h
PRECOMPILED_CXX             =1
PRECOMPILED_SOURCEFILE      =..\stdpch.cpp


!if $(FREEBUILD)

VIPER_C_FLAGS = $(VIPER_C_FLAGS) /FAsc

!endif

SOURCES=                        \
        ..\compsthunk.cpp           \
    ..\ComPsinit.cpp            \
    ..\iidNoMarshal.cpp         \
    ..\iidNdrMarshal.cpp

#JohnDoty:  Pulled out ComPsDriverEntry.cpp since it only contains KernelMode
#           Code, and thus doesn't generate anything at all.  Waste of time.
#   ..\ComPsDriverEntry.cpp     \


i386_SOURCES=           \
    ..\i386\impthnk.asm
       
AMD64_SOURCES=          \
    ..\amd64\impthnk.asm

IA64_SOURCES=           \
    ..\ia64\impthnk.s
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\compsthunk.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// thunk.cpp
//
#include "stdpch.h"
#include "common.h"

////////////////////////////////////////////////////
//
// Instantiation
//

extern "C" HRESULT RPC_ENTRY thkNdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer)
    {
    return ComPs_NdrDllGetClassObject(rclsid, riid, ppv, pProxyFileList, pclsid, pPSFactoryBuffer);
    }

extern "C" HRESULT RPC_ENTRY thkNdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer * pPSFactoryBuffer)
    {
    return ComPs_NdrDllCanUnloadNow(pPSFactoryBuffer);
    }

////////////////////////////////////////////////////
//
// Memory Management
//

#define TXF_TAG (' fxT')

LPVOID RPC_ENTRY NdrOleAllocate(size_t cb)
    {
    #ifdef _DEBUG
        return AllocateMemory(cb);
    #else
        #ifdef KERNELMODE
            return ExAllocatePoolWithTag(PagedPool, cb, TXF_TAG); 
        #else
            return CoTaskMemAlloc((DWORD) cb);
        #endif
    #endif
    }


void RPC_ENTRY NdrOleFree(LPVOID pvToFree)
    {
    #ifdef _DEBUG
        FreeMemory(pvToFree);
    #else
        #ifdef KERNELMODE
            if (pvToFree) ExFreePool(pvToFree);
        #else
            CoTaskMemFree(pvToFree);
        #endif
    #endif
    }


////////////////////////////////////////////////////
//
// Delgation support

extern "C" long RPC_ENTRY NdrStubCall2(
        struct IRpcStubBuffer __RPC_FAR *    pThis,
        struct IRpcChannelBuffer __RPC_FAR * pChannel,
        PRPC_MESSAGE                         pRpcMsg,
        unsigned long __RPC_FAR *            pdwStubPhase
        )
    {
    return ComPs_NdrStubCall2(pThis, pChannel, pRpcMsg, pdwStubPhase);
    }

extern "C" void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD __RPC_FAR *   pdwStubPhase)
    {
    ComPs_NdrStubForwardingFunction(This, pChannel, pmsg, pdwStubPhase);
    }

extern "C" CLIENT_CALL_RETURN RPC_VAR_ENTRY NdrClientCall2(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    )
    {
    va_list va;
    va_start (va, pFormat);

    CLIENT_CALL_RETURN c = ComPs_NdrClientCall2_va(pStubDescriptor, pFormat, va);

    va_end(va);

    return c;
    }


////////////////////////////////////////////////////
//
// CStdStubBuffer implementation
//
extern "C" HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(IRpcStubBuffer *This, REFIID riid, void **ppvObject)
    {
    return ComPs_CStdStubBuffer_QueryInterface(This, riid, ppvObject);
    }

extern "C" ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(IRpcStubBuffer *This)
    {
    return ComPs_CStdStubBuffer_AddRef(This);
    }

extern "C" ULONG STDMETHODCALLTYPE NdrCStdStubBuffer_Release(IRpcStubBuffer *This, IPSFactoryBuffer* pPSF)
    {
    return ComPs_NdrCStdStubBuffer_Release(This, pPSF);
    }

extern "C" ULONG STDMETHODCALLTYPE NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF)
    {
    return ComPs_NdrCStdStubBuffer2_Release(This, pPSF);
    }

extern "C" HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(IRpcStubBuffer *This, IUnknown *pUnkServer)
    {
    return ComPs_CStdStubBuffer_Connect(This, pUnkServer);
    }

extern "C" void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(IRpcStubBuffer *This)
    {
    ComPs_CStdStubBuffer_Disconnect(This);
    }

extern "C" HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(IRpcStubBuffer *This, RPCOLEMESSAGE *pRpcMsg, IRpcChannelBuffer *pRpcChannelBuffer)
    {
    return ComPs_CStdStubBuffer_Invoke(This, pRpcMsg, pRpcChannelBuffer);
    }

extern "C" IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(IRpcStubBuffer *This, REFIID riid)
    {
    return ComPs_CStdStubBuffer_IsIIDSupported(This, riid);
    }

extern "C" ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(IRpcStubBuffer *This)
    {
    return ComPs_CStdStubBuffer_CountRefs(This);
    }

extern "C" HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(IRpcStubBuffer *This, void **ppv)
    {
    return ComPs_CStdStubBuffer_DebugServerQueryInterface(This, ppv);
    }

extern "C" void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(IRpcStubBuffer *This, void *pv)
    {
    ComPs_CStdStubBuffer_DebugServerRelease(This, pv);
    }


////////////////////////////////////////////////////
//
// Proxy IUnknown implementation
//


extern "C" HRESULT STDMETHODCALLTYPE 
IUnknown_QueryInterface_Proxy(IUnknown* This, REFIID riid, void**ppvObject)
    {
    return ComPs_IUnknown_QueryInterface_Proxy(This, riid, ppvObject);
    }

extern "C" ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy(IUnknown* This)
    {
    return ComPs_IUnknown_AddRef_Proxy(This);
    }

extern "C" ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy(IUnknown* This)
    {
    return ComPs_IUnknown_Release_Proxy(This);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\iidnomarshal.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// iidNoMarshal.cpp
//
// Must be in a separate compilation unit, so that it gets put in it's own .obj
// and so gets pulled in independently by the linker, if and only if it is needed.
//
#include "stdpch.h"
// #include "common.h"

extern "C" const IID* iidsDontRegisterInterceptor[] =
    {
    NULL
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//
#define _RPCRT4_

//JohnDoty: Removed KERNELMODE stuff

#include <stdio.h>
#include <stdarg.h>

extern "C" {

//JohnDoty: Removed dependancy on kernel headers
//#include "ntos.h"
//#include "zwapi.h"
//#include "fsrtl.h"

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#define NT_INCLUDED

#include "windows.h"
#include "objbase.h"

#include "rpcndr.h"

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\clinkable.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
/* -----------------------------------------------------------------------
   Microsoft Application Server (Microsoft Confidential)

   @rev 0 | 3/23/97 | jimbo  | Sherpa-M3
   @rev 1 | 10/9/98 | bobatk | made inline version in TXF
   ----------------------------------------------------------------------- */

//
// Includes
//
#include <Linkable.h>


//
// Class -- CLinkable
//		Elements on a linked list
//


//
// Member Function (public) -- InsertAfter
//		Insert 'that' onto the list after 'this'. Remove 'other' from its current
//		list, if necessary.
//
inline void CLinkable::InsertAfter( CLinkable* that )
{
	CLinkable* prev = that->m_pPrev;
	CLinkable* next = that->m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	next = this->m_pNext;

	this->m_pNext = that;
	that->m_pPrev = this;
	that->m_pNext = next;
	next->m_pPrev = that;
}


//
// Member Function (public) -- InsertBefore
//		Insert 'that' onto the list before 'this'. Remove 'other' from its current
//		list, if necessary.
//
inline void CLinkable::InsertBefore( CLinkable* that )
{
	CLinkable* prev = that->m_pPrev;
	CLinkable* next = that->m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	prev = this->m_pPrev;

	prev->m_pNext = that;
	that->m_pPrev = prev;
	that->m_pNext = this;
	this->m_pPrev = that;
}


//
// Member Function (public) -- Remove
//		Remove element from its current list, if any.
//
inline void CLinkable::Remove()
{
	CLinkable* prev = m_pPrev;
	CLinkable* next = m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	m_pPrev = m_pNext = this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\amd64\impthnk.asm ===
TITLE   impthnk.asm

;******************************************************************************
; PROJECT:      ComPs.Lib, impthnk.asm
; 
; Microsoft Viper 97. (c) Copyright 2001 Microsoft Corp. 
; All Rights Reserved.
;
; PURPOSE:      Assembly code that defines the __imp__ version of the RPC runtime
;           entry points that comps.lib must intercept.
;
;           We write in assembler because we must export a POINTER whose
;           name contains an '@' symbol, and you can't do that from C/C++.
;
; AUTHOR:   Bob Atkinson, December 1997
;
;******************************************************************************


_TEXT SEGMENT

        extern  _thkNdrDllRegisterProxy:proc
        extern  _thkNdrDllUnregisterProxy:proc
        extern  _thkNdrDllGetClassObject:proc
        extern  _thkNdrDllCanUnloadNow:proc

        PUBLIC __imp__NdrDllRegisterProxy  
        PUBLIC __imp__NdrDllUnregisterProxy
        PUBLIC __imp__NdrDllGetClassObject 
        PUBLIC __imp__NdrDllCanUnloadNow

__imp__NdrDllRegisterProxy   dq _thkNdrDllRegisterProxy
__imp__NdrDllUnregisterProxy dq _thkNdrDllUnregisterProxy
__imp__NdrDllGetClassObject  dq _thkNdrDllGetClassObject
__imp__NdrDllCanUnloadNow    dq _thkNdrDllCanUnloadNow

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\i386\impthnk.asm ===
;******************************************************************************
; PROJECT:	ComPs.Lib, impthnk.asm
; 
; Microsoft Viper 97. (c) Copyright 1997 Microsoft Corp. 
; All Rights Reserved.
;
; PURPOSE:	Assembly code that defines the __imp__ version of the RPC runtime
;           entry points that comps.lib must intercept.
;
;           We write in assembler because we must export a POINTER whose
;           name contains an '@' symbol, and you can't do that from C/C++.
;
; AUTHOR:   Bob Atkinson, December 1997
;
;******************************************************************************

TITLE	impthnk.asm
.386P
.model FLAT
assume fs:flat

_TEXT SEGMENT

EXTRN _thkNdrDllRegisterProxy@12:NEAR
EXTRN _thkNdrDllUnregisterProxy@12:NEAR
EXTRN _thkNdrDllGetClassObject@24:NEAR
EXTRN _thkNdrDllCanUnloadNow@4:NEAR

PUBLIC __imp__NdrDllRegisterProxy@12  
PUBLIC __imp__NdrDllUnregisterProxy@12
PUBLIC __imp__NdrDllGetClassObject@24 
PUBLIC __imp__NdrDllCanUnloadNow@4

__imp__NdrDllRegisterProxy@12       DD _thkNdrDllRegisterProxy@12
__imp__NdrDllUnregisterProxy@12     DD _thkNdrDllUnregisterProxy@12
__imp__NdrDllGetClassObject@24      DD _thkNdrDllGetClassObject@24
__imp__NdrDllCanUnloadNow@4         DD _thkNdrDllCanUnloadNow@4

_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\comps\ia64\impthnk.s ===
//==============================================================================
// PROJECT: ComPs.Lib, impthnk.s
//
// Microsoft (c) Copyright 2000 Microsoft Corp.
// All Rights Reserved.
//
// PURPOSE: Assembly code that defines the __imp__ version of the RPC runtime
//          entry points that ComPs.lib must intercept.
//
//          On IA64, this could be done in C instead of assembly, but using
//          assembly code is consistent with the other architectures, so
//          we use it.
//
// AUTHOR:  John Strange (JohnStra)   February 2000
//            * This is a direct port to IA64 of Bob Atkinson's i386 and
//              alpha implementations, so he gets credit for figuring out
//              how to do this.
//
//==============================================================================
        #include "ksia64.h"

        .text

        .global __imp_NdrDllRegisterProxy#
        .global __imp_NdrDllUnregisterProxy#
        .global __imp_NdrDllGetClassObject#
        .global __imp_NdrDllCanUnloadNow#

	.type	thkNdrDllRegisterProxy#	,@function 
        .global thkNdrDllRegisterProxy#
	.type	thkNdrDllUnregisterProxy#	,@function 
        .global thkNdrDllUnregisterProxy#
	.type	thkNdrDllGetClassObject#	,@function 
        .global thkNdrDllGetClassObject#
	.type	thkNdrDllCanUnloadNow#	,@function 
        .global thkNdrDllCanUnloadNow#

	.section	.sdata
__imp_NdrDllRegisterProxy:
	data8	@fptr(thkNdrDllRegisterProxy#)
__imp_NdrDllUnregisterProxy:
	data8	@fptr(thkNdrDllUnregisterProxy#)
__imp_NdrDllGetClassObject:
	data8	@fptr(thkNdrDllGetClassObject#)
__imp_NdrDllCanUnloadNow:
	data8	@fptr(thkNdrDllCanUnloadNow#)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\comps.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// comps.h
//
// Definitions exported from Kom to the ComPs static library

#define N(x)    x

#ifdef __cplusplus
extern "C" {
#endif
    HRESULT __stdcall N(ComPs_CStdStubBuffer_QueryInterface)   (IRpcStubBuffer *This, REFIID, void**);
    ULONG   __stdcall N(ComPs_CStdStubBuffer_AddRef)           (IRpcStubBuffer *This);
    ULONG   __stdcall N(ComPs_NdrCStdStubBuffer_Release)       (IRpcStubBuffer *This, IPSFactoryBuffer* pPSF);
    ULONG   __stdcall N(ComPs_NdrCStdStubBuffer2_Release)      (IRpcStubBuffer *This, IPSFactoryBuffer* pPSF);

    HRESULT __stdcall N(ComPs_CStdStubBuffer_Connect)          (IRpcStubBuffer *This, IUnknown *pUnkServer);
    void    __stdcall N(ComPs_CStdStubBuffer_Disconnect)       (IRpcStubBuffer *This);
    HRESULT __stdcall N(ComPs_CStdStubBuffer_Invoke)           (IRpcStubBuffer *This, RPCOLEMESSAGE *pRpcMsg, IRpcChannelBuffer *pRpcChannelBuffer);
    IRpcStubBuffer* __stdcall N(ComPs_CStdStubBuffer_IsIIDSupported)(IRpcStubBuffer *This, REFIID riid);
    ULONG   __stdcall N(ComPs_CStdStubBuffer_CountRefs)        (IRpcStubBuffer *This);
    HRESULT __stdcall N(ComPs_CStdStubBuffer_DebugServerQueryInterface)(IRpcStubBuffer *This, void **ppv);
    void    __stdcall N(ComPs_CStdStubBuffer_DebugServerRelease)(IRpcStubBuffer *This, void *pv);



    HRESULT __stdcall N(ComPs_IUnknown_QueryInterface_Proxy)   (IUnknown* This, REFIID riid, void**ppvObject);
    ULONG   __stdcall N(ComPs_IUnknown_AddRef_Proxy)           (IUnknown* This);
    ULONG   __stdcall N(ComPs_IUnknown_Release_Proxy)          (IUnknown* This);


    HRESULT __stdcall N(ComPs_NdrDllRegisterProxy)(
        IN HMODULE                  hDll,
        IN const ProxyFileInfo **   pProxyFileList,
        IN const CLSID *            pclsid,
        IN const IID**              rgiidNoCallFrame,
        IN const IID**              rgiidNoMarshal
        );

    HRESULT __stdcall N(ComPs_NdrDllUnregisterProxy)(
        IN HMODULE                  hDll,
        IN const ProxyFileInfo **   pProxyFileList,
        IN const CLSID *            pclsid,
        IN const IID**              rgiidNoCallFrame,
        IN const IID**              rgiidNoMarshal
        );


    HRESULT __stdcall N(ComPs_NdrDllGetClassObject)(
        IN  REFCLSID                rclsid,
        IN  REFIID                  riid,
        OUT void **                 ppv,
        IN const ProxyFileInfo **   pProxyFileList,
        IN const CLSID *            pclsid,
        IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

    HRESULT __stdcall N(ComPs_NdrDllCanUnloadNow)(
        IN CStdPSFactoryBuffer * pPSFactoryBuffer);


    CLIENT_CALL_RETURN RPC_VAR_ENTRY N(ComPs_NdrClientCall2)(
        PMIDL_STUB_DESC                     pStubDescriptor,
        PFORMAT_STRING                      pFormat,
        ...
        );

    CLIENT_CALL_RETURN __stdcall N(ComPs_NdrClientCall2_va)(
            PMIDL_STUB_DESC pStubDescriptor,
            PFORMAT_STRING  pFormat,
            va_list         va
            );

    long __stdcall N(ComPs_NdrStubCall2)(
        struct IRpcStubBuffer __RPC_FAR *    pThis,
        struct IRpcChannelBuffer __RPC_FAR * pChannel,
        PRPC_MESSAGE                         pRpcMsg,
        unsigned long __RPC_FAR *            pdwStubPhase
        );

    ///////////////////////////////////////////////////////////////////////////////
    //
    // Support for forwarding to base in stubs

    void __stdcall N(ComPs_NdrStubForwardingFunction)(IRpcStubBuffer*, IRpcChannelBuffer*, PRPC_MESSAGE pmsg, DWORD* pdwStubPhase);
    // The actual workhorse, exported from KomDll / KomSys

#ifdef __cplusplus
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\comregistration.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ComRegistration.h
//
// A simple utility class that manages COM registration for you.
//
// To register a class, construct a instance of CComRegistration on the stack. Then:
//      Manditory: set the fields:
//          hModule     - module handle of the DLL to be registered
//          clsid       - clsid to register it under
//      Optional: set the remaining fields
//      Finally: call Register();
//
// To unregister a class, construct an instance of CComRegistration on the stack, 
//      set at least the clsid and hModule fields, then call Unregister(). If progID or 
//      versionIndependentProgID is not provided, they are computed from the information
//      presently found in the registry.
//
// Note that this class is fully Unicode. To be able to use it on Win95, you must 
// link with the Viper thunk libraries.
//

#ifndef _COMREGISTRATION_H_
#define _COMREGISTRATION_H_

#include <memory.h>

/////////////////////////////////////////////////////////////////////////////////////
//
// Registering information about a particular CLSID
//

#define CComRegistration ClassRegistration          // temporary, until we can change existing clients to use the new name

#ifndef LEGACY_VIPER_TREE
typedef GUID APPID;
#endif

class ClassRegistration
    {
public:
    
    //
    // REVIEW: We should eliminate SERVER_TYPE and just use the CLSCTX values
    //
    enum SERVER_TYPE
        {                       
        INPROC_SERVER    = CLSCTX_INPROC_SERVER,    // an inproc server (default)
        LOCAL_SERVER     = CLSCTX_LOCAL_SERVER,     // a  local server
        INPROC_HANDLER   = CLSCTX_INPROC_HANDLER,   // an inproc handler for a local server
        SERVER_TYPE_NONE = 0,                       // don't do any server dll/exe registration
        };

    CLSID               clsid;                      // class identifier to register
    DWORD               serverType;                 // what flavor of server to register
    HMODULE             hModule;                    // module handle of EXE/DLL being registered
    LPCWSTR             className;                  // e.g. "Recorder Class"
    LPCWSTR             progID;                     // e.g. "MTS.Recorder.1"
    LPCWSTR             versionIndependentProgID;   // e.g. "MTS.Recorder"
    LPCWSTR             threadingModel;             // e.g. "Both", "Free". Only for servers of type INPROC_SERVER.
    APPID               appid;                      // optional AppId to associate with this class
    
    GUID                moduleid;                   // for kernel servers: the id of the module under which to register
    BOOL                fCreateService;             // for kernel servers: whether we should create the service or assume it's there
    

    ClassRegistration()
        {
        memset(this, 0, sizeof(ClassRegistration)); // we have no virtual functions, so this is OK
        serverType = INPROC_SERVER;
        }
    
    HRESULT Register();         // Make CLASS registry entries
    HRESULT Unregister();       // Remove CLASS registry entries
    };


/////////////////////////////////////////////////////////////////////////////////////
//
// Registering information about a particular APPID
//

class AppRegistration
    {
public:
    APPID               appid;                      // app identifier to register
    LPCWSTR             appName;                    // name of said appid
    BOOL                dllSurrogate;               // if true, then set the DllSurrogate entry
    HMODULE             hModuleSurrogate;           // used to form DllSurrogate path

    HRESULT Register();
    HRESULT Unregister();

    AppRegistration()
        {
        memset(this, 0, sizeof(AppRegistration));
        }

    };


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\enum_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __ENUM_INCLUDED__
#define __ENUM_INCLUDED__

// Expected enumerator usage:
//	XS xs;
//	EnumXS exs(xs);
//	while (exs.next())
//		exs.get(&x);
//	exs.reset();
//	while (exs.next())
//		exs.get(&x)

class Enum {
public:
    virtual void reset() =0;
    virtual BOOL next() =0;
};

#endif // !__ENUM_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\genericclassfactory.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// GenericClassFactory.h
//
// A generic instantiator that drives two-phase initialization of COM objects
// that support aggregation through IUnkInner, together with a class factory
// wrapper on top of same.

#ifndef __GenericClassFactory__h__
#define __GenericClassFactory__h__

#ifndef STDCALL
#define STDCALL __stdcall
#endif

///////////////////////////////////////////////////////////////////////////////////////
//
// Generic instance creation function

template <class ClassToInstantiate>
class GenericInstantiator
    {
public:
    template <class T>
    static HRESULT CreateInstance(IUnknown* punkOuter, T*& pt)
        {
        return CreateInstance(punkOuter, __uuidof(T), (void**)&pt);
        }

    static HRESULT CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv, POOL_TYPE poolType = PagedPool)
        {
        HRESULT hr = S_OK;
        ASSERT(ppv && (punkOuter == NULL || iid == IID_IUnknown));
        if  (!(ppv && (punkOuter == NULL || iid == IID_IUnknown))) return E_INVALIDARG;
   
        *ppv = NULL;
        #ifdef _DEBUG
        ClassToInstantiate* pnew = new(poolType, _ReturnAddress()) ClassToInstantiate(punkOuter);
        #else
        ClassToInstantiate* pnew = new(poolType) ClassToInstantiate(punkOuter);
        #endif
        if (pnew)
            {
            IUnkInner* pme = (IUnkInner*)pnew;
            hr = pnew->Init();
            if (hr == S_OK)
                {
                hr = pme->InnerQueryInterface(iid, ppv);
                }
            pme->InnerRelease();                // balance starting ref cnt of one    
            }
        else 
            hr = E_OUTOFMEMORY;
    
        return hr;
        }

    static HRESULT New(OUT ClassToInstantiate** ppNewT, POOL_TYPE poolType = PagedPool)
        {
        HRESULT hr = S_OK;

        ClassToInstantiate* pnew = new(poolType) ClassToInstantiate();
        if (pnew)
            {
            hr = pnew->Init();
            if (hr == S_OK)
                {
                }
            else
                {
                delete pnew;
                pnew = NULL;
                }
            }

        *ppNewT = pnew;

        return hr;
        }
    };

//
////////////////////////////////////////////////////////////////////////////////////
//
// Generic class factory implemenation

template <class ClassToInstantiate>
class GenericClassFactory : public IClassFactory
    {
public:
    GenericClassFactory() : m_crefs(1)  // NB: starting reference count of one
        {
        }

public:
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
        {
        if (NULL == ppv)
            return E_INVALIDARG;

        if (iid == IID_IUnknown || iid == IID_IClassFactory)
            {
            *ppv = (IClassFactory*)this;
            }
        else
            {
            *ppv = NULL;
            return E_NOINTERFACE;
            }

        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
        }

    ULONG STDCALL AddRef()  { InterlockedIncrement (&m_crefs); return (m_crefs); }
    ULONG STDCALL Release() { long cRef = InterlockedDecrement(&m_crefs); if (cRef == 0) delete this; return cRef; }

public:
    HRESULT STDCALL LockServer (BOOL fLock) { return S_OK; }

    HRESULT STDCALL CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv)
        {
        return GenericInstantiator< ClassToInstantiate >::CreateInstance(punkOuter, iid, ppv);
        }

    
private:
    long m_crefs;
    };

//
////////////////////////////////////////////////////////////////////////////////////
//
// Generic unloadable class factory implemenation
//
#include "kom.h"

template <class ClassToInstantiate>
class GenericUnloadableClassFactory : public IClassFactory
    {
public:
    GenericUnloadableClassFactory(COM_MODULE_INFO* pDriverInfo)
        {
        ASSERT(pDriverInfo);
        m_crefs = 1;                     // NB: starting reference count of one
        m_pDriverInfo = pDriverInfo;
        InterlockedIncrement(&pDriverInfo->crefsModule);
        }

public:
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
        {
        if (NULL == ppv)
            return E_INVALIDARG;

        if (iid == IID_IUnknown || iid == IID_IClassFactory)
            {
            *ppv = (IClassFactory*)this;
            }
        else
            {
            *ppv = NULL;
            return E_NOINTERFACE;
            }

        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
        }

    ULONG STDCALL AddRef()  { InterlockedIncrement (&m_crefs); return (m_crefs); }
    ULONG STDCALL Release() { return KoRelease(m_pDriverInfo, this, &m_crefs, operator delete); }

public:
    HRESULT STDCALL LockServer (BOOL fLock) { return S_OK; }

    HRESULT STDCALL CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv)
        {
        return GenericInstantiator< ClassToInstantiate >::CreateInstance(punkOuter, iid, ppv);
        }

    
private:
    long m_crefs;
    COM_MODULE_INFO* m_pDriverInfo;
    };


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\concurrent.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Concurrent.h
//
#ifndef __CONCURRENT_H__
#define __CONCURRENT_H__

////////////////////////////////////////////////////////////////////////////////////////////
//
// EVENT - A user / kernel implementation of an event object.
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE

class EVENT
    {
    KEVENT m_kevent;
    #ifdef _DEBUG
    BOOL   m_fInitialized;
    #endif

public:
    EVENT(BOOL manualReset, BOOL fSignalled)
        {
        DEBUG(m_fInitialized = FALSE);
        Initialize(manualReset, fSignalled);
        }
    EVENT()
        {
        DEBUG(m_fInitialized = FALSE;)
        }
    void Initialize(BOOL manualReset, BOOL fSignalled)
        {
        ASSERT(!m_fInitialized);
        KeInitializeEvent(&m_kevent, manualReset ? NotificationEvent : SynchronizationEvent, fSignalled);
        DEBUG(m_fInitialized = TRUE;)
        }
    HRESULT IsConstructed()
        {
        #ifdef _DEBUG
            return m_fInitialized ? S_OK : E_OUTOFMEMORY;
        #else
            return S_OK;
        #endif
        }
    ~EVENT()
        {
        /* nothing to do */
        }

    NTSTATUS Wait(ULONG msWait = INFINITE)
        {
        ASSERT(m_fInitialized);
        LARGE_INTEGER lTenthsOfMicroseconds;
        lTenthsOfMicroseconds.QuadPart = (LONGLONG)msWait * 10000;
        return KeWaitForSingleObject(&m_kevent, UserRequest, KernelMode, FALSE, msWait == INFINITE ? NULL : &lTenthsOfMicroseconds);
        }

    void Set()
        {
        ASSERT(m_fInitialized);
        KeSetEvent(&m_kevent, 0, FALSE);
        }

    void Reset()
        {
        ASSERT(m_fInitialized);
        KeClearEvent(&m_kevent);
        }

    };


class EVENT_INDIRECT
    {
    EVENT*  m_pevent;

public:

    EVENT_INDIRECT(BOOL manualReset, BOOL fSignalled)
        {
        m_pevent = new EVENT(manualReset, fSignalled);
        }

    EVENT_INDIRECT()
        {
        m_pevent = new EVENT();
        }
    void Initialize(BOOL manualReset, BOOL fSignalled)
        {
        m_pevent->Initialize(manualReset, fSignalled);
        }

    HRESULT IsConstructed()
        {
        return m_pevent? m_pevent->IsConstructed() : E_OUTOFMEMORY;
        }

    ~EVENT_INDIRECT()
        {
        delete m_pevent;
        }

    NTSTATUS Wait(ULONG msWait = INFINITE)
        {
        return m_pevent->Wait(msWait);
        }

    void Set()
        {
        m_pevent->Set();
        }

    void Reset()
        {
        m_pevent->Set();
        }

    };

////////////////////////////////////////////////////////////////////////////////////////////
#else // USERMODE

class EVENT
    {
    HANDLE m_hEvent;

public:
    EVENT(BOOL manualReset, BOOL fSignalled)
        {
        m_hEvent = NULL;
        Initialize(manualReset, fSignalled);
        }
    EVENT()
        {
        m_hEvent = NULL;
        ASSERT(!IsInitialized());
        }
    void Initialize(BOOL manualReset, BOOL fSignalled)
        {
        ASSERT(!IsInitialized());
        m_hEvent = CreateEvent(NULL, manualReset, fSignalled, NULL);
        if (m_hEvent == NULL) FATAL_ERROR();
        ASSERT(IsInitialized());
        }
    BOOL IsInitialized()
        {
        return m_hEvent != NULL;
        }
    HRESULT IsConstructed()
        {
        return IsInitialized() ? S_OK : E_OUTOFMEMORY;
        }

    ~EVENT()
        {
        if (m_hEvent) CloseHandle(m_hEvent); DEBUG(m_hEvent = NULL;);
        }

    NTSTATUS Wait(ULONG msWait = INFINITE)
        {
        ASSERT(IsInitialized());
        DWORD ret = WaitForSingleObject(m_hEvent, msWait);
        switch (ret)
            {
        case WAIT_TIMEOUT:  return STATUS_TIMEOUT;
        case WAIT_OBJECT_0: return STATUS_SUCCESS;
        default:            return STATUS_ALERTED;  // REVIEW
            }
        }

    void Set()
        {
        ASSERT(IsInitialized());
        SetEvent(m_hEvent);
        }

    void Reset()
        {
        ASSERT(IsInitialized());
        ResetEvent(m_hEvent);
        }

    HANDLE& GetHandle() { return m_hEvent; }
    };

typedef EVENT EVENT_INDIRECT;

#endif






////////////////////////////////////////////////////////////////////////////////////////////
//
// SEMAPHORE - A user / kernel implementation of a semaphore
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE

class SEMAPHORE
    {
    KSEMAPHORE m_ksem;

public:
    SEMAPHORE(LONG count = 0, LONG limit = MAXLONG)
        {
        Initialize(count, limit);
        }
    ~SEMAPHORE()
        {
        /* nothing to do */
        }

    void Initialize(LONG count = 0, LONG limit = MAXLONG)
        {
        KeInitializeSemaphore(&m_ksem, count, limit);
        }

    void Wait(ULONG msWait = INFINITE)
        {
        LARGE_INTEGER lTenthsOfMicroseconds;
        lTenthsOfMicroseconds.QuadPart = (LONGLONG)msWait * 10000;
        KeWaitForSingleObject(&m_ksem, UserRequest, KernelMode, FALSE, msWait == INFINITE ? NULL : &lTenthsOfMicroseconds);
        }

    void Release(ULONG count = 1)
        {
        KeReleaseSemaphore(&m_ksem, /*priority inc*/0, /*adjust*/count, /*wait*/FALSE);
        }

    };

////////////////////////////////////////////////////////////////////////////////////////////
#else // USERMODE

class SEMAPHORE
    {
    HANDLE m_hSem;

public:
    SEMAPHORE(LONG count, LONG limit = MAXLONG)
        {
        m_hSem = NULL;
        Initialize(count, limit);
        }
    SEMAPHORE()
        {
        m_hSem = NULL;
        }
    void Initialize(LONG count = 0, LONG limit = MAXLONG)
        {
        m_hSem = CreateSemaphore(NULL, count, limit, NULL);
        if (m_hSem == NULL) FATAL_ERROR();
        }
    BOOL IsInitialized()
        {
        return m_hSem != NULL;
        }
    ~SEMAPHORE()
        {
        if (m_hSem) CloseHandle(m_hSem);
        }

    void Wait(ULONG msWait = INFINITE)
        {
        WaitForSingleObject(m_hSem, msWait);
        }

    void Release(ULONG count = 1)
        {
        ReleaseSemaphore(m_hSem, count, NULL);
        }

    };

#endif



////////////////////////////////////////////////////////////////////////////////////////////
//
// Use these macros in your code to actually use this stuff. Declare a variable of type
// XSLOCK and name m_lock. Or invent your own variation on these macros and call the
// XSLOCK methods as you see fit.
//

#define __SHARED(lock)      (lock).LockShared();       __try {
#define __EXCLUSIVE(lock)   (lock).LockExclusive();    __try {
#define __DONE(lock)        } __finally { (lock).ReleaseLock(); }  

#define __SHARED__      __SHARED(m_lock)
#define __EXCLUSIVE__   __EXCLUSIVE(m_lock)
#define __DONE__        __DONE(m_lock)


////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK - supports only exclusive locks. That is, it supports the LockExclusive() and ReleaseLock() 
//         methods (recursively) but does not support LockShared(). An XLOCK is recursively
//         acquirable.
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE
    
    // defined later

#else

//
// NOTE: This constructor can throw an exception when out of memory.
//
class XLOCK
    {
    CRITICAL_SECTION critSec;
    BOOL m_fCsInitialized;
public:
    XLOCK() : m_fCsInitialized(FALSE) {}
    BOOL FInit()                      
    { 
        if (m_fCsInitialized == FALSE)
       	{
        	NTSTATUS status = RtlInitializeCriticalSection(&critSec);
           	if (NT_SUCCESS(status))
           		m_fCsInitialized = TRUE;
           	}
        return m_fCsInitialized;
    }

    BOOL FInited() { return m_fCsInitialized; }
        	
    HRESULT IsConstructed()                { return S_OK; }

    ~XLOCK()
    {
        if (m_fCsInitialized == TRUE) 
        {
#ifdef _DEBUG
            NTSTATUS status =
#endif
            RtlDeleteCriticalSection(&critSec); // if RtlDeleteCriticalSection fails, tough luck--we leak. 
#ifdef _DEBUG                       // But I'm asserting for it to see if we ever really hit it.
            ASSERT(NT_SUCCESS(status));
#endif
        }
    }
    BOOL LockExclusive(BOOL fWait=TRUE)    
    { 
        ASSERT(fWait); 
        VALIDATE(); 
        ASSERT(m_fCsInitialized == TRUE);
        EnterCriticalSection(&critSec); 
        return TRUE; 
    }
    void ReleaseLock()
    { 
        VALIDATE(); 
        ASSERT(m_fCsInitialized == TRUE);
        LeaveCriticalSection(&critSec);
    }

#ifdef _DEBUG
    BOOL WeOwnExclusive()   
        { 
        ASSERT(this);
        return 
            (THREADID)critSec.OwningThread == GetCurrentThreadId() &&  // that someone is us
                      critSec.LockCount    >= 0;                       // is locked by someone
        }
    void VALIDATE()
        {
        ASSERT(critSec.LockCount != 0xDDDDDDDD);    // This is the memory pattern set by the debug memory allocator upon freeing
        }
#else
    void VALIDATE() { }
#endif
    };

#endif



////////////////////////////////////////////////////////////////////////////////////////////
//
// XSLOCK - supports both exclusive and shared locks
// 
// This specification describes functionality that implements multiple-readers, 
// single-writer access to a shared resource.  Access is controlled via a shared resource 
// variable and a set of routines to acquire the resource for shared access (also commonly 
// known as read access) or to acquire the resource for exclusive access (also called 
// write access).
//
// A resource is logically in one of three states:
//	o	Acquired for shared access
//	o	Acquired for exclusive access
//	o	Released (i.e., not acquired for shared or exclusive access)
//
// Initially a resource is in the released state, and can be acquired for either shared or 
// exclusive access by a user.  
//
// A resource that is acquired for shared access can be acquired by other users for shared 
// access.  The resource stays in the acquired for shared access state until all users that 
// have acquired it have released the resource, and then it becomes released.  Each resource, 
// internally, maintains information about the users that have been granted shared access.
//
// A resource that is acquired for exclusive access cannot be acquired by other users until 
// the single user that has acquired the resource for exclusive access releases the resource.  
// However, a thread can recursively acquire exclusive access to the same resource without blocking.
//
// The routines described in this specification do not return to the caller until the 
// resource has been acquired.
//

#ifdef KERNELMODE 


//////////////////////////////////////////////////////////////////////////////////////
// 
// Kernel mode implementation - simply a wrapper for ERESOURCE
//
class XSLOCK : public NonPaged
    {
public:

    ERESOURCE m_resource;

    XSLOCK()                                { ExInitializeResource(&m_resource);    }
    ~XSLOCK()                               { ExDeleteResource(&m_resource);        }

    HRESULT IsConstructed()                 { return S_OK;                          }

    BOOL LockShared(BOOL fWait=TRUE)        { return ExAcquireResourceShared    (&m_resource, fWait); }
    BOOL LockExclusive(BOOL fWait=TRUE)     { return ExAcquireResourceExclusive (&m_resource, fWait); }
    void ReleaseLock()                      {        ExReleaseResource          (&m_resource);        }
    void Promote()                          {        ReleaseLock();  LockExclusive();                 }
    void Demote()                           {        ExConvertExclusiveToShared (&m_resource);        }

    BOOL WeOwnExclusive()     { ASSERT(this); return ExIsResourceAcquiredExclusive(&m_resource);      }
    BOOL WeOwnShared()        { ASSERT(this); return ExIsResourceAcquiredShared   (&m_resource);      }
    };

#else
//////////////////////////////////////////////////////////////////////////////////////
// 
// User mode implementation
//
// NOTE: The constructor for XSLOCK can throw an exception when out of memory, as it
//       contains an XLOCK, which contains a critical section.
//
class XSLOCK
    {
    struct OWNERENTRY
        {
        THREADID dwThreadId;
        union
            {
            LONG    ownerCount;                     // normal usage
            ULONG   tableSize;                      // only in entry m_ownerTable[0]
            };

        OWNERENTRY()
            {
            dwThreadId = 0;
            ownerCount = 0;
            }
        };

    XLOCK               m_lock;                     // controls access during locks & unlocks
    ULONG               m_cOwner;                   // how many threads own this lock
    OWNERENTRY          m_ownerThreads[2];          // 0 is exclusive owner; 1 is first shared. 0 can be shared in demote case
    OWNERENTRY*         m_ownerTable;               // the rest of the shared
    EVENT               m_eventExclusiveWaiters;    // the auto-reset event that exclusive guys wait on
    SEMAPHORE           m_semaphoreSharedWaiters;   // what shared guys wait on
    ULONG               m_cExclusiveWaiters;        // how many threads are currently waiting for exclusive access?
    ULONG               m_cSharedWaiters;           // how many threads are currently waiting for shared access?
    BOOL                m_isOwnedExclusive;         // whether we are at present owned exclusively
    
    BOOL            IsSharedWaiting();
    BOOL            IsExclusiveWaiting();
    OWNERENTRY*     FindThread      (THREADID dwThreadId);
    OWNERENTRY*     FindThreadOrFree(THREADID dwThreadId);
    void            LetSharedRun();
    void            LetExclusiveRun();
    void            SetOwnerTableHint(THREADID dwThreadId, OWNERENTRY*);
    ULONG           GetOwnerTableHint(THREADID dwThreadId);

    void            LockEnter();
    void            LockExit();

#ifdef _DEBUG
    void            CheckInvariants();
    BOOL            fCheckInvariants;
#endif

public:
     XSLOCK();
    ~XSLOCK();

    ////////////////////////////////////////////////////////////////////
    //
    // 2-phase construction. You must call FInit for an XSLOCK object to be
    // ready for use. Returns TRUE if initialization successful, otherwise FALSE.
    //
    BOOL FInit() { return m_lock.FInit(); }

    ////////////////////////////////////////////////////////////////////
    //
    // Lock for shared access. Shared locks may be acquired recursively,
    // (as can exclusive locks). Further, many threads can simultaneously
    // hold a shared lock, but not concurrently with any exclusive locks.
    // However, it _is_ permissible for the one thread which holds an 
    // exclusive lock to attempt to acquire a shared lock -- the shared lock 
    // request is automatically turned into a (recursive) exclusive lock 
    // request.
    //
    BOOL LockShared(BOOL fWait=TRUE);

    ////////////////////////////////////////////////////////////////////
    //
    // Lock for exclusive access. Exclusive locks may be acquired
    // recursively. At most one thread can hold concurrently hold an
    // exclusive lock.
    //
    BOOL LockExclusive(BOOL fWait=TRUE);

    ////////////////////////////////////////////////////////////////////
    //
    // Release the lock that this thread most recently acquired.
    //
    void ReleaseLock();

    ////////////////////////////////////////////////////////////////////
    //
    // Promote a shared lock to exlusive access. Similar in function to releasing a 
    // shared resource and then acquiring it for exclusive access; however, in the 
    // case where only one user has the resource acquired with shared access, the 
    // conversion to exclusive access with Promote can perhaps be more efficient.
    //
    void Promote()
        {
        ReleaseLock();
        LockExclusive();
        }

    ////////////////////////////////////////////////////////////////////
    //
    // Demote an exclusive lock to shared access. Similar in function to releasing an
    // exclusive resource and then acquiring it for shared access; however the user  
    // calling Demote probably does not relinquish access to the resource as the two 
    // step operation does.
    //
    void Demote();


    ////////////////////////////////////////////////////////////////////
    //
    // This routine determines if a resource is acquired exclusive by the
    // calling thread
    //
    BOOL WeOwnExclusive();

    ////////////////////////////////////////////////////////////////////
    //
    // This routine determines if a resource is acquired shared by the calling thread
    //
    BOOL WeOwnShared();

    ////////////////////////////////////////////////////////////////////
    //
    // Has this object been successfully constructed?
    //
    HRESULT IsConstructed() { return S_OK; }

    };

#endif


////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK - supports only exclusive locks. That is, it supports the LockExclusive() and ReleaseLock() 
//         methods (recursively) but does not support LockShared().
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE
    
    typedef XSLOCK XLOCK; // for now until we get better implementation

#else

    // defined above

#endif


////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK_SPIN - An exclusive lock that (generally) is NOT recursively acquirable. While
//              holding a spin lock, you cannot take page faults.
//
//              The key semantics here are dictated by the existing kernel mode code.
//
////////////////////////////////////////////////////////////////////////////////////////////


#ifdef KERNELMODE

class XLOCK_SPIN : public NonPaged
    {
    KSPIN_LOCK      m_lock;
    KIRQL           m_irql;       // when we have the lock, this is the previous irql
    
    #ifdef _DEBUG
    THREADID        m_threadId;
    ULONG           m_five;
    #endif

public:

    XLOCK_SPIN()
        {
        Initialize();
        }

    void Initialize()
        {
        KeInitializeSpinLock(&m_lock);
        DEBUG(m_threadId = NULL);
        DEBUG(m_five     = 5);
        }

    HRESULT IsConstructed() { return S_OK; }

    BOOL LockExclusive(BOOL fWait = TRUE)
        {
        ASSERT(fWait);
        ASSERT(!WeOwnExclusive());
        ASSERT(5 == m_five);
        KeAcquireSpinLock(&m_lock, &m_irql);
        DEBUG(m_threadId = GetCurrentThreadId());
        ASSERT(WeOwnExclusive());
        return TRUE;
        }

    void ReleaseLock()
        {
        ASSERT(WeOwnExclusive());
        ASSERT(5 == m_five);
        DEBUG(m_threadId = NULL);
        KeReleaseSpinLock(&m_lock, m_irql);
        ASSERT(!WeOwnExclusive());
        }

    #ifdef _DEBUG
    BOOL WeOwnExclusive()
        {
        ASSERT(this);
        return m_threadId == GetCurrentThreadId();
        }
    #endif
    };  

#else

// User mode implementation of spin locks just uses XLOCK, but checks to ensure
// that we're not acquiring recursively for compatibility with kernel mode.
//
struct XLOCK_SPIN : public XLOCK
    {
    BOOL LockExclusive(BOOL fWait = TRUE)
        {
        ASSERT(!WeOwnExclusive());
        return XLOCK::LockExclusive(fWait);
        }    
    };

#endif


////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK_LEAF - An exclusive lock that is NOT recursively acquirable, yet in kernel mode 
//              doesn't mess with your irql. You can take page faults while holding an
//              XLOCK_LEAF.
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE

class XLOCK_LEAF : public NonPaged
    {
    FAST_MUTEX  m_lock;

    #ifdef _DEBUG
    THREADID        m_threadId;
    ULONG           m_five;
    #endif

public:
    
    XLOCK_LEAF()
        {
        Initialize();
        }

    void Initialize()
        {
        ExInitializeFastMutex(&m_lock);
        DEBUG(m_threadId = NULL);
        DEBUG(m_five     = 5);
        }

    HRESULT IsConstructed() { return S_OK; }

    BOOL LockExclusive(BOOL fWait = TRUE)
        {
        BOOL fResult;
        ASSERT(!WeOwnExclusive());
        ASSERT(5 == m_five);

        if (fWait)
            {
            ExAcquireFastMutex(&m_lock);
            fResult = TRUE;
            }
        else
            fResult = ExTryToAcquireFastMutex(&m_lock);

        DEBUG(if (fResult) { m_threadId = GetCurrentThreadId(); });
        ASSERT(fResult ? WeOwnExclusive() : TRUE);
        return fResult;
        }

    void ReleaseLock()
        {
        ASSERT(WeOwnExclusive());
        ASSERT(5 == m_five);
        DEBUG(m_threadId = NULL);
        ExReleaseFastMutex(&m_lock);
        ASSERT(!WeOwnExclusive());
        }

    #ifdef _DEBUG
    BOOL WeOwnExclusive()
        {
        ASSERT(this);
        return m_threadId == GetCurrentThreadId();
        }
    #endif
    
    };

#else

// User mode implementation of leaf locks just uses XLOCK, but checks to ensure
// that we're not acquiring recursively for compatibility with kernel mode.
//
// REVIEW: In future, it would be nice to actually support the fWait feature.
//
struct XLOCK_LEAF : public XLOCK
    {
    BOOL LockExclusive(BOOL fWait = TRUE)
        {
        ASSERT(!WeOwnExclusive());
        return XLOCK::LockExclusive(fWait);
        }    
    };


#endif

//
////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//
// A specialized kind of lock. With this lock, the owning resources aren't threads
// but rather a fixed number of 'buttons'. Specific buttons are locked and released
// explicitly.
//
////////////////////////////////////////////////////////////////////////////////

template <class XLOCK_T, int CBUTTON>
struct RADIO_LOCK : NonPaged
    {
    enum {NOBUTTON = -1};

    //////////////////////////////
    //
    struct BUTTON
        {
        BOOL LockExclusive(BOOL fWait = TRUE)
        //
        // 'Push' this radio button, which we can't do until all the other buttons are 'unpushed'.
        //
            {
            BOOL fResult = TRUE;
            BOOL fContinueLooping = TRUE;
            BOOL fHaveLock = FALSE;

            while (fContinueLooping)
                {
                if (!fHaveLock)
                    {
                    m_pGroup->m_lock.LockExclusive();
                    fHaveLock = TRUE;
                    }

                if (m_pGroup->m_iButtonCur == m_iButton)
                    {
                    // Thus button is already pushed!
                    //
                    m_pGroup->m_cButtonCur++;
                    fContinueLooping = FALSE;
                    }
                else if (m_pGroup->m_iButtonCur == NOBUTTON)
                    {
                    // No button is pushed. Push this one for the first time.
                    //
                    m_pGroup->m_iButtonCur = m_iButton;   
                    m_pGroup->m_cButtonCur = 1;
                    fContinueLooping = FALSE;
                    }
                else if (fWait)
                    {
                    // Someone else has the lock. Wait until someone lets us go
                    //
                    m_pGroup->m_lock.ReleaseLock();
                    fHaveLock = FALSE;

                    InterlockedIncrement(&this->m_cWaiting);          // corresponding decrement done in ReleaseLock();
                    InterlockedIncrement(&m_pGroup->m_cWaiting);
                    m_semaphore.Wait();
                    }
                else
                    {
                    // Someone else has the lock, but we're not allowed to wait
                    //
                    fResult = FALSE;
                    fContinueLooping = FALSE;
                    }
                }

            if (fHaveLock) m_pGroup->m_lock.ReleaseLock();
            return fResult;
            }

        void ReleaseLock()
        //
        // 'Unpush' this radio button
        //
            {
            m_pGroup->m_lock.LockExclusive();
            BOOL fHaveLock = TRUE;
            
            ASSERT(m_pGroup->m_cButtonCur > 0);
            ASSERT(m_pGroup->m_iButtonCur == m_iButton);

            m_pGroup->m_cButtonCur--;
            if (0 == m_pGroup->m_cButtonCur)
                {
                m_pGroup->m_iButtonCur = NOBUTTON;
                //
                // Find one other button that's got someone waiting, and let him get pushed.
                // We round-robin from the current button.
                //
                for (LONG i = 1; i <= CBUTTON; i++)
                    {
                    LONG iButton = (m_iButton + i >= CBUTTON) ? (m_iButton + i - CBUTTON) : (m_iButton + i);
                    
                    BUTTON& button = m_pGroup->m_buttons[iButton];
                    LONG cWaiting = button.m_cWaiting;

                    if (cWaiting > 0)
                        {
                        // Claim this many releases as those for us to do
                        //
                        InterlockedExchangeAdd(&button.m_cWaiting, -cWaiting);
                        InterlockedExchangeAdd(&m_pGroup->m_cWaiting, -cWaiting);
                        //
                        // Release the lock before releasing waiters in order to (possibly) avoid spurious 
                        // context switches. (May not be real if in fact we're using a spin-lock).
                        //
                        m_pGroup->m_lock.ReleaseLock();
                        fHaveLock = FALSE;
                        //
                        // Finally, let the waiters go
                        //
                        button.m_semaphore.Release(cWaiting);
                        break;
                        }
                    }
                }

            if (fHaveLock) m_pGroup->m_lock.ReleaseLock();
            }

        void Initialize(LONG iButton, RADIO_LOCK* pGroup)
            {
            m_iButton = iButton;
            m_pGroup = pGroup;
            m_semaphore.Initialize();
            m_cWaiting = 0;
            }

    private:
        LONG        m_iButton;
        RADIO_LOCK* m_pGroup;
        SEMAPHORE   m_semaphore;
        LONG        m_cWaiting;     // number of threads waiting on this button
        };
    //
    //////////////////////////////

    BUTTON& Button(int iButton)     { return m_buttons[iButton]; }
    RADIO_LOCK()                    { Initialize(); }
    ~RADIO_LOCK()                   { /* nothing to do */ }
    
    void Initialize()
        {
        for (LONG iButton = 0; iButton < CBUTTON; iButton++)
            {
            m_buttons[iButton].Initialize(iButton, this);
            }

        m_lock.Initialize();
        m_iButtonCur = NOBUTTON;
        m_cWaiting = 0;
        ASSERT(CBUTTON > 1);
        }

    LONG LockCount()
        {
        return m_cButtonCur;
        }

    LONG WaitingCount()
        {
        return m_cWaiting;
        }

private:
    friend struct BUTTON;

    BUTTON  m_buttons[CBUTTON];
    XLOCK_T m_lock;
    LONG    m_iButtonCur;
    LONG    m_cButtonCur;
    LONG    m_cWaiting;
    };


////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK_INDIRECT - Used for indirecting lock calls so as to separate paged memory from
//                  non-paged memory requirements.
//
////////////////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE

    template <class TARGET_LOCK>
    class XLOCK_INDIRECT : Paged
        {
        //////////////////////////////////////////////////////
        //
        // State
        //
        //////////////////////////////////////////////////////
    protected:
        TARGET_LOCK* m_ptarget;

        //////////////////////////////////////////////////////
        //
        // Construction
        //
        //////////////////////////////////////////////////////
    public:
        XLOCK_INDIRECT()
            {
            m_ptarget = new TARGET_LOCK;
            }
        ~XLOCK_INDIRECT()
            {
            delete m_ptarget;
            }

        HRESULT IsConstructed()
            {
            return m_ptarget ? m_ptarget->IsConstructed() : E_OUTOFMEMORY;
            }

        //////////////////////////////////////////////////////
        //
        // Operations
        //
        //////////////////////////////////////////////////////

        BOOL LockExclusive(BOOL fWait=TRUE)
            {
            return m_ptarget->LockExclusive(fWait);
            }


        void ReleaseLock()
            {
            m_ptarget->ReleaseLock();
            }

    #ifdef _DEBUG
        BOOL WeOwnExclusive()   
            { 
            ASSERT(this); ASSERT(m_ptarget);
            return m_ptarget->WeOwnExclusive();
            }
    #endif
        };

    ////////////////////////////////////////

    template <class TARGET_LOCK>
    class XSLOCK_INDIRECT : public XLOCK_INDIRECT<TARGET_LOCK>
        {
        //////////////////////////////////////////////////////
        //
        // Operations
        //
        //////////////////////////////////////////////////////
    public:
        BOOL LockShared(BOOL fWait=TRUE)
            {
            return m_ptarget->LockShared(fWait);
            }

    #ifdef _DEBUG
        BOOL WeOwnShared()   
            { 
            return m_ptarget->WeOwnShared();
            }
    #endif
        };

#else // else user mdoe

    template <class TARGET_LOCK>
    class XLOCK_INDIRECT : public TARGET_LOCK
        {
        public:
        };


    template <class TARGET_LOCK>
    class XSLOCK_INDIRECT : public TARGET_LOCK
        {
        public:
        };

#endif




#endif // #ifndef __CONCURRENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\idispatchinfo.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// IDispatchInfo.h
//
// Information about the IDispatch interface
//
// REVIEW: These stack layouts are NOT correct for 64 bit!

enum {
    IMETHOD_FIRST = 3,
    IMETHOD_GetTypeInfoCount = IMETHOD_FIRST,
    IMETHOD_GetTypeInfo,
    IMETHOD_GetIDsOfNames,
    IMETHOD_Invoke,
    IMETHOD_DISPATCH_MAX,

    IPARAM_Invoke_DispId     = 0,
    IPARAM_Invoke_Iid        = 1,
    IPARAM_Invoke_Lcid       = 2,
    IPARAM_Invoke_WFlags     = 3,
    IPARAM_Invoke_DispParams = 4,
    IPARAM_Invoke_PVarResult = 5,
    IPARAM_Invoke_PExcepInfo = 6,
    IPARAM_Invoke_PUArgErr   = 7,
    }; 


#if defined(_M_ALPHA) || defined(IA64)
    #define PAD4(n)     char __pad ## n [4];
#else
    #define PAD4(n)     
#endif

#if !defined(_WIN64)
   #define PPAD4(n)     PAD4(n) 
#else
   #define PPAD4(n)
#endif

#ifndef _WIN64
#pragma pack(push, 4)   // mimic what MIDL does
#else
#pragma pack(push, 8)
#endif


//
////////////////////////////////////////////////////////////////////
//
// IDispatch

struct FRAME_GetTypeInfoCount 
    {
    IDispatch*  This;           PPAD4(0);
    UINT*       pctinfo;
    };

struct FRAME_GetTypeInfo
    {
    IDispatch*      This;       PPAD4(0);
    UINT            iTInfo;     PAD4(1);
    LCID            lcid;       PAD4(2);
    ITypeInfo**     ppTInfo;    PPAD4(3);
    };

struct FRAME_GetIDsOfNames
    {
    IDispatch*      This;       PPAD4(0);
    REFIID          riid;       PPAD4(1);
    LPOLESTR*       rgszNames;  PPAD4(2);
    UINT            cNames;     PAD4(3);
    LCID            lcid;       PAD4(4);
    DISPID*         rgDispId;   PPAD4(5);
    };

struct FRAME_RemoteInvoke;

struct FRAME_Invoke
    {
    IDispatch*      This;           PPAD4(0);
    DISPID          dispIdMember;   PAD4(1);
    IID*            piid;           PPAD4(2);
    LCID            lcid;           PAD4(3);
    WORD            wFlags;         PAD4(4);
    DISPPARAMS*     pDispParams;    PPAD4(5);
    VARIANT*        pVarResult;     PPAD4(6);
    EXCEPINFO*      pExcepInfo;     PPAD4(7);
    UINT*           puArgErr;       PPAD4(8);
    
    void CopyTo(FRAME_RemoteInvoke&) const;
    void CopyFrom(const FRAME_RemoteInvoke&);
    };

struct FRAME_RemoteInvoke
    {
    IDispatch*      This;           PPAD4(0);
    DISPID          dispIdMember;   PAD4(1);
    IID*            piid;           PPAD4(2);
    LCID            lcid;           PAD4(3);
    DWORD           dwFlags;        PAD4(4);        // ****
    DISPPARAMS*     pDispParams;    PPAD4(5);
    VARIANT*        pVarResult;     PPAD4(6);
    EXCEPINFO*      pExcepInfo;     PPAD4(7);
    UINT*           puArgErr;       PPAD4(8);
    UINT            cVarRef;        PAD4(9);        // ****
    UINT*           rgVarRefIdx;    PPAD4(10);       // ****
    VARIANTARG*     rgVarRef;       PPAD4(11);       // ****

    void CopyTo(FRAME_Invoke&) const;
    void CopyFrom(const FRAME_Invoke&);
    };

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\fixedpoint.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// FixedPoint.h
//
// A fixeded point arithmeticic library.
//
// Why bother with this? Because we can't do floating point in kernel mode, yet
// we need to carry out some amount of non-integral arithmetic operations.
//
#ifndef __FIXEDPOINT_H__
#define __FIXEDPOINT_H__

///////////////////////////////////////////////////////////////////////////////////
//
// A FIXEDPOINT number representation with 32 bits of integer representation
// and 32 bits of fractional representation.
//
///////////////////////////////////////////////////////////////////////////////////

#pragma pack(push, 1)

struct FIXEDPOINT
    {
    ///////////////////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////////////////

    enum {
        cbitFixed = 64,
        cbitFrac  = 32,
        cbitInt   = cbitFixed - cbitFrac,
        };

    union
        {
        struct
            {
            ULONG           low;
            ULONG           high;
            };
        LONGLONG   ll; 
        };

    __declspec( property( get=GetFraction, put=PutFraction ) ) unsigned int fraction;
    __declspec( property( get=GetInteger,  put=PutInteger  ) ) unsigned int integer;

    unsigned int GetFraction() const            { return low; }
    void         PutFraction(unsigned int f)    { low = f;    }
    unsigned int GetInteger() const             { return high; }
    void         PutInteger(unsigned int i)     { high = i;    }


    ///////////////////////////////////////////////////////////////////////////////
    //
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////

    FIXEDPOINT()                                { }
    FIXEDPOINT(ULONG u)                         { integer = u; fraction = 0; }
    FIXEDPOINT(LONG  l)                         { integer = l; fraction = 0; }
    FIXEDPOINT(int   i)                         { integer = i; fraction = 0; }
    FIXEDPOINT(unsigned int i)                  { integer = i; fraction = 0; }

    FIXEDPOINT(const FIXEDPOINT& f)             { ll  = f.ll;  }

    FIXEDPOINT(ULONG i, ULONG f)                { integer = i; fraction = f; }

    #ifndef KERNELMODE

    FIXEDPOINT(double d)
        {
        if (d >= 0)
            {
            integer  = LONG(floor(d));
            fraction = LONG(ScaleFraction() * (d - double(integer)));
            }
        else
            {
            d = -d;
            integer  = LONG(floor(d));
            fraction = LONG(ScaleFraction() * (d - double(integer)));
            *this = - *this;
            }
        }

    #endif
  
        
    ///////////////////////////////////////////////////////////////////////////////
    //
    // Conversion operators
    //
    ///////////////////////////////////////////////////////////////////////////////

    operator ULONG() const  { return integer; }
    operator LONG()  const  { return integer; }
    operator int()   const  { return integer; }

    #ifndef KERNELMODE

    operator double() const 
        { 
        if (IsPositive())
            return (double)integer + (double)fraction / ScaleFraction(); 
        else
            return -double(- *this);
        }

    #endif


    ///////////////////////////////////////////////////////////////////////////////
    //
    // Arithmetic
    //
    ///////////////////////////////////////////////////////////////////////////////

    FIXEDPOINT  operator+ (const FIXEDPOINT& f) const { FIXEDPOINT r(*this);   r += f;     return r;     }
    FIXEDPOINT& operator+=(const FIXEDPOINT& f)       {                       ll += f.ll;  return *this; }
    FIXEDPOINT  operator- (const FIXEDPOINT& f) const { FIXEDPOINT r(*this);   r -= f;     return r;     }
    FIXEDPOINT& operator-=(const FIXEDPOINT& f)       {                       ll -= f.ll;  return *this; }
    FIXEDPOINT  operator* (const FIXEDPOINT& f) const { FIXEDPOINT r(*this);   r *= f;     return r;     }
    FIXEDPOINT& operator*=(const FIXEDPOINT& f);
    FIXEDPOINT  operator/ (const FIXEDPOINT& f) const { FIXEDPOINT r(*this);   r /= f;     return r;     }
    FIXEDPOINT operator/=(const FIXEDPOINT& f);

    FIXEDPOINT  operator- ()                    const { FIXEDPOINT r = *this; r.ll = -r.ll;  return r;  }

    ///////////////////////////////////////////////////////////////////////////////
    //
    // Other operators
    //
    ///////////////////////////////////////////////////////////////////////////////

    FIXEDPOINT  operator<<(ULONG cbit)          const   { FIXEDPOINT r(*this); r <<= cbit; return r; }
    FIXEDPOINT  operator>>(ULONG cbit)          const   { FIXEDPOINT r(*this); r >>= cbit; return r; }

    BOOL        operator==(const FIXEDPOINT& f) const   { return ll == f.ll; }
    BOOL        operator==(LONG  i)             const   { return fraction == 0 && integer == (unsigned int) i; }
    BOOL        operator==(ULONG i)             const   { return fraction == 0 && integer == i; }
    BOOL        operator==(int   i)             const   { return fraction == 0 && integer == (unsigned int) i; }

    BOOL        operator!=(const FIXEDPOINT& f) const   { return ! (*this==f); }
    BOOL        operator!=(LONG  i)             const   { return ! (*this==i); }
    BOOL        operator!=(ULONG i)             const   { return ! (*this==i); }
    BOOL        operator!=(int   i)             const   { return ! (*this==i); }
    
    FIXEDPOINT& operator<<=(ULONG cbit)                 { ll <<= cbit; return *this; }
    FIXEDPOINT& operator>>=(ULONG cbit)                 { ll >>= cbit; return *this; }

    BOOL        operator> (const FIXEDPOINT& f) const   { return ll > f.ll;             }
    BOOL        operator> (int    i)            const   { return *this > FIXEDPOINT(i); }
    BOOL        operator> (LONG   i)            const   { return *this > FIXEDPOINT(i); }
    BOOL        operator> (ULONG  i)            const   { return *this > FIXEDPOINT(i); }

    BOOL        operator< (const FIXEDPOINT& f) const   { return ll < f.ll;             }
    BOOL        operator< (int    i)            const   { return *this < FIXEDPOINT(i); }
    BOOL        operator< (LONG   i)            const   { return *this < FIXEDPOINT(i); }
    BOOL        operator< (ULONG  i)            const   { return *this < FIXEDPOINT(i); }

    BOOL        operator>=(const FIXEDPOINT& f) const   { return ll >= f.ll;             }
    BOOL        operator>=(int    i)            const   { return *this >= FIXEDPOINT(i); }
    BOOL        operator>=(LONG   i)            const   { return *this >= FIXEDPOINT(i); }
    BOOL        operator>=(ULONG  i)            const   { return *this >= FIXEDPOINT(i); }

    BOOL        operator<=(const FIXEDPOINT& f) const   { return ll <= f.ll;             }
    BOOL        operator<=(int    i)            const   { return *this <= FIXEDPOINT(i); }
    BOOL        operator<=(LONG   i)            const   { return *this <= FIXEDPOINT(i); }
    BOOL        operator<=(ULONG  i)            const   { return *this <= FIXEDPOINT(i); }

    ///////////////////////////////////////////////////////////////////////////////
    //
    // Misc
    //
    ///////////////////////////////////////////////////////////////////////////////

    ULONG Bit(ULONG i) const          // return zero / non-zero for the ith bit, 0 <= i < 64
        {
        if (i >= 32)
            return (high & ((ULONG)1 << (i-32)));
        else
            return (low  & ((ULONG)1 << i));
        }

    BOOL IsNegative() const
        {
        return Bit(cbitFixed-1);
        }

    BOOL IsPositive() const
        {
        return !IsNegative();     
        }

    ///////////////////////////////////////////////////////////////////////////////
    //
    // Private
    //
    ///////////////////////////////////////////////////////////////////////////////
private:

    #ifndef KERNELMODE

    double ScaleFraction() const
        {
        double s = 1.0;
        for (int i = 0; i<cbitFrac; i++)
            {
            s *= 2.0;
            }
        return s;
        }

    #endif
    };

#pragma pack(pop)



///////////////////////////////////////////////////////////////////////////////////
//
// Support functions
//
///////////////////////////////////////////////////////////////////////////////////


FIXEDPOINT Exp(const FIXEDPOINT& f);
FIXEDPOINT Log(const FIXEDPOINT& f);


inline FIXEDPOINT Floor(const FIXEDPOINT& f)
// Truncate towards -infinity
    {
    if (f.IsPositive() || f.fraction == 0)
        return FIXEDPOINT(f.integer);
    else
        return FIXEDPOINT(f.integer - 1);
    }

inline ULONG Round(const FIXEDPOINT& f)
// Round f to the nearest integer
    {
    FIXEDPOINT ONEHALF(0,2147483648UL);  // double ONEHALF = 5.0000000000000000000e-001;
    return Floor(f + ONEHALF);
    }

inline BOOL SameSign(const FIXEDPOINT& f1, const FIXEDPOINT& f2)
// Answer nz/z as to whether these two have the same sign
    {
    return !(f1.Bit(FIXEDPOINT::cbitFixed-1) ^ f2.Bit(FIXEDPOINT::cbitFixed-1));
    }

inline FIXEDPOINT Abs(const FIXEDPOINT& f)
// Return the absolute value of f
    {
    if (f.IsNegative())
        return -f;
    else
        return f;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\kompobj.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// kompobj.h
//
// Main include file for Kernel mode COM APIs
//
// REVIEW: This is in need of a cleanup. KomObj.h is probably a dead header file.
// This stuff here should be integrated into kom.h / komaux.h.
//

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////////////////
// 
// Type definitions, etc
//
////////////////////////////////////////////////////////////////////////////////////

__inline NTSTATUS NtHr(HRESULT hr)      
    { 
    if (SUCCEEDED(hr))
        return STATUS_SUCCESS;
    else
        return (hr & FACILITY_NT_BIT) ? (NTSTATUS)(hr & ~FACILITY_NT_BIT) : STATUS_UNSUCCESSFUL;
    }

//
// A convenient type for passing UNICODE_STRINGs as in parmeters
//
#ifdef __cplusplus
typedef UNICODE_STRING& REFUSTR;
#else
typedef UNICODE_STRING* REFUSTR;
#endif 

////////////////////////////////////////////////////////////////////////////////////
// 
// Kernel-mode COM APIs
//
////////////////////////////////////////////////////////////////////////////////////

EXTERN_C HRESULT __stdcall KoInitialize();
EXTERN_C HRESULT __stdcall KoUninitialize();

////////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\interlockedqueue.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// queue.h
//
#ifndef __QUEUE__H__
#define __QUEUE__H__

/////////////////////////////////////////////////////////////
//
// A simple queue class
//
/////////////////////////////////////////////////////////////

#ifdef KERNELMODE
    
    // not yet written. but could probably just wrap the existing kernel mode queues

#else


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\imalloc.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// IMalloc.h
//

#pragma once

// IMalloc is defined in objidl.h. Define it here if we haven't already seen it.
// 
#ifndef __objidl_h__

    struct __declspec(uuid("00000002-0000-0000-C000-000000000046")) __declspec(novtable)
    IMalloc : public IUnknown
        {
    public:
        virtual void* __stdcall Alloc(ULONG cb) = 0;
        virtual void* __stdcall Realloc(void* pv, ULONG cb) = 0;
        virtual void  __stdcall Free(void* pv) = 0;
        virtual ULONG __stdcall GetSize(void* pv) = 0;
        virtual int   __stdcall DidAlloc(void* pv) = 0;
        virtual void  __stdcall HeapMinimize() = 0;
        };


#endif

#define IID_IMalloc     __uuidof(IMalloc)
#define IID_IUnknown    __uuidof(IUnknown)


// Return a memory allocator for the indicated pool type. Works in both
// user and kernel mode, though in user mode, only PagedPool works, and
// when used, the standard OLE allocator is returned.
//
extern "C" IMalloc* GetStandardMalloc(POOL_TYPE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\linkable.h ===
/* -----------------------------------------------------------------------
   Microsoft Application Server (Microsoft Confidential)
   Copyright 1997 Microsoft Corporation.  All Rights Reserved.

   @rev 0 | 3/23/97 | jimbo | Sherpa-M3
   ----------------------------------------------------------------------- */

#ifndef _LINKABLE_H_
#define _LINKABLE_H_

#include <windows.h>

//
// Class -- CLinkable
//		Base class for objects that can be placed onto cheap circular doubly-linked lists.
//
class CLinkable
{
public:

	// Constructor
	CLinkable() { m_pNext = m_pPrev = this; }

	// Destructor
	~CLinkable() { Remove(); }

	// return TRUE iff on a list
	BOOL			IsLinked() { return ( m_pNext != this ); }

	// return next element on list
	CLinkable*		Next() { return m_pNext; }

	// return previous element on list
	CLinkable*		Previous() { return m_pPrev; }

	// insert parameter onto list after this, removing it first if necessary
	void			InsertAfter( CLinkable* other );

	// insert parameter onto list before this, removing it first if necessary
	void			InsertBefore( CLinkable* other );

	// remove us from list, if any
	void			Remove();

private:
	CLinkable*		m_pNext;		// next element on list
	CLinkable*		m_pPrev;		// previous element on list
};


//
// Class - CListHeader
//		List header for list of CLinkable's. This is merely a CLinkable with
//		some methods renamed for better readability.
//
class CListHeader : public CLinkable
{

public:

	// Constructor
	CListHeader() {}

	// Destructor
	~CListHeader() {};

	// return TRUE iff list is empty
	BOOL			IsEmpty()	{ return !IsLinked(); }

	// return first element on list
	CLinkable*		First()		{ return Next(); }

	// return last element on list
	CLinkable*		Last()		{ return Previous(); }

	// insert parameter at head of list
	void			InsertFirst ( CLinkable* other )	{ InsertAfter( other ); }

	// insert parameter at tail of list
	void			InsertLast ( CLinkable* other )		{ InsertBefore( other ); }
};

#endif _LINKABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\itypeinfostackhelper.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Copied from Src/Runtime/Inc/ITypeInfoStackHelper.h
//
// It's a (frozen) interface, so shouldn't matter.
//

/* ----------------------------------------------------------------------------
@interface

 A call back interface used in walking various things in the stack 
---------------------------------------------------------------------------- */

DEFINE_GUID (IID_IStackFrameWalker,
			 0xac2a6f41,
			 0x7d06,
			 0x11cf,
			 0xb1, 0xed, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6);

#undef  INTERFACE
#define INTERFACE   IStackFrameWalker

DECLARE_INTERFACE_(IStackFrameWalker, IUnknown)
    {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(OnWalkInterface)(THIS_
        REFIID  iid,        // the id of the interface actually pointed to by pv
        LPVOID* ppv         // pointer to where the interface pointer lives (ie: usually an IUnknown**)
        ) PURE;
    };

#define IStackFrameWalker_OnWalkInterface(This,iid,pv) \
    (This)->lpVtbl->OnWalkInterface(This,iid,pv)
 

/* ----------------------------------------------------------------------------
@interface 

 An interface that can tell you certain kinds of information about an activation
 record on the stack.

 Being a stack walker, the methods in this interface are intrinsically tied to  
 the particular machine architecture on which they are invoked. The same  
 invocation on different architectures may produce different results.

 Also, dealing as they do with stack frames, these methods are flat out not
 remoteable.

 Instances of this interface are assumed to be initialized (by means not 
 specified here) to be scoped to a context identified by a particular GUID. 
 Typically, this is an interface id, but could also be a module id. This id 
 can be retrieved with GetGuid().
---------------------------------------------------------------------------- */

DEFINE_GUID(IID_ITypeInfoStackHelper,
			0x7ee46340,
			0x81ad,
			0x11cf,
			0xb1, 0xf0, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6);


#undef  INTERFACE
#define INTERFACE   ITypeInfoStackHelper

DECLARE_INTERFACE_(ITypeInfoStackHelper, IUnknown)
    {
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //
    // Retrieve the name of the interface / module on which this stack helper lives
    //
    STDMETHOD(GetGuid)(THIS_
        GUID*                   // the place to return the id
        ) PURE;

    //
    // Retrieve the number of methods in this interface / module
    //
    STDMETHOD(GetMethodCount)(THIS_
        ULONG*                  // the place to return the method count
        ) PURE;

    //
    // Answer the size of a particular activation record. It is only valid
    // to call this BEFORE the call that uses the activation record is
    // actually made.
    //
    STDMETHOD(GetStackSize)(THIS_
        ULONG  iMethod,         // method index
        BOOL   fIncludeReturn,  // whether to include the return value in the size or not
        ULONG* pcbStack         // [out] the size needed for the stack frame
        ) PURE;

    //
    // Walk all the interface pointers in a given activation record
    //
    STDMETHOD(WalkInterfacePointers)(THIS_
        ULONG   iMethod,        // the method / function index (zero based)
        LPVOID  pStack,         // pointer to the stack frame
        BOOL    fBeforeCall,    // true if before the call; false if after
        IStackFrameWalker*      // the callback to call
        ) PURE;

    //
    // Null all the out params. Before call if true implies that only need to
	// set the out params to null. If FALSE implies that any out params in the
	// call stack also need to be released
    //
    STDMETHOD(NullOutParams)(THIS_
        ULONG   iMethod,        // the method / function index (zero based)
        LPVOID  pStack,         // pointer to the stack frame
        BOOL    fBeforeCall     // true if before the call; false if after
        ) PURE;


    // Return TRUE if a given method has an out parameter
    STDMETHOD(HasOutParams)(THIS_
        ULONG   iMethod,        // the method / function index (zero based)
		LPBOOL	pfHasOutParams
        ) PURE;

    // Return TRUE if a given method has an out interface pointer
    STDMETHOD(HasOutInterfaces)(THIS_
        ULONG   iMethod,        // the method / function index (zero based)
		LPBOOL	pfHasOutInterfaces
        ) PURE;

    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\interlockedstack.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// InterlockedStack.h
//
// Implements a stack of T's, where T is an arbitrary type. 

#ifndef __INTERLOCKED_STACK_H__
#define __INTERLOCKED_STACK_H__

#include "TxfUtil.h"        // for CanUseCompareExchange64
#include "Concurrent.h"

////////////////////////////////////////////////////////////////////////////////////////
//
// Forward declarations
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T> struct InterlockedStack;
template <class T> struct LockingStack;


////////////////////////////////////////////////////////////////////////////////////////
//
// Type-friendly interlocked swapping
//
////////////////////////////////////////////////////////////////////////////////////////

#ifndef _WIN64
template <class T> InterlockedStack<T> 
TxfInterlockedCompareExchange64(volatile InterlockedStack<T>* pDestination, const InterlockedStack<T>& exchange, const InterlockedStack<T>& comperand)
{
	return (InterlockedStack<T>)TxfInterlockedCompareExchange64((volatile LONGLONG*)pDestination, (LONGLONG)exchange, (LONGLONG)comperand);
}
#else
template <class T> InterlockedStack<T> 
TxfInterlockedCompareExchange64(InterlockedStack<T>* pDestination, const InterlockedStack<T>& exchange, const InterlockedStack<T>& comperand)
{
	return (InterlockedStack<T>)TxfInterlockedCompareExchange64((LONGLONG*)pDestination, (LONGLONG)exchange, (LONGLONG)comperand);
}
#endif


////////////////////////////////////////////////////////////////////////////////////////
//
// IFastStack: Generic interface to the fast stack functionality. Allows for either
//             InterlockedStack or non-interlocked versions to be used transparently
//             by clients.
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct IFastStack
{
    virtual ~IFastStack() {};
    virtual void Push(T* pt) = 0;
    virtual T*   Pop()       = 0;    
};


////////////////////////////////////////////////////////////////////////////////////////
//
// InterlockedStack
//
////////////////////////////////////////////////////////////////////////////////////////


template <class T>
struct InterlockedStack
// A class that supports the interlocked pushing and popping of singly-linked list.
// The parameterized type here, T, must have a pNext field which is the list linkage.
//
{

    union { // Force this structure as a whole to have eight byte alignment
        struct
        {
            T*      m_p;        // the client data of interest that we point to
            ULONG   m_n;        // the operation number used to interlock the push and pop action 
        };
        LONGLONG dummy;
    };

    void Init() 
    {
#ifdef _M_ALPHA
#ifndef _WIN64 // it's not a long
        ASSERT((ULONG)this % 8 == 0);   // We require eight byte alignment, but only on Alpha where CoTaskMemAlloc will guarantee that
#else
        ASSERT((ULONGLONG)this % 8 == 0);   // We require eight byte alignment, but only on Alpha where CoTaskMemAlloc will guarantee that
#endif
#endif
#ifdef IA64
        ASSERT((ULONGLONG)this % 8 == 0);   // We require eight byte alignment on IA64
#endif
        m_p = NULL;                     // We don't care what m_n is, and can so leave it uninitialized
    }
    InterlockedStack()
    {
        Init();
    }
    InterlockedStack(const InterlockedStack& him)
    {
        *this = him;
    }
    InterlockedStack(const LONGLONG& ll)
    {
        *(LONGLONG*)this = ll;
    }

    operator LONGLONG() const
    {
        return *(LONGLONG*)this;
    }

    void Push(T* pt)
        // Push a new T* onto the stack of which you are the top. Type T must have
        // a pNext member of type T* which is to be the list linkage.
    {
        
        InterlockedStack<T> comp, xchg;
        for (;;)
        {
            // Capture what we expect the list top to be
            //
            comp = *this;
            // 
            // Set up what we want the new list top to be
            //
            pt->pNext   = comp.m_p;        // link the list
            xchg.m_p    = pt;              //       ...
            xchg.m_n    = comp.m_n + 1;    // set the operation number expectation
            //
            // Try to atomically push the list
            //
            if (comp == TxfInterlockedCompareExchange64(this, xchg, comp))
            {
                // List top was what we expected it to be, the push happened, and we are done!
                //
                return;
            }
            //
            // Otherwise, continue around the loop until we can successfully push
            //
        }
    }

    T* Pop()
        // Pop the top element from the stack of which you are the list head
    {
        
        InterlockedStack<T> comp, xchg;
        for (;;)
        {
            // Capture what we expect the list top to be
            //
            comp = *this;

            if (NULL == comp.m_p)
            {
                // The stack is empty, nothing to return
                //
                return NULL;
            }
            else
            {
                // Set up what we expect the new list top to be
                //
                xchg.m_p = comp.m_p->pNext;     // unlink the list
                xchg.m_n = comp.m_n + 1;        // set the operation number expectation
                //
                // Try to pop the list
                //
                if (comp == TxfInterlockedCompareExchange64(this, xchg, comp))
                {
                    // List top was what we expected it to be. We popped!
                    //
                    comp.m_p->pNext = NULL;     // NULL it for safety's sake
                    return comp.m_p;
                }
                //
                // Otherwise, go around and try again
                //
            }
        }        
    }


};

template <class T>
struct InterlockedStackIndirect : IFastStack<T>
{
    // The ALPHA requires that stack be eight-byte aligned
    // in order that we can use InterlockedCompareExchange64 on it
    //
    InterlockedStack<T> stack;
    void Push(T* pt)    { stack.Push(pt); }
    T*   Pop()          { return stack.Pop(); }
};


////////////////////////////////////////////////////////////////////////////////////////
//
// LockingStack
//
// A stack that must use locks to get what it needs. Used in the absence of 
// interlocked compare exchange support. We only really need this on X86, as the other
// platforms all have the necessary interlocked support.
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct LockingStack : IFastStack<T>
{
    T*      m_p;
    XLOCK   m_lock;

    LockingStack()
    {
        m_p = NULL;
    }

    BOOL FInit()
    {
        return m_lock.FInit();
    }

    void Push(T* pt)
    {
        m_lock.LockExclusive();
        pt->pNext = m_p;        // link the list
        m_p       = pt;         //    ...
        m_lock.ReleaseLock();
    }

    T* Pop()
    {
        T* ptReturn;
        
        m_lock.LockExclusive();
        ptReturn = m_p;

        if (NULL != m_p)
        {
            m_p = m_p->pNext;   // unlink the list
            ptReturn->pNext = NULL; // for safety's sake
        }

        m_lock.ReleaseLock();

        return ptReturn;
    }
};


////////////////////////////////////////////////////////////////////////////////////////
//
// CreateFastStack
//
// Create a fast stack, using the hardware support if possible.
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T>
HRESULT CreateFastStack(IFastStack<T>** ppStack)
{
    HRESULT hr = S_OK;

    ASSERT(ppStack);

    // BUGBUG: Until we repair the LL/SC data structures for Win64,
    // we can't use the InterlockedStack
#ifndef _WIN64
    if (CanUseCompareExchange64())
    {
        *ppStack = new InterlockedStackIndirect<T>;
    }
    else
 #endif // _WIN64
    {
        *ppStack = new LockingStack<T>;
        if (*ppStack != NULL)
        {
        	if (((LockingStack<T>*)*ppStack)->FInit() == FALSE)
        	{
        		delete *ppStack;
        		*ppStack = NULL;
        	}
        }	
    }

    if (NULL == *ppStack)
        hr = E_OUTOFMEMORY;

    return hr;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\iunkinner.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// IUnkInner.h
//

interface IUnkInner
	{
	virtual HRESULT __stdcall InnerQueryInterface(REFIID iid, LPVOID* ppv) = 0;
 	virtual ULONG   __stdcall InnerAddRef() = 0;
 	virtual ULONG   __stdcall InnerRelease() = 0;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\lookaside.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// lookaside.h
//
// (A curious historically-based name for this header. A more apt name might be something
// like hashtable.h or something.)
//
// Contains a hash table implemention with several interesting features:
//
//  1) is template based in the key and value types, providing strong typing
//  2) supports both paged and non-paged variations
//  3) associates a lock with the table for ease and convenience
//

#ifndef __LOOKASIDE_H__
#define __LOOKASIDE_H__

#include "concurrent.h"
#include "txfdebug.h"               
#include "map_t.h"
#include "CLinkable.h"

///////////////////////////////////////////////////////////////////////////////////
//
// A memory allocator for use with the hash table in map_t.h. Said table assumes
// that memory allocation always succeeds; here, we turn failures into a throw
// that we'll catch in our MAP wrapper's routines.
//
///////////////////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif

template <POOL_TYPE poolType>
struct FromPoolThrow
    {
    #ifdef _DEBUG
        void* __stdcall operator new(size_t cb)                     
            { 
            PVOID pv = AllocateMemory_(cb, poolType, _ReturnAddress()); 
            ThrowIfNull(pv);
            return pv;
            }
        void* __stdcall operator new(size_t cb, POOL_TYPE ignored) 
            { 
            PVOID pv = AllocateMemory_(cb,  poolType, _ReturnAddress()); 
            ThrowIfNull(pv);
            return pv;
            }
        void* __stdcall operator new(size_t cb, POOL_TYPE ignored, PVOID pvReturnAddress) 
            { 
            PVOID pv = AllocateMemory_(cb, poolType, pvReturnAddress); 
            ThrowIfNull(pv);
            return pv;
            }
    #else
        void* __stdcall operator new(size_t cb)
            {
            PVOID pv = AllocateMemory(cb, poolType);
            ThrowIfNull(pv);
            return pv;
            }
        void* __stdcall operator new(size_t cb, POOL_TYPE ignored)
            {
            PVOID pv = AllocateMemory(cb, poolType);
            ThrowIfNull(pv);
            return pv;
            }
    #endif

private:

    static void ThrowIfNull(PVOID pv)
        {
        if (NULL == pv)
            {
            ThrowOutOfMemory();
            }
        }
    };

inline int CatchOOM(ULONG exceptionCode)
    {
    return exceptionCode == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
    }


///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for the hashing class that (for historical reasons, mostly) delegates
// the hashing to the object in question.
// 
///////////////////////////////////////////////////////////////////////////////////

template <class D> struct MAP_HASHER
    {
    static HASH Hash(const D& d)
        {
        return d.Hash();
        }
    static BOOL Equals(const D& d1, const D& d2)
        {
        return d1 == d2;
        }
    };

#pragma warning ( disable : 4200 )  // nonstandard extension used : zero-sized array in struct/union



///////////////////////////////////////////////////////////////////////////////////
//
// The hash table itself
//
///////////////////////////////////////////////////////////////////////////////////

template
    <
    class LOCK_T,
    POOL_TYPE poolType,
    class KEY_T,
    class VALUE_T
    >
class MAP : public Paged
    {
    /////////////////////////////////////////////////////////////////////////////
    //
    // Lock management
    //
    /////////////////////////////////////////////////////////////////////////////
protected:

    LOCK_T m_lock;  // normally will be some form of indirect lock because of paging requirements

public:
    BOOL LockExclusive(BOOL fWait=TRUE)   
    	{
    	ASSERT(m_fCsInitialized == TRUE);
    	if (m_fCsInitialized)
    	    return m_lock.LockExclusive(fWait); 
    	else
    		return FALSE;
    	}
    
    void ReleaseLock()
    	{
    	ASSERT(m_fCsInitialized == TRUE);
    	if (m_fCsInitialized)
    	    m_lock.ReleaseLock();
    	}
    #ifdef _DEBUG
        BOOL WeOwnExclusive()
            {
            ASSERT(m_fCsInitialized == TRUE);
            if (m_fCsInitialized)
                return m_lock.WeOwnExclusive();     
            return FALSE;
            }
    #endif

    /////////////////////////////////////////////////////////////////////////////
    //
    // Operations
    //
    /////////////////////////////////////////////////////////////////////////////
public:

    // This function must be called and return TRUE to use any functions in this class.
    virtual BOOL FInit()
    	{
    	if (m_fCsInitialized == FALSE)
    	    m_fCsInitialized = m_lock.FInit();
    	return m_fCsInitialized;
    	}
    
    BOOL IsEmpty() const 
        { 
        return Size() == 0;   
        }
    ULONG Size() const 
        { 
        return m_map.count(); 
        }
    BOOL Lookup(const KEY_T& key, VALUE_T* pvalue) const
        {
        return m_map.map(key, pvalue);
        }
    BOOL IncludesKey(const KEY_T& key) const
        {
        return m_map.contains(key);
        }
    BOOL SetAt(const KEY_T& key, const VALUE_T& value)
        {
        __try 
            {
            m_map.add(key, value);

            #ifdef _DEBUG
                ASSERT(IncludesKey(key));
                //
                VALUE_T val;
                ASSERT(Lookup(key, &val));
                ASSERT(val == value);
            #endif
            }
        __except(CatchOOM(GetExceptionCode()))
            {
            return FALSE;
            }
        return TRUE;
        }
    void RemoveKey(const KEY_T& key)
        {
        m_map.remove(key);
        ASSERT(!IncludesKey(key));
        }
    void RemoveAll()
        {
        m_map.reset();
        }

    /////////////////////////////////////////////////////////////////////////////
    //
    // Construction & copying
    //
    /////////////////////////////////////////////////////////////////////////////

    MAP() : m_fCsInitialized(FALSE)
        {
        }

    MAP(unsigned initialSize) : m_map(initialSize), m_fCsInitialized(FALSE)
        {
        FInit();
        }

    MAP* Copy()
    // Return a second map which is a copy of this one
        {
        MAP* pMapNew = new MAP(this->Size());
        if (pMapNew && pMapNew->FInit() == FALSE)
        	{
           	delete pMapNew;
           	pMapNew = NULL;
           	}
        
        if (pMapNew)
            {
            BOOL fComplete = TRUE;
            iterator itor;
            for (itor = First(); itor != End(); itor++)
                {
                if (pMapNew->SetAt(itor.key, itor.value))
                    {
                    }
                else
                    {
                    fComplete = FALSE;
                    break;
                    }
                }
            if (fComplete) 
            	return pMapNew;
            }
        if (pMapNew)
            delete pMapNew;
        return NULL;
        }

    /////////////////////////////////////////////////////////////////////////////
    //
    // Iteration
    //
    /////////////////////////////////////////////////////////////////////////////
public:
    typedef MAP_HASHER<KEY_T> HASHER;
    //
    //
    //
    class iterator 
    //
    //
        {
    friend class MAP<LOCK_T, poolType, KEY_T, VALUE_T>;

        EnumMap<KEY_T, VALUE_T, HASHER, FromPoolThrow<poolType> >   m_enum;
        BOOL                                                        m_fDone;
        KEY_T*                                                      m_pkey;
        VALUE_T*                                                    m_pvalue;
        Map<KEY_T, VALUE_T, HASHER, FromPoolThrow<poolType> >*      m_pmap;

    public:
        // Nice friendly data-like names for the keys and values being enumerated
        // 
        __declspec(property(get=GetKey))   KEY_T&   key;
        __declspec(property(get=GetValue)) VALUE_T& value;

        void Remove()
        // Remove the current entry, advancing to the subsequent entry in the interation
            {
            ASSERT(!m_fDone);
            m_pmap->remove(key);
            (*this)++;
            }
        
        void operator++(int postfix)
        // Advance the iteration forward
            {
            ASSERT(!m_fDone);
            if (m_enum.next())
                {
                m_enum.get(&m_pkey, &m_pvalue);
                }
            else
                m_fDone = TRUE;
            }

        BOOL operator==(const iterator& itor) const
            { 
            return m_pmap==itor.m_pmap && (m_fDone ? itor.m_fDone : (!itor.m_fDone && m_enum==itor.m_enum)); 
            }
        BOOL operator!=(const iterator& itor) const
            { 
            return ! this->operator==(itor); 
            }

        iterator& operator= (const iterator& itor)
            {
            m_enum   = itor.m_enum;
            m_fDone  = itor.m_fDone;
            m_pkey   = itor.m_pkey;
            m_pvalue = itor.m_pvalue;
            m_pmap   = itor.m_pmap;
            return *this;
            }

        KEY_T&   GetKey()   { return *m_pkey; }
        VALUE_T& GetValue() { return *m_pvalue; }

        iterator() 
            { 
            /* leave it uninitialized; initialize in First() or End() */ 
            }

        iterator(Map<KEY_T, VALUE_T, HASHER, FromPoolThrow<poolType> >& map)
                : m_enum(map)
            {
            m_pmap = &map;
            }

        };

    iterator First()
        {
        iterator itor(this->m_map);
        itor.m_fDone = FALSE;
        itor++;
        return itor;
        }

    iterator End()
        {
        iterator itor(this->m_map);
        itor.m_fDone = TRUE;
        return itor;
        }


protected:
    Map<KEY_T, VALUE_T, HASHER, FromPoolThrow<poolType> > m_map;
    BOOL m_fCsInitialized;
    };


///////////////////////////////////////////////////////////////////////////////////

//
// NOTE: The constructor of this object, and thus the constructor of objects derived 
//       from this, can throw an exception, beause it contains an XSLOCK (which contains
//       an XLOCK, which contains a critical section).
//
template
    <
    POOL_TYPE poolType,
    class KEY_T,
    class VALUE_T
    >
struct MAP_SHARED : MAP<XSLOCK_INDIRECT<XSLOCK>, poolType, KEY_T, VALUE_T>
    {
    BOOL LockShared(BOOL fWait=TRUE) 
    	{
    	ASSERT(m_fCsInitialized == TRUE); // should not be called if critsec not initialized
    	if (m_fCsInitialized)
    	    return m_lock.LockShared(fWait); 
    	return FALSE;
    	}
    
    #ifdef _DEBUG
    BOOL WeOwnShared()           
        { 
        ASSERT(m_fCsInitialized == TRUE); // should not be called if critsec not initialized
        if (m_fCsInitialized)
            return m_lock.WeOwnShared();     
        return FALSE;
        }
    #endif

    /////////////////////////////////////////////////////////////////////////////
    //
    // Construction & copying
    //
    /////////////////////////////////////////////////////////////////////////////

    MAP_SHARED()
        {
        }

    MAP_SHARED(unsigned initialSize) : MAP<XSLOCK_INDIRECT<XSLOCK>, poolType, KEY_T, VALUE_T>(initialSize)
        {
        }

    MAP_SHARED* Copy()
        {
        return (MAP_SHARED*)(void*) MAP<XSLOCK_INDIRECT<XSLOCK>, poolType, KEY_T, VALUE_T>::Copy();
        }
    };


template
    <
    POOL_TYPE poolType,
    class KEY_T,
    class VALUE_T
    >
struct MAP_EX : MAP<XLOCK_INDIRECT<XLOCK>, poolType, KEY_T, VALUE_T>
    {
    /////////////////////////////////////////////////////////////////////////////
    //
    // Construction & copying
    //
    /////////////////////////////////////////////////////////////////////////////

    MAP_EX()
        {
        }

    MAP_EX(unsigned initialSize) : MAP<XLOCK_INDIRECT<XLOCK>, poolType, KEY_T, VALUE_T>(initialSize)
        {
        }

    MAP_EX* Copy()
        {
        return (MAP_EX*)(void*) MAP<XLOCK_INDIRECT<XLOCK>, poolType, KEY_T, VALUE_T>::Copy();
        }
    };











///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//
// Hashing support
//
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for integers that allows them to work with MAPs
//
///////////////////////////////////////////////////////////////////////////////////

template
    <
    class INT_T
    >
class MAP_KEY_INT
    {
public:
    INT_T     data;

    MAP_KEY_INT()                         {                }
    MAP_KEY_INT(INT_T i)                  { data = i;      }
    MAP_KEY_INT(const MAP_KEY_INT& w)     { data = w.data; }

    operator INT_T()                      { return data; }

    MAP_KEY_INT<INT_T>& operator=(const MAP_KEY_INT<INT_T>& him)  { data = him.data; return *this; }
    MAP_KEY_INT<INT_T>& operator=(INT_T i)                        { data = i;        return *this; }

    ULONG Hash() const
        { 
        return (ULONG)data * 214013L + 2531011L;
        }
    
    BOOL operator==(const MAP_KEY_INT<INT_T>&him) const           { return this->data == him.data;  }
    BOOL operator!=(const MAP_KEY_INT<INT_T>&him) const           { return ! this->operator==(him); }
    };

///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for PVOIDs that allows them to work with MAPs
//
///////////////////////////////////////////////////////////////////////////////////

class MAP_KEY_PVOID
    {
public:
    PVOID   data;

    MAP_KEY_PVOID()                       {                }
    MAP_KEY_PVOID(PVOID i)                { data = i;      }
    MAP_KEY_PVOID(const MAP_KEY_PVOID& w) { data = w.data; }

    operator PVOID()                      { return data; }

    MAP_KEY_PVOID& operator=(const MAP_KEY_PVOID& him)  { data = him.data; return *this; }
    MAP_KEY_PVOID& operator=(PVOID i)                   { data = i;        return *this; }

    ULONG Hash() const
        { 
        return (ULONG)PtrToUlong(data) * 214013L + 2531011L;
        }
    
    BOOL operator==(const MAP_KEY_PVOID&w2) const       { return (*this).data == w2.data; }
    BOOL operator!=(const MAP_KEY_PVOID&w2) const       { return ! this->operator==(w2);  }
    };


typedef MAP_KEY_PVOID MAP_KEY_HANDLE;

///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for zero terminated strings that allows them to work with MAPs.
// We provide both case-sensitive and case-insensitive versions.
//
///////////////////////////////////////////////////////////////////////////////////

struct REF_COUNTED_STRING
    {
    ULONG   refs;
    WCHAR   wsz[];

    void AddRef()  { InterlockedIncrement(&refs); }
    void Release() { if (0==InterlockedDecrement(&refs)) ExFreePool(this); }

    static REF_COUNTED_STRING* From(LPCWSTR w)
        {
        SIZE_T cch = wcslen(w);
        REF_COUNTED_STRING* pstr = (REF_COUNTED_STRING*)AllocatePagedMemory(sizeof(REF_COUNTED_STRING) + (cch+1)*sizeof(WCHAR));
        if (pstr)
            {
            pstr->refs = 1;
            wcscpy(&pstr->wsz[0], w);
            }
        return pstr;
        }

private:
    REF_COUNTED_STRING()  { NOTREACHED(); }
    ~REF_COUNTED_STRING() { NOTREACHED(); }
    };

///////////////

template
    <
    WCHAR Canonicalize(WCHAR)
    >
class STRING_GENERIC
    {
public:
    /////////////////////////////////////////////////////////
    //
    // State
    //
    /////////////////////////////////////////////////////////

    typedef STRING_GENERIC<Canonicalize> ME_T;

    REF_COUNTED_STRING* pstr;

    /////////////////////////////////////////////////////////
    //
    // Construction
    //
    /////////////////////////////////////////////////////////

    STRING_GENERIC()
        {
        pstr = NULL;
        }

    STRING_GENERIC(LPCWSTR wsz)
        { 
        pstr = REF_COUNTED_STRING::From(wsz);
        }

    STRING_GENERIC(const ME_T& him)
        {
        pstr = him.pstr;
        if (pstr) pstr->AddRef();
        }

    /////////////////////////////////////////////////////////
    //
    // Destruction
    //
    /////////////////////////////////////////////////////////

    ~STRING_GENERIC()
        {
        if (pstr) pstr->Release();
        }

    /////////////////////////////////////////////////////////
    //
    // Assignment
    //
    /////////////////////////////////////////////////////////

    ME_T& operator=(const ME_T& him)
        {
        if (him.pstr) him.pstr->AddRef();
        if (pstr) pstr->Release();
        pstr = him.pstr;
        return *this;
        }

    ME_T& operator=(LPCWSTR wsz)
        {
        if (pstr) pstr->Release();
        pstr = REF_COUNTED_STRING::From(wsz);
        return *this;
        }

    /////////////////////////////////////////////////////////
    //
    // Operations
    //
    /////////////////////////////////////////////////////////

    operator LPCWSTR() const 
        { 
        if (pstr)
            return &pstr->wsz[0];
        else
            return NULL;
        }

    ULONG Hash() const
        {
        if (pstr)
            {
            ULONG sum = 0;
            for (const WCHAR *pwch = &pstr->wsz[0]; *pwch; pwch++)
                {
                sum += Canonicalize(*pwch);
                }
            return sum * 214013L + 2531011L;
            }
        else
            return 13;
        }

    BOOL operator==(const ME_T& him) const
        {
        if (pstr && him.pstr)
            {
            LPCWSTR w1 = &pstr->wsz[0];
            LPCWSTR w2 = &him.pstr->wsz[0];
            while (true)
                {
                if (Canonicalize(w1[0]) == Canonicalize(w2[0]))
                    {
                    if (w1[0] == L'\0')
                        return true;
                    w1++;
                    w2++;
                    }
                else
                    return false;
                }
            }
        else
            {
            return (!!pstr == !!him.pstr);
            }
        }

    BOOL operator!=(const ME_T& him) const
        {
        return ! this->operator==(him);
        }

    };


inline WCHAR __Identity(WCHAR wch)        { return wch; }
inline WCHAR __ToLower(WCHAR wch)         { return towlower(wch); }

typedef STRING_GENERIC<__Identity>        MAP_KEY_STRING;
typedef STRING_GENERIC<__ToLower>         MAP_KEY_STRING_IGNORE_CASE;


///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for UNICODE_STRINGs
//
///////////////////////////////////////////////////////////////////////////////////

struct REF_COUNTED_UNICODE_STRING
    {
    ULONG           refs;
    UNICODE_STRING  u;

    void AddRef()  { InterlockedIncrement(&refs); }
    void Release() { if (0==InterlockedDecrement(&refs)) ExFreePool(this); }

    static REF_COUNTED_UNICODE_STRING* From(const UNICODE_STRING& uFrom)
        {
        REF_COUNTED_UNICODE_STRING* pstr = (REF_COUNTED_UNICODE_STRING*)AllocatePagedMemory(sizeof(REF_COUNTED_UNICODE_STRING) + uFrom.Length);
        if (pstr)
            {
            pstr->refs = 1;
            pstr->u.Length = pstr->u.MaximumLength = uFrom.Length;
            pstr->u.Buffer = (WCHAR*)&pstr[1];
            memcpy(pstr->u.Buffer, uFrom.Buffer, pstr->u.Length);
            }
        return pstr;
        }

private:
    REF_COUNTED_UNICODE_STRING()  { NOTREACHED(); }
    ~REF_COUNTED_UNICODE_STRING() { NOTREACHED(); }
    };

//////////////////////////////////

template
    <
    WCHAR Canonicalize(WCHAR)
    >
class UNICODE_GENERIC
    {
public:
    /////////////////////////////////////////////////////////
    //
    // State
    //
    /////////////////////////////////////////////////////////

    typedef UNICODE_GENERIC<Canonicalize> ME_T;

    REF_COUNTED_UNICODE_STRING* pstr;

    /////////////////////////////////////////////////////////
    //
    // Construction
    //
    /////////////////////////////////////////////////////////

    UNICODE_GENERIC()
        {
        pstr = NULL;
        }

    UNICODE_GENERIC(LPCWSTR wsz)
        {
        UNICODE_STRING uT;
        RtlInitUnicodeString(&uT, (LPWSTR)wsz);
        pstr = REF_COUNTED_UNICODE_STRING::From(uT);
        }

    UNICODE_GENERIC(const UNICODE_STRING& u)
        {
        pstr = REF_COUNTED_UNICODE_STRING::From(u);
        }

    UNICODE_GENERIC(const ME_T& him)
        {
        pstr = him.pstr;
        if (pstr) pstr->AddRef();
        }

    /////////////////////////////////////////////////////////
    //
    // Destruction
    //
    /////////////////////////////////////////////////////////

    ~UNICODE_GENERIC()
        {
        if (pstr) pstr->Release();
        }

    /////////////////////////////////////////////////////////
    //
    // Assignment
    //
    /////////////////////////////////////////////////////////

    ME_T& operator=(const ME_T& him)
        {
        if (him.pstr) him.pstr->AddRef();
        if (pstr) pstr->Release();
        pstr = him.pstr;
        return *this;
        }

    ME_T& operator=(LPCWSTR wsz)
        {
        if (pstr) pstr->Release();
        UNICODE_STRING uT;
        RtlInitUnicodeString(&uT, (LPWSTR)wsz);
        pstr = REF_COUNTED_UNICODE_STRING::From(uT);
        return *this;
        }

    ME_T& operator=(const UNICODE_STRING& u)
        {
        if (pstr) pstr->Release();
        pstr = REF_COUNTED_UNICODE_STRING::From(u);
        return *this;
        }

    /////////////////////////////////////////////////////////
    //
    // Operations
    //
    /////////////////////////////////////////////////////////

    operator UNICODE_STRING()
        {
        if (pstr)
            return pstr->u;
        else
            {
            UNICODE_STRING u;
            u.Length = u.MaximumLength = 0;
            u.Buffer = NULL;
            return u;
            }
        }

    ULONG Hash() const
        {
        if (pstr)
            {
            ULONG sum = 0;
            WCHAR* pwchFirst = &pstr->u.Buffer[0];
            WCHAR* pwchMax   = &pstr->u.Buffer[pstr->u.Length / sizeof(WCHAR)];
            for (const WCHAR *pwch = pwchFirst; pwch < pwchMax; pwch++)
                {
                sum += Canonicalize(*pwch);
                }
            return sum * 214013L + 2531011L;
            }
        else
            return 5;
        }

    BOOL operator==(const ME_T& m2) const
        {
        if (pstr && m2.pstr)
            {
            if (pstr->u.Length == m2.pstr->u.Length)
                {
                WCHAR* w1   = (*this).pstr->u.Buffer;
                WCHAR* w2   = m2.pstr->u.Buffer;
                int cchLeft = pstr->u.Length / sizeof(WCHAR);
                while (cchLeft > 0)
                    {
                    if (Canonicalize(w1[0]) == Canonicalize(w2[0]))
                        {
                        w1++;
                        w2++;
                        cchLeft--;
                        }
                    else
                        return false;
                    }
                return true;
                }
            else
                return false;
            }
        else
            return !!pstr == !!m2.pstr;
        }

    BOOL operator!=(const ME_T& m2) const
        {
        return ! this->operator==(m2);
        }

    };

typedef UNICODE_GENERIC<__Identity>     MAP_KEY_UNICODE;
typedef UNICODE_GENERIC<__ToLower>      MAP_KEY_UNICODE_IGNORE_CASE;

///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for GUIDs
//
///////////////////////////////////////////////////////////////////////////////////

class MAP_KEY_GUID
    {
public:
    GUID    guid;

    MAP_KEY_GUID()                                  {                }
    MAP_KEY_GUID(const GUID& g)                     { guid = g;      }
    MAP_KEY_GUID(const MAP_KEY_GUID& w)             { guid = w.guid; }

    operator GUID()                                 { return guid; }
    operator GUID&()                                { return guid; }

    MAP_KEY_GUID& operator=(const MAP_KEY_GUID& h)  { guid = h.guid; return *this; }
    MAP_KEY_GUID& operator=(const GUID& g)          { guid = g;      return *this; }

    ULONG Hash() const
    // Hash the GUID
        { 
        return *(ULONG*)&guid * 214013L + 2531011L;
        }
    
    BOOL operator==(const MAP_KEY_GUID& him) const  { return (*this).guid == him.guid; }
    BOOL operator!=(const MAP_KEY_GUID& him) const  { return ! this->operator==(him);  }
    };

///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for BOIDs, which are also the data type of XACTUOW
//
///////////////////////////////////////////////////////////////////////////////////

#ifdef __transact_h__   // that's where BOIDs are defined

inline BOOL operator==(const BOID& b1, const BOID& b2)
    {
    return memcmp(&b1, &b2, sizeof(BOID)) == 0;
    }

inline BOOL operator!=(const BOID& b1, const BOID& b2)
    {
    return memcmp(&b1, &b2, sizeof(BOID)) != 0;
    }

class MAP_KEY_BOID
    {
public:
    BOID    boid;

    MAP_KEY_BOID()                                  {                }
    MAP_KEY_BOID(const BOID& g)                     { boid = g;      }
    MAP_KEY_BOID(const MAP_KEY_BOID& w)             { boid = w.boid; }

    operator BOID()                                 { return boid; }
    operator BOID&()                                { return boid; }

    MAP_KEY_BOID& operator=(const MAP_KEY_BOID& h)  { boid = h.boid; return *this; }
    MAP_KEY_BOID& operator=(BOID& g)                { boid = g;      return *this; }

    ULONG Hash() const
    // Hash the BOID
        { 
        return *(ULONG*)&boid * 214013L + 2531011L;
        }
    
    BOOL operator==(const MAP_KEY_BOID& him) const  { return (*this).boid == him.boid; }
    BOOL operator!=(const MAP_KEY_BOID& him) const  { return ! this->operator==(him);  }
    };

#endif

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\md5.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// md5.h
//
// A pretty-darned fast implementation of MD5
//

#ifndef __MD5_H__
#define __MD5_H__

/////////////////////////////////////////////////////////////////////////////////////
//
// Declaration of the central transform function
//
void __stdcall MD5Transform(ULONG state[4], const ULONG* data);
        
/////////////////////////////////////////////////////////////////////////////////////

#pragma pack(push, 1)


// This structure is used to return the final resulting hash.
// 
struct MD5HASHDATA
    {
    union
        {
        BYTE rgb[16];
        struct
            {
            ULONGLONG ullLow;
            ULONGLONG ullHigh;
            };
        struct
            {
            ULONG     u0;
            ULONG     u1;
            ULONG     u2;
            ULONG     u3;
            };
        };
    };

inline BOOL operator==(const MD5HASHDATA& me, const MD5HASHDATA& him)
    {
    return memcmp(&me, &him, sizeof(MD5HASHDATA)) == 0;
    }

inline BOOL operator!=(const MD5HASHDATA& me, const MD5HASHDATA& him)
    {
    return memcmp(&me, &him, sizeof(MD5HASHDATA)) != 0;
    }


// The engine that carries out the hash
//
class MD5
    {
    // These four values must be contiguous, and in this order
    union
        {
        ULONG       m_state[4];
        struct
            {
            ULONG       m_a;              // state 
            ULONG       m_b;              //     ... variables
            ULONG       m_c;              //            ... as found in
            ULONG       m_d;              //                    ... RFC1321
            };
        };
    
    BYTE        m_data[64];       // where to accumulate the data as we are passed it
    ULONGLONG   m_cbitHashed;     // amount of data that we've hashed
    ULONG       m_cbData;         // number of bytes presently in data
    
    BYTE        m_padding[64];    // padding data, used if length data not = 0 mod 64

public:

    /////////////////////////////////////////////////////////////////////////////////////

    void Hash(const BYTE* pbData, ULONG cbData, MD5HASHDATA* phash, BOOL fConstructed = FALSE)
        {
        Init(fConstructed);
        HashMore(pbData, cbData);
        GetHashValue(phash);
        }

    /////////////////////////////////////////////////////////////////////////////////////

    void Hash(const BYTE* pbData, ULONGLONG cbData, MD5HASHDATA* phash, BOOL fConstructed = FALSE)
        {
        Init(fConstructed);

        ULARGE_INTEGER ul;
        ul.QuadPart = cbData;

        while (ul.HighPart)
            {
            ULONG cbHash = 0xFFFFFFFF;                      // Hash as much as we can at once
            HashMore(pbData, cbHash);
            pbData      += cbHash;
            ul.QuadPart -= cbHash;
            }
        
        HashMore(pbData, ul.LowPart);                       // Hash whatever is left

        GetHashValue(phash);
        }

    /////////////////////////////////////////////////////////////////////////////////////

    void Init(BOOL fConstructed = FALSE);

    /////////////////////////////////////////////////////////////////////////////////////

    void HashMore(const void* pvInput, ULONG cbInput);

    /////////////////////////////////////////////////////////////////////////////////////

    void GetHashValue(MD5HASHDATA* phash);

    /////////////////////////////////////////////////////////////////////////////////////

    };

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\nonpaged.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// nonpaged.h
//
#pragma code_seg(".text")

#undef SILENT_ENTRY
#undef ENTRY
#undef _

#pragma warning ( disable : 4003 ) //  not enough actual parameters for macro

#ifdef _DEBUG
    
    #define ENTRY(fn,traceCategory,traceTag)                                             \
        __FUNCTION_TRACER __trace(__FILE__,__LINE__,fn##"", traceCategory,traceTag##""); \
        __try { __trace.Enter();

    #define SILENT_ENTRY(fn)                                                             \
        __FUNCTION_TRACER __trace(__FILE__,__LINE__, fn ## "", 0, "");                   \
        __try { __trace.Enter();

    #define _                                                                            \
        } __finally { __trace.Exit(); }

   
#else

    #define SILENT_ENTRY(fn)
    #define ENTRY(fn,traceCategory,traceTag)
    #define _

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\probability.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// probability.h
//

#include "fixedpoint.h"

//BOOL       __stdcall SetRandomSeed(ULONG);

FIXEDPOINT __stdcall SampleUniform();
ULONG      __stdcall SampleUniform(ULONG);

ULONG      __stdcall SampleExponential(ULONG m);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\registry.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// registry.h
//
extern "C" {

//////////////////////////////////////////////////////////////////////
//
// Open / create
//

typedef struct HREG {
    HANDLE h;

    HREG() { h = NULL; }

    } HREG;

HRESULT OpenRegistryKey(
        HREG*       phkey,                      // place to return new key
        HREG        hKeyParent OPTIONAL,        // parent key to open under. may be NULL.
        LPCWSTR     wszKeyName,                 // child key name
        DWORD       dwDesiredAccess=KEY_READ,   // read, write, etc 
        BOOL        fCreate=FALSE               // whether to force creation or not
        );

HRESULT EnumerateRegistryKeys(
        HREG        hkey,
        ULONG       index,
        LPWSTR*     pwsz);

inline HRESULT CreateRegistryKey(HREG* pNewKey, HREG hkeyParent, LPCWSTR wszKeyName)
    {
    return OpenRegistryKey(pNewKey, hkeyParent, wszKeyName, KEY_WRITE, TRUE);
    }

inline void CloseRegistryKey(HREG hKey)
    {
    ZwClose(hKey.h);
    }

inline HRESULT DeleteRegistryKey(HREG hKey)
    {
    NTSTATUS status = ZwDeleteKey(hKey.h);
    return HrNt(status);
    }

inline HRESULT DeleteRegistryValue(HREG hKey, LPCWSTR wszValueName)
    {
    UNICODE_STRING u;
    RtlInitUnicodeString(&u, wszValueName);
    NTSTATUS status = ZwDeleteValueKey(hKey.h, &u);
    return HrNt(status);
    }

//////////////////////////////////////////////////////////////////////
//
// Retrieval
//

HRESULT GetRegistryValue(HREG hkey, LPCWSTR wszValueName, PKEY_VALUE_FULL_INFORMATION *ppinfo, ULONG expectedType);
HRESULT DoesRegistryValueExist(HREG hkey, LPCWSTR wszValue);

inline LPWSTR StringFromRegInfo(PKEY_VALUE_FULL_INFORMATION pinfo)
    {
    ASSERT(pinfo->Type == REG_SZ || pinfo->Type == REG_EXPAND_SZ);
    return (LPWSTR)((BYTE*)pinfo + pinfo->DataOffset);
    }

}

//////////////////////////////////////////////////////////////////////
//
// Setting
//
HRESULT __cdecl SetRegistryValue(HREG hkey, LPCWSTR wszValueName, ...);

inline HRESULT SetRegistryValue(HREG hkey, LPCWSTR wszValueName, LPCWSTR wsz)
    {
    return SetRegistryValue(hkey, wszValueName, wsz, NULL);
    }

//////////////////////////////////////////////////////////////////////
//
// Helper routines
//
extern "C" HRESULT RegisterInterfaceName(REFIID iid, LPCWSTR wszInterfaceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\map_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#pragma once

#include <enum_t.h>
#include <Linkable.h>


typedef unsigned long HASH;

//
// Several common Hasher classes: HashGUID, HashWSTR, HashInt, HashVoidPtr
//
class HashGUID {
    // "The best hash of a GUID is its first word" -- jimbo
public:
    static HASH Hash(const GUID& g) { return *(unsigned long*)&g; }
	static BOOL Equals(const GUID& g1, const GUID& g2) { return g1 == g2; }
};

class HashWSTR {
public:
	static HASH Hash(const WCHAR* pwc) {
		unsigned long hash = 0x01234567;
		while (*pwc) hash = (hash << 5) + (hash >> 27) + *pwc++;
		return hash;
	}
	static BOOL Equals(const WCHAR* pwc1, const WCHAR* pwc2) { 
		if (pwc1 == pwc2) return TRUE;
		if (!pwc1 || !pwc2) return FALSE;
		while (*pwc1 == *pwc2) {
			if (*pwc1 == 0) return TRUE;
			pwc1++, pwc2++;
		}
		return FALSE;
	}
};

class HashInt {
public:
	static HASH Hash(int i) { return i; }
	static BOOL Equals(int i, int j) { return i == j; }
};

class HashVoidPtr {
public:
	static HASH Hash(const void* pv) { return PtrToUlong(pv); }
	static BOOL Equals(const void* pv1, const void* pv2) { return pv1 == pv2; }
};

// empty class used as default base
class EmptyMapBase {};

// fwd decl template enum class used as friend
template <class D, class R, class H, class Base> class EnumMap;

//
// Map class
// Map<D,R,H> defines a hash table that maps from instances of 'D' to instances of 'R',
// using hashing class H.
// Map<D,R,H,Base> does the same thing, except that memory allocators are inherited from 'Base'.
//
// Class H should contain methods compatible with the following:
//		static HASH Hash(D);
//		static BOOL Equals(D,D);
//		if you prefer, any of the D's above can be "D&", "const D" or "const D&".
//
// If a 'Base' class is defined, it should contain nothing but "operator new" and "operator delete".
// So far as the present code is concerned, it is explicitly OK for said "operator new" to throw on 
// OOM. One must, of course, also understand if clients are expecting such behaviour.

template <class D, class R, class H, class Base=EmptyMapBase>
class Map : public Base {	// map from Domain type to Range type
public:
	Map(unsigned cBucketsInitial =17);
	~Map();

	// Remove all elements from the table
	void reset();

	// Find mapping for 'd' if any. If found, sets *pr. Return TRUE iff found.
	BOOL map (const D& d, R* pr) const;

	// Find mapping for 'd' if any. If found, sets *ppr. Return TRUE iff found.
	BOOL map (const D& d, R** ppr) const;

	// Return TRUE iff mapping for 'd' exists. If 'pd' supplied, also return a copy
	// of the 'd' that is mapped. (When we return TRUE, H::Equals(d,*pd) is true, but
	// not necessarily d==*pd).
	BOOL contains (const D& d, D* pd=NULL) const;

	// Add new mapping for 'd' -> 'r'. Delete previous mapping for 'd' if any.
	void add (const D& d, const R& r);
	
	// Remove mapping for 'd' if any.
	void remove (const D& d);

	// Return number of entries currently mapped.
	unsigned count() const;

	// If mapping for 'd' already exists, set *prFound to the mapped value and return FALSE.
	// Otherwise, add mapping for 'd' -> 'r', set *prFound = r, and return TRUE.
	BOOL addIfAbsent (const D& d, const R& r, R* prFound);

	// Perform internal consistency checks. Return TRUE iff hash table is healthy.
	BOOL invariants();

private:
	class Assoc : private CLinkable {
	private:
		Assoc* m_pAssocNext;
		long m_lcUse;
		D m_d;
		R m_r;

		Assoc (const D& d, const R& r) : m_pAssocNext(NULL), m_lcUse(0), m_d(d), m_r(r) {}
		BOOL isPresent() const	{ return m_lcUse < 0; }
		void setPresent()		{ m_lcUse |= 0x80000000; }
		void clearPresent()		{ m_lcUse &= 0x7FFFFFFF; }
		void* operator new (size_t n, Assoc* p) { return p; }	// for re-initializing a previously allocated Assoc
		friend class Map<D,R,H,Base>;
		friend class EnumMap<D,R,H,Base>;
	};

	Assoc** m_rgpAssoc;		// hash buckets. Linked list of elements (through Assoc::m_pAssocNext) that hash to the same value.
	unsigned m_cAssoc;		// number of hash buckets.
	unsigned m_cPresent;	// number of currently mapped entries.
	Assoc* m_pAssocFree;	// linked list (through Assoc::m_pAssocNext) of unused elements.
	CListHeader m_listInUse; // doubly linked list (through CLinkable) of elements that are either mapped, or referred to by an enumerator.

	// Find mapping for 'd'. If found, set *pppAssoc to the pointer to the pointer to the mapping element, and return TRUE.
	// If not found, set *pppAssoc to the pointer to where to store a pointer to a mapping element if you're going to create one, and return FALSE.
	BOOL find (const D& d, Assoc*** pppAssoc) const;

	// Rehash, using a number of buckets which is larger than the current number of elements.
	void grow ();

	// Create a new mapping for 'd' -> 'r', linking it into the linked list at 'ppAssoc'.
	void newAssoc (const D& d, const R& r, Assoc** ppAssoc);

	// Add an enumerator's reference to an Assoc.
	void addRefAssoc (Assoc* pAssoc);

	// Remove an enumerator's reference to an Assoc.
	void releaseAssoc (Assoc* pAssoc);

	// "Free" an Assoc (put it onto our free list).
	void freeAssoc (Assoc* pAssoc);

	friend class EnumMap<D,R,H,Base>;
};


template <class D, class R, class H, class Base> inline
Map<D,R,H,Base>::Map<D,R,H,Base> (unsigned cBucketsInitial)
:
	m_rgpAssoc(NULL),
	m_cAssoc(cBucketsInitial > 0 ? cBucketsInitial : 17),
	m_cPresent(0),
	m_pAssocFree(NULL)
{
	m_rgpAssoc = (Assoc**) operator new (sizeof(Assoc*) * m_cAssoc);	// uses Base::operator new, if any
	for (unsigned i = 0; i < m_cAssoc; i++)
		m_rgpAssoc[i] = NULL;
}

template <class D, class R, class H, class Base> inline
Map<D,R,H,Base>::~Map<D,R,H,Base> () {
	Assoc* pAssoc;

	while (!m_listInUse.IsEmpty()) {
		pAssoc = (Assoc*) m_listInUse.First();
		delete pAssoc;
	}

	while (m_pAssocFree != NULL) {
		pAssoc = m_pAssocFree;
		m_pAssocFree = pAssoc->m_pAssocNext;
		operator delete (pAssoc);	// uses Base::operator delete, if any
	}

	operator delete (m_rgpAssoc);	// uses Base::operator delete, if any
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::reset() {
	Assoc* pAssoc;
	CLinkable* pLinkable;

	pLinkable = m_listInUse.First();
	while (pLinkable != &m_listInUse) {
		pAssoc = (Assoc*)pLinkable;
		pLinkable = pLinkable->Next();
		pAssoc->clearPresent();
		if (pAssoc->m_lcUse == 0) {
			freeAssoc (pAssoc);
		}
	}

	for (unsigned i = 0; i < m_cAssoc; i++) {
		m_rgpAssoc[i] = NULL;
	}
	m_cPresent = 0;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::map (const D& d, R* pr) const {
	R* pr2;
	if (map(d, &pr2)) {
		*pr = *pr2;
		return TRUE;
	}
	return FALSE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::map (const D& d, R** ppr) const {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		*ppr = &(*ppAssoc)->m_r;
		return TRUE;
	}
	else
		return FALSE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::contains (const D& d, D* pd) const {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		if (pd) *pd = (*ppAssoc)->m_d;
		return TRUE;
	}
	else {
		return FALSE;
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::add (const D& d, const R& r) {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		// some mapping d->r2 already exists, replace with d->r
		(*ppAssoc)->m_d = d;
		(*ppAssoc)->m_r = r;
	}
	else {
		newAssoc(d,r,ppAssoc);
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::remove (const D& d) {
	Assoc** ppAssoc;
	Assoc* pAssoc;
	if (find(d, &ppAssoc)) {
		pAssoc = *ppAssoc;
		*ppAssoc = pAssoc->m_pAssocNext;

		pAssoc->clearPresent();
		if (pAssoc->m_lcUse == 0) {
			freeAssoc (pAssoc);
		}

		m_cPresent--;
	}
}

// Return the count of elements
template <class D, class R, class H, class Base> inline
unsigned Map<D,R,H,Base>::count() const {
	return m_cPresent;
}

// Lookup at d.
// If absent, return TRUE
// In any case, establish *prFound.
template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::addIfAbsent(const D& d, const R& r, R* prFound) {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		// some mapping d->r2 already exists; return r2
		*prFound = (*ppAssoc)->m_r;
		return FALSE;
	}
	else {
		// establish a new mapping d->r in the first unused entry
		newAssoc(d,r,ppAssoc);
		*prFound = r;
		return TRUE;
	}
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::invariants() {
	Assoc* pAssoc;
	Assoc** ppAssoc;
	CLinkable* pLinkable;
	unsigned cPresent = 0;

#define INVARIANTASSERT(x) { if (!(x)) { DebugBreak(); return FALSE; } }

	// Verify each Assoc on the inuse list
	for (pLinkable = m_listInUse.First(); pLinkable != &m_listInUse; pLinkable = pLinkable->Next()) {
		pAssoc = (Assoc*) pLinkable;
		INVARIANTASSERT (pAssoc == ((Assoc*)pLinkable->Next())->Previous());
		INVARIANTASSERT (pAssoc->m_lcUse != 0);
		find (pAssoc->m_d, &ppAssoc);
		if (pAssoc->isPresent()) {
			cPresent++;
			INVARIANTASSERT (pAssoc == *ppAssoc);
		}
		else {
			INVARIANTASSERT (pAssoc != *ppAssoc);
		}
	}
	INVARIANTASSERT (m_cPresent == cPresent);

	// Verify each Assoc on the hash lists
	cPresent = 0;
	for (unsigned i = 0; i < m_cAssoc; i++) {
		for (pAssoc = m_rgpAssoc[i]; pAssoc != NULL; pAssoc = pAssoc->m_pAssocNext) {
			INVARIANTASSERT (pAssoc != pAssoc->Next());
			INVARIANTASSERT (pAssoc->isPresent());
			find (pAssoc->m_d, &ppAssoc);
			INVARIANTASSERT (pAssoc == *ppAssoc);
			cPresent++;
		}
	}
	INVARIANTASSERT (m_cPresent == cPresent);

	// Verify each Assoc on the free list
	for (pAssoc = m_pAssocFree; pAssoc != NULL; pAssoc = pAssoc->m_pAssocNext) {
		INVARIANTASSERT (pAssoc == pAssoc->Next());
		INVARIANTASSERT (pAssoc->m_lcUse == 0);
	}

#undef INVARIANTASSERT
	return TRUE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::find (const D& d, Assoc*** pppAssoc) const {  
	unsigned h		= H::Hash(d) % m_cAssoc;

	*pppAssoc = &m_rgpAssoc[h];
	for (;;) {
		if (**pppAssoc == NULL)
			return FALSE;
		else if (H::Equals((**pppAssoc)->m_d,d))
			return TRUE;
		else
			*pppAssoc = &(**pppAssoc)->m_pAssocNext;
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::grow () {
	CLinkable* pLinkable;
	Assoc* pAssoc;
	Assoc** ppAssoc;
	unsigned i;

	static unsigned int rgprime[] = { 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949,
		21911, 43853, 87719, 175447, 350899, 701819, 1403641, 2807303, 5614657, 11229331,
		22458671, 44917381, 89834777, 179669557, 359339171, 718678369, 1437356741, 2874713497 };

	operator delete(m_rgpAssoc);	// uses Base::operator delete, if any
    m_rgpAssoc = NULL;              // in case the 'new' below throws, and we end up in our dtor

	for (i = 0; m_cPresent >= rgprime[i]; i++) /*nothing*/ ;
	m_rgpAssoc = (Assoc**)operator new(sizeof(Assoc*) * rgprime[i]);	// uses Base::operator new, if any
	m_cAssoc = rgprime[i];
	for (i = 0; i < m_cAssoc; i++)
		m_rgpAssoc[i] = NULL;

	pLinkable = m_listInUse.First();
	while (pLinkable != &m_listInUse) {
		pAssoc = (Assoc*) pLinkable;
		if (pAssoc->isPresent()) {
			find(pAssoc->m_d, &ppAssoc);
			pAssoc->m_pAssocNext = *ppAssoc;
			*ppAssoc = pAssoc;
		}
		pLinkable = pLinkable->Next();
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::newAssoc (const D& d, const R& r, Assoc** ppAssoc) {
	Assoc* pAssoc;
	if (m_pAssocFree == NULL) {
		pAssoc = (Assoc*) operator new(sizeof Assoc); // uses Base::operator new, if any
	}
	else {
		pAssoc = m_pAssocFree;
		m_pAssocFree = pAssoc->m_pAssocNext;
	}

	new(pAssoc) Assoc(d,r);	// run Assoc constructor on existing memory: ("yuck-o-rama!" -- BobAtk)
	pAssoc->setPresent();
	pAssoc->m_pAssocNext = *ppAssoc;
	*ppAssoc = pAssoc;
	m_listInUse.InsertLast(pAssoc);
	if (++m_cPresent > m_cAssoc)
		grow();
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::addRefAssoc (Assoc* pAssoc) {
	pAssoc->m_lcUse++;
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::releaseAssoc (Assoc* pAssoc) {
	pAssoc->m_lcUse--;
	if (pAssoc->m_lcUse == 0) {
		freeAssoc (pAssoc);
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::freeAssoc (Assoc* pAssoc) {
	pAssoc->~Assoc();		// run Assoc destructor
	pAssoc->m_pAssocNext = m_pAssocFree;
	m_pAssocFree = pAssoc;
}



// EnumMap must continue to enumerate correctly in the presence of Map<foo>::add()
// or Map<foo>::remove() being called in the midst of the enumeration.
template <class D, class R, class H, class Base=EmptyMapBase>
class EnumMap : public Enum, public Base {
public:
	EnumMap ();
	EnumMap (const Map<D,R,H,Base>& map);
	EnumMap (const EnumMap<D,R,H,Base>& e);
	~EnumMap ();

	void reset ();
	BOOL next ();
	void get (OUT D* pd, OUT R* pr) const;
	void get (OUT D* pd, OUT R** ppr) const;
    void get (OUT D** ppd, OUT R** ppr) const;
    void get (OUT D** ppd, OUT R* pr) const;

	EnumMap<D,R,H,Base>& operator= (const EnumMap<D,R,H,Base>& e);

    BOOL operator==(const EnumMap<D,R,H,Base>& enum2) const {
        return m_pmap == enum2.m_pmap && m_pLinkable == enum2.m_pLinkable;
    }

    BOOL operator!=(const EnumMap<D,R,H,Base>& enum2) const {
        return ! this->operator==(enum2);
    }

private:
	typedef Map<D,R,H,Base>::Assoc Assoc;

	Map<D,R,H,Base>* m_pmap;
	CLinkable* m_pLinkable;
};	



template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap () {
	m_pmap = NULL;
	m_pLinkable = &m_pmap->m_listInUse;
	// The above is NOT a bug. It makes the mantra "if (m_pLinkable != &m_pmap->m_listInUse)" return the right answer for null enum's.
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap (const Map<D,R,H,Base>& map) {
	m_pmap = const_cast<Map<D,R,H,Base>*> (&map);
	m_pLinkable = &m_pmap->m_listInUse;
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap (const EnumMap<D,R,H,Base>& e) {
	m_pmap = e.m_pmap;
	m_pLinkable = e.m_pLinkable;
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->addRefAssoc((Assoc*)m_pLinkable);
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::~EnumMap () {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::reset () {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
	m_pLinkable = &m_pmap->m_listInUse;
}

template <class D, class R, class H, class Base> inline
BOOL EnumMap<D,R,H,Base>::next () {
	CLinkable* pLink2 = m_pLinkable->Next();
	Assoc* pAssoc;
	
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);

	for(;;) {
		if (pLink2 == &m_pmap->m_listInUse) {
			m_pLinkable = pLink2;
			return FALSE;
		}
		pAssoc = (Assoc*)pLink2;
		if (pAssoc->isPresent()) {
			m_pmap->addRefAssoc(pAssoc);
			m_pLinkable = pLink2;
			return TRUE;
		}
		pLink2 = pLink2->Next();
	}
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D* pd, OUT R* pr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*pd = pAssoc->m_d;
	*pr = pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D* pd, OUT R** ppr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*pd = pAssoc->m_d;
	*ppr = &pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D** ppd, OUT R** ppr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*ppd = &pAssoc->m_d;
	*ppr = &pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D** ppd, OUT R* pr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*ppd = &pAssoc->m_d;
	*pr  = pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>& EnumMap<D,R,H,Base>::operator= (const EnumMap<D,R,H,Base>& e) {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
	m_pmap = e.m_pmap;
	m_pLinkable = e.m_pLinkable;
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->addRefAssoc((Assoc*)m_pLinkable);
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\paged.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// paged.h
//

// Paging isn't significant in user mode, and sections are worth saving

#ifdef KERNELMODE
    #pragma code_seg("PAGED")
#else
    #pragma code_seg(".text")
#endif

#undef SILENT_ENTRY
#undef ENTRY
#undef _

#pragma warning ( disable : 4003 ) //  not enough actual parameters for macro

#ifdef _DEBUG
    
    #define ENTRY(fn,traceCategory,traceTag)                                             \
        PAGED_CODE()                                                                     \
        __FUNCTION_TRACER __trace(__FILE__,__LINE__,fn##"", traceCategory,traceTag##""); \
        __try { __trace.Enter();

    #define SILENT_ENTRY(fn)                                                             \
        PAGED_CODE()                                                                     \
        __FUNCTION_TRACER __trace(__FILE__,__LINE__, fn ## "", 0, "");                   \
        __try { __trace.Enter();

    #define _                                                                            \
        } __finally { __trace.Exit(); }

   
#else

    #define SILENT_ENTRY(fn)
    #define ENTRY(fn,traceCategory,traceTag)
    #define _

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\oainternalrep.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// oaInternalRep.h
//
// Internal in-memory representations of OLE Automation data types

//////////////////////////////////////////////////////////////////////////
//
// BSTR
//
#pragma warning ( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union

//
// If one of these assertions fails, you will get a compiler error (C2118) about the subscript being bad.
//
#ifndef C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#endif

struct BSTR_INTERNAL
{
  private:
    ULONG cbPayload;
    WCHAR sz[];

  public:
    BSTR_INTERNAL(ULONG cch)
    {
        cbPayload = cch * sizeof(WCHAR);
    }

    ULONG  Cch()     { return cbPayload / sizeof(WCHAR); }
    ULONG  Cb()      { return cbPayload;                 }
    WCHAR* Sz()      { return &sz[0];                    }
    ULONG  CbAlloc() { return (ULONG) CbFor(Cch());              }

    static BSTR_INTERNAL* From(BSTR bstr)
    {
        return bstr ? CONTAINING_RECORD(bstr, BSTR_INTERNAL, sz) : NULL;
    }

#ifdef _DEBUG
    void* __stdcall operator new(size_t cbCore, ULONG cch, POOL_TYPE poolType, void* retAddr)
    {
        ASSERT(cbCore == sizeof(BSTR_INTERNAL));
        return AllocateMemory_(CbFor(cch), poolType, retAddr);
    }
    void* __stdcall operator new(size_t cbCore, ULONG cch, POOL_TYPE poolType = PagedPool)
    {
        ASSERT(cbCore == sizeof(BSTR_INTERNAL));
        return AllocateMemory_(CbFor(cch), poolType, _ReturnAddress());
    }
#else
    void* __stdcall operator new(size_t cbCore, size_t cch, POOL_TYPE poolType = PagedPool)
    {
        return AllocateMemory(CbFor(cch), poolType);
    }
#endif

  private:
    
    static size_t CbFor(size_t cch)
    {
        return sizeof(BSTR_INTERNAL) + (cch+1) * sizeof(WCHAR);
    }

};

//////////////////////////////////////////////////////////////////////////
//
// SAFEARRAY
//
struct SAFEARRAY_INTERNAL
{
    //////////////////////////////////////////////////////////
    //
    // State
    //
    //////////////////////////////////////////////////////////

    // See SafeArrayAllocDescriptor in oa\src\dispatch\sarray.cpp. An extra
    // GUID-sized-space is always allocated at the start.
    //
    union 
    {
        IID                 iid;

        struct
        {
            LONG            __dummy0[3];
            LONG            vt;
        };

        struct
        {
            // ::sigh:: There are 16 bytes before the pointer,
            // but the end of the valid part is always flush
            // with the SAFEARRAY structure.  Thus, we need to
            // pad according to the size of a pointer.
#ifdef _WIN64
            DWORD           __dummy1[2];
#else
            DWORD           __dummy1[3];
#endif
            IRecordInfo*    piri;
        };
    };

    SAFEARRAY array;

    //////////////////////////////////////////////////////////
    //
    // Operations
    //
    //////////////////////////////////////////////////////////

    SAFEARRAY* psa() { return &array; }

    SAFEARRAY_INTERNAL(UINT cDims)
    {
        Zero(this, CbFor(cDims));
        array.cDims = (USHORT)(cDims);
    }

    static SAFEARRAY_INTERNAL* From(SAFEARRAY* psa)
    {        
        return CONTAINING_RECORD(psa, SAFEARRAY_INTERNAL, array);
    }

#ifdef _DEBUG
    void* __stdcall operator new(size_t cbCore, UINT cDims, POOL_TYPE poolType, void* retAddr)
    {
        ASSERT(cbCore == sizeof(SAFEARRAY_INTERNAL));
        return AllocateMemory_(CbFor(cDims), poolType, retAddr);
    }
    void* __stdcall operator new(size_t cbCore, UINT cDims, POOL_TYPE poolType = PagedPool)
    {
        ASSERT(cbCore == sizeof(SAFEARRAY_INTERNAL));
        return AllocateMemory_(CbFor(cDims), poolType, _ReturnAddress());
    }
#else
    void* __stdcall operator new(size_t cbCore, UINT cDims, POOL_TYPE poolType = PagedPool)
    {
        return AllocateMemory(CbFor(cDims), poolType);
    }
#endif

  private:
    
    static size_t CbFor(UINT cDims)
    {
        return sizeof(SAFEARRAY_INTERNAL) + (cDims-1u) * sizeof(SAFEARRAYBOUND);
    }

};

//
// If one of these assertions fails, you will get a compiler error (C2118) about the subscript being bad.
//
// The allocation before a SAFEARRAY is exactly 16 bytes, so make sure we don't
// get messed up by padding or something else.
C_ASSERT(sizeof(SAFEARRAY_INTERNAL) == (sizeof(SAFEARRAY)+16));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\probe.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Probe.h
//
// Taken from ex.h



//
// Probe function definitions
//

//++
//
// BOOLEAN
// ProbeAndReadBoolean(
//     IN PBOOLEAN Address
//     )
//
//--

#define ProbeAndReadBoolean(Address) \
    (((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS) : (*(volatile BOOLEAN *)(Address)))

//++
//
// CHAR
// ProbeAndReadChar(
//     IN PCHAR Address
//     )
//
//--

#define ProbeAndReadChar(Address) \
    (((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CHAR * const)MM_USER_PROBE_ADDRESS) : (*(volatile CHAR *)(Address)))

//++
//
// UCHAR
// ProbeAndReadUchar(
//     IN PUCHAR Address
//     )
//
//--

#define ProbeAndReadUchar(Address) \
    (((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UCHAR * const)MM_USER_PROBE_ADDRESS) : (*(volatile UCHAR *)(Address)))

//++
//
// SHORT
// ProbeAndReadShort(
//     IN PSHORT Address
//     )
//
//--

#define ProbeAndReadShort(Address) \
    (((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SHORT * const)MM_USER_PROBE_ADDRESS) : (*(volatile SHORT *)(Address)))

//++
//
// USHORT
// ProbeAndReadUshort(
//     IN PUSHORT Address
//     )
//
//--

#define ProbeAndReadUshort(Address) \
    (((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile USHORT * const)MM_USER_PROBE_ADDRESS) : (*(volatile USHORT *)(Address)))

//++
//
// HANDLE
// ProbeAndReadHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeAndReadHandle(Address) \
    (((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HANDLE * const)MM_USER_PROBE_ADDRESS) : (*(volatile HANDLE *)(Address)))

//++
//
// LONG
// ProbeAndReadLong(
//     IN PLONG Address
//     )
//
//--

#define ProbeAndReadLong(Address) \
    (((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LONG * const)MM_USER_PROBE_ADDRESS) : (*(volatile LONG *)(Address)))

//++
//
// ULONG
// ProbeAndReadUlong(
//     IN PULONG Address
//     )
//
//--

#define ProbeAndReadUlong(Address) \
    (((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULONG * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULONG *)(Address)))

//++
//
// QUAD
// ProbeAndReadQuad(
//     IN PQUAD Address
//     )
//
//--

#define ProbeAndReadQuad(Address) \
    (((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile QUAD * const)MM_USER_PROBE_ADDRESS) : (*(volatile QUAD *)(Address)))

//++
//
// UQUAD
// ProbeAndReadUquad(
//     IN PUQUAD Address
//     )
//
//--

#define ProbeAndReadUquad(Address) \
    (((Address) >= (UQUAD * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UQUAD * const)MM_USER_PROBE_ADDRESS) : (*(volatile UQUAD *)(Address)))

//++
//
// LARGE_INTEGER
// ProbeAndReadLargeInteger(
//     IN PLARGE_INTEGER Source
//     )
//
//--

#define ProbeAndReadLargeInteger(Source)  \
    (((Source) >= (LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) : (*(volatile LARGE_INTEGER *)(Source)))

//++
//
// ULARGE_INTEGER
// ProbeAndReadUlargeInteger(
//     IN PULARGE_INTEGER Source
//     )
//
//--

#define ProbeAndReadUlargeInteger(Source)  \
    (((Source) >= (ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULARGE_INTEGER *)(Source)))

//++
//
// UNICODE_STRING
// ProbeAndReadUnicodeString(
//     IN PUNICODE_STRING Source
//     )
//
//--

#define ProbeAndReadUnicodeString(Source)  \
    (((Source) >= (UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) : (*(volatile UNICODE_STRING *)(Source)))

//++
//
// <STRUCTURE>
// ProbeAndReadStructure(
//     IN P<STRUCTURE> Source
//     <STRUCTURE>
//     )
//
//--

#define ProbeAndReadStructure(Source,STRUCTURE)  \
    (((Source) >= (STRUCTURE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(STRUCTURE * const)MM_USER_PROBE_ADDRESS) : (*(STRUCTURE *)(Source)))

//
// Probe for write functions definitions.
//
//++
//
// VOID
// ProbeForWriteBoolean(
//     IN PBOOLEAN Address
//     )
//
//--

#define ProbeForWriteBoolean(Address) {                                      \
    if ((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {               \
        *(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                        \
                                                                             \
    *(volatile BOOLEAN *)(Address) = *(volatile BOOLEAN *)(Address);         \
}

//++
//
// VOID
// ProbeForWriteChar(
//     IN PCHAR Address
//     )
//
//--

#define ProbeForWriteChar(Address) {                                         \
    if ((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile CHAR * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(volatile CHAR *)(Address) = *(volatile CHAR *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteUchar(
//     IN PUCHAR Address
//     )
//
//--

#define ProbeForWriteUchar(Address) {                                        \
    if ((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile UCHAR *)(Address) = *(volatile UCHAR *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteIoStatus(
//     IN PIO_STATUS_BLOCK Address
//     )
//
//--

#define ProbeForWriteIoStatus(Address) {                                     \
    if ((Address) >= (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS) {       \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                                           \
                                                                                                \
    *(volatile NTSTATUS *)&(Address)->Status      = *(volatile NTSTATUS*)&(Address)->Status;        \
    *(volatile ULONG    *)&(Address)->Information = *(volatile ULONG   *)&(Address)->Information;   \
}

//++
//
// VOID
// ProbeForWriteShort(
//     IN PSHORT Address
//     )
//
//--

#define ProbeForWriteShort(Address) {                                        \
    if ((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile SHORT * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile SHORT *)(Address) = *(volatile SHORT *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteUshort(
//     IN PUSHORT Address
//     )
//
//--

#define ProbeForWriteUshort(Address) {                                       \
    if ((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile USHORT * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile USHORT *)(Address) = *(volatile USHORT *)(Address);           \
}

//++
//
// VOID
// ProbeForWriteHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeForWriteHandle(Address) {                                       \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile HANDLE *)(Address) = *(volatile HANDLE *)(Address);           \
}

//++
//
// VOID
// ProbeAndZeroHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeAndZeroHandle(Address) {                                        \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile HANDLE *)(Address) = 0;                                       \
}

//++
//
// VOID
// ProbeAndNullPointer(
//     IN PVOID Address
//     )
//
//--

#define ProbeAndNullPointer(Address) {                                       \
    if ((PVOID *)(Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) {        \
        *(volatile PVOID * const)MM_USER_PROBE_ADDRESS = NULL;               \
    }                                                                        \
                                                                             \
    *(volatile PVOID *)(Address) = NULL;                                     \
}

//++
//
// VOID
// ProbeForWriteLong(
//     IN PLONG Address
//     )
//
//--

#define ProbeForWriteLong(Address) {                                        \
    if ((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                       \
                                                                            \
    *(volatile LONG *)(Address) = *(volatile LONG *)(Address);              \
}

//++
//
// VOID
// ProbeForWriteUlong(
//     IN PULONG Address
//     )
//
//--

#define ProbeForWriteUlong(Address) {                                        \
    if ((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile ULONG *)(Address) = *(volatile ULONG *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteQuad(
//     IN PQUAD Address
//     )
//
//--

#define ProbeForWriteQuad(Address) {                                         \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(volatile QUAD *)(Address) = *(volatile QUAD *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteUquad(
//     IN PUQUAD Address
//     )
//
//--

#define ProbeForWriteUquad(Address) {                                        \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile UQUAD *)(Address) = *(volatile UQUAD *)(Address);             \
}

//
// Probe and write functions definitions.
//
//++
//
// VOID
// ProbeAndWriteBoolean(
//     IN PBOOLEAN Address,
//     IN BOOLEAN Value
//     )
//
//--

#define ProbeAndWriteBoolean(Address, Value) {                               \
    if ((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {               \
        *(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteChar(
//     IN PCHAR Address,
//     IN CHAR Value
//     )
//
//--

#define ProbeAndWriteChar(Address, Value) {                                  \
    if ((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile CHAR * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUchar(
//     IN PUCHAR Address,
//     IN UCHAR Value
//     )
//
//--

#define ProbeAndWriteUchar(Address, Value) {                                 \
    if ((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteShort(
//     IN PSHORT Address,
//     IN SHORT Value
//     )
//
//--

#define ProbeAndWriteShort(Address, Value) {                                 \
    if ((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile SHORT * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUshort(
//     IN PUSHORT Address,
//     IN USHORT Value
//     )
//
//--

#define ProbeAndWriteUshort(Address, Value) {                                \
    if ((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile USHORT * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteHandle(
//     IN PHANDLE Address,
//     IN HANDLE Value
//     )
//
//--

#define ProbeAndWriteHandle(Address, Value) {                                \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteLong(
//     IN PLONG Address,
//     IN LONG Value
//     )
//
//--

#define ProbeAndWriteLong(Address, Value) {                                  \
    if ((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUlong(
//     IN PULONG Address,
//     IN ULONG Value
//     )
//
//--

#define ProbeAndWriteUlong(Address, Value) {                                 \
    if ((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteQuad(
//     IN PQUAD Address,
//     IN QUAD Value
//     )
//
//--

#define ProbeAndWriteQuad(Address, Value) {                                  \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUquad(
//     IN PUQUAD Address,
//     IN UQUAD Value
//     )
//
//--

#define ProbeAndWriteUquad(Address, Value) {                                 \
    if ((Address) >= (UQUAD * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteSturcture(
//     IN P<STRUCTURE> Address,
//     IN <STRUCTURE> Value,
//     <STRUCTURE>
//     )
//
//--

#define ProbeAndWriteStructure(Address, Value,STRUCTURE) {                   \
    if ((STRUCTURE * const)(Address) >= (STRUCTURE * const)MM_USER_PROBE_ADDRESS) {    \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\txfcommon.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfcommon.h
//
// #include "nt4sp3.h"
#include "txfdebug.h"
#include "txfmalloc.h"
#include "kompobj.h"
#include "txfutil.h"
#include "concurrent.h"
#include "lookaside.h"
#include "kom.h"
#include "IUnkInner.h"
#include "GenericClassFactory.h"
#include "ITypeInfoStackHelper.h"
#include "WorkerQueue.h"
#ifndef KERNELMODE
#include "ComRegistration.h"
#endif

class DECLSPEC_UUID("7A110BF5-D3C8-11d1-B88F-00C04FB9618A") TxfService;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\txfmalloc.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfmalloc.h
//
// Global, generic, memory managment related functionality
//
// JohnDoty:  Cleaned this up.  Removed kernel-mode stuff 
//            (since we don't use it).  Fake the existance of pool type
//            (from the DDK headers) since it doesn't matter in user mode.
//            Really should clean it out of functions...
//

#ifndef __TXFMALLOC_H__
#define __TXFMALLOC_H__

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// POOL_TYPE definition (for user mode, doesn't matter)
//
///////////////////////////////////////////////////////////////////////////////////////////////////

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType


    } POOL_TYPE;

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Ensure that the return address intrinsic is turned on
//
///////////////////////////////////////////////////////////////////////////////////////////////////

extern "C" void * _ReturnAddress(void);
#pragma intrinsic(_ReturnAddress)

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Core support for core allocation functionality
//
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

    #define TXFMALLOC_MAGIC ':rda'
    #define TXFMALLOC_FREE  0xcccccccc
    #define TXFMALLOC_RAW   0x88888888

    template <class T>
    inline BOOL IsGoodPointer(T* pt)
        {
        return (pt != NULL)
         && ((ULONG)pt != TXFMALLOC_FREE)
         && ((ULONG)pt != TXFMALLOC_RAW);
        }

        inline void* AllocateMemory_(size_t cb, POOL_TYPE poolType, PVOID retAddr)
            {
            PVOID pv = CoTaskMemAlloc((DWORD) (cb + 4 + sizeof(PVOID)));
            if (pv) 
	        {
				*(UNALIGNED ULONG*) ((BYTE*)pv + cb) = TXFMALLOC_MAGIC;
                memcpy( (BYTE*)pv + cb + 4, &retAddr, sizeof(PVOID));
			}
            return pv;
            }
        inline void FreeMemory(void* pv)
            {
            CoTaskMemFree(pv);
            }

    inline void* AllocateNonPagedMemory(size_t cb) { return AllocateMemory_(cb, NonPagedPool, _ReturnAddress()); }
    inline void* AllocatePagedMemory(size_t cb)    { return AllocateMemory_(cb,    PagedPool, _ReturnAddress()); }
    inline void* AllocateMemory(size_t cb, POOL_TYPE poolType=PagedPool)         
                                                   { return AllocateMemory_(cb,     poolType, _ReturnAddress()); }

#else

    template <class T>
    inline BOOL IsGoodPointer(T* pt)
        {
        return pt != NULL;
        }

        inline void* AllocateMemory(size_t cb, POOL_TYPE poolType=PagedPool)
            { 
            return CoTaskMemAlloc((DWORD) cb); 
            }
        inline void FreeMemory(void* pv)               
            { 
            CoTaskMemFree(pv);
            }


    inline void* AllocatePagedMemory(size_t cb)     { return AllocateMemory(cb, PagedPool); }
    inline void* AllocateNonPagedMemory(size_t cb)  { return AllocateMemory(cb, NonPagedPool); }

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Global operator new and deletes. 
//
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

    static inline void* __cdecl operator new(size_t cb)                     
        { 
        return AllocateMemory_(cb, PagedPool, _ReturnAddress()); 
        }
    static inline void* __stdcall operator new(size_t cb, POOL_TYPE poolType) 
        { 
        return AllocateMemory_(cb,  poolType, _ReturnAddress()); 
        }
    static inline void* __stdcall operator new(size_t cb, POOL_TYPE poolType, PVOID pvReturnAddress) 
        { 
        return AllocateMemory_(cb,  poolType, pvReturnAddress); 
        }

    static inline void __cdecl operator delete(void* pv) 
        { 
        FreeMemory(pv); 
        }

    extern "C" void CheckHeaps();

    extern "C" void PrintMemoryLeaks();


#else

    static inline void* __cdecl operator new(size_t cb)
        {
        return AllocateMemory(cb, PagedPool);
        }
    static inline void* __cdecl operator new(size_t cb, POOL_TYPE poolType)
        {
        return AllocateMemory(cb, poolType);
        }
    static inline void __cdecl operator delete(void* pv) 
        { 
        FreeMemory(pv); 
        }
    inline void CheckHeaps() { }


#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Support for having some classes declared as always-paged or always-nonpaged. Simply inherit
// the class from either 'Paged' or 'NonPaged'. In user mode, there is no difference, but it's 
// very significant in kernel mode.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template <POOL_TYPE poolType>
struct FromPool
    {
    #ifdef _DEBUG
        void* __stdcall operator new(size_t cb)                     
            { 
            return AllocateMemory_(cb, poolType, _ReturnAddress()); 
            }
        void* __stdcall operator new(size_t cb, POOL_TYPE ignored) 
            { 
            return AllocateMemory_(cb,  poolType, _ReturnAddress()); 
            }
        void* __stdcall operator new(size_t cb, POOL_TYPE ignored, PVOID pvReturnAddress) 
            { 
            return AllocateMemory_(cb, poolType, pvReturnAddress); 
            }
    #else
        void* __stdcall operator new(size_t cb)
            {
            return AllocateMemory(cb, poolType);
            }
        void* __stdcall operator new(size_t cb, POOL_TYPE ignored)
            {
            return AllocateMemory(cb, poolType);
            }
    #endif
    };

typedef FromPool<PagedPool>     Paged;
typedef FromPool<NonPagedPool>  NonPaged;

#include "InterlockedStack.h"

template <class T, POOL_TYPE poolType>
struct DedicatedAllocator
    {
    // The link we must have in order to use the interlocked stack
    //
    T* pNext;
    //
    // Our stack. Initialized somewhere else, one hopes. Clients are responsible
    // for declaring these variables and initializing them to the result of calling
    // CreateStack.
    //
    static IFastStack<T>* g_pStack;

    static IFastStack<T>* CreateStack()
        {
        IFastStack<T> *pFastStack;
        HRESULT hr = ::CreateFastStack(&pFastStack);
        return pFastStack;
        }

    static void DeleteStack()
        {
        if (g_pStack)
            {
            while (TRUE)
                {
                T* pt = g_pStack->Pop();
                if (pt)
                    {
                    FreeMemory(pt);
                    }
                else
                    {
                    break;
                    }
                }
            delete g_pStack;
            g_pStack = NULL;
            }
        }

    /////////////////////////////

    #ifdef _DEBUG
        static void* __stdcall DoAlloc(size_t cb, PVOID pvReturnAddress)
		{
            ASSERT(cb == sizeof(T));
            ASSERT(g_pStack);
            T* pt = g_pStack->Pop();
            if (!pt)
			{
                pt = (T*)AllocateMemory_(cb, poolType, pvReturnAddress);
				if (pt)
					pt->pNext = NULL;
			}
            return pt;
		}

        void* __stdcall operator new(size_t cb)
		{
            return DoAlloc(cb, _ReturnAddress());
		}
        
		void* __stdcall operator new(size_t cb, POOL_TYPE ignored) 
		{
            return DoAlloc(cb, _ReturnAddress());
		}
        
		void* __stdcall operator new(size_t cb, POOL_TYPE ignored, PVOID pvReturnAddress) 
		{
            return DoAlloc(cb, pvReturnAddress);
		}
    #else
        static void* __stdcall DoAlloc(size_t cb)
		{
            ASSERT(cb == sizeof(T));
            ASSERT(g_pStack);
            T* pt = g_pStack->Pop();
            if (!pt)
			{
                pt = (T*)AllocateMemory(cb, poolType);
				if (pt)
					pt->pNext = NULL;
			}
            return pt;
		}

        void* __stdcall operator new(size_t cb)
		{
            return DoAlloc(cb);
		}

        void* __stdcall operator new(size_t cb, POOL_TYPE ignored)
		{
            return DoAlloc(cb);
		}       
    #endif

    void __cdecl operator delete(void* pv)
        {
        ASSERT(g_pStack);
        T* pt = (T*)pv;
        ASSERT(NULL == pt->pNext);
        g_pStack->Push(pt);
        }
    };


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Make it so that the "COM Allocator" can be called by either CoTaskMemAlloc or ExAllocPool
// in both user and kernel mode
//
///////////////////////////////////////////////////////////////////////////////////////////////////


    inline PVOID ExAllocatePool(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
        {
        return CoTaskMemAlloc(NumberOfBytes);
        }

    inline void NTAPI ExFreePool(IN PVOID p)
        {
        CoTaskMemFree(p);
        }

/////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\txfrpcproxy.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// TxfRpcProxy.h
//
// Version of RpcProxy.h that is compilable under C++ instead of C.
// Also, contains the external declarations for the marshalling runtime 
// thunks exported from komdll.dll / komsys.sys.
//
#ifndef __TxfRpcProxy__h__
#define __TxfRpcProxy__h__

// 
// First, copy the C-variation of the vtbl defintions of some 
// key interfaces whose definitions are needed by the standard
// rpcproxy.h, which was designed to only be compilable as C, not 
// as C++. As these interfaces are frozen (like all interfaces, natch')
// snarfing them here doesn't particularly cause us problems
//

    typedef struct IRpcStubBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkServer);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *_prpcmsg,
            /* [in] */ IRpcChannelBuffer __RPC_FAR *_pRpcChannelBuffer);
        
        IRpcStubBuffer __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *IsIIDSupported )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *CountRefs )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DebugServerQueryInterface )( 
            IRpcStubBuffer __RPC_FAR * This,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *DebugServerRelease )( 
            IRpcStubBuffer __RPC_FAR * This,
            void __RPC_FAR *pv);
        
        END_INTERFACE
    } IRpcStubBufferVtbl;


    #define IRpcStubBufferVtbl_DEFINED


    typedef struct IPSFactoryBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPSFactoryBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPSFactoryBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProxy )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStub )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
            /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub);
        
        END_INTERFACE
    } IPSFactoryBufferVtbl;




    typedef struct IPSFactoryHookVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( __stdcall __RPC_FAR *QueryInterface )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( __stdcall __RPC_FAR *AddRef )(
            IPSFactoryBuffer __RPC_FAR * This);

        ULONG ( __stdcall __RPC_FAR *Release )(
            IPSFactoryBuffer __RPC_FAR * This);

        HRESULT ( __stdcall __RPC_FAR *CreateProxy )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);

        HRESULT ( __stdcall __RPC_FAR *CreateStub )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
            /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub);


        HRESULT ( __stdcall __RPC_FAR *HkGetProxyFileInfo )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out]*/ PINT     pOffset,
            /* [out]*/ PVOID    *ppProxyFileInfo);

        END_INTERFACE
    } IPSFactoryHookVtbl;


//
// Now, include the external definitions seen by COM proxies and stubs
//
extern "C" 
    {
    #define USE_STUBLESS_PROXY
    #include "rpcproxy.h"
    }



//////////////////////////////////////////////////////////////////////////////////
//
// Declarations for the ComPs exports
//



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\txfutil.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfutil.h
//
// Miscellanous and varied support utilities
//
#ifndef __TXFUTIL_H__
#define __TXFUTIL_H__

#include <malloc.h>     // for __alloca

/////////////////////////////////////////////////////////////////////////////////
//
// COM+ support functions called via COMSVCS.dll
//
/////////////////////////////////////////////////////////////////////////////////

void CallComSvcsLogError(HRESULT i_hrError, int i_iErrorMessageCode, LPWSTR i_wszInfo, BOOL i_fFailFast);

DWORD CallComSvcsExceptionFilter(EXCEPTION_POINTERS * i_xp, const WCHAR * i_wszMethodName, const WCHAR * i_wszObjectName);

///////////////////////////////////////////////////////////////////////////////////
//
// Error code management
//
///////////////////////////////////////////////////////////////////////////////////
//
// A simple utility that maps NT status codes into HRESULTs
//
extern "C" HRESULT HrNt(NTSTATUS status);


///////////////////////////////////////////////////////////////////////////////////
//
// Exception management
//
///////////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE
    inline void Throw_(DWORD dw)
        {
        EXCEPTION_RECORD ex;
        memset(&ex, 0, sizeof(ex));
        ex.ExceptionCode    = dw;
        ex.ExceptionFlags   = EXCEPTION_NONCONTINUABLE;
        ExRaiseException(&ex);
        }
#else
    inline void Throw_(DWORD dw)
        {
        RaiseException(dw, EXCEPTION_NONCONTINUABLE, 0, 0);
        }
#endif

inline void Throw_(DWORD dw, LPCSTR szTag, LPCSTR szFile, ULONG iline)
    {
    DEBUG(DebugTrace(__TRACE_ANY, szTag, "%s(%d): throwing exception 0x%08x", szFile, iline, dw));
    Throw_(dw);
    }

//////////////////

#ifdef _DEBUG

    #define Throw(dw)                                                                                   \
        {                                                                                               \
            DebugTrace(__TRACE_ANY, TAG, "%s(%d): throwing exception 0x%08x", __FILE__, __LINE__, dw);    \
            Throw_(dw);                                                                                 \
        }                                                                                               \

    #define ThrowNYI()                                                                                      \
        {                                                                                                   \
            DebugTrace(__TRACE_ANY, TAG, "%s(%d): functionality not yet implemented", __FILE__, __LINE__);    \
            Throw_(STATUS_NOT_IMPLEMENTED);                                                                 \
        }                                                                                                   \

    #define ThrowOutOfMemory()                                                                              \
        {                                                                                                   \
            DebugTrace(__TRACE_ANY, TAG, "%s(%d): out of memory", __FILE__, __LINE__);                        \
            Throw_(STATUS_NO_MEMORY);                                                                       \
        }                                                                                                   \

#else

    #define Throw(dw) Throw_(dw)

    inline void ThrowNYI()
        {
        Throw(STATUS_NOT_IMPLEMENTED);
        }

    inline void ThrowOutOfMemory()
        {
        Throw(STATUS_NO_MEMORY);
        }

#endif

inline void ThrowHRESULT(HRESULT hr)
    {
    Throw_(hr);      // REVIEW!
    }

///////////////////////////////////////////////////////////////////
//
// Support for reference counting in structures
//
///////////////////////////////////////////////////////////////////

struct REF_COUNTED_STRUCT
    {
private:

    LONG m_refs;

public:

    void AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs);      }
    void Release()  { if (InterlockedDecrement(&m_refs) == 0) delete this;  }

    REF_COUNTED_STRUCT()
        {
        m_refs = 1;
        }

protected:

    virtual ~REF_COUNTED_STRUCT()
        {
        }

    };


///////////////////////////////////////////////////////////////////
//
// Some functions for managing references
//
///////////////////////////////////////////////////////////////////

// Safely release pointer and NULL it
//
template <class Interface>
inline void Release(Interface*& punk)
    {
    if (punk) punk->Release();
    punk = NULL;
    }

template <class Interface>
inline void ReleaseConcurrent(Interface*& punk)
    {
    IUnknown* punkToRelease = (IUnknown*)InterlockedExchangePointer( (void**)&punk, NULL);
    if (punkToRelease) punkToRelease->Release();
    }
//
// Safely (re)set pointer
//
template <class Interface>
inline void Set(Interface*& var, Interface* value)
    {
    if (value) value->AddRef();
    ::Release(var);
    var = value;
    }

template <class Interface>
inline void SetConcurrent(Interface*& var, Interface* punkNew)
    {
    if (punkNew)  punkNew->AddRef();
    IUnknown* punkPrev = (IUnknown*)InterlockedExchangePointer( (void **)&var, punkNew);
    if (punkPrev) punkPrev->Release();
    }
//
// Type-safe QueryInterface: avoid the bug of forgetting to ptu the '&' before the out-param!
//
template <class T>
inline HRESULT QI(IUnknown*punk, T*& pt)
    {
    return punk->QueryInterface(__uuidof(T), (void**)&pt);
    }
//
// Reference counting for out-params on iid, ppv pairs
//
inline void AddRef(void**ppv)
    {
    ASSERT(*ppv);
    (*((IUnknown**)ppv))->AddRef();
    }


/////////////////////////////////////////////////////////////
//
// Process and thread inquiry
//
/////////////////////////////////////////////////////////////

//
// This is a neat little class.  It allows you to effectively
// have strongly typed "handles" (which are usually typed void * 
// or DWORD).
//
template <int i> class OPAQUE_HANDLE
{
  public:
    OPAQUE_HANDLE()                                     { }
    OPAQUE_HANDLE(HANDLE_PTR h)                         { m_h = h; }
    template <class T> OPAQUE_HANDLE(const T& t)        { m_h = (HANDLE_PTR)t; }
    
    OPAQUE_HANDLE& operator=(const OPAQUE_HANDLE& him)  { m_h = him.m_h; return *this; }
    OPAQUE_HANDLE& operator=(HANDLE_PTR h)              { m_h = h;       return *this; }
    
    BOOL operator==(const OPAQUE_HANDLE& him) const     { return m_h == him.m_h; }
    BOOL operator!=(const OPAQUE_HANDLE& him) const     { return m_h != him.m_h; }
    
    ULONG Hash() const { return (ULONG)m_h * 214013L + 2531011L; }

  private:
    HANDLE_PTR m_h;   
};

typedef OPAQUE_HANDLE<1> THREADID;
typedef OPAQUE_HANDLE<2> PROCESSID;

/////////////////////////////////////////////////////////////
//
// Process and thread notifications
//
/////////////////////////////////////////////////////////////

#ifdef KERNELMODE

typedef VOID (__stdcall * TXF_PCREATE_PROCESS_NOTIFY_ROUTINE)(
    IN PROCESSID processIdParent,
    IN PROCESSID processIdChild,
    IN BOOLEAN   fCreate
    );

typedef VOID (__stdcall * TXF_PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN PROCESSID processId,
    IN THREADID  threadId,
    IN BOOLEAN   fCreate
    );

extern "C" NTSTATUS
TxfSetCreateProcessNotifyRoutine(
    IN TXF_PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    );

extern "C" NTSTATUS
TxfSetCreateThreadNotifyRoutine(
    IN TXF_PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    );

#endif

/////////////////////////////////////////////////////////////
//
// Misc
//
/////////////////////////////////////////////////////////////

inline void Zero(VOID* pv, size_t cb)
    {
    memset(pv, 0, cb);
    }

template <class T> void Zero(T* pt)
    {
    Zero(pt, sizeof(*pt));
    }


inline void DebugInit(VOID* pv, ULONG cb)
    {
    #ifdef _DEBUG
        memset(pv, 0xcd, cb);
    #endif
    }

template <class T> void DebugInit(T* pt)
    {
    DebugInit(pt, sizeof(*pt));
    }

//////////////////////////////////////////////////////////////////////////////////

inline int DebuggerFriendlyExceptionFilter(DWORD dwExceptionCode)
// An exception filter that still allows JIT debugging to work inside a server method
    {
    if (dwExceptionCode == EXCEPTION_BREAKPOINT)
        return EXCEPTION_CONTINUE_SEARCH;
    else
        return EXCEPTION_EXECUTE_HANDLER;
    }

//////////////////////////////////////////////////////////////////////////////////


#ifdef KERNELMODE

#ifndef _WIN64
    inline BOOL IsUserModeAddress(PVOID Address, ULONG Length = 1)
        {
        if ((((ULONG)(Address) + (Length)) < (ULONG)(Address)) ||
            (((ULONG)(Address) + (Length)) > (ULONG)MM_USER_PROBE_ADDRESS))
            return FALSE;
        return TRUE;
        }
#else
    inline BOOL IsUserModeAddress(PVOID Address, ULONG Length = 1)
        {
        if (((PtrToUlong(Address) + (Length)) < PtrToUlong(Address)) ||
            ((PtrToUlong(Address) + (Length)) > (ULONG)MM_USER_PROBE_ADDRESS))
            return FALSE;
        return TRUE;
        }
#endif

    template <class T> void TestWrite(BOOL fProbe, T* pt, ULONG cb = sizeof(T)) { if (fProbe) { ProbeForWrite(pt, cb, 1);    }}
    template <class T> void TestWrite(             T* pt, ULONG cb = sizeof(T)) { TestWrite(IsUserModeAddress(pt), pt, cb);   }

    template <class T> void TestRead (BOOL fProbe, T* pt, ULONG cb = sizeof(T)) { if (fProbe) { ProbeForRead(pt, cb, 1);    }}
    template <class T> void TestRead (             T* pt, ULONG cb = sizeof(T)) { TestRead(IsUserModeAddress(pt), pt, cb);   }

#else

    inline BOOL IsUserModeAddress(PVOID Address, ULONG Length = 1)
    // In user mode it doesn't matter what we answer since we can't see the kernel mode addresses anyway
        {
        return TRUE;
        }

    #undef ProbeForRead
    #undef ProbeForWrite

    #define ProbeForRead(pv, cb, alignment)     ProbeForRead_(pv, cb, alignment)
    #define ProbeForWrite(pv, cb, alignment)    ProbeForWrite_(pv, cb, alignment)

    inline void ProbeForRead_(PVOID pv, ULONG cb, ULONG Alignement)
        {
        // Do nothing
        }

    inline void ProbeForWrite_(PVOID Address, ULONG Length, ULONG Alignment)
        {
        // Do nothing
        }

    template <class T> void TestWrite(BOOL fProbe, T* pt, ULONG cb = sizeof(T)) { }
    template <class T> void TestWrite(             T* pt, ULONG cb = sizeof(T)) { }

    template <class T> void TestRead (BOOL fProbe, T* pt, ULONG cb = sizeof(T)) { }
    template <class T> void TestRead (             T* pt, ULONG cb = sizeof(T)) { }


#endif


//////////////////////////////////////////////////////////////////////////////////


#ifdef KERNELMODE

inline void CopyFromUserMode(void* pvTo, void* pvFrom, ULONG cb)
    {
    ProbeForRead(pvFrom, cb, 1);
    memcpy(pvTo, pvFrom, cb);
    }

inline NTSTATUS TryCopyFromUserMode(void* pvTo, void* pvFrom, ULONG cb)
    {
    __try
        {
        CopyFromUserMode(pvTo, pvFrom, cb);
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
        return GetExceptionCode();
        }
    return(STATUS_SUCCESS);
    }

inline void CopyToUserMode(void* pvTo, void* pvFrom, ULONG cb)
    {
    ProbeForWrite(pvTo, cb, 1);
    memcpy(pvTo, pvFrom, cb);
    }

inline NTSTATUS TryCopyToUserMode(void* pvTo, void* pvFrom, ULONG cb)
    {
    __try
        {
        CopyToUserMode(pvTo, pvFrom, cb);
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
        return GetExceptionCode();
        }
    return(STATUS_SUCCESS);
    }


#endif

/////////////////////////////////////////////////////////////
//
// Startup / shutdown calls that must be made by
// clients of TxfAuxSys.Sys. In user mode, they're optional.
//
/////////////////////////////////////////////////////////////

extern "C" void __stdcall InitializeTxfAux();
extern "C" void __stdcall UninitializeTxfAux();

/////////////////////////////////////////////////////////////
//
// Convert guids to strings. String buffers must be at least
// 39 characters characters long:
//
// {F75D63C5-14C8-11d1-97E4-00C04FB9618A}
// 123456789012345678901234567890123456789
//
void    __stdcall StringFromGuid(REFGUID guid, LPWSTR pwsz);  // unicode
void    __stdcall StringFromGuid(REFGUID guid, LPSTR psz);    // ansi

HRESULT __stdcall GuidFromString(LPCWSTR pwsz, GUID* pGuid);
HRESULT __stdcall GuidFromString(LPCSTR  sz,   GUID* pguid);
HRESULT __stdcall GuidFromString(UNICODE_STRING& u, GUID* pguid);


/////////////////////////////////////////////////////////////
//
// Type-specific wrappers for the interlocked primitives
//
/////////////////////////////////////////////////////////////

inline
ULONG
InterlockedCompareExchange(
    ULONG volatile *Destination,
    ULONG Exchange,
    ULONG Comperand
    )

{
    return InterlockedCompareExchange((LONG *)Destination,
                                      (LONG)Exchange,
                                      (LONG)Comperand);
}

inline
ULONG
InterlockedIncrement(
    ULONG* pul
    )

{
    return (ULONG)InterlockedIncrement((LONG *)pul);
}

inline
ULONG
InterlockedDecrement(
    ULONG* pul
    )

{
    return (ULONG)InterlockedDecrement((LONG *)pul);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Support for swapping 64 bits of data in an interlocked manner.
//
////////////////////////////////////////////////////////////////////////////////////////

#ifdef _X86_
    #pragma warning (disable: 4035)     // function doesn't return value warning.
    inline LONGLONG TxfInterlockedCompareExchange64 (volatile LONGLONG* pDestination, LONGLONG exchange, LONGLONG comperand)
        {
        __asm
            {
            mov esi, pDestination

            mov eax, DWORD PTR comperand[0]
            mov edx, DWORD PTR comperand[4]

            mov ebx, DWORD PTR exchange[0]
            mov ecx, DWORD PTR exchange[4]

            // lock cmpxchg8b [esi] - REVIEW: would like to use new compiler that understands this
            _emit 0xf0
            _emit 0x0f
            _emit 0xc7
            _emit 0x0e

            // result is in DX,AX
            }
        }
    #pragma warning (default: 4035)     // function doesn't return value warning
#endif


#if defined(_WIN64)
    inline LONGLONG TxfInterlockedCompareExchange64 (volatile LONGLONG* pDestination, LONGLONG exchange, LONGLONG comperand)
        {
        return ((ULONGLONG)_InterlockedCompareExchangePointer( (void **)pDestination, (PULONGLONG)exchange, (PULONGLONG)comperand ));
        }

#endif

////////////////////////////////////////////////////////////////////////////////////////
//
// CanUseCompareExchange64: Are we allowed to use the hardware support?
//
////////////////////////////////////////////////////////////////////////////////////////

#ifdef _X86_
    #ifdef KERNELMODE
        inline BOOL CanUseCompareExchange64() { return ExIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE); }
    #else
        extern "C" BOOL __stdcall CanUseCompareExchange64();
    #endif
#else
        inline BOOL CanUseCompareExchange64() { return TRUE; }
#endif

/////////////////////////////////////////////////////////////
//
// C Runtime support
//
/////////////////////////////////////////////////////////////

#ifdef KERNELMODE

//
// Simulated C / C++ runtime support. Call these to initialize / terminate static
// data / constructors. The functions internally do reference counting, and so calls
// to them nest correctly.
//
BOOL __stdcall InitializeRuntime(); // Return value indicates whether this is the first time in
void __stdcall TerminateRuntime();

#else

// In user mode the actual work is done in dll attach / unattach
//
inline BOOL __stdcall InitializeRuntime() { return FALSE; }
inline void __stdcall TerminateRuntime()  { }

#endif


/////////////////////////////////////////////////////////////
//
// String utilties
//
/////////////////////////////////////////////////////////////

//
// Concatenate a list of zero-terminated wide strings together into a newly allocated string.
//
HRESULT __cdecl   StringCat(LPWSTR* pwsz,       ...);
HRESULT __cdecl   StringCat(UNICODE_STRING* pu, ...);
HRESULT __stdcall StringCat(LPWSTR* pwsz, va_list va);

//
// Concatenate a list of unicode strings together to yield a new unicode string
//
HRESULT __cdecl StringUnicodeCat(UNICODE_STRING* pu, ...);


inline LPWSTR StringBetween(const WCHAR* pchFirst, const WCHAR* pchMax)
    {
    SIZE_T cch = pchMax - pchFirst;
    SIZE_T cb = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz = (LPWSTR)AllocateMemory(cb);
    if (wsz)
        {
        memcpy(wsz, pchFirst, cch*sizeof(WCHAR));
        wsz[cch] = L'\0';
        }
    return wsz;
    }

inline LPSTR StringBetween(const CHAR* pchFirst, const CHAR* pchMax)
    {
    SIZE_T cch = pchMax - pchFirst;
    SIZE_T cb = (cch+1) * sizeof(CHAR);
    LPSTR sz = (LPSTR)AllocateMemory(cb);
    if (sz)
        {
        memcpy(sz, pchFirst, cch*sizeof(CHAR));
        sz[cch] = '\0';
        }
    return sz;
    }

inline WCHAR& LastChar(LPWSTR wsz)
    {
    ASSERT(wcslen(wsz) > 0);
    return wsz[wcslen(wsz)-1];
    }

inline const WCHAR& LastChar(LPCWSTR wsz)
    {
    ASSERT(wcslen(wsz) > 0);
    return wsz[wcslen(wsz)-1];
    }

inline CHAR& LastChar(LPSTR sz)
    {
    ASSERT(strlen(sz) > 0);
    return sz[strlen(sz)-1];
    }

inline const CHAR& LastChar(LPCSTR sz)
    {
    ASSERT(strlen(sz) > 0);
    return sz[strlen(sz)-1];
    }

inline LPWSTR CopyString(LPCWSTR wszFrom)
    {
    SIZE_T  cch = wcslen(wszFrom);
    SIZE_T  cb = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz = (LPWSTR)AllocateMemory(cb);
    if (wsz)
        {
        memcpy(wsz, wszFrom, cb);
        }
    return wsz;
    }

inline LPSTR CopyString(LPCSTR szFrom)
    {
    SIZE_T cch = strlen(szFrom);
    SIZE_T cb = (cch+1);
    LPSTR sz = (LPSTR)AllocateMemory(cb);
    if (sz)
        {
        memcpy(sz, szFrom, cb);
        }
    return sz;
    }

inline BLOB Copy(const BLOB& bFrom)
    {
    BLOB bTo;
    Zero(&bTo);
    if (bFrom.cbSize > 0)
        {
        bTo.pBlobData = (BYTE*)AllocateMemory(bFrom.cbSize);
        if (bTo.pBlobData)
            {
            memcpy(bTo.pBlobData, bFrom.pBlobData, bFrom.cbSize);
            bTo.cbSize = bFrom.cbSize;
            }
        }
    return bTo;
    }

//////////////////////////////////////////////////////////////
//
// Unicode conversion
//
void    ToUnicode(LPCSTR sz, LPWSTR wsz, ULONG cch);
LPWSTR  ToUnicode(LPCSTR sz);

#ifdef KERNELMODE
//
// In kernel mode we've snarfed copies of the system's core conversion routines
//
extern "C" int UTF8ToUnicode(LPCSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr,int cchDest);
extern "C" int UnicodeToUTF8(LPCWSTR lpSrcStr, int cchSrc, LPSTR lpDestStr,int cchDest);

#endif

inline LPSTR ToUtf8(LPCWSTR wsz, ULONG cch)
// String doesn't have to be zero terminated
    {
    ULONG cb   = (cch+1) * 3;
    LPSTR sz   = (LPSTR)_alloca(cb);
    #ifdef KERNELMODE
        int cbWritten = UnicodeToUTF8(wsz, cch, sz, cb);
    #else
        int cbWritten = WideCharToMultiByte(CP_UTF8, 0, wsz, cch, sz, cb, NULL, NULL);
    #endif
    sz[cbWritten]=0;
    return CopyString(sz);
    }

inline LPSTR ToUtf8(LPCWSTR wsz)
    {
    return ToUtf8(wsz, (ULONG) wcslen(wsz));
    }

inline LPWSTR FromUtf8(CHAR* sz, ULONG cch)
// String doesn't have to be zero terminated
    {
    ULONG cb   = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz  = (LPWSTR)_alloca(cb);
    #ifdef KERNELMODE
        int cchWritten = UTF8ToUnicode(sz, cch, wsz, cch+1);
    #else
        int cchWritten = MultiByteToWideChar(CP_UTF8, 0, sz, cch, wsz, cch+1);
    #endif
    wsz[cchWritten] = 0;
    return CopyString(wsz);
    }

inline LPWSTR FromUtf8(LPSTR sz)
    {
    return FromUtf8(sz, (ULONG) strlen(sz));
    }


//
// Misc
//
UNICODE_STRING  __stdcall UnicodeFindLast(UNICODE_STRING* pu, WCHAR wch);
UNICODE_STRING* __stdcall UnicodeContingous(UNICODE_STRING* pu);
inline UNICODE_STRING Copy(UNICODE_STRING& u)
    {
    UNICODE_STRING uMe;
    if (S_OK == StringUnicodeCat(&uMe, &u, NULL))
        return uMe;
    memset(&uMe, 0, sizeof(uMe));
    return uMe;
    }


inline void Advance(UNICODE_STRING&u, USHORT cch=1)
// Advance the UNICODE_STRING by the indicated number of charcters
    {
    u.Buffer        += cch;         // in characters
    u.Length        -= (cch+cch);   // in bytes
    u.MaximumLength -= (cch+cch);   // in bytes
    }

#ifdef _DEBUG

inline BOOL IsValid(UNICODE_STRING& u)
// Answer whether this is a reasonable UNICODE_STRING or not
    {
    return (u.Length % 2 == 0)
        && (u.Length <= u.MaximumLength)
        && (u.MaximumLength == 0 || u.Buffer != NULL);
    }

#endif

inline BOOL IsPrefixOf(LPCWSTR wszPrefix, LPCWSTR wszTarget)
    {
    if (wszPrefix && wszTarget)
        {
        while (TRUE)
            {
            if (wszPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (wszTarget[0] == 0)  return FALSE;   // run out of target first
            if (wszPrefix[0] == wszTarget[0])
                {
                wszPrefix++;
                wszTarget++;
                }
            else
                return FALSE;
            }
        }
    else
        return FALSE;
    }

inline BOOL IsPrefixOf(LPCSTR szPrefix, LPCSTR szTarget)
    {
    if (szPrefix && szTarget)
        {
        while (TRUE)
            {
            if (szPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (szTarget[0] == 0)  return FALSE;   // run out of target first
            if (szPrefix[0] == szTarget[0])
                {
                szPrefix++;
                szTarget++;
                }
            else
                return FALSE;
            }
        }
    else
        return FALSE;
    }

inline BOOL IsPrefixOfIgnoreCase(LPCWSTR wszPrefix, LPCWSTR wszTarget)
    {
    if (wszPrefix && wszTarget)
        {
        while (TRUE)
            {
            if (wszPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (wszTarget[0] == 0)  return FALSE;   // run out of target first
            if (towupper(wszPrefix[0]) == towupper(wszTarget[0]))
                {
                wszPrefix++;
                wszTarget++;
                }
            else
                return FALSE;
            }
        }
    else
        return FALSE;
    }

inline BOOL IsPrefixOfIgnoreCase(LPCSTR szPrefix, LPCSTR szTarget)
    {
    if (szPrefix && szTarget)
        {
        while (TRUE)
            {
            if (szPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (szTarget[0] == 0)  return FALSE;   // run out of target first
            if (toupper(szPrefix[0]) == toupper(szTarget[0]))
                {
                szPrefix++;
                szTarget++;
                }
            else
                return FALSE;
            }
        }
    else
        return FALSE;
    }

/////////////////////////////////////////////////////////

#ifndef __RC_STRINGIZE__
#define __RC_STRINGIZE__AUX(x)      #x
#define __RC_STRINGIZE__(x)         __RC_STRINGIZE__AUX(x)
#endif

#define MESSAGE_WARNING(file,line)   file "(" __RC_STRINGIZE__(line) ") : warning "
#define MESSAGE_ERROR(file,line)     file "(" __RC_STRINGIZE__(line) ") : error "

/////////////////////////////////////////////////////////////
//
// IStream utilities
//
/////////////////////////////////////////////////////////////

HRESULT __stdcall SeekFar(IStream* pstm, LONGLONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET);

inline HRESULT SeekFar(IStream* pstm, ULONGLONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET)
    {
    return SeekFar(pstm, (LONGLONG)offset, fromWhat);
    }

HRESULT __stdcall Seek(IStream* pstm, LONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET);

HRESULT __stdcall Seek(IStream* pstm, ULONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET);

HRESULT __stdcall Read(IStream* pstm, LPVOID pBuffer, ULONG cbToRead);

HRESULT __stdcall Write(IStream* pstm, const void* pBuffer, ULONG cbToWrite);

inline HRESULT Write(IStream* pstm, const BLOB& blob)
    {
    return Write(pstm, blob.pBlobData, blob.cbSize);
    }
inline HRESULT __stdcall WriteChar(IStream* pstm, wchar_t wch)
    {
    return Write(pstm, &wch, sizeof(wchar_t));
    }
inline HRESULT __stdcall WriteChar(IStream* pstm, char ch)
    {
    return Write(pstm, &ch, sizeof(char));
    }
inline HRESULT __stdcall WriteString(IStream* pstm, LPCWSTR wsz)
    {
    if (wsz)
        return Write(pstm, wsz, (ULONG) wcslen(wsz)*sizeof(WCHAR));
    else
        return S_OK;
    }
inline HRESULT __stdcall WriteString(IStream* pstm, LPCSTR sz)
    {
    if (sz)
        return Write(pstm, sz, (ULONG) strlen(sz));
    else
        return S_OK;
    }

inline HRESULT CurrentPosition(IStream* pstm, ULONGLONG* pCurrentPosition)
    {
    LARGE_INTEGER lMove;
    lMove.QuadPart = 0;
    return pstm->Seek(lMove, STREAM_SEEK_CUR, (ULARGE_INTEGER*)pCurrentPosition);
    }


extern "C" HRESULT __stdcall NewMemoryStream    (BLOB* pb, IStream** ppstm);
extern "C" HRESULT __stdcall CreateMemoryStream (IUnknown* punkOuter, REFIID, void**);
extern "C" HRESULT __stdcall FreeMemoryStream   (IStream* pstm);

#include "txfaux.h"

inline BLOB GetBuffer(IStream* pstm)
// Get back the BLOB that underlies a memory stream;
    {
    BLOB b;
    IMemoryStream* pmem;
    HRESULT_ hr = QI(pstm, pmem);
    if (!hr)
        {
        hr = pmem->GetBuffer(&b);
        if (!hr)
            {
            pmem->Release();
            return b;
            }
        }
    NOTREACHED();
    return b;
    }

/////////////////////////////////////////////////////////////
//
// System work arounds
//
/////////////////////////////////////////////////////////////

#ifdef KERNELMODE

/*
 * ZwFlushBuffersFile is defined as __declspec(dllimport):
 *
 *   NTSYSAPI
 *   NTSTATUS
 *   NTAPI
 *   ZwFlushBuffersFile(
 *       IN HANDLE FileHandle,
 *       OUT PIO_STATUS_BLOCK IoStatusBlock
 *       );
 *
 * Thus to link against it statically, which we want to do here, we have to do
 * a rename.
 */
#define ZwFlushBuffersFile(FineHandle, IoStatusBlock)\
    TxfZwFlushBuffersFile(FineHandle, IoStatusBlock)

#define ZwCreateThread(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended)\
    TxfZwCreateThread(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended);

NTSTATUS NTAPI TxfZwFlushBuffersFile(
        IN HANDLE FileHandle,
        OUT PIO_STATUS_BLOCK IoStatusBlock);

NTSTATUS NTAPI TxfZwCreateThread(
        OUT PHANDLE ThreadHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
        IN HANDLE ProcessHandle,
        OUT PCLIENT_ID ClientId,
        IN PCONTEXT ThreadContext,
        IN PINITIAL_TEB InitialTeb,
        IN BOOLEAN CreateSuspended
        );

#endif




/////////////////////////////////////////////////////////////
//
// Some arithmetic utilities
//
/////////////////////////////////////////////////////////////

inline ULONG RoundToNextMultiple(ULONG i, ULONG multiple)
// Round i to the next multiple of 'multiple'
    {
    return (i + multiple-1) / multiple * multiple;
    }


inline void * RoundToNextMultiple(void * i, ULONG multiple)
    {
    return (void *)(((ULONG_PTR)i + multiple-1) / multiple * multiple);
    }
inline ULONGLONG RoundToNextMultiple(ULONGLONG i, ULONG multiple)
    {
    return (i + multiple-1) / multiple * multiple;
    }


/////////////////////////////////////////////////////////////
//
// Some alignment management utilities
//
/////////////////////////////////////////////////////////////

template <class T>
inline ULONG AlignmentOf(T* pt)
// Answer 1, 2, 4, 8 etc as to the required alignement for the given type
//
    {
    switch (sizeof(*pt))
        {
    case 0:
        return 1;
    case 1:
        return 1;
    case 2:
        return 2;
    case 3: case 4:
        return 4;
    case 5: case 6: case 7: case 8: default:
        return 8;
        }
    }

inline BYTE* AlignTo(PVOID pv, ULONG alignment)
    {
    ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
    BYTE* pb = (BYTE*)RoundToNextMultiple(pv, alignment);
    return pb;
    }

template <class T>
inline BYTE* AlignedConcat(PVOID pv, T* pt)
// Concatenate new data on the end of a buffer in an aligned way
    {
    if (pt)
        {
        ULONG alignment = AlignmentOf(pt);

        ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
        BYTE* pb = (BYTE*)RoundToNextMultiple(pv, alignment);

        memcpy(pb, pt, sizeof(*pt));

        return pb + sizeof(*pt);
        }
    else
        return (BYTE*)pv;
    }

template <class T>
inline BYTE* AlignedConcatSize(PVOID pv, T* pt)
// Concatenate new data on the end of a buffer in an aligned way
    {
    if (pt)
        {
        ULONG alignment = AlignmentOf(pt);

        ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
        BYTE* pb = (BYTE*)RoundToNextMultiple((UINT_PTR)pv, (UINT_PTR)alignment);

        return pb + sizeof(*pt);
        }
    else
        return (BYTE*)pv;
    }


/////////////////////////////////////////////////////////////
//
// Reasonable arithmetic on large integers
//
/////////////////////////////////////////////////////////////

#define DEFINE_LARGE_ARITHMETIC(__LARGE_INT__, op)                                  \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, const __LARGE_INT__& a2) \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2.QuadPart;                                      \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, LONGLONG a2)             \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, LONG a2)                 \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, ULONGLONG a2)            \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, ULONG a2)                \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (LONGLONG a1, const __LARGE_INT__& a2)             \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (LONG a1, const __LARGE_INT__& a2)                 \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (ULONGLONG a1, const __LARGE_INT__& a2)            \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (ULONG a1, const __LARGE_INT__& a2)                \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }


DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, +)
DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, -)
DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, *)
DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, /)

DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, +)
DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, -)
DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, *)
DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, /)


#define DEFINE_LARGE_BOOLEAN(op)                                                                                            \
                                                                                                                            \
    inline BOOL operator op (const  LARGE_INTEGER& a1, const  LARGE_INTEGER& a2){ return a1.QuadPart op a2.QuadPart;   }    \
    inline BOOL operator op (const ULARGE_INTEGER& a1, const ULARGE_INTEGER& a2){ return a1.QuadPart op a2.QuadPart;   }    \
                                                                                                                            \
    inline BOOL operator op (const LARGE_INTEGER& a1,  LONGLONG a2)           { return a1.QuadPart op a2;              }    \
    inline BOOL operator op (const LARGE_INTEGER& a1, ULONGLONG a2)           { return (ULONGLONG)a1.QuadPart op a2;   }    \
    inline BOOL operator op ( LONGLONG a1, const LARGE_INTEGER& a2)           { return a1 op a2.QuadPart;              }    \
    inline BOOL operator op (ULONGLONG a1, const LARGE_INTEGER& a2)           { return a1 op (ULONGLONG)a2.QuadPart;   }    \
                                                                                                                            \
    inline BOOL operator op (const ULARGE_INTEGER& a1,  LONGLONG a2)           { return a1.QuadPart  op  (ULONGLONG)a2; }   \
    inline BOOL operator op (const ULARGE_INTEGER& a1, ULONGLONG a2)           { return a1.QuadPart  op  a2;            }   \
    inline BOOL operator op ( LONGLONG a1, const ULARGE_INTEGER& a2)           { return (ULONGLONG)a1  op  a2.QuadPart; }   \
    inline BOOL operator op (ULONGLONG a1, const ULARGE_INTEGER& a2)           { return a1  op  a2.QuadPart;            }   \
                                                                                                                            \
    inline BOOL operator op (const LARGE_INTEGER& a1,      LONG a2)           { return a1.QuadPart op a2;               }   \
    inline BOOL operator op (const LARGE_INTEGER& a1,     ULONG a2)           { return a1.QuadPart op a2;               }   \
    inline BOOL operator op (     LONG a1, const LARGE_INTEGER& a2)           { return a1 op a2.QuadPart;               }   \
    inline BOOL operator op (    ULONG a1, const LARGE_INTEGER& a2)           { return a1 op  a2.QuadPart;              }   \
                                                                                                                            \
    inline BOOL operator op (const ULARGE_INTEGER& a1,      LONG a2)           { return a1.QuadPart  op  a2;            }   \
    inline BOOL operator op (const ULARGE_INTEGER& a1,     ULONG a2)           { return a1.QuadPart  op  a2;            }   \
    inline BOOL operator op (     LONG a1, const ULARGE_INTEGER& a2)           { return a1  op  a2.QuadPart;            }   \
    inline BOOL operator op (    ULONG a1, const ULARGE_INTEGER& a2)           { return a1  op  a2.QuadPart;            }   \


DEFINE_LARGE_BOOLEAN(==)
DEFINE_LARGE_BOOLEAN(!=)
DEFINE_LARGE_BOOLEAN(>)
DEFINE_LARGE_BOOLEAN(>=)
DEFINE_LARGE_BOOLEAN(<)
DEFINE_LARGE_BOOLEAN(<=)


/////////////////////////////////////////////////////////////
//
// Reasonable arithmetic on FILETIMEs
//
/////////////////////////////////////////////////////////////

inline ULONGLONG& Int(FILETIME& ft)
    {
    return *(ULONGLONG*)&ft;
    }
inline const ULONGLONG& Int(const FILETIME& ft)
    {
    return *(const ULONGLONG*)&ft;
    }


#define DEFINE_FILETIME_ARITHMETIC(op)                                              \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, const FILETIME& a2)                \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  Int(a2);                                                  \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, LONGLONG a2)                       \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, LONG a2)                           \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, ULONGLONG a2)                      \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, ULONG a2)                          \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (LONGLONG a1, const FILETIME& a2)                       \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (LONG a1, const FILETIME& a2)                           \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (ULONGLONG a1, const FILETIME& a2)                      \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (ULONG a1, const FILETIME& a2)                          \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }


DEFINE_FILETIME_ARITHMETIC(+)
DEFINE_FILETIME_ARITHMETIC(-)
DEFINE_FILETIME_ARITHMETIC(*)
DEFINE_FILETIME_ARITHMETIC(/)

#define DEFINE_FILETIME_BOOLEAN(op)                                                                                 \
                                                                                                                    \
    inline BOOL operator op (const  FILETIME& a1, const  FILETIME& a2)   { return Int(a1) op Int(a2);   }           \
                                                                                                                    \
    inline BOOL operator op (const FILETIME& a1,  LONGLONG a2)           { return (LONGLONG)Int(a1) op a2;    }     \
    inline BOOL operator op (const FILETIME& a1, ULONGLONG a2)           { return Int(a1) op a2;              }     \
    inline BOOL operator op ( LONGLONG a1, const FILETIME& a2)           { return a1 op (LONGLONG)Int(a2);    }     \
    inline BOOL operator op (ULONGLONG a1, const FILETIME& a2)           { return a1 op Int(a2);              }     \
                                                                                                                    \
    inline BOOL operator op (const FILETIME& a1,      LONG a2)           { return Int(a1) op a2;               }    \
    inline BOOL operator op (const FILETIME& a1,     ULONG a2)           { return Int(a1) op a2;               }    \
    inline BOOL operator op (     LONG a1, const FILETIME& a2)           { return a1 op Int(a2);               }    \
    inline BOOL operator op (    ULONG a1, const FILETIME& a2)           { return a1 op Int(a2);               }


DEFINE_FILETIME_BOOLEAN(==)
DEFINE_FILETIME_BOOLEAN(!=)
DEFINE_FILETIME_BOOLEAN(>)
DEFINE_FILETIME_BOOLEAN(>=)
DEFINE_FILETIME_BOOLEAN(<)
DEFINE_FILETIME_BOOLEAN(<=)


/////////////////////////////////////////////////////////////
//
// Some security related utilities
//
/////////////////////////////////////////////////////////////

inline BOOL IsSelfRelativeSecurityDescriptor(PVOID psd)
// Find out if this is a self relative SD or not.
//
// REVIEW: We have to resort to using internal implementation details to get this
//
    {
    PISECURITY_DESCRIPTOR pinternal = (PISECURITY_DESCRIPTOR)psd;
    return pinternal->Control & SE_SELF_RELATIVE;
    }

#ifndef KERNELMODE

inline PSECURITY_DESCRIPTOR ToSelfRelative(PSECURITY_DESCRIPTOR psdOld)
// Return a newly allocated security descriptor which is guaranteed to be self-relative.
// My oh my it's yucky trying to write this code. Sigh.
//
    {
    ASSERT(IsValidSecurityDescriptor(psdOld));

    ULONG cbNeeded = GetSecurityDescriptorLength(psdOld);
    PSECURITY_DESCRIPTOR psdNew = (PSECURITY_DESCRIPTOR)AllocateMemory(cbNeeded);
    if (psdNew)
        {
        if (MakeSelfRelativeSD(psdOld, psdNew, &cbNeeded))
            {
            }
        else if (GetLastError() == ERROR_BAD_DESCRIPTOR_FORMAT)
            {
            memcpy(psdNew, psdOld, cbNeeded);
            }
        else
            {
            FreeMemory(psdNew);
            psdNew = NULL;
            }
        }

    if (psdNew)
        {
        ASSERT(IsSelfRelativeSecurityDescriptor(psdNew));
        }

    return psdNew;
    }

#endif

/////////////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\txfdebug.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfdebug.h
//
// Suite of ASSERT macros usable from either kernel and / or user mode.
//
#ifndef __TXFDEBUG_H__
#define __TXFDEBUG_H__


/////////////////////////////////////////////////////////////////////////////
//
// In the x86 version, we in-line the int3 so that when you hit it the debugger
// stays in source mode instead of anoyingly switching to disassembly mode, which
// you then immediately always want to switch out of
//
#if defined(KERNELMODE)
    #if defined(_X86_)
        #define DbgBreakPoint() { __asm int 3 }
    #endif
    #define BREAKPOINT()        DbgBreakPoint()
    #define ASSERT_BREAK        { if (KdDebuggerEnabled) { BREAKPOINT(); } }
#else
    #ifdef _X86_
        #define DebugBreak()    {  __asm int 3 }
    #endif
    #define BREAKPOINT()        DebugBreak()
    #define ASSERT_BREAK        BREAKPOINT()
    extern "C" ULONG _cdecl DbgPrint(PCH szFormat, ...);
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

    #undef ASSERT
    #undef ASSERTMSG
    #undef VERIFY
    
    #define ASSERT(exp)                                                             \
        {                                                                           \
        if (!(exp))                                                                 \
            {                                                                       \
            DbgPrint( "Assertion failed: %s:%d %s\n",__FILE__,__LINE__,#exp );      \
            ASSERT_BREAK;                                                           \
            }                                                                       \
        }                                                           
    
    #define ASSERTMSG(msg,exp)                                                          \
        {                                                                               \
        if (!(exp))                                                                     \
            {                                                                           \
            DbgPrint( "Assertion failed: %s:%d %s %s\n",__FILE__,__LINE__,msg,#exp );   \
            ASSERT_BREAK;                                                               \
            }                                                                           \
        }

    #define VERIFY(exp)         ASSERT(exp)
    #define NYI()               ASSERTMSG("not yet implemented", FALSE)
    #define FATAL_ERROR()       ASSERTMSG("a fatal error has occurred", FALSE)
    #define	NOTREACHED()		ASSERTMSG("this should not be reached", FALSE)

    #undef  DEBUG
    #define DEBUG(x)            x
    #define PRECONDITION(x)     ASSERT(x)
    #define POSTCONDITION(x)    ASSERT(x)

/////////////////////////////////////////////////////////////////////////////

#else

    #undef ASSERTMSG
    #undef ASSERT
    #undef VERIFY

    #define ASSERTMSG(msg,exp)
    #define ASSERT(x)

    #define VERIFY(exp)         (exp)
    #define NYI()               BREAKPOINT()
    #define FATAL_ERROR()       BREAKPOINT()        // REVIEW - fix  ?? STATUS_FAIL_CHECK ?? RPC_NT_INTERNAL_ERROR ?? STATUS_INTERNAL_ERROR
    #define NOTREACHED()                            // REVIEW: should this instead be FATAL_ERROR?

    #undef  DEBUG
    #define DEBUG(x)
    #define PRECONDITION(x)
    #define POSTCONDITION(x)

#endif

/////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
//
// A wrapper for HRESULTs that will detect error assignments thereto
// Use sparingly!
//
///////////////////////////////////////////////////////////////////

#if defined(_DEBUG) && defined(TRAP_HRESULT_ERRORS)

    struct HRESULT_
        {
        HRESULT m_hr;

        void V()               { ASSERT(SUCCEEDED(m_hr)); }

        HRESULT_(HRESULT   hr) { m_hr = hr;      V(); }
        HRESULT_(HRESULT_& hr) { m_hr = hr.m_hr; V(); }

        HRESULT_& operator =(HRESULT   hr) { m_hr = hr;      V(); return *this;}
        HRESULT_& operator =(HRESULT_& hr) { m_hr = hr.m_hr; V(); return *this;}

        operator HRESULT()     { return m_hr; }
        };

#else

    typedef HRESULT HRESULT_;

#endif

///////////////////////////////////////////////////////////////////
//
// Some tracing utilities
//
///////////////////////////////////////////////////////////////////

void __cdecl Print  (PCSZ szFormat, ...);
void         PrintVa(PCSZ szFormat, va_list va);

#define __TRACE_OTHER   (0x80000000) 
#define __TRACE_ANY     (0xFFFFFFFF)

#ifdef _DEBUG

    extern void     TracingIndentIncrement();
    extern void     TracingIndentDecrement();
    extern ULONG    GetTracingIndent();
    extern ULONG    GetTracing();

    void __stdcall _DebugTrace(PCSZ szModule, ULONG tracingIndent, PCSZ szFormat, va_list va);

    inline void __cdecl DebugTrace(ULONG traceCat, PCSZ szModule, PCSZ szFormat, ...)
        {
        va_list va;
        va_start(va, szFormat);

        if (GetTracing() & traceCat)
            {
            _DebugTrace(szModule, GetTracingIndent(), szFormat, va);
            }

        va_end(va);
        }

    struct __FUNCTION_TRACER
        {
        PCSZ    _file;     // file name
        long    _line;     // line number in file
        PCSZ    _fn;       // function name (optional)
        ULONG   _traceCat; // category of tracing
        BOOL    _fTraced;
        PCSZ    _traceTag;

        __FUNCTION_TRACER(PCSZ file, long line, PCSZ fn, ULONG traceCategory, PCSZ szTraceTag, ...)
            {
            _file = file;
            while(*file)    // find the end of the file name
                {
                if (*file == '\\')
                    _file = file+1;
                file++;
                }
            _line     = line;
            _fn       = fn;
            _traceCat = traceCategory;
            _traceTag = szTraceTag ? szTraceTag : "";
            }

        void Enter()
            {
            _fTraced = _traceCat & GetTracing();
            if (_fTraced)
                {
                if (_fn[0] != '\0')
                    DebugTrace(_traceCat, _traceTag, "%s(%d:%s)", _file, _line, _fn);
                else
                    DebugTrace(_traceCat, _traceTag, "%s(%d)", _file, _line);

                TracingIndentIncrement();
                }
            }

        void Exit()
            {
            if (_fTraced)
                {
                TracingIndentDecrement();
                DebugTrace(_traceCat, _traceTag, "|(%d)", _line);
                }
            }

        };

#else // else !debug

    inline void __cdecl DebugTrace(ULONG traceCat, PCSZ szModule, PCSZ szFormat, ...)
        {
        /* do nothing */
        }

#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\threadpool.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// threadpool.h
//
// Interface to the worker-thread-pool functionality in the
// txf support library.
//
// This is a C++-only header file

///////////////////////////////////////////////////////////////
//
// The core functionality on which this thread pool is based, the
// NT kernel mode thread pools, have their headers etc defined in
// viper\inc\ntos\ex.h. If you are using both that header and this 
// one here, you must include the former first, then this one. If
// you're only using this one, then we snarf copies of just the stuff
// you need to get this thread pool going
//
// LIST_ENTRY is defined either in ntdef.h or winnt.h, depending
// on what other headers you've included.
//
///////////////////////////////////////////////////////////////

#ifndef _EX_

    typedef enum _WORK_QUEUE_TYPE {
        CriticalWorkQueue,
        DelayedWorkQueue,
        HyperCriticalWorkQueue,
        MaximumWorkQueue
    } WORK_QUEUE_TYPE;

    typedef
    void 
    (__stdcall* PWORKER_THREAD_ROUTINE)(
        void* Parameter
        );

    typedef struct _WORK_QUEUE_ITEM {
        LIST_ENTRY List;
        PWORKER_THREAD_ROUTINE WorkerRoutine;
        void* Parameter;
    } WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

#endif

///////////////////////////////////////////////////////////////
//
// WorkerQueueItem 
//
// An item to be placed a the worker queue
//
///////////////////////////////////////////////////////////////

class WorkerQueueItem : public WORK_QUEUE_ITEM
    {
public:
    typedef void (__stdcall*PFN)(void*);

    WorkerQueueItem(PFN pfn, void* pvContext)
        {
        WorkerRoutine = pfn;
        Parameter     = pvContext;
        List.Flink    = NULL;
        }

    WorkerQueueItem(PFN pfn = NULL)
        {
        WorkerRoutine = pfn;
        Parameter     = this;
        List.Flink    = NULL;
        }

    #ifdef KERNELMODE

        void QueueTo(WORK_QUEUE_TYPE queue)
            {
            ExQueueWorkItem(this, queue);
            }

    #else

        void QueueTo(WORK_QUEUE_TYPE queue);

    #endif
    };

///////////////////////////////////////////////////////////////
//
// Helper for type-casting member functions to WorkerQueueItem::PFN's.
// Member function should be a void __stdcall MemberFunction(void).
//
///////////////////////////////////////////////////////////////

template <class T>
WorkerQueueItem::PFN AsWorkerFunction(void (__stdcall T::*pmfn)())
    {
    union {
        void (__stdcall T::*pmfn)();
        WorkerQueueItem::PFN pfn;
        } u;
    u.pmfn = pmfn;
    return u.pfn;
    }



///////////////////////////////////////////////////////////////
//
// AutoDeleteWorker
//
// Worker items that inherit from this get automaticially 
// deleted after they execute
//
///////////////////////////////////////////////////////////////

#pragma warning(disable : 4355) // 'this' : used in base member initializer list

class AutoDeleteWorker: public WorkerQueueItem
    {
    WorkerQueueItem::PFN  m_pfn;
    void*                 m_pvContext;

public:
    AutoDeleteWorker(WorkerQueueItem::PFN pfn=NULL, void* pvContext=NULL)
            : WorkerQueueItem(AutoDeleteWorker::DoWork, this)
        {
        m_pfn = pfn;
        m_pvContext = pvContext;
        }

    template <class T>
    AutoDeleteWorker(void (__stdcall T::*pmfn)(), T* pt)
            : WorkerQueueItem(AutoDeleteWorker::DoWork, this)
        {
        m_pfn = AsWorkerFunction(pmfn);
        m_pvContext = pt;
        }

private:

    void OnDoWork()
        {
        if (m_pfn)
            {
            m_pfn(m_pvContext);
            }
        }

    static void DoWork(void* pvContext)
        {
        AutoDeleteWorker* This = (AutoDeleteWorker*)pvContext;
        This->OnDoWork();
        delete This;
        }

    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\svcmsg.h ===
/*
 COM+ 1.0
 Copyright (c) 1996 Microsoft Corporation

 This file contains the message definitions for MS Transaction Server
-------------------------------------------------------------------------
 HEADER SECTION

 The header section defines names and language identifiers for use
 by the message definitions later in this file. The MessageIdTypedef,
 SeverityNames, FacilityNames, and LanguageNames keywords are
 optional and not required.



 The MessageIdTypedef keyword gives a typedef name that is used in a
 type cast for each message code in the generated include file. Each
 message code appears in the include file with the format: #define
 name ((type) 0xnnnnnnnn) The default value for type is empty, and no
 type cast is generated. It is the programmer's responsibility to
 specify a typedef statement in the application source code to define
 the type. The type used in the typedef must be large enough to
 accommodate the entire 32-bit message code.



 The SeverityNames keyword defines the set of names that are allowed
 as the value of the Severity keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 severity name is a number that, when shifted left by 30, gives the
 bit pattern to logical-OR with the Facility value and MessageId
 value to form the full 32-bit message code. The default value of
 this keyword is:

 SeverityNames=(
   Success=0x0
   Informational=0x1
   Warning=0x2
   Error=0x3
   )

 Severity values occupy the high two bits of a 32-bit message code.
 Any severity value that does not fit in two bits is an error. The
 severity codes can be given symbolic names by following each value
 with :name

 The FacilityNames keyword defines the set of names that are allowed
 as the value of the Facility keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 facility name is a number that, when shifted left by 16 bits, gives
 the bit pattern to logical-OR with the Severity value and MessageId
 value to form the full 32-bit message code. The default value of
 this keyword is:

 FacilityNames=(
   System=0x0FF
   Application=0xFFF
  )

 Facility codes occupy the low order 12 bits of the high order
 16-bits of a 32-bit message code. Any facility code that does not
 fit in 12 bits is an error. This allows for 4,096 facility codes.
 The first 256 codes are reserved for use by the system software. The
 facility codes can be given symbolic names by following each value
 with :name

 The 1033 comes from the result of the MAKELANGID() macro
 (SUBLANG_ENGLISH_US << 10) | (LANG_ENGLISH)

 The LanguageNames keyword defines the set of names that are allowed
 as the value of the Language keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 language name is a number and a file name that are used to name the
 generated resource file that contains the messages for that
 language. The number corresponds to the language identifier to use
 in the resource table. The number is separated from the file name
 with a colon. The initial value of LanguageNames is:

 LanguageNames=(English=1:MSG00001)

 Any new names in the source file that don't override the built-in
 names are added to the list of valid languages. This allows an
 application to support private languages with descriptive names.


-------------------------------------------------------------------------
 MESSAGE DEFINITION SECTION

 Following the header section is the body of the Message Compiler
 source file. The body consists of zero or more message definitions.
 Each message definition begins with one or more of the following
 statements:

 MessageId = [number|+number]
 Severity = severity_name
 Facility = facility_name
 SymbolicName = name

 The MessageId statement marks the beginning of the message
 definition. A MessageID statement is required for each message,
 although the value is optional. If no value is specified, the value
 used is the previous value for the facility plus one. If the value
 is specified as +number, then the value used is the previous value
 for the facility plus the number after the plus sign. Otherwise, if
 a numeric value is given, that value is used. Any MessageId value
 that does not fit in 16 bits is an error.

 The Severity and Facility statements are optional. These statements
 specify additional bits to OR into the final 32-bit message code. If
 not specified, they default to the value last specified for a message
 definition. The initial values prior to processing the first message
 definition are:

 Severity=Success
 Facility=Application

 The value associated with Severity and Facility must match one of
 the names given in the FacilityNames and SeverityNames statements in
 the header section. The SymbolicName statement allows you to
 associate a C/C++ symbolic constant with the final 32-bit message
 code.

*/
/* IMPORTANT - PLEASE READ BEFORE EDITING FILE
  This file is divided into four sections. They are:
	1. Success Codes
	2. Information Codes
	3. Warning Codes
	4. Error Codes

  Please enter your codes in the appropriate section.
  All codes must be in sorted order.  Please use codes
  in the middle that are free before using codes at the end.
  The success codes (Categories) must be consecutive i.e. with no gaps.
  The category names cannot be longer than 22 chars.
*/
/******************************* Success Codes ***************************************/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_STUBS                   0x3
#define FACILITY_RUNTIME                 0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ID_CAT_UNKNOWN
//
// MessageText:
//
//  SVC%0
//
#define ID_CAT_UNKNOWN                   ((DWORD)0x00000001L)

//
// MessageId: ID_CAT_ASP
//
// MessageText:
//
//  Executive%0
//
#define ID_CAT_ASP                       ((DWORD)0x00000002L)

//
// MessageId: ID_CAT_CAT
//
// MessageText:
//
//  Catalog%0
//
#define ID_CAT_CAT                       ((DWORD)0x00000003L)

//
// MessageId: ID_CAT_SPM
//
// MessageText:
//
//  SPM%0
//
#define ID_CAT_SPM                       ((DWORD)0x00000004L)

//
// MessageId: ID_CAT_QCRECORDER
//
// MessageText:
//
//  QC Recorder%0
//
#define ID_CAT_QCRECORDER                ((DWORD)0x00000005L)

//
// MessageId: ID_CAT_QCINTEGRATOR
//
// MessageText:
//
//  QC ListenerHelper%0
//
#define ID_CAT_QCINTEGRATOR              ((DWORD)0x00000006L)

//
// MessageId: ID_CAT_QCPLAYER
//
// MessageText:
//
//  QC Player%0
//
#define ID_CAT_QCPLAYER                  ((DWORD)0x00000007L)

//
// MessageId: ID_CAT_QCLISTENER
//
// MessageText:
//
//  QC Listener%0
//
#define ID_CAT_QCLISTENER                ((DWORD)0x00000008L)

//
// MessageId: ID_CAT_CRM
//
// MessageText:
//
//  CRM%0
//
#define ID_CAT_CRM                       ((DWORD)0x00000009L)

//
// MessageId: ID_CAT_SECURITY
//
// MessageText:
//
//  Security%0
//
#define ID_CAT_SECURITY                  ((DWORD)0x0000000AL)

//
// MessageId: ID_CAT_ACTIVATION
//
// MessageText:
//
//  Activation%0
//
#define ID_CAT_ACTIVATION                ((DWORD)0x0000000BL)

//
// MessageId: ID_CAT_BYOT
//
// MessageText:
//
//  BYOT%0
//
#define ID_CAT_BYOT                      ((DWORD)0x0000000CL)

//
// MessageId: ID_CAT_QCADMIN
//
// MessageText:
//
//  QC Queue Admin%0
//
#define ID_CAT_QCADMIN                   ((DWORD)0x0000000DL)

//
// MessageId: ID_CAT_QCMONIKER
//
// MessageText:
//
//  Queue Moniker%0
//
#define ID_CAT_QCMONIKER                 ((DWORD)0x0000000EL)

//
// MessageId: ID_CAT_MTSTOCOM
//
// MessageText:
//
//  MTS 2.0 Migration%0
//
#define ID_CAT_MTSTOCOM                  ((DWORD)0x0000000FL)

//
// MessageId: ID_CAT_EXTERNAL
//
// MessageText:
//
//  External%0
//
#define ID_CAT_EXTERNAL                  ((DWORD)0x00000010L)

//
// MessageId: ID_CAT_EVENTS
//
// MessageText:
//
//  Events%0
//
#define ID_CAT_EVENTS                    ((DWORD)0x00000011L)

//
// MessageId: ID_CAT_QCMARSHALINTERCEPTOR
//
// MessageText:
//
//  QC Marshal%0
//
#define ID_CAT_QCMARSHALINTERCEPTOR      ((DWORD)0x00000012L)

//
// MessageId: ID_CAT_QCMSMQRT
//
// MessageText:
//
//  QC MSMQ Runtime%0
//
#define ID_CAT_QCMSMQRT                  ((DWORD)0x00000013L)

//
// MessageId: ID_CAT_NEW_MONIKER
//
// MessageText:
//
//  New Moniker%0
//
#define ID_CAT_NEW_MONIKER               ((DWORD)0x00000014L)

 /*
 ID_CAT_COM_LAST defines a constant specifying how many categories
 there are in the COM+ event logging client
 ID_CAT_COM_LAST must remain the last category.  To add new categories
 simply add the category above.  Give it the message id of the
 last category (ID_CAT_COM_LAST) and increment the id of ID_CAT_COM_LAST
 Note: ID_CAT_COM_LAST must always be one greater than the last outputable
 category
 */
//
// MessageId: ID_CAT_COM_LAST
//
// MessageText:
//
//  <>%0
//
#define ID_CAT_COM_LAST                  ((DWORD)0x00000015L)

/************************************ Information Codes ***************************************/
//MessageId=0x1001
//Severity=Informational
//Facility=Runtime
//SymbolicName=IDS_COMSVCS_STARTUP
//Language=English
//COM+ has started.%0
//.
//MessageId=0x1002
//Severity=Informational
//Facility=Runtime
//SymbolicName=ID_REF_COUNT
//Language=English
//Unexpected object reference count. The object still had references after the run-time environment released its last reference. %1%0
//.
//
// MessageId: IDS_I_CRM_NEW_LOG_FILE_NO_SECURITY
//
// MessageText:
//
//  A new CRM log file was created. This CRM log file is not secure because the application Identity is Interactive User or the file system is not NTFS. %1%0
//
#define IDS_I_CRM_NEW_LOG_FILE_NO_SECURITY ((DWORD)0x40021003L)

//
// MessageId: IDS_I_CRM_NEW_LOG_FILE_WITH_SECURITY
//
// MessageText:
//
//  A new CRM log file was created. This CRM log file is secure. %1%0
//
#define IDS_I_CRM_NEW_LOG_FILE_WITH_SECURITY ((DWORD)0x40021004L)

//
// MessageId: IDS_I_CRM_NEW_SYSTEM_APP_LOG_FILE
//
// MessageText:
//
//  A new CRM log file was created for the System Application.%0
//
#define IDS_I_CRM_NEW_SYSTEM_APP_LOG_FILE ((DWORD)0x40021005L)

//
// MessageId: IDS_I_MTSTOCOM_LAUNCH_STARTED
//
// MessageText:
//
//  The mtstocom launching routine has started.%1%0
//
#define IDS_I_MTSTOCOM_LAUNCH_STARTED    ((DWORD)0x40001006L)

//
// MessageId: IDS_I_MTSTOCOM_LAUNCH_FINISHED
//
// MessageText:
//
//  The mtstocom launching routine has completed.%1%0
//
#define IDS_I_MTSTOCOM_LAUNCH_FINISHED   ((DWORD)0x40001007L)

//
// MessageId: IDS_MTSTOCOM_MIGRATION_POPULATE_FAILED
//
// MessageText:
//
//  The MTSTOCOM migration utility is attempting to retry populating the packages collection because it failed it's first attempt.%1%0
//
#define IDS_MTSTOCOM_MIGRATION_POPULATE_FAILED ((DWORD)0x40001008L)

/************************************ Warning Codes ***************************************/
//
// MessageId: IDS_COMSVCS_APPLICATION_ERROR
//
// MessageText:
//
//  An error occurred in your COM+ component.  %1%0
//
#define IDS_COMSVCS_APPLICATION_ERROR    ((DWORD)0x80001001L)

//
// MessageId: IDS_COMSVCS_CALL_ACCESS_DENIED
//
// MessageText:
//
//  A method call to an object in a COM+ application was rejected because the caller is not properly authorized to make this call. The COM+ application is configured to use Application and Component level access checks, and enforcement of these checks is currently enabled. The remainder of this message provides information about the component method that the caller attempted to invoke and the identity of the caller.%1%0
//
#define IDS_COMSVCS_CALL_ACCESS_DENIED   ((DWORD)0x80001002L)

//
// MessageId: IDS_COMSVCS_CALL_ACCESS_DENIED_X
//
// MessageText:
//
//  A method call to an object in a COM+ application was rejected because the caller is not properly authorized to make this call. The COM+ application is configured to use Application and Component level access checks, and enforcement of these checks is currently enabled. Information about the component method that the caller attempted to invoke and about the identity of the caller could not be obtained, probably due to low memory conditions on this computer.%0
//
#define IDS_COMSVCS_CALL_ACCESS_DENIED_X ((DWORD)0x80001003L)

//MessageId=0x1004
//Severity=Warning
//Facility=Runtime
//SymbolicName=ID_MISSING_CAUSALITY_ID
//Language=English
//DCOM was unable to provide a logical thread ID. Entering activity without acquiring a lock. %0
//.
//MessageId=0x1005
//Severity=Warning
//Facility=Runtime
//SymbolicName=ID_DUPLICATE_LAUNCH
//Language=English
//An attempt was made to launch a server process for a package that was already actively supported by another server process on this computer. %1%0
//.
//MessageId=0x1006
//Severity=Warning
//Facility=Runtime
//SymbolicName=ID_BACK_LEVEL_MSDTC
//Language=English
////The version of MS DTC installed on this machine is incompatible with COM+.  Please re-install MTS to upgrade to a compatible version of MS DTC. %1%0
//.
//MessageId=0x1007
//Severity=Warning
//Facility=Runtime
//SymbolicName=ID_IMPERSONATION_ERROR
//Language=English
//The run-time environment was unable to obtain the identity of the caller. An access error may be returned to the caller.  %1%0
//.
//
// MessageId: IDS_W_CRM_DIFFERENT_MACHINE
//
// MessageText:
//
//  The CRM log file was originally created on a computer with a different name. It has been updated with the name of the current computer. If this warning appears when the computer name has been changed then no further action is required. %1%0
//
#define IDS_W_CRM_DIFFERENT_MACHINE      ((DWORD)0x80021008L)

//
// MessageId: IDS_W_CRM_DIFFERENT_APPID
//
// MessageText:
//
//  The CRM log file was originally created with a different application ID. It has been updated with the current application ID. If this warning appears when the CRM log file has been renamed then no further action is required. %1%0
//
#define IDS_W_CRM_DIFFERENT_APPID        ((DWORD)0x80021009L)

//
// MessageId: IDS_W_CRM_NO_LOGINFO
//
// MessageText:
//
//  A log information record was not found in the existing CRM log file. It has been added. If this warning appears when the CRM log file is being initially created then no further action is required. %1%0
//
#define IDS_W_CRM_NO_LOGINFO             ((DWORD)0x8002100AL)

//
// MessageId: IDS_W_CRM_UNEXPECTED_METHOD_CALL
//
// MessageText:
//
//  An unexpected method call was received. It has been safely ignored. Method Name: %1%0
//
#define IDS_W_CRM_UNEXPECTED_METHOD_CALL ((DWORD)0x8002100BL)

//
// MessageId: IDS_W_CRM_INIT_ZERO_BYTE_LOG_FILE
//
// MessageText:
//
//  An empty CRM log file was detected. It has been re-initialized. If this warning appears when the CRM log file is being initially created then no further action is required. %1%0
//
#define IDS_W_CRM_INIT_ZERO_BYTE_LOG_FILE ((DWORD)0x8002100CL)

//
// MessageId: IDS_W_CRM_INIT_EXISTING_LOG_FILE
//
// MessageText:
//
//  An incompletely initialized CRM log file was detected. It has been re-initialized. If this warning appears when the CRM log file is being initially created then no further action is required. %1%0
//
#define IDS_W_CRM_INIT_EXISTING_LOG_FILE ((DWORD)0x8002100DL)

//
// MessageId: IDS_W_CRM_NOT_STARTED
//
// MessageText:
//
//  The application attempted to use the CRM but the CRM is not enabled for this application. You can correct this problem using the Component Services administrative tool. Display the Properties for your application. Select the Advanced tab and check Enable Compensating Resource Managers. The CRM can only be enabled for server applications. %1%0
//
#define IDS_W_CRM_NOT_STARTED            ((DWORD)0x8002100EL)

//
// MessageId: IDS_W_CRM_CLERKS_REMAIN_AFTER_RECOVERY
//
// MessageText:
//
//  Some transactions could not be completed because they are in-doubt. The CRM will attempt to complete them on its next recovery. %1%0
//
#define IDS_W_CRM_CLERKS_REMAIN_AFTER_RECOVERY ((DWORD)0x80021010L)

//
// MessageId: IDS_W_CRM_EXCEPTION_IN_DELIVER_NOTIFICATIONS
//
// MessageText:
//
//  The system has called the CRM Compensator custom component and that component has failed and generated an exception. This indicates a problem with the CRM Compensator component. Notify the developer of the CRM Compensator component that this failure has occurred. The system will continue because the IgnoreCompensatorErrors registry flag is set, but correct compensation might not have occurred. %1%0
//
#define IDS_W_CRM_EXCEPTION_IN_DELIVER_NOTIFICATIONS ((DWORD)0x80021011L)

//
// MessageId: IDS_W_CRM_ERROR_IN_DELIVER_NOTIFICATIONS
//
// MessageText:
//
//  The system has called the CRM Compensator custom component and that component has returned an error. This indicates a problem with the CRM Compensator component. Notify the developer of the CRM Compensator component that this failure has occurred. The system will continue because the IgnoreCompensatorErrors registry flag is set, but correct compensation might not have occurred. %1%0
//
#define IDS_W_CRM_ERROR_IN_DELIVER_NOTIFICATIONS ((DWORD)0x80021012L)

//
// MessageId: IDS_W_CRM_LOW_DISK_SPACE
//
// MessageText:
//
//  The CRM log file for this application is located on a disk which is short of space. This may cause failures of this application. Please increase the space available on this disk. The CRM log file name is shown below.%1%0
//
#define IDS_W_CRM_LOW_DISK_SPACE         ((DWORD)0x80021013L)

//
// MessageId: IDS_MTSTOCOM_MIGRATION_ERRORS
//
// MessageText:
//
//  Failures reported during migration of MTS packages and program settings to COM+ applications and program settings. See the mtstocom.log file in the windows directory for more information.%1%0
//
#define IDS_MTSTOCOM_MIGRATION_ERRORS    ((DWORD)0x80001014L)

//
// MessageId: IDS_W_CRM_NO_TRANSACTION
//
// MessageText:
//
//  CRM Worker custom components require a transaction. You can correct this problem using the Component Services administrative tool. Display the Properties for your CRM Worker component. Select the Transactions tab. Select the Transaction support Required option button.%1%0
//
#define IDS_W_CRM_NO_TRANSACTION         ((DWORD)0x80021015L)

//
// MessageId: IDS_W_EVENT_FAILED_QI
//
// MessageText:
//
//  Event class failed Query Interface. Please check the event log for any other errors from the EventSystem.%1%0
//
#define IDS_W_EVENT_FAILED_QI            ((DWORD)0x80021016L)

//
// MessageId: IDS_W_EVENT_FAILED_CREATE
//
// MessageText:
//
//  Failed to create event class. Please check the event log for any other errors from the EventSystem.%1%0
//
#define IDS_W_EVENT_FAILED_CREATE        ((DWORD)0x80021017L)

//
// MessageId: IDS_W_EVENT_FAILED
//
// MessageText:
//
//  Event failed. Please check the event log for any other errors from the EventSystem.%1%0
//
#define IDS_W_EVENT_FAILED               ((DWORD)0x80021018L)

/************************************ Error Codes ***************************************/
//
// MessageId: IDS_E_COMSVCS_INTERNAL_ERROR
//
// MessageText:
//
//  The run-time environment has detected an inconsistency in its internal state. Please contact Microsoft Product Support Services to report this error.  %1%0
//
#define IDS_E_COMSVCS_INTERNAL_ERROR     ((DWORD)0xC0021001L)

//
// MessageId: IDS_COMSVCS_RESOURCE_ERROR
//
// MessageText:
//
//  The run-time environment has detected the absence of a critical resource and has caused the process that hosted it to terminate.  %1%0
//
#define IDS_COMSVCS_RESOURCE_ERROR       ((DWORD)0xC0021002L)

//
// MessageId: ID_INITIALIZE_FOR_DTC
//
// MessageText:
//
//  The run-time environment was unable to initialize for transactions required to support transactional components. Make sure that MS DTC is running.%1%0
//
#define ID_INITIALIZE_FOR_DTC            ((DWORD)0xC0021003L)

//MessageId=0x1004
//Severity=Error
//Facility=Runtime
//SymbolicName=IDS_COMSVCS_REGISTRY_ERROR
//Language=English
//An attempt to access the registry failed. You might not have the necessary permissions, or the registry is corrupted.  %1%0
//.
//MessageId=0x1005
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INTERFACE_TOO_LARGE
//Language=English
//The interface is too large. The limit on the number of methods for this interface has been exceeded.  %1%0
//.
//MessageId=0x1006
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_ASPRM_INIT_FAILED
//Language=English
//Failed to initialize AspExec RESOURCE MANAGER.  %1%0
//.
//MessageId=0x1007
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NOTISH
//Language=English
//COM+ does not support this interface because it is a custom interface built with MIDL and has not been linked with the type info helper library.  %1%0
//.
//MessageId=0x1008
//Severity=Error
//Facility=Runtime
//SymbolicName=CONTEXT_E_INSTANCE_EXCEPTION
//Language=English
//An object call caused an exception.  %1%0
//.
//
// MessageId: ID_E_NOPSFORIID
//
// MessageText:
//
//  Could not obtain a proxy/stub class factory for given interface. Proxy/stub is not registered correctly.  %1%0
//
#define ID_E_NOPSFORIID                  ((DWORD)0xC0021009L)

//
// MessageId: ID_E_CREATESTUBFORIID
//
// MessageText:
//
//  Failed to create a stub object for given interface.  %1%0
//
#define ID_E_CREATESTUBFORIID            ((DWORD)0xC002100AL)

//MessageId=0x100B
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_IIDNOTINREG
//Language=English
//No registry entry exists for given interface.  %1%0
//.
//MessageId=0x100C
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NOTLBFORIID
//Language=English
//No type library registry entry exists for given interface.  %1%0
//.
//MessageId=0x100D
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NODLLFORIID
//Language=English
//Could not load the proxy/stub DLL for given interface. One possible cause is that the DLL does not exist.  %1%0
//.
//MessageId=0x100E
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_QIFAILONBIND
//Language=English
//QueryInterface failed during object activation due to an error in your component. This error caused the process to terminate. %1%0
//.
//MessageId=0x100F
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NOTLSALLOC
//Language=English
//Failed to allocate thread state.  %1%0
//.
//MessageId=0x1010
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NOTLSWRITE
//Language=English
//Failed to write thread state. A possible cause is that your system might be low in resources.  %1%0
//.
//MessageId=0x1011
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_QIFAILURE
//Language=English
//IUnknown::QueryInterface failed on given object.  %1%0
//.
//MessageId=0x1012
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_UNBIND
//Language=English
//Failed to unbind on given interface.  %1%0
//.
//MessageId=0x1013
//Severity=Error
//Facility=Runtime
//SymbolicName=E_INVALIDSTACKSIZE
//Language=English
//Invalid stack size for given method. A possible cause is that the method has parameters of data types not supported by COM+.  %1%0
//.
//MessageId=0x1014
//Severity=Error
//Facility=Runtime
//SymbolicName=E_NOSTACK
//Language=English
//Out of stack space for given method.  %1%0
//.
//MessageId=0x1015
//Severity=Error
//Facility=Runtime
//SymbolicName=E_CLEAROUT
//Language=English
//Failed to clear out parameters for given method. There was a failure before or after the call was made to this object. A possible cause is that this method has parameters of data types not supported by COM+.  %1%0
//.
//MessageId=0x1016
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDMETHODCALL
//Language=English
//Call to invalid method. A component is trying to call a method that does not exist on this interface.  %1%0
//.
//MessageId=0x1017
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_WALKINTERFACES
//Language=English
//Failed to walk given interface.  %1%0
//.
//MessageId=0x1018
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_LOADREGTLB
//Language=English
//The type library is registered, but could not be loaded.  %1%0
//.
//MessageId=0x1019
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NOTYPEINFO
//Language=English
//No type information for this interface exists in the associated type library. A possible cause is that the type library is corrupted or out of date.  %1%0
//.
//MessageId=0x101A
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDTLB
//Language=English
//Invalid type library for this interface. A possible cause is that the type library is corrupted. %1%0
//.
//MessageId=0x101B
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDFUNCTLB
//Language=English
//Invalid function description in the type library for this interface. A possible cause is that the type library is corrupted.  %1%0
//.
//MessageId=0x101C
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDPARAMTLB
//Language=English
//Invalid function parameter description in the type library for this interface. A possible cause is that the type library is corrupted.  %1%0
//.
//MessageId=0x101D
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDPARAMSIZE
//Language=English
//Invalid parameter size in the type library for this interface. Possible causes are that the type library is corrupted or that your interface has methods that use parameters with data types not supported by COM+. %1%0
//.
//MessageId=0x101E
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDTLBINREG
//Language=English
//Invalid type library registry value for this interface. A possible cause is that the registry is corrupted. %1%0
//.
//MessageId=0x101F
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_INVALIDPARAM
//Language=English
//A method on this interface has an unsupported data type.  %1%0
//.
//MessageId=0x1020
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_CFW_INVALIDSERVER
//Language=English
//The run-time environment was unable to load an application component due to either an error obtaining its properties from the catalog, loading the DLL, or getting the procedure address of DllGetClassObject. This error caused the process to terminate. %1%0
//.
//MessageId=0x1021
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_APPLICATION_EXCEPTION
//Language=English
//The run-time environment caught an exception during a call into your component. This error caused the process to terminate. %1%0
//.
//MessageId=0x1022
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_COM_ERROR
//Language=English
//An error occurred during a run-time environment call to a COM API. This error caused the process to terminate.  %1%0
//.
//MessageId=0x1023
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_LAUNCH_ERROR
//Language=English
//A server process failed during initialization. The most common cause is an invalid command line, which may indicate an inconsistent or corrupted catalog. This error caused the process to terminate. %1%0
//.
//
// MessageId: ID_E_REPL_BADMACHNAME
//
// MessageText:
//
//  Replication: Invalid machine name supplied for %1.%0
//
#define ID_E_REPL_BADMACHNAME            ((DWORD)0xC0021024L)

//MessageId=0x1025
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_NOTYPEINFORDISPATCH
//Language=English
//Interface is not supported by COM+. It does not have either a type library or a proxy stub. The object that implements it does not support IDispatch::GetTypeInfo, ITypeLib, or ITypeInfo: %1%0
//.
//MessageId=0x1026
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_CONTEXT_CREATEINSTANCE
//Language=English
//Failed on creation from object context: %1%0
//.
//MessageId=0x1027
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_CREATEINSTANCE
//Language=English
//Failed on creation within a server process. %1%0
//.
//MessageId=0x1028
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_CONTEXT_NOT_CURRENT
//Language=English
//An application used an object context that is not currently active.  %1%0
//.
//MessageId=0x1029
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_UUID_CREATE
//Language=English
//The run-time environment was unable to create a new UUID. %1%0
//.
//MessageId=0x102A
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_BEGINTRANSACTION
//Language=English
//An error occurred when starting a transaction for an object. References to that object and other related objects in its activity become obsolete.  %1%0
//.
//MessageId=0x102B
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_TRANSACTION_STREAM
//Language=English
//An error occurred when communicating with the root of a transaction. References to the associated objects become obsolete.  %1%0
//.
//MessageId=0x102C
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_TRANSACTION_IMPORT
//Language=English
//A call that required the transaction to be imported failed because an error occurred when the run-time environment attempted to import a transaction into the process. %1%0
//.
//MessageId=0x102D
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_TRANSACTION_EXPORT
//Language=English
//A call failed because of a transaction export error. %1%0
//.
//MessageId=0x102E
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_LICENSE_EXPIRED
//Language=English
//Your license to use COM+ has expired. %1%0
//.
//MessageId=0x102F
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_MIXED_THREADING
//Language=English
//An attempt was made to create an object that would have resulted in components with different threading models running in the same activity within the same process. %1%0
//.
//MessageId=0x1030
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_ACTIVITY_TIMEOUT
//Language=English
//A time-out occurred while waiting for a client's call to get exclusive access to an activity that was already in a call from another client. The call fails with CONTEXT_E_ACTIVITYTIMEOUT. %1%0
//.
//MessageId=0x1031
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_ACTIVATION
//Language=English
//A call failed due to an activation error returned by the component. %1%0
//.
//MessageId=0x1032
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_THREADINGMODEL
//Language=English
//Invalid component configuration. %1%0
//.
//MessageId=0x1033
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_TRANSACTIONSUPPORT
//Language=English
//Invalid component configuration. The transaction support for this component is invalid. %1%0
//.
//MessageId=0x1034
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_CONTEXT_RELEASE
//Language=English
//An object released more references to its object context than it had acquired. The extra release is ignored. %1%0
//.
//MessageId=0x1035
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_SPM_NOCONTEXT
//Language=English
//An attempt was made to access a SPM Property Group in LockMethod mode, by an object without JIT Activation, or by an object with a lock on another Property Group. %1%0
//.
//MessageId=0x1036
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_MIDLNOINTERPRET
//Language=English
//Unable to obtain extended information about this interface. The interface may not have been generated using the -Oicf options in MIDL or the interface has methods with types (float or double) that are not currently supported for custom interfaces. %1%0
//.
//MessageId=0x1037
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_EVALEXPIRED
//Language=English
//Your evaluation copy has expired. %1%0
//.
//MessageId=0x1038
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_REGPATHMISSING
//Language=English
//The following registry path was expected to exist but is missing: %1%0
//.
//MessageId=0x1039
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_DISPENSER_EXCEPTION
//Language=English
//An exception occurred within a Resource Dispenser: %1%0
//.
//MessageId=0x103A
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_LICENSE_SERVICE_FAILURE
//Language=English
//License Service failed or is unavailable, status code returned: %1%0
//.
//MessageId=0x103B
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_WRONG_SERVER_IDENTITY
//Language=English
//The package could not be started under the debugger because it is configured to run as a different identity. %1%0
//.
//MessageId=0x104E
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_INVALID_CREATE_OPTIONS_OBJECT
//Language=English
//An invalid create options object was passed to the CreateInstance call.%0
//.
//
// MessageId: ID_RECORDER_PS_CLSID_NOT_KNOWN
//
// MessageText:
//
//  The clsid of the proxy stub dll for the interface is not available, or failed to load the proxy stub dll, or failed to create a proxy.%0
//
#define ID_RECORDER_PS_CLSID_NOT_KNOWN   ((DWORD)0xC002104FL)

//MessageId=0x1050
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_RECORDER_PROXY_ERROR
//Language=English
//The Proxy called the channel manager with wrong arguments or when unexpected. %0
//.
//
// MessageId: ID_QC_UNEXPECTED
//
// MessageText:
//
//  COM+ Queued Components: An unexpected error occurred. The failing function is listed below. The data section may have additional information.%1%0
//
#define ID_QC_UNEXPECTED                 ((DWORD)0xC0021051L)

//MessageId=0x1052
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_RECORDER_CLSID_NOT_ASYNCABLE
//Language=English
//The clsid is not asyncable.%0
//.
//
// MessageId: ID_E_QC_CATALOG
//
// MessageText:
//
//  COM+ QC failed to obtain necessary information from the catalog.%1%0
//
#define ID_E_QC_CATALOG                  ((DWORD)0xC0021053L)

//
// MessageId: ID_QCLISTENER_MSMQ_UNAVAILABLE
//
// MessageText:
//
//  The listener has timed out waiting for the MSMQ service to start.  Therefore the process was terminated.%0	
//
#define ID_QCLISTENER_MSMQ_UNAVAILABLE   ((DWORD)0xC0021057L)

//MessageId=0x1058
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_REPUTIL_IFACE_NOTDEFERRABLE
//Language=English
//Interface is not deferrable because %1. %0
//.
//MessageId=0x1059
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_QCPLY_NOTCONFIG
//Language=English
//The player has not been installed/configured correctly. %0
//.
//MessageId=0x105A
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_QCLISTENER_IOCOMPPORT
//Language=English
//The listener Mgr could not create an IOCompletionPort. Check the error value in data.%1%0
//.
//MessageId=0x105B
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_QCLISTENER_CLOSEHND
//Language=English
//The listener Mgr could not close handles. %0
//.
//MessageId=0x105C
//Severity=Error
//Facility=Runtime
//SymbolicName=ID_E_QCLISTENER_STARTED
//Language=English
//The listener Mgr has already started. %0
//.
//
// MessageId: ID_E_USER_EXCEPTION
//
// MessageText:
//
//  The system has called a custom component and that component has failed and generated an exception. This indicates a problem with the custom component. Notify the developer of this component that a failure has occurred and provide them with the information below. %1%2%0
//
#define ID_E_USER_EXCEPTION              ((DWORD)0xC0021062L)

//
// MessageId: ID_COMSVCS_GER_FAILED
//
// MessageText:
//
//  An error occurred while checking to see if a queued message was sent by a trusted partner. The process may have insufficient privileges to call GetEffectiveRightsFromAcl. The HRESULT from this call is %1%0
//
#define ID_COMSVCS_GER_FAILED            ((DWORD)0xC0021064L)

//
// MessageId: ID_COMSVCS_ISTRUSTEDENQ_MEM
//
// MessageText:
//
//  The server was unable to determine if a queued message was sent by a trusted partner due to a lack of available memory. The sender is assumed to be untrusted. %1%0
//
#define ID_COMSVCS_ISTRUSTEDENQ_MEM      ((DWORD)0xC0021065L)

//
// MessageId: ID_COMSVCS_ISTRUSTEDENQ_WIN32
//
// MessageText:
//
//  The server was unable to determine if a queued message was sent by a trusted partner due to an unexpected failure in a Win32 API call. The sender is assumed to be untrusted. The failed API and corresponding error code are shown below. %1%0
//
#define ID_COMSVCS_ISTRUSTEDENQ_WIN32    ((DWORD)0xC0021066L)

//
// MessageId: ID_COMSVCS_TLSALLOC_FAILED
//
// MessageText:
//
//  The COM+ Services DLL (comsvcs.dll) was unable to load because allocation of thread local storage failed. %1%0
//
#define ID_COMSVCS_TLSALLOC_FAILED       ((DWORD)0xC0021067L)

//
// MessageId: ID_COMCAT_REGDB_FOUNDCORRUPT
//
// MessageText:
//
//  The current registration database is corrupt. COM+ catalog has reverted to a previous version of the database. %0
//
#define ID_COMCAT_REGDB_FOUNDCORRUPT     ((DWORD)0xC0001068L)

//
// MessageId: ID_COMSVCS_STRING_MISSING
//
// MessageText:
//
//  COM+ Services was unable to load a required string resource. The string resource identifier was not found. This results from an error in the localization process for this product and should be reported to Microsoft customer support. The binary data for this event contains the resource identifier that failed to load. %1%0
//
#define ID_COMSVCS_STRING_MISSING        ((DWORD)0xC002106AL)

//
// MessageId: ID_COMSVCS_STRING_TOO_LONG
//
// MessageText:
//
//  COM+ Services was unable to load a required string resource. The buffer supplied for the string was not large enough. This results from an error in the localization process for this product and should be reported to Microsoft customer support. The binary data for this event contains the resource identifier that failed to load.%1%0
//
#define ID_COMSVCS_STRING_TOO_LONG       ((DWORD)0xC002106BL)

//
// MessageId: ID_COMSVCS_ADMIN_NOTFOUND
//
// MessageText:
//
//  COM+ Services was unable to lookup the local Administrator account and obtain its security identifier (SID). COM+ will continue to operate normally, but any calls between local and remote COM+ components will incur additional overhead. The error returned by LookupAccountName is shown below.%1%0
//
#define ID_COMSVCS_ADMIN_NOTFOUND        ((DWORD)0x8002106CL)

//
// MessageId: ID_COMSVCS_INIT_FAILED
//
// MessageText:
//
//  COM+ Services was unable to initialize due to a failure in the system API shown below. This is often caused by a shortage of system resources on the local machine.%1%0
//
#define ID_COMSVCS_INIT_FAILED           ((DWORD)0xC002106DL)

//
// MessageId: IDS_E_CRM_EXCEPTION_IN_DELIVER_NOTIFICATIONS
//
// MessageText:
//
//  The system has called the CRM Compensator custom component and that component has failed and generated an exception. This indicates a problem with the CRM Compensator component. Notify the developer of the CRM Compensator component that this failure has occurred. %1%0
//
#define IDS_E_CRM_EXCEPTION_IN_DELIVER_NOTIFICATIONS ((DWORD)0xC002106EL)

//
// MessageId: IDS_E_CRM_SHARING_VIOLATION
//
// MessageText:
//
//  The application cannot access the CRM log file because it is being used by another process. Most likely this is because another server process is running for the same application. Please check that no other server processes are running for this application and try again. If the condition persists, please contact Microsoft Product Support Services. %1%0
//
#define IDS_E_CRM_SHARING_VIOLATION      ((DWORD)0xC002106FL)

//
// MessageId: ID_COMSVCS_ITM_FAILURE
//
// MessageText:
//
//  COM+ Services was unable to authorize the incoming call due to an unexpected failure. The incoming call was denied and a "permission denied" error was returned to the caller. The unexpected error code is shown below.%1%0
//
#define ID_COMSVCS_ITM_FAILURE           ((DWORD)0xC0021070L)

//
// MessageId: ID_COMSVCS_IDENTIFY_CALLER
//
// MessageText:
//
//  COM+ Services was unable to determine the caller's identity because of an unexpected error. This may be caused by a shortage of system resources on the local machine. The caller will be treated as anonymous which may result in access failures or other errors. The name of the failed API and the error code that it returned are shown below.%1%0
//
#define ID_COMSVCS_IDENTIFY_CALLER       ((DWORD)0xC0021071L)

//
// MessageId: ID_COMSVCS_ITM_ICIR_FAILURE
//
// MessageText:
//
//  COM+ Services was unable to process a component's call to IsCallerInRole due to an unexpected failure. The unexpected error code (shown below) was returned to the caller.%1%0
//
#define ID_COMSVCS_ITM_ICIR_FAILURE      ((DWORD)0xC0021072L)

//
// MessageId: IDS_E_CRM_ERROR_IN_DELIVER_NOTIFICATIONS
//
// MessageText:
//
//  The system has called the CRM Compensator custom component and that component has returned an error. This indicates a problem with the CRM Compensator component. Notify the developer of the CRM Compensator component that this failure has occurred. %1%0
//
#define IDS_E_CRM_ERROR_IN_DELIVER_NOTIFICATIONS ((DWORD)0xC0021073L)

//
// MessageId: IDS_E_CRM_CCI_COMPENSATOR_FAILED
//
// MessageText:
//
//  The system failed to create the CRM Compensator custom component. %1%0
//
#define IDS_E_CRM_CCI_COMPENSATOR_FAILED ((DWORD)0xC0021074L)

//
// MessageId: IDS_E_CRM_CCI_COMPENSATOR_OUT_OF_MEMORY
//
// MessageText:
//
//  The system failed to create the CRM Compensator because the system is out of memory. %1%0
//
#define IDS_E_CRM_CCI_COMPENSATOR_OUT_OF_MEMORY ((DWORD)0xC0021075L)

//
// MessageId: ID_QC_BADMESSAGE
//
// MessageText:
//
//  The QC Player detected an invalid QC message. The message will be moved to the deadqueue.%1%0
//
#define ID_QC_BADMESSAGE                 ((DWORD)0xC0021076L)

//
// MessageId: ID_QC_THREADTOKEN_OPERATION_FAILED
//
// MessageText:
//
//  COM+ QC was unable to open or set thread token due to an unexpected failure in the system API shown below. (Make sure that there are no ACLs set on the thread.) %1%0
//
#define ID_QC_THREADTOKEN_OPERATION_FAILED ((DWORD)0xC0021077L)

//
// MessageId: ID_COMSVCS_QC_MSMQ1
//
// MessageText:
//
//  An unexpected error was returned by the MSMQ API function indicated. The following error message was retrieved from MSMQ.%1%0 
//
#define ID_COMSVCS_QC_MSMQ1              ((DWORD)0xC0021078L)

//
// MessageId: ID_COMSVCS_ISTRUSTEDENQ_CATALOG
//
// MessageText:
//
//  The server was unable to determine if a queued message was sent by a trusted partner due to an unexpected failure in a COM+ catalog component. The sender is assumed to be untrusted. The failed catalog API and corresponding error code are shown below.%1%0
//
#define ID_COMSVCS_ISTRUSTEDENQ_CATALOG  ((DWORD)0xC002107AL)

//
// MessageId: ID_COMSVCS_QC_MSMQ2
//
// MessageText:
//
//  An unexpected error was returned by the MSMQ API function indicated. An error occurred while retrieving the error message from MSMQ. MSMQ API function return values are defined in MSMQ header file MQ.H.%1%0 
//
#define ID_COMSVCS_QC_MSMQ2              ((DWORD)0xC002107BL)

//
// MessageId: IDS_E_SYNC_REQUIRED_FOR_TX
//
// MessageText:
//
//  The Synchronization property is required for the Transaction property. Activation failed for object: %1%0
//
#define IDS_E_SYNC_REQUIRED_FOR_TX       ((DWORD)0xC0021080L)

//
// MessageId: IDS_E_SYNC_REQUIRED_FOR_JIT
//
// MessageText:
//
//  The Synchronization property is required for the JIT property. Activation failed for object: %1%0
//
#define IDS_E_SYNC_REQUIRED_FOR_JIT      ((DWORD)0xC0021081L)

//
// MessageId: IDS_E_CONSTRUCTION_FAILED
//
// MessageText:
//
//  The following component is configured for Construction, and either the IObjectConstruct::Construct() method failed, or the component does not support IObjectConstruct. Activation failed for object: %1%0
//
#define IDS_E_CONSTRUCTION_FAILED        ((DWORD)0xC0021082L)

//
// MessageId: ID_COMCAT_REGDB_INITSECURITYDESC
//
// MessageText:
//
//  Error creating security descriptor. %0
//
#define ID_COMCAT_REGDB_INITSECURITYDESC ((DWORD)0xC0001083L)

//
// MessageId: ID_COMCAT_REGDBSVR_INITFAILED
//
// MessageText:
//
//  Failed to initialize registration database server. %0
//
#define ID_COMCAT_REGDBSVR_INITFAILED    ((DWORD)0xC0001084L)

//
// MessageId: ID_COMCAT_REGDBAPI_INITFAILED
//
// MessageText:
//
//  Failed to initialize registration database API. %0
//
#define ID_COMCAT_REGDBAPI_INITFAILED    ((DWORD)0xC0001085L)

//
// MessageId: IDS_COMSVCS_INTERNAL_ERROR_ASSERT
//
// MessageText:
//
//  COM+ Internal Error. Please contact Microsoft Product Support Services to report this error. Assertion Failure: %1%0
//
#define IDS_COMSVCS_INTERNAL_ERROR_ASSERT ((DWORD)0xC0021086L)

//
// MessageId: ID_E_REPL_UNEXPECTED_ERR
//
// MessageText:
//
//  COM Replication: An unexpected error occurred.  The function which failed is listed below. %1%0
//
#define ID_E_REPL_UNEXPECTED_ERR         ((DWORD)0xC0001087L)

//
// MessageId: ID_QC_OUT_ARGS
//
// MessageText:
//
//  COM Queued Components: Output arguments are not supported by queued methods. Check the data section for IID and method ID.%1%0
//
#define ID_QC_OUT_ARGS                   ((DWORD)0xC0021089L)

//
// MessageId: ID_SRGTAPI_APP_LAUNCH_FAILED
//
// MessageText:
//
//  A COM+ service (such as Queued Components or Compensating Resource Manager) failed an ApplicationLaunch event.  If this problem continues, try disabling CRM and/or QC on your application. If you are using QC, make sure that MSMQ is installed. The service GUID and HRESULT are: %1%0
//
#define ID_SRGTAPI_APP_LAUNCH_FAILED     ((DWORD)0xC002108AL)

//
// MessageId: ID_SRGTAPI_APP_FREE_FAILED
//
// MessageText:
//
//  A COM+ service (such as Queued Components or Compensating Resource Manager) failed an ApplicationFree event.  This is not a normal occurrence, but it is considered a non-critical error. The service GUID and HRESULT are: %1%0
//
#define ID_SRGTAPI_APP_FREE_FAILED       ((DWORD)0x8002108BL)

//
// MessageId: ID_SRGTAPI_PROCESS_SHUTDOWN_FAILED
//
// MessageText:
//
//  A COM+ service (such as Queued Components or Compensating Resource Manager) failed an ApplicationShutdown event.  This is not a normal occurrence, but it is considered a non-critical error. The service GUID and HRESULT are: %1%0
//
#define ID_SRGTAPI_PROCESS_SHUTDOWN_FAILED ((DWORD)0x8002108CL)

//
// MessageId: ID_SRGTAPI_START_FAILED
//
// MessageText:
//
//  A COM+ service (such as Queued Components or Compensating Resource Manager) failed to start. The service GUID and HRESULT are: %1%0
//
#define ID_SRGTAPI_START_FAILED          ((DWORD)0xC002108DL)

//
// MessageId: ID_LOW_MEMORY
//
// MessageText:
//
//  COM+ has determined that your machine is running very low on available memory.  In order to ensure proper system behavior, the activation of the component has been refused.  If this problem continues, either install more memory or increase the size of your paging file.  Memory statistics are: %1%0
//
#define ID_LOW_MEMORY                    ((DWORD)0x8002108EL)

//
// MessageId: ID_OUTOFMEMORY_ACTIVATIONFAILED
//
// MessageText:
//
//  COM+ failed an activation because the creation of a context property returned E_OUTOFMEMORY %1%0
//
#define ID_OUTOFMEMORY_ACTIVATIONFAILED  ((DWORD)0x8002108FL)

//
// MessageId: ID_THREAD_QUEUE_FAILED
//
// MessageText:
//
//  A request for a callback on a MTA thread failed. The only time this should happen is your machine is in a completely unstable state and you should reboot, or there is a bug in COM+.  If the problem is reproducible, please report this error to Microsoft. %1%0
//
#define ID_THREAD_QUEUE_FAILED           ((DWORD)0xC0021090L)

//
// MessageId: ID_SRGTAPI_CAPPLICATION_INIT_FAILED
//
// MessageText:
//
//  The initialization of the COM+ surrogate failed -- the CApplication object failed to initialize.%1%0
//
#define ID_SRGTAPI_CAPPLICATION_INIT_FAILED ((DWORD)0xC0021091L)

//
// MessageId: ID_SRGTAPI_APP_FREE_UNKNOWN_APPLID
//
// MessageText:
//
//  The shutdown process of COM+ surrogate failed because of an unknown ApplId. This is an unexpected error, but is ignored because the application is in the process of shutting down.%1%0
//
#define ID_SRGTAPI_APP_FREE_UNKNOWN_APPLID ((DWORD)0x80021092L)

//
// MessageId: ID_BYOT_TIP_IMPORT_FAILED
//
// MessageText:
//
//  The Byot Gateway failed to import the transaction using Tip. Make sure that the installed DTC supports the TIP protocol. %1%0
//
#define ID_BYOT_TIP_IMPORT_FAILED        ((DWORD)0xC0021093L)

//
// MessageId: ID_BYOT_OBJ_CREATE_FAILED
//
// MessageText:
//
//  The Byot Gateway failed to create the component.%1%0
//
#define ID_BYOT_OBJ_CREATE_FAILED        ((DWORD)0xC0021094L)

//
// MessageId: ID_BYOT_TXN_SET_FAILED
//
// MessageText:
//
//  The Byot Gateway could not set transactional property in new object context.%1%0
//
#define ID_BYOT_TXN_SET_FAILED           ((DWORD)0xC0021095L)

//
// MessageId: ID_BYOT_DELEGATE_ACTIVATION_FAILED
//
// MessageText:
//
//  The Byot Gateway could not delegate the activation. The component being created may be incorrectly configured. %1%0
//
#define ID_BYOT_DELEGATE_ACTIVATION_FAILED ((DWORD)0xC0021096L)

//
// MessageId: ID_BYOT_BAD_CONTEXT
//
// MessageText:
//
//  The Byot Gateway component is incorrectly configured. %1%0
//
#define ID_BYOT_BAD_CONTEXT              ((DWORD)0xC0021097L)

//
// MessageId: ID_IOBJECT_CONTROL_ACTIVATE_FAILED
//
// MessageText:
//
//  The IObjectControl::Activate() method failed.  The CLSID of the object is: %1%0
//
#define ID_IOBJECT_CONTROL_ACTIVATE_FAILED ((DWORD)0xC0021098L)

//
// MessageId: ID_QC_BAD_MARSHALEDOBJECT
//
// MessageText:
//
//  QC has detected an invalid Marshaled object. The message will be moved to the deadqueue.%1%0
//
#define ID_QC_BAD_MARSHALEDOBJECT        ((DWORD)0xC0021099L)

//
// MessageId: ID_QCRECORDER_BADOBJREF
//
// MessageText:
//
//  An unsupported object reference was used during a method call to a QC component.  The object reference should either be a QC recorder or support IPersistStream.%1%0
//
#define ID_QCRECORDER_BADOBJREF          ((DWORD)0xC002109AL)

//
// MessageId: IDS_E_CRM_DTC_ERROR
//
// MessageText:
//
//  The CRM has lost its connection with MS DTC. This is expected if MS DTC has stopped, or if MS DTC failover has occurred on a cluster.%1%0
//
#define IDS_E_CRM_DTC_ERROR              ((DWORD)0xC002109BL)

//
// MessageId: IDS_E_QCADMIN_QUEUE_NOT_EMPTY
//
// MessageText:
//
//  Unable to delete queue because it has messages.  Purge messages and try again.%1%0
//
#define IDS_E_QCADMIN_QUEUE_NOT_EMPTY    ((DWORD)0xC00210A0L)

//
// MessageId: IDS_E_QUEUE_BLOB_VERSION
//
// MessageText:
//
//  Queued Application has an obsolete catalog entry. Uncheck and check the Application's Queue property.%1%0
//
#define IDS_E_QUEUE_BLOB_VERSION         ((DWORD)0xC00210A1L)

//
// MessageId: IDS_E_QUEUE_BLOB
//
// MessageText:
//
//  Queued Application has an invalid catalog entry (Queue BLOB).%1%0
//
#define IDS_E_QUEUE_BLOB                 ((DWORD)0xC00210A2L)

//
// MessageId: ID_QC_MSMQ_UNAVAILABLE
//
// MessageText:
//
//  MSMQ is unavailable.  QC requires MSMQ to be installed.  If no queued calls are made then simply turn off the listener and use DCOM calls.%1%0
//
#define ID_QC_MSMQ_UNAVAILABLE           ((DWORD)0xC00210A3L)

//
// MessageId: ID_QC_MSMQ_GETPROC
//
// MessageText:
//
//  GetProcAddress on one of the MSMQ functions failed.  Please make sure that MSMQ is installed correctly.%1%0
//
#define ID_QC_MSMQ_GETPROC               ((DWORD)0xC00210A4L)

//
// MessageId: IDS_E_EVENT_UNKNOWN_ID
//
// MessageText:
//
//  Unknown event id. Please check the event log for any other errors from the EventSystem.%1%0
//
#define IDS_E_EVENT_UNKNOWN_ID           ((DWORD)0xC00210A5L)

//
// MessageId: IDS_E_EXCEPTION_CLASS
//
// MessageText:
//
//  Unable to instantiate Exception Class.%1%0
//
#define IDS_E_EXCEPTION_CLASS            ((DWORD)0xC00210A6L)

//
// MessageId: IDS_E_WRONG_ODBC_VERSION
//
// MessageText:
//
//  COM+ requires that ODBC version 2.0 or greater be installed on your machine.  The version of ODBC that ships with Windows 2000 is sufficient.  Please reinstall ODBC from your distribution media.%1%0
//
#define IDS_E_WRONG_ODBC_VERSION         ((DWORD)0xC00210A7L)

//
// MessageId: IDS_E_ODBC_SETUP_ERROR
//
// MessageText:
//
//  COM+ was unable to set up the ODBC shared environment, which means that automatic transaction enlistment will not work.%1%0
//
#define IDS_E_ODBC_SETUP_ERROR           ((DWORD)0xC00210A8L)

//
// MessageId: IDS_E_CRM_CHECKPOINT_FAILED_ON_CLUSTER
//
// MessageText:
//
//  A CRM checkpoint has failed. Most likely this application is not configured correctly for use on the cluster. See the COM+ Compensating Resource Manager (CRM) documentation for details on how to fix this problem.%1%0
//
#define IDS_E_CRM_CHECKPOINT_FAILED_ON_CLUSTER ((DWORD)0xC00210A9L)

//
// MessageId: ID_COMCAT_SLTCOMS_THREADINGMODELINCONSISTENT
//
// MessageText:
//
//  The threading model of the component specified in the registry is inconsistent with the registration database. The faulty component is: %1%0
//
#define ID_COMCAT_SLTCOMS_THREADINGMODELINCONSISTENT ((DWORD)0xC00210AAL)

//
// MessageId: IDS_E_CRM_DUPLICATE_GUID
//
// MessageText:
//
//  CRM recovery has failed because MS DTC thinks that the previous instance of this application is still connected. This problem can occur if the system is too busy. Please attempt the CRM recovery again by restarting this application.%1%0
//
#define IDS_E_CRM_DUPLICATE_GUID         ((DWORD)0xC00210ABL)

//
// MessageId: IDS_E_CRM_WORK_DONE_TIMEOUT
//
// MessageText:
//
//  The CRM Compensator custom component has timed out out waiting for the CRM Worker custom component to complete. See the COM+ Compensating Resource Manager (CRM) documentation for further explanation of this error.%1%0
//
#define IDS_E_CRM_WORK_DONE_TIMEOUT      ((DWORD)0xC00210ACL)

 /***** NEW ERROR MESSAGES GO ABOVE HERE *****/
 /***** BEGIN EXTERNAL MESSAGES *****/
 /***** this section (0x1500 thru 0x15FF) is for EXTERNAL message ids used by function ComSvcsLogError *****/
//
// MessageId: IDS_E_FIRST_EXTERNAL_ERROR_MESSAGE
//
// MessageText:
//
//  This is the first external error message in this file. It is a marker only, never issued.%1%0
//
#define IDS_E_FIRST_EXTERNAL_ERROR_MESSAGE ((DWORD)0xC0021500L)

//
// MessageId: IDS_E_UNKNOWN_EXTERNAL_ERROR
//
// MessageText:
//
//  An external error has been reported to COM+ services.%1%0
//
#define IDS_E_UNKNOWN_EXTERNAL_ERROR     ((DWORD)0xC0021501L)

//
// MessageId: IDS_W_UNKNOWN_EXTERNAL_ERROR
//
// MessageText:
//
//  An external error has been reported to COM+ services.%1%0
//
#define IDS_W_UNKNOWN_EXTERNAL_ERROR     ((DWORD)0x80021502L)

//
// MessageId: IDS_W_TXF_TMDOWN
//
// MessageText:
//
//  The server process has lost its connection with MS DTC. This is expected if MS DTC has stopped, or if MS DTC failover has occurred on a cluster.%1%0
//
#define IDS_W_TXF_TMDOWN                 ((DWORD)0x80021503L)

//
// MessageId: IDS_E_THREAD_START_FAILED
//
// MessageText:
//
//  COM+ could not create a new thread due to a low memory situation.%1%0
//
#define IDS_E_THREAD_START_FAILED        ((DWORD)0xC0021504L)

 /***** END EXTERNAL MESSAGES *****/
 /***** DO NOT PUT NEW "NORMAL" ERROR MESSAGES HERE - SEE ABOVE *****/
 /***** this section (0x1500 thru 0x15FF) is for EXTERNAL message ids used by function ComSvcsLogError *****/
 /***** WARNING ***** WARNING ***** update the message id below when adding new EXTERNAL messages *****/
//
// MessageId: IDS_E_LAST_EXTERNAL_ERROR_MESSAGE
//
// MessageText:
//
//  This is the last external error message in this file. It is a marker only, never issued.%1%0
//
#define IDS_E_LAST_EXTERNAL_ERROR_MESSAGE ((DWORD)0xC0021505L)

 /***** put new 'normal' messages below here at MessageId of 0x1600 or above to allow for further external messages *****/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\unicode.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// unicode.h
//
// Header file that forcibly turns on a unicode compile
//

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef MBCS
#undef _MBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\vtableimpl.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// vtableimpl.h
//
// Definitions for creating static vtables
//
// Use: define meth() and methname() macros before including this file
// Then, do (e.g.)
//
//      defineVtableMethods()
//      defineVtable(g_UKInterfaceVtable, pfnQI, pfnAddRef, pfnRelease)
// 
// to actually create the defintions
//

#define meth10(i) \
	meth(i##0) \
	meth(i##1) \
	meth(i##2) \
	meth(i##3) \
	meth(i##4) \
	meth(i##5) \
	meth(i##6) \
	meth(i##7) \
	meth(i##8) \
	meth(i##9)

#define meth100(i) \
	meth10(i##0) \
	meth10(i##1) \
	meth10(i##2) \
	meth10(i##3) \
	meth10(i##4) \
	meth10(i##5) \
	meth10(i##6) \
	meth10(i##7) \
	meth10(i##8) \
	meth10(i##9)


#define defineVtableMethods() \
    meth(3)         \
    meth(4)         \
    meth(5)         \
    meth(6)         \
    meth(7)         \
    meth(8)         \
    meth(9)         \
    meth10(1)       \
    meth10(2)       \
    meth10(3)       \
    meth10(4)       \
    meth10(5)       \
    meth10(6)       \
    meth10(7)       \
    meth10(8)       \
    meth10(9)       \
    meth100(1)      \
    meth100(2)      \
    meth100(3)      \
    meth100(4)      \
    meth100(5)      \
    meth100(6)      \
    meth100(7)      \
    meth100(8)      \
    meth100(9)      \
    meth10(100)     \
    meth10(101)     \
    meth(1020)      \
    meth(1021)      \
    meth(1022)      \
    meth(1023)

// 
// _LANGUAGE_ASSEMBLY is defined by the ALPHA assembler
//
#ifndef _LANGUAGE_ASSEMBLY
    #define rmeth(i) (PFN_VTABLE_ENTRY)(&methname(i)),
#else

#ifndef _WIN64
    #define rmeth(i) .long methname(i);
#else
    #define rmeth(i) .quad methname(i);
#endif

#endif

#define rmeth10(i) \
	rmeth(i##0) \
	rmeth(i##1) \
	rmeth(i##2) \
	rmeth(i##3) \
	rmeth(i##4) \
	rmeth(i##5) \
	rmeth(i##6) \
	rmeth(i##7) \
	rmeth(i##8) \
	rmeth(i##9)

#define rmeth100(i) \
	rmeth10(i##0) \
	rmeth10(i##1) \
	rmeth10(i##2) \
	rmeth10(i##3) \
	rmeth10(i##4) \
	rmeth10(i##5) \
	rmeth10(i##6) \
	rmeth10(i##7) \
	rmeth10(i##8) \
	rmeth10(i##9)


#ifndef _LANGUAGE_ASSEMBLY

#define defineVtable(name, qi, ar, rel)                             \
                                                                    \
    extern "C" const PFN_VTABLE_ENTRY name[] =                      \
        {                                                           \
        (PFN_VTABLE_ENTRY)(&qi),                                    \
        (PFN_VTABLE_ENTRY)(&ar),                                    \
        (PFN_VTABLE_ENTRY)(&rel),                                   \
	    rmeth(3)            \
	    rmeth(4)            \
	    rmeth(5)            \
	    rmeth(6)            \
	    rmeth(7)            \
	    rmeth(8)            \
	    rmeth(9)            \
	    rmeth10(1)          \
	    rmeth10(2)          \
	    rmeth10(3)          \
	    rmeth10(4)          \
	    rmeth10(5)          \
	    rmeth10(6)          \
	    rmeth10(7)          \
	    rmeth10(8)          \
	    rmeth10(9)          \
	    rmeth100(1)         \
	    rmeth100(2)         \
	    rmeth100(3)         \
	    rmeth100(4)         \
	    rmeth100(5)         \
	    rmeth100(6)         \
	    rmeth100(7)         \
	    rmeth100(8)         \
	    rmeth100(9)         \
	    rmeth10(100)        \
	    rmeth10(101)        \
	    rmeth(1020)         \
	    rmeth(1021)         \
	    rmeth(1022)         \
	    rmeth(1023)         \
        };

#else

#ifndef _WIN64
#define defineVtable(name, qi, ar, rel) \
    .extern qi;                         \
    .extern ar;                         \
    .extern rel;                        \
                                        \
    .globl name;                        \
                                        \
    name:                               \
        .long qi;           \
        .long ar;           \
        .long rel;          \
	    rmeth(3)            \
	    rmeth(4)            \
	    rmeth(5)            \
	    rmeth(6)            \
	    rmeth(7)            \
	    rmeth(8)            \
	    rmeth(9)            \
	    rmeth10(1)          \
	    rmeth10(2)          \
	    rmeth10(3)          \
	    rmeth10(4)          \
	    rmeth10(5)          \
	    rmeth10(6)          \
	    rmeth10(7)          \
	    rmeth10(8)          \
	    rmeth10(9)          \
	    rmeth100(1)         \
	    rmeth100(2)         \
	    rmeth100(3)         \
	    rmeth100(4)         \
	    rmeth100(5)         \
	    rmeth100(6)         \
	    rmeth100(7)         \
	    rmeth100(8)         \
	    rmeth100(9)         \
	    rmeth10(100)        \
	    rmeth10(101)        \
	    rmeth(1020)         \
	    rmeth(1021)         \
	    rmeth(1022)         \
	    rmeth(1023)         \
    
#else

#define defineVtable(name, qi, ar, rel) \
    .extern qi;                         \
    .extern ar;                         \
    .extern rel;                        \
                                        \
    .globl name;                        \
                                        \
    name:                               \
        .quad qi;           \
        .quad ar;           \
        .quad rel;          \
	    rmeth(3)            \
	    rmeth(4)            \
	    rmeth(5)            \
	    rmeth(6)            \
	    rmeth(7)            \
	    rmeth(8)            \
	    rmeth(9)            \
	    rmeth10(1)          \
	    rmeth10(2)          \
	    rmeth10(3)          \
	    rmeth10(4)          \
	    rmeth10(5)          \
	    rmeth10(6)          \
	    rmeth10(7)          \
	    rmeth10(8)          \
	    rmeth10(9)          \
	    rmeth100(1)         \
	    rmeth100(2)         \
	    rmeth100(3)         \
	    rmeth100(4)         \
	    rmeth100(5)         \
	    rmeth100(6)         \
	    rmeth100(7)         \
	    rmeth100(8)         \
	    rmeth100(9)         \
	    rmeth10(100)        \
	    rmeth10(101)        \
	    rmeth(1020)         \
	    rmeth(1021)         \
	    rmeth(1022)         \
	    rmeth(1023)         \
    
#endif // WIN64

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\workerqueue.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// workerqueue.h
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////
//// Thread Pool Services: header is in viper\src\inc
////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#include "threadpool.h"

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////
//// Timeout Services
////
//// Support for maintaining a large number of objects that have a like or
//// an approximate timeout duration.
////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

struct TIMEOUT_ENTRY
    {
    LONGLONG              m_deadline;           // timeout deadline: FILETIME format
    RTL_SPLAY_LINKS       m_links;              // links that connect this timeout entry to others
    WorkerQueueItem::PFN  m_pfn;
    PVOID                 m_pvContext;
    ULONG                 m_reserved;

    TIMEOUT_ENTRY(WorkerQueueItem::PFN pfn=NULL, PVOID pvContext=NULL)
        {
        RtlInitializeSplayLinks(&m_links);
        m_pfn = pfn;
        m_pvContext = pvContext;
        m_reserved = 0;
        }

    HRESULT TimeoutAfter(LONGLONG delta);
    // Time this entry out after the indicated delta from the current time

    void CancelTimeout();
    // Cancel any timeout that this entry presently has
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\vtable.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// vtable.h
//
// Generic definitions for creating vtables
//
typedef void (__stdcall * const PFN_VTABLE_ENTRY)();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\jtl\txftwo.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txftwo.h
//
// Simple arithmetic utilities

#ifndef __TXFTWO_H__
#define __TXFTWO_H__

inline int lg(unsigned u) 
// return largest i such that 2^i <= u
    {
    DEBUG(unsigned u0 = u;)
    PRECONDITION(u > 0);

    int n = 0;
#define t(j) if (u >= (1 << (j))) { u >>= (j); n += (j); }
    t(16); t(8); t(4); t(2); t(1);
#undef t

    POSTCONDITION(u == 1);
    POSTCONDITION((1U << n) <= u0);
    POSTCONDITION(n == 31 || u0 < (1U << (n+1)));
    return n;
    }

inline unsigned nextPowerOfTwo(unsigned u)
// return smallest n such that n = 2^i and u <= n
    {
    PRECONDITION(u > 0);

    int lgu = lg(u);
    int lguRoundedUp = lg(u + (1 << lgu) - 1);
    unsigned n = 1 << lguRoundedUp;

    POSTCONDITION(n/2 < u && u <= n);
    return n;
    // examples:
    // u lgu lgRU n
    // 1   0   0  1
    // 4   2   2  4
    // 5   2   3  8
    // 7   2   3  8
    // 8   3   3  8
    }

inline unsigned nextMultiple(unsigned u, unsigned m) 
    {
    return (u + m - 1) / m * m;
    }

inline int nextMultiple(int i, unsigned m) 
    {
    return (i + m - 1) / m * m;
    }


inline unsigned bitcount(unsigned u)
// Return number of set bits in the word.
    {
    // In-place adder tree: perform 16 1-bit adds, 8 2-bit adds, 4 4-bit adds,
    // 2 8=bit adds, and 1 16-bit add.
    u = ((u >> 1)&0x55555555) + (u&0x55555555);
    u = ((u >> 2)&0x33333333) + (u&0x33333333);
    u = ((u >> 4)&0x0F0F0F0F) + (u&0x0F0F0F0F);
    u = ((u >> 8)&0x00FF00FF) + (u&0x00FF00FF);
    u = ((u >>16)&0x0000FFFF) + (u&0x0000FFFF);
    return u;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\shared\chkstk\i386\chkstk.asm ===
TITLE	vtable.asm
.386P
.model FLAT

	
_PAGESIZE_      equ     4096	; Intel x86 pages are 4K
	
	
_TEXT SEGMENT

	PUBLIC __chkstk
	PUBLIC __alloca_probe
	
__chkstk PROC NEAR
__alloca_probe:
	or	eax,eax
	jnz	nonzero		; Non-zero alloc
	ret			; Just return if zero was requested
	
nonzero:	
	push	eax		; Save alloc count
	push	edi		; Save non-volatile EDI
	lea	edi,[esp+12]	; Adjust for return address + saved registers
	cmp	eax,_PAGESIZE_	; More than one page requested?
	jb	short lastpage

probepages:
	sub	edi,_PAGESIZE_	; Move down a page
	sub	eax,_PAGESIZE_	; Decrease requested amount
	test	[edi],eax	; Probe it
	cmp	eax,_PAGESIZE_	; Still more than one page requested?
	jae	probepages

lastpage:
	sub	edi,eax		; Move down leftover amount on this page
	test	[edi],eax	; Probe it
	
	mov	eax,esp		; EAX = current top of stack
	mov	esp,edi		; Set the new stack pointer
	mov	edi,[eax+0]	; Recover EDI
	
	push	[eax+4]		; Save alloc count again
	push	[eax+8]		; Save return address again
	push	edi		; Save EDI again
	push	ecx		; Save ECX
	
	lea	edi,[esp+16]	; EDI = start of local variables
	mov	ecx,[esp+12]	; ECX = alloc count
	shr	ecx,2		; Convert bytes to DWORDS
	mov	eax,0deadbeefH	; EAX = fill value
	rep stosd [edi]

	pop	ecx
	pop	edi
	pop	eax
	add	esp,4		; Discard saved alloc count
	jmp	eax
			
__chkstk ENDP
	
	
		
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\jtl\txfmap.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfmap.h
//
#ifndef __TXFMAP_H__
#define __TXFMAP_H__

#include "txfarray.h"
#include "txftwo.h"
#include "txfiset.h"

//////////////////////////////////////////////////////////////////////////

#if defined(_DEBUG) && 0
    #define trace(args) trace_ args
    #define traceOnly(x) x
#else
    #define trace(args) 0
    #define traceOnly(x)
#endif

enum TR { trMap };

inline void trace_(TR tr, const char* szFmt, ...)
    {
    va_list va;
    va_start(va, szFmt);
    PrintVa(szFmt, va);
    va_end(va);
    }

//////////////////////////////////////////////////////////////////////////

typedef ULONG HASH;

template <class H,int>
class HashClass 
    {
public: inline HASH __fastcall operator()(H);
    };

//
// standard version of the HashClass merely casts the object to a HASH.
//  by convention, this one is always HashClass<H,hcCast>
//
#define hcCast 0
#define hcSig 1     // SIG is an unsigned long (like NI!) and needs a different hash function
#define hcKey 2     // KEY is an unsigned long (like NI!) and needs a different hash function

template <class H,int i> inline HASH __fastcall
HashClass<H,i>::operator()(H h) 
    {
    ASSERT(i==hcCast);
    return HASH(h);
    }

typedef HashClass<unsigned long, hcCast> HcNi;

//////////////////////////////////////////////////////////////////////////

// fwd decl template enum class used as friend
template <class D, class R, class H, POOL_TYPE poolType> class EnumMap;

const unsigned iNil = (unsigned)-1;

template <class D, class R, class H, POOL_TYPE poolType>
class Map : public FromPool<poolType>
    {   
public:
    Map(unsigned cdrInitial =1) :
            rgd(cdrInitial > 0 ? cdrInitial : 1),
            rgr(cdrInitial > 0 ? cdrInitial : 1)
        {
        cdr = 0;
        traceOnly(cFinds = 0;)
        traceOnly(cYes   = 0;)
        traceOnly(cNo    = 0;)
        traceOnly(cProbes = 0;)
        traceOnly(cProbesYes = 0;)
        traceOnly(cProbesNo  = 0;)

        POSTCONDITION(fullInvariants());
        }
    ~Map() 
        {
        traceOnly(if (cProbes>50) trace((trMap, "~Map() cFinds=%d cYes=%d cNo=%d cProbes=%d cProbesY=%d cProbesN=%d cdr=%u rgd.size()=%d\n", cFinds, cYes, cNo, cProbes, cProbesYes, cProbesNo, cdr, rgd.size()));)
        }
    void reset();
    BOOL map(const D& d, R* pr) const;
    BOOL map(const D& d, R** ppr) const;
    BOOL contains(const D& d) const;
    BOOL add(const D& d, const R& r);
    BOOL remove(const D& d);
    BOOL mapThenRemove(const D& d, R* pr);
//  BOOL save(Buffer* pbuf);
//  BOOL reload(PB* ppb);
    void swap(Map& m);
//  CB   cbSave() const;
    unsigned count() const;
private:
    Array<D, poolType> rgd;
    Array<R, poolType> rgr;
    ISet<poolType> isetPresent;
    ISet<poolType> isetDeleted;
    unsigned cdr;
    traceOnly(unsigned cProbes;)
    traceOnly(unsigned cFinds;)
    traceOnly(unsigned cYes;)
    traceOnly(unsigned cNo;)
    traceOnly(unsigned cProbesYes;)
    traceOnly(unsigned cProbesNo;)

    BOOL find(const D& d, unsigned *pi) const;
    BOOL grow();
    void shrink();
    BOOL fullInvariants() const;
    BOOL partialInvariants() const;
    unsigned cdrLoadMax() const 
        {
        return rgd.size() * 2/4 + 1; // we do not permit the hash table load factor to exceed 50%
        }
    BOOL setHashSize(unsigned size) 
        {
        ASSERT(size >= rgd.size());
        return rgd.setSize(size) && rgr.setSize(size);
        }
    Map(const Map&);
    friend class EnumMap<D,R,H,poolType>;
    };

///////////////////////////////////////////////////////////////////////////////////

template <class D, class R, class H, POOL_TYPE poolType> inline
void Map<D,R,H,poolType>::reset() 
    {
    cdr = 0;
    isetPresent.reset();
    isetDeleted.reset();
    rgd.reset();
    rgr.reset();
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::map(const D& d, R* pr) const 
// do a lookup, returning a copy of the referenced range item
    {
    PRECONDITION(pr);

    R * prT;
    if (map(d, &prT)) 
        {
        *pr = *prT;
        return TRUE;
        }
    return FALSE;
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::map(const D& d, R** ppr) const 
// do a lookup, returning an lvalue of the referenced range item
    {
    PRECONDITION(partialInvariants());
    PRECONDITION(ppr);

    unsigned i;
    if (find(d, &i)) 
        {
        *ppr = &rgr[i];
        return TRUE;
        }
    else
        return FALSE;
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::contains(const D& d) const 
    {
    unsigned iDummy;
    return find(d, &iDummy);
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::add(const D& d, const R& r) 
    {
    PRECONDITION(partialInvariants());

    unsigned i;
    if (find(d, &i)) 
        {
        // some mapping d->r2 already exists, replace with d->r
        ASSERT(isetPresent.contains(i) && !isetDeleted.contains(i) && rgd[i] == d);
        rgr[i] = r;                     // *** set the value - on top of existing value
        }
    else 
        {
        // establish a new mapping d->r in the first unused entry
        ASSERT(!isetPresent.contains(i));
        isetDeleted.remove(i);
        isetPresent.add(i);
        rgd[i] = d;                     // *** asign the key
        rgr[i] = r;                     // *** set the value - newly created value
        grow();
        }

    DEBUG(R rCheck);
    POSTCONDITION(map(d, &rCheck) && r == rCheck);
    POSTCONDITION(fullInvariants());
    return TRUE;
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
void Map<D,R,H,poolType>::shrink() 
    {
    --cdr;
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::remove(const D& d) 
    {
    PRECONDITION(partialInvariants());

    unsigned i;
    if (find(d, &i)) 
        {
        ASSERT(isetPresent.contains(i) && !isetDeleted.contains(i));

        rgr[i] = R();                   // *** destroy the existing value

        isetPresent.remove(i);
        isetDeleted.add(i);             
                                        
        shrink();
        }

    POSTCONDITION(fullInvariants());
    return TRUE;
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::mapThenRemove(const D& d, R* pr) 
    {
    PRECONDITION(partialInvariants());
    PRECONDITION(pr);

    unsigned i;
    if (find(d, &i)) 
        {
        *pr = rgr[i];                   // *** copy the value
        ASSERT(isetPresent.contains(i) && !isetDeleted.contains(i));
        rgr[i] = R();                   // *** destroy the existing value
        isetPresent.remove(i);
        isetDeleted.add(i);
        shrink();
        POSTCONDITION(fullInvariants());
        return TRUE;
        }
    else
        return FALSE;
    }

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::find(const D& d, unsigned *pi) const 
    {
    PRECONDITION(partialInvariants());
    PRECONDITION(pi);

    traceOnly(++((Map<D,R,H,poolType>*)this)->cFinds;)
    traceOnly(unsigned cProbes = 0;)

    H hasher;
    unsigned n      = rgd.size();
    unsigned h      = hasher(d) % n;    // *** hash
    unsigned i      = h;
    unsigned iEmpty = iNil;

    do  {
        traceOnly(++((Map<D,R,H,poolType>*)this)->cProbes;)
        traceOnly(++cProbes;)

        ASSERT(!(isetPresent.contains(i) && isetDeleted.contains(i)));
        if (isetPresent.contains(i)) 
            {
            if (rgd[i] == d)            // *** compare keys
                {
                *pi = i;
                traceOnly(++((Map<D,R,H,poolType>*)this)->cYes;)
                traceOnly(((Map<D,R,H,poolType>*)this)->cProbesYes += cProbes;)
                return TRUE;
                }
            } 
        else 
            {
            if (iEmpty == iNil)
                iEmpty = i;
            if (!isetDeleted.contains(i))
                break;
            }

        i = (i+1 < n) ? i+1 : 0;
        } 
    while (i != h);

    // not found
    *pi = iEmpty;
    POSTCONDITION(*pi != iNil);
    POSTCONDITION(!isetPresent.contains(*pi));
    traceOnly(++((Map<D,R,H,poolType>*)this)->cNo;)
    traceOnly(((Map<D,R,H,poolType>*)this)->cProbesNo += cProbes;)
    return FALSE;
    }

/*
// append a serialization of this map to the buffer
// format:
//  cdr
//  rgd.size()
//  isetPresent
//  isetDeleted
//  group of (D,R) pairs which were present, a total of cdr of 'em
//
template <class D, class R, class H, POOL_TYPE poolType>
BOOL Map<D,R,H,poolType>::save(Buffer* pbuf) 
    {
    PRECONDITION(fullInvariants());

    unsigned size = rgd.size();
    if (!(pbuf->Append((PB)&cdr, sizeof(cdr)) &&
          pbuf->Append((PB)&size, sizeof(size)) &&
          isetPresent.save(pbuf) &&
          isetDeleted.save(pbuf)))
        return FALSE;

    for (unsigned i = 0; i < rgd.size(); i++)
        {
        if (isetPresent.contains(i))
            if (!(pbuf->Append((PB)&rgd[i], sizeof(rgd[i])) &&
                  pbuf->Append((PB)&rgr[i], sizeof(rgr[i]))))
                return FALSE;
        }

    return TRUE;
    }
               
// reload a serialization of this empty NMT from the buffer; leave
// *ppb pointing just past the NMT representation
template <class D, class R, class H, POOL_TYPE poolType>
BOOL Map<D,R,H,poolType>::reload(PB* ppb) 
    {
    PRECONDITION(cdr == 0);

    cdr = *((unsigned UNALIGNED *&)*ppb)++;
    unsigned size = *((unsigned UNALIGNED *&)*ppb)++;

    if (!setHashSize(size))
        return FALSE;

    if (!(isetPresent.reload(ppb) && isetDeleted.reload(ppb)))
        return FALSE;

    for (unsigned i = 0; i < rgd.size(); i++) 
        {
        if (isetPresent.contains(i)) 
            {
            rgd[i] = *((D UNALIGNED *&)*ppb)++;
            rgr[i] = *((R UNALIGNED *&)*ppb)++;
            }
        }

    POSTCONDITION(fullInvariants());
    return TRUE;
    }
*/

template <class D, class R, class H, POOL_TYPE poolType>
BOOL Map<D,R,H,poolType>::fullInvariants() const 
    {
    ISet<poolType> isetInt;
    if (!partialInvariants())                                   return FALSE;
    else if (cdr != isetPresent.cardinality())                  return FALSE;
    else if (!intersect(isetPresent, isetDeleted, isetInt))     return FALSE;
    else if (isetInt.cardinality() != 0)                        return FALSE;
    else
        return TRUE;
    }

template <class D, class R, class H, POOL_TYPE poolType>
BOOL Map<D,R,H,poolType>::partialInvariants() const 
    {
    if (rgd.size() == 0)                                        return FALSE;
    else if (rgd.size() != rgr.size())                          return FALSE;
    else if (cdr > rgd.size())                                  return FALSE;
    else if (cdr > 0 && cdr >= cdrLoadMax())                    return FALSE;
    else
        return TRUE;
    }

// Swap contents with "map", a la Smalltalk-80 become.
template <class D, class R, class H, POOL_TYPE poolType>
void Map<D,R,H,poolType>::swap(Map<D,R,H,poolType>& map) 
    {
    isetPresent.swap(map.isetPresent);
    isetDeleted.swap(map.isetDeleted);
    rgd.swap(map.rgd);
    rgr.swap(map.rgr);
    ::swap(cdr, map.cdr);
    traceOnly(::swap(cProbes,   map.cProbes));
    traceOnly(::swap(cFinds,    map.cFinds));
    traceOnly(::swap(cYes,      map.cYes));
    traceOnly(::swap(cNo,       map.cNo));
    traceOnly(::swap(cProbesNo, map.cProbesNo));
    traceOnly(::swap(cProbesYes,map.cProbesYes));
    }

/*
// Return the size that would be written, right now, via save()
template <class D, class R, class H, POOL_TYPE poolType> inline
CB Map<D,R,H,poolType>::cbSave() const 
    {
    ASSERT(partialInvariants());
    return
        sizeof(cdr) +
        sizeof(unsigned) +
        isetPresent.cbSave() +
        isetDeleted.cbSave() +
        cdr * (sizeof(D) + sizeof(R))
        ;
    }
*/

// Return the count of elements
template <class D, class R, class H, POOL_TYPE poolType> inline
unsigned Map<D,R,H,poolType>::count() const 
    {
    ASSERT(partialInvariants());
    return cdr;
    }

///////////////////////////////////////////////////////////////////////////////////////
//
// Interation
//
///////////////////////////////////////////////////////////////////////////////////////

// EnumMap must continue to enumerate correctly in the presence
// of Map<foo>::remove() being called in the midst of the enumeration.
template <class D, class R, class H, POOL_TYPE poolType>
class EnumMap
    {
public:
    EnumMap()
        {
        pmap = NULL;
        reset();
        }
    EnumMap(const Map<D,R,H,poolType>& map) 
        {
        pmap = &map;
        reset();
        }
    void release() 
        {
        delete this;
        }
    void reset() 
        {
        i = (unsigned)-1;
        }
    BOOL next() 
        {
        while (++i < pmap->rgd.size())
            {
            if (pmap->isetPresent.contains(i))
                return TRUE;
            }
        return FALSE;
        }
    void get(OUT D* pd, OUT R* pr) 
        {
        PRECONDITION(pd && pr);
        PRECONDITION(0 <= i && i < pmap->rgd.size());
        PRECONDITION(pmap->isetPresent.contains(i));

        *pd = pmap->rgd[i];
        *pr = pmap->rgr[i];
        }
    void get(OUT D* pd, OUT R** ppr) 
        {
        PRECONDITION(pd && ppr);
        PRECONDITION(0 <= i && i < pmap->rgd.size());
        PRECONDITION(pmap->isetPresent.contains(i));

        *pd = pmap->rgd[i];
        *ppr = &pmap->rgr[i];
        }
    void get(OUT D** ppd, OUT R** ppr)
        {
        PRECONDITION(ppd && ppr);
        PRECONDITION(0 <= i && i < pmap->rgd.size());
        PRECONDITION(pmap->isetPresent.contains(i));

        *ppd = &pmap->rgd[i];
        *ppr = &pmap->rgr[i];
        }
public:
    const Map<D,R,H,poolType>* pmap;
    unsigned i;
    };

///////////////////////////////////////////////////////////////////////////////////////

template <class D, class R, class H, POOL_TYPE poolType> inline
BOOL Map<D,R,H,poolType>::grow() 
    {
    if (++cdr >= cdrLoadMax()) 
        {
        // Table is becoming too full.  Rehash.  Create a second map twice
        // as large as the first, propagate current map contents to new map,
        // then "become" (Smalltalk-80 style) the new map.
        //
        // The storage behind the original map is reclaimed on exit from this block.
        //
        Map<D,R,H,poolType> map;
        if (!map.setHashSize(2*cdrLoadMax()))
            return FALSE;

        EnumMap<D,R,H,poolType> e(*this);
        while (e.next()) 
            {
            D d; R r;
            e.get(&d, &r);
            if (!map.add(d, r))
                return FALSE;
            }
        (*this).swap(map);
        }
    return TRUE;
    }

#endif // !__TXFMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\jtl\txfiset.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfiset.h
//
#ifndef __TXFISET_H__
#define __TXFISET_H__

#include "txfarray.h"
#include "txftwo.h"

template <POOL_TYPE poolType>
class ISet : public FromPool<poolType>
// dense set of small integers, implemented using a bit array
    {   
public:
    ISet() { }
    ISet(unsigned size) : rgw(size ? words(size - 1) : 0)
        {
        rgw.fill(0);
        }
    ~ISet() { }
    void reset() 
        { 
        rgw.reset();
        }
    BOOL __fastcall contains(unsigned i) const 
        {
        return (i < size()) && (word(i) & bitmask(i));
        }
    BOOL __fastcall add(unsigned i) 
        {
        if (!ensureRoomFor(i))
            return FALSE;
        word(i) |= bitmask(i);
        return TRUE;
        }
    unsigned __fastcall size() const 
        {
        return rgw.size() << lgBPW;
        }
    BOOL __fastcall remove(unsigned i) 
        {
        if (i < size())
            word(i) &= ~bitmask(i);
        return TRUE;
        }
    unsigned cardinality() const 
        {
        unsigned n = 0;
        for (unsigned i = 0; i < rgw.size(); i++)
            n += bitcount(rgw[i]);
        return n;
        }
    friend BOOL intersect(const ISet& s1, const ISet& s2, ISet& iset) 
        {
        iset.reset();
        if (iset.rgw.setSize(min(s1.rgw.size(), s2.rgw.size()))) 
            {
            for (unsigned i = 0; i < iset.rgw.size(); i++)
                iset.rgw[i] = s1.rgw[i] & s2.rgw[i];
            return TRUE;
            } 
        else 
            {
            return FALSE;
            }
        }
/*  BOOL save(Buffer* pbuf) 
        {
        return rgw.save(pbuf);
        }
    BOOL reload(PB* ppb) 
        {
        return rgw.reload(ppb);
        } */
    void swap(ISet& is) 
        {
        rgw.swap(is.rgw);
        }
/*  CB cbSave() const 
        {
        return rgw.cbSave();
        } */
private:
    enum { BPW = 32, lgBPW = 5 };
    Array<ULONG, poolType> rgw;

    ISet(const ISet&);

    unsigned __fastcall index(unsigned i) const 
        {
        return i >> lgBPW;
        }
    unsigned __fastcall words(unsigned i) const 
        {
        return index(i) + 1;
        }
    unsigned __fastcall bit(unsigned i) const 
        {
        return i & (BPW-1);
        }
    ULONG& __fastcall word(unsigned i) 
        {
        return rgw[index(i)];
        }
    const ULONG& __fastcall word(unsigned i) const 
        {
        return rgw[index(i)];
        }
    ULONG bitmask(unsigned i) const 
        {
        return 1 << bit(i);
        }
    BOOL ensureRoomFor(unsigned i) 
        {
        unsigned long zero = 0;
        while (words(i) > (unsigned)rgw.size())
            {
            if (!rgw.append(zero))
                return FALSE;
            }
        return TRUE;
        }
    };

#endif // !__TXFISET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\inc\jtl\txfarray.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfarray.h
//

#ifndef __TXFARRAY_H__
#define __TXFARRAY_H__

template <class T> inline void swap(T& t1, T& t2) 
    {
    T t = t1;
    t1 = t2;
    t2 = t;
    }

#define self (*this)

template <class T, POOL_TYPE poolType> class Array : public FromPool<poolType>
    {
    T* rgt;
    unsigned itMac;
    unsigned itMax;
    enum { itMaxMax = (1<<29) };

public:
    Array() 
        {
        rgt = NULL;
        itMac = itMax = 0;
        }
    Array(unsigned itMac_) 
        {
        rgt = (itMac_ > 0) ? new(poolType) T[itMac_] : 0;
        itMac = itMax = rgt ? itMac_ : 0;
        }
    ~Array() 
        {
        if (rgt) delete [] rgt;
        }
    BOOL isValidSubscript(unsigned it) const 
        {
        return 0 <= it && it < itMac;
        }
    unsigned size() const 
        {
        return itMac;
        }
    unsigned sizeMax() const 
        {
        return itMax;
        }
    BOOL getAt(unsigned it, T** ppt) const 
        {
        if (isValidSubscript(it)) 
            {
            *ppt = &rgt[it];
            return TRUE;
            }
        else
            return FALSE;
        }
    BOOL putAt(unsigned it, const T& t) 
        {
        if (isValidSubscript(it)) 
            {
            rgt[it] = t;
            return TRUE;
            }
        else
            return FALSE;
        }
    T& operator[](unsigned it) const 
        {
        PRECONDITION(isValidSubscript(it));
        return rgt[it];
        }
    BOOL append(const T& t) 
        {
        if (setSize(size() + 1)) 
            {
            self[size() - 1] = t;
            return TRUE;
            } 
        else
            return FALSE;
        }
    void swap(Array& a) 
        {
        ::swap(rgt,   a.rgt);
        ::swap(itMac, a.itMac);
        ::swap(itMax, a.itMax);
        }
    void reset() 
        {
        setSize(0);
        }
    void fill(const T& t) 
        {
        for (unsigned it = 0; it < size(); it++)
            self[it] = t;
        }
//  BOOL        insertAt(unsigned itInsert, const T& t);
//  void        deleteAt(unsigned it);
//  BOOL        insertManyAt(unsigned itInsert, unsigned ct);
//  void        deleteManyAt(unsigned it, unsigned ct);
    BOOL        setSize(unsigned itMacNew);
    BOOL        growMaxSize(unsigned itMaxNew);
    BOOL        findFirstEltSuchThat(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const;
    BOOL        findFirstEltSuchThat_Rover(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const;
    unsigned    binarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const;
//  BOOL        save(Buffer* pbuf) const;
//  BOOL        reload(PB* ppb);
//  CB          cbSave() const;
    };

/*
template <class T, POOL_TYPE poolType> inline BOOL Array<T, poolType>::insertAt(unsigned it, const T& t) 
    {
    PRECONDITION(isValidSubscript(it) || it == size());

    if (setSize(size() + 1)) 
        {
        memmove(&rgt[it + 1], &rgt[it], (size() - (it + 1)) * sizeof(T));
        rgt[it] = t;
        return TRUE;
        }
    else
        return FALSE;
    }

template <class T, POOL_TYPE poolType> inline BOOL Array<T, poolType>::insertManyAt(unsigned it, unsigned ct) 
    {
    PRECONDITION(isValidSubscript(it) || it == size());

    if (setSize(size() + ct)) 
        {
        memmove(&rgt[it + ct], &rgt[it], (size() - (it + ct)) * sizeof(T));
        for (unsigned itT = it; itT < it + ct; itT++) 
            {
            rgt[itT] = T(); // ***
            }
        return TRUE;
        }
    else
        return FALSE;
    }

template <class T, POOL_TYPE poolType> inline void Array<T, poolType>::deleteAt(unsigned it) 
    {
    PRECONDITION(isValidSubscript(it));

    memmove(&rgt[it], &rgt[it + 1], (size() - (it + 1)) * sizeof(T));
    VERIFY(setSize(size() - 1));
    rgt[size()] = T(); // ***
    }

template <class T, POOL_TYPE poolType> inline void Array<T, poolType>::deleteManyAt(unsigned it, unsigned ct) 
    {
    PRECONDITION(isValidSubscript(it));
    
    unsigned ctActual = max(size() - it, ct);

    memmove(&rgt[it], &rgt[it + ctActual], (size() - (it + ctActual)) * sizeof(T));
    VERIFY(setSize(size() - ctActual));
    for (unsigned itT = size(); itT < size() + ctActual; itT++) 
        {
        rgt[itT] = T(); // ***
        }
    }
*/

template <class T, POOL_TYPE poolType> inline
BOOL Array<T, poolType>::growMaxSize(unsigned itMaxNew) 
// Make sure the array is big enough, only grows, never shrinks.
    {
    PRECONDITION(0 <= itMaxNew && itMaxNew <= itMaxMax);

    if (itMaxNew > itMax) 
        {
        // Ensure growth is by at least 50% of former size.
        unsigned itMaxNewT = max(itMaxNew, 3*itMax/2);
        ASSERT(itMaxNewT <= itMaxMax);

        T* rgtNew = new(poolType) T[itMaxNewT]; // ***
        if (!rgtNew)
            return FALSE;
        if (rgt) 
            {
            for (unsigned it = 0; it < itMac; it++)
                rgtNew[it] = rgt[it]; // ***
            delete [] rgt;
            }
        rgt = rgtNew;
        itMax = itMaxNewT;
        }
    return TRUE;
    }


template <class T, POOL_TYPE poolType> inline
BOOL Array<T, poolType>::setSize(unsigned itMacNew) 
// Grow the array to a new size.
    {
    PRECONDITION(0 <= itMacNew && itMacNew <= itMaxMax);

    if (itMacNew > itMax) 
        {
        // Ensure growth is by at least 50% of former size.
        unsigned itMaxNew = max(itMacNew, 3*itMax/2);
        ASSERT(itMaxNew <= itMaxMax);

        T* rgtNew = new(poolType) T[itMaxNew];    // ***
        if (!rgtNew)
            return FALSE;
        if (rgt) 
            {
            for (unsigned it = 0; it < itMac; it++)
                rgtNew[it] = rgt[it];   // ***
            delete [] rgt;
            }
        rgt = rgtNew;
        itMax = itMaxNew;
        }
    else if (itMacNew < itMac)
        {
        for (unsigned it = itMacNew; it<itMac; it++)
            {
            rgt[it] = T();              // *** overwrite deleted guys with empty value
            }
        }
    itMac = itMacNew;
    return TRUE;
    }

/*
template <class T, POOL_TYPE poolType> inline
BOOL Array<T, poolType>::save(Buffer* pbuf) const 
    {
    return pbuf->Append((PB)&itMac, sizeof itMac) && (itMac == 0 || pbuf->Append((PB)rgt, itMac*sizeof(T)));
    }

template <class T, POOL_TYPE poolType> inline
BOOL Array<T, poolType>::reload(PB* ppb) 
    {
    unsigned itMacNew = *((unsigned UNALIGNED *&)*ppb)++;
    if (!setSize(itMacNew))
        return FALSE;
    memcpy(rgt, *ppb, itMac*sizeof(T));
    *ppb += itMac*sizeof(T);
    return TRUE;
    }

template <class T, POOL_TYPE poolType> inline
CB Array<T, poolType>::cbSave() const 
    {
    return sizeof(itMac) + itMac * sizeof(T);
    }
*/

template <class T, POOL_TYPE poolType> inline
BOOL Array<T, poolType>::findFirstEltSuchThat(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const
    {
    for (unsigned it = 0; it < size(); ++it) 
        {
        if ((*pfn)(&rgt[it], pArg)) 
            {
            *pit = it;
            return TRUE;
            }
        }
    return FALSE;
    }

template <class T, POOL_TYPE poolType> inline
BOOL Array<T, poolType>::findFirstEltSuchThat_Rover(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const
    {
    PRECONDITION(pit);

    if (!(0 <= *pit && *pit < size()))
        *pit = 0;

    for (unsigned it = *pit; it < size(); ++it) 
        {
        if ((*pfn)(&rgt[it], pArg)) 
            {
            *pit = it;
            return TRUE;
            }
        }

    for (it = 0; it < *pit; ++it) 
        {
        if ((*pfn)(&rgt[it], pArg)) 
            {
            *pit = it;
            return TRUE;
            }
        }

    return FALSE;
    }

template <class T, POOL_TYPE poolType> inline
unsigned Array<T, poolType>::binarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const
    {
    unsigned itLo = 0;
    unsigned itHi = size(); 
    while (itLo < itHi) 
        {
        // (low + high) / 2 might overflow
        unsigned itMid = itLo + (itHi - itLo) / 2;
        if ((*pfnLE)(&rgt[itMid], pArg))
            itHi = itMid;
        else
            itLo = itMid + 1;
        }
    POSTCONDITION(itLo == 0      || !(*pfnLE)(&rgt[itLo - 1], pArg));
    POSTCONDITION(itLo == size() ||  (*pfnLE)(&rgt[itLo], pArg));
    return itLo;
    }

#undef self

#endif // !__TXFARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\common.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// common.h
//
#include "nonpaged.h"

#include "TxfCommon.h"
#include "IMalloc.h"
#include "txfutil.h"
#include "md5.h"
#include "fixedpoint.h"
#include "probability.h"
#include "InterlockedQueue.h"
#include "Registry.h"
#include "TxfAux.h"
#include "MemoryStream.h"

extern HINSTANCE g_hinst;
extern BOOL      g_fProcessDetach;

extern "C" void StopWorkerQueues();

// Utilties for cleaning up per-process memory in order that 
// PrintMemoryLeaks can do a more reasonable job.
//
extern "C" void ShutdownTxfAux();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\compsmakefileinc.inc ===
#
# makefileinc.inc in txfaux\comps
#

BuildComPs: $(TARGETVIPBIN)\$(TARGET_DIRECTORY)\ComPs.Lib


$(TARGETVIPBIN)\$(TARGET_DIRECTORY)\ComPs.Lib : $(DYNLINK_LIB) $(TARGETVIPBIN)\$(TARGET_DIRECTORY)\ComPsDllLib.Lib
    del $@
    lib /out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\compsdummy.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// dummy.cpp
//
#pragma code_seg("INIT")

#ifdef KERNELMODE

#include "..\stdpch.h"

extern "C" NTSTATUS __stdcall
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,     // our driver object
    IN PUNICODE_STRING RegistryPath     // our registry entry:  \Registry\Machine\System\ControlSet001\Services\"DriverName"
    )
    {
    return 0;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\compssources.inc ===
#
# TxfAux\Dummy
#

TARGETPATH          =$O\..

COFFBASE            =TestDll

MINORCOMP=txf

EXCEPTION_HANDLING      =$(SEHONLY)

#
# Make sure we don't mess up symbols on the build machine
#
CUSTOM_BINPLACE_CMD=


SOURCES=                            \
        ..\ComPsdummy.cpp           \

LINKLIBS=                                   \
        $(TARGETVIPBIN)\*\TxfAuxLib.Lib     \
        $(TARGETVIPBIN)\*\CallFrameDll.Lib         

TARGETLIBS=                                 \
        $(SDK_LIB_PATH)\ntdll.lib           \
        $(VIPLIBS)\ComRegistration.lib


DLLDEF=$O\ComPsTxfAux.def

#
# In user mode, we get some duplicate definition errors which
# we ignore with this force since we don't really care to actually
# run this DLL, only to get its export library.
#
LINKER_FLAGS=$(LINKER_FLAGS) /Force
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\shared\comregistration\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//

#include "unicode.h"

#include <windows.h>
#include <ole2.h>
#include <crtdbg.h>
#include <olectl.h>		// SELFREG_E_CLASS and SELFREG_E_TYPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\shared\comregistration\comregistration.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft Transaction Server (Microsoft Confidential)

 Implementation of a simple utility class that supports registering and 
 unregistering COM classes.                      

 
-------------------------------------------------------------------------------
Revision History:

 @rev 2     | 08/05/97 | BobAtk      | Alternate server types. AppIDs.
 @rev 1     | 07/22/97 | BobAtk      | Adapted to shared code. Made fully Unicode.
                                     | Dynaload OLE Libraries.
 @rev 0     | 07/08/97 | DickD       | Created
---------------------------------------------------------------------------- */

#include "stdpch.h"
#include "ComRegistration.h"
#include <malloc.h>


// BUGBUG: I don't know why this doesn't work.
//         It refuses to find Win4AssertEx (?) so I'm just gonna
//         remove the assert completely
#ifdef Assert
#undef Assert
#endif
#define Assert(x) (0)

//////////////////////////////////////////////////////////////////////////////

static void GetGuidString(const GUID & i_rGuid, WCHAR * o_pstrGuid);
static void DeleteKey(HKEY hKey, LPCWSTR szSubKey);
static void GuardedDeleteKey(HKEY hKey, LPCWSTR szSubKey);
static void DeleteValue(HKEY hKey, LPCWSTR szSubKey, LPCWSTR szValue);
static void SetKeyAndValue
					(HKEY	i_hKey,		// input key handle (may be 0 for no-op)
					LPCWSTR	i_szKey,	// input key string (ptr may be NULL)
					LPCWSTR	i_szVal,	// input value string (ptr may be NULL)
					HKEY *	o_phkOut,   // may be NULL.  If supplied, means leave key handle open for subsequent steps.
                    BOOL fForceKeyCreation=FALSE    // if true, key is created even if no value to be set
                    );
static void SetValue
					(HKEY		i_hKey,	    // input key handle (may be 0 for no-op)
					const WCHAR *i_szName,	// input value name string (ptr may be NULL)
					const WCHAR *i_szVal);	// input value string (ptr may be NULL)
static LPWSTR GetSubkeyValue
                    (HKEY hkey, 
                    LPCWSTR szSubKeyName, 
                    LPCWSTR szValueName, 
                    WCHAR szValue[MAX_PATH]);
static HRESULT UnRegisterTypeLib               
                    (LPCWSTR szModuleName); 

///////////////////////////////////////////////////////////////////////////////

#define HKCR        HKEY_CLASSES_ROOT       // Just to make typing simpler.
#define GUID_CCH    39                      // length of a printable GUID, with braces & trailing NULL

///////////////////////////////////////////////////////////////////////////////

// A utility that accomplishes a non-local jump, giving us an HRESULT 
// to return when we catch it.
//
inline static void THROW_HRESULT(HRESULT hr)
    {
    // Ideally we'd like our own exception code, but this will work fine as
    // no one actually throws it.
    //
	DWORD_PTR newhr = hr;
    RaiseException(NOERROR,EXCEPTION_NONCONTINUABLE,1,&newhr);
    }
inline static HRESULT HRESULTFrom(EXCEPTION_POINTERS* e)
    {
    Assert(e && e->ExceptionRecord && (e->ExceptionRecord->NumberParameters == 1));
    return (HRESULT)e->ExceptionRecord->ExceptionInformation[0];
    }
#define THROW_LAST_ERROR()  THROW_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
#define IS_THROWN_HRESULT() (GetExceptionCode() == NOERROR)
#define HError()            (HRESULT_FROM_WIN32(GetLastError()))


///////////////////////////////////////////////////////////////////////////////

static HRESULT OpenServices(SC_HANDLE* pschSCManager, SC_LOCK* pscLock)
// Open the services database and get the lock
//
    {
    *pschSCManager = OpenSCManager(NULL, NULL, GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE);
    if (*pschSCManager)
        {
        while (true)
            {
            *pscLock = LockServiceDatabase(*pschSCManager);
            if (*pscLock == NULL)
                {
                DWORD dw = GetLastError();
                if (dw != ERROR_SERVICE_DATABASE_LOCKED)
                    {
                    CloseServiceHandle(*pschSCManager);
                    return HError();
                    }
                Sleep(1000);
                }
            else
                break; // got it
            }
        }
    else
        return HError();
    return S_OK;
    }


//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::RegisterClass>
//
//  Makes registry entries under key
//  HKCR\CLASS\{....clsid....}
//-----------------------------------------------------------------------------

HRESULT ClassRegistration::Register()
    {
    HKEY    hkCLSID     = 0;
    HKEY    hkGuid      = 0;
    HKEY    hkProgID    = 0;
    HKEY    hkInproc    = 0;
    DWORD   dwLenFileName;
    WCHAR   szClsid[GUID_CCH];  // string form of CLSID
    WCHAR   szModuleName[MAX_PATH+1];
    EXCEPTION_POINTERS* e;
    HRESULT hr = S_OK;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            // Obtain our module's file name
            Assert(hModule);
            if (hModule == NULL)
                return E_INVALIDARG;
            dwLenFileName = GetModuleFileName(hModule, szModuleName, MAX_PATH);
            if (dwLenFileName == 0)
                {
					//_RPTF0(_CRT_ERROR, "GetModuleFileName returned 0\n");
                return E_UNEXPECTED;
                }
            RegOpenKey(HKCR, L"CLSID", &hkCLSID);

            if (clsid == GUID_NULL)
                return E_INVALIDARG;

            GetGuidString(clsid, szClsid);  // make string form of CLSID 

            // 
            // Set the class name
            //
            SetKeyAndValue(hkCLSID, szClsid, className, &hkGuid, TRUE);

            //
            // Set the appid if asked to
            //
            if (appid != GUID_NULL)
                {
                WCHAR szAppId[GUID_CCH];
                GetGuidString(appid, szAppId);
                SetValue(hkGuid, L"AppID", szAppId);
                //
                // Ensure that the APPID entry exists
                //
                AppRegistration a;
                a.appid = appid;
                hr = a.Register();
                if (!!hr) return hr;
                }

            // Set the appropriate execution information
            // 
            switch (serverType)
                {
            case INPROC_SERVER:
                SetKeyAndValue(hkGuid,   L"InprocServer32", szModuleName, &hkInproc);
                SetValue      (hkInproc, L"ThreadingModel", threadingModel);
                break;
            
            case LOCAL_SERVER:
                SetKeyAndValue(hkGuid,   L"LocalServer32", szModuleName, NULL);
                break;

            case INPROC_HANDLER:
                SetKeyAndValue(hkGuid,   L"InprocHandler32", szModuleName, NULL);
                break;

            case SERVER_TYPE_NONE:
                break;

            default:
                return E_INVALIDARG;
                }
    
            // HKCR\CLSID\{....clsid....}\ProgID = "x.y.1"
            SetKeyAndValue(hkGuid, L"ProgID", progID, NULL);

            // HKCR\CLSID\{....clsid....}\VersionIndependentProgID = "x.y"
            SetKeyAndValue(hkGuid, L"VersionIndependentProgID", versionIndependentProgID, NULL);

            RegCloseKey(hkGuid);
            hkGuid = 0;

            // HKCR\x.y.1 = "Class Name"
            SetKeyAndValue(HKCR, progID, className, &hkProgID);

            //      CLSID = {....clsid....}
            SetKeyAndValue(hkProgID, L"CLSID", szClsid, NULL);
            RegCloseKey(hkProgID);
            hkProgID = 0;

            // HKCR\x.y = "Class Name"
            SetKeyAndValue(HKCR, versionIndependentProgID, className,&hkProgID);

            //      CLSID = {....clsid....}
            SetKeyAndValue(hkProgID, L"CLSID", szClsid, NULL);

            //      CurVer = "x.y.1"
            SetKeyAndValue(hkProgID, L"CurVer", progID, NULL);
            RegCloseKey(hkProgID);
            hkProgID = 0;

            // Register the typelib that's present in this module, if any. Dynaload
            // OLEAUT32 to get there to avoid a static linkage against OLEAUT32
            //
            HINSTANCE hOleAut = LoadLibraryA("OLEAUT32");
            if (hOleAut)
                {
                __try
                    {
                    // Find LoadLibraryEx in OLEAUT32
                    //
                    typedef HRESULT (STDAPICALLTYPE *PFN_T)(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib);
                    PFN_T MyLoadTypeLibEx = (PFN_T) GetProcAddress(hOleAut, "LoadTypeLibEx");

                    if (MyLoadTypeLibEx)
                        {
                        HRESULT hr;
                        ITypeLib * pITypeLib = 0;
                        hr = MyLoadTypeLibEx(szModuleName, REGKIND_REGISTER, &pITypeLib);
                        if (SUCCEEDED(hr))
                            {
                            Assert(pITypeLib);
                            pITypeLib->Release();
                            pITypeLib = 0;
                            }
                        else if (hr == TYPE_E_CANTLOADLIBRARY)
                            {
                            // There was no type lib in the DLL to register. So ignore
                            }
                        else
                            {
                            Assert(pITypeLib == 0);
                            return SELFREG_E_TYPELIB;
                            }
                        }
                    else
                        THROW_LAST_ERROR(); // LoadLibraryEx not found
                    }
                __finally
                    {
                    FreeLibrary(hOleAut);
                    }
                }
            else
                THROW_LAST_ERROR(); // Can't load OLEAUT32

            }

        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        if (hkCLSID)  RegCloseKey(hkCLSID);
        if (hkGuid)   RegCloseKey(hkGuid);
        if (hkProgID) RegCloseKey(hkProgID);
        if (hkInproc) RegCloseKey(hkInproc);
        }

    return S_OK;
    }

//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::UnregisterClass>
//
//  Removes registry entries under key
//  HKCR\CLASS\{....clsid....}
//-----------------------------------------------------------------------------

HRESULT ClassRegistration::Unregister()
    {
    LONG    lRetVal;
    HKEY    hKeyCLSID   = 0;
    HKEY    hKeyGuid    = 0;
    HKEY    hKeyProgID  = 0;
    WCHAR   szClsid[GUID_CCH];
    EXCEPTION_POINTERS* e;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            WCHAR szProgID[MAX_PATH];
            WCHAR szVersionIndependentProgID[MAX_PATH];

            // Get our string form
            //
            GetGuidString(clsid, szClsid);

            // Unregister the type library, if any.
            // 
                {
                WCHAR szModuleName[MAX_PATH+1];
                if (hModule == NULL)
                    return E_INVALIDARG;
                if (GetModuleFileName(hModule, szModuleName, MAX_PATH))
                    UnRegisterTypeLib(szModuleName); // ignore errors so as to continue with unregistration
                }

            //
            // Open the {clsid} key and remove all the gunk thereunder that we know about
            // 
            lRetVal = RegOpenKey(HKCR, L"CLSID", &hKeyCLSID);
            if (lRetVal == ERROR_SUCCESS)
                {
                Assert(hKeyCLSID);
                lRetVal = RegOpenKey(hKeyCLSID, szClsid, &hKeyGuid);
                if (lRetVal == ERROR_SUCCESS)
                    {
                    Assert(hKeyGuid);

                    // Figure out the prog id if they're not provided for us explicitly
                    // Ditto the version independent progID.
                    //
                    if (!progID) progID = 
                        GetSubkeyValue(hKeyGuid, L"ProgID",                   L"", szProgID);
                    if (!versionIndependentProgID) versionIndependentProgID = 
                        GetSubkeyValue(hKeyGuid, L"VersionIndependentProgID", L"", szProgID);

                    // Delete entries under the CLSID. We are conservative, in that
                    // if there are subkeys/values left that we don't know about, we
                    // leave a key intact. This leaks registry space in order to deal
                    // reasonably with a lack of full knowledge.
                    // 
                    // REVIEW: There's more work to do here. Such as dealing with 
                    // COM Categories, PersistentHandler, etc.
                    //
                    // Notably, we do NOT remove any extant TreatAs entry, or any
                    // AutoConvertTo entry, as these can be added by OTHERS in order
                    // to redirect legacy users of the class.
                    //
                    
                    //
                    // AppID entries
                    //
                    DeleteValue     (hKeyGuid, NULL, L"AppID");
                    //
                    // Inproc entries
                    //
                    DeleteValue     (hKeyGuid, L"InprocServer32", L"ThreadingModel");
                    GuardedDeleteKey(hKeyGuid, L"InprocServer32");
                    //
                    // Server keys
                    //
                    GuardedDeleteKey(hKeyGuid, L"LocalServer");
                    GuardedDeleteKey(hKeyGuid, L"InprocHandler");
                    GuardedDeleteKey(hKeyGuid, L"LocalServer32");
                    GuardedDeleteKey(hKeyGuid, L"InprocHandler32");
                    //
                    // Legacy COM categories
                    //
                    GuardedDeleteKey(hKeyGuid, L"Control");
                    GuardedDeleteKey(hKeyGuid, L"Programmable");
                    GuardedDeleteKey(hKeyGuid, L"DocObject");
                    GuardedDeleteKey(hKeyGuid, L"Insertable");
                    GuardedDeleteKey(hKeyGuid, L"Printable");
                    //
                    // OLE entries. We ignore possible subkeys cause we're lazy coders
                    // and because no one in their right mind would store info thereunder
                    // that should stick around after we've nuked the class itself.
                    //
                           DeleteKey(hKeyGuid, L"MiscStatus");
                           DeleteKey(hKeyGuid, L"Verb");
                           DeleteKey(hKeyGuid, L"AuxUserType");
                           DeleteKey(hKeyGuid, L"Conversion");
                           DeleteKey(hKeyGuid, L"DataFormats");
                    GuardedDeleteKey(hKeyGuid, L"ToolBoxBitmap32");
                    GuardedDeleteKey(hKeyGuid, L"DefaultIcon");
                    GuardedDeleteKey(hKeyGuid, L"Version");
                    //
                    // Prog id entries
                    //
                    GuardedDeleteKey(hKeyGuid, L"ProgID");
                    GuardedDeleteKey(hKeyGuid, L"VersionIndependentProgID");

                    RegCloseKey(hKeyGuid);
                    hKeyGuid = 0;
                    }
                //
                // Finally, delete the CLSID entry itself
                //
                GuardedDeleteKey(hKeyCLSID, szClsid);
                RegCloseKey(hKeyCLSID);
                hKeyCLSID = 0;
                }

            // HKEY_CLASSES_ROOT\MTS.Recorder.1
            // HKEY_CLASSES_ROOT\MTS.Recorder.1\CLSID

            if (progID)
                {
                lRetVal = RegOpenKey(HKCR, progID, &hKeyProgID);
                if (lRetVal == ERROR_SUCCESS)
                    {
                    Assert(hKeyProgID);
                    GuardedDeleteKey(hKeyProgID, L"CLSID");
                    RegCloseKey(hKeyProgID);
                    hKeyProgID = 0;
                    GuardedDeleteKey(HKCR, progID);
                    }
                }

            // HKEY_CLASSES_ROOT\MTS.Recorder
            // HKEY_CLASSES_ROOT\MTS.Recorder.1\CLSID
            // HKEY_CLASSES_ROOT\MTS.Recorder.1\CurVer

            if (versionIndependentProgID)
                {
                lRetVal = RegOpenKey(HKCR, versionIndependentProgID, &hKeyProgID);
                if (lRetVal == ERROR_SUCCESS)
                    {
                    Assert(hKeyProgID);
                    GuardedDeleteKey(hKeyProgID, L"CLSID");
                    GuardedDeleteKey(hKeyProgID, L"CurVer");
                    RegCloseKey(hKeyProgID);
                    hKeyProgID = 0;
                    GuardedDeleteKey(HKCR, versionIndependentProgID);
                    }
                }
            }

        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        if (hKeyCLSID)  RegCloseKey(hKeyCLSID);
        if (hKeyGuid)   RegCloseKey(hKeyGuid);
        if (hKeyProgID) RegCloseKey(hKeyProgID);
        }

    return S_OK;
    }

//
//////////////////////////////////////////////////////////////////////////////
//
// Unregister the typelib contained in this module, if any
//

HRESULT UnRegisterTypeLib(LPCWSTR szModuleName)
    {
    HRESULT hr = S_OK;
    HINSTANCE hOleAut = LoadLibraryA("OLEAUT32");
    if (hOleAut)
        {
        __try
            {
            // Find UnRegisterTypeLib etc in OLEAUT32
            //
            typedef HRESULT (STDAPICALLTYPE *PFN_LOAD) (LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib);
            typedef HRESULT (STDAPICALLTYPE *PFN_UNREG)(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
            PFN_LOAD  MyLoadTypeLibEx     = (PFN_LOAD)  GetProcAddress(hOleAut, "LoadTypeLibEx");
            PFN_UNREG MyUnRegisterTypeLib = (PFN_UNREG) GetProcAddress(hOleAut, "UnRegisterTypeLib");

            if (MyLoadTypeLibEx && MyUnRegisterTypeLib)
                {
                // Load the typelib to see what version etc it is
                //
                ITypeLib* ptlb;
                hr = MyLoadTypeLibEx(szModuleName, REGKIND_NONE, &ptlb);
                if (hr==S_OK)
                    {
                    TLIBATTR* pa;
                    hr = ptlb->GetLibAttr(&pa);
                    if (hr==S_OK)
                        {
                        // Do the unregistration
                        //
                        hr = MyUnRegisterTypeLib(pa->guid, pa->wMajorVerNum, pa->wMinorVerNum, pa->lcid, pa->syskind);
                        ptlb->ReleaseTLibAttr(pa);
                        }
                    ptlb->Release();
                    }
                else
                    {
                    // Nothing to unregister, cause we don't have a type lib
                    }
                }
            else
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);  // entry points missing from OLEAUT32 
            }
        __finally
            {
            FreeLibrary(hOleAut);
            }
        }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());  // couldn't load OLEAUT32

    return hr;
    }


//
//////////////////////////////////////////////////////////////////////////////
//
// Register the indicate APPID information
//

HRESULT AppRegistration::Register()
    {
    HRESULT hr = S_OK;
    EXCEPTION_POINTERS* e;
    HKEY hkeyAllAppIds = NULL;
    HKEY hkeyAppId = NULL;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            //
            // Ensure the root HKEY_CLASSES_ROOT\AppID key exists
            //
            SetKeyAndValue(HKEY_CLASSES_ROOT, L"AppID", NULL, &hkeyAllAppIds, TRUE);

            //
            // Ensure that our particular AppID key exists
            //
            if (appid == GUID_NULL) return E_INVALIDARG;
            WCHAR szAppId[GUID_CCH];
            GetGuidString(appid, szAppId);
            SetKeyAndValue(hkeyAllAppIds, szAppId, NULL, &hkeyAppId, TRUE);
                
            //
            // Set the appid name, if asked
            //
            if (appName)
                SetValue(hkeyAppId, NULL, appName);

            //
            // Set the DllSurrogate entry, if asked
            //
            if (dllSurrogate)
                {
                if (hModuleSurrogate)
                    {
                    WCHAR szModuleName[MAX_PATH+1];
                    if (!GetModuleFileName(hModuleSurrogate, szModuleName, MAX_PATH)) return HRESULT_FROM_WIN32(GetLastError());
                    SetValue(hkeyAppId, L"DllSurrogate", szModuleName);
                    }
                else
                    {
                    // Use the default surrogate
                    //
                    SetValue(hkeyAppId, L"DllSurrogate", L"");
                    }
                }
            }
        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        // Cleanup on the way out
        //
        if (hkeyAllAppIds)  RegCloseKey(hkeyAllAppIds);
        if (hkeyAppId)      RegCloseKey(hkeyAppId);
        }
    return hr;
    }

//
//////////////////////////////////////////////////////////////////////////////
//
// Unregister the indicate APPID information
//

HRESULT AppRegistration::Unregister()
    {
    HRESULT hr = S_OK;
    EXCEPTION_POINTERS* e;
    HKEY hkeyAllAppIds = NULL;
    HKEY hkeyAppId = NULL;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, L"AppID", &hkeyAllAppIds))
                {
                //
                // Get our AppID key, if it exists
                //
                if (appid == GUID_NULL) return E_INVALIDARG;
                WCHAR szAppId[GUID_CCH];
                GetGuidString(appid, szAppId);
                if (ERROR_SUCCESS == RegOpenKey(hkeyAllAppIds, szAppId, &hkeyAppId))
                    {
                    //
                    // Delete known values
                    //
                    DeleteValue(hkeyAppId, NULL, L"DllSurrogate");
                    DeleteValue(hkeyAppId, NULL, L"RemoteServerName");
                    DeleteValue(hkeyAppId, NULL, L"ActivateAtStorage");
                    DeleteValue(hkeyAppId, NULL, L"LocalService");
                    DeleteValue(hkeyAppId, NULL, L"ServiceParameters");
                    DeleteValue(hkeyAppId, NULL, L"RunAs");
                    DeleteValue(hkeyAppId, NULL, L"LaunchPermission");
                    DeleteValue(hkeyAppId, NULL, L"AccessPermission");
                    //
                    // Delete our APPID key
                    //
                    RegCloseKey(hkeyAppId); hkeyAppId = 0;
                    GuardedDeleteKey(hkeyAllAppIds, szAppId);
                    }
                }
            }
        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        // Cleanup on the way out
        //
        if (hkeyAllAppIds)  RegCloseKey(hkeyAllAppIds);
        if (hkeyAppId)      RegCloseKey(hkeyAppId);
        }
    return hr;
    }


//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::GetGuidString>
//
//  Forms the string form of a GUID given its binary GUID. Dynaload OLE32.DLL
//  to avoid creating a static linkage. REVIEW: if this function is frequently
//  called then we'd want to cache the loading of OLE32.
//
//-----------------------------------------------------------------------------

static void GetGuidString(const GUID& rGuid, WCHAR * pstrGuid)
    {
    HINSTANCE hInstOle = LoadLibraryA("OLE32");
    if (hInstOle)
        {
        __try
            {
            typedef int (STDAPICALLTYPE* PFN_T)(REFGUID rguid, LPOLESTR lpsz, int cbMax);
            PFN_T MyStringFromGuid = (PFN_T) GetProcAddress(hInstOle, "StringFromGUID2");
            if (MyStringFromGuid)
                {
                int iLenGuid = MyStringFromGuid(rGuid, pstrGuid, GUID_CCH);
                Assert(iLenGuid == GUID_CCH);
                }
            else
                {
                THROW_LAST_ERROR();
                }
            }
        __finally
            {
            FreeLibrary(hInstOle);
            }
        }
    else
        {
        THROW_LAST_ERROR();
        }
    }


//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::GuardedDeleteKey>
//
//  Deletes a key if and only if it has no subkeys and no sub values.
//
//-----------------------------------------------------------------------------

static void DeleteKey(HKEY hKey, LPCWSTR szSubKey)
// Unconditionally delete a key
    {
    RegDeleteKey(hKey, szSubKey);
    }

static void GuardedDeleteKey(HKEY hKey, LPCWSTR szSubKey)
// Conditionally delete a key, only if it lacks children
    {
    HKEY  hSubkey;

    // If there's no subkey of that name, nothing to delete
    //
    if (ERROR_SUCCESS != RegOpenKey(hKey, szSubKey, &hSubkey))
        return;

    DWORD cSubKeys;
    DWORD cValues;
    if (ERROR_SUCCESS == RegQueryInfoKeyA(hSubkey, 
            NULL,   // LPSTR lpClass,
            NULL,   // LPDWORD lpcbClass,
            0,      // LPDWORD lpReserved,
            &cSubKeys,
            NULL,   // LPDWORD lpcbMaxSubKeyLen,
            NULL,   // LPDWORD lpcbMaxClassLen,
            &cValues,
            NULL,   // LPDWORD lpcbMaxValueNameLen,
            NULL,   // LPDWORD lpcbMaxValueLen,
            NULL,   // LPDWORD lpcbSecurityDescriptor,
            NULL    // PFILETIME lpftLastWriteTime
            ))
        {
        RegCloseKey(hSubkey);

        // Don't delete if there are any child keys, or if there are any child values 
        // besides the default value, which is always there (true on Win95; assumed on NT).
        //
        if (cSubKeys > 0 || cValues > 1)
            return;

        RegDeleteKey(hKey, szSubKey);
        }
    else
        {
        RegCloseKey(hSubkey);
        }
    }

///////////////////////////////////////////////////

static void DeleteValue(HKEY hKey, LPCWSTR szSubkey, LPCWSTR szValue)
// Delete the indicated value under the indicated (optional) subkey of the indicated key.
    {
    Assert(hKey);
    if (szSubkey && lstrlenW(szSubkey)>0)
        {
        HKEY hSubKey;
        if (RegOpenKey(hKey, szSubkey, &hSubKey) == ERROR_SUCCESS)
            {
            RegDeleteValue(hSubKey, szValue);
            RegCloseKey(hSubKey);
            }
        }
    else
        RegDeleteValue(hKey, szValue);
    }

//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::SetKeyAndValue>
//
//  Stores a key and its associated value in the registry
//
//-----------------------------------------------------------------------------

static void SetKeyAndValue
        (
        HKEY        i_hKey,     // input key handle (may be 0 for no-op)
        const WCHAR *i_szKey,   // input key string (ptr may be NULL)
        const WCHAR *i_szVal,   // input value string (ptr may be NULL)
        HKEY *      o_phkOut,   // may be NULL.  If supplied, means leave key handle open for subsequent steps.
        BOOL        fForceKeyCreation
        )
    {
    long    lRet    = 0;        // output return code
    HKEY    hKey    = 0;        // new key's handle

    if (o_phkOut)               // init out params in all cases
        *o_phkOut = 0;

    if (i_hKey &&                       // have a parent key to make under
        i_szKey &&                      // got a child key to operate on
        (i_szVal || fForceKeyCreation)  // have a value to set or we really want to make the key anyway
       )                 
        {
        // Create a new key/value pair
        DWORD dwDisposition;
        lRet = RegCreateKeyEx(  i_hKey,         // open key handle 
                                i_szKey,        // subkey name
                                0,              // DWORD reserved 
                                L"",            // address of class string 
                                REG_OPTION_NON_VOLATILE,    // special options flag
                                KEY_ALL_ACCESS, // desired security access
                                NULL,           // address of key security structure
                                &hKey,          // address of buffer for opened handle
                                &dwDisposition);// address of disposition value buffer
        }
    else
        {
        // If we dont make sure the key exists, no point in trying the value
        return;
        }

    if (ERROR_SUCCESS == lRet && i_szVal)
        {
        Assert( (lRet != ERROR_SUCCESS) || hKey );  // if successful, better have got a key
        if (lRet == ERROR_SUCCESS)                  // new key's handle was opened
            {
            lRet = RegSetValueEx
                        (   
                            hKey,       // key handle
                            L"",        // value name (default)
                            0,          // reserved DWORD
                            REG_SZ,     // value type flag
                            (const BYTE *) i_szVal, // value data
                            sizeof(WCHAR) * (lstrlenW(i_szVal)+1) // byte count
                        );
            }
        }
    
    if (lRet != ERROR_SUCCESS)
        {
        if (hKey) RegCloseKey(hKey);
        THROW_LAST_ERROR();
        }
                         
    if (o_phkOut)               // caller wants output key
        {
        *o_phkOut = hKey;       // provide it (it's 0 if we failed)
        }
    else                        // caller doesn't want key
        {
        if (hKey) RegCloseKey(hKey);
        }

    } //end SetKeyAndValue

//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::SetValue>
//
//  Stores a name and its associated value in the registry
//  Note: this function takes an INPUT return code as well
//      as the more obvious input parameters.
//      The idea is that we can avoid a chain of return code
//      tests in the main line, we just can just keep calling
//      this function and it ceases to try to do work once the
//      return code is set to a non-zero value.
//
//-----------------------------------------------------------------------------
 
static void SetValue
        (
        HKEY        i_hKey,     // input key handle (may be 0 for no-op)
        const WCHAR *i_szName,  // input name string (ptr may be NULL)
        const WCHAR *i_szVal    // input value string (ptr may be NULL)
        )   
    {

    if (i_szVal &&              // non-null input value pointer (if NULL, we don't attempt to set)
        i_hKey)                 // non-zero input key handle
        {
        LONG lRet = RegSetValueEx
                    (
                        i_hKey,     // input key handle
                        i_szName,   // value name string (NULL for default value)
                        0,          // reserved DWORD
                        REG_SZ,
                        (const BYTE *) i_szVal, // value data
                        sizeof(WCHAR) * (lstrlenW(i_szVal)+1) // byte count
                    );
        if (lRet != ERROR_SUCCESS)
            THROW_LAST_ERROR();
        }
    
    } // end SetValue

////////////////////////////////////////////////////////////////////////////////

static LPWSTR GetSubkeyValue(HKEY hkey, LPCWSTR szSubKeyName, LPCWSTR szValueName, WCHAR szValue[MAX_PATH])
    {
    HKEY hSubkey;
    LPWSTR result = NULL;
    if (ERROR_SUCCESS == RegOpenKey(hkey, szSubKeyName, &hSubkey))
        {
        DWORD dwType;
        DWORD cbData = MAX_PATH * sizeof(WCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx(hSubkey, szValueName, 0, &dwType, (BYTE*)szValue, &cbData))
            {
            result = &szValue[0];            
            }
        RegCloseKey(hSubkey);
        }
    return result;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\debug.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// debug.cpp
//
#include "stdpch.h"
#include "common.h"

#if !defined(KERNELMODE)

ULONG _cdecl DbgPrint(PCH szFormat, ...)
// This is the user-mode implementation; the kernel mode implementation is in the system
//
    {
    va_list va;
    va_start(va, szFormat);

    char szBuffer[1024];
    char* pch = &szBuffer[0];
    _vsnprintf(pch, 1024, szFormat, va);
    OutputDebugStringA(&szBuffer[0]);

    va_end(va);
    return 0;
    }

#endif


//////////////////////////////////////////////////////////////////////////
//
// Tracing utilities
//
//////////////////////////////////////////////////////////////////////////

#include <malloc.h> // for _alloca

void PrintNoMemory()
    {
    DbgPrint("** Insufficient memory to print message **");
    }


void Print(const char * sz, ...)
// printf clone 
    {
    va_list va;
    va_start (va, sz);

    PrintVa(sz, va);

    va_end(va);
    }


void PrintVa(PCSZ szFormat, va_list va)
    {
    char buffer[256];
    if (buffer)
        {
        THREADID dwThreadId = GetCurrentThreadId();
        _vsnprintf(buffer, 256, szFormat, va);
        #ifdef KERNELMODE
            DbgPrint("%4xk: %s", dwThreadId, buffer);
        #else
            DbgPrint("%4x:  %s", dwThreadId, buffer);
        #endif
        }
    else
        PrintNoMemory();
    }


#ifdef _DEBUG

////////////////////////////////////////////////////////////////////////////////

void __stdcall _DebugTrace(PCSZ szModule, ULONG tracingIndent, PCSZ szFormat, va_list va)
    {
    char buffer[1024];
    if (buffer)
        {
        // Pad with blanks according to the current tracing indent
        //
        char* pch    = &buffer[0];
        char* pchMax = &buffer[1024];
        for (ULONG i=0; i<tracingIndent; i++)
            {
            *pch++ = ' ';
            *pch++ = ' ';
            }
        *pch = 0;

        THREADID dwThreadId = GetCurrentThreadId();

#ifndef _WIN64
        _vsnprintf(pch, pchMax-pch, szFormat, va);
#else
        _vsnprintf(pch, PtrToUlong(pchMax)-PtrToUlong(pch), szFormat, va);
#endif

        #ifdef KERNELMODE
            DbgPrint("%4xk:%s: %s\n", dwThreadId, szModule, buffer);
        #else
            DbgPrint("%4x: %s: %s\n", dwThreadId, szModule, buffer);
        #endif
        }
    else
        PrintNoMemory();
    }

////////////////////////////////////////////////////////////////////////////////
//
// REVIEW: Replace with a per-thread count
//

ULONG tracingIndent;

void TracingIndentIncrement()
{
    InterlockedIncrement(&tracingIndent);
}

void TracingIndentDecrement()
{
    InterlockedDecrement(&tracingIndent);
}

ULONG GetTracingIndent()
{
    return tracingIndent;
}

////////////////////////////////////////////////////////////////////////////////

extern ULONG GetCallFrameTracing();

// For your reference...
#define TRACE_COPY          0x40000000
#define TRACE_FREE          0x20000000
#define TRACE_MARSHAL       0x10000000
#define TRACE_UNMARSHAL     0x08000000
#define TRACE_MEMORY        0x04000000
#define TRACE_TYPEGEN       0x02000000
#define TRACE_ANY          (0xFFFFFFFF)

//static ULONG g_TracingLevel = TRACE_ANY
static ULONG g_TracingLevel = 0;

ULONG GetTracing()
{
	//return GetCallFrameTracing();
	return g_TracingLevel;
}


#endif

extern "C" void ShutdownCallFrame();

extern "C"
void ShutdownTxfAux()
{
    ShutdownCallFrame();
}

////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\concurrent.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Concurrent.cpp
//
// Concurrency control support
//
#include "stdpch.h"
#include "common.h"


#ifndef KERNELMODE

/////////////////////////////////////////////////////////////////////
//
// Some debug & trace support
//

// BUGBUG (JohnStra): On managing to get the magic comps.lib functionality
// working for IA64, I ran into AVs during the unwinding in the finally
// block.  For now, I'm disabling this for IA64.
#if defined(_DEBUG) && !defined(IA64) 
    #define PUBLIC_ENTRY    ASSERT(!m_lock.WeOwnExclusive()); __try {
    #define PUBLIC_EXIT(x)  } __finally { ASSERT(!m_lock.WeOwnExclusive()); x; }
#else
    #define PUBLIC_ENTRY
    #define PUBLIC_EXIT(x)
#endif

#if 0 && defined(_DEBUG)
#define TRACE0(x)  Print(x)
#define TRACE(x,y) Print(x,y)
#else
#define TRACE0(x)   0
#define TRACE(x,y)  0
#endif


////////////////////////////////////////////////////////////////////
//
// User mode implementation of XSLOCK
//
// This design was lifted from the kernel mode NT implementation of
// ERESOURCE, in ntos\ex\resource.c
//
////////////////////////////////////////////////////////////////////

XSLOCK::XSLOCK()
    {
    m_cOwner                = 0;
    m_isOwnedExclusive      = FALSE;
    m_cExclusiveWaiters     = 0;
    m_cSharedWaiters        = 0;
    m_ownerTable            = NULL;
    m_lock.FInit();
    DEBUG(fCheckInvariants  = TRUE;)
    DEBUG(CheckInvariants());
    }

XSLOCK::~XSLOCK()
    {
    if (m_ownerTable) FreeMemory(m_ownerTable);
    }

////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

void XSLOCK::CheckInvariants()
    {
    ASSERT(fCheckInvariants == FALSE || fCheckInvariants == TRUE);
    if (fCheckInvariants)
        {
        if (IsSharedWaiting())
            {
            ASSERT(m_isOwnedExclusive || IsExclusiveWaiting());
            ASSERT(m_cOwner > 0);
            }

        if (IsExclusiveWaiting())
            {
            ASSERT(m_cOwner > 0);
            }
        }
    }

#endif

////////////////////////////////////////////////////////////////////

inline void XSLOCK::LockEnter() 
    { 
    ASSERT(!m_lock.WeOwnExclusive()); 
    m_lock.LockExclusive(); 
    DEBUG(CheckInvariants();)
    }

inline void XSLOCK::LockExit()
    { 
    ASSERT(m_lock.WeOwnExclusive()); 
    DEBUG(CheckInvariants();)
    m_lock.ReleaseLock(); 
    ASSERT(!m_lock.WeOwnExclusive());
    }



inline BOOL XSLOCK::IsExclusiveWaiting()
    {
    return m_cExclusiveWaiters > 0;
    }

inline BOOL XSLOCK::IsSharedWaiting()
    {
    return m_cSharedWaiters > 0;
    }

inline void XSLOCK::LetSharedRun()
// Let the shared guys run. Must be called
//      a) with shared guys waiting
//      b) with the lock held
// This function releases the lock as a side effect.
//
    {
    ASSERT(m_lock.WeOwnExclusive());

    ASSERT(IsSharedWaiting());
    m_isOwnedExclusive  = FALSE;
    ULONG cWaiters      = m_cSharedWaiters;
    m_cSharedWaiters    = 0;
    m_cOwner            = cWaiters;
    LockExit();

    ASSERT(!m_lock.WeOwnExclusive());

    m_semaphoreSharedWaiters.Release(cWaiters);
    }

inline void XSLOCK::LetExclusiveRun()
// Leth the exclusive guys run. Must be called
//      a) with exclusive guys waiting
//      b) with the lock held
// This function releases the lock as a side effect.
//
    {
    ASSERT(m_lock.WeOwnExclusive());

    ASSERT(IsExclusiveWaiting());
    m_isOwnedExclusive           = TRUE;
    m_ownerThreads[0].dwThreadId = (THREADID)1;   // will be set correctly later by the waiter who runs waiter
    m_ownerThreads[0].ownerCount = 1;
    m_cOwner                     = 1;
    m_cExclusiveWaiters         -= 1;
    LockExit();
    
    m_eventExclusiveWaiters.Set();      // an auto-reset event, so just lets one guy through
    }


static DWORD tlsIndexOwnerTableHint; // set to zero by the loader

static void AllocateTlsIndexOwnerTableHint()
// Allocate a tls index and atomically set it as our hint
{
    // Allocate a new index. Waste index zero if we happen to get it, since
    // it interferes with our ability to tell if we've initialized things yet
    // or not.
    //
    DWORD tlsIndex;
    do  
    {
        tlsIndex = TlsAlloc();
    }
    while (tlsIndex == 0);
    
    if (tlsIndex != 0xFFFFFFFF)
    {
        if (0 == InterlockedCompareExchange(&tlsIndexOwnerTableHint, tlsIndex, 0))
        {
            // We successfully set our new index
        }
        else
        {
            // Someone else got there before us; we don't need the one we just allocated.
            //
            TlsFree(tlsIndex);
        }
    }
}

inline void XSLOCK::SetOwnerTableHint(THREADID dwThreadId, XSLOCK::OWNERENTRY* pOwnerEntry)
// Set the owner table hint for the indicated thread, if we can.
{
    // Don't gratuitiously mess up other thread's hints!
    //
    if (dwThreadId == GetCurrentThreadId())
    {
        // Make sure we have a tls index to work with
        //
        if (tlsIndexOwnerTableHint == 0)
        {
            AllocateTlsIndexOwnerTableHint();
        }
        
        if (tlsIndexOwnerTableHint != 0)
        {
            //
            // Set up the hint
            //
            ASSERT(m_ownerTable);
#ifndef _WIN64
            ULONG iHint;
#else
            ULONGLONG iHint;
#endif
            iHint = (ULONG)(pOwnerEntry - m_ownerTable);
            ASSERT(1 <= iHint && iHint < m_ownerTable->tableSize);
            TlsSetValue(tlsIndexOwnerTableHint, (PVOID)iHint);
        }
    }
}

inline ULONG XSLOCK::GetOwnerTableHint(THREADID dwThreadId)
// Return a hint as to where we should look for this thread in the owner table array
{
    ASSERT(m_ownerTable);
    //
    // Don't gratuitiously mess up other thread's hints!
    //
    if (dwThreadId == GetCurrentThreadId() && tlsIndexOwnerTableHint != 0)
    {
        // iHint can come back zero if we've allocated tlsIndexOwnerTableHint but
        // have yet to ever actually set any TLS. Since it's only a hint, we just
        // ignore any bogus values.
        //
        ULONG iHint;
#ifndef _WIN64
        iHint = (ULONG)TlsGetValue(tlsIndexOwnerTableHint);
#else
        iHint = PtrToUlong(TlsGetValue(tlsIndexOwnerTableHint));
#endif
        if (iHint == 0 || iHint >= m_ownerTable->tableSize)
            iHint = 1;
        return iHint;
    }
    else
        return 1;
}

////////////////////////////////////////////////////////////////////

BOOL XSLOCK::LockShared(BOOL fWait)
{
    DEBUG(BOOL fAcquired = TRUE);
    PUBLIC_ENTRY
		
	LockEnter();
	
    THREADID dwThreadId = GetCurrentThreadId();
    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //
    if (m_cOwner == 0) 
	{
        m_ownerThreads[1].dwThreadId = dwThreadId;
        m_ownerThreads[1].ownerCount = 1;
        m_cOwner                     = 1;
        LockExit();
        return true;
	}
    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count.
    //
    if (m_isOwnedExclusive && (m_ownerThreads[0].dwThreadId == dwThreadId)) 
	{
        m_ownerThreads[0].ownerCount += 1;
		
        LockExit();
        return true;
	}
    //
    // Take the long way home
    //
    OWNERENTRY* pOwnerEntry = NULL;
    if (m_isOwnedExclusive)
	{
        // The resource is owned exclusive, but not by us.  We'll have to wait.
        // Find an empty entry in the thread array.
        //
        pOwnerEntry = FindThreadOrFree(THREADID(0));
	}
    else
	{
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count.
        //
        pOwnerEntry = FindThreadOrFree(dwThreadId);
		if (pOwnerEntry == NULL)
		{
			LockExit();
			return false;
		}
		
        if (pOwnerEntry->dwThreadId == dwThreadId) 
		{
            ASSERT(pOwnerEntry->ownerCount != 0);
            pOwnerEntry->ownerCount += 1;
            ASSERT(pOwnerEntry->ownerCount != 0);
			
            LockExit();
            return true;
		}
        //
        // This thread doesn't _already_ have shared access, so before we
        // grant it we need to see if there are any exclusive guys waiting.
        //
        // If there aren't, then we can grant. But if there are, then to avoid
        // starving them we need to defer the shared grant here until after
        // an exclusive has had its turn
        //
        if (!IsExclusiveWaiting())
		{
            pOwnerEntry->dwThreadId = dwThreadId;
            pOwnerEntry->ownerCount = 1;
            m_cOwner               += 1;
			
            LockExit();
            return true;
		}
	}
    //
    // The resource is either owned exclusive by some other thread, OR it is 
    // owned shared by some other threads, but there is an exclusive
    // waiter and the current thread does not already have shared access
    // to the resouce.
    //
    if (!fWait)
	{
        // He's not going to let us wait. So don't.
        //
        LockExit();
        DEBUG(fAcquired = FALSE);
        return false;
	}
    //
    // If the shared wait semphore has not yet been allocated, then allocate
    // and initialize it.
    //
    if (!m_semaphoreSharedWaiters.IsInitialized())
	{
        m_semaphoreSharedWaiters.Initialize();
	}
    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //
    pOwnerEntry->dwThreadId = dwThreadId;
    pOwnerEntry->ownerCount = 1;
    m_cSharedWaiters       += 1; ASSERT(IsSharedWaiting());
    
    LockExit();
	
    TRACE("XSLOCK 0x%08x:   ... waiting on shared ...\n", this);
    m_semaphoreSharedWaiters.Wait();
    TRACE("XSLOCK 0x%08x:   ... wait on shared done ...\n", this);
	
    PUBLIC_EXIT( fAcquired ? TRACE("XSLOCK 0x%08x: acquired shared\n", this) : TRACE("XSLOCK 0x%08x: couldn't wait to acquire shared\n", this) );
    return true;
}

////////////////////////////////////////////////////////////////////

inline XSLOCK::OWNERENTRY* XSLOCK::FindThread(THREADID dwThreadId)
// Find the owner entry for the indicated thread. The caller guarantees
// us that it is in there somewhere!
//
    {
    OWNERENTRY* pOwner = NULL;
    //
    // Try the likely suspects
    //
    if (m_ownerThreads[1].dwThreadId == dwThreadId) 
        {
        pOwner = &m_ownerThreads[1];
        } 
    else if (m_ownerThreads[0].dwThreadId == dwThreadId)
        {
        pOwner = &m_ownerThreads[0];
        }
    else 
        {
        // Search the owner table for a match. We know it's there somewhere!
        //
        ASSERT(m_ownerTable);
        //
        // Try first with the ownerTableHint on the current thread
        //
        ULONG iHint = GetOwnerTableHint(dwThreadId);
        ASSERT(1 <= iHint && iHint < m_ownerTable->tableSize);
        if (m_ownerTable[iHint].dwThreadId == dwThreadId)
            {
            // The hint matched!
            //
            pOwner = &m_ownerTable[iHint];
            }
        else
            {
            // Hint didn't match. Scan for the thing
            //
            pOwner = &m_ownerTable[1];
            while (true)
                {
                if (pOwner->dwThreadId == dwThreadId)
                    break;
                pOwner++;
                }
            }
        }    
    ASSERT(pOwner);
    return pOwner;
    }

////////////////////////////////////////////////////////////////////

XSLOCK::OWNERENTRY* XSLOCK::FindThreadOrFree(THREADID dwThreadId)
// This function searches for the specified thread in the resource
// thread array. If the thread is located, then a pointer to the
// array entry is returned as the fucntion value. Otherwise, a pointer
// to a free entry is returned.
//
    {
    // Search the owner threads for the specified thread and return either
    // a pointer to the found thread or a pointer to a free thread table entry.
    //
    if (m_ownerThreads[0].dwThreadId == dwThreadId)
        {
        return &m_ownerThreads[0];
        }
    else if (m_ownerThreads[1].dwThreadId == dwThreadId)
        {
        return &m_ownerThreads[1];
        }

    OWNERENTRY* pFreeEntry = NULL;
    BOOL fInOwnerTable = FALSE;
    if (m_ownerThreads[1].dwThreadId == THREADID(0))
        {
        pFreeEntry = &m_ownerThreads[1];
        }

    ULONG oldSize;
    if (m_ownerTable == NULL)
        {
        oldSize = 0;
        }
    else
        {
        // Scan the existing table, looking for the thread
        //
        oldSize = m_ownerTable->tableSize;
        OWNERENTRY* pOwnerBound = &m_ownerTable[oldSize];
        OWNERENTRY* pOwnerEntry = &m_ownerTable[1];
        do  {
            if (pOwnerEntry->dwThreadId == dwThreadId) 
                {
                // Found the thread! Set the thread's 
                // ownerTableHint and return the entry.
                //
                SetOwnerTableHint(dwThreadId, pOwnerEntry);
                return pOwnerEntry;
                }
            if ((pFreeEntry == NULL) && (pOwnerEntry->dwThreadId == THREADID(0))) 
                {
                pFreeEntry = pOwnerEntry;
                fInOwnerTable = TRUE;
                }
            pOwnerEntry++;
            } 
        while (pOwnerEntry < pOwnerBound);
        }
    //
    // We didn't find the entry. If we found a free entry, though,
    // then return it.
    //
    if (pFreeEntry != NULL)
        {
        // Set the  thread's ownerTableHint
        //
        if (fInOwnerTable) SetOwnerTableHint(dwThreadId, pFreeEntry);
        return pFreeEntry;
        }
    //
    // Allocate an expanded owner table
    //
    ULONG newSize;
    if (oldSize == 0)
        newSize = 3;
    else
        newSize = oldSize + 4;

    ULONG cbOldTable = oldSize * sizeof(OWNERENTRY);
    ULONG cbNewTable = newSize * sizeof(OWNERENTRY);

    OWNERENTRY* ownerTable = (OWNERENTRY*)AllocateMemory(cbNewTable);
    if (ownerTable)
        {
        // Init new table from old one
        //
        memset(ownerTable, 0, cbNewTable);
        memcpy(ownerTable, m_ownerTable, cbOldTable);
        ownerTable->tableSize = newSize;
        //
        // Free old table and keep the new one
        //
        if (m_ownerTable) FreeMemory(m_ownerTable);
        m_ownerTable = ownerTable;
        //
        // Return one of the now available free entries
        //
        if (oldSize == 0) 
            oldSize++;                  // skip first table entry (contains tablesize)

        // Set the  thread's ownerTableHint and return the 
        // newly-created free entry.
        //
        pFreeEntry = &m_ownerTable[oldSize];
        SetOwnerTableHint(dwThreadId, pFreeEntry);
        ASSERT(pFreeEntry->dwThreadId == THREADID(0));
        return pFreeEntry;
        }
    else
        {
        // We really can't continue here.
        // 
        FATAL_ERROR();
        return 0;
        }
    }

////////////////////////////////////////////////////////////////////

BOOL XSLOCK::LockExclusive(BOOL fWait)
    {
    // Do some debugging checks to help detect deadlocks
    //
    #ifdef _DEBUG
    BOOL fAcquired = TRUE;
    if (fWait && WeOwnShared())
        {
        ASSERTMSG("Deadlock: acquiring an XSLOCK exclusive while we hold it shared\n", FALSE);
        }
    #endif

    PUBLIC_ENTRY
    LockEnter();

    THREADID dwThreadId = GetCurrentThreadId();
    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //
    if (m_cOwner != 0) 
        {
        // The resource is either owned exclusive or shared.
        //
        // If the resource is owned exclusive and the current thread is the
        // owner, then increment the recursion count.
        //
        if (m_isOwnedExclusive && m_ownerThreads[0].dwThreadId == dwThreadId)
            {
            m_ownerThreads[0].ownerCount += 1;
            }
        else
            {
            // The resource is either owned exclusive by some other thread, or owned shared.
            //
            // We need to wait.
            //
            if (!fWait)
                {
                LockExit();
                DEBUG(fAcquired = FALSE);
                return false;
                }
            //
            // If the exclusive wait event has not yet been allocated, then the
            // long path code must be taken.
            //
            if (!m_eventExclusiveWaiters.IsInitialized())
                {
                m_eventExclusiveWaiters.Initialize(/*manual reset*/ FALSE, /*initial state*/ FALSE);
                LockExit();
                //
                // Recurse
                //
                return LockExclusive(fWait);
                }
            else
                {
                // Wait for exclusive access to the resource to be granted and set the
                // owner thread.
                //
                m_cExclusiveWaiters += 1; ASSERT(IsExclusiveWaiting());
                LockExit();
                TRACE("XSLOCK 0x%08x:   ... waiting on exclusive ...\n", this);
                m_eventExclusiveWaiters.Wait();
                TRACE("XSLOCK 0x%08x:   ... wait on exclusive done ... \n", this);
                //
                // N.B. It is "safe" to store the owner thread without obtaining any
                //      locks since this thread has now been granted exclusive
                //      ownership.
                //
                m_ownerThreads[0].dwThreadId = dwThreadId;
                return true;
                }            
            NOTREACHED();
            }
        }
    else
        {
        // The resource is not owned. Grant us exclusive.
        //
        m_isOwnedExclusive           = TRUE;
        m_ownerThreads[0].dwThreadId = dwThreadId;
        m_ownerThreads[0].ownerCount = 1;
        m_cOwner                     = 1;
        }

    LockExit();
    PUBLIC_EXIT( fAcquired ? TRACE("XSLOCK 0x%08x: acquired exclusive\n", this) : TRACE("XSLOCK 0x%08x: couldn't wait to acquire exclusive\n", this) );

    return true;
    }

////////////////////////////////////////////////////////////////////

void XSLOCK::ReleaseLock()
    {
    PUBLIC_ENTRY

    LockEnter();
    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    if (m_isOwnedExclusive)
        {
        // The lock is held exclusive. Since we're releasing the lock we
        // believe we hold the lock. Thus, that exclusive guy better be us!
        //
        ASSERT(m_ownerThreads[0].dwThreadId == GetCurrentThreadId());
        //
        // Decrement the recursion count and check if ownership can be released.
        //
        ASSERT(m_ownerThreads[0].ownerCount > 0);
        if (--m_ownerThreads[0].ownerCount != 0) 
            {
            LockExit();
            return;
            }
        //
        // Clear the owner thread.
        //
        m_ownerThreads[0].dwThreadId = 0;
        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //
        ASSERT(m_cOwner > 0); // REVIEW: Can this ever be >1? This is exclusive after all...
        if (--m_cOwner == 0) 
            {
            // If there are shared waiters, then grant shared access to the
            // resource. That is, let pending shareds go after each exclusive
            // is done so as to avoid starvation of the shareds.
            //
            if (IsSharedWaiting())
                {
                LetSharedRun();
                return;
                }
            //
            //  Otherwise, grant exclusive ownership if there are exclusive waiters.
            //
            else if (IsExclusiveWaiting())
                {
                LetExclusiveRun();
                return;
                }
            //
            // Otherwise we're just sitting pretty for the next lock request to come along
            //
            else
                m_isOwnedExclusive = FALSE;
            }
        }
    else
        {
        // The lock is held shared. Release the shared lock.
        //
        THREADID dwThreadId = GetCurrentThreadId();
        OWNERENTRY* pOwner = FindThread(dwThreadId);
        //
        // Decrement the recursion count and check if ownership can be released.
        //
        ASSERT(pOwner->dwThreadId == dwThreadId);
        ASSERT(pOwner->ownerCount > 0);
        if (--pOwner->ownerCount != 0) 
            {
            // Nope: this thread still has a lock
            //
            LockExit();
            return;
            }
        //
        // Yep. This thread now no longer has a lock. Clear the owner thread identity.
        //
        pOwner->dwThreadId = 0;
        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //
        ASSERT(m_cOwner > 0);
        if (--m_cOwner == 0) 
            {
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //
            if (IsExclusiveWaiting()) 
                {
                LetExclusiveRun();
                return;
                }
            }
        }

    LockExit();

    PUBLIC_EXIT(TRACE("XSLOCK 0x%08x: released\n", this));
    }


////////////////////////////////////////////////////////////////////
//
// Demote an exclusive lock to shared access. Similar in function to releasing an
// exclusive resource and then acquiring it for shared access; however the user calling 
// Demote may not necessarily relinquish access to the resource as the two step operation does.

void XSLOCK::Demote()    
    {
    PUBLIC_ENTRY
    LockEnter();

    ASSERT(m_isOwnedExclusive);
    ASSERT(m_ownerThreads[0].dwThreadId == GetCurrentThreadId());
    //
    // Convert the granted access from exclusive to shared.
    //
    m_isOwnedExclusive = FALSE;
    //
    // If there are any shared waiters, then grant them shared access.
    //
    if (IsSharedWaiting()) 
        {
        LetSharedRun();
        return;
        }
    
    LockExit();
    PUBLIC_EXIT(0);
    }

////////////////////////////////////////////////////////////////////
//

BOOL XSLOCK::WeOwnExclusive()
// This routine determines if a resource is acquired exclusive by the calling thread
//
    {
    BOOL fResult;
    LockEnter();

    fResult = m_isOwnedExclusive && (m_ownerThreads[0].dwThreadId == GetCurrentThreadId());

    LockExit();
    return fResult;
    }

BOOL XSLOCK::WeOwnShared()
// Answer as to whether this guy owns this lock shared but not exclusive. If it is owned
// shared, then it'll be a deadlock if we then try to get it exclusive.
{
    BOOL fResult = FALSE;
    LockEnter();
	
    if (m_isOwnedExclusive)
	{
        // If it's owned exclusive, then there's no way we can be owning it just-shared at the moment
        //
	}
    else
	{
        // No own owns it exclusive. If we own it all, then we must own it shared
        //
		THREADID dwThreadId = GetCurrentThreadId();
        OWNERENTRY* pOwnerEntry = FindThreadOrFree(dwThreadId);
		if (pOwnerEntry)
		{
			if (pOwnerEntry->dwThreadId == dwThreadId) 
            {
				ASSERT(pOwnerEntry->ownerCount != 0);
				fResult = TRUE;
            }
        }
	}
		
	LockExit();
	return fResult;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\iid.c ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// iid.c
//
#include "txfaux_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\loader.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Loader.cpp
//
// REVIEW: Are these used any more? At all?
//
#include "stdpch.h"
#include "common.h"

#if !defined(KERNELMODE)

///////////////////////////////////////////////////////////////////////////////////
//
// User mode implementations just call the Win32 apis and dig out the return value
//

HRESULT LoadLibrary(LPCWSTR name, HANDLE* ph)
    {
    *ph = LoadLibraryW(name);
    if (NULL == *ph)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        return S_OK;
    }

HRESULT FreeLibrary(HANDLE h)
    {
    if (!FreeLibrary(h))
        return HRESULT_FROM_WIN32(GetLastError());
    else
        return S_OK;
    }

HRESULT GetProcAddress(HANDLE h, LPCSTR name, LPVOID* ppfn)
    {
    *ppfn = GetProcAddress((HMODULE)h, name);
    if (NULL == *ppfn)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        return S_OK;
    }


#else

///////////////////////////////////////////////////////////////////////////////////
//
// Kernel mode implementations are a lot more work. NOT YET IMPLEMENTED.
//

HRESULT LoadLibrary(LPCWSTR name, HANDLE* ph)
    {
    HRESULT hr = E_NOTIMPL;
    *ph = NULL;
    return hr;
    }

HRESULT FreeLibrary(HANDLE h)
    {
    HRESULT hr = E_NOTIMPL;
    return hr;
    }

HRESULT GetProcAddress(HANDLE h, LPCSTR name, LPVOID* ppfn)
    {
    HRESULT hr = E_NOTIMPL;
    *ppfn = NULL;
    return hr;
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\flushbuffers.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// flushbuffers.cpp
//
// An implementation of ZwFlushBuffersFile. We'd of course would rather use the 
// actual implementation found in 
//
//      nt\private\ntos\io\misc.c
//
// but regrettably and annoyingly that is not exported from ntoskrnl.exe. However,
// the function IS exported to user mode as NtFlushBuffersFile. So what we do
// is use the entry in the system service table sitting on the thread, which
// it turns out can get us to the ZwFlushBuffersFile entry point we need.
//
#include "stdpch.h"
#include "common.h"

#ifdef KERNELMODE

static void CantContinue()
// A routine that deals us a fatal blow if we find ourselves running on 
// a system that we fundamentally don't understand.
//
    {
    KeBugCheck(BAD_SYSTEM_CONFIG_INFO);
    }


static inline ULONG ServiceNumberFromZw(LPVOID pfnZwRoutine)
// The service table entries contain the pointers to the actual function
// bodies, the actual PFN of NtFlushBuffersFile, for example. The Zw routines
// are thunks that end up calling same. What we are to do here is figure out
// which index in the service table is used for a given Zw routine.
//
    {
    #if defined(_X86_)
        //
        // On x86, the (e.g.) ZwFlushBuffersFile entry point then looks like this:
        //
        //      _ZwFlushBuffersFile@8:
        //      8012A3FC B835000000       mov         eax,35h
        //      8012A401 8D542404         lea         edx,[esp+4]
        //      8012A405 CD2E             int         2Eh
        //      8012A407 C20800           ret         8
        //      8012A40A 8BC0             mov         eax,eax
        //
        // Note that the service number is the DWORD following the first byte.
        //
        BYTE* pb = (BYTE*)pfnZwRoutine;
        ASSERT(pb[0] == 0xB8);
        return *(ULONG*)(&pb[1]);

    #elif defined(ALPHA)
        //
        // On Alpha, the Zw thunks are generated with the following set of macros, from
        //  
        //  nt\private\ntos\ke\alpha\services.stb
        //
        // #define SYSSTUBS_ENTRY1( ServiceNumber, Name, NumArgs ) LEAF_ENTRY(Zw##Name)
        // #define SYSSTUBS_ENTRY2( ServiceNumber, Name, NumArgs ) ldiq v0, ServiceNumber
        // #define SYSSTUBS_ENTRY3( ServiceNumber, Name, NumArgs ) SYSCALL
        // #define SYSSTUBS_ENTRY4( ServiceNumber, Name, NumArgs ) .end Zw##Name ;
        // #define SYSSTUBS_ENTRY5( ServiceNumber, Name, NumArgs ) 
        // #define SYSSTUBS_ENTRY6( ServiceNumber, Name, NumArgs )
        // #define SYSSTUBS_ENTRY7( ServiceNumber, Name, NumArgs )
        // #define SYSSTUBS_ENTRY8( ServiceNumber, Name, NumArgs )
        //
        return (*(PULONG)pfnZwRoutine) & 0x0000FFFF;

        #pragma message( MESSAGE_WARNING(__FILE__,__LINE__) ": the above code not yet verified, but likely correct")

    #else
        #error Unknown processor

    #endif
    }

///////////////////////////////////////////////////////////////////////////////////////////

extern "C" ULONG ServiceNumberOfZwFlushBuffersFile()
// Find the index of ZwFlushBuffersFile in the system table. There
// really is no good way of doing this, but we try our best. The exactly layout
// of the tables if platform- and release-specific. However, on a local basis
// on hopes that it won't change much. As at this writing, the relavant fragment
// of the tables are:
//
// ntos\ke\services.tab for NT4 SP3
//    EnumerateValueKey,6
//    ExtendSection,2
//    FindAtom,2
//    FlushBuffersFile,2
//    FlushInstructionCache,3
//
// ntos\ke\services.tab for NT5 as of 11 June 1998
//    EnumerateValueKey,6
//    ExtendSection,2
//    FilterToken,6
//    FindAtom,3
//    FlushBuffersFile,2
//    FlushInstructionCache,3
//
// Now, ZwEnumerateValueKey and ZwFlushInstructionCache are both exported from
// ntoskrnl.exe. So we first find ZwEnumerateValueKey, verify that ZwFlushInstructionCache
// is at the correct relative offset, and finally assume that ZwFlushBuffersFile is
// one less than that.
//
    {
    // Pointer to system table data structure is an NTOSKRNL export. There's actually
    // a table of service entries: system, win32, iis. We want the first one. Further,
    // what's actually exported is a pointer to the table, notwithstanding what the 
    // compilation environment here says.
    //
    KSERVICE_TABLE_DESCRIPTOR* pServices = *(KSERVICE_TABLE_DESCRIPTOR**)KeServiceDescriptorTable;

    ULONG iEnumerateValueKey     = ServiceNumberFromZw(ZwEnumerateValueKey);
    ULONG iFlushInstructionCache = ServiceNumberFromZw(ZwFlushInstructionCache);

    if ((iEnumerateValueKey+4 == iFlushInstructionCache) || (iEnumerateValueKey+5 == iFlushInstructionCache))
        {
        return iFlushInstructionCache-1;
        }

    // If we can't find the entry, then we're running on some strange system 
    // that we don't understand.
    //
    CantContinue();
    return 0;
    }

extern "C" ULONG ServiceNumberOfZwCreateProcess()
// Find the index of ZwCreateProcess. Use a similar approach to ServiceNumberOfZwFlushBuffersFile.
//
// From ke\services.tab, for both NT4 SP3 and NT5
//
//    CreateKey,7
//    CreateMailslotFile,8
//    CreateMutant,4
//    CreateNamedPipeFile,14
//    CreatePagingFile,4
//    CreatePort,5
//    CreateProcess,8
//    CreateProfile,9
//    CreateSection,7
//
// Now, ZwCreateKey and ZwCreateSection are both exported from ntoskrnl.exe. 
//
    {
    // Pointer to system table data structure is an NTOSKRNL export. There's actually
    // a table of service entries: system, win32, iis. We want the first one. Further,
    // what's actually exported is a pointer to the table, notwithstanding what the 
    // compilation environment here says.
    //
    KSERVICE_TABLE_DESCRIPTOR* pServices = *(KSERVICE_TABLE_DESCRIPTOR**)KeServiceDescriptorTable;

    ULONG iCreateKey     = ServiceNumberFromZw(ZwCreateKey);
    ULONG iCreateSection = ServiceNumberFromZw(ZwCreateSection);

    if (iCreateKey+8 == iCreateSection)
        {
        return iCreateSection-2;
        }

    // If we can't find the entry, then we're running on some strange system 
    // that we don't understand.
    //
    CantContinue();
    return 0;
    }

extern "C" ULONG ServiceNumberOfZwCreateThread()
// Find the index of ZwCreateThread. Use a similar approach to ServiceNumberOfZwFlushBuffersFile.
//
// From ke\services.tab, for both NT4 SP3
//
//    CreateSymbolicLinkObject,4
//    CreateThread,8
//    CreateTimer,4
//    CreateToken,13
//    DelayExecution,2
//    DeleteAtom,1
//    DeleteFile,1
//
// And NT5:
//
//    CreateSymbolicLinkObject,4
//    CreateThread,8
//    CreateTimer,4
//    CreateToken,13
//    CreateWaitablePort,5
//    DelayExecution,2
//    DeleteAtom,1
//    DeleteFile,1
//
    {
    // Pointer to system table data structure is an NTOSKRNL export. There's actually
    // a table of service entries: system, win32, iis. We want the first one. Further,
    // what's actually exported is a pointer to the table, notwithstanding what the 
    // compilation environment here says.
    //
    KSERVICE_TABLE_DESCRIPTOR* pServices = *(KSERVICE_TABLE_DESCRIPTOR**)KeServiceDescriptorTable;

    ULONG iCreateSymbolicLink   = ServiceNumberFromZw(ZwCreateSymbolicLinkObject);
    ULONG iDeleteFile           = ServiceNumberFromZw(ZwDeleteFile);

    if ((iCreateSymbolicLink+6 == iDeleteFile) || (iCreateSymbolicLink+7 == iDeleteFile))
        {
        return iCreateSymbolicLink+1;
        }

    // If we can't find the entry, then we're running on some strange system 
    // that we don't understand.
    //
    CantContinue();
    return 0;
    }

///////////////////////////////////////////////////////////////////////////////////////////

#if defined(_X86_)

    extern "C" NTSTATUS __declspec(naked) __cdecl CallZwService(ULONG iService, ...)
    // Invoke the indicated service number with the indicated argument list
        {
        _asm 
            {
            mov     eax, [esp+4]    // iService
            lea     edx, [esp+8]    // the first arg beyond that is the actual arglist
            int     2eh
            ret                     // we're cdecl, so caller pops
            }
        }

#elif defined(ALPHA)

    extern "C" NTSTATUS __cdecl CallZwService(ULONG iService, ...)
        {
        #pragma message( MESSAGE_WARNING(__FILE__,__LINE__) ": CallService not yet supported on the ALPHA")
        return 0;
        }

#else

    #error Unknown processor

#endif

////////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
TxfZwFlushBuffersFile(IN HANDLE FileHandle, OUT PIO_STATUS_BLOCK IoStatusBlock)
    {
    // Find the right service number
    //
    ULONG iFlushBuffersFile = ServiceNumberOfZwFlushBuffersFile();
    //
    // Call the entry point, exactly as ZwFlushBuffersFile would
    //
    return CallZwService(iFlushBuffersFile, FileHandle, IoStatusBlock);
    }

NTSTATUS
NTAPI
TxfZwCreateThread(
        OUT PHANDLE ThreadHandle,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
        IN HANDLE ProcessHandle,
        OUT PCLIENT_ID ClientId,
        IN PCONTEXT ThreadContext,
        IN PINITIAL_TEB InitialTeb,
        IN BOOLEAN CreateSuspended
        )
    {
    ULONG iCreateThread = ServiceNumberOfZwCreateThread();

    return CallZwService(iCreateThread, 
                ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, ThreadContext, InitialTeb, CreateSuspended);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\fixedpoint.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// FixedPoint.cpp
//
#include "stdpch.h"
#include "common.h"
#include "paged.h"

////////////////////////////////////////////////////////////////////////////
//
// Numeric constants
//
////////////////////////////////////////////////////////////////////////////

static FIXEDPOINT const e(2UL,3084996962UL);            // double e        = 2.7182818284590451000e+000;
static FIXEDPOINT const ONEHALF (0,2147483648UL);       // double ONEHALF  = 5.0000000000000000000e-001;
static FIXEDPOINT const LN2INV(1UL,1901360722UL);       // double LN2INV   = 1.4426950408896342000e+000; // 1/ln(2) 
static FIXEDPOINT const SQRT2   (1,1779033703UL);       // double SQRT2    = 1.4142135623730951000;      // sqrt(2) 
static FIXEDPOINT const SQRT2INV(0,3037000499UL);       // double SQRT2INV = 7.0710678118654746000e-001; // 1/sqrt(2)

////////////////////////////////////////////////////////////////////////////
//
// Arithmetic
//
////////////////////////////////////////////////////////////////////////////
FIXEDPOINT& FIXEDPOINT::operator*=(const FIXEDPOINT& himIn)
/* Do digit-wise mutiplication. It's a four-digit result, of
   which we want the middle two digits.
          a.b
          c.d
       ------
          b d  
        a d
        b c
      a c
    ----------
*/
    {
    BOOL fResultNegative = !SameSign(*this, himIn);
    FIXEDPOINT me  = Abs(*this);
    FIXEDPOINT him = Abs(himIn);
    
    ULARGE_INTEGER bd; bd.QuadPart = (ULONGLONG)me.low  * him.low;
    ULARGE_INTEGER ad; ad.QuadPart = (ULONGLONG)me.high * him.low;
    ULARGE_INTEGER bc; bc.QuadPart = (ULONGLONG)me.low  * him.high;
    ULARGE_INTEGER ac; ac.QuadPart = (ULONGLONG)me.high * him.high;

    ll = (ULONGLONG)bd.HighPart 
            + ad.QuadPart 
            + bc.QuadPart 
            + ((ULONGLONG)ac.LowPart << cbitFrac);

    if (fResultNegative)
        ll = - ll;

    return *this;
    }

#pragma warning (disable : 4723)            // warning C4723: potential divide by 0

#pragma optimize( "", off )
FIXEDPOINT FIXEDPOINT::operator/=(const FIXEDPOINT& him)
// Bob's approach to division
//
    {
    const FIXEDPOINT& me = *this;
    //
    // Check for divide by zero
    //
    if (him == 0)
        {
        FIXEDPOINT r(me.low / him.low);     // will generate a div by zero exception
        return r;
        }
    //
    // Zero over anything else is zero
    //
    if (me == 0)
        {
        FIXEDPOINT r(0L);
        return r;
        }
    //
    // Figure out sign of result and make arguments positive
    //
    BOOL fResultNegative = !SameSign(me, him);
    FIXEDPOINT num = Abs(me);
    FIXEDPOINT den = Abs(him);
    //
    // Shift the numerator and denominator apart so as to have
    // the widest possible relative precision. This is the somewhat
    // part: small increments in, say, the denominator can cause
    // us to shift much less, and so have much less precision in the
    // result.
    //
    // Scale numerator so as to have a 1 in highest bit position
    //
    int cbitShiftNum = 0;
    while (num.Bit(cbitFixed-1) == 0)
        {
        num <<= 1;
        cbitShiftNum++;
        }
    //
    // Scale denominator so as to have a 1 in lowest bit position
    //
    int cbitShiftDen = 0;
    while (den.Bit(0) == 0)
        {
        den >>= 1;
        cbitShiftDen++;
        }
    //
    // Form the quotient using unsigned arithmetic
    //
    ULONGLONG q = (ULONGLONG)num.ll / (ULONGLONG)den.ll;
    //
    // Scale the result
    //
    int cbitShiftLeft = (int)cbitFrac - cbitShiftNum - cbitShiftDen;
    if (cbitShiftLeft >= 0)
        q <<= cbitShiftLeft;
    else
        q >>= -cbitShiftLeft;

    //
    // Set the result, with the right sign
    //
    ll = q;
    if (fResultNegative)
        ll = -ll;

    return *this;
    }

#pragma optimize( "", on ) 


////////////////////////////////////////////////////////////////////////////
//
// Exponentiation
//
////////////////////////////////////////////////////////////////////////////


FIXEDPOINT Power(const FIXEDPOINT& base, ULONG power)
    {
    FIXEDPOINT p = 1;
    for (int ibit = 31; ibit >= 0; ibit--)
        {
        // exp(2a) = exp(a) * exp(a)
        //
        p *= p;
        //
        // Add in the next bit 
        //
        if (power & (1<<ibit))
            p *= base;
        }
    return p;
    }


static FIXEDPOINT const p0(0UL,1073741824UL);   // double p0 = 2.5000000000000000000e-001;
static FIXEDPOINT const p1(0UL,29822534UL);     // double p1 = 6.9436000151179289000e-003;
static FIXEDPOINT const p2(0UL,70954UL);        // double p2 = 1.6520330026827912000e-005;
static FIXEDPOINT const q0(0UL,2147483648UL);   // double q0 = 5.0000000000000000000e-001;
static FIXEDPOINT const q1(0UL,238602040UL);    // double q1 = 5.5553866696900121000e-002;
static FIXEDPOINT const q2(0UL,2129714UL);      // double q2 = 4.9586288490544126000e-004;

static FIXEDPOINT const c1(0UL,2977955840UL);   // double c1 = 6.9335937500000000000e-001;
static FIXEDPOINT const c2(0,911368UL);         // double c2 = 2.1219444005469057000e-004;
           
#define p(z)  ( (p2 * (z) + p1) * (z) + p0 )
#define q(z)  ( (q2 * (z) + q1) * (z) + q0 )

inline static FIXEDPOINT ExpUnit(FIXEDPOINT x)
// Compute the exponential function on the range [0.0, 1.0]
//
    {
    FIXEDPOINT px, xx;
    int n = 0;

    px = Floor( LN2INV * x + ONEHALF ); // floor() truncates toward -infinity.
    n = (int) px;
    x -= px * c1;
    x += px * c2;

    xx = x * x;
    px = x * p(xx);
    x  = px / ( q(xx) - px );
    x  = FIXEDPOINT(1) + (x + x);

    x = x * Power(FIXEDPOINT(2), n);
    
    return x;
    }


/////////////////////////////////
//
// Actual exponentiation
//
/////////////////////////////////

FIXEDPOINT Exp(const FIXEDPOINT& x)
// Compute the exponential function. REVIEW: Currently works only for
// unsigned numbers.
// 
    {
    if (x < 0)
        {
        return FIXEDPOINT(1) / Exp(-x);
        }
    else
        {
        // Figure out the integral part of the exponentiation
        //
        int xi       = int(Floor(x));
        FIXEDPOINT p = Power(e, xi);
        //
        // Figure out the fractional part
        //
        FIXEDPOINT f = x - (FIXEDPOINT)xi;
        FIXEDPOINT fp = ExpUnit(f);
        //
        // Result is the product of the two
        //
        return p * fp;
        }
    }




////////////////////////////////////////////////////////////////////////////
//
// Logarithms
//
////////////////////////////////////////////////////////////////////////////



static FIXEDPOINT frexp(FIXEDPOINT x, int* expptr)
// The frexp function breaks down the floating-point value (x) into 
// a mantissa (m) and an exponent (n), such that the absolute value of m 
// is greater than or equal to ONEHALF and less than 1.0, and x = m* 2^n. The integer 
// exponent n is stored at the location pointed to by expptr. 
//
    {
    ASSERT(x > 0);
    int n = 0;

    if (x.integer != 0)
        {
        // Shift right
        while (x.integer != 0)
            {
            x >>= 1;
            n++;
            }
        }
    else
        {
        // Shift left
        while (x.Bit(FIXEDPOINT::cbitFrac-1) == 0)
            {
            x <<= 1;
            n--;
            }
        }

    ASSERT(ONEHALF <= x && x < FIXEDPOINT(1));

    *expptr = n;
    return x;
    }

////////////////////////////////////////////////////////////////////////////////////////
//
// Coefficients for 
//
//      log(1+x) = x - x**2/2 + x**3 P(x)/Q(x)
//
// where    
//
//      1/sqrt(2) <= x < sqrt(2)
//
static FIXEDPOINT const P0(7UL,3042500447UL);   // double P0 = 7.7083873375588539000e+000;
static FIXEDPOINT const P1(17UL,4023816779UL);  // double P1 = 1.7936867850781983000e+001;
static FIXEDPOINT const P2(14UL,2142855967UL);  // double P2 = 1.4498922534161093000e+001;
static FIXEDPOINT const P3(4UL,3031350116UL);   // double P3 = 4.7057911987888170000e+000;
static FIXEDPOINT const P4(0UL,2136724733UL);   // double P4 = 4.9749499497674698000e-001;
static FIXEDPOINT const P5(0UL,8055UL);         // double P5 = 1.8756638045809317000e-006;

static FIXEDPOINT const Q0(23UL,537566751UL);   // double Q0 = 2.3125162012676533000e+001;
static FIXEDPOINT const Q1(71UL,663465338UL);   // double Q1 = 7.1154475061856388000e+001;
static FIXEDPOINT const Q2(82UL,4241394842UL);  // double Q2 = 8.2987526691277665000e+001;
static FIXEDPOINT const Q3(45UL,978885683UL);   // double Q3 = 4.5227914583753225000e+001;
static FIXEDPOINT const Q4(11UL,1234196299UL);  // double Q4 = 1.1287358718916746000e+001;
static FIXEDPOINT const Q5(1UL,0UL);            // double Q5 = 1.0000000000000000000e+000;

FIXEDPOINT P(const FIXEDPOINT& x)
    {
    return ((((P5*x + P4)*x + P3)*x + P2)*x + P1)*x + P0;
    }

FIXEDPOINT Q(const FIXEDPOINT& x)
    {
    return ((((/*Q5**/x + Q4)*x + Q3)*x + Q2)*x + Q1)*x + Q0;
    }


////////////////////////////////////////////////////////////////////////////////////////
//
// Coefficients for 
//
//      log(x) = z + z**3 R(z)/S(z),
//
// where    
//
//      z = 2(x-1)/(x+1)
//
// and
//      ??? < x < ???
//
static FIXEDPOINT const R2(4294967295UL,903745821UL);  // double R2 = -7.8958027888479920000e-001;
static FIXEDPOINT const R1(16UL,1660711682UL);         // double R1 = 1.6386664569955808000e+001;
static FIXEDPOINT const R0(4294967231UL,3689397112UL); // double R0 = -6.4140995295871562000e+001;

static FIXEDPOINT const S3(1UL,0UL);                   // double S3 = 1.0000000000000000000e+000;
static FIXEDPOINT const S2(4294967260UL,1407547432UL); // double S2 = -3.5672279825632430000e+001;
static FIXEDPOINT const S1(312UL,402723502UL);         // double S1 = 3.1209376637224420000e+002;
static FIXEDPOINT const S0(4294966526UL,1323092377UL); // double S0 = -7.6969194355046000000e+002;

FIXEDPOINT R(const FIXEDPOINT& x)
    {
    return (R2*x + R1)*x + R0;
    }

FIXEDPOINT S(const FIXEDPOINT& x)
    {
    return ((/*S3**/x + S2)*x + S1)*x + S0;
    }

////////////////////////////////////////////////////////////////////////////////////////
//
// Log
//
FIXEDPOINT Log(const FIXEDPOINT& xIn)
    {
    FIXEDPOINT w,x = xIn,y,z;
    int n;
    
    if (x <= 0)
        return FIXEDPOINT(0);           // would like NAN really
    else if (x == 1)
        return FIXEDPOINT(0);

    x = frexp(x, &n);
    
    if( (n > 2) || (n < -2) )
        {
        if ( x < SQRT2INV )
            { /* 2( 2x-1 )/( 2x+1 ) */
            n -= 1;                       
            z = x - ONEHALF;              
            y = ONEHALF * z + ONEHALF;    
            }       
        else
            { /*  2 (x-1)/(x+1)   */
            z = (x - ONEHALF) - ONEHALF;  
            y = ONEHALF * x  + ONEHALF;   
            }

        z = z / y;                        
        w = z * z;                        

        FIXEDPOINT rzsq = w * R(w)/S(w) ; 
        FIXEDPOINT rz = z + z*rzsq;       

        z  = (FIXEDPOINT(n) * c2 + rz) + FIXEDPOINT(n) * c1;
        }
    else
        {
        if( x < SQRT2INV )
            {
            n -= 1;
            x = x+x - FIXEDPOINT(1);
            }   
        else
            {
            x = x - FIXEDPOINT(1);
            }

        /* rational form */
        z = x*x;
        y = x * ( z * P(x) / Q(x) );
        if (n)
            y = y - FIXEDPOINT(n) * c2;
        y = y - ONEHALF * z;
        z = x + y;
        if (n)
            z = z + FIXEDPOINT(n) * c1;
        }
    
    return z;
    }

/////////////////////////////////////////////////////////////////////////
//
// Make sure that all templates get generated as non-paged
//
#include "nonpaged.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\init.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// init.cpp
//
#include "stdpch.h"
#include "common.h"
#include "callobj.h"

// #pragma code_seg("INIT")

void InitializeTxfAux()
    {
    #ifdef KERNELMODE
    InitializeRuntime();
    #endif
    }

void UninitializeTxfAux()
    {
    #ifdef KERNELMODE
    TerminateRuntime();
    #endif
    }

/////////////////////////////////////////////////////////////////////////////
//
// DllMain
//
/////////////////////////////////////////////////////////////////////////////

BOOL      g_fProcessDetach = FALSE;

// The init functions scattered throughout the DLL.
BOOL InitTypeInfoCache();
BOOL InitLegacy();
BOOL InitCallFrame();
BOOL InitMetaDataCache();
BOOL InitDisabledFeatures();

// The corresponding cleanup functions.
void FreeTypeInfoCache();
void FreeMetaDataCache();

// Conditionally compile the init code, depending on whether we're
// statically linked inside ole32.dll or not.
#ifdef _OLE32_

// These will be called manually, from inside ole32.dll's DllMain, 
// DllRegisterServer, etc.
#define DLLMAIN             TxfDllMain
#define DLLREGISTERSERVER   TxfDllRegisterServer
#define DLLUNREGISTERSERVER TxfDllUnregisterServer

// And this is maintained by ole32.
extern HINSTANCE g_hinst;

#else

// Need to provide these on our own.
#define DLLMAIN             DllMain
#define DLLREGISTERSERVER   DllRegisterServer
#define DLLUNREGISTERSERVER DllUnregisterServer

HINSTANCE g_hinst;

#endif

extern "C"
BOOL WINAPI DLLMAIN(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	BOOL fOK = TRUE;

	if (dwReason == DLL_PROCESS_ATTACH)
	{
        g_hinst = hInstance;

#ifndef _OLE32_
		DisableThreadLibraryCalls(hInstance);
#endif

		// Moved the initialization work in here instead of in
		// constructor objects, since when linked with Ole32 we need
		// to control when this code is executed.
		fOK = InitTypeInfoCache ();
		
		if (fOK)
			fOK = InitLegacy();

		if (fOK)
			fOK = InitCallFrame();

		if (fOK)
			fOK = InitMetaDataCache();

		if (fOK)
			fOK = InitDisabledFeatures();
	}
	
	if (dwReason == DLL_PROCESS_DETACH || (!fOK))
	{
        g_fProcessDetach = TRUE;

#ifndef _OLE32_
        StopWorkerQueues();
#endif
		FreeTypeInfoCache();
		FreeMetaDataCache();

		ShutdownTxfAux();
	}

	return fOK;    // ok
}


/////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Standard COM entry point that asks us to register ourselves
//
/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT RegisterInterfaceName(REFIID iid, LPCWSTR name);

#define REGNAME(x) RegisterInterfaceName(__uuidof(x), L ## #x)


extern "C" HRESULT STDCALL RegisterCallFrameInfrastructure();
extern "C" HRESULT STDCALL UnregisterCallFrameInfrastructure();

STDAPI DLLREGISTERSERVER()
{
    HRESULT hr = S_OK;
    REGNAME(ICallIndirect);
    REGNAME(ICallFrame);
    REGNAME(ICallInterceptor);
    REGNAME(ICallUnmarshal);
    REGNAME(ICallFrameEvents);
    REGNAME(ICallFrameWalker);
    REGNAME(IInterfaceRelated);

    if (!hr) hr = RegisterCallFrameInfrastructure();
    return hr;
}


STDAPI DLLUNREGISTERSERVER()
{
    UnregisterCallFrameInfrastructure();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\lookaside.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// lookaside.cpp
//
// Implementation of an associative map. We use it for associating
// extra data with FileObjects

#include "stdpch.h"
#include "common.h"

#if 0

/////////////////////////////////////////////////////////////////////////////

CMapKeyToValue::CMapKeyToValue(
        POOL_TYPE memctx, 
        LPFNHASHKEY     lpfnHashKey, 
        LPFNEQUALKEY    lpfnEqualKey,
        LPFNDELETEVALUE lpfnDeleteValue,
        LPFNDELETEKEY   lpfnDeleteKey,
        LPFNASSIGNKEY   lpfnAssignKey,
        ULONG cbValue, 
        ULONG cbKey,
        int nBlockSize, 
        ULONG nHashSize
        )
    {
    ASSERT(nBlockSize > 0);
    ASSERT(lpfnHashKey);
    ASSERT(cbKey > 0);
    ASSERT(cbValue > 0);

    m_cbValue           = cbValue;
    m_cbKey             = cbKey;

    m_pHashTable        = NULL;
    m_nHashTableSize    = nHashSize;
    m_pfnHashKey        = lpfnHashKey;
    m_pfnEqualKey       = lpfnEqualKey;
    m_pfnDeleteValue    = lpfnDeleteValue;
    m_pfnDeleteKey      = lpfnDeleteKey;
    m_pfnAssignKey      = lpfnAssignKey;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
    m_palloc = GetStandardMalloc(memctx);
    }

CMapKeyToValue::~CMapKeyToValue()
    {
    RemoveAll();
    ASSERT(m_nCount == 0);
    }


BOOL CMapKeyToValue::InitHashTable()
    {
    ASSERT(m_nHashTableSize  > 0);
    
    if (m_pHashTable != NULL)
        return TRUE;

    ASSERT(m_nCount == 0);

    if ((m_pHashTable = (CAssoc**)m_palloc->Alloc(m_nHashTableSize * sizeof(CAssoc *))) == NULL)
        return FALSE;

    RtlZeroMemory(m_pHashTable, sizeof(CAssoc *) * m_nHashTableSize);
    return TRUE;
    }


void CMapKeyToValue::RemoveAll()
// Free all key values and then hash table
    {
    if (m_pHashTable != NULL)
        {
        // destroy assocs
        for (ULONG nHash = 0; nHash < m_nHashTableSize; nHash++)
            {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
                {
                // assoc itself is freed by FreeDataChain below
                FreeAssocKeyAndValue(pAssoc);
                }
            }

        // free hash table
        m_palloc->Free(m_pHashTable);
        m_pHashTable = NULL;
        }

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain(m_palloc);
    m_pBlocks = NULL;
    }

/////////////////////////////////////////////////////////////////////////////

CMapKeyToValue::CAssoc*
CMapKeyToValue::NewAssoc(ULONG hash, LPVOID pKey, LPVOID pValue)
// Get me a new association to use
    {
    if (m_pFreeList == NULL)
        {
        // add another block
        CPlex* newBlock = CPlex::Create(m_pBlocks, m_palloc, m_nBlockSize, SizeAssoc());
        if (newBlock == NULL)
            return NULL;

        // chain them into free list
        BYTE* pbAssoc = (BYTE *) &newBlock->data[0];
        // free in reverse order to make it easier to debug
        pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
        for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
            {
            ((CAssoc *)pbAssoc)->pNext = m_pFreeList;
            m_pFreeList = (CAssoc *)pbAssoc;
            }
        }
    ASSERT(m_pFreeList != NULL); // we must have something

    CMapKeyToValue::CAssoc* pAssoc = m_pFreeList;

    // init all fields except pNext while still on free list
    pAssoc->nHashValue = hash;
    if (!SetAssocKey(pAssoc, pKey, FALSE))
        return NULL;

    // remove from free list after successfully initializing it (except pNext)
    SetAssocValue(pAssoc, pValue, FALSE);

    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);       // make sure we don't overflow

    return pAssoc;
    }



CMapKeyToValue::CAssoc*
CMapKeyToValue::GetAssocAt(LPVOID pKey, ULONG* pnHash) const
// Find the association for a given key, or NULL
    {
    ULONG nHash;
    if (m_pfnHashKey)
        {
        nHash = (*m_pfnHashKey)(pKey) % m_nHashTableSize;
        if (pnHash)
            *pnHash = nHash;
        }
    else 
        {
        ASSERT(m_pfnHashKey);
        return NULL;
        }

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
        {
        if (CompareAssocKey(pAssoc, pKey))
            return pAssoc;
        }
    return NULL;
    }

/////////////////////////////////////////////////////////////////////////////

// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, LPVOID pValue)
    {
    ULONG nHash;
    CAssoc  * pAssoc;

    if ((pAssoc = GetAssocAt(pKey, &nHash)) == NULL)
        {
        if (!InitHashTable())
            // out of memory
            return FALSE;

        // it doesn't exist, add a new Association
        if ((pAssoc = NewAssoc(nHash, pKey, pValue)) == NULL)
            return FALSE;

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
        }
    else
        {
        SetAssocValue(pAssoc, pValue, TRUE);
        }

    #ifdef _DEBUG
        {
        ASSERT(Lookup(pKey, NULL));
        }
    #endif

    return TRUE;
    }


// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey)
    {
    if (m_pHashTable == NULL)
        return FALSE;       // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[(*m_pfnHashKey)(pKey) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
        {
        if (CompareAssocKey(pAssoc, pKey))
            {
            // remove it
            *ppAssocPrev = pAssoc->pNext;       // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
            }
        ppAssocPrev = &pAssoc->pNext;
        }
    return FALSE;   // not found
    }



/////////////////////////////////////////////////////////////////////////////
//
// Iterating
//
/////////////////////////////////////////////////////////////////////////////

void CMapKeyToValue::GetNextAssoc
        (
        POSITION*   pNextPosition,      // in, out: where we are to read
        LPVOID      pKey,               // pointer to key data / pointer to pointer to key
        LPVOID      pValue
        ) const
    {
    ASSERT(pKey);
    ASSERT(m_pHashTable != NULL);       // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)*pNextPosition;
    ASSERT(pAssocRet != NULL);

    if (pAssocRet == (CAssoc*)BEFORE_START_POSITION)
        {
        // find the first association
        for (ULONG nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            {
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
            }
        }

    ASSERT(pAssocRet != NULL);

    // find next association
    CAssoc* pAssocNext = pAssocRet->pNext;
    if (pAssocNext == NULL)
        {
        // go to next bucket
        for (ULONG nBucket = pAssocRet->nHashValue + 1; nBucket < m_nHashTableSize; nBucket++)
            {
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
            }
        }

    // fill in return data
    *pNextPosition = (POSITION)pAssocNext;

    // fill in key/pointer to key
    LPVOID pKeyFrom;
    GetAssocKeyPtr(pAssocRet, &pKeyFrom);

    RtlCopyMemory(pKey, pKeyFrom, m_cbKey);

    // get value
    GetAssocValue(pAssocRet, pValue);
    }

/////////////////////////////////////////////////////////////////////////////

void CMapKeyToValue::FreeAssocKeyAndValue(CAssoc * pAssoc) const
    {
    if (m_pfnDeleteValue)
        {
        LPVOID pValueTo;
        GetAssocValuePtr(pAssoc, &pValueTo);
        m_pfnDeleteValue(pValueTo);
        #if DBG
            RtlFillMemory(pValueTo, m_cbValue, 0x3c);
        #endif
        }

    if (m_pfnDeleteKey)
        {
        LPVOID pKey;
        GetAssocKeyPtr(pAssoc, &pKey);
        m_pfnDeleteKey(pKey);
        #if DBG
            RtlFillMemory(pKey, m_cbKey, 0x3d);
        #endif
        }
    }

BOOL CMapKeyToValue::SetAssocKey(CAssoc * pAssoc, LPVOID pKey, BOOL fTargetInitialized) const
// Set the key of an association to be the indicated value
//
    {
    LPVOID pKeyTo;
    GetAssocKeyPtr(pAssoc, &pKeyTo);
    if (m_pfnAssignKey) 
        m_pfnAssignKey(pKeyTo, pKey, fTargetInitialized);
    else
        RtlCopyMemory(pKeyTo, pKey, m_cbKey);
    return TRUE;
    }

void CMapKeyToValue::SetAssocValue(CAssoc * pAssoc, LPVOID pValue, BOOL fTargetInitialized) const
// Set the value in the assoc from the indicated value, making a copy. If the existing
// value is not at present empty, destory it before overwriting.
    {
    LPVOID pValueTo;
    GetAssocValuePtr(pAssoc, &pValueTo);
    if (fTargetInitialized && m_pfnDeleteValue)
        {
        m_pfnDeleteValue(pValueTo);
        }
    if (pValue == NULL)
        RtlZeroMemory(pValueTo, m_cbValue);
    else
        RtlCopyMemory(pValueTo, pValue, m_cbValue);
    }

void CMapKeyToValue::GetAssocValue(CAssoc * pAssoc, LPVOID pValue) const
// Copy out the value in the assoc
    {
    LPVOID pValueFrom;
    GetAssocValuePtr(pAssoc, &pValueFrom);
    if (pValue)
        RtlCopyMemory(pValue, pValueFrom, m_cbValue);
    }

////////////////////////////////////////////////////////////////////////



/*
void Foo()
    {
    typedef MAP<MAP_INT_KEY<int>, int>              INTMAP;
    typedef MAP<MAP_STRING_KEY,   int>              STRINGMAP;
    typedef MAP<MAP_STRING_KEY_IGNORE_CASE, int>    STRINGMAP_IGNORECASE;
    typedef MAP<MAP_UNICODE_KEY_IGNORE_CASE, int>   STRINGMAP_U_IGNORE;

    INTMAP im;
    im.SetAt(1,2);

    STRINGMAP_IGNORECASE s1;
    STRINGMAP s2;
    STRINGMAP_U_IGNORE s3;

    s1.SetAt(L"Hello", 1);
    s2.SetAt(L"Hello", 1);
    s3.SetAt(L"Hello", 1);
    }
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\malloc.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// malloc.cpp
//
// Implementation of GetStandardMalloc for both user and kernel mode.
// Also: for kernel mode, an implementation of new and delete since 
// the C runtime doesn't provide one.
//
#include "stdpch.h"
#include "common.h"


/////////////////////////////////////////////////////////////////////////
//
// User mode. Just use the OLE allocator
//
/////////////////////////////////////////////////////////////////////////

IMalloc* GetStandardMalloc(POOL_TYPE pool)
{
    switch (pool)
	{
    default:
    case PagedPool:
	{
        IMalloc* pmalloc;
        HRESULT hr = CoGetMalloc(1, &pmalloc);
        if (!!hr) 
            FATAL_ERROR();
        return pmalloc;
        }
/*    default:
        ASSERTMSG("Illegal pool type used", FALSE);
        FATAL_ERROR();
        return NULL;
 */     };
    }

/////////////////////////////////////////////////////////////////////////
//
// Heap validation
//
/////////////////////////////////////////////////////////////////////////

#if defined(_DEBUG) && !defined(KERNELMODE)

void CheckHeaps()
// Validate all the heaps in this process
    {
    // Check the C runtime heap 
    //
		// ASSERT(_CrtCheckMemory());
    //
    // Have Win32 check its heaps
    //
    HANDLE rgHeap[100];
    DWORD cHeap = GetProcessHeaps(100, rgHeap);
    ASSERT(cHeap > 0 && cHeap <= 100);
    for (ULONG iHeap=0; iHeap<cHeap; iHeap++)
        {
        ASSERT(HeapValidate(rgHeap[iHeap],0,NULL));
        }
    }

void PrintMemoryLeaks()
// Print memory leaks. Or more correctly, print anything in the process heap
// that (probably) was allocated by us
    {
    HANDLE h = GetProcessHeap();
    if (HeapLock(h))
        {
        PROCESS_HEAP_ENTRY e; e.lpData = NULL;

        while (HeapWalk(h, &e))
            {
            if ((e.wFlags & PROCESS_HEAP_ENTRY_BUSY) && 
               !(e.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) &&
                (e.cbData >= (4+sizeof(PVOID))))
                {
                BYTE* pb = (BYTE*)e.lpData;
                ULONG cb = e.cbData - (4+sizeof(PVOID));
                if (*(UNALIGNED ULONG*) (pb + cb) == TXFMALLOC_MAGIC)
                    {
                    PVOID retAddr = *(PVOID*)(pb + cb + 4);
                    Print("likely leaked memory block at 0x%08x, %06u bytes long, allocated from 0x%08x\n", pb, cb, retAddr);
                    }
                }
            }

        HeapUnlock(h);
        }
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\probability.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Probability.cpp
//
#include "stdpch.h"
#include "common.h"
#include "paged.h"

MD5HASHDATA randomSeed;
XSLOCK      randomLock;

// returns TRUE on success, FALSE on failure
// 3/25/01 danroth: comment out because doesn't seem to be used.
/*
BOOL SetRandomSeed(ULONG u)
    {
    if (!randomLock.FInited())
    {
        if (randomLock.FInit()==FALSE)
            return FALSE;
    }
    randomLock.LockExclusive();
    randomSeed.ullLow  = u;
    randomSeed.ullHigh = 0;
    randomLock.ReleaseLock();
    return TRUE;
    }
*/

FIXEDPOINT SampleUniform()
// Return a sample from the uniform distribution with on [0,1)
//
    {
    randomLock.LockExclusive();
    
    MD5 md5;
    md5.Hash((BYTE*)&randomSeed, (ULONG)sizeof(randomSeed), &randomSeed);
    
    FIXEDPOINT f;
    f.integer  = 0;
    f.fraction = randomSeed.u0 ^ randomSeed.u1 ^ randomSeed.u2 ^ randomSeed.u3;

    randomLock.ReleaseLock();

    ASSERT( FIXEDPOINT(0) <= f && f < FIXEDPOINT(1) );

    return f;
    }

ULONG SampleUniform(ULONG m)
// Return a sample from the uniform distribution on [0, m)
//
    {
    while (true)
        {
        FIXEDPOINT f = SampleUniform() * FIXEDPOINT(m);
        ULONG u = ULONG(f);
        if (u < m)      // may be equal due to roundoff ?
            return u;
        }
    }

ULONG SampleExponential(ULONG m)
// Return a sample from the exponential distribution with mean m
//
    {
    while (true)
        {
        FIXEDPOINT f = FIXEDPOINT(1) - SampleUniform();
        if (FIXEDPOINT(0) < f)
            {
            return Log(f) * -FIXEDPOINT(m);
            }
        }
    }

/////////////////////////////////////////////////////////////////////////
//
// Make sure that all templates get generated as non-paged
//
#include "nonpaged.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\stdpch.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.cpp
//
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\sources.inc ===
#
# Common build instructions for kernel / user mode
# COM support dll.
#
#   Bob Atkinson
#   September 1997


PRECOMPILED_INCLUDE     =..\stdpch.h
PRECOMPILED_CXX         =1
PRECOMPILED_SOURCEFILE  =..\stdpch.cpp

EXCEPTION_HANDLING      =$(SEHONLY)

INCLUDES	= $(INCLUDES); ..\..\COMSvcs\Inc; ..\..\COMSvcs\Inc2

#
# SOURCES MOVED FROM HERE INTO COMPONENT DIRECTORIES
# (Static, UserMode)
#

ALPHA_SOURCES=		        \
	    ..\alpha\interlocked.s    

PASS0_HEADERDIR =..\..\inc
MIDL_UUIDDIR    =..\..\inc
VIPER_MIDL_FLAGS=$(MIDL_HEADER_AND_IID)

SOURCES_USED=$(SOURCES_USED) ..\sources.inc

!if $(FREEBUILD)
VIPER_C_FLAGS = $(VIPER_C_FLAGS) /FAsc
!endif

!if defined(USE_ICECAP) && !defined(KERNELMODE)
VIPER_C_FLAGS = $(VIPER_C_FLAGS) /DUSE_ICECAP
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\rtl.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// rtl.cpp
//
// Clone of various RTL routines
//
#include "stdpch.h"
#include "common.h"

#if !defined(KERNELMODE)

/*
// 4273: 'RtlInitUnicodeString' : inconsistent dll linkage.  dllexport assumed.
#pragma warning(disable : 4273)

VOID RtlInitUnicodeString(    
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )
    {
    ULONG Length;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = lstrlenW( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
    }
*/

/*
NTSTATUS 
RtlUnicodeStringToAnsiString(
    IN OUT PANSI_STRING DestinationString, // optional
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\memorystream.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// MemoryStream.cpp
//
// A IStream on IMalloc implementation
//
#include "stdpch.h"
#include "common.h"

extern "C" HRESULT STDCALL NewMemoryStream(BLOB* pb, IStream** ppstm)
// Create and return a new read-write memory stream on some existing or on some new data
    {
    HRESULT hr = S_OK;
    *ppstm = NULL;

    IMemoryStream* pmem = NULL;
    hr = CreateMemoryStream(NULL, __uuidof(IMemoryStream), (LPVOID*)&pmem);
    if (!hr)
        {
                       hr = pmem->SetAllocator(PagedPool);
        if (!hr && pb) hr = pmem->SetBuffer(pb->pBlobData, pb->cbSize);
        if (!hr)       hr = pmem->SetReadOnly(FALSE);
        if (!hr)       hr = pmem->QueryInterface(IID_IStream, (LPVOID*)ppstm);
        pmem->Release();
        }
    return hr;
    }

extern "C" HRESULT STDCALL FreeMemoryStream(IStream* pstm)
    {
    HRESULT hr = S_OK;
    if (pstm)
        {
        IMemoryStream* pmem;
        hr = pstm->QueryInterface(__uuidof(IMemoryStream), (void**)&pmem);
        if (!hr)
            {
            hr = pmem->FreeBuffer();
            pmem->Release();
            }
        pstm->Release();
        }
    return hr;
    }

///////////////////////////////////////////////////////////////////
//
// IMemoryStream
//
///////////////////////////////////////////////////////////////////

HRESULT CMemoryStream::SetAllocator(POOL_TYPE pool)
    {
    m_alloc = pool;
    return S_OK;
    }

HRESULT CMemoryStream::SetReadOnly(BOOL f)
    {
    m_fReadOnly = f;
    return S_OK;
    }

HRESULT CMemoryStream::SetBuffer(LPVOID pv, ULONG cb)
// Set the current memory buffer. Unless the stream is read-only
// then the buffer must be allocated
    {
    __EXCLUSIVE__

    FreeBuffer();
    m_pbFirst   = (BYTE*) pv;
    m_pbCur     = m_pbFirst;
    m_pbMac     = m_pbFirst + cb;
    m_pbMax     = m_pbFirst + cb;
    
    __DONE__
    return S_OK;
    }

HRESULT CMemoryStream::GetBuffer(BLOB* pBlob)
    {
    __EXCLUSIVE__
    
    pBlob->pBlobData = m_pbFirst;
    pBlob->cbSize    = PtrToUlong(m_pbMac) - PtrToUlong(m_pbFirst);
    
    __DONE__
    return S_OK;
    }

HRESULT CMemoryStream::FreeBuffer()
    {
    __EXCLUSIVE__
    //
    // We free things if we're not read-only
    //
    if (!m_fReadOnly && m_pbFirst)
        {
        FreeMemory(m_pbFirst);
        }
    m_pbFirst = m_pbCur = m_pbMax = m_pbMac = NULL;
    
    __DONE__
    return S_OK;
    }


///////////////////////////////////////////////////////////////////
//
// IStream
//
///////////////////////////////////////////////////////////////////

HRESULT CMemoryStream::Read(LPVOID pvBuffer, ULONG cb, ULONG* pcbRead)
    {
    HRESULT hr = S_OK;

    __EXCLUSIVE__

    if (m_pbFirst)
        {
        ULONG cbToRead = min(cb, (ULONG)(m_pbMac - m_pbCur));
        memcpy(pvBuffer, m_pbCur, cbToRead);
        m_pbCur += cbToRead;
        if (pcbRead)
            *pcbRead = cbToRead;
        hr = cbToRead == cb ? S_OK : S_FALSE;
        }
    else
        {
        if (pcbRead)
            *pcbRead = 0;
        hr = E_FAIL;
        }
    
    __DONE__
    
    return hr;
    }

HRESULT CMemoryStream::Write(LPCVOID pvBuffer, ULONG cbToWrite, ULONG* pcbWritten)
    {
    HRESULT_ hr = S_OK;

    __EXCLUSIVE__

    if (m_fReadOnly)
        {
        *pcbWritten = 0;
        return E_UNEXPECTED;
        }

    //
    // Grow the buffer if we need to
    //
    LONG cbCurFree = PtrToUlong(m_pbMax) - PtrToUlong(m_pbCur);    // can be negative if we've seeked beyond EOF
    if (cbCurFree < (LONG)cbToWrite)
        {
        ULONG cbCur    = PtrToUlong(m_pbCur) - PtrToUlong(m_pbFirst);
        ULONG cbMac    = PtrToUlong(m_pbMac) - PtrToUlong(m_pbFirst);
        ULONG cbMax    = cbCur + cbToWrite + max(256, cbToWrite);   // add extra slop so we don't repeatedly grow

        ASSERT(cbMax >  cbMac);                         // don't want to loose data
        ASSERT(cbMax >= cbCur + cbToWrite);             // want to make sure we have enough room

        BYTE* pbNew = (BYTE*)AllocateMemory(cbMax, m_alloc);
        if (pbNew)
            {
            memcpy(pbNew, m_pbFirst, cbMac);
            FreeMemory(m_pbFirst);

            m_pbFirst   = pbNew;
            m_pbCur     = m_pbFirst + cbCur;
            m_pbMac     = m_pbFirst + cbMac;
            m_pbMax     = m_pbFirst + cbMax;
            }
        else
            hr = E_OUTOFMEMORY;
        }
    //
    // Write the data
    //
    if (!hr)
        {
        ASSERT(m_pbCur + cbToWrite <= m_pbMax);
        memcpy(m_pbCur, pvBuffer, cbToWrite);
        m_pbCur += cbToWrite;
        m_pbMac = max(m_pbMac, m_pbCur);
        if (pcbWritten)
            *pcbWritten = cbToWrite;
        }
    else
        {
        if (pcbWritten)
            *pcbWritten = 0;
        }

    __DONE__
    return hr;
    }

HRESULT CMemoryStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition)
{
    HRESULT_ hr = S_OK;
    __EXCLUSIVE__

    BYTE* pbCur;

    ASSERT(m_pbFirst <= m_pbCur);

    switch (dwOrigin)
	{
    case STREAM_SEEK_SET:
        pbCur = m_pbFirst + dlibMove.QuadPart;
        break;

    case STREAM_SEEK_CUR:
        pbCur = m_pbCur + dlibMove.QuadPart;
        break;

    case STREAM_SEEK_END:
        pbCur = m_pbMac + dlibMove.QuadPart;
        break;

    default:
        hr = E_INVALIDARG;
	}

	if (SUCCEEDED(hr))
	{
		if (m_pbFirst <= pbCur) // not allowed to seek before start, but are allowed to seek beyond end
        {
			m_pbCur = pbCur;
			if (plibNewPosition)
				(*plibNewPosition).QuadPart = m_pbCur - m_pbFirst;
        }
		else
			hr = E_INVALIDARG;
	}

    
    __DONE__
    return hr;
}



HRESULT CMemoryStream::SetSize(ULARGE_INTEGER libNewSize)
    {
    HRESULT_ hr = S_OK;
    __EXCLUSIVE__

    if (m_fReadOnly)
        return E_UNEXPECTED;

    ULONG cbMax = (ULONG)(m_pbMax - m_pbFirst);

    if (0L <= libNewSize && libNewSize <= cbMax)
        {
        // Fits in existing buffer. Just forget about a suffix of the buffer
        //
        m_pbMac = m_pbFirst + libNewSize.QuadPart;
        }
    else if (libNewSize > cbMax)
        {
        // Doesn't fit in buffer. Make a new one that's big enough.
        //
        // REVIEW: Try to use ReAlloc if it's implemented by the memory allocator
        //
        ULONG cbCur = PtrToUlong(m_pbCur) - PtrToUlong(m_pbFirst);
        ULONG cbNew = (ULONG)(libNewSize.QuadPart);
        BYTE* pbNew = (BYTE*)AllocateMemory(cbNew, m_alloc);
        if (pbNew)
            {
            memcpy(pbNew, m_pbFirst, min(cbCur, cbMax));
            FreeMemory(m_pbFirst);
            m_pbFirst   = pbNew;
            m_pbCur     = m_pbFirst + cbCur;
            m_pbMac     = m_pbFirst + cbNew;
            m_pbMax     = m_pbFirst + cbNew;
            }
        else
            hr = E_OUTOFMEMORY;
        }
    else
        hr = E_INVALIDARG;

    __DONE__
    return hr;
    }



HRESULT CMemoryStream::CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten)
    {
    HRESULT_ hr = S_OK;

    __EXCLUSIVE__

    ULARGE_INTEGER u;
    u.QuadPart = m_pbMac - m_pbCur;
    ULONG cbToRead = (ULONG)min(cb, u).QuadPart;
    ULONG cbWritten;

    hr = pstm->Write(m_pbCur, cbToRead, &cbWritten);
    m_pbCur += cbToRead;

    if (pcbRead)    pcbRead   ->QuadPart = cbToRead;
    if (pcbWritten) pcbWritten->QuadPart = cbWritten;

    if (cbToRead != cbWritten && !FAILED(hr))
        hr = STG_E_WRITEFAULT;
        
    __DONE__
    return hr;
    }

HRESULT CMemoryStream::Commit(DWORD grfCommitflags)
    {
    return S_OK;
    }

HRESULT CMemoryStream::Revert()
    {
    return S_OK;
    }

HRESULT CMemoryStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
    return E_NOTIMPL;
    }
    
HRESULT CMemoryStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
    return E_NOTIMPL;
    }

HRESULT CMemoryStream::Stat(STATSTG* pstatstg, DWORD grfStatFlag)
    {
    HRESULT_ hr = S_OK;
    __EXCLUSIVE__

    if (pstatstg) 
        {
        memset(pstatstg, 0, sizeof(*pstatstg));
        pstatstg->type              = STGTY_STREAM;
        pstatstg->cbSize.QuadPart   = m_pbMac - m_pbFirst;
        }
    else
        hr = E_INVALIDARG;

    __DONE__
    return hr;
    }

HRESULT CMemoryStream::Clone(IStream** ppstm)
    {
    *ppstm = NULL;
    return E_NOTIMPL;
    }


///////////////////////////////////////////////////////////////////
//
// Standard COM infrastructure stuff
//
///////////////////////////////////////////////////////////////////

HRESULT CMemoryStream::InnerQueryInterface(REFIID iid, LPVOID* ppv)
	{
	if (iid == IID_IUnknown)
		{
		*ppv = (IUnkInner *) this;
		}
	else if (iid == IID_IStream)
		{
		*ppv = (IStream *) this;
		}
	else if (iid == IID_IMemoryStream)
		{
		*ppv = (IMemoryStream*) this;
		}
    else
        {
        *ppv = NULL;
		return E_NOINTERFACE;
        }

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
	}


HRESULT __stdcall CreateMemoryStream(IUnknown* punkOuter, REFIID iid, void** ppv)
// Publically exported instantiation function.
    {
    return GenericInstantiator<CMemoryStream>::CreateInstance(NULL, iid, ppv);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\md5.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// md5.cpp
//
#include "stdpch.h"
#include "common.h"

void MD5::Init(BOOL fConstructed)
    {
    // These two fields are read only, and so initialization thereof can be 
    // omitted on the second and subsequent hashes using this same instance.
    //
    if (!fConstructed)
        {
        memset(m_padding, 0, 64);
        m_padding[0]=0x80;
        }

    m_cbitHashed = 0;
    m_cbData     = 0;
    m_a = 0x67452301;   // magic
    m_b = 0xefcdab89;   //      ... constants
    m_c = 0x98badcfe;   //              ... per
    m_d = 0x10325476;   //                      .. RFC1321
    }


void MD5::HashMore(const void* pvInput, ULONG cbInput)
// Hash the additional data into the state
    {
    const BYTE* pbInput = (const BYTE*)pvInput;

    m_cbitHashed += (cbInput<<3);

    ULONG cbRemaining = 64 - m_cbData;
    if (cbInput < cbRemaining)
        {
        // It doesn't fill up the buffer, so just store it
        memcpy(&m_data[m_cbData], pbInput, cbInput);
        m_cbData += cbInput;
        }
    else
        {
        // It does fill up the buffer. Fill up all that it will take
        memcpy(&m_data[m_cbData], pbInput, cbRemaining);

        // Hash the now-full buffer
        MD5Transform(m_state, (ULONG*)&m_data[0]);
        cbInput -= cbRemaining;
        pbInput += cbRemaining;

        // Hash the data in 64-byte runs, starting just after what we've copied
        while (cbInput >= 64)
            {
            MD5Transform(m_state, (ULONG*)pbInput);
            pbInput += 64;
            cbInput -= 64;
            }

        // Store the tail of the input into the buffer
        memcpy(&m_data[0], pbInput, cbInput);
        m_cbData = cbInput;
        }
    }


void MD5::GetHashValue(MD5HASHDATA* phash)
// Finalize the hash by appending the necessary padding and length count. Then
// return the final hash value.
    {
    union {
        ULONGLONG cbitHashed;
        BYTE      rgb[8];
        }u;

    // Remember how many bits there were in the input data
    u.cbitHashed = m_cbitHashed;

    // Calculate amount of padding needed. Enough so total byte count hashed is 56 mod 64
    ULONG cbPad = (m_cbData < 56 ? 56-m_cbData : 120-m_cbData);

    // Hash the padding
    HashMore(&m_padding[0], cbPad);

    // Hash the (before padding) bit length
    HashMore(&u.rgb[0], 8);

    // Return the hash value
    memcpy(phash, &m_a, 16);
    }




// We have two implementations of the core 'transform' at the heart
// of this hash: one in C, another in x86 assembler.
//
#ifndef _X86_
    #define USE_C_MD5_TRANSFORM
#endif

#if defined(USE_C_MD5_TRANSFORM)

    ////////////////////////////////////////////////////////////////
    //
    // ROTATE_LEFT should be a macro that updates its first operand
    // with its present value rotated left by the amount of its 
    // second operand, which is always a constant.
    // 
    // One way to portably do it would be
    //
    //      #define ROL(x, n)        (((x) << (n)) | ((x) >> (32-(n))))
    //      #define ROTATE_LEFT(x,n) (x) = ROL(x,n)
    //
    // but our compiler has an intrinsic!

    #define ROTATE_LEFT(x,n) (x) = _lrotl(x,n)

    ////////////////////////////////////////////////////////////////
    //
    // Constants used in each of the various rounds

    #define MD5_S11 7
    #define MD5_S12 12
    #define MD5_S13 17
    #define MD5_S14 22
    #define MD5_S21 5
    #define MD5_S22 9
    #define MD5_S23 14
    #define MD5_S24 20
    #define MD5_S31 4
    #define MD5_S32 11
    #define MD5_S33 16
    #define MD5_S34 23
    #define MD5_S41 6
    #define MD5_S42 10
    #define MD5_S43 15
    #define MD5_S44 21

    ////////////////////////////////////////////////////////////////
    //
    // The core twiddle functions

//  #define F(x, y, z) (((x) & (y)) | ((~x) & (z)))         // the function per the standard
    #define F(x, y, z) ((((z) ^ (y)) & (x)) ^ (z))          // an alternate encoding

//  #define G(x, y, z) (((x) & (z)) | ((y) & (~z)))         // the function per the standard
    #define G(x, y, z) ((((x) ^ (y)) & (z)) ^ (y))          // an alternate encoding

    #define H(x, y, z) ((x) ^ (y) ^ (z))

    #define I(x, y, z) ((y) ^ ((x) | (~z)))

    #define AC(ac)  ((ULONG)(ac))
    
    ////////////////////////////////////////////////////////////////

    #define FF(a, b, c, d, x, s, ac) { \
        (a) += F (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }
    
    ////////////////////////////////////////////////////////////////
    
    #define GG(a, b, c, d, x, s, ac) { \
        (a) += G (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }

    ////////////////////////////////////////////////////////////////

    #define HH(a, b, c, d, x, s, ac) { \
        (a) += H (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }
    
    ////////////////////////////////////////////////////////////////
    
    #define II(a, b, c, d, x, s, ac) { \
        (a) += I (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }

    void __stdcall MD5Transform(ULONG state[4], const ULONG* data)
        {
        ULONG a=state[0];
        ULONG b=state[1];
        ULONG c=state[2];
        ULONG d=state[3];

        // Round 1
        FF (a, b, c, d, data[ 0], MD5_S11, 0xd76aa478); // 1 
        FF (d, a, b, c, data[ 1], MD5_S12, 0xe8c7b756); // 2 
        FF (c, d, a, b, data[ 2], MD5_S13, 0x242070db); // 3 
        FF (b, c, d, a, data[ 3], MD5_S14, 0xc1bdceee); // 4 
        FF (a, b, c, d, data[ 4], MD5_S11, 0xf57c0faf); // 5 
        FF (d, a, b, c, data[ 5], MD5_S12, 0x4787c62a); // 6 
        FF (c, d, a, b, data[ 6], MD5_S13, 0xa8304613); // 7 
        FF (b, c, d, a, data[ 7], MD5_S14, 0xfd469501); // 8 
        FF (a, b, c, d, data[ 8], MD5_S11, 0x698098d8); // 9 
        FF (d, a, b, c, data[ 9], MD5_S12, 0x8b44f7af); // 10 
        FF (c, d, a, b, data[10], MD5_S13, 0xffff5bb1); // 11 
        FF (b, c, d, a, data[11], MD5_S14, 0x895cd7be); // 12 
        FF (a, b, c, d, data[12], MD5_S11, 0x6b901122); // 13 
        FF (d, a, b, c, data[13], MD5_S12, 0xfd987193); // 14 
        FF (c, d, a, b, data[14], MD5_S13, 0xa679438e); // 15 
        FF (b, c, d, a, data[15], MD5_S14, 0x49b40821); // 16 

        // Round 2
        GG (a, b, c, d, data[ 1], MD5_S21, 0xf61e2562); // 17 
        GG (d, a, b, c, data[ 6], MD5_S22, 0xc040b340); // 18 
        GG (c, d, a, b, data[11], MD5_S23, 0x265e5a51); // 19 
        GG (b, c, d, a, data[ 0], MD5_S24, 0xe9b6c7aa); // 20 
        GG (a, b, c, d, data[ 5], MD5_S21, 0xd62f105d); // 21 
        GG (d, a, b, c, data[10], MD5_S22,  0x2441453); // 22 
        GG (c, d, a, b, data[15], MD5_S23, 0xd8a1e681); // 23 
        GG (b, c, d, a, data[ 4], MD5_S24, 0xe7d3fbc8); // 24 
        GG (a, b, c, d, data[ 9], MD5_S21, 0x21e1cde6); // 25 
        GG (d, a, b, c, data[14], MD5_S22, 0xc33707d6); // 26 
        GG (c, d, a, b, data[ 3], MD5_S23, 0xf4d50d87); // 27 
        GG (b, c, d, a, data[ 8], MD5_S24, 0x455a14ed); // 28 
        GG (a, b, c, d, data[13], MD5_S21, 0xa9e3e905); // 29 
        GG (d, a, b, c, data[ 2], MD5_S22, 0xfcefa3f8); // 30 
        GG (c, d, a, b, data[ 7], MD5_S23, 0x676f02d9); // 31 
        GG (b, c, d, a, data[12], MD5_S24, 0x8d2a4c8a); // 32 

        // Round 3
        HH (a, b, c, d, data[ 5], MD5_S31, 0xfffa3942); // 33 
        HH (d, a, b, c, data[ 8], MD5_S32, 0x8771f681); // 34 
        HH (c, d, a, b, data[11], MD5_S33, 0x6d9d6122); // 35 
        HH (b, c, d, a, data[14], MD5_S34, 0xfde5380c); // 36 
        HH (a, b, c, d, data[ 1], MD5_S31, 0xa4beea44); // 37 
        HH (d, a, b, c, data[ 4], MD5_S32, 0x4bdecfa9); // 38 
        HH (c, d, a, b, data[ 7], MD5_S33, 0xf6bb4b60); // 39 
        HH (b, c, d, a, data[10], MD5_S34, 0xbebfbc70); // 40 
        HH (a, b, c, d, data[13], MD5_S31, 0x289b7ec6); // 41 
        HH (d, a, b, c, data[ 0], MD5_S32, 0xeaa127fa); // 42 
        HH (c, d, a, b, data[ 3], MD5_S33, 0xd4ef3085); // 43 
        HH (b, c, d, a, data[ 6], MD5_S34,  0x4881d05); // 44 
        HH (a, b, c, d, data[ 9], MD5_S31, 0xd9d4d039); // 45 
        HH (d, a, b, c, data[12], MD5_S32, 0xe6db99e5); // 46 
        HH (c, d, a, b, data[15], MD5_S33, 0x1fa27cf8); // 47 
        HH (b, c, d, a, data[ 2], MD5_S34, 0xc4ac5665); // 48 

        // Round 4
        II (a, b, c, d, data[ 0], MD5_S41, 0xf4292244); // 49 
        II (d, a, b, c, data[ 7], MD5_S42, 0x432aff97); // 50 
        II (c, d, a, b, data[14], MD5_S43, 0xab9423a7); // 51 
        II (b, c, d, a, data[ 5], MD5_S44, 0xfc93a039); // 52 
        II (a, b, c, d, data[12], MD5_S41, 0x655b59c3); // 53 
        II (d, a, b, c, data[ 3], MD5_S42, 0x8f0ccc92); // 54 
        II (c, d, a, b, data[10], MD5_S43, 0xffeff47d); // 55 
        II (b, c, d, a, data[ 1], MD5_S44, 0x85845dd1); // 56 
        II (a, b, c, d, data[ 8], MD5_S41, 0x6fa87e4f); // 57 
        II (d, a, b, c, data[15], MD5_S42, 0xfe2ce6e0); // 58 
        II (c, d, a, b, data[ 6], MD5_S43, 0xa3014314); // 59 
        II (b, c, d, a, data[13], MD5_S44, 0x4e0811a1); // 60 
        II (a, b, c, d, data[ 4], MD5_S41, 0xf7537e82); // 61 
        II (d, a, b, c, data[11], MD5_S42, 0xbd3af235); // 62 
        II (c, d, a, b, data[ 2], MD5_S43, 0x2ad7d2bb); // 63 
        II (b, c, d, a, data[ 9], MD5_S44, 0xeb86d391); // 64 

        state[0] += a;
        state[1] += b;
        state[2] += c;
        state[3] += d;
        }

#else

    __declspec(naked) void __stdcall MD5Transform(ULONG state[4], const ULONG* data)
    // This implementation uses some pretty funky arithmetic identities
    // to effect its logic. Way cool! Kudos to whomever came up with this.
    //
        {
        __asm
            {
            push        ebx
            push        esi
            
            mov         ecx,dword ptr [esp+10h]     // data pointer to ecx
            
            push        edi
            mov         edi,dword ptr [esp+10h]     // state pointer to edi
            
            push        ebp
            mov         ebx,dword ptr [edi+4]       // ebx = b
            mov         ebp,dword ptr [edi+8]       // ebp = c
            mov         edx,dword ptr [edi+0Ch]     // edx = d
            
            mov         eax,edx                     // eax = d
            xor         eax,ebp                     // eax =    d xor c
            and         eax,ebx                     // eax =   (d xor c) ^ b
            xor         eax,edx                     // eax =  ((d xor c) ^ b) xor d
            add         eax,dword ptr [ecx]         // eax = (((d xor c) ^ b) xor d) + data[0]
            add         eax,dword ptr [edi]         // eax = (((d xor c) ^ b) xor d) + data[0] + a
            sub         eax,28955B88h               // eax = (((d xor c) ^ b) xor d) + data[0] + a + ac
            rol         eax,7                       // rotated left in the standard way
            lea         esi,dword ptr [eax+ebx]     // store temp sum in esi
            
            mov         eax,ebp                     // eax =        c
            xor         eax,ebx                     // eax =  b xor c
            and         eax,esi                     // eax = (b xor c) ^ ...
            xor         eax,ebp
            add         eax,dword ptr [ecx+4]
            lea         eax,dword ptr [edx+eax-173848AAh]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [ebp+eax+242070DBh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+0Ch]
            lea         eax,dword ptr [ebx+eax-3E423112h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+10h]
            lea         eax,dword ptr [esi+eax-0A83F051h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+14h]
            lea         eax,dword ptr [edx+eax+4787C62Ah]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+18h]
            lea         eax,dword ptr [edi+eax-57CFB9EDh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+1Ch]
            lea         eax,dword ptr [ebx+eax-2B96AFFh]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+20h]
            lea         eax,dword ptr [esi+eax+698098D8h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+24h]
            lea         eax,dword ptr [edx+eax-74BB0851h]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+28h]
            lea         eax,dword ptr [edi+eax-0A44Fh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+2Ch]
            lea         eax,dword ptr [ebx+eax-76A32842h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+30h]
            lea         eax,dword ptr [esi+eax+6B901122h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+34h]
            lea         eax,dword ptr [edx+eax-2678E6Dh]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+38h]
            lea         eax,dword ptr [edi+eax-5986BC72h]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+3Ch]
            lea         eax,dword ptr [ebx+eax+49B40821h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+4]
            lea         eax,dword ptr [esi+eax-9E1DA9Eh]
            rol         eax,5
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edi
            xor         eax,ebx
            add         eax,dword ptr [ecx+18h]
            lea         eax,dword ptr [edx+eax-3FBF4CC0h]
            rol         eax,9
            add         eax,esi
            
            mov         edx,eax                             // edx =    x
            xor         edx,esi                             // edx =   (x xor y)
            and         edx,ebx                             // edx =  ((x xor y) and z)
            xor         edx,esi                             // edx = (((x xor y) and z) xor y)
            add         edx,dword ptr [ecx+2Ch]             // edx = (((x xor y) and z) xor y) + data
            lea         edx,dword ptr [edi+edx+265E5A51h]   // edx = (((x xor y) and z) xor y) + data + ...
            rol         edx,0Eh
            lea         edi,dword ptr [eax+edx]
            
            mov         edx,eax
            xor         edx,edi
            and         edx,esi
            xor         edx,eax
            add         edx,dword ptr [ecx]
            lea         edx,dword ptr [ebx+edx-16493856h]
            mov         ebx,edi
            rol         edx,14h
            add         edx,edi

            xor         ebx,edx
            and         ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+14h]
            lea         esi,dword ptr [esi+ebx-29D0EFA3h]
            mov         ebx,edx
            rol         esi,5
            add         esi,edx

            xor         ebx,esi
            and         ebx,edi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+28h]
            lea         eax,dword ptr [eax+ebx+2441453h]
            rol         eax,9
            lea         ebx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,esi
            add         eax,dword ptr [ecx+3Ch]
            lea         eax,dword ptr [edi+eax-275E197Fh]
            rol         eax,0Eh
            lea         edi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,edi
            and         eax,esi
            xor         eax,ebx
            add         eax,dword ptr [ecx+10h]
            lea         eax,dword ptr [edx+eax-182C0438h]
            mov         edx,edi
            rol         eax,14h
            add         eax,edi
            
            xor         edx,eax
            and         edx,ebx
            xor         edx,edi
            add         edx,dword ptr [ecx+24h]
            lea         edx,dword ptr [esi+edx+21E1CDE6h]
            rol         edx,5
            lea         esi,dword ptr [eax+edx]
            
            mov         edx,eax
            xor         edx,esi
            and         edx,edi
            xor         edx,eax
            add         edx,dword ptr [ecx+38h]
            lea         edx,dword ptr [ebx+edx-3CC8F82Ah]
            rol         edx,9
            add         edx,esi
            
            mov         ebx,edx
            xor         ebx,esi
            and         ebx,eax
            xor         ebx,esi
            add         ebx,dword ptr [ecx+0Ch]
            lea         edi,dword ptr [edi+ebx-0B2AF279h]
            mov         ebx,edx
            rol         edi,0Eh
            add         edi,edx
            
            xor         ebx,edi
            and         ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+20h]
            lea         eax,dword ptr [eax+ebx+455A14EDh]
            rol         eax,14h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+34h]
            lea         eax,dword ptr [esi+eax-561C16FBh]
            rol         eax,5
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edi
            xor         eax,ebx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [edx+eax-3105C08h]
            rol         eax,9
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,ebx
            xor         eax,esi
            add         eax,dword ptr [ecx+1Ch]
            lea         eax,dword ptr [edi+eax+676F02D9h]
            rol         eax,0Eh
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,edi
            mov         ebp,eax
            and         ebp,esi
            xor         ebp,edx
            add         ebp,dword ptr [ecx+30h]
            lea         ebx,dword ptr [ebx+ebp-72D5B376h]
            rol         ebx,14h
            add         ebx,edi
            
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+14h]
            lea         eax,dword ptr [esi+ebp-5C6BEh]
            mov         esi,edi
            rol         eax,4
            add         eax,ebx
            
            xor         esi,ebx
            xor         esi,eax
            add         esi,dword ptr [ecx+20h]
            lea         edx,dword ptr [edx+esi-788E097Fh]
            rol         edx,0Bh
            add         edx,eax
            
            mov         esi,edx
            mov         ebp,edx
            xor         esi,ebx
            xor         esi,eax
            add         esi,dword ptr [ecx+2Ch]
            lea         esi,dword ptr [edi+esi+6D9D6122h]
            rol         esi,10h
            add         esi,edx
            
            xor         ebp,esi
            mov         edi,ebp
            xor         edi,eax
            add         edi,dword ptr [ecx+38h]
            lea         edi,dword ptr [ebx+edi-21AC7F4h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebx,edi
            xor         ebx,ebp
            add         ebx,dword ptr [ecx+4]
            lea         eax,dword ptr [eax+ebx-5B4115BCh]
            mov         ebx,esi
            rol         eax,4
            add         eax,edi
            
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+10h]
            lea         edx,dword ptr [edx+ebx+4BDECFA9h]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+1Ch]
            lea         esi,dword ptr [esi+ebx-944B4A0h]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+28h]
            lea         edi,dword ptr [edi+ebp-41404390h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebp,edi
            xor         ebp,ebx
            mov         ebx,esi
            add         ebp,dword ptr [ecx+34h]
            xor         ebx,edi
            lea         eax,dword ptr [eax+ebp+289B7EC6h]
            rol         eax,4
            add         eax,edi
            
            xor         ebx,eax
            add         ebx,dword ptr [ecx]
            lea         edx,dword ptr [edx+ebx-155ED806h]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+0Ch]
            lea         esi,dword ptr [esi+ebx-2B10CF7Bh]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+18h]
            lea         edi,dword ptr [edi+ebp+4881D05h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebp,edi
            xor         ebp,ebx
            mov         ebx,esi
            add         ebp,dword ptr [ecx+24h]
            xor         ebx,edi
            lea         eax,dword ptr [eax+ebp-262B2FC7h]
            rol         eax,4
            add         eax,edi

            xor         ebx,eax
            add         ebx,dword ptr [ecx+30h]
            lea         edx,dword ptr [edx+ebx-1924661Bh]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+3Ch]
            lea         esi,dword ptr [esi+ebx+1FA27CF8h]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+8]
            lea         edi,dword ptr [edi+ebx-3B53A99Bh]
            mov         ebx,edx
            rol         edi,17h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx]
            lea         eax,dword ptr [eax+ebx-0BD6DDBCh]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+1Ch]
            lea         edx,dword ptr [edx+ebx+432AFF97h]
            mov         ebx,edi
            rol         edx,0Ah
            not         ebx
            add         edx,eax
            
            or          ebx,edx
            xor         ebx,eax
            add         ebx,dword ptr [ecx+38h]
            lea         esi,dword ptr [esi+ebx-546BDC59h]
            mov         ebx,eax
            rol         esi,0Fh
            not         ebx
            add         esi,edx
            
            or          ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+14h]
            lea         edi,dword ptr [edi+ebx-36C5FC7h]
            mov         ebx,edx
            rol         edi,15h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx+30h]
            lea         eax,dword ptr [eax+ebx+655B59C3h]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+0Ch]
            lea         edx,dword ptr [edx+ebx-70F3336Eh]
            rol         edx,0Ah
            add         edx,eax
            mov         ebx,edi
            not         ebx
            
            or          ebx,edx
            xor         ebx,eax
            add         ebx,dword ptr [ecx+28h]
            lea         esi,dword ptr [esi+ebx-100B83h]
            mov         ebx,eax
            rol         esi,0Fh
            not         ebx
            add         esi,edx
            
            or          ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+4]
            lea         edi,dword ptr [edi+ebx-7A7BA22Fh]
            mov         ebx,edx
            rol         edi,15h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx+20h]
            lea         eax,dword ptr [eax+ebx+6FA87E4Fh]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+3Ch]
            lea         edx,dword ptr [edx+ebx-1D31920h]
            rol         edx,0Ah
            lea         ebx,dword ptr [eax+edx]
            mov         edx,edi
            not         edx
            
            or          edx,ebx
            xor         edx,eax
            add         edx,dword ptr [ecx+18h]
            lea         edx,dword ptr [esi+edx-5CFEBCECh]
            rol         edx,0Fh
            lea         esi,dword ptr [ebx+edx]
            mov         edx,eax
            not         edx
            
            or          edx,esi
            xor         edx,ebx
            add         edx,dword ptr [ecx+34h]
            lea         edx,dword ptr [edi+edx+4E0811A1h]
            rol         edx,15h
            lea         edi,dword ptr [esi+edx]
            mov         edx,ebx
            not         edx
            
            or          edx,edi
            xor         edx,esi
            add         edx,dword ptr [ecx+10h]
            lea         eax,dword ptr [eax+edx-8AC817Eh]
            rol         eax,6
            lea         edx,dword ptr [edi+eax]
            mov         eax,esi
            not         eax
            
            or          eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+2Ch]
            lea         eax,dword ptr [ebx+eax-42C50DCBh]
            rol         eax,0Ah
            lea         ebx,dword ptr [edx+eax]
            mov         eax,edi
            not         eax
            
            or          eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [esi+eax+2AD7D2BBh]
            rol         eax,0Fh
            lea         esi,dword ptr [ebx+eax]
            mov         eax,edx
            not         eax
            
            or          eax,esi
            xor         eax,ebx
            add         eax,dword ptr [ecx+24h]
            lea         eax,dword ptr [edi+eax-14792C6Fh]
            mov         edi,dword ptr [esp+14h]
            rol         eax,15h
            add         eax,esi
            
            add         edx,dword ptr [edi]             // add in starting state
            add         eax,dword ptr [edi+4]
            add         esi,dword ptr [edi+8]
            add         ebx,dword ptr [edi+0Ch]
            
            pop         ebp
            mov         dword ptr [edi],edx             // store back new state
            mov         dword ptr [edi+4],eax
            mov         dword ptr [edi+8],esi
            mov         dword ptr [edi+0Ch],ebx

            pop         edi
            pop         esi
            pop         ebx
            ret         8
            }
        }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\memorystream.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// MemoryStream.h
//
// An implementation of IStream that sits on an IMalloc instance
//
class CMemoryStream :
        IStream, 
        IMemoryStream,
        NonPaged,
        IUnkInner
    {
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    XSLOCK      m_lock;
    POOL_TYPE   m_alloc;                    // Memory allocator to use to get more memory when we need it
    
    BYTE*       m_pbFirst;                  // First byte of buffer
    BYTE*       m_pbCur;                    // Place to write next byte
    BYTE*       m_pbMac;                    // Just past logical end of buffer
    BYTE*       m_pbMax;                    // Just past physical end of buffer

    BOOL        m_fReadOnly;                // Whether we are read-only or not


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    CMemoryStream(IUnknown* punkOuter = NULL)
        {
        m_refs              = 1;    // nb starts at one
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_alloc             = PagedPool;
        m_fReadOnly         = TRUE;

        m_lock.FInit();
        
        m_pbFirst = m_pbCur = m_pbMax = m_pbMac = NULL;
        }

    ~CMemoryStream()
        {
        // note that we don't free the buffer
        }

    HRESULT Init()
        {
        if (m_lock.FInit() == FALSE)
        	return E_OUTOFMEMORY;
        return S_OK;
        }

    ///////////////////////////////////////////////////////////////////
    //
    // IMemoryStream
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetReadOnly (BOOL);
    HRESULT STDCALL SetAllocator(POOL_TYPE);
    HRESULT STDCALL SetBuffer   (LPVOID pv,   ULONG cb);
    HRESULT STDCALL GetBuffer   (BLOB*);
    HRESULT STDCALL FreeBuffer  ();

    ///////////////////////////////////////////////////////////////////
    //
    // IStream
    //
    ///////////////////////////////////////////////////////////////////
    
    HRESULT STDCALL Read        (LPVOID  pvBuffer, ULONG cb, ULONG* pcbRead);
    HRESULT STDCALL Write       (LPCVOID pvBuffer, ULONG cb, ULONG* pcbWritten);
    HRESULT STDCALL Seek        (LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition);
    HRESULT STDCALL SetSize     (ULARGE_INTEGER libNewSize);
    HRESULT STDCALL CopyTo      (IStream*, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten);
    HRESULT STDCALL Commit      (DWORD grfCommitflags);
    HRESULT STDCALL Revert      ();
    HRESULT STDCALL LockRegion  (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    HRESULT STDCALL UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    HRESULT STDCALL Stat        (STATSTG*, DWORD grfStatFlag);
    HRESULT STDCALL Clone       (IStream**);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<CMemoryStream>;

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\registry.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// registry.cpp
//
#include "stdpch.h"
#include "common.h"

////////////////////////////////////////////////////////////////////////////////////
//
// OpenRegistryKey
//
// Open or create a registry key. 
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT OpenRegistryKey(
        HREG*       phkey,                  // place to return new key
        HREG        hKeyParent OPTIONAL,    // parent key to open under. may be NULL.
        LPCWSTR     wszKeyName,             // child key name
        DWORD       dwDesiredAccess,        // read, write, etc 
        BOOL        fCreate                 // whether to force creation or not
        )
    {
    OBJECT_ATTRIBUTES objectAttributes;
    //
    // Initialize the object for the key.
    //
    UNICODE_STRING u;
    RtlInitUnicodeString(&u, wszKeyName);
    InitializeObjectAttributes( &objectAttributes,
                                &u,
                                OBJ_CASE_INSENSITIVE,
                                hKeyParent.h,
                                (PSECURITY_DESCRIPTOR)NULL);

    NTSTATUS status;
    if (fCreate)
        {
        ULONG disposition;
        status = ZwCreateKey(&phkey->h, dwDesiredAccess,&objectAttributes, 0, (PUNICODE_STRING)NULL, REG_OPTION_NON_VOLATILE, &disposition);
        }
    else
        {
        status = ZwOpenKey(&phkey->h, dwDesiredAccess, &objectAttributes );
        }
    return HrNt(status);
    }

////////////////////////////////////////////////////////////////////////////////////
//
// EnumerateRegistryKeys
//
// Return the data of a named value under a key. Free the returned information 
// with FreeMemory.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT EnumerateRegistryKeys(HREG hkey, ULONG index, LPWSTR* pwsz)
{
    HRESULT hr = S_OK;
    *pwsz = NULL;

    KEY_BASIC_INFORMATION* pInfo = NULL;
#ifdef DBG
    ULONG cbTry = 4;
#else
	ULONG cbTry = MAX_PATH;
#endif

    while (!hr)
	{
        ULONG cb = cbTry;
        pInfo = (KEY_BASIC_INFORMATION*)AllocateMemory(cb);
        if (pInfo)
		{
            ULONG cbResult;
            NTSTATUS status = ZwEnumerateKey(hkey.h, index, KeyBasicInformation, pInfo, cb, &cbResult);
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL)
			{
                FreeMemory(pInfo); 
                cbTry *= 2;
			}
            else if (status == STATUS_NO_MORE_ENTRIES)
			{
                FreeMemory(pInfo);
                pInfo = NULL;
                break;
			}
            else if (status == STATUS_SUCCESS)
			{
                break;
			}
            else
			{
                FreeMemory(pInfo);
				pInfo = NULL;

                hr = HrNt(status);
			}
		}
        else
            hr = E_OUTOFMEMORY;
	}
    
    if (!hr && pInfo)
	{
        LPWSTR wsz = (LPWSTR)AllocateMemory(pInfo->NameLength + sizeof(WCHAR));
        if (wsz)
		{
            memcpy(wsz, &pInfo->Name[0], pInfo->NameLength);
            wsz[pInfo->NameLength / sizeof(WCHAR)] = 0;
            *pwsz = wsz;
		}
        else
            hr = E_OUTOFMEMORY;
	}

	if (pInfo)
		FreeMemory(pInfo);
    
    return hr;
}


////////////////////////////////////////////////////////////////////////////////////
//
// GetRegistryValue
//
// Return the data of a named value under a key. Free the returned information 
// with FreeMemory.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT GetRegistryValue(HREG hkey, LPCWSTR wszValue, PKEY_VALUE_FULL_INFORMATION *ppinfo, ULONG expectedType)
    {
    UNICODE_STRING              unicodeString;
    NTSTATUS                    status;
    PKEY_VALUE_FULL_INFORMATION pinfoBuffer;
    ULONG                       keyValueLength;

    RtlInitUnicodeString(&unicodeString, wszValue);

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey( hkey.h,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) 
        {
        return HrNt(status);
        }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    pinfoBuffer = (PKEY_VALUE_FULL_INFORMATION)AllocateMemory(keyValueLength);
    if (!pinfoBuffer) 
        {
        return HrNt(STATUS_INSUFFICIENT_RESOURCES);
        }

    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey( hkey.h,
                              &unicodeString,
                              KeyValueFullInformation,
                              pinfoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (NT_SUCCESS(status)) 
        {
        if (expectedType == REG_NONE || expectedType == pinfoBuffer->Type)
            {
            //
            // Everything worked, so simply return the address of the allocated
            // buffer to the caller, who is now responsible for freeing it.
            //
            *ppinfo = pinfoBuffer;
            return S_OK;
            }
        else
            {
            FreeMemory(pinfoBuffer);
            return REGDB_E_INVALIDVALUE;
            }
        }
    else
        {
        FreeMemory(pinfoBuffer);
        return HrNt(status);
        }
    }


////////////////////////////////////////////////////////////////////////////////////
//
// DoesRegistryValueExist
//
// Answer S_OK or S_FALSE as to whether a given value exists under a particular registry key.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT DoesRegistryValueExist(HREG hkey, LPCWSTR wszValue)
    {
    UNICODE_STRING              unicodeString;
    NTSTATUS                    status;
    ULONG                       keyValueLength;

    RtlInitUnicodeString(&unicodeString, wszValue);

    status = ZwQueryValueKey( hkey.h,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );

    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) 
        {
        return S_FALSE;
        }

    return S_OK;
    }


////////////////////////////////////////////////////////////////////////////////////
//
// SetRegistryValue
//
// Set the value of a named-value that lives under the given key. The value we
// set is the concatenation of a list of literal zero-terminated string values.
// The end of the list is indicated with a NULL entry.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT __cdecl SetRegistryValue(HREG hkey, LPCWSTR wszValueName, ...)
    {
    HRESULT_ hr = S_OK;

    LPWSTR wszValue;

    //
    // Concatenate the values altogether
    //
    va_list va;
    va_start(va, wszValueName);
    hr = StringCat(&wszValue, va);
    va_end(va);

    if (!hr)
        {
        //
        // Write the value
        //
        ULONG cbValue = (ULONG) (wcslen(wszValue)+1) * sizeof(WCHAR);
        NTSTATUS status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE, (PWSTR)hkey.h, (PWSTR)wszValueName, REG_SZ, wszValue, cbValue);
        if (NT_SUCCESS(status))
            {
            // All is well; do nothing
            }
        else
            hr = HrNt(status);

        //
        // Clean up
        //
        FreeMemory(wszValue);
        }

    return hr;
    }


////////////////////////////////////////////////////////////////////////////////////
//
// RegisterInterfaceName
//
// Helper routine that sets the name of a given interface IID in the registry.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT RegisterInterfaceName(REFIID iid, LPCWSTR wszInterfaceName)
    {
    HRESULT hr = S_OK;

    #define GUID_CCH 39
    LPCWSTR wszInterface = L"\\Registry\\Machine\\Software\\Classes\\Interface";
    HREG hKeyInterface;
    hr = CreateRegistryKey(&hKeyInterface, HREG(), wszInterface);
    if (!hr)
        {
        WCHAR wszIID[GUID_CCH];
        StringFromGuid(iid, &wszIID[0]);

        HREG hKeyIID;
        hr = CreateRegistryKey(&hKeyIID, hKeyInterface, wszIID);
        if (!hr)
            {
            hr = SetRegistryValue(hKeyIID, L"", wszInterfaceName);

            CloseRegistryKey(hKeyIID);
            }

        CloseRegistryKey(hKeyInterface);
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//

//JohnDoty: Removed KERNELMODE stuff
extern "C" {
#include "crtdbg.h"
}

#include <stdio.h>
#include <stdarg.h>

extern "C" {

//JohnDoty: Removed dependancy on kernel headers
//#include "ntos.h"
//#include "zwapi.h"
//#include "fsrtl.h"

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#define NT_INCLUDED

#include "windows.h"
#include "objbase.h"
}

#include "math.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\dll\txfdll.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfdll.cpp
//
#include "..\stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\compsusermode\makefile.inc ===
#
# makefile.inc
#
!include ..\compsmakefileinc.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\dllwf\txfdll.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfdll.cpp
//
#include "..\stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\txfutil.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfutil.cpp
//
#include "stdpch.h"
#include "common.h"

//#include "svcintfs.h"
#include "svcmsg.h"

/////////////////////////////////////////////////////////////////////////////////
//
// COM+ support functions called via COMSVCS.dll
//
/////////////////////////////////////////////////////////////////////////////////

typedef HRESULT __stdcall FN_ComSvcsLogError(HRESULT i_hrError, int i_iErrorMessageCode, LPWSTR i_wszInfo, BOOL i_fFailFast);
typedef DWORD __stdcall FN_ComSvcsExceptionFilter(EXCEPTION_POINTERS * i_xp, const WCHAR * i_wszMethodName, const WCHAR * i_wszObjectName);

void CallComSvcsLogError(HRESULT i_hrError, int i_iErrorMessageCode, LPWSTR i_wszInfo, BOOL i_fFailFast)
{
	HINSTANCE hInst = LoadLibrary(L"COMSVCS.dll");

	if (hInst)
	{
		FN_ComSvcsLogError * pfnComSvcsLogError = (FN_ComSvcsLogError *)GetProcAddress(hInst, "ComSvcsLogError");

		if (pfnComSvcsLogError)
		{
			HRESULT hr = (pfnComSvcsLogError)(i_hrError, i_iErrorMessageCode, i_wszInfo, i_fFailFast);
		}

		FreeLibrary(hInst);
	}

	if (!i_fFailFast) return;

	ASSERT(!"CallComSvcsLogError - terminating process");

	HANDLE hProcess = GetCurrentProcess();

	TerminateProcess(hProcess, 0);

} // CallComSvcsLogError


DWORD CallComSvcsExceptionFilter(EXCEPTION_POINTERS * i_xp, const WCHAR * i_wszMethodName, const WCHAR * i_wszObjectName) 
{
	HINSTANCE hInst = LoadLibrary(L"COMSVCS.dll");

	DWORD dwRc = EXCEPTION_EXECUTE_HANDLER;

	if (hInst)
		{
		FN_ComSvcsExceptionFilter * pfnComSvcsExceptionFilter = (FN_ComSvcsExceptionFilter *)GetProcAddress(hInst, "ComSvcsExceptionFilter");

		if (pfnComSvcsExceptionFilter)
			{
			dwRc = (pfnComSvcsExceptionFilter)(i_xp, i_wszMethodName, i_wszObjectName);
			}

		FreeLibrary(hInst);
		}

	return dwRc;

} // CallComSvcsExceptionFilter


/////////////////////////////////////////////////////////////////////////////////
//
// GUID conversion
//
/////////////////////////////////////////////////////////////////////////////////

void StringFromGuid(REFGUID guid, LPWSTR pwsz)
    {
    // Example: 
    //
    // {F75D63C5-14C8-11d1-97E4-00C04FB9618A}
    swprintf(pwsz, L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", 
        guid.Data1,
        guid.Data2,
        guid.Data3,
        guid.Data4[0], guid.Data4[1], 
        guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
    }


void StringFromGuid(REFGUID guid, LPSTR psz)
    {
    // Example:
    //
    // {F75D63C5-14C8-11d1-97E4-00C04FB9618A}
    sprintf(psz, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", 
        guid.Data1,
        guid.Data2,
        guid.Data3,
        guid.Data4[0], guid.Data4[1], 
        guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
    }



BOOL HexStringToDword(LPCWSTR& lpsz, DWORD& Value, int cDigits, WCHAR chDelim)
    {
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
        {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return FALSE;
        }

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
    }


HRESULT GuidFromString(LPCWSTR lpsz, GUID* pguid)
// Convert the indicated string to a GUID. More lenient than the OLE32 version,
// in that it works with or without the braces.
//
    {
    DWORD dw;

    if (L'{' == lpsz[0])    // skip opening brace if present
        lpsz++;

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))    return E_INVALIDARG;
    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))               return E_INVALIDARG;
    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))               return E_INVALIDARG;
    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))               return E_INVALIDARG;
    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[6] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[7] = (BYTE)dw;

    return S_OK;
    }

#ifndef KERNELMODE

HRESULT GuidFromString(LPCSTR sz, GUID* pguid)
    {
    HRESULT hr = S_OK;
    ULONG cch = lstrlenA(sz);
    ULONG cb  = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz = (LPWSTR)_alloca(cb);
    if (wsz)
        {
        MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cb);
        hr = GuidFromString(wsz, pguid);
        }
    else
        hr = E_OUTOFMEMORY;
    return hr;
    }

#endif

HRESULT __stdcall GuidFromString(UNICODE_STRING& u, GUID* pguid)
    {
    ULONG cch = u.Length / sizeof(WCHAR);
    ULONG cb = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz = (LPWSTR)_alloca(cb);
    if (wsz)
        {
        memcpy(wsz, u.Buffer, u.Length);
        wsz[cch] = 0;
        return GuidFromString(wsz, pguid);
        }
    else
        return E_OUTOFMEMORY;
    }

/////////////////////////////////////////////////////////////////////////////////
//
// String concatenation functions of various flavor. All allocate a new string
// in which to put the result, which must be freed by the caller.
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT __cdecl StringCat(UNICODE_STRING* pu, ...)
    {
    LPWSTR wsz;
    va_list va;
    va_start(va, pu);
    HRESULT hr = StringCat(&wsz, va);
    if (!hr)
        RtlInitUnicodeString(pu, wsz);
    else
        {
        pu->Length = 0;
        pu->Buffer = NULL;
        pu->MaximumLength = 0;
        }
    return hr;
    }

HRESULT __cdecl StringCat(LPWSTR* pwsz, ...)
    {
    va_list va;
    va_start(va, pwsz);
    return StringCat(pwsz, va);
    }

HRESULT StringCat(LPWSTR* pwsz, va_list vaIn)
    {
    HRESULT hr = S_OK;

    //
    // What's the total length of the strings we need to concat?
    //
    va_list va;
    SIZE_T cchTotal = 0;
    va = vaIn;
    while(true)
        {
        LPWSTR wsz = va_arg(va, LPWSTR);
        if (NULL == wsz)
            break;
        cchTotal += wcslen(wsz);
        }
    va_end(va);

    //
    // Allocate the string
    //
    SIZE_T cbTotal = (cchTotal+1) * sizeof(WCHAR);
    if (cbTotal > 0) 
        {
        LPWSTR wszBuffer = (LPWSTR)AllocateMemory(cbTotal);
        if (wszBuffer)
            {
            wszBuffer[0] = 0;

            //
            // Concatenate everything together
            //
            va = vaIn;
            while (true)
                {
                LPWSTR wsz = va_arg(va, LPWSTR);
                if (NULL == wsz)
                    break;
                wcscat(wszBuffer, wsz);
                }
            va_end(va);

            //
            // Return the string
            //
            *pwsz = wszBuffer;
            }
        else
            {
            *pwsz = NULL;
            hr = E_OUTOFMEMORY;
            }
        }
    else
        *pwsz = NULL;

    return hr;
    }

void ToUnicode(LPCSTR sz, LPWSTR wsz, ULONG cch)
// Convert the ansi string to unicode 
    {
    #if defined(KERNELMODE) || 1
        {
        UNICODE_STRING u;
        ANSI_STRING    a;

        u.Length        = 0;
        u.MaximumLength = (USHORT)(cch * sizeof(WCHAR));
        u.Buffer        = wsz;

        a.Length        = (USHORT) strlen(sz);
        a.MaximumLength = a.Length;
        a.Buffer        = (LPSTR)sz;

        RtlAnsiStringToUnicodeString(&u, &a, FALSE);
        wsz[strlen(sz)] = 0;
        }
    #else
        MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch);
    #endif
    }

LPWSTR ToUnicode(LPCSTR sz)
    {
    SIZE_T cch = strlen(sz) + 1;
    LPWSTR wsz = (LPWSTR)AllocateMemory( cch * sizeof(WCHAR) );
    if (wsz)
        {
        ToUnicode(sz, wsz, (ULONG) cch);
        }
    return wsz;
    }

//
/////////////////////////////////////////////////////////////
//
// 

HRESULT __cdecl StringUnicodeCat(UNICODE_STRING* puOut, ...)
// Concatenate a set of unicode strings together, returning a newly allocated unicode
// string. Return string is also zero terminated, just for convenience.
    {
    HRESULT hr = S_OK;

    puOut->Length = 0;
    puOut->Buffer = NULL;
    puOut->MaximumLength = 0;

    //
    // What's the total length of the strings we need to concat?
    //
    va_list va;
    int cbTotal = 0;
    va_start(va, puOut);
    while(true)
        {
        UNICODE_STRING* pu = va_arg(va, UNICODE_STRING*);
        if (NULL == pu)
            break;
        cbTotal += pu->Length;
        }
    va_end(va);
    cbTotal += 2;   // for terminating NULL

    //
    // Allocate the string
    //
    BYTE* pbBuffer = (BYTE*)AllocateMemory(cbTotal);
    if (pbBuffer)
        {
        // Concatenate everything together
        //
        int cbCur = 0;
        va_start(va, puOut);
        while (true)
            {
            UNICODE_STRING* pu = va_arg(va, UNICODE_STRING*);
            if (NULL == pu)
                break;
            memcpy(&pbBuffer[cbCur], pu->Buffer, pu->Length);
            cbCur += pu->Length;
            }
        va_end(va);

        //
        // Zero terminate and return the string
        //
        puOut->Buffer = (WCHAR*)pbBuffer;
        puOut->Length = (USHORT)(cbCur);
        puOut->MaximumLength = (USHORT)(cbTotal);

        puOut->Buffer[cbCur / sizeof(WCHAR)] = L'\0';
        }
    else
        hr = E_OUTOFMEMORY;

    return hr;
    }

//
/////////////////////////////////////////////////////////////
//
// UNICODE_STRING variation on strrchr. If the indicated 
// character is not found, then a UNICODE_STRING with 
// Buffer == NULL is returned; otherwise, a UNICODE_STRING
// which is a subset of the input string is returned.

UNICODE_STRING UnicodeFindLast(UNICODE_STRING* pu, WCHAR wch)
    {
    WCHAR* pwchFirst = pu->Buffer;
    WCHAR* pwchMax   = (WCHAR*)((BYTE*)pwchFirst + pu->Length);
    
    WCHAR* pwchFound = NULL;
    for (WCHAR* pwchCur = pwchFirst; pwchCur < pwchMax; pwchCur++)
        {
        if (*pwchCur == wch)
            pwchFound = pwchCur;
        }

    UNICODE_STRING u;
    if (pwchFound)
        {
        u.Buffer = pwchFound;
        u.Length = (unsigned short)(PtrToUlong(pwchMax) - PtrToUlong(pwchFound)) * sizeof(WCHAR);
        u.MaximumLength = u.Length + (pu->MaximumLength - pu->Length);
        }
    else
        {
        u.Buffer = NULL;
        u.Length = 0;
        u.MaximumLength = 0;
        }

    return u;
    }

//
/////////////////////////////////////////////////////////////
//
// Return a contingous unicode string from a given input one. Note that you
// can't call Free() on these to free the buffer.
//
UNICODE_STRING* UnicodeContingous(UNICODE_STRING* puIn)
    {
    int cbNeeded = sizeof(UNICODE_STRING) + puIn->Length;
    UNICODE_STRING* puOut = (UNICODE_STRING*)AllocateMemory(cbNeeded);
    if (puOut)
        {
        puOut->MaximumLength   = puIn->Length;
        puOut->Length          = puIn->Length;
        puOut->Buffer          = (LPWSTR)((BYTE*)puOut + sizeof(UNICODE_STRING));
        memcpy(puOut->Buffer, puIn->Buffer, puIn->Length);
        }
    return puOut;
    }

//
/////////////////////////////////////////////////////////////////////////////////
//
// Stream utilities
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT Read(IStream* pstm, LPVOID pBuffer, ULONG cbToRead)
    {
    ASSERT(pstm); ASSERT(pBuffer);
    HRESULT_ hr = S_OK;
    ULONG cbRead;
    hr = pstm->Read(pBuffer, cbToRead, &cbRead);
    if (cbToRead == cbRead)
        {
        ASSERT(!hr);
        }
    else 
        {
        if (!FAILED(hr))
            {
            hr = STG_E_READFAULT;
            }
        }
    return hr;
    }

HRESULT Write(IStream* pstm, const void *pBuffer, ULONG cbToWrite)
    {
    ASSERT(pstm); ASSERT(pBuffer || cbToWrite==0);
    HRESULT_ hr = S_OK;
    if (cbToWrite > 0)  // writing zero bytes is pointless, and perhaps dangerous (can truncate stream?)
        {
        ULONG cbWritten;
        hr = pstm->Write(pBuffer, cbToWrite, &cbWritten);
        if (cbToWrite == cbWritten)
            {
            ASSERT(!hr);
            }
        else 
            {
            if (!FAILED(hr))
                {
                hr = STG_E_WRITEFAULT;
                }
            }
        }
    return hr;
    }

HRESULT SeekFar(IStream* pstm, LONGLONG offset, STREAM_SEEK fromWhat)
    {
    ULARGE_INTEGER ulNewPosition;
    LARGE_INTEGER  lMove;
    lMove.QuadPart = offset;
    return pstm->Seek(lMove, fromWhat, &ulNewPosition);
    }

HRESULT Seek(IStream* pstm, LONG offset, STREAM_SEEK fromWhat)
    {
    ULARGE_INTEGER ulNewPosition;
    LARGE_INTEGER  lMove;
    lMove.QuadPart = offset;
    return pstm->Seek(lMove, fromWhat, &ulNewPosition);
    }

HRESULT Seek(IStream* pstm, ULONG offset, STREAM_SEEK fromWhat)
    {
    ULARGE_INTEGER ulNewPosition;
    LARGE_INTEGER  lMove;
    lMove.QuadPart = offset;
    return pstm->Seek(lMove, fromWhat, &ulNewPosition);
    }

/////////////////////////////////////////////////////////////////////////////////
//
// CanUseCompareExchange64
//
/////////////////////////////////////////////////////////////////////////////////

#if defined(_X86_) && !defined(KERNELMODE)


extern "C" BOOL __stdcall CanUseCompareExchange64()
// Figure out whether we're allowed to use hardware support for 8 byte interlocked compare exchange 
{
    return IsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE);    
}

#endif


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Error code managment
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

    extern "C" HRESULT HrNt(NTSTATUS status)
    // Convert an NTSTATUS code into an appropriate HRESULT
        {
        if (STATUS_SUCCESS == status)
            {
            // Straitforward success maps to itself 
            //
            return S_OK;
            }
        else if (NT_SUCCESS(status))
		{
            // Policy driven by fear of distorting existing code paths:
            // success statuses map to themselves!
			//
            return status;
            }
        else
            {
            switch (status)
                {
            //
            // Handle a few as mapping to equivalent first-class HRESULTs
            //
            case STATUS_NO_MEMORY:          return E_OUTOFMEMORY;
            case STATUS_NOT_IMPLEMENTED:    return E_NOTIMPL;
            case STATUS_INVALID_PARAMETER:  return E_INVALIDARG;
            //
            // The remainder we map through the RTL mapping table
            //
            default:
                {
                BOOL fFound = true;
                ULONG err;

                __try
                    {
                    err = RtlNtStatusToDosError(status);
                    }
                __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    // RtlNtStatusToDosError(status) might throw an DbgBreakPoint() (maybe only on checked builds)
                    // for unmapped codes. We don't care about that, and so catch and ignore it if it happens.
                    //
                    fFound = false;
                    }
                
                if (!fFound || err == ERROR_MR_MID_NOT_FOUND)
                    {
                    // There was no formal mapping for the status code. Do the best we can.
                    //
                    return HRESULT_FROM_NT(status);
                    }
                else
                    {
                    if (err == (ULONG)status)
                        {
                        // Status code mapped to itself
                        //
                        return HRESULT_FROM_NT(status);
                        }
                    else if (err < 65536)
                        {
                        // Status code mapped to a Win32 error code
                        // 
                        return HRESULT_FROM_WIN32(err);
                        }
                    else
                        {
                        // Status code mapped to something weird. Don't know how to HRESULT-ize
                        // the mapping, so HRESULT-ize the original status instead
                        //
                        return HRESULT_FROM_NT(status);
                        }
                    }
                }
            /* end switch */
                }
            }
        }

///////////////////////////////////////////////////////////////////////////////////////////////

#ifndef KERNELMODE
 
HRESULT HError();
HRESULT HError(DWORD dw);

HRESULT HError()
    {
    return HError(GetLastError());
    }

HRESULT HError(DWORD dw)
	{
	HRESULT hr;
	if (dw == 0)
		hr = S_OK;
	else if (dw <= 0xFFFF)
		hr = HRESULT_FROM_WIN32(dw);
	else
		hr = dw;
	
    #ifdef _DEBUG
    if (!FAILED(hr))
        {
        WCHAR szBuf[128];
        wsprintfW(szBuf, L"TXFAUX: GetLastError returned success (%08x) when it should have returned a failure\n", hr);
        OutputDebugStringW(szBuf);
        }
    #endif
    if (!FAILED(hr))
        {
        hr = E_UNEXPECTED;
        }

	return hr;
	}

#endif

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#ifdef KERNELMODE

// From windows/winnls/utf.h
// 
#define ASCII             0x007f

#define SHIFT_IN          '+'     // beginning of a shift sequence
#define SHIFT_OUT         '-'     // end       of a shift sequence

#define UTF8_2_MAX        0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2     0xc0    // 110x xxxx
#define UTF8_1ST_OF_3     0xe0    // 1110 xxxx
#define UTF8_TRAIL        0x80    // 10xx xxxx

#define HIGER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

// From windows/winnls/utf.c
// 
////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    char UTF8;

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                //
                //  Make room for the trail byte and add the trail byte
                //  value.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] <<= 6;
                    lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                }

                if (nTB == 0)
                {
                    //
                    //  End of sequence.  Advance the output counter.
                    //
                    cchWC++;
                }
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
//      SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int cchU8 = 0;                // # of UTF8 chars generated

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        if (*lpWC <= ASCII)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchU8] = (char)*lpWC;
            }
            cchU8++;
        }
        else if (*lpWC <= UTF8_2_MAX)
        {
            //
            //  Found 2 byte sequence if < 0x07ff (11 bits).
            //
            if (cchDest)
            {
                if ((cchU8 + 1) < cchDest)
                {
                    //
                    //  Use upper 5 bits in first byte.
                    //  Use lower 6 bits in second byte.
                    //
                    lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU8 += 2;
            }
        }
        else
        {
            //
            //  Found 3 byte sequence.
            //
            if (cchDest)
            {
                if ((cchU8 + 2) < cchDest)
                {
                    //
                    //  Use upper  4 bits in first byte.
                    //  Use middle 6 bits in second byte.
                    //  Use lower  6 bits in third byte.
                    //
                    lpDestStr[cchU8++] = UTF8_1ST_OF_3 | (*lpWC >> 12);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU8 += 3;
            }
        }

        lpWC++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}

#endif

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\ifnames.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       IfNames.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-10-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

char *apszIUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
};
char *apszIClassFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateInstance"
,    "LockServer"
};
char *apszIMarshalNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetUnmarshalClass"
,    "GetMarshalSizeMax"
,    "MarshalInterface"
,    "UnmarshalInterface"
,    "ReleaseMarshalData"
,    "DisconnectObject"
};
char *apszIStdMarshalInfoNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassForHandler"
};
char *apszIMessageFilterNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "HandleInComingCall"
,    "RetryRejectedCall"
,    "MessagePending"
};
char *apszIExternalConnectionNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "AddConnection"
,    "ReleaseConnection"
};
char *apszIEnumStringNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATSTGNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszILockBytesNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ReadAt"
,    "WriteAt"
,    "Flush"
,    "SetSize"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
};
char *apszIStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Read"
,    "Write"
,    "Seek"
,    "SetSize"
,    "CopyTo"
,    "Commit"
,    "Revert"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
,    "Clone"
};
char *apszIStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateStream"
,    "OpenStream"
,    "CreateStorage"
,    "OpenStorage"
,    "CopyTo"
,    "MoveElementTo"
,    "Commit"
,    "Revert"
,    "EnumElements"
,    "DestroyElement"
,    "RenameElement"
,    "SetElementTimes"
,    "SetClass"
,    "SetStateBits"
,    "Stat"
};
char *apszIRootStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SwitchToFile"
};
char *apszIEnumFORMATETCNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATDATANames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIDataObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetData"
,    "GetDataHere"
,    "QueryGetData"
,    "GetCanonicalFormatEtc"
,    "SetData"
,    "EnumFormatEtc"
,    "DAdvise"
,    "DUnadvise"
,    "EnumDAdvise"
};
char *apszIViewObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
};
char *apszIViewObject2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
,    "GetExtent"
};
char *apszIAdviseSinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
};
char *apszIAdviseSink2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
,    "OnLinkSrcChange"
};
char *apszIDataAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnDataChange"
};
char *apszIOleCacheNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
};
char *apszIOleCache2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
,    "UpdateCache"
,    "DiscardCache"
};
char *apszIOleCacheControlNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnRun"
,    "OnStop"
};
char *apszIDropTargetNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "DragEnter"
,    "DragOver"
,    "DragLeave"
,    "Drop"
};
char *apszIDropSourceNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "QueryContinueDrag"
,    "GiveFeedback"
};
char *apszIPersistNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
};
char *apszIPersistStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "InitNew"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "HandsOffStorage"
};
char *apszIPersistStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
};
char *apszIPersistFileNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "GetCurFile"
};
char *apszIBindCtxNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RegisterObjectBound"
,    "RevokeObjectBound"
,    "ReleaseBoundObjects"
,    "SetBindOptions"
,    "GetBindOptions"
,    "GetRunningObjectTable"
,    "RegisterObjectParam"
,    "GetObjectParam"
,    "EnumObjectParam"
,    "RevokeObjectParam"
};
char *apszIMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
,    "BindToObject"
,    "BindToStorage"
,    "Reduce"
,    "ComposeWith"
,    "Enum"
,    "IsEqual"
,    "Hash"
,    "IsRunning"
,    "GetTimeOfLastChange"
,    "Inverse"
,    "CommonPrefixWith"
,    "RelativePathTo"
,    "GetDisplayName"
,    "ParseDisplayName"
,    "IsSystemMoniker"
};
char *apszIRunningObjectTableNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Register"
,    "Revoke"
,    "IsRunning"
,    "GetObject"
,    "NoteChangeTime"
,    "GetTimeOfLastChange"
,    "EnumRunning"
};
char *apszIEnumMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumOLEVERBNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIOleObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetClientSite"
,    "GetClientSite"
,    "SetHostNames"
,    "Close"
,    "SetMoniker"
,    "GetMoniker"
,    "InitFromData"
,    "GetClipboardData"
,    "DoVerb"
,    "EnumVerbs"
,    "Update"
,    "IsUpToDate"
,    "GetUserClassID"
,    "GetUserType"
,    "SetExtent"
,    "GetExtent"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "GetMiscStatus"
,    "SetColorScheme"
};
char *apszIOleClientSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
};
char *apszIRunnableObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetRunningClass"
,    "Run"
,    "IsRunning"
,    "LockRunning"
,    "SetContainedObject"
};
char *apszIParseDisplayNameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
};
char *apszIOleContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
};
char *apszIOleItemContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
,    "GetObject"
,    "GetObjectStorage"
,    "IsRunning"
};
char *apszIOleAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnRename"
,    "SendOnSave"
,    "SendOnClose"
};
char *apszIOleLinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetUpdateOptions"
,    "GetUpdateOptions"
,    "SetSourceMoniker"
,    "GetSourceMoniker"
,    "SetSourceDisplayName"
,    "GetSourceDisplayName"
,    "BindToSource"
,    "BindIfRunning"
,    "GetBoundSource"
,    "UnbindSource"
,    "Update"
};
char *apszIOleWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
};
char *apszIOleInPlaceObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "InPlaceDeactivate"
,    "UIDeactivate"
,    "SetObjectRects"
,    "ReactivateAndUndo"
};
char *apszIOleInPlaceActiveObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "TranslateAccelerator"
,    "OnFrameWindowActivate"
,    "OnDocWindowActivate"
,    "ResizeBorder"
,    "EnableModeless"
};
char *apszIOleInPlaceUIWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
};
char *apszIOleInPlaceFrameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
,    "InsertMenus"
,    "SetMenu"
,    "RemoveMenus"
,    "SetStatusText"
,    "EnableModeless"
,    "TranslateAccelerator"
};
char *apszIOleInPlaceSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
};
char *apszIRpcChannelBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetBuffer"
,    "SendReceive"
,    "FreeBuffer"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
,    "DebugServerQueryInterface"
,    "DebugServerRelease"
};
char *apszIPSFactoryBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};
char *apszIRpcChannelNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetStream"
,    "Call"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
};
char *apszIPSFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};

char *apszIServerHandlerNames[] =
{
     "QueryInterface"
,    "AddRef"
,    "Release"
,    "RunAndInitialize"
,    "RunAndDoVerb"
,    "DoVerb"
};

char *apszIClientSiteHandlerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "PrivQueryInterface"
,    "PrivAddRef"
,    "PrivRelease"
,    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
,    "StartInPlaceActivation"
,    "DoInPlace"
,    "UndoInPlace"
};



char *apszIRpcServiceNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CheckContextHdl"
,    "GetChannelId"
,    "ReleaseChannel"
,    "DoChannelOperation"
,    "DoChnlOp_ADD_MARSHALCONNECTION"
,    "DoChnlOp_REMOVE_MARSHALCONNECTION"
,    "DoChnlOp_TRANSFER_MARSHALCONNECTION"
,    "DoChnlOp_LOCK_CONNECTION"
,    "DoChnlOp_UNLOCK_CONNECTION"
,    "DoChnlOp_DOESSUPPORTIID"
,    "DoChnlOp_OPERATION"
};

char *apszIRpcSCMNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassObject"
,    "CreateObject"
,    "ActivateObject"
};

char *apszIRpcCoAPINames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CoGetActiveClassObject"
,    "CoActivateObject"
,    "CoCreateObject"
};

char *apszInterfaceFromWindowProp[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetInterfaceFromWindowProp"
,    "PrivDragDrop"
};

char *apszISCMActivator[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SCMActivatorGetClassObject"
,    "SCMActivatorCreateInstance"
};
char *apszILocalSystemActivator[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassObject"
,    "CreateInstance"
,    "ObjectServerLoadDll"
,    "NotifyServerRetired"
};
char *apszIRemUnknown[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RemQueryInterface"
,    "RemAddRef"
,    "RemRelease"
};
char *apszIRundown[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RemQueryInterface"
,    "RemAddRef"
,    "RemRundownOid"
};




IIDMethodNames IidMethodNames[] =
{
     { &IID_IUnknown,               "IUnknown", apszIUnknownNames                                   }
    ,{ &IID_IClassFactory,          "IClassFactory", apszIClassFactoryNames                     }
    ,{ &IID_IMarshal,               "IMarshal", apszIMarshalNames                               }
    ,{ &IID_IStdMarshalInfo,        "IStdMarshalInfo", apszIStdMarshalInfoNames                 }
    ,{ &IID_IMessageFilter,         "IMessageFilter", apszIMessageFilterNames                   }
    ,{ &IID_IExternalConnection,    "IExternalConnection", apszIExternalConnectionNames         }
    ,{ &IID_IEnumString,            "IEnumString", apszIEnumStringNames                         }
    ,{ &IID_IEnumUnknown,           "IEnumUnknown", apszIEnumUnknownNames                       }
    ,{ &IID_IEnumSTATSTG,           "IEnumSTATSTG", apszIEnumSTATSTGNames                       }
    ,{ &IID_ILockBytes,             "ILockBytes", apszILockBytesNames                           }
    ,{ &IID_IStream,                "IStream", apszIStreamNames                                 }
    ,{ &IID_IStorage,               "IStorage", apszIStorageNames                               }
    ,{ &IID_IRootStorage,           "IRootStorage", apszIRootStorageNames                       }
    ,{ &IID_IEnumFORMATETC,         "IEnumFORMATETC", apszIEnumFORMATETCNames                   }
    ,{ &IID_IEnumSTATDATA,          "IEnumSTATDATA", apszIEnumSTATDATANames                     }
    ,{ &IID_IDataObject,            "IDataObject", apszIDataObjectNames                         }
    ,{ &IID_IViewObject,            "IViewObject", apszIViewObjectNames                         }
    ,{ &IID_IViewObject2,           "IViewObject2", apszIViewObject2Names                       }
    ,{ &IID_IAdviseSink,            "IAdviseSink", apszIAdviseSinkNames                         }
    ,{ &IID_IAdviseSink2,           "IAdviseSink2", apszIAdviseSink2Names                       }
    ,{ &IID_IDataAdviseHolder,      "IDataAdviseHolder", apszIDataAdviseHolderNames             }
    ,{ &IID_IOleCache,              "IOleCache", apszIOleCacheNames                             }
    ,{ &IID_IOleCache2,             "IOleCache2", apszIOleCache2Names                           }
    ,{ &IID_IOleCacheControl,       "IOleCacheControl", apszIOleCacheControlNames               }
    ,{ &IID_IDropTarget,            "IDropTarget", apszIDropTargetNames                         }
    ,{ &IID_IDropSource,            "IDropSource", apszIDropSourceNames                         }
    ,{ &IID_IPersist,               "IPersist", apszIPersistNames                               }
    ,{ &IID_IPersistStorage,        "IPersistStorage", apszIPersistStorageNames                 }
    ,{ &IID_IPersistStream,         "IPersistStream", apszIPersistStreamNames                   }
    ,{ &IID_IPersistFile,           "IPersistFile", apszIPersistFileNames                       }
    ,{ &IID_IBindCtx,               "IBindCtx", apszIBindCtxNames                               }
    ,{ &IID_IMoniker,               "IMoniker", apszIMonikerNames                               }
    ,{ &IID_IRunningObjectTable,    "IRunningObjectTable", apszIRunningObjectTableNames         }
    ,{ &IID_IEnumMoniker,           "IEnumMoniker", apszIEnumMonikerNames                       }
    ,{ &IID_IEnumOLEVERB,           "IEnumOLEVERB", apszIEnumOLEVERBNames                       }
    ,{ &IID_IOleObject,             "IOleObject", apszIOleObjectNames                           }
    ,{ &IID_IOleClientSite,         "IOleClientSite", apszIOleClientSiteNames                   }
    ,{ &IID_IRunnableObject,        "IRunnableObject", apszIRunnableObjectNames                 }
    ,{ &IID_IParseDisplayName,      "IParseDisplayName", apszIParseDisplayNameNames             }
    ,{ &IID_IOleContainer,          "IOleContainer", apszIOleContainerNames                     }
    ,{ &IID_IOleItemContainer,      "IOleItemContainer", apszIOleItemContainerNames             }
    ,{ &IID_IOleAdviseHolder,       "IOleAdviseHolder", apszIOleAdviseHolderNames               }
    ,{ &IID_IOleLink,               "IOleLink", apszIOleLinkNames                               }
    ,{ &IID_IOleWindow,             "IOleWindow", apszIOleWindowNames                           }
    ,{ &IID_IOleInPlaceObject,      "IOleInPlaceObject", apszIOleInPlaceObjectNames             }
    ,{ &IID_IOleInPlaceActiveObject,"IOleInPlaceActiveObject", apszIOleInPlaceActiveObjectNames }
    ,{ &IID_IOleInPlaceUIWindow,    "IOleInPlaceUIWindow", apszIOleInPlaceUIWindowNames         }
    ,{ &IID_IOleInPlaceFrame,       "IOleInPlaceFrame", apszIOleInPlaceFrameNames               }
    ,{ &IID_IOleInPlaceSite,        "IOleInPlaceSite", apszIOleInPlaceSiteNames                 }
    ,{ &IID_IRpcChannelBuffer,      "IRpcChannelBuffer", apszIRpcChannelBufferNames             }
    ,{ &IID_IRpcProxyBuffer,        "IRpcProxyBuffer", apszIRpcProxyBufferNames                 }
    ,{ &IID_IRpcStubBuffer,         "IRpcStubBuffer", apszIRpcStubBufferNames                   }
    ,{ &IID_IPSFactoryBuffer,       "IPSFactoryBuffer", apszIPSFactoryBufferNames               }
    ,{ &IID_IRpcChannel,            "IRpcChannel", apszIRpcChannelNames                         }
    ,{ &IID_IRpcProxy,              "IRpcProxy", apszIRpcProxyNames                             }
    ,{ &IID_IRpcStub,               "IRpcStub", apszIRpcStubNames                               }
    ,{ &IID_IPSFactory,             "IPSFactory", apszIPSFactoryNames                           }
#ifdef SERVER_HANDLER
    ,{ &IID_IServerHandler,         "IServerHandler", apszIServerHandlerNames                   }
    ,{ &IID_IClientSiteHandler,     "IClientSiteHandler", apszIClientSiteHandlerNames           }
#endif // SERVER_HANDLER
    ,{ &IID_IRpcService,            "IRpcService", apszIRpcServiceNames                         }
    ,{ &IID_IRpcSCM,                "IRpcSCM", apszIRpcSCMNames                                 }
    ,{ &IID_IRpcCoAPI,              "IRpcCoAPI", apszIRpcCoAPINames                             }
#ifdef DCOM
    ,{ &IID_IInterfaceFromWindowProp,"InterfaceFromWindowProp", apszInterfaceFromWindowProp     }
    ,{ &IID_ISystemActivator,                  "ISystemActivator", apszISCMActivator                                          }
    ,{ &IID_ILocalSystemActivator,             "ILocalSystemActivator", apszILocalSystemActivator                                }
    ,{ &IID_IRemUnknown,            "IRemUnknown", apszIRemUnknown                              }
    ,{ &IID_IRundown,               "IRundown", apszIRundown                                    }
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\txfaux\workerqueue.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// workerqueue.cpp
//
#include "stdpch.h"
#include "common.h"
#include "jtl/txfarray.h"

#include "svcmsg.h"

/////////////////////////////////////////////////////////////////////////////////////////

#if defined(USE_ICECAP)

    #include "icapexp.h"
    #define TXF_CONTROL_ICECAP(x) x

#else

    #define TXF_CONTROL_ICECAP(x)

#endif

/////////////////////////////////////////////////////////////////////////////////////////

#define dbg 0x03, "WORK_QUEUE"


/////////////////////////////////////////////////////////////////////////////////////////
//
// Some utilities
//
/////////////////////////////////////////////////////////////////////////////////////////

inline void IncrementLibraryUsageCount(HINSTANCE hinst, int nCount) 
    {
    WCHAR szModuleName[_MAX_PATH];
    GetModuleFileNameW(hinst, szModuleName, _MAX_PATH);
    while (nCount--)
        { 
        LoadLibraryW(szModuleName);
        }
    }

/////////////////////////////////////////////////////////////////////////////////////////
//
// Manager for a pool of worker threads
//
/////////////////////////////////////////////////////////////////////////////////////////

class WORK_QUEUE 
    {
    HANDLE    m_ioCompletionPort;
    int       m_threadPriority;

    EVENT     m_eventStop;
    BOOL      m_fClosingDown;

    ULONG     m_timeout;
    
    LONG      m_cTotalThreads;                  // the total number of threads in this pool
    LONG      m_cThreadWaitingOrStartingUp;     // the number of said threads that are not actively doing useful work
    LONG      m_cThreadMinWaiting;              // minimum number of threads that we keep in the pool

    ULONG     m_msDelayStartNewThread;          // fudge factor to control rate of creation of new threads

    LARGE_INTEGER   m_sumT;
    LARGE_INTEGER   m_sumTSquared;
    LARGE_INTEGER   m_scale;
    ULONG           m_n;

    LONG      m_refs;

    CRITICAL_SECTION m_csClosingDown;
    CRITICAL_SECTION m_csThreadShutdown;
    
    enum { m_timingUnits = 100000 };  // 1/100,000 of a sec == 10 uSec

public:

    WORK_QUEUE(int threadPriority=THREAD_PRIORITY_NORMAL)
            : m_eventStop(/*manual reset*/FALSE, /*signalled*/FALSE)
        {
        NTSTATUS status;
        status = RtlInitializeCriticalSection(&m_csClosingDown);
        if (!NTSUCCESS(status))
            FATAL_ERROR();
        status = RtlInitializeCriticalSection(&m_csThreadShutdown);
        if (!NTSUCCESS(status))
            FATAL_ERROR();

        m_ioCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0, 0);
        if (NULL == m_ioCompletionPort)
            {
            FATAL_ERROR(); // REVIEW
            }

        m_cTotalThreads    = 0;
        m_cThreadWaitingOrStartingUp  = 0;
        m_threadPriority   = threadPriority;

        EnterCriticalSection(&m_csClosingDown);
        m_fClosingDown     = FALSE;
        LeaveCriticalSection(&m_csClosingDown);
        
        m_msDelayStartNewThread = 0;
        // 
        // initial timeout is something big, but not INFINITE so all threads can 
        // eventually prune themselves out
        //
        m_timeout = 3 * 60 * 1000;         
        m_cThreadMinWaiting = 1;
        //
        // Init the statistics
        //
        m_sumT.QuadPart = 0; m_sumTSquared.QuadPart = 0; m_n = 0;
        QueryPerformanceFrequency(&m_scale); 
        m_scale = m_scale / (ULONG)m_timingUnits;
        if (m_scale.QuadPart == 0)
            m_scale.QuadPart = 1;
        //
        // Reference counting for liveness management
        //
        m_refs = 1;
        }

    void AddRef()   { InterlockedIncrement(&m_refs); }
    void Release()  { if (0 == InterlockedDecrement(&m_refs)) delete this; }

    BOOL StartNewThread()
    // Actually start up a new thread for the thread pool
        {
        BOOL result = FALSE;

        EnterCriticalSection(&m_csClosingDown);
        if(!m_fClosingDown){
            InterlockedIncrement(&m_cTotalThreads);
            LeaveCriticalSection(&m_csClosingDown);
        }
        else{ 
            LeaveCriticalSection(&m_csClosingDown);
            return TRUE;
        }
        
        DWORD threadId;
        //
        // Make sure that the current impersonation context is NOT propogated to the child thread
        //
        ///////////////////////////////
        //
		HANDLE hToken = NULL;
		OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &hToken);
		if (hToken != NULL)
            {
			SetThreadToken (NULL, NULL);
            }
        //
        HANDLE threadHandle = CreateThread(NULL, 0, ThreadLoop, this, 0, &threadId);
        //
		if (hToken != NULL)
		    {
			SetThreadToken (NULL, hToken);
			CloseHandle (hToken);
		    }
        //
        ///////////////////////////////
        //
        if (threadHandle != NULL)
            {
            InterlockedIncrement(&m_cThreadWaitingOrStartingUp);
            CloseHandle(threadHandle);
            result = TRUE;
            }
        else
            {
            InterlockedDecrement(&m_cTotalThreads);
            }

        return result;
        }

    ///////////

    struct DELAYED_THREAD_CREATION : TIMEOUT_ENTRY
    // Helper class used in ScheduleNewThreadCreation.
        {
        WORK_QUEUE* m_pqueue;

        DELAYED_THREAD_CREATION(WORK_QUEUE* pqueue)
            {
            m_pqueue = pqueue;
            m_pvContext = this;
            m_pfn       = StaticOnDelayedThreadCreationTimeout;
            }

        static void StaticOnDelayedThreadCreationTimeout(PVOID pvContext)
            {
            DELAYED_THREAD_CREATION* pdelay = (DELAYED_THREAD_CREATION*)pvContext;
            pdelay->m_pqueue->OnDelayedThreadCreationTimeout();
            delete pdelay;
            }

        };

    BOOL ScheduleNewThreadCreation()
    // Ensure that a new thread is available to take new work. We might possibly
    // delay actually doing this in order to attenuate growth in the number of threads
    // actually used.
    //
        {
        BOOL fResult = TRUE;

        LONG msDelay = m_msDelayStartNewThread;

        if (0 == msDelay)
            {
            // No delay needed, just start up a thread right now
            //
            fResult = StartNewThread();
            }
        else
            {
            // We're to retard the thread creation delay for a little bit
            //
            TIMEOUT_ENTRY* pdelay = new DELAYED_THREAD_CREATION(this);
            if (pdelay)
                {
                LONGLONG fileTimeDelay = (LONGLONG)msDelay * 1000 * 10;     // to units of 100ns
                HRESULT hr = pdelay->TimeoutAfter(fileTimeDelay);
                if (!hr)
                    {
                    // all is well: the delay has been scheduled.
                    }
                else
                    {
                    delete pdelay;
                    fResult = FALSE;
                    }
                }
            else
                fResult = FALSE; // OOM
            }

        return fResult;
        }

    void OnDelayedThreadCreationTimeout()
    // A delayed thread creation request has fired. If there's still not a thread who's guaranteed to consume
    // something from the queue, then start up a new thread to do so.
        {
        if (0 == m_cThreadWaitingOrStartingUp)
            {
            if (StartNewThread())
                {
                }
            else
                FATAL_ERROR();
            }
        else
            {
            // Some thread or other is starting up. He'll consume SOMETHING from the queue, so we'll make 
            // forward progress.
            }
        }

    void ComputeThreadCreationDelay()
    // Compute an appropriate thread creation delay based in current load etc
        {
        // Note: we reason here with concurrently updated values, but since the delay we're
        // going to be setting is only a heuristic, that's OK.
        //
        ULONG cThreads = m_cTotalThreads - m_cThreadWaitingOrStartingUp;
        ASSERT( (LONG)cThreads >= 0 );
        //
        // Heuristic: we delay based on the *log* of the number of threads.
        //
        ULONG l  = (cThreads >> 4);       // don't bother with any delay until we have at least 16 threads busy
        ULONG ms = 0;
        while (l != 0)
            {
            if (ms == 0)
                ms = 1;
            else
                ms *= 2;
            l = (l >> 2);
            }
        //
        m_msDelayStartNewThread = ms;
        }

    ///////////////

    BOOL Start()
    // Start up the queue
        {
        ASSERT(m_cTotalThreads == 0);
        return StartNewThread();
        }


    BOOL Add(WorkerQueueItem* pItem)
    // Add a new item to this queue
        {
        EnterCriticalSection(&m_csClosingDown);
        if (!m_fClosingDown && pItem)
            {
            BOOL bTemp = PostQueuedCompletionStatus(m_ioCompletionPort, 0, (UINT_PTR)pItem, NULL);
            LeaveCriticalSection(&m_csClosingDown);
            return bTemp;
            }
        else
            {
            LeaveCriticalSection(&m_csClosingDown);
            return FALSE;
            }
        }

private:
    ~WORK_QUEUE()
    // Close down the queue
        {
        EnterCriticalSection(&m_csClosingDown);
        m_fClosingDown = TRUE;
        m_eventStop.Reset();
        LeaveCriticalSection(&m_csClosingDown);
        //
        // We can't be graceful during process detach because, generally speaking, we
        // have at this time absolutely no darn way of communicating with those threads 
        // of ours to tell them to drain their work. So we don't even try. 
        //
        if (!g_fProcessDetach)
            {
            // Try to shut down somewhat more gracefully so as not to, for example,
            // leak memory from the items that they contain.
            //
            while (m_cTotalThreads > 0)
                {
                if (PostQueuedCompletionStatus(m_ioCompletionPort, 0, 0, NULL))
                    {
                    DEBUG(DebugTrace(dbg, "waiting for worker thread termination..."));
                    m_eventStop.Wait();
                    DEBUG(DebugTrace(dbg, "...worker thread terminated"));
                    }
                else
                    break; // posting failure: to heck with being graceful
                }
            }

        CloseHandle(m_ioCompletionPort);

        //Make sure we can enter and leave this critical section to ensure there
        //are no threads on their way out
        EnterCriticalSection(&m_csThreadShutdown);
        LeaveCriticalSection(&m_csThreadShutdown);

        DeleteCriticalSection(&m_csClosingDown);
        DeleteCriticalSection(&m_csThreadShutdown);
        
        }

private:
    static DWORD WINAPI ThreadLoop(LPVOID pvParam);

    DWORD WINAPI WorkerLoop();
    void  UpdateStatistics(const LARGE_INTEGER& tStart, const LARGE_INTEGER& tStop);
    };

/////////////////////////////////////////////////////////////////////////////////////////
//
// Main worker loop for thread pool
//
/////////////////////////////////////////////////////////////////////////////////////////

inline DWORD WINAPI WORK_QUEUE::WorkerLoop()
// The core thread pool worker loop
    {
    DEBUG(DebugTrace(dbg, "worker thread started...now %d threads in pool", m_cTotalThreads));

    BOOL fCoInitialized = FALSE;
    THREADID myThreadId = GetCurrentThreadId();
    SetThreadPriority(GetCurrentThread(), m_threadPriority);

    while (TRUE)
        {
        WorkerQueueItem* pItem = NULL;
        DWORD            bytesTransferred;
        LPOVERLAPPED     overlapped;
        ULONG            timeoutUsed = m_timeout;
        //
        // Wait for more work. Note that per ntos/ke/queueobj.c, the wait
        // discipline for a kernel queue / completion port is LIFO.
        //
        InterlockedIncrement(&m_cThreadWaitingOrStartingUp);
        //
        // Don't count our idle time in ICECAP
        //
        TXF_CONTROL_ICECAP(SuspendCAP());

        BOOL ioSuccess = GetQueuedCompletionStatus(
                        m_ioCompletionPort,
                        &bytesTransferred,
                        (ULONG_PTR*)&pItem,
                        &overlapped,
                        timeoutUsed
                        );  

        TXF_CONTROL_ICECAP(ResumeCAP());

        ULONG cThreadsNowWaitingOrStartingUp = InterlockedDecrement(&m_cThreadWaitingOrStartingUp);

        if (pItem != NULL)
            {
            // Something was dequeued. Implicitly, this must have been done successfully.
            //
            // Update our thread-creation throttling heuristic.
            //
            ComputeThreadCreationDelay();
            //
            // Make sure that there's always someone available to make forward progress in the queue
            //
            if (0==cThreadsNowWaitingOrStartingUp)
                {
                if (ScheduleNewThreadCreation())
                    {
                    }
                else
                    FATAL_ERROR();
                }
            //
            // Now actually carry out the work, CoInitializing ourselves if we need to.
            //
            if (!fCoInitialized)
                {
                fCoInitialized = TRUE;
                CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE | COINIT_SPEED_OVER_MEMORY);
                }

            EXCEPTION_RECORD e;
            __try
                {
                // Do it! Time it if we can.
                //
                LARGE_INTEGER timeStart, timeStop;
                BOOL          fTime;
                fTime = QueryPerformanceCounter(&timeStart);
                //
                pItem->WorkerRoutine(pItem->Parameter); // BTW: Now aren't allowed to touch pItem any more, since it might have just been deallocated
                //
                QueryPerformanceCounter(&timeStop);
                if (fTime && !m_fClosingDown)
                    {
                    UpdateStatistics(timeStart, timeStop);
                    }
                }

			// FIX: COM+ bug # 11947
			
			__except (CallComSvcsExceptionFilter(GetExceptionInformation(), NULL, NULL))
                {
					// the exception filter will write an event log message
                }
            }
        else
            {
            // Nothing was dequeued
            //
            if (!ioSuccess && (GetLastError() == WAIT_TIMEOUT))
                {
                EnterCriticalSection(&m_csClosingDown);
                if (m_fClosingDown)
                    {
                    // Timed out during shutdown because our queue is now fully drained
                    //
                    LeaveCriticalSection(&m_csClosingDown);
                    break;
                    }
                else // !m_fClosingDown
                    {
                    LeaveCriticalSection(&m_csClosingDown);
                    // If we time out during the normal course of events, and if we're not the
                    // last thread in the pool, then we commit suicide. This is what brings the
                    // size of the thread pool back down during a period of quiet that follows 
                    // a period of intense activity.
                    //
                    if (m_cThreadMinWaiting <= m_cThreadWaitingOrStartingUp)
                        {
                        DEBUG(DebugTrace(dbg, "no work for %d ms: committing suicide...", timeoutUsed));
                        break;
                        }
                    }
                }
            else
                {
                // Either a NULL item was posted, or we got some unexpected error.
                //
                // In practice, conditions where ioSuccess was FALSE but GetLastError() was zero 
                // have been observed during process termination sequences.
                //
                // In any case, this thread is going down.
                //
                if (ioSuccess)
                    {
                    // A NULL item posted. Try to get out gracefully, being careful to drain
                    // our queue.
                    //
                    ASSERT(m_fClosingDown);
                    m_timeout = 0;
                    }
                else
                    {
                    // We got one of the strange errors. Be sure that the thread actually exits,
                    // at the possible expense of not maybe somehow fully draining the queue.
                    //
                    Print("WORK_QUEUE: weird error 0x%08x...\n", GetLastError());
                    break;
                    }
                }
            }
        }

    if (fCoInitialized)
        {
        CoUninitialize();
        }

    EnterCriticalSection(&m_csThreadShutdown);
    InterlockedDecrement(&m_cTotalThreads);
    if(m_eventStop.IsInitialized()) m_eventStop.Set();

    DEBUG(DebugTrace(dbg, "worker thread exiting"));
    LeaveCriticalSection(&m_csThreadShutdown);

    return 0;
    }

DWORD WINAPI WORK_QUEUE::ThreadLoop(LPVOID pvParam)
    {
    WORK_QUEUE* queue = (WORK_QUEUE*)pvParam;
    InterlockedDecrement(&queue->m_cThreadWaitingOrStartingUp); // balance the increment in StartNewThread
    //
    // Keep the library alive for this thread so someone doesn't pull the rug out
    // from under us while our stack still points into it.
    //
    IncrementLibraryUsageCount(g_hinst, 1);
    DWORD dw = 0;
    //
    // Actually carry out all the work that people want us to
    //
    dw = queue->WorkerLoop();
    //
    // Nuke the library and kill this thread
    //
    FreeLibraryAndExitThread(g_hinst, dw);  // never returns
    return 0;                               // not actually reached
    }

void AddTo(LARGE_INTEGER& d, const LARGE_INTEGER& a)
// Add more info to the destination in a non-information losing way. Since we don't lock
// the whole 64 bits atomically, intermediate readers might see not fully added results,
// but so long as they are aware of that, and don't _propogate_ the error that might be
// present, that's ok.
    {
    LONG oldLowPart = InterlockedExchangeAdd((LONG*)&d.LowPart, a.LowPart);
    if ((ULONG)oldLowPart + (ULONG)a.LowPart < (ULONG)oldLowPart)
        {
        InterlockedIncrement(&d.HighPart);   // add in the cary
        }
    InterlockedExchangeAdd(&d.HighPart, a.HighPart);
    }


void WORK_QUEUE::UpdateStatistics(const LARGE_INTEGER& tStart, const LARGE_INTEGER& tStop)
    {
    // Update our timings statistics that will tell us when to kill off excess threads. The 
    // sample variance is given by:
    //
    //                     n
    //                    ---         _ 2
    //      2       1     \    ( t  - t) 
    //     S   =  -----   /       i
    //      n     (n-1)   ---
    //                    i=1
    //
    // Note, however, that
    //
    //           _ 2       2        _     _2
    //     (t  - t)   =   t    - 2t t   + t
    //       i             i       i
    //
    // so, summing over i, 
    //
    //                  (   n               n              )
    //                  (  ---   2       _ ---         _2  )
    //      2       1   (  \    t     - 2t \   t    + nt   )
    //     S   =  ----- (  /     i         /    i          )
    //      n     (n-1) (  ---             ---             )
    //                  (  i=1             i=1             )
    //
    //                  (   n             n      2       )
    //                  (  ---   2     ( ---    )        )
    //              1   (  \    t   -  ( \   t  )  / n   )
    //         =  ----- (  /     i     ( /    i )        )
    //            (n-1) (  ---         ( ---    )        )
    //                  (  i=1           i=1             )
    //
    //
    // Thus, to maintain the statistics, we keep track of sumT, sumTSquared, and n.
    // 
    // What we do, having gathered sufficient data to be of some significance, is to adjust 
    // the timeout period to be way up there in the tail of the distribution of service times.
    // Having hit such a timeout, our threads will commit suicide, modulo keeping a few extra
    // threads around to handle fluctuations.
    //
    ULONG n = InterlockedIncrement(&m_n);
    //
    // Scale the elapsed time to get reasonable units. Mainly so that m_sumTSquared doesn't
    // overflow and so that most timings don't round down to zero.
    //
    LARGE_INTEGER t        = (tStop - tStart) / m_scale;
    LARGE_INTEGER tSquared = t * t;
    
    AddTo(m_sumT, t);
    AddTo(m_sumTSquared, tSquared);

    const ULONG significanceThreshold = 1000;

    if ((n > significanceThreshold) && (n % 32 == 0)) // Don't adjust really very often: just not worth it. 32 is arbitrary.
        {
        // When we read m_sumT and m_sumTSquared here, we might get slightly incorrect answers
        // due to how we add increments to them (see AddTo above). However, since we're 
        // only seeking an approximate timeout hint in the first place, we live with it.
        //
        LARGE_INTEGER l; 
        l = m_sumT;        double sumT        = (double)l.QuadPart;
        l = m_sumTSquared; double sumTSquared = (double)l.QuadPart;
        //
        // Paranoia: We might be maybe just a chance going to overflow the counters. If we're
        // close, then reset the stats gathering machinery. REVIEW: We might consider doing
        // it more often just to make sure that the statistics reflect recent data and not
        // something from ages and ages and ages ago.
        //
        // 2^62 = 4.61169E+18
        //
        if (sumTSquared > 4.61169E+18)
            {
            // We don't do this thread safe, 'cause we can't. However, again, since we're only
            // interested in approximations, it doesn't really much matter.
            //
            m_n = 0;
            m_sumT.QuadPart = 0;
            m_sumTSquared.QuadPart = 0;
            }
        else
            {
            // Actually adjust the timeout period
            //
            double S2           = (n * sumTSquared - sumT * sumT) / ( (double)n * (n-1) );
            if(S2 < 0) return;
            double S            = sqrt(S2);
            double msS          = S * 1000.0 / m_timingUnits;           // in units of milliseconds
            double msMean       = sumT * 1000.0 / m_timingUnits / n;    // in units of milliseconds
            //
            LONG  msNewTimeout  = (LONG)(msMean + 30.0 * msS);          // thirty std devs is pretty arbitrary
            LONG  cThreadMin    = (LONG)(1.0 * msS / msMean + 1.0);     // #threads to keep on standby to handle fluctuation
            ASSERT(cThreadMin >= 1);
            //
            DEBUG(DebugTrace(dbg,"n=%d msS=%f, msMean=%f, new timeout=%d, cThreadMin=%d", n, msS, msMean, msNewTimeout, cThreadMin));
            //
            m_timeout           = msNewTimeout;
            m_cThreadMinWaiting = cThreadMin;
            }
        }
    }



/////////////////////////////////////////////////////////////
//
// The overall set of worker queues
//
class WorkerQueues
    {
    WORK_QUEUE* m_rgQueues[MaximumWorkQueue];

public:
    WorkerQueues()
        {
        for (ULONG t = CriticalWorkQueue; t<MaximumWorkQueue; t++)
            {
            m_rgQueues[(WORK_QUEUE_TYPE)t] = NULL;
            }
        }

    ~WorkerQueues()
        {
        Stop();
        }

    //////////////////////////////////////////////////////////////
    //
    // A spin lock that we use to avoid weird problems with calling
    // system routines during process detach. That is: you'd think
    // we'd use a system-provided lock mechanism, like say a critical
    // section. But you can't reliably use those if you're in the
    // middle of a process detach.

    struct SPIN_LOCK
        {
        THREADID m_ownerThread;

        SPIN_LOCK()
            {
            m_ownerThread = 0;
            }

        void LockExclusive()
            {
            THREADID thisThread = GetCurrentThreadId();

            for(;;)
                {
                THREADID currentOwner = (THREADID)InterlockedCompareExchangePointer((PVOID*)&m_ownerThread, *(PVOID*)&thisThread, (PVOID)0);
                if (currentOwner == 0)
                    {
                    break;  // We just acquired the lock
                    }
                else
                    {
                    // Relinquish the remainder of our time quantum
                    //
                    Sleep(0);
                    //
                    // Spin on...
                    }
                }

            ASSERT(WeOwnExclusive());
            }

        void ReleaseLock()
            {
            ASSERT(WeOwnExclusive());
            m_ownerThread = 0;
            }

        BOOL WeOwnExclusive()
            {
            return m_ownerThread == GetCurrentThreadId();
            }
        };

    //////////////////////////////////////////////////////////////

    SPIN_LOCK m_lock;

    void Stop()
    // Shut down all of the worker queues
        {
        for (ULONG t = CriticalWorkQueue; t<MaximumWorkQueue; t++)
            {
            m_lock.LockExclusive(); // Need this lock to remove the table's reference ####
            //
            WORK_QUEUE* pQueue = (WORK_QUEUE*)InterlockedExchangePointer((PVOID*)&m_rgQueues[(WORK_QUEUE_TYPE)t], NULL);
            if (pQueue)
                {
                pQueue->Release();
                }
            //
            m_lock.ReleaseLock();
            }

        }

    WORK_QUEUE* GetQueue(WORK_QUEUE_TYPE queue)
    // Returns a new refcnt on the indicated worker queue, creating it if needed
        {
        m_lock.LockExclusive(); // Use the lock to get the addref. See #### above.
        //
        WORK_QUEUE* pQueue = m_rgQueues[queue];
        if (pQueue)
            {
            pQueue->AddRef();
            }
        //
        m_lock.ReleaseLock();

        if (pQueue == NULL)
            {
            int threadPriority = THREAD_PRIORITY_NORMAL;
            switch (queue)
                {
            case DelayedWorkQueue:       threadPriority = THREAD_PRIORITY_NORMAL;       break;
            case CriticalWorkQueue:      threadPriority = THREAD_PRIORITY_ABOVE_NORMAL; break;
            case HyperCriticalWorkQueue: threadPriority = THREAD_PRIORITY_HIGHEST;      break;
                }
            //
            // Make a new queue
            //
            WORK_QUEUE* pNewQueue = new WORK_QUEUE(threadPriority); // returns ref cnt == 1

            if (pNewQueue)
                {
                // Try to swap it in: table then owns our newly created refcnt
                //
                WORK_QUEUE* pExistingQueue = (WORK_QUEUE*)InterlockedCompareExchangePointer((PVOID*)&m_rgQueues[queue], (PVOID)pNewQueue, (PVOID)NULL);

                if (NULL == pExistingQueue)
                    {
                    // What we just made is now current. So start the thing up!
                    //
                    if (!pNewQueue->Start())
                    {
						// FIX: COM+ bugs # 10464, # 11947
						
						// "COM+ could not create a new thread due to a low memory situation."

						CallComSvcsLogError(E_OUTOFMEMORY, IDS_E_THREAD_START_FAILED, L" ", TRUE);
					}

                    pQueue = pNewQueue;
                    pQueue->AddRef();           // table took the creation ref, we need another for return value
                    }
                else
                    {
                    // Someone else got there first
                    //
                    pNewQueue->Release();       // don't need the new queue
                    pQueue = pExistingQueue;
                    pQueue->AddRef();           // bump it for return value
                    }
                }
            }

        return pQueue;
        }
    };


/////////////////////////////////////////////////////////////
//
// Data
//
// This is the list of worker queues. We rely on the C++ Runtime 
// initialization to get it all initialized correctly, the threads
// a-going, etc.
//
WorkerQueues g_workerQueues;


void WorkerQueueItem::QueueTo(WORK_QUEUE_TYPE queue)
// Queue us to the appropriate worker queue
//
    {
    WORK_QUEUE* pQueue = g_workerQueues.GetQueue(queue);
    if (pQueue)
        {
        pQueue->Add(this);
        pQueue->Release();
        }
    else
        {
        // FATAL_ERROR(); ????
        }
    }



////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////
//// Timeout Services
////
//// Support for maintaining a large number of objects that have a like or
//// an approximate timeout duration.
////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#undef  dbg
#define dbg 0, "TIMER"

class TimeoutManager
    {
    XLOCK               m_lock;
    BOOL		 m_fCsInitialized;

    RTL_SPLAY_LINKS*    m_root;             // the root entry in the tree, or NULL if there are no entries

    BOOL                m_fClosingDown;
    ULONG               m_cTotalThreads;
    EVENT               m_newWorkEvent;

    static DWORD WINAPI ThreadLoop(LPVOID pvParam);
           DWORD        WorkerLoop();

    #ifdef KERNELMODE

    BOOL StartNewThread()
        {
        BOOL result = FALSE;
        if (1==InterlockedIncrement(&m_cTotalThreads))
            {
            HANDLE threadHandle;

            NTSTATUS status = PsCreateSystemThread(&threadHandle, (ACCESS_MASK)0L, NULL, NULL, NULL, (PKSTART_ROUTINE)ThreadLoop, this);
            if (STATUS_SUCCESS == status)
                {
                result = TRUE;
                }
            else
                InterlockedDecrement(&m_cTotalThreads);
            }
        else
            result = TRUE;
        return result;
        }

    #else

    BOOL StartNewThread()
        {
        BOOL result = FALSE;
        if (1==InterlockedIncrement(&m_cTotalThreads))
            {
            // Make sure that the current impersonation context isn't propogated to the new thread.
            //
            DWORD threadId;
			HANDLE hToken = NULL;
			OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &hToken);
            //
            /////////////////////////////
            //
			if (hToken != NULL)
                {
				SetThreadToken(NULL, NULL);
                }
            //
            HANDLE threadHandle = CreateThread(NULL, 0, ThreadLoop, this, 0, &threadId);
            //
			if (hToken != NULL)
			    {
				SetThreadToken(NULL, hToken);
				CloseHandle(hToken);
			    }
            //
            /////////////////////////////
            //
            if (threadHandle != NULL)
                {
                CloseHandle(threadHandle);
                result = TRUE;
                }
            else
                {
                InterlockedDecrement(&m_cTotalThreads);
                }
            }
        else
            result = TRUE;
        return result;
        }

    #endif

    LONGLONG GetCurrentTime() // returns time in UTC in units of 100ns
        {
        union {
            FILETIME ft;
            LONGLONG ull;
            LARGE_INTEGER largeInt;
            } u;
        #ifdef KERNELMODE
            KeQuerySystemTime(&u.largeInt);
        #else
            GetSystemTimeAsFileTime(&u.ft);
        #endif
        return u.ull;
        }

    DWORD GetCurrentDelta()
    // Answer the current timeout delta, in milliseconds, that the worker thread should wait
        {
        if (IsEmpty())
            return INFINITE;
        else
            {
            LONGLONG deadline = First()->m_deadline;
            LONGLONG now      = GetCurrentTime();
            LONGLONG delta    = deadline - now;
            //
            // delta is in units of 100ns. Convert to ms. Factor is 1000 * 10
            //
            if (delta > 0)
                return (ULONG)(delta / (LONGLONG)10000);
            else
                return 0;
            }
        }

    BOOL IsEmpty()
        {
        return NULL == m_root;
        }

    TIMEOUT_ENTRY* First()
    // Return the first entry in the worklist
        {
        if (IsEmpty())
            return NULL;
        else
            {
            PRTL_SPLAY_LINKS pNodeCur = m_root;
            while (RtlLeftChild(pNodeCur))
                {
                pNodeCur = RtlLeftChild(pNodeCur);
                }
            return CONTAINING_RECORD(pNodeCur, TIMEOUT_ENTRY, m_links);
            }
        }

    enum SEARCH_RESULT
        {
        EmptyTree,
        FoundNode,
        InsertAsLeft,
        InsertAsRight
        };

    RTL_GENERIC_COMPARE_RESULTS Compare(TIMEOUT_ENTRY* p1, TIMEOUT_ENTRY* p2)
        {
        if (p1->m_deadline < p2->m_deadline)
            {
            return GenericLessThan;
            }
        else if (p1->m_deadline > p2->m_deadline)
            {
            return GenericGreaterThan;
            }
        else
            {
            // Same deadlines: sub-compare on pointer values
            if (p1 < p2)
                return GenericLessThan;
            else if (p1 > p2)
                return GenericGreaterThan;
            else
                return GenericEqual;
            }
        }

    TIMEOUT_ENTRY* EntryFromNode(PRTL_SPLAY_LINKS pNode)
        {
        return CONTAINING_RECORD(pNode, TIMEOUT_ENTRY, m_links);
        }

    SEARCH_RESULT FindNodeOrParent(TIMEOUT_ENTRY* pEntryNew, TIMEOUT_ENTRY** ppEntryParent)
    // Find the indicated node in the tree, or the parent node under which it should be found.
    // The tree is ordered by increasing deadline.
        {
        if (IsEmpty()) 
            {
            return EmptyTree;
            }
        else
            {
            PRTL_SPLAY_LINKS pNodeCur = m_root;
            PRTL_SPLAY_LINKS pNodeChild;

            while (TRUE) 
                {
                TIMEOUT_ENTRY* pEntryCur = EntryFromNode(pNodeCur);

                switch (Compare(pEntryNew, pEntryCur))
                    {
                case GenericLessThan:
                    {
                    pNodeChild = RtlLeftChild(pNodeCur);
                    if (pNodeChild) 
                        {
                        pNodeCur = pNodeChild;
                        }
                    else 
                        {
                        *ppEntryParent = EntryFromNode(pNodeCur);
                        return InsertAsLeft;
                        }
                    break;
                    }

                case GenericGreaterThan:
                    {
                    pNodeChild = RtlRightChild(pNodeCur);
                    if (pNodeChild)
                        {
                        pNodeCur = pNodeChild;
                        }
                    else
                        {
                        *ppEntryParent = EntryFromNode(pNodeCur);
                        return InsertAsRight;
                        }
                    break;
                    }

                case GenericEqual:
                    {
                    *ppEntryParent = EntryFromNode(pNodeCur);
                    return FoundNode;
                    }
                /* end switch */
                    }
                }
            }
        }

public:

    TimeoutManager() : m_newWorkEvent(/*manual reset*/FALSE, /*signalled*/FALSE)
        {
        m_fClosingDown = FALSE;
        m_cTotalThreads = 0;
        m_root = NULL;
        m_fCsInitialized = m_lock.FInit();
        }

    BOOL StartIfNeeded()
        {
        if (!m_fCsInitialized)
            {
            Assert(FALSE);
            return FALSE;
            }
        if (m_cTotalThreads == 0)
            return StartNewThread();
        else
            return true;
        }

    void Stop()
        {
        m_fClosingDown = TRUE;
        //
        // We can't be graceful during process detach because, generally speaking, we
        // have at this time absolutely no darn way of communicating with those threads 
        // of ours to tell them to drain their work. So we don't even try. 
        //
        #ifndef KERNELMODE
        if (!g_fProcessDetach)
        #endif
            {
            // Try to shut down somewhat more gracefully so as not to, for example,
            // leak memory from the items that they contain.
            //
            m_newWorkEvent.Set();
            }
        }


    HRESULT Add(TIMEOUT_ENTRY* pEntryNew, LONGLONG delta)
    // Add a new entry to the timeout list. It had better not already be in us
        {
        HRESULT hr = S_OK;
        LONGLONG now = GetCurrentTime();
        pEntryNew->m_deadline = now + delta;

        if (!m_fCsInitialized)
        {
            ASSERT(FALSE);
       	    return E_OUTOFMEM;
        }
        LockExclusive();

        TIMEOUT_ENTRY* pEntryFirstOld = First();

        TIMEOUT_ENTRY* pEntryParentOrCur;
        
        switch (FindNodeOrParent(pEntryNew, &pEntryParentOrCur))
            {
        case EmptyTree:         
            m_root = &pEntryNew->m_links;
            break;
            
        case InsertAsLeft:
            RtlInsertAsLeftChild(&pEntryParentOrCur->m_links, &pEntryNew->m_links);
            break;

        case InsertAsRight:
            RtlInsertAsRightChild(&pEntryParentOrCur->m_links, &pEntryNew->m_links);
            break;

        case FoundNode:
            NOTREACHED();
            break;
            }

        m_root = RtlSplay(&pEntryNew->m_links); // always splay the new node

        // If we changed the first entry in the list, then we had better reschedule
        // 
        if (First() != pEntryFirstOld)
            {
            m_newWorkEvent.Set();
            }

        ReleaseLock();

        return hr;
        }


    void Remove(TIMEOUT_ENTRY* pEntry)
    // Remove the entry from the tree, if it exists in our tree
    //
        {
        if (!m_fCsInitialized)
        {
            ASSERT(FALSE);
            return;
        }
        LockExclusive();

        TIMEOUT_ENTRY* pEntryParentOrCur;
        switch (FindNodeOrParent(pEntry, &pEntryParentOrCur))
            {
        case FoundNode:         
            m_root = RtlDelete(&pEntry->m_links);
            RtlInitializeSplayLinks(&pEntry->m_links);
            break;

        default:
            /* nothing to remove */;
            }

        ReleaseLock();
        }

    void LockExclusive() 
    	{
    	ASSERT(m_fCsInitialized);
    	m_lock.LockExclusive(); 
    	}
    void ReleaseLock()   
    	{
    	ASSERT(m_fCsInitialized);
    	m_lock.ReleaseLock();   
    	}
    };

TimeoutManager g_TimeoutManager;

////////////////////////////////////////////////////////////////////////////////

HRESULT TIMEOUT_ENTRY::TimeoutAfter(LONGLONG delta)
    {
    HRESULT hr = S_OK;

    CancelTimeout();

    if (g_TimeoutManager.StartIfNeeded())
        {
        hr = g_TimeoutManager.Add(this, delta);
        }
    else
        hr = E_UNEXPECTED;

    return hr;
    }

void TIMEOUT_ENTRY::CancelTimeout()
// Remove this entry from any timeout list it might be on
    {
    g_TimeoutManager.Remove(this);
    }

DWORD TimeoutManager::WorkerLoop()
// The core loop for the timeout thread
    {
    DEBUG(DebugTrace(dbg, "timeout worker loop started"));

    while (true)
        {
        // Find out how long we are to timeout, and wait for either that
        // duration or until we get notified that new work is available
        //
        LockExclusive();
        ULONG dwDelta = GetCurrentDelta();
        #ifdef _DEBUG
            LONGLONG firstDeadline = (First() ? First()->m_deadline : 0);
            DebugTrace(dbg, "wait=%d(ms)", dwDelta);
        #endif
        ReleaseLock();
        
        NTSTATUS status = m_newWorkEvent.Wait(dwDelta);
        switch (status)
            {
        case STATUS_TIMEOUT:
            {
            DEBUG(DebugTrace(dbg, "timed out"));

            // We timed out. Run down our first few entries and let them
            // know they hit their deadline.
            //
            if (m_fClosingDown) goto ExitThread;

            LONGLONG now = GetCurrentTime();

            LockExclusive();
            while (true)
                {
                TIMEOUT_ENTRY* p = First();
                if (p)
                    {
                    if (p->m_deadline < now)
                        {
                        // Remove it from the list
                        //
                        p->CancelTimeout();
                        //
                        // Let it know that it expired, but don't hold the lock while we call out
                        //
                        ReleaseLock();
                        // DebugTrace(dbg, "doing work");

                        EXCEPTION_RECORD e;
                        __try
                            {
                            p->m_pfn(p->m_pvContext);   // NOTE: may, generally speaking, destroy p, so can't use p after here...
                            }
                        __except(e = *(GetExceptionInformation())->ExceptionRecord, DebuggerFriendlyExceptionFilter(GetExceptionCode()))
                            {
                            Print("TIMER: exception 0x%08x raised from address 0x%08x\n", e.ExceptionCode, e.ExceptionAddress);
                            }
                        LockExclusive();
                        }
                    else
                        break;
                    }
                else
                    break;
                }
            ReleaseLock();

            break;
            }
        case STATUS_SUCCESS:
            {
            DEBUG(DebugTrace(dbg, "new work"));

            // New work for us, or we are to shut down.
            //
            if (m_fClosingDown)
                {
                goto ExitThread;
                }
            else
                {
                // Just go around and reschedule our timeout
                }
            break;
            }
        default:
            DEBUG(DebugTrace(dbg, "unexpected status code in TimeoutManager::WorkerLoop.Wait: 0x%08x", status));
            }
        }
ExitThread:
    DEBUG(DebugTrace(dbg, "timeout worker loop exiting"));
    InterlockedDecrement(&m_cTotalThreads);
    return 0;
    }

DWORD WINAPI TimeoutManager::ThreadLoop(LPVOID pvParam)
// REVIEW: for kernel mode, should use some mechanism that does the job of
// FreeLibraryAndExitThread. In the absence, the this library isn't really 
// safely unloadable, as it's uncertain when the thread actually exits.
    {
    TimeoutManager* lists = (TimeoutManager*)pvParam;

    ASSERT(lists->m_fCSInitialized == TRUE);

    //
    // Keep the library alive for this thread so someone doesn't pull the rug out
    // from under us while our stack still points into it.
    //
    #ifndef KERNELMODE
        IncrementLibraryUsageCount(g_hinst, 1);
    #endif
    //
    // Actually carry out all the work that people want us to
    //

    DWORD dw = lists->WorkerLoop();
    //
    // Nuke the library and kill this thread
    //
    #ifndef KERNELMODE
        FreeLibraryAndExitThread(g_hinst, dw);  // never returns
    #endif

    return 0;
    }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////
//// Shutting Down
////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void StopWorkerQueues()
    {
    #ifndef KERNELMODE
        g_workerQueues.Stop();
    #endif
    g_TimeoutManager.Stop();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\info.cxx ===
#include <ole2int.h>
#include <debnot.h>

DECLARE_INFOLEVEL(Cairole)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\exports.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       exports.cxx
//
//
//  History:    20-Jul-95    t-stevan    Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#pragma hdrstop

#if DBG==1

const char *g_pscExportNames[] =
{
    "CoInitialize"
,    "CoUninitialize"
,    "CoGetClassObject"
,    "CoRegisterClassObject"
,    "CoRevokeClassObject"
,    "CoMarshalInterface"
,    "CoUnmarshalInterface"
,    "CoReleaseMarshalData"
,    "CoDisconnectObject"
,    "CoLockObjectExternal"
,    "CoGetStandardMarshal"
,    "CoIsHandlerConnected"
,    "CoFreeAllLibraries"
,    "CoFreeUnusedLibraries"
,    "CoCreateInstance"
,    "CLSIDFromString"
,    "CoIsOle1Class"
,    "ProgIDFromCLSID"
,    "CLSIDFromProgID"
,    "CoCreateGuid"
,    "CoFileTimeToDosDateTime"
,    "CoDosDateTimeToFileTime"
,    "CoFileTimeNow"
,    "CoRegisterMessageFilter"
,    "CoGetTreatAsClass"
,    "CoTreatAsClass"
,    "DllGetClassObject"
,    "StgCreateDocfile"
,    "StgCreateDocfileOnILockBytes"
,    "StgOpenStorage"
,    "StgOpenStorageOnILockBytes"
,    "StgIsStorageFile"
,    "StgIsStorageILockBytes"
,    "StgSetTimes"
,    "CreateDataAdviseHolder"
,    "CreateDataCache"
,    "BindMoniker"
,    "MkParseDisplayName"
,    "MonikerRelativePathTo"
,    "MonikerCommonPrefixWith"
,    "CreateBindCtx"
,    "CreateGenericComposite"
,    "GetClassFile"
,    "CreateFileMoniker"
,    "CreateItemMoniker"
,    "CreateAntiMoniker"
,    "CreatePointerMoniker"
,    "GetRunningObjectTable"
,    "ReadClassStg"
,    "WriteClassStg"
,    "ReadClassStm"
,    "WriteClassStm"
,    "WriteFmtUserTypeStg"
,    "ReadFmtUserTypeStg"
,    "OleInitialize"
,    "OleUninitialize"
,    "OleQueryLinkFromData"
,    "OleQueryCreateFromData"
,    "OleCreate"
,    "OleCreateFromData"
,    "OleCreateLinkFromData"
,    "OleCreateStaticFromData"
,    "OleCreateLink"
,    "OleCreateLinkToFile"
,    "OleCreateFromFile"
,    "OleLoad"
,    "OleSave"
,    "OleLoadFromStream"
,    "OleSaveToStream"
,    "OleSetContainedObject"
,    "OleNoteObjectVisible"
,    "RegisterDragDrop"
,    "RevokeDragDrop"
,    "DoDragDrop"
,    "OleSetClipboard"
,    "OleGetClipboard"
,    "OleFlushClipboard"
,    "OleIsCurrentClipboard"
,    "OleCreateMenuDescriptor"
,    "OleSetMenuDescriptor"
,    "OleDestroyMenuDescriptor"
,    "OleDraw"
,    "OleRun"
,    "OleIsRunning"
,    "OleLockRunning"
,    "CreateOleAdviseHolder"
,    "OleCreateDefaultHandler"
,    "OleCreateEmbeddingHelper"
,    "OleRegGetUserType"
,    "OleRegGetMiscStatus"
,    "OleRegEnumFormatEtc"
,    "OleRegEnumVerbs"
,    "OleConvertIStorageToOLESTREAM"
,    "OleConvertOLESTREAMToIStorage"
,    "OleConvertIStorageToOLESTREAMEx"
,    "OleConvertOLESTREAMToIStorageEx"
,    "OleDoAutoConvert"
,    "OleGetAutoConvert"
,    "OleSetAutoConvert"
,    "GetConvertStg"
,    "SetConvertStg"
,    "ReadOleStg"
,    "WriteOleStg"
,     "CoGetCallerTID"
,     "CoGetState"
,     "CoSetState"
,     "CoMarshalHresult"
,     "CoUnmarshalHresult"
,     "CoGetCurrentLogicalThreadId"
,     "CoGetPSClsid"
,     "CoMarshalInterThreadInterfaceInStream"
,     "IIDFromString"
,     "StringFromCLSID"
,     "StringFromIID"
,     "StringFromGUID2"
,     "CoBuildVersion"
,     "CoGetMalloc"
,     "CoInitializeWOW"
,     "CoUnloadingWOW"
,     "CoTaskMemAlloc"
,     "CoTaskMemFree"
,     "CoTaskMemRealloc"
,     "CoFreeLibrary"
,     "CoLoadLibrary"
,     "CoCreateFreeThreadedMarshaler"
,     "OleInitializeWOW"
,     "OleDuplicateData"
,     "OleGetIconOfFile"
,     "OleGetIconOfClass"
,     "OleMetafilePictFromIconAndLabel"
,     "OleTranslateAccelerator"
,     "ReleaseStgMedium"
,     "ReadStringStream"
,     "WriteStringStream"
,     "OpenOrCreateStream"
,     "IsAccelerator"
,     "CreateILockBytesOnHGlobal"
,     "GetHGlobalFromILockBytes"
,     "SetDocumentBitStg"
,     "GetDocumentBitStg"
,     "CreateStreamOnHGlobal"
,     "GetHGlobalFromStream"
,     "CoGetInterfaceAndReleaseStream"
,     "CoGetCurrentProcess"
,     "CoQueryReleaseObject"
,     "CoRegisterMallocSpy"
,     "CoRevokeMallocSpy"
,     "CoGetMarshalSizeMax"
,     "CoGetObject"
,     "CreateClassMoniker"
,     "OleCreateEx"
,     "OleCreateFromDataEx"
,     "OleCreateLinkFromDataEx"
,     "OleCreateLinkEx"
,     "OleCreateLinkToFileEx"
,     "OleCreateFromFileEx"
,     "CoRegisterSurrogate"
,     "CoCreateInstanceExAsync"
,     "CoGetClassObjectAsync"
};

const char *g_pscInterfaceNames[] =
{
    "API",
    "IUnknown",
    "IClassFactory",
    "IMarshal"
};

const char *g_pscIUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
};
const char *g_pscIClassFactoryNames[] =
{
     "CreateInstance"
,    "LockServer"
};
const char *g_pscIMarshalNames[] =
{
     "GetUnmarshalClass"
,    "GetMarshalSizeMax"
,    "MarshalInterface"
,    "UnmarshalInterface"
,    "ReleaseMarshalData"
,    "DisconnectObject"
};

const char *g_pscIStdMarshalInfoNames[] =
{
    "GetClassForHandler"
};

const char *g_pscIMessageFilterNames[] =
{
     "HandleInComingCall"
,    "RetryRejectedCall"
,    "MessagePending"
};

const char *g_pscIExternalConnectionNames[] =
{
     "AddConnection"
,    "ReleaseConnection"
};

const char *g_pscIEnumStringNames[] =
{
     "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumUnknownNames[] =
{
     "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumSTATSTGNames[] =
{
     "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscILockBytesNames[] =
{
     "ReadAt"
,    "WriteAt"
,    "Flush"
,    "SetSize"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
};

const char *g_pscIStreamNames[] =
{
     "Read"
,    "Write"
,    "Seek"
,    "SetSize"
,    "CopyTo"
,    "Commit"
,    "Revert"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
,    "Clone"
};

const char *g_pscIStorageNames[] =
{
     "CreateStream"
,    "OpenStream"
,    "CreateStorage"
,    "OpenStorage"
,    "CopyTo"
,    "MoveElementTo"
,    "Commit"
,    "Revert"
,    "EnumElements"
,    "DestroyElement"
,    "RenameElement"
,    "SetElementTimes"
,    "SetClass"
,    "SetStateBits"
,    "Stat"
};

const char *g_pscIRootStorageNames[] =
{
    "SwitchToFile"
};

const char *g_pscIEnumFORMATETCNames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumSTATDATANames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIDataObjectNames[] =
{
    "GetData"
,    "GetDataHere"
,    "QueryGetData"
,    "GetCanonicalFormatEtc"
,    "SetData"
,    "EnumFormatEtc"
,    "DAdvise"
,    "DUnadvise"
,    "EnumDAdvise"
};

const char *g_pscIViewObjectNames[] =
{
    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
};

const char *g_pscIViewObject2Names[] =
{
    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
,    "GetExtent"
};

const char *g_pscIAdviseSinkNames[] =
{
    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
};

const char *g_pscIAdviseSink2Names[] =
{
    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
,    "OnLinkSrcChange"
};

const char *g_pscIDataAdviseHolderNames[] =
{
    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnDataChange"
};

const char *g_pscIOleCacheNames[] =
{
    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
};

const char *g_pscIOleCache2Names[] =
{
    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
,    "UpdateCache"
,    "DiscardCache"
};

const char *g_pscIOleCacheControlNames[] =
{
    "OnRun"
,    "OnStop"
};

const char *g_pscIDropTargetNames[] =
{
    "DragEnter"
,    "DragOver"
,    "DragLeave"
,    "Drop"
};

const char *g_pscIDropSourceNames[] =
{
    "QueryContinueDrag"
,    "GiveFeedback"
};

const char *g_pscIPersistNames[] =
{
    "GetClassID"
};

const char *g_pscIPersistStorageNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "InitNew"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "HandsOffStorage"
};

const char *g_pscIPersistStreamNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
};

const char *g_pscIPersistFileNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "GetCurFile"
};

const char *g_pscIBindCtxNames[] =
{
    "RegisterObjectBound"
,    "RevokeObjectBound"
,    "ReleaseBoundObjects"
,    "SetBindOptions"
,    "GetBindOptions"
,    "GetRunningObjectTable"
,    "RegisterObjectParam"
,    "GetObjectParam"
,    "EnumObjectParam"
,    "RevokeObjectParam"
};

const char *g_pscIMonikerNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
,    "BindToObject"
,    "BindToStorage"
,    "Reduce"
,    "ComposeWith"
,    "Enum"
,    "IsEqual"
,    "Hash"
,    "IsRunning"
,    "GetTimeOfLastChange"
,    "Inverse"
,    "CommonPrefixWith"
,    "RelativePathTo"
,    "GetDisplayName"
,    "ParseDisplayName"
,    "IsSystemMoniker"
};

const char *g_pscIRunningObjectTableNames[] =
{
    "Register"
,    "Revoke"
,    "IsRunning"
,    "GetObject"
,    "NoteChangeTime"
,    "GetTimeOfLastChange"
,    "EnumRunning"
};

const char *g_pscIEnumMonikerNames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumOLEVERBNames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIOleObjectNames[] =
{
    "SetClientSite"
,    "GetClientSite"
,    "SetHostNames"
,    "Close"
,    "SetMoniker"
,    "GetMoniker"
,    "InitFromData"
,    "GetClipboardData"
,    "DoVerb"
,    "EnumVerbs"
,    "Update"
,    "IsUpToDate"
,    "GetUserClassID"
,    "GetUserType"
,    "SetExtent"
,    "GetExtent"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "GetMiscStatus"
,    "SetColorScheme"
};

const char *g_pscIOleClientSiteNames[] =
{
    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
};

const char *g_pscIRunnableObjectNames[] =
{
    "GetRunningClass"
,    "Run"
,    "IsRunning"
,    "LockRunning"
,    "SetContainedObject"
};

const char *g_pscIParseDisplayNameNames[] =
{
    "ParseDisplayName"
};

const char *g_pscIOleContainerNames[] =
{
    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
};

const char *g_pscIOleItemContainerNames[] =
{
    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
,    "GetObject"
,    "GetObjectStorage"
,    "IsRunning"
};

const char *g_pscIOleAdviseHolderNames[] =
{
    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnRename"
,    "SendOnSave"
,    "SendOnClose"
};

const char *g_pscIOleLinkNames[] =
{
    "SetUpdateOptions"
,    "GetUpdateOptions"
,    "SetSourceMoniker"
,    "GetSourceMoniker"
,    "SetSourceDisplayName"
,    "GetSourceDisplayName"
,    "BindToSource"
,    "BindIfRunning"
,    "GetBoundSource"
,    "UnbindSource"
,    "Update"
};

const char *g_pscIOleWindowNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
};

const char *g_pscIOleInPlaceObjectNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "InPlaceDeactivate"
,    "UIDeactivate"
,    "SetObjectRects"
,    "ReactivateAndUndo"
};

const char *g_pscIOleInPlaceActiveObjectNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "TranslateAccelerator"
,    "OnFrameWindowActivate"
,    "OnDocWindowActivate"
,    "ResizeBorder"
,    "EnableModeless"
};

const char *g_pscIOleInPlaceUIWindowNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
};

const char *g_pscIOleInPlaceFrameNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
,    "InsertMenus"
,    "SetMenu"
,    "RemoveMenus"
,    "SetStatusText"
,    "EnableModeless"
,    "TranslateAccelerator"
};

const char *g_pscIOleInPlaceSiteNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
};

const char *g_pscIRpcChannelBufferNames[] =
{
    "GetBuffer"
,    "SendReceive"
,    "FreeBuffer"
,    "GetDestCtx"
,    "IsConnected"
};

const char *g_pscIRpcProxyBufferNames[] =
{
    "Connect"
,    "Disconnect"
};

const char *g_pscIRpcStubBufferNames[] =
{
    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
,    "DebugServerQueryInterface"
,    "DebugServerRelease"
};

const char *g_pscIPSFactoryBufferNames[] =
{
    "CreateProxy"
,    "CreateStub"
};

const char *g_pscIRpcChannelNames[] =
{
    "GetStream"
,    "Call"
,    "GetDestCtx"
,    "IsConnected"
};

const char *g_pscIRpcProxyNames[] =
{
    "Connect"
,    "Disconnect"
};

const char *g_pscIRpcStubNames[] =
{
    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
};

const char *g_pscIPSFactoryNames[] =
{
    "CreateProxy"
,    "CreateStub"
};

const char **g_ppNameTables[] =
{
    g_pscExportNames,
    g_pscIUnknownNames,
    g_pscIClassFactoryNames,
    g_pscIMarshalNames,
    g_pscIStdMarshalInfoNames,
    g_pscIMessageFilterNames,
    g_pscIExternalConnectionNames,
    g_pscIEnumStringNames,
    g_pscIEnumUnknownNames,
    g_pscIEnumSTATSTGNames,
    g_pscILockBytesNames,
    g_pscIStreamNames,
    g_pscIStorageNames,
    g_pscIRootStorageNames,
    g_pscIEnumFORMATETCNames,
    g_pscIEnumSTATDATANames,
    g_pscIDataObjectNames,
    g_pscIViewObjectNames,
    g_pscIViewObject2Names,
    g_pscIAdviseSinkNames,
    g_pscIAdviseSink2Names,
    g_pscIDataAdviseHolderNames,
    g_pscIOleCacheNames,
    g_pscIOleCache2Names,
    g_pscIOleCacheControlNames,
    g_pscIDropTargetNames,
    g_pscIDropSourceNames,
    g_pscIPersistNames,
    g_pscIPersistStorageNames,
    g_pscIPersistStreamNames,
    g_pscIPersistFileNames,
    g_pscIBindCtxNames,
    g_pscIMonikerNames,
    g_pscIRunningObjectTableNames,
    g_pscIEnumMonikerNames,
    g_pscIEnumOLEVERBNames,
    g_pscIOleObjectNames,
    g_pscIOleClientSiteNames,
    g_pscIRunnableObjectNames,
    g_pscIParseDisplayNameNames,
    g_pscIOleContainerNames,
    g_pscIOleItemContainerNames,
    g_pscIOleAdviseHolderNames,
    g_pscIOleLinkNames,
    g_pscIOleWindowNames,
    g_pscIOleInPlaceObjectNames,
    g_pscIOleInPlaceActiveObjectNames,
    g_pscIOleInPlaceUIWindowNames,
    g_pscIOleInPlaceFrameNames,
    g_pscIOleInPlaceSiteNames,
    g_pscIRpcChannelBufferNames,
    g_pscIRpcProxyBufferNames,
    g_pscIRpcStubBufferNames,
    g_pscIPSFactoryBufferNames,
    g_pscIRpcChannelNames,
    g_pscIRpcProxyNames,
    g_pscIRpcStubNames,
    g_pscIPSFactoryNames
};

#endif // DBG==1

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   util
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=    ..;..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=    $(INCLUDES);..\..\..\common;..\..\class;..\..\objact
INCLUDES=    $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=    $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=    $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)

C_DEFINES=    \
              $(C_DEFINES)    \
              -D_TRACKLINK_=1

SOURCES=      \
              $(SOURCES)      \
              ..\spyclnt.cxx  \
              ..\olespy.cxx   \
              ..\time.cxx     \
              ..\w32new.cxx   \
              ..\info.cxx     \
              ..\exports.cxx  \
              ..\task.cxx     \

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\spyclnt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spyclnt.cxx
//
//  Contents:   Funktionality for OleSpy client.
//
//  Classes:
//
//  Functions:
//
//  History:    8-16-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#pragma hdrstop
#if DBG==1
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "SpyClnt.hxx"

#define APPMAXLEN 512


static HANDLE       hPipe;             // File or Pipe handle.
static OVERLAPPED   OverLapWrt;        // Overlapped structure
static HANDLE       hEventWrt;         // Event handle for overlapped writes.


#undef wsprintf
#undef wsprintfA
#define wsprintf wsprintfA
#undef MessageBoxA
#undef MessageBox
#define MessageBox MessageBoxA

#undef CreateFileA
#undef CreateFile
#define CreateFile CreateFileA
#define GetModuleName GetModuleNameA

LPSTR GetAppName();


//+---------------------------------------------------------------------------
//
//  Function:   GetAppName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-16-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetAppName()
{
    static CHAR szAppName[APPMAXLEN];
    LPSTR psz, psz1;
    GetModuleFileNameA(NULL, szAppName, APPMAXLEN);
    psz = strrchr(szAppName, '\\');
    psz++;
    psz1 = strchr(psz,'.');
    *psz1 = '\0';
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SendEntry
//
//  Synopsis:
//
//  Arguments:  [szOutBuf] --
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int SendEntry(char * szOutBuf)
{
    DWORD  dwRet;
    char   szSendBuf[OUT_BUF_SIZE] = "";
    DWORD  cbWritten;

    wsprintf (szSendBuf, "%s: %s\n", GetAppName(), szOutBuf);
    dwRet = WriteFile (hPipe, szSendBuf, strlen(szSendBuf), &cbWritten, &OverLapWrt);

    if (!dwRet)
    {
        DWORD  dwLastError;
        dwLastError = GetLastError();

        // If Error = IO_PENDING, wait until the event signals success.
        if (dwLastError == ERROR_IO_PENDING)
        {
            WaitForSingleObject (hEventWrt, (DWORD)-1);
        }
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitClient
//
//  Synopsis:
//
//  Arguments:  [pszShrName] --
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int InitClient(char *pszShrName)
{
    CHAR   szSendBuf[OUT_BUF_SIZE] = "";
    CHAR   szFileName[LINE_LEN+NAME_SIZE+2];
    DWORD  dwRet;
    DWORD  dwLastError;
    DWORD  dwThreadID;
    DWORD  cbWritten;

    if (pszShrName == NULL)
    {
        return -1;
    }

    // Construct file/pipe name.
    wsprintf (szFileName, "%s%s%s", "\\\\", pszShrName, "\\PIPE\\OleSpy");

    // CreateFile() to connect to the named pipe. Generic access, read/write.
    hPipe = CreateFile(szFileName, GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE ,
                        NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);


    // Do some error checking.
    if (hPipe == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();

         // This error means pipe wasn't found.
        if ((dwRet == ERROR_SEEK_ON_DEVICE) || (dwRet == ERROR_FILE_NOT_FOUND))
        {
            MessageBox(NULL,"CANNOT FIND PIPE: Assure OleSpy is started on server.",
                   "", MB_OK);
        }
        else
        {
            CHAR   szErrorBuf[LINE_LEN] = "";
            // Flagging unknown errors.
            wsprintf (szErrorBuf,"CreateFile() on pipe failed, see winerror.h error #%d.",dwRet);
            MessageBox (NULL, szErrorBuf, "", MB_ICONINFORMATION | MB_OK | MB_APPLMODAL);
        }
        return -1;
    }

    // Create and init overlapped structure for writes.
    hEventWrt = CreateEvent (NULL, TRUE, FALSE, NULL);
    OverLapWrt.hEvent = hEventWrt;

    {
        LPSTR szStr = GetAppName();

        // Write the client name to server.
        dwRet = WriteFile(hPipe, szStr, strlen(szStr), &cbWritten, &OverLapWrt);
    }

    if (!dwRet)
    {
        dwLastError = GetLastError();

        // Wait on overlapped if need be.
        if (dwLastError == ERROR_IO_PENDING)
        {
            WaitForSingleObject(hEventWrt, (DWORD)-1);
        }
     }

    // Create a thread to read the pipe.
    CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)ReadPipe,
                 (LPVOID)&hPipe, 0, &dwThreadID);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitClient
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void UninitClient()
{
    CloseHandle (hPipe);
    CloseHandle (hEventWrt);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadPipe
//
//  Synopsis:
//
//  Arguments:  [hPipe] --
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID ReadPipe (HANDLE *hPipe)
{
    CHAR       inBuf[IN_BUF_SIZE] = "";// Input buffer.
    DWORD      bytesRead;              // Used for ReadFile()
    DWORD      dwRet;                  // Used to trap return codes.
    DWORD      dwLastError;            // Used to trap returns from GetLastError.

    HANDLE     hEventRd;               // Event handle for overlapped reads.
    OVERLAPPED OverLapRd;              // Overlapped structure.
    DWORD      bytesTrans;             // Bytes transferred in read.

                                       // Create and init overlap structure.
    hEventRd = CreateEvent (NULL, TRUE, FALSE, NULL);
    memset (&OverLapRd, 0, sizeof(OVERLAPPED));
    OverLapRd.hEvent = hEventRd;

    // Loop, reading the named pipe until it is broken.  The ReadFile() uses
    // an overlapped structure.  When the event handle signals a completed
    // read, this loop writes the message to the larger edit field.

    do {
        dwRet = ReadFile (*hPipe, inBuf, IN_BUF_SIZE, &bytesRead, &OverLapRd);
        // Do some error checking.
        if (!dwRet)
        {
            dwLastError = GetLastError();

            if (dwLastError == ERROR_IO_PENDING)
            {
                // If Error = IO_PENDING, wait for event
                // handle to signal success.
                WaitForSingleObject (hEventRd, (DWORD)-1);
            }
            else
            {
                // If pipe is broken, tell user and break.
                if (dwLastError == (DWORD)ERROR_BROKEN_PIPE)
                {
                    MessageBox (NULL,
                        "The connection to this client has been broken.", "", MB_OK);
                }
                else
                {
                    // Or flag unknown errors, and break.
                    CHAR       szErrorBuf[80];
                    wsprintf (szErrorBuf,
                              "ReadFile() on pipe failed, see winerror.h error #%d",GetLastError());
                    MessageBox (NULL, szErrorBuf, "", MB_OK);
                }
                break;
            }
        }
        // NULL terminate string.
        GetOverlappedResult (*hPipe, &OverLapRd, &bytesTrans, FALSE);
        inBuf[bytesTrans] = '\0';

     } while(1);

    ExitThread(0);
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\time.cxx ===
//+------------------------------------------------------------
//
// File:        time.cxx
//
// Contents:    Component object model time utilities
//
// Functions:   CoFileTimeToDosDateTime
//              CoDosDateTimeToFileTime
//              CoFileTimeNow
//
// History:     5-Apr-94       brucema         Created
//
//-------------------------------------------------------------
#include <ole2int.h>

#if defined (WIN32)

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
{
    OLETRACEIN((API_CoFileTimeToDosDateTime, PARAMFMT("lpFileTime= %tf, lpFatDate= %p, lpFatTime= %p"),
                                lpFileTime, lpFatDate, lpFatTime));
    BOOL fRet= FALSE;

    if ((lpFileTime != NULL) &&
        IsValidPtrIn(lpFileTime, sizeof(*lpFileTime)) &&
        IsValidPtrOut(lpFatDate, sizeof(*lpFatDate)) &&
        IsValidPtrOut(lpFatTime, sizeof(*lpFatTime)))
    {
        fRet = FileTimeToDosDateTime(lpFileTime, lpFatDate, lpFatTime);
    }

    OLETRACEOUTEX((API_CoFileTimeToDosDateTime, RETURNFMT("%B"), fRet));
    return fRet;
}

STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime)
{
    OLETRACEIN((API_CoDosDateTimeToFileTime, PARAMFMT("nDosDate=%x, nDosTime=%x, lpFileTime=%p"),
                                nDosDate, nDosTime, lpFileTime));

    BOOL fRet= FALSE;

    if (IsValidPtrOut(lpFileTime, sizeof(*lpFileTime)))
    {
        fRet = DosDateTimeToFileTime(nDosDate, nDosTime, lpFileTime);
    }

    OLETRACEOUTEX((API_CoDosDateTimeToFileTime, RETURNFMT("%B"), fRet));
    return fRet;
}

#else

#include <dos.h>
// 64 bit representation of 100ns units between 1-1-1601 and (excluding) 1-1-80
// in two 32 bit values  (H1980:L1980) and
// in four 16 bit values  (HH1980:HL1980:LH1980:LL1980)
//
#define H1980    0x01A8E79F
#define L1980    0xE1D59586
#define HH1980   0x01A8
#define HL1980   0xE79F
#define LH1980   0xE1D5
#define LL1980   0x9586

// Number of 100ns units in one second represented as one 32 bit value
//
#define ONESEC   10000000

// ONESEC0 * ONESEC1 = ONESEC both are 16 bits values
//
#define ONESEC0     4000
#define ONESEC1     2500

// Non-leap year accumulating days, excluding current month, jan is month[0]
static const UINT MonthTab[] = {0,31,59,90,120,151,181,212,243,273,304,334};

// Leap year accumulating days, excluding current month, jan is month[0]
static const UINT LeapmTab[] = {0,31,60,91,121,152,182,213,244,274,305,335};

// Accumulating days, excluding current year,  year[0] is leap year
static const UINT YearTab[] = {0,366,731,1096};

// Number of days in a four years period that includes a leap year
static const UINT FourYear = 1461;

// Number of days in a 100 years period that does not start with a leap year
static const DWORD HundredYear = 36524;

// Number of days in a 400 years period (starts with a leap year)
static const DWORD FourHundredYear = 146097;


#pragma SEG(CoFileTimeToDosDateTime)
STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
{
    DWORD Year,Month,Day,Hour,Min,Sec;
    DWORD Days, Seconds;
    DWORD LowNs, HighNs;
    int i;

    if ((lpFileTime == NULL) ||
        !IsValidPtrIn(lpFileTime, sizeof(*lpFileTime)) ||
        !IsValidPtrOut(lpFatDate, sizeof(*lpFatDate)) ||
        !IsValidPtrOut(lpFatTime, sizeof(*lpFatTime)))
    {
        return(FALSE);
    }

    LowNs =  lpFileTime->dwLowDateTime;
    HighNs = lpFileTime->dwHighDateTime;

    i = 1;

    // Note that the following code works because 2000 is a leap year
    // and DosDate year range is 1980 - 2099
    //
    _asm {
        mov     ax,word ptr LowNs
        mov     bx,word ptr LowNs+2
        mov     cx,word ptr HighNs
        mov     dx,word ptr HighNs+2 ; (dx:cx:bx:ax) = time in NT format
        sub     ax,LL1980
        sbb     bx,LH1980
        sbb     cx,HL1980
        sbb     dx,HH1980  ; (dx:cx:bx:ax) = 100ns since 1-1-1980
        jc      cvt0       ; Before the beginning of DosDateTime

        ; Divide (dx:cx:bx:ax) by ONESEC.
        ; Note that for any time before year 2100 the bumber of 100ns
        ; since 1-1-1980 divided by ONESEC0 < 2^48 (that is can be stored
        ; in three registers) and that the result divided by ONESEC1 < 2^32
        ;
        mov     si,cx      ; (dx:si:bx:ax) = 100ns since 1-1-1980
        mov     cx,ONESEC0
        mov     di,ax      ; (dx:si:bx:di) = 100ns since 1-1-1980
        mov     ax,dx      ; divide
        xor     dx,dx
        div     cx         ; ax = q (should be 0) dx = r (used in next div)
        or      ax,ax
        jnz     cvt0       ; past 1-1-2100
        mov     ax,si
        div     cx         ; ax = q (should be 0) dx = r (used in next div)
        mov     si,ax
        mov     ax,bx
        div     cx
        mov     bx,ax
        mov     ax,di
        div     cx
        mov     di,ax      ; (si:bx:di) = 100ns since 1-1-1980 / ONESEC0
        mov     ax,si
        mov     cx,ONESEC1
        xor     dx,dx
        div     cx         ; ax = q (should be 0) dx = r (used in next div)
        or      ax,ax
        jnz     cvt0       ; past 1-1-2100
        mov     ax,bx
        div     cx
        mov     word ptr Seconds+2,ax
        mov     ax,di
        div     cx
        mov     word ptr Seconds,ax
        mov     i,0        ; No error
cvt0:
    }

    if  (i)
        return FALSE;

    // Min, Hour, Days since 1980
    //
    Sec = Seconds % 60;
    Seconds /= 60;
    Min = Seconds % 60;
    Seconds /= 60;
    Hour = Seconds % 24;
    Days = Seconds / 24;

    // Find year number (1980 = 0)
    //
    Year = (Days / FourYear) * 4;
    Days %= FourYear;

    for (i = 1; i < 4; i++)
        if (Days < YearTab[i])
            break;

    i--;
    Year += i;
    Days -= YearTab[i];

    if (Year + 1980 > 2099)
        return FALSE;

    // Find month (jan == 1)
    //
    if (Year % 4) { // Non Leap year
        for (i = 1; i < 12; i++)
            if (Days < MonthTab[i])
                break;

        Month = i;
        Day = Days - MonthTab[i - 1] + 1;
    }
    else {
        for (i = 1; i < 12; i++)
            if (Days < LeapmTab[i])
                break;

        Month = i;
        Day = Days - LeapmTab[i - 1] + 1;
    }

    // The Dos time and date are stored in two packed 16-bit words
    // as follows:
    // Date:  | 9-15 Year | 5-8 Month | 0-4 Day |
    // Time:  | 11-15 Hour| 5-10 Min  | 0-4 Sec |
    // Year 1980 = 0
    // Month jan = 1
    // Day first = 1
    // Hours 0-23
    // Min 0-59
    // Seconds are delinated in 2sec increments (0-29).
    //
    *lpFatTime= (WORD) ((Hour << 11) + (Min << 5) + Sec / 2);
    *lpFatDate= (WORD) ((Year << 9) + (Month << 5) + Day);

    return (TRUE);
}

#pragma SEG(CoDosDateTimeToFileTime)
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime)
{
    DWORD Year,Month,Day,Hour,Min,Sec;
    DWORD Days, Seconds;
    DWORD LowNs, HighNs;

    if (!IsValidPtrOut(lpFileTime, sizeof(*lpFileTime))
    {
        return(FALSE);
    }

    // Note that the following code works because 2000 is a leap year
    // and DosDate year range is 1980 - 2099
    //
    // All operations done in Seconds, then multiply by 10^7.
    //
    // The Dos time and date are stored in two packed 16-bit words
    // as follows:
    // Date:  | 9-15 Year | 5-8 Month | 0-4 Day |
    // Time:  | 11-15 Hour| 5-10 Min  | 0-4 Sec |
    // Year 1980 = 0
    // Month jan = 1
    // Day first = 1
    // Hours 0-23
    // Min 0-59
    // Seconds are delinated in 2sec increments (0-29).
    //

    Year =  ((nDosDate >> 9) & 0x0000007f);
    Month = ((nDosDate >> 5) & 0x0000000f) - 1;
    Day =   ((nDosDate)      & 0x0000001f) - 1;

    Hour = ((nDosTime >> 11) & 0x0000001f);
    Min  = ((nDosTime >>  5) & 0x0000003f);
    Sec  = ((nDosTime <<  1) & 0x0000003e);

    if (Year < 0 || Month < 0 || Day < 0 || Hour < 0 || Min < 0 || Sec < 0 ||
           Month > 11 || Day > 30 || Hour > 23 || Min > 59 || Sec > 59)
    return FALSE;

    if (Year + 1980 > 2099)
        return FALSE;

    //
    // Calculate days since 1980


    Days = (Year / 4) * FourYear + YearTab[Year % 4] +
           ((Year % 4) ? MonthTab[Month] : LeapmTab[Month]) + Day;

    Seconds = ((Days * 24 + Hour) * 60 + Min) * 60 + Sec;

    LowNs = L1980;
    HighNs = H1980;

    _asm {
        mov     ax,word ptr Seconds
        mov     bx,word ptr Seconds+2

        ; Multiply (bx:ax) by ONESEC.
        ; Note that for any time before year 2100 the bumber of seconds
        ; since 1-1-1980 multiplied by ONESEC0 < 2^48 (that is can be stored
        ; in three registers)
        ;
        mov     cx,ONESEC0
        mul     cx
        mov     di,dx
        mov     si,ax               ; di:si = ax * ONESEC0
        mov     ax,bx
        xor     bx,bx
        mul     cx                  ; dx:ax = bx * ONESEC0
        add     di,ax
        adc     bx,dx               ; bx:di:si = Seconds * ONESEC0
        mov     ax,si
        mov     cx,ONESEC1
        mul     cx
        add     word ptr LowNs,ax
        adc     word ptr LowNs+2,dx
        adc     word ptr HighNs,0
        adc     word ptr HighNs+2,0
        mov     ax,di
        mul     cx
        add     word ptr LowNs+2,ax
        adc     word ptr HighNs,dx
        adc     word ptr HighNs+2,0
        mov     ax,bx
        mul     cx
        add     word ptr HighNs,ax
        adc     word ptr HighNs+2,dx
    }

    lpFileTime->dwLowDateTime = LowNs;
    lpFileTime->dwHighDateTime= HighNs;

    return (TRUE);
}

#endif  //  WIN32

#pragma SEG(CoFileTimeNow)

//
// Get the current UTC time, in the FILETIME format.
//

STDAPI  CoFileTimeNow(FILETIME *pfiletime )
{

    // Validate the input

    if (!IsValidPtrOut(pfiletime, sizeof(*pfiletime)))
    {
        return(E_INVALIDARG);
    }

#ifdef WIN32

    // Get the time in SYSTEMTIME format.

    SYSTEMTIME stNow;
    GetSystemTime(&stNow);

    // Convert it to FILETIME format.

    if( !SystemTimeToFileTime(&stNow, pfiletime) )
    {
        pfiletime->dwLowDateTime = 0;
        pfiletime->dwHighDateTime = 0;
        return( HRESULT_FROM_WIN32( GetLastError() ));
    }
    else
        return( NOERROR );

#else // WIN32

    static    struct _dosdate_t date;    // declared static so it will be in
    static    struct _dostime_t time;

    WORD    wDate;
    WORD    wTime;
    DWORD   dw;
    BOOL    fHighBitSet;

    _dos_getdate( &date );
    _dos_gettime( &time );

    //  build wDate
    wDate = date.day;
    wDate |= (date.month << 5);
    wDate |= ((date.year - 1980) << 9);

    //  build wTime;
    wTime = time.second / 2;
    wTime |= (time.minute << 5);
    wTime |= (time.hour << 11);


    if (!CoDosDateTimeToFileTime( wDate, wTime, pfiletime ))
    {
            return E_UNSPEC;
    }

    //  so far our resolution is only 2 seconds.
    dw = (time.second % 2)*100 + time.hsecond;
    dw *= 10000;
    //  add the difference and check for carry

    fHighBitSet = (((pfiletime->dwLowDateTime)& 0x80000000) != 0);
    pfiletime->dwLowDateTime += dw;
    if (fHighBitSet && ((pfiletime->dwLowDateTime & 0x80000000) == 0))
    {
        pfiletime->dwHighDateTime++;
    }

    return NOERROR;

#endif // WIN32

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\utexcept.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	utexcept.cxx
//
//  Contents:	Functions used to make exception handling nicer.
//
//  Functions:	SafeIUnknownRelease
//
//  History:	22-Jan-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include <ole2int.h>


//+-------------------------------------------------------------------------
//
//  Function:	SafeIUnknownRelease
//
//  Synopsis:	Guarantees that an IUnknown can be released without
//		causing an to be thrown outside of this routine.
//
//  Arguments:	[pUnk] - pointer to interface instance to release
//
//  Algorithm:	Verify pointer is not NULL then call its Release operation
//		inside of a try block.
//
//  History:	22-Jan-93 Ricksa    Created
//
//  Notes:	This exists because we are working under the assumption
//		that Release (like close on a file) cannot really fail.
//		And that if it does fail it should be ignored. This function
//		isn't really necessary, its purpose is simply to make code
//		smaller and easier to write by not duplicating thousands
//		of tiny try blocks throughout code which must clean up
//		interfaces before an exit.
//
//--------------------------------------------------------------------------
void SafeIUnknownRelease(IUnknown *pUnk)
{
    TRY
    {
	if (pUnk)
	{
	    pUnk->Release();
	}
    }
    CATCH(CException, e)
    {
	HandleException(e);
    }
    END_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\olespy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       rpcspy.cxx
//
//  Contents:   rpcspy functions
//
//  Classes:
//
//  Functions:
//
//  History:    7-06-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#pragma hdrstop
#if DBG==1

#include <smmutex.hxx>

#ifdef DCOM
#include    <activate.h>
#include    <getif.h>
#include    <objsrv.h>
#include    <remunk.h>
#include    <odeth.h>
#endif  // DCOM

#include <outfuncs.h>

#ifdef SERVER_HANDLER
#include "srvhdl.h"
#endif

#include "OleSpy.hxx"
#include "SpyClnt.hxx"

#include <trace.hxx>

void SetTraceInfoLevel(DWORD dwLevel);
int OleSpySendEntry(char * szOutBuf);


char szOutBuffer[2048];

typedef enum
{
     OleSpy_None   = 0
    ,OleSpy_Rpc    = 1
    ,OleSpy_API    = 2
    ,OleSpy_Method = 4
    ,OleSpy_OleThk = 8
} OleSpy;

// OleSpy output options
typedef  enum
{
     OleSpyOut_None     = 0
    ,OleSpyOut_Debugger = 1
    ,OleSpyOut_OleSpy   = 2
} OleSpyOut;

// interface to interface name and method mapping
typedef struct _tagIIDMethodNames
{
    IID const *piid;
    char *pszInterface;
    char **ppszMethodNames;
} IIDMethodNames;


DWORD nInCount = 0;
DWORD nOutCount = 0;

DWORD OleSpyOpt = OleSpy_None;
DWORD OleSpyOutput = OleSpyOut_None;
DWORD OleSpyBreakForUnknownCalls = 0;


// internal interfaces
IID IID_IRpcService = {0x0000001aL, 0, 0};
IID IID_IRpcSCM     = {0x0000001bL, 0, 0};
IID IID_IRpcCoAPI   = {0x0000001cL, 0, 0};
IID IID_IRpcDragDrop= {0x0000001dL, 0, 0};

CHAR   szSendBuf[OUT_BUF_SIZE] = "";   // Buffer used to modify message.
IIDMethodNames *GetIIDMethodName(REFIID riid);

//
// switch on to trace rpc calls
// by setting CairoleInfoLevel = DEB_USER1;
//
//
#define NESTING_SPACES 32
#define SPACES_PER_LEVEL 3
static char achSpaces[NESTING_SPACES+1] = "                                ";
WORD wlevel = 0;
char tabs[128];

//+---------------------------------------------------------------------------
//
//  Method:     PushLevel
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void PushLevel()
{
    wlevel++;
}
//+---------------------------------------------------------------------------
//
//  Method:     PopLevel
//
//  Synopsis:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void PopLevel()
{
    if (wlevel)
        wlevel--;
}

//+---------------------------------------------------------------------------
//
//  Method:     NestingSpaces
//
//  Synopsis:
//
//  Arguments:  [psz] --
//
//  Returns:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void NestingSpaces(char *psz)
{
    int iSpaces, i;

    iSpaces = wlevel * SPACES_PER_LEVEL;

    while (iSpaces > 0)
    {
        i = min(iSpaces, NESTING_SPACES);
        memcpy(psz, achSpaces, i);
        psz += i;
        *psz = 0;
        iSpaces -= i;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     GetTabs
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetTabs()
{
    static char ach[256];
    char *psz;

    wsprintfA(ach, "%2d:", wlevel);
    psz = ach+strlen(ach);

    if (sizeof(ach)/SPACES_PER_LEVEL <= wlevel)
    {
        strcpy(psz, "...");
    }
    else
    {
        NestingSpaces(psz);
    }
    return ach;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeOleSpy
//
//  Synopsis:
//
//  Arguments:  [dwLevel] --
//
//  Returns:
//
//  History:    11-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT UninitializeOleSpy(DWORD dwLevel)
{
    if (dwLevel == OLESPY_TRACE)
    {
        CleanupTraceInfo();
    }
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeOleSpy
//
//  Synopsis:
//
//  Arguments:  [dwReserved] --
//
//  Returns:
//
//  History:    11-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT InitializeOleSpy(DWORD dwLevel)
{
    CHAR szOleSpyInfo[] = "OleSpy";
    CHAR szServerName[SERVERNAMEMAX] = ".";
    CHAR *pszServerName = szServerName;
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);
    ULONG   ulValue = 0x0003;

    if (dwLevel == OLESPY_TRACE)
    {
        InitializeTraceInfo();
        return NOERROR;
    }

    if (GetProfileStringA(szOleSpyInfo,"Output","",szServerName,SERVERNAMEMAX) )
    {
        // check if debugger was specified
        if (_stricmp(szServerName, "debugger") == 0)
        {
            // output should go to the debugger
            OleSpyOutput = OleSpyOut_Debugger;
            AddOutputFunction((StringOutFunc) OutputDebugStringA);

        }
        else
        {
            pszServerName = szServerName;
            // "." means OleSpy on local machine
            // strip of the leading backslash
            while(*pszServerName == '\\')
            {
                pszServerName++;
            }
            if (strlen(pszServerName))
            {
                OleSpyOutput = OleSpyOut_OleSpy;
                AddOutputFunction((StringOutFunc) SendEntry);

            }
        }
    }

    if (OleSpyOutput == OleSpyOut_None)
    {
        // nothing to do
        return NOERROR;
    }

    //
    if (GetProfileStringA(szOleSpyInfo, "TraceRpc", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_Rpc;
        }
    }
    if (GetProfileStringA(szOleSpyInfo, "TraceAPI", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_API;
            SetTraceInfoLevel(ulValue);
        }

    }
    if (GetProfileStringA(szOleSpyInfo, "TraceMethod", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_Method;
        }
    }
    if (GetProfileStringA(szOleSpyInfo, "TraceOlethk", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_OleThk;
        }
    }

    if (GetProfileStringA(szOleSpyInfo, "BreakForUnknownCalls", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyBreakForUnknownCalls = 1;
        }
    }

    if (OleSpyOutput == OleSpyOut_OleSpy)
    {
        // initialize client if output goes to OleSpy
        InitClient(pszServerName);
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   OutputToOleSpy
//
//  Synopsis:
//
//  Arguments:  [iOption] --
//              [pscFormat] --
//
//  Returns:
//
//  History:    11-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void OutputToOleSpy(int iOption, const char *pscFormat, ...)
{
    va_list args;
    va_start(args, pscFormat);
    wvsprintfA(szOutBuffer, pscFormat, args);
    va_end(args);

    switch (OleSpyOutput)
    {
    default:
    case OleSpyOut_None:
    break;
    case OleSpyOut_Debugger:
        OutputDebugStringA(szSendBuf);

    break;
    case OleSpyOut_OleSpy:
        SendEntry(szOutBuffer);
    break;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     RpcSpyOutput
//
//  Synopsis:
//
//  Arguments:  [mode] -- in or out call
//              [iid] --  interface id
//              [dwMethod] -- called method
//              [hres] -- hresult of finished call
//
//  Returns:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void RpcSpyOutput(RPCSPYMODE mode , LPVOID pv, REFIID iid, DWORD dwMethod, HRESULT hres)
{
    WCHAR wszName[100];

    if(OleSpyOutput == OleSpyOut_None)
    {
        // nothing to do
        return;
    }

    // turn of the 800xx in dwMethod
    WORD wMethod = (WORD) (dwMethod & 0x000000FF);
    char * szInterfaceName = "Unknown";
    char * szMethodName = "Unknown";
    IIDMethodNames *pIidMethName = 0;

    if (pIidMethName = GetIIDMethodName(iid) )
    {
        szInterfaceName = pIidMethName->pszInterface;
        if (wMethod > 32)
        {
            szMethodName = "InvalidMethod";
        }
        else
        {
            szMethodName = pIidMethName->ppszMethodNames[wMethod];
        }
    }
    else
    {
        if (OleSpyBreakForUnknownCalls)
        {
            DebugBreak();
        }
    }

    switch (mode)
    {
    default:
        return;

    case CALLIN_BEGIN:
        wsprintfA(szSendBuf,"%4ld,%s<<< %s (%lx), %s \n",nInCount, GetTabs(), szInterfaceName, pv, szMethodName );
        PushLevel();
        nInCount++;
    break;
    case CALLIN_END:
        PopLevel();
        wsprintfA(szSendBuf,"%4ld,%s=== %s (%lx), %s (%lx) \n", nInCount-1, GetTabs(), szInterfaceName, pv, szMethodName, hres);
    break;
    case CALLIN_TRACE:
        wsprintfA(szSendBuf,"     %s\n",(LPSTR) pv);
    break;
    case CALLIN_QI:
        {
            PopLevel();
            wsprintfA(szSendBuf,"     %s!!! QI for: %s, %s (%lx) \n",GetTabs(), szInterfaceName, dwMethod ? "S_OK" : "E_NOINTERFACE", hres);
            PushLevel();
        }
    break;
    case CALLIN_ERROR:
    break;
    case CALLOUT_BEGIN:
        wsprintfA(szSendBuf,"%4ld,%s>>> %s (%lx), %s \n",nOutCount, GetTabs(), szInterfaceName, pv, szMethodName );
        nOutCount++;
        PushLevel();
    break;
    case CALLOUT_TRACE:
    break;
    case CALLOUT_ERROR:
        wsprintfA(szSendBuf,"%s!!! %s, %s, error:%lx \n",GetTabs(), szInterfaceName, szMethodName, hres);
    break;
    case CALLOUT_END:
        PopLevel();
        wsprintfA(szSendBuf,"%4ld,%s=== %s (%lx), %s (%lx) \n",nOutCount-1,GetTabs(), szInterfaceName, pv, szMethodName, hres);
    break;
    }

    switch (OleSpyOutput)
    {
    default:
    case OleSpyOut_None:
    break;
    case OleSpyOut_Debugger:
        OutputDebugStringA(szSendBuf);
    break;
    case OleSpyOut_OleSpy:
        SendEntry(szSendBuf);
    break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSpySendEntry
//
//  Synopsis:
//
//  Arguments:  [szOutBuf] --
//
//  Returns:
//
//  History:    09-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int OleSpySendEntry(char * szOutBuf)
{
    switch (OleSpyOutput)
    {
    default:
    case OleSpyOut_None:
    break;
    case OleSpyOut_Debugger:
        OutputDebugStringA(szOutBuf);
    break;
    case OleSpyOut_OleSpy:
        SendEntry(szOutBuf);
    break;
    }

    return 1;
}

#include "ifnames.cxx"

//+---------------------------------------------------------------------------
//
//  Function:   GetIIDMethodName
//
//  Synopsis:
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    06-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
IIDMethodNames *GetIIDMethodName(REFIID riid)
{
    int idx;
    int cElements = sizeof(IidMethodNames) / sizeof(IidMethodNames[0]);

    for (idx = 0; idx < cElements; idx++)
    {
        if (IsEqualIID(riid, *IidMethodNames[idx].piid))
        {
            return &(IidMethodNames[idx]);
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInterfaceName
//
//  Synopsis:
//
//  Arguments:  [iid] --
//
//  Returns:
//
//  History:    06-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetInterfaceName(REFIID iid)
{
    IIDMethodNames *pIidMethName = 0;
    LPSTR szInterfaceName = NULL;

    if (pIidMethName = GetIIDMethodName(iid) )
    {
        szInterfaceName = pIidMethName->pszInterface;
    }
    if (szInterfaceName == NULL)
    {
        // look up the interface name in the registry
    }

    return szInterfaceName;
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\utils.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the code for the utility routines

Author:

    Srini Koppolu   (srinik)    02-Mar-1992

Revision History:

    Erik Gavriluk   (erikgav)   31-Dec-1993   Chicago port

--*/

#include <ole2int.h>


#pragma SEG(UtDupString)
// copies string using the TASK allocator; returns NULL on out of memory
FARINTERNAL_(LPWSTR) UtDupString(LPCWSTR lpszIn)
{
	LPWSTR lpszOut = NULL;
	IMalloc FAR* pMalloc;

	if (CoGetMalloc(MEMCTX_TASK, &pMalloc) == S_OK) {

		if ((lpszOut =
			(LPWSTR)pMalloc->Alloc(
			   (lstrlenW(lpszIn)+1) * sizeof(WCHAR))) != NULL)
			   lstrcpyW(lpszOut, lpszIn);

		pMalloc->Release();
	}

	return lpszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\task.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	Task.cxx
//
//  Contents:	Helper function to determine the current task
//
//  Functions:	IsTaskName
//
//  History:	28-Mar-95 scottsk	Created
//              12-Feb-97 ronans	Added utGetModuleName, utGetAppIdForModule
//              12-Feb-97 ronans	Added utGetTowerId, utGetProtseqFromTowerId
//
//  CODEWORK:   - list of protocols and towerids should come from 
//              the Resolver, along with a list of protocols that 
//              the Admin is willing to use for DCOM.
//
//              - change 
//
//--------------------------------------------------------------------------

#include <ole2int.h>

WCHAR gawszImagePath[MAX_PATH];
DWORD gcImagePath = 0;

// Helper function for IsTaskName
inline BOOL IsPathSeparator( WCHAR ch )
{
    return (ch == L'\\' || ch == L'/' || ch == L':');
}

//+-------------------------------------------------------------------------
//
//  Function:  	IsTaskName
//
//  Synopsis: 	Determines if the passed name is the current task
//
//  Effects:
//
//  Arguments: 	[lpszIn]        -- Task name
//
//  Returns:	TRUE, FALSE
//
//  History:    dd-mmm-yy Author    Comment
//              03-Mar-95 Scottsk    Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
FARINTERNAL_(BOOL) IsTaskName(LPCWSTR lpszIn)
{
    BOOL retval = FALSE;

    if (IsWOWThread()) 
    {    

        //we cannot use the single global var for WOW as each thread is 
        //a different 16-bit task!
        //Since, in the case of WOW, this is thread specific info -- 
        //the loader lock is not taken. So no deadlocks(ref: NT 197603).

        WCHAR awszImagePath[MAX_PATH];
        if (GetModuleFileName(NULL, awszImagePath, MAX_PATH))
        {
            WCHAR * pch;

            // Get last component of path

            //
            // Find the end of the string and determine the string length.
            //
            for (pch=awszImagePath; *pch; pch++);

            DecLpch (awszImagePath, pch);   // pch now points to the last real charater

            while (!IsPathSeparator(*pch))
                DecLpch (awszImagePath, pch);

            // we're at the last separator.  does the name match?
            if (!lstrcmpiW(pch+1, lpszIn))
                retval = TRUE;
        }

    }
    else if (gcImagePath)
    {
        WCHAR * pch;

        // Get last component of path

        //
        // Find the end of the string and determine the string length.
        //
        for (pch=gawszImagePath; *pch; pch++);

        DecLpch (gawszImagePath, pch);   // pch now points to the last real character

        while (!IsPathSeparator(*pch))
           DecLpch (gawszImagePath, pch);

        // we're at the last separator.  does the name match?
        if (!lstrcmpiW(pch+1, lpszIn))
	        retval = TRUE;
    }

    return retval;
}


//+-------------------------------------------------------------------------
//
//  Function:  	utGetModuleName
//
//  Synopsis: 	Get Module Name for current module
//
//  Effects:
//
//  Arguments: 	[lpszModuleName]	-- Buffer to hold module name
//				[dwLength]			-- length in characters
//
//  Returns:	S_OK, E_UNEXPECTED, E_OUTOFMEMORY
//
//  History:    dd-mmm-yy Author    Comment
//	            06-Feb-97 Ronans	Created
//
//
//--------------------------------------------------------------------------
FARINTERNAL utGetModuleName(LPWSTR lpszModuleName, DWORD dwLength)
{
    WCHAR* pModule = gawszImagePath;
    DWORD cModule = gcImagePath;
    int i = cModule;
    HRESULT hr;

    // check arguments
    if ((!lpszModuleName) ||  
        (!dwLength) || 
        !IsValidPtrOut(lpszModuleName, dwLength * sizeof(WCHAR)))
    {
        ComDebOut((DEB_ERROR, "utGetModuleName - invalid arguments\n"));
        return E_INVALIDARG;
    }

    // skip back to start of filename
    while(i && !IsPathSeparator(pModule[i-1]))
        i--;

    // i is now index of start of module name
    DWORD nNameLen = (DWORD)((cModule - i) + 1);

    if (nNameLen <= dwLength)
        lstrcpyW(lpszModuleName, &pModule[i]);
    else
    {
        ComDebOut((DEB_ERROR, "utGetModuleName - supplied buffer is too small\n"));
        return HRESULT_FROM_WIN32(ERROR_MORE_DATA); // supplied buffer is too small
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:  	utGetAppIdForModule
//
//  Synopsis: 	Get AppID for the current module in string form
//
//  Effects:
//
//  Arguments: 	[lpszAppId]	-- Buffer to hold string represntation of AppId
//				[dwLength]	-- length of buffer in bytes
//
//  Returns:	S_OK, E_FAIL, E_UNEXPECTED, E_OUTOFMEMORY or error value from 
//              registry functions.
//
//  Notes:      E_FAIL indicates that AppId key was not found or other
//              "regular" error as opposed to out of memory or something
//
//  History:    dd-mmm-yy Author    Comment
//	            06-Feb-97 Ronans	Created
//
//--------------------------------------------------------------------------
FARINTERNAL utGetAppIdForModule(LPWSTR lpszAppId, DWORD dwLength)
{
    HRESULT hr;
    LONG lErr;
    WCHAR aModule[MAX_PATH];
    WCHAR aKeyName[MAX_PATH];
    DWORD dwModuleLen = MAX_PATH;
    HKEY hKey;
    int i;

    // check arguments
    if ((!lpszAppId) || (!dwLength) || (dwLength < 39 ))
    {
        ComDebOut((DEB_ERROR, 
            "utGetAppIdForModule - invalid arguments\n"));
        return E_INVALIDARG;
    }

    hr = utGetModuleName(aModule, dwModuleLen);


    if (SUCCEEDED(hr))
    {
        dwModuleLen = lstrlenW(aModule);

        if ((dwModuleLen + 7) > MAX_PATH)
        {
            ComDebOut((DEB_ERROR, 
                "utGetAppIdForModule - module name too large for buffer\n"));
            return E_OUTOFMEMORY;
        }

        // Open the key for the EXE's module name.
        lstrcpyW( aKeyName, L"AppID\\");
        lstrcpyW( &aKeyName[6], aModule);

        lErr = RegOpenKeyEx( HKEY_CLASSES_ROOT, aKeyName,
                           NULL, KEY_READ, &hKey );

        // Look for an application id.
        if (lErr == ERROR_SUCCESS)
        {
            DWORD dwType;
            lErr = RegQueryValueEx( hKey, L"AppId", NULL, &dwType,
                                  (unsigned char *) lpszAppId, &dwLength );
            RegCloseKey( hKey );

            if ((lErr == ERROR_SUCCESS) && dwType == REG_SZ)
            {
                ComDebOut((DEB_WARN, 
                    "utGetAppIdForModule - got appid [%ws]\n", lpszAppId));
                return S_OK;
            }
            else
            {
                ComDebOut((DEB_ERROR, 
                    "utGetAppIdForModule - couldn't open AppId subkey for key [%ws]\n", aKeyName));
                hr = E_FAIL;
            }
        }
        else
        {
            ComDebOut((DEB_WARN, 
                "utGetAppIdForModule - couldn't open appid key[%ws]\n", aKeyName));
            hr = E_FAIL;
        }
    }

    return hr;
}

// tower id to string mapping table - index is TowerId

// CODEWORK: this should come from the Resolver, along with a list of
// protocols that the Admin is willing to use for DCOM.


PWSTR   utProtseqInfo[] =
    {
    /* 0x00 */ { 0 },
    /* 0x01 */ { 0 },
    /* 0x02 */ { 0 },
    /* 0x03 */ { 0 },
    /* 0x04 */ { L"ncacn_dnet_dsp" },
    /* 0x05 */ { 0 },
    /* 0x06 */ { 0 },
    /* 0x07 */ { L"ncacn_ip_tcp" },
    /* 0x08 */ { L"ncadg_ip_udp" },
    /* 0x09 */ { L"ncacn_nb_tcp" },
    /* 0x0a */ { 0 },
    /* 0x0b */ { 0 },
    /* 0x0c */ { L"ncacn_spx" },
    /* 0x0d */ { L"ncacn_nb_ipx" },
    /* 0x0e */ { L"ncadg_ipx" },
    /* 0x0f */ { L"ncacn_np" },
    /* 0x10 */ { L"ncalrpc" },
    /* 0x11 */ { 0 },
    /* 0x12 */ { 0 },
    /* 0x13 */ { L"ncacn_nb_nb" },
    /* 0x14 */ { 0 },
    /* 0x15 */ { 0 }, // was ncacn_nb_xns - unsupported.
    /* 0x16 */ { L"ncacn_at_dsp" },
    /* 0x17 */ { L"ncadg_at_ddp" },
    /* 0x18 */ { 0 },
    /* 0x19 */ { 0 },
    /* 0x1A */ { L"ncacn_vns_spp"},
    /* 0x1B */ { 0 },
    /* 0x1C */ { 0 },
    /* 0x1D */ { L"ncadg_mq"}, /* NCADG_MQ */
    /* 0x1E */ { 0 },          
    /* 0x1F */ { L"ncacn_http"} /* ronans - DCOMHTTP */
};

const ULONG utcProtSeqs = sizeof(utProtseqInfo) / sizeof(PWSTR);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetProtseqFromTowerId
//
//  Synopsis: 	Get protseq string from DCE TowerID 
//
//  Effects:
//
//  Arguments: 	[wTowerId]	-- TowerID to retrieve
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//	            06-Feb-97   Ronans	    Converted to utility fn and 
//                                      changed array format
//
//--------------------------------------------------------------------------
FARINTERNAL_(LPCWSTR) utGetProtseqFromTowerId(USHORT wTowerId)
{
    Win4Assert(wTowerId < utcProtSeqs);
	
    // Do not look at memory outside of the table
    if (wTowerId < utcProtSeqs)
        return utProtseqInfo[wTowerId];
    else
        return NULL;
} 

//+-------------------------------------------------------------------------
//
//  Function:  	utGetTowerId
//
//  Synopsis: 	Get DCE TowerId for protseq string
//
//  Effects:
//
//  Arguments: 	[pwszProtseq]	-- string to look up
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//	            06-Feb-97   Ronans	    Converted to utility fn
//
//--------------------------------------------------------------------------
FARINTERNAL_(USHORT) utGetTowerId(LPCWSTR pwszProtseq)
{
    int idx;

    for (idx = 0; idx < sizeof(utProtseqInfo) / sizeof(*utProtseqInfo); ++idx)
    {
        if (lstrcmpW(utProtseqInfo[idx], pwszProtseq) == 0)
	        return (USHORT) idx;
    }

    ComDebOut((DEB_ERROR, "utGetTowerId - Can't get towerId for protseq[%ws]\n", pwszProtseq));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\utstream.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    utstream.cpp

Abstract:

    This module contains the code for the stream utility routines

Author:

    Srini Koppolu   (srinik)    14-Mar-1992

Revision History:
	(SriniK) 6/23/92	Moved ReadStringStream, WriteStringStream and
						OpenOrCreateStream from "api.cpp, ole2.cpp"

    (ErikGav) 12/31/93  Chicago port
	
--*/


#include <ole2int.h>

#include <limits.h>

#define MAX_STR	256


#pragma SEG(OpenOrCreateStream)
STDAPI	OpenOrCreateStream( IStorage FAR * pstg, OLECHAR const FAR * pwcsName,
	IStream FAR* FAR* ppstm)
{
	HRESULT error;
	error = pstg->CreateStream(pwcsName,
		STGM_SALL | STGM_FAILIFTHERE, 0, 0, ppstm);
	if (GetScode(error) == STG_E_FILEALREADYEXISTS)
		error = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, ppstm);

	return error;
}


#pragma SEG(ReadStringStream)
// returns S_OK when string read and allocated (even if zero length)
STDAPI	ReadStringStream( LPSTREAM pstm, LPOLESTR FAR * ppsz )
{
	ULONG cb;
	HRESULT hresult;
	
	*ppsz = NULL;

	if ((hresult = StRead(pstm, (void FAR *)&cb, sizeof(ULONG))) != NOERROR)
		return hresult;

	if (cb == NULL)
		// NULL string case
		return NOERROR;

	if ((LONG)cb < 0 || cb > INT_MAX)
		// out of range
		return ReportResult(0, E_UNSPEC, 0, 0);
	
	if (!(*ppsz = new FAR OLECHAR[(int)cb]))
		return ReportResult(0, E_OUTOFMEMORY, 0, 0);

	if ((hresult = StRead(pstm, (void FAR *)(*ppsz), cb)) != NOERROR)
		goto errRtn;
	
	return NOERROR;

errRtn:	
	delete *ppsz;
	*ppsz = NULL;
	return hresult;
}


#pragma SEG(WriteStringStream)

//+-------------------------------------------------------------------------
//
//  Function:   WriteStringStream
//
//  Synopsis:   Write a null-terminated string out to a stream.
//
//  Effects:
//
//  Arguments:  pstm, the stream to write to.
//              psz, the string to write out.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//
//  Notes:
//      Writes out a count (in bytes) and then the string, including NULL termination.
//      E.G.:
//      psz == NULL: writes out a 0, followed by zero bytes.
//      psz == "": writes out a 1, followed by the zero termination.
//      psz == "dog": writes out a 4, followed by "dog", followed by zero termination
//
//--------------------------------------------------------------------------

STDAPI	WriteStringStream( LPSTREAM pstm, LPCOLESTR psz )
{
	HRESULT error;
	ULONG cb = NULL;

	if (psz)
		cb = (1 + _xstrlen(psz)) * sizeof(OLECHAR);
	
	if (error = pstm->Write((VOID FAR *)&cb, sizeof(ULONG), NULL))
		goto errRtn;
	
	if (psz == NULL)
		// we are done writing the string
		return NOERROR;
		
	if (error = pstm->Write((VOID FAR *)psz, cb, NULL))
		goto errRtn;
errRtn:
	return error;
}

#pragma SEG(StRead)
// REVIEW: spec issue 313 requests that IStream::Read return S_FALSE when end
// of file; this change eliminate the need for this routine.
FARINTERNAL_(HRESULT) StRead (IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen)
{
	HRESULT error;
	ULONG cbRead;

	if ((error = lpstream->Read( lpBuf, ulLen, &cbRead)) != NOERROR)
		return error;
	
	return ((cbRead != ulLen) ? ReportResult(0, S_FALSE , 0, 0): NOERROR);
}


#pragma SEG(StSave10NativeData)
FARINTERNAL_(HRESULT) StSave10NativeData(IStorage FAR* pstgSave, HANDLE hNative)
{
	LPOLESTR		lpNative;
	DWORD		dwSize;
	LPSTREAM   	lpstream = NULL;
	HRESULT		error;

	if (!hNative)
		return ReportResult(0, E_UNSPEC, 0, 0);

	if (!(dwSize = GlobalSize (hNative)))
		return ReportResult(0, E_OUTOFMEMORY, 0, 0);
	
	if (!(lpNative = (LPOLESTR) GlobalLock (hNative)))
		return ReportResult(0, E_OUTOFMEMORY, 0, 0);
	GlobalUnlock (hNative);	
	
	if (error = OpenOrCreateStream(pstgSave, OLE10_NATIVE_STREAM, &lpstream))
		return error;

	if (error = StWrite (lpstream, &dwSize, sizeof(DWORD)))
		goto errRtn;
	
	
   	if (error = StWrite (lpstream, lpNative, dwSize))
		goto errRtn;
		
errRtn:	
	if (lpstream)
		lpstream->Release();

	return error;
}



#pragma SEG(StSave10ItemName)
FARINTERNAL StSave10ItemName
	(IStorage FAR* pstg,
	LPCOLESTR szItemName)
{
	LPSTREAM   	lpstream = NULL;
	HRESULT		hresult;

	if ((hresult = OpenOrCreateStream (pstg, OLE10_ITEMNAME_STREAM, &lpstream))
		!= NOERROR)
	{
		return hresult;
	}

	hresult = WriteStringStream (lpstream, szItemName);

	if (lpstream)
		lpstream->Release();

	return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\w32new.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       w32new.cxx
//
//  Contents:   memory management
//
//  Functions: operator new
//             operator delete
//--------------------------------------------------------------------------
#include <ole2int.h>
#include <memapi.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   operator new, public
//
//  Synopsis:   Global operator new which does not throw exceptions.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:	A pointer to the allocated memory.  Is *NOT* initialized to 0!
//
//----------------------------------------------------------------------------
void* __cdecl
operator new (size_t size)
{
    return(PrivMemAlloc(size));
}

//+-------------------------------------------------------------------------
//
//  Function:	::operator delete
//
//  Synopsis:	Free a block of memory
//
//  Arguments:	[lpv] - block to free.
//
//--------------------------------------------------------------------------

void __cdecl operator delete(void FAR* lpv)
{
    PrivMemFree(lpv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\chicago\stkclip.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       stkclip.cpp
//
//  Contents:   Ole stack switching api's for Clipboard operations
//
//  Classes:
//
//  Functions:
//
//  History:    12-16-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
// Note: Enable including native user APIs
// for stack switching
#include <userapis.h>


BOOL WINAPI SSOpenClipboard(HWND hWndNewOwner)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on Openclipboard\n"));
	return SSCall(4 ,SSF_SmallStack, (LPVOID) OpenClipboard, (DWORD)hWndNewOwner);
    }
    else
    {
	return(OpenClipboard(hWndNewOwner));
    }
}
BOOL WINAPI SSCloseClipboard(VOID)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on CloseClipboard\n"));
	return SSCall(0 ,SSF_SmallStack, (LPVOID) CloseClipboard, 0);
    }
    else
    {
	return(CloseClipboard());
    }
}
HWND WINAPI SSGetClipboardOwner(VOID)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on GetClipboardOwner\n"));
	return (HWND)SSCall(0 ,SSF_SmallStack, (LPVOID) GetClipboardOwner, 0);
    }
    else
    {
	return(GetClipboardOwner());
    }
}
HANDLE WINAPI SSSetClipboardData(UINT uFormat,HANDLE hMem)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on SetClipboardData\n"));
	return (HANDLE)SSCall(8 ,SSF_SmallStack, (LPVOID)SetClipboardData, (DWORD) uFormat, hMem);
    }
    else
    {
	return(SetClipboardData(uFormat, hMem));
    }
}
HANDLE WINAPI SSGetClipboardData(UINT uFormat)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on GetClipboardData\n"));
	return (HANDLE) SSCall(4 ,SSF_SmallStack, (LPVOID) GetClipboardData, (DWORD) uFormat);
    }
    else
    {
	return(GetClipboardData(uFormat));
    }
}
UINT WINAPI SSRegisterClipboardFormatA(LPCSTR lpszFormat)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on RegisterClipboardFormatA\n"));
	return SSCall(4 ,SSF_SmallStack, (LPVOID) RegisterClipboardFormatA, (DWORD)lpszFormat);
    }
    else
    {
	return(RegisterClipboardFormatA(lpszFormat));
    }
}
UINT WINAPI SSEnumClipboardFormats(UINT format)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on EnumClipboardFormats\n"));
	return SSCall(4 ,SSF_SmallStack, (LPVOID)EnumClipboardFormats, (DWORD) format);
    }
    else
    {
	return(EnumClipboardFormats(format));
    }
}
int WINAPI SSGetClipboardFormatNameA(UINT format,LPSTR lpszFormatName,int cchMaxCount)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on GetClipboardFormatNameA\n"));
	return SSCall(12 ,SSF_SmallStack, (LPVOID)GetClipboardFormatNameA, (DWORD)format,lpszFormatName, cchMaxCount);
    }
    else
    {
	return(GetClipboardFormatNameA( format, lpszFormatName, cchMaxCount));
    }
}
BOOL WINAPI SSEmptyClipboard(VOID)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on EmptyClipboard\n"));
	return SSCall(0 ,SSF_SmallStack, (LPVOID) EmptyClipboard, 0);
    }
    else
    {
	return(EmptyClipboard());
    }
}
BOOL WINAPI SSIsClipboardFormatAvailable(UINT format)
{
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on IsClipboardFormatAvailable\n"));
	return SSCall(4 ,SSF_SmallStack, (LPVOID)IsClipboardFormatAvailable, (DWORD) format);
    }
    else
    {
	return(IsClipboardFormatAvailable( format));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\chicago\stkswtch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       stkswtch.cxx
//
//  Contents:   Stack Switching function for Win95.
//              Alls functions switch either to the 32 bit stack or
//              back to the 16 bit stack.
//
//  Classes:
//
//  Functions:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Note:       These functions are called on W95 only.
//
//----------------------------------------------------------------------------

#include <ole2int.h>
// Note: Enable including native user APIs
// for stack switching
#include <userapis.h>

STDAPI SSAPI(DoDragDrop)(LPDATAOBJECT pDataObject,
        LPDROPSOURCE pDropSource, DWORD dwOKEffects,
        DWORD FAR *pdwEffect);
STDAPI SSAPI(CoInitializeEx)(LPVOID pvReserved, ULONG flags);
STDAPI_(void) SSAPI(CoUninitialize)(void);

//+---------------------------------------------------------------------------
//
//  Method:     SSSendMessage
//
//  Synopsis:   Switches to 16 bit stack and calls SendMessages
//
//  Arguments:  [hWnd] --   see SendMessage
//              [Msg] --
//              [wParam] --
//              [lParam] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT WINAPI SSSendMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    StackDebugOut((DEB_ITRACE, "SSSendMessage\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on SendMessage\n"));
        return SSCall(16 ,SSF_SmallStack, (LPVOID)SendMessageA,
                      (DWORD)hWnd, (DWORD)Msg, wParam, lParam);
    }
    else
        return SendMessage(hWnd, Msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSReplyMessage
//
//  Synopsis:   Switches to 16 bit stack and calls ReplyMessage
//
//  Arguments:  [lResult] -- see ReplyMessage
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSReplyMessage(LRESULT lResult)
{
    StackDebugOut((DEB_ITRACE, "SSReplyMessage\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on ReplyMessage\n"));
        return SSCall(4, SSF_SmallStack, (LPVOID)ReplyMessage , (DWORD)lResult);
    }
    else
        return ReplyMessage(lResult);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSCallWindowProc
//
//  Synopsis:   Switches to 16 bit stack and calls CallWindowProc
//
//  Arguments:  [lpPrevWndFunc] -- see CallWindowProc
//              [hWnd] --
//              [Msg] --
//              [wParam] --
//              [lParam] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT WINAPI SSCallWindowProc(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg,
                                        WPARAM wParam, LPARAM lParam)
{
    StackDebugOut((DEB_ITRACE, "SSCallWindowProc\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on CallWindowProc\n"));
        return SSCall(20, SSF_SmallStack, (LPVOID)CallWindowProcA,
                            (DWORD)lpPrevWndFunc, hWnd, Msg, wParam, lParam);
    }
    else
        return CallWindowProc(lpPrevWndFunc, hWnd, Msg, wParam, lParam);

}

//+---------------------------------------------------------------------------
//
//  Method:     SSDefWindowProc
//
//  Synopsis:   Switches to 16 bit stack and calls DefWindowProc
//
//  Arguments:  [hWnd] -- see DefWindowProc
//              [Msg] --
//              [wParam] --
//              [lParam] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT WINAPI SSDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    StackDebugOut((DEB_ITRACE, "SSDefWindowProc\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on DefWindowProc\n"));
        return SSCall(16, SSF_SmallStack, (LPVOID)DefWindowProcA,
                        (DWORD)hWnd, Msg, wParam, lParam);
    }
    else
        return DefWindowProc(hWnd, Msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSPeekMessage
//
//  Synopsis:   Switches to 16 bit stack and calls PeekMessage
//
//  Arguments:  [lpMsg] -- see PeekMessage
//              [hWnd] --
//              [wMsgFilterMin] --
//              [UINT] --
//              [wRemoveMsg] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSPeekMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin,
                            UINT wMsgFilterMax,UINT wRemoveMsg)
{
    StackDebugOut((DEB_ITRACE, "SSPeekMessage\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on PeekMessage\n"));
        return SSCall(20, SSF_SmallStack, (LPVOID)PeekMessageA , (DWORD)lpMsg,
                (DWORD)hWnd, (DWORD)wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    }
    else
        return PeekMessage(lpMsg, hWnd, wMsgFilterMin,
                           wMsgFilterMax, wRemoveMsg);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSGetMessage
//
//  Synopsis:   Switches to 16 bit stack and calls GetMessage
//
//  Arguments:  [lpMsg] --  see GetMessage
//              [hWnd] --
//              [wMsgFilterMin] --
//              [wMsgFilterMax] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin,
                            UINT wMsgFilterMax)
{
    StackDebugOut((DEB_ITRACE, "SSGetMessage\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on GetMessage\n"));
        return SSCall(16, SSF_SmallStack, (LPVOID)GetMessageA,
                      (DWORD)lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    }
    else
        return GetMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSDispatchMessage
//
//  Synopsis:   Switches to 16 bit stack and calls DispatchMessage
//
//  Arguments:  [lpMsg] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG WINAPI SSDispatchMessage(CONST MSG *lpMsg)
{
    StackDebugOut((DEB_ITRACE, "SSDispatchMessage\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on DispatchMessage\n"));
        return SSCall(4, SSF_SmallStack, (LPVOID)DispatchMessageA, (DWORD)lpMsg);
    }
    else
        return DispatchMessage(lpMsg);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSWaitMessage
//
//  Synopsis:   Switches to 16 bit stack and calls WaitMessage
//
//  Arguments:  [VOID] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSWaitMessage(VOID)
{
    StackDebugOut((DEB_ITRACE, "SSWaitMessage\n"));
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on WaitMessage\n"));
        return SSCall(0, SSF_SmallStack, (LPVOID)WaitMessage, 0);
    }
    else
        return WaitMessage();
}

//+---------------------------------------------------------------------------
//
//  Method:	SSMsgWaitForMultipleObjects
//
//  Synopsis:   Switches to 16 bit stack and calls WaitMessage
//
//----------------------------------------------------------------------------
DWORD WINAPI SSMsgWaitForMultipleObjects(DWORD nCount, LPHANDLE pHandles,
		    BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
{
    StackDebugOut((DEB_ITRACE, "SSMsgWaitForMultipleObjects\n"));
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on MsgWaitForMultipleObjects\n"));
	return SSCall(20, SSF_SmallStack, (LPVOID)MsgWaitForMultipleObjects,
		      nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
    }
    else
    {
	return MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll,
					 dwMilliseconds, dwWakeMask);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     SSDialogBoxParam
//
//  Synopsis:
//
//  Arguments:  [hInstance] --
//              [lpTemplateName] --
//              [hWndParent] --
//              [lpDialogFunc] --
//              [dwInitParam] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI SSDialogBoxParam(HINSTANCE hInstance, LPCSTR lpTemplateName,
                    HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "Stack switch(16) on DialogBoxParam\n"));
        return SSCall(20, SSF_SmallStack, (LPVOID)DialogBoxParam,
                        (DWORD)hInstance, (DWORD)lpTemplateName, hWndParent,
                        lpDialogFunc, dwInitParam);
    }
    else
        return DialogBoxParam(hInstance, lpTemplateName, hWndParent,
                                lpDialogFunc, dwInitParam);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSDialogBoxIndirectParam
//
//  Synopsis:
//
//  Arguments:  [hInstance] --
//              [hDialogTemplate] --
//              [hWndParent] --
//              [lpDialogFunc] --
//              [dwInitParam] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI SSDialogBoxIndirectParam(HINSTANCE hInstance,
                LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent,
                DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    if (SSONBIGSTACK())
    {
        // BUGBUG: why pass 24 instead of 20?
        StackDebugOut((DEB_STCKSWTCH, "SSDialogBoxIndirectParam 32->16\n"));
        return SSCall(24, SSF_SmallStack, (LPVOID)DialogBoxIndirectParam,
                            (DWORD)hInstance, (DWORD)hDialogTemplate,
                            hWndParent, lpDialogFunc, dwInitParam);
    }
    else
        return DialogBoxIndirectParam(hInstance, hDialogTemplate,
                            hWndParent, lpDialogFunc, dwInitParam);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSMessageBox
//
//  Synopsis:   Switches to 16 bit stack and calls MessageBox
//
//  Arguments:  [LPCSTR] -- see MessageBox
//              [LPCSTR] --
//              [lpCaption] --
//              [uType] --
//
//  Returns:
//
//  History:    12-12-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType)
{
    if (SSONBIGSTACK())
    {
        // BUGBUG: why pass 24 instead of 16?
        StackDebugOut((DEB_STCKSWTCH, "SSMessageBox 32->16\n"));
        return SSCall(24, SSF_SmallStack, (LPVOID)MessageBoxA,
                      (DWORD)hWnd, lpText, lpCaption, uType);
    }
    else
        return MessageBoxA(hWnd, lpText, lpCaption, uType);
}
//+---------------------------------------------------------------------------
//
//  Method:     SSCreateWindowExA
//
//  Synopsis:
//
//  Arguments:  [dwExStyle] --
//              [lpClassName] --
//              [lpWindowName] --
//              [dwStyle] --
//              [X] --
//              [Y] --
//              [nWidth] --
//              [nHeight] --
//              [hWndParent] --
//              [hMenu] --
//              [hInstance] --
//              [lpParam] --
//
//  Returns:
//
//  History:    12-12-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HWND WINAPI SSCreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName,
                LPCSTR lpWindowName, DWORD dwStyle, int X, int Y,
                int nWidth, int nHeight, HWND hWndParent, HMENU hMenu,
                HINSTANCE hInstance, LPVOID lpParam)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSCreateWindowExA 32->16\n"));
        return (HWND)SSCall(48 ,SSF_SmallStack, (LPVOID)CreateWindowExA,
                            dwExStyle, (DWORD)lpClassName, (DWORD)lpWindowName,
                            dwStyle, X, Y, nWidth, nHeight, (DWORD)hWndParent,
                            (DWORD)hMenu, (DWORD)hInstance, (DWORD)lpParam);
    }
    else
        return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle,
                            X, Y, nWidth, nHeight, hWndParent, hMenu,
                            hInstance, lpParam);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSCreateWindowExW
//
//  Synopsis:
//
//  Arguments:  [dwExStyle] --
//              [lpClassName] --
//              [lpWindowName] --
//              [dwStyle] --
//              [X] --
//              [Y] --
//              [nWidth] --
//              [nHeight] --
//              [hWndParent] --
//              [hMenu] --
//              [hInstance] --
//              [lpParam] --
//
//  Returns:
//
//  History:    12-12-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HWND WINAPI SSCreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName,
                LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y,
                int nWidth, int nHeight, HWND hWndParent, HMENU hMenu,
                HINSTANCE hInstance, LPVOID lpParam)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSCreateWindowExX 32->16\n"));
        return (HWND)SSCall(48 ,SSF_SmallStack, (LPVOID)CreateWindowExX,
                            dwExStyle, (DWORD)lpClassName, (DWORD)lpWindowName,
                            dwStyle, X, Y, nWidth, nHeight, (DWORD)hWndParent,
                            (DWORD)hMenu, (DWORD)hInstance, (DWORD)lpParam);
    }
    else
        return CreateWindowExX(dwExStyle, lpClassName, lpWindowName, dwStyle,
                            X, Y, nWidth, nHeight, hWndParent, hMenu,
                            hInstance, lpParam);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSDestroyWindow
//
//  Synopsis:
//
//  Arguments:  [hWnd] --
//
//  Returns:
//
//  History:    12-12-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSDestroyWindow(HWND hWnd)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSDestroyWindow 32->16\n"));
        return SSCall(4, SSF_SmallStack, (LPVOID)DestroyWindow, (DWORD)hWnd);
    }
    else
        return DestroyWindow(hWnd);
}

//+---------------------------------------------------------------------------
//
//  Method:     SSCreateProcessA
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    07-29-96   SteveBl (Steve Blanding)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSCreateProcessA(
                    LPCSTR lpApplicationName,
                    LPSTR lpCommandLine,
                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                    BOOL bInheritHandles,
                    DWORD dwCreationFlags,
                    LPVOID lpEnvironment,
                    LPCSTR lpCurrentDirectory,
                    LPSTARTUPINFOA lpStartupInfo,
                    LPPROCESS_INFORMATION lpProcessInformation)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSCreateProcessA 32->16\n"));
        return SSCall(40, SSF_SmallStack, (LPVOID)CreateProcessA,
            (DWORD)lpApplicationName,
            (DWORD)lpCommandLine,
            (DWORD)lpProcessAttributes,
            (DWORD)lpThreadAttributes,
            bInheritHandles,
            dwCreationFlags,
            (DWORD)lpEnvironment,
            (DWORD)lpCurrentDirectory,
            (DWORD)lpStartupInfo,
            (DWORD)lpProcessInformation);
    }
    else
        return CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes,
                    lpThreadAttributes, bInheritHandles, dwCreationFlags,
                    lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}


//+---------------------------------------------------------------------------
//
//  Method:     SSInSendMessage
//
//  Synopsis:
//
//  Arguments:  none
//
//  Returns:
//
//  History:    07-29-96   SteveBl (Steve Blanding)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSInSendMessage(void)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSInSendMessage 32->16\n"));
        return SSCall(0, SSF_SmallStack, (LPVOID)InSendMessage, (DWORD)NULL);
    }
    else
        return InSendMessage();
}

//+---------------------------------------------------------------------------
//
//  Method:     SSInSendMessageEx
//
//  Synopsis:
//
//  Arguments:  [LPVOID]
//
//  Returns:
//
//  History:    09-12-97   MPrabhu (Manish Prabhu)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD   WINAPI SSInSendMessageEx(LPVOID pvReserved)
{
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSInSendMessageEx 32->16\n"));
        return SSCall(4, SSF_SmallStack, (LPVOID)InSendMessageEx, (DWORD)pvReserved);
    }
    else
        return InSendMessageEx(pvReserved);
}

//+---------------------------------------------------------------------------
//
//  Method:     DoDragDrop
//
//  Synopsis:
//
//  Arguments:  [LPDROPSOURCE] --
//              [pDropSource] --
//              [DWORD] --
//              [pdwEffect] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DoDragDrop(LPDATAOBJECT pDataObject,LPDROPSOURCE pDropSource,
                    DWORD dwOKEffects,DWORD FAR *pdwEffect)
{
    StackDebugOut((DEB_ITRACE, "DoDragDrop\n"));
    HRESULT hres;
    if (SSONBIGSTACK())
    {
        // BUGBUG: why 20 instead of 16?
        StackDebugOut((DEB_STCKSWTCH, "SWDoDragDrop: 32->16\n"));
        hres = SSCall(20, SSF_SmallStack, (LPVOID)SSDoDragDrop,
                        (DWORD)pDataObject, pDropSource,
                        dwOKEffects, pdwEffect);
        StackDebugOut((DEB_STCKSWTCH,
                "SWDoDragDrop 16<-32 done; hres:%ld\n", hres));
    }
    else
    {
        hres = SSDoDragDrop(pDataObject, pDropSource, dwOKEffects, pdwEffect);
    }
    return hres;
}

//+---------------------------------------------------------------------------
//
//  Method:     CoInitializeEx
//
//  Synopsis:
//
//  Arguments:  [pvReserved] --
//              [flags] --
//
//  Returns:
//
//  History:    1-05-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInitializeEx(LPVOID pvReserved, ULONG flags)
{
    StackDebugOut((DEB_ITRACE, "CoInitializeEx\n"));
    HRESULT hres;
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSCoInitializeEx: 32->16\n"));
        hres = SSCall(8, SSF_SmallStack, (LPVOID)SSCoInitializeEx,
                        (DWORD)pvReserved, flags);
        StackDebugOut((DEB_STCKSWTCH,
                        "CoInitializeEx 16<-32 done; hres:%ld\n", hres));
    }
    else
    {
        hres = SSCoInitializeEx(pvReserved, flags);
    }
    return hres;
}


//+---------------------------------------------------------------------------
//
//  Method:     CoUninitialize
//
//  Synopsis:
//
//  Arguments:  [pvReserved] --
//              [flags] --
//
//  Returns:
//
//  History:    1-05-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(void) CoUninitialize(void)
{
    StackDebugOut((DEB_ITRACE, "CoUninitialize\n"));
    HRESULT hres;
    if (SSONBIGSTACK())
    {
        StackDebugOut((DEB_STCKSWTCH, "SSCoUninitialize: 32->16\n"));
        hres = SSCall(0, SSF_SmallStack, (LPVOID)SSCoUninitialize, (DWORD)NULL);
        StackDebugOut((DEB_STCKSWTCH,
                        "CoInitializeEx 16<-32 done; hres:%ld\n", hres));
    }
    else
    {
        SSCoUninitialize();
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\util\chicago\widewrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.cxx
//
//  Contents:   Unicode wrapper API, used only on Chicago
//
//  Functions:  About fifty Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//
//  History:    28-Dec-93   ErikGav   Created
//              06-14-94    KentCe    Various Chicago build fixes.
//              21-Dec-94   BruceMa   Use olewcstombs + other fixes
//              21-Feb-95   BruceMa   Add support for AreFileApisANSI
//              29-Feb-96   JeffE     Add lots of wide character rtns
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include <winbase.h>
#include "memapi.hxx"

#ifdef _CHICAGO_

#define HFINDFILE HANDLE
#define ERR ((char*) -1)


//
//  BUGBUG: 9869
//
//  The length of a Unicode string (in chars) and a DBCS string are not
//  always equal.  We need to review all WideChar to MultiByte conversions
//  logic to verify that the proper result buffer size is used.
//
//  Make the below Win95 only change to get the Win95 FE build out.
//

int UnicodeToAnsi(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz, cb, NULL, NULL);

#if DBG==1
    CairoleAssert(ret != 0 && "Lost characters in Unicode->Ansi conversion");
    if (ret == 0)
    {
        DebugBreak();
    }
#endif

    return ret;
}


int UnicodeToAnsiOem(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    if (AreFileApisANSI())
    {
        ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz,
                                  cb, NULL, NULL);
    }
    else
    {
        ret = WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, pwsz, -1, sz,
                                  cb, NULL, NULL);
    }

#if DBG==1
    CairoleAssert(ret != 0 && "Lost characters in Unicode->Ansi conversion");
    if (ret == 0)
    {
        DebugBreak();
    }
#endif

    return ret;
}



#if DBG==1
int AnsiToUnicode(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;
    DWORD WindowsError;

    ret = MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, sz, -1, pwsz, cb);
    if (ret == 0) {
        WindowsError = GetLastError ();
    }
    CairoleAssert(ret != 0 && "Lost characters in Ansi->Unicode conversion");
    if (ret == 0)
    {
        DebugBreak();
    }

    return ret;
}
#else
#define AnsiToUnicode(pwsz,sz,cb) MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, sz, -1, pwsz, cb)
#endif



int AnsiToUnicodeOem(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    if (AreFileApisANSI())
    {
        ret = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cb, pwsz, cb);
    }
    else
    {
        ret = MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, sz, cb, pwsz, cb);
    }

#if DBG==1
    CairoleAssert(ret != 0 && "Lost characters in Ansi->Unicode conversion");
    if (ret == 0)
    {
        DebugBreak();
    }
#endif

    return ret;
}




LPSTR Convert(LPCWSTR pwsz)
{
    LONG len;
    LPSTR sz = NULL;

    if (pwsz == NULL)
        goto Exit;

#if DBG==1
    // some Win32 API accept atoms in their string parameters
    CairoleAssert(HIWORD(pwsz)!=0 && "ATOM passed to Convert -- GP fault coming");
#endif

    len = (lstrlenW(pwsz) + 1) * 2;

    sz = new CHAR[len];
    if (sz==NULL)
    {
        sz = ERR;
        goto Exit;
    }

    __try
    {
        UnicodeToAnsi(sz, pwsz, len);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG==1
        MessageBoxA(NULL, "GP fault in unicode conversion -- caught",
                   NULL, MB_OK);
#endif
        if (sz)
            delete sz;
        sz = ERR;
    }

Exit:
    return sz;
}









LPSTR ConvertOem(LPCWSTR pwsz)
{
    LONG len;
    LPSTR sz = NULL;

    if (pwsz == NULL)
        goto Exit;

#if DBG==1
    // some Win32 API accept atoms in their string parameters
    CairoleAssert(HIWORD(pwsz)!=0 && "ATOM passed to Convert -- GP fault coming");
#endif

    len = (lstrlenW(pwsz) + 1) * 2;

    sz = new CHAR[len];
    if (sz==NULL)
    {
        sz = ERR;
        goto Exit;
    }

    __try
    {
        UnicodeToAnsiOem(sz, pwsz, len);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG==1
        MessageBoxA(NULL, "GP fault in unicode conversion -- caught",
                   NULL, MB_OK);
#endif
        if (sz)
            delete sz;
        sz = ERR;
    }

Exit:
    return sz;
}





HANDLE WINAPI CreateFileX(LPCWSTR pwsz, DWORD fdwAccess, DWORD fdwShareMask,
        LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags,
        HANDLE hTemplateFile)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsiOem(sz, pwsz, sizeof(sz));

    return CreateFileA(sz, fdwAccess, fdwShareMask, lpsa, fdwCreate,
            fdwAttrsAndFlags, hTemplateFile);
}

BOOL WINAPI DeleteFileX(LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("DeleteFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsi(sz, pwsz, sizeof(sz));

    return DeleteFileA(sz);
}

UINT WINAPI RegisterClipboardFormatX(LPCWSTR pwszFormat)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterClipboardFormat\n");
    #endif

    UINT ret;
#if 0
    LPSTR sz;

    sz = Convert(pwszFormat);
    if (sz == ERR)
    {
        return 0;
    }
#else
    // BUGBUG: CairOLE calls this from libmain -- have to use static buffer

    CHAR sz[200];

    UnicodeToAnsi(sz, pwszFormat, sizeof(sz));
#endif

    ret = SSRegisterClipboardFormatA(sz);
#if 0
    delete sz;
#endif
    return ret;
}

int WINAPI GetClipboardFormatNameX(UINT format, LPWSTR pwsz,
    int cchMaxCount)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetClipboardFormatName\n");
    #endif

    LPSTR sz;
    int i;

    sz = (LPSTR) alloca(cchMaxCount);
    if (sz == NULL)
    {
        return 0;
    }

    i = SSGetClipboardFormatNameA(format, sz, cchMaxCount);

    if (i)
    {
        AnsiToUnicode(pwsz, sz, lstrlenA(sz) + 1);
    }
    return i;
}

LONG APIENTRY RegOpenKeyX(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegOpenKey\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(pwszSubKey);

    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegOpenKeyA(hKey, sz, phkResult);
    if (sz)
        delete sz;
    return ret;
}

LONG APIENTRY RegQueryValueX(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
    PLONG   lpcbValue)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegQueryValue\n");
    #endif

    LONG  cb, ret;
    LPSTR szValue = NULL;
    LPSTR sz;

    sz = Convert(pwszSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegQueryValueA(hKey, sz, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (pwszValue == NULL)
    {
        // Adjust size of buffer to report, to account for CHAR -> WCHAR
        *lpcbValue = cb * sizeof(WCHAR);
        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.

        szValue = (LPSTR) alloca(cb);
        if (szValue == NULL)
        {
            ret = ERROR_OUTOFMEMORY;
            goto Exit;
        }

        ret = RegQueryValueA(hKey, sz, szValue, &cb);

        if (ret == ERROR_SUCCESS)
        {
            AnsiToUnicode(pwszValue, szValue, cb);

            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
        }
    }

Exit:
    if (sz)
        delete sz;

    return ret;
}

LONG APIENTRY RegSetValueX(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
    LPCWSTR lpData, DWORD cbData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegSetValue\n");
    #endif

    LPSTR szKey = NULL;
    LPSTR szValue = NULL;
    LONG  ret = ERROR_OUTOFMEMORY;

    szKey = Convert(lpSubKey);
    if (szKey == ERR)
    {
        szKey = NULL;
        goto Exit;
    }

    szValue = Convert(lpData);
    if (szValue == ERR)
    {
        szValue = NULL;
        goto Exit;
    }

    ret = RegSetValueA(hKey, szKey, dwType, szValue, cbData);

Exit:
    if (szKey)
        delete szKey;
    if (szValue)
        delete szValue;
    return ret;
}

UINT WINAPI RegisterWindowMessageX(LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterWindowMessage\n");
    #endif

    UINT ret;
#if 0
    LPSTR sz;

    sz = Convert(lpString);
    if (sz == ERR)
    {
        return 0;
    }
#else
    // BUGBUG: CairOLE calls this from libmain -- have to use static buffer

    CHAR sz[200];
    UnicodeToAnsi(sz, lpString, sizeof(sz));
#endif

    ret = RegisterWindowMessageA(sz);
#if 0
    delete sz;
#endif
    return ret;
}

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegOpenKeyEx\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(lpSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
    if (sz)
        delete sz;
    return ret;
}

LONG
APIENTRY
RegQueryValueExX(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegQueryValueEx\n");
    #endif

    LPBYTE lpTempBuffer;
    DWORD dwTempType;
    DWORD cb, cbRequired;
    LONG  ret;
    LPSTR sz;
    LPWSTR pwszTempWide;
    LPSTR pszTempNarrow;
    ULONG ulStringLength;

    sz = Convert(lpValueName);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (lpData == NULL)
    {
        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            // Adjust size of buffer to report, to account for CHAR -> WCHAR

            if (lpcbData != NULL)
                *lpcbData = cb * sizeof(WCHAR);
            break;

        default:

            if (lpcbData != NULL)
                *lpcbData = cb;
            break;
        }

        // Set the type, if required.
        if (lpType != NULL)
        {
            *lpType = dwTempType;
        }

        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        //
        // Determine the size of buffer needed
        //

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            cbRequired = cb * sizeof(WCHAR);
            break;

        default:

            cbRequired = cb;
            break;
        }

        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (lpcbData != NULL && *lpcbData < cbRequired)
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbData = cbRequired;

            // Set the type, if required.
            if (lpType != NULL)
            {
                *lpType = dwTempType;
            }

            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            lpTempBuffer = (LPBYTE) alloca(cbRequired);
            if (lpTempBuffer == NULL)
            {
                return ERROR_OUTOFMEMORY;
            }

            ret = RegQueryValueExA(hKey,
                                  sz,
                                  lpReserved,
                                  &dwTempType,
                                  lpTempBuffer,
                                  &cb);

            if (ret == ERROR_SUCCESS)
            {
                switch (dwTempType)
                {
                case REG_EXPAND_SZ:
                case REG_SZ:

                    AnsiToUnicode((LPWSTR) lpData, (LPSTR) lpTempBuffer, cb);

                    // Adjust size of buffer to report, to account for CHAR -> WCHAR
                    *lpcbData = cbRequired;

                    // Set the type, if required.
                    if (lpType != NULL)
                    {
                        *lpType = dwTempType;
                    }
                    break;

                case REG_MULTI_SZ:

                    pszTempNarrow = (LPSTR) lpTempBuffer;
                    pwszTempWide = (LPWSTR) lpData;

                    while (*pszTempNarrow != NULL)
                    {
                        ulStringLength = strlen(pszTempNarrow) + 1;
                        AnsiToUnicode(pwszTempWide,
                                      pszTempNarrow,
                                      ulStringLength);

                        // Compiler will scale appropriately here
                        pszTempNarrow += ulStringLength;
                        pwszTempWide += ulStringLength;
                    }
                    *pwszTempWide = NULL; // let's not forget MULTI_SZ end NULL
                    break;
                }
            }

            break;

        default:

            //
            // No conversion of out parameters needed.  Just call narrow
            // version with args passed in, and return directly.
            //

            ret = RegQueryValueExA(hKey,
                                   sz,
                                   lpReserved,
                                   lpType,
                                   lpData,
                                   lpcbData);

        }
    }

Exit:
    if (sz)
       delete sz;
    return ret;
}

HWND
WINAPI
CreateWindowExX( DWORD dwExStyle,
              LPCWSTR lpClassName,
                LPCWSTR lpWindowName,
                DWORD dwStyle,
                int X,
                int Y,
                int nWidth,
                int nHeight,
                HWND hWndParent ,
                HMENU hMenu,
                HINSTANCE hInstance,
                LPVOID lpParam )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateWindowEx\n");
    #endif

    HWND ret = NULL;
    LPSTR szClass;
    LPSTR szWindow;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpClassName) == 0)
    {
        // is it an atom?

        szClass = (LPSTR) lpClassName;
        fAtom = TRUE;
    }
    else
    {
        // otherwise convert the string

        szClass = Convert(lpClassName);
        if (szClass == ERR)
        {
            szClass = NULL;
            goto Exit;
        }
    }

    szWindow = Convert(lpWindowName);
    if (szWindow == ERR)
    {
        szWindow = NULL;
        goto Exit;
    }

    ret = SSCreateWindowExA (dwExStyle, szClass, szWindow, dwStyle, X, Y,
                         nWidth, nHeight, hWndParent, hMenu, hInstance,
                         lpParam);

Exit:
    if (!fAtom)
        if (szClass)
            delete szClass;
    if (szWindow)
        delete szWindow;
    return ret;
}


HWND
WINAPI
CreateWindowX(  LPCWSTR lpClassName,
                LPCWSTR lpWindowName,
                DWORD dwStyle,
                int X,
                int Y,
                int nWidth,
                int nHeight,
                HWND hWndParent ,
                HMENU hMenu,
                HINSTANCE hInstance,
                LPVOID lpParam )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateWindow\n");
    #endif

    return CreateWindowExX(0, lpClassName, lpWindowName, dwStyle, X, Y,
            nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}


ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterClass\n");
    #endif

    WNDCLASSA wc;
    ATOM      ret;
    BOOL      fAtom = FALSE;

    Win4Assert(sizeof(WNDCLASSA) == sizeof(WNDCLASSW));

    memcpy(&wc, lpWndClass, sizeof(WNDCLASS));

    wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
    if (wc.lpszMenuName==ERR)
    {
        return NULL;
    }

    if (HIWORD(lpWndClass->lpszClassName) == 0)
    {
        wc.lpszClassName = (LPSTR) lpWndClass->lpszClassName;
        fAtom = TRUE;
    }
    else
    {
        wc.lpszClassName = Convert(lpWndClass->lpszClassName);
        if (wc.lpszClassName==ERR)
        {
            if ((LPSTR) wc.lpszMenuName)
                delete (LPSTR) wc.lpszMenuName;
            return NULL;
        }
    }

    ret = RegisterClassA(&wc);
    if ((LPSTR) wc.lpszMenuName)
        delete (LPSTR) wc.lpszMenuName;
    if (!fAtom) delete (LPSTR) wc.lpszClassName;
    return ret;
}

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("UnregisterClass\n");
    #endif

    LPSTR sz;
    BOOL  ret;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpClassName) == 0)
    {
        sz = (LPSTR) lpClassName;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpClassName);
        if (sz == ERR)
            return FALSE;
    }

    ret = UnregisterClassA(sz, hInstance);
    if (!fAtom) delete sz;
    return ret;
}

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        fAtom = TRUE;
        sz = (LPSTR) lpString;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = GetPropA(hWnd, sz);
    if (!fAtom) delete sz;
    return ret;
}


BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("SetProp\n");
    #endif

    BOOL  ret;
    LPSTR sz;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = SetPropA(hWnd, sz, hData);
    if (!fAtom) delete sz;
    return ret;
}


HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RemoveProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = RemovePropA(hWnd, sz);
    if (!fAtom) delete sz;
    return ret;
}


UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProfileInt\n");
    #endif

    LPSTR szApp;
    LPSTR szKey;
    UINT  ret;

    szApp = Convert(lpAppName);
    if (szApp==ERR)
    {
        return nDefault;
    }

    szKey = Convert(lpKeyName);
    if (szApp==ERR)
    {
        if (szApp)
            delete szApp;
        return nDefault;
    }

    ret = GetProfileIntA(szApp, szKey, nDefault);
    if (szApp)
        delete szApp;
    if (szKey)
        delete szKey;
    return ret;
}

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalAddAtom\n");
    #endif

    ATOM ret;
    LPSTR sz;

    sz = Convert(lpString);
    if (sz==ERR)
    {
        return NULL;
    }

    ret = GlobalAddAtomA(sz);
    if (sz)
        delete sz;
    return ret;
}

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR pwszBuffer,
    int nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalGetAtomName\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = (LPSTR) alloca(nSize);
    if (sz == NULL)
    {
        return 0;
    }

    ret = GlobalGetAtomNameA(nAtom, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszBuffer, sz, lstrlenA(sz) + 1);
    }
    return ret;
}


DWORD
WINAPI
GetModuleFileNameX(
    HINSTANCE hModule,
    LPWSTR pwszFilename,
    DWORD nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetModuleFileName\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = (LPSTR) alloca(nSize);
    if (sz == NULL)
    {
        return 0;
    }

    ret = GetModuleFileNameA(hModule, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszFilename, sz, lstrlenA(sz) + 1);
    }

    return ret;
}


LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CharPrev\n");
    #endif

    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}

HFONT WINAPI CreateFontX(int a, int b, int c, int d, int e, DWORD f,
                         DWORD g, DWORD h, DWORD i, DWORD j, DWORD k,
                         DWORD l, DWORD m, LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFont\n");
    #endif

    LPSTR sz;
    HFONT ret;

    sz = Convert(pwsz);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateFontA(a,b,c,d,e,f,g,h,i,j,k,l,m,sz);
    if (sz)
        delete sz;
    return ret;
}


HINSTANCE
WINAPI
LoadLibraryX(
    LPCWSTR pwszFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = Convert(pwszFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryA(sz);
    if (sz)
        delete sz;
    return ret;
}


HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = ConvertOem(lpLibFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryExA(sz, hFile, dwFlags);
    if (sz)
        delete sz;
    return ret;
}



LONG
APIENTRY
RegDeleteKeyX(
    HKEY hKey,
    LPCWSTR pwszSubKey
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegDeleteKey\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(pwszSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegDeleteKeyA(hKey, sz);
    if (sz)
        delete sz;
    return ret;
}

BOOL
APIENTRY
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateProcess\n");
    #endif

    STARTUPINFOA si;
    BOOL         ret = FALSE;
    LPSTR        szApp = NULL;
    LPSTR        szCommand = NULL;
    LPSTR        szDir = NULL;

    memcpy(&si, lpStartupInfo, sizeof(STARTUPINFO));

    si.lpTitle = NULL;

    si.lpDesktop = Convert(lpStartupInfo->lpDesktop);
    if (si.lpDesktop == ERR)
    {
        si.lpDesktop = NULL;
        goto Error;
    }
    si.lpTitle = Convert(lpStartupInfo->lpTitle);
    if (si.lpTitle == ERR)
    {
        si.lpTitle = NULL;
        goto Error;
    }

    szApp = Convert(lpApplicationName);
    if (szApp == ERR)
    {
        szApp = NULL;
        goto Error;
    }
    szCommand = ConvertOem(lpCommandLine);
    if (szCommand == ERR)
    {
        szCommand = NULL;
        goto Error;
    }
    szDir = Convert(lpCurrentDirectory);
    if (szDir == ERR)
    {
        szDir = NULL;
        goto Error;
    }

    ret = SSCreateProcessA(szApp, szCommand, lpProcessAttributes,
                lpThreadAttributes, bInheritHandles, dwCreationFlags,
                lpEnvironment, szDir, &si, lpProcessInformation);

Error:
    if (si.lpDesktop)
        delete si.lpDesktop;
    if (si.lpTitle)
        delete si.lpTitle;

    if (szApp)
        delete szApp;
    if (szCommand)
        delete szCommand;
    if (szDir)
        delete szDir;

    return ret;
}

LONG
APIENTRY
RegEnumKeyExX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumKeyEx\n");
    #endif

    LPSTR szName;
    LPSTR szClass = NULL;
    LONG  ret = ERROR_OUTOFMEMORY;

    szName = (LPSTR) alloca(*lpcbName + 1);
    if (szName == NULL)
        goto Exit;

    if (lpClass != NULL)
    {
        szClass = (LPSTR) alloca(*lpcbClass + 1);
        if (szClass == NULL)
            goto Exit;
    }

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyExA(hKey, dwIndex, szName, lpcbName, lpReserved,
                       szClass, lpcbClass, lpftLastWriteTime);

    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(lpName, szName, *lpcbName + 1);

        if (szClass)
        {
            AnsiToUnicode(lpClass, szClass, *lpcbClass + 1);
        }
    }

Exit:
    return ret;
}

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDnewItem,
    LPCWSTR lpnewItem
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("AppendMenu\n");
    #endif

    BOOL  ret;
    LPSTR sz;

    if (uFlags == MF_STRING)
    {
        sz = Convert(lpnewItem);
        if (sz==ERR)
        {
            return FALSE;
        }
    }
    else
    {
        sz = (LPSTR) lpnewItem;
    }

    ret = AppendMenuA(hMenu, uFlags, uIDnewItem, sz);

    if (uFlags == MF_STRING)
    {
        if (sz)
            delete sz;
    }

    return ret;
}

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("OpenEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = OpenEventA(dwDesiredAccess, bInheritHandle, sz);
    if (sz)
        delete sz;
    return ret;
}

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
    if (sz)
        delete sz;
    return ret;
}

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetDriveType\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = Convert(lpRootPathName);
    if (sz == ERR)
    {
        return 0;
    }

    ret = GetDriveTypeA(sz);
    if (sz)
        delete sz;
    return ret;
}

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFileAttributes\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = ConvertOem(lpFileName);
    if (sz == ERR)
        return 0xFFFFFFFF;

    ret = GetFileAttributesA(sz);
    if (sz)
        delete sz;
    return ret;
}

LONG
APIENTRY
RegEnumKeyX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumKey\n");
    #endif

    CHAR sz[MAX_PATH+1];
    LONG ret;

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyA(hKey, dwIndex, sz, cbName);
    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(lpName, sz, lstrlenA(sz) + 1);
    }
    return ret;
}

HFINDFILE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW pwszFd
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("FindFirstFile\n");
    #endif

    WIN32_FIND_DATAA fd;
    CHAR             sz[MAX_PATH * 2];
    HFINDFILE        ret;
    int              len = lstrlenW(lpFileName) + 1;

    UnicodeToAnsiOem(sz, lpFileName, sizeof(sz));
    ret = FindFirstFileA(sz, &fd);
    if (ret != INVALID_HANDLE_VALUE)
    {
        memcpy(pwszFd, &fd, sizeof(FILETIME)*3 + sizeof(DWORD)*5);
        AnsiToUnicodeOem(pwszFd->cFileName, fd.cFileName,
                         lstrlenA(fd.cFileName) + 1);
        AnsiToUnicodeOem(pwszFd->cAlternateFileName, fd.cAlternateFileName,
                         14);
    }

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   wsprintfX
//
//  Synopsis:   Nightmare string function
//
//  Arguments:  [pwszOut]    --
//              [pwszFormat] --
//              [...]        --
//
//  Returns:
//
//  History:    1-06-94   ErikGav   Created
//
//  Notes:      If you're reading this, you're probably having a problem with
//              this function.  Make sure that your "%s" in the format string
//              says "%ws" if you are passing wide strings.
//
//              %s on NT means "wide string"
//              %s on Chicago means "ANSI string"
//
//----------------------------------------------------------------------------

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("wsprintf\n");
    #endif

    LPSTR szFormat;
    LPWSTR pwszTemp = NULL;
    int i = 0;

    // Convert the format string over

    szFormat = Convert(pwszFormat);
    if (szFormat == ERR)
    {
        szFormat = NULL;
        goto Exit;
    }

    // magic voodoo follows:
    //
    // 1. Call wvsprintf passing the varargs
    // 2. Use the pwszOut as a temp buffer to hold the ANSI output
    // 3. Save the returned characters

    i = wvsprintfA((LPSTR) pwszOut, szFormat,
                  (LPSTR) ((BYTE*)&pwszFormat) + sizeof(pwszFormat));

    // allocate a buffer for the Ansi to Unicode conversion

    pwszTemp = (LPWSTR) alloca((i+1)*sizeof(WCHAR));

    // convert the string

    AnsiToUnicode(pwszTemp, (LPSTR) pwszOut, i+1);

    // copy it to the out buffer

    lstrcpynW(pwszOut, pwszTemp, i+1);

Exit:
    if (szFormat)
        delete szFormat;
    return i;
}

BOOL
WINAPI
GetComputerNameX(
    LPWSTR pwszName,
    LPDWORD lpcchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetComputerName\n");
    #endif

    BOOL ret;
    LPSTR sz;
    DWORD OldSize = *lpcchBuffer;

    sz  = (LPSTR) alloca(*lpcchBuffer);
    ret = GetComputerNameA(sz, &OldSize);

    if (ret)
    {
        DWORD NewSize = AnsiToUnicode(pwszName, sz, *lpcchBuffer);
        if (NewSize) {
            *lpcchBuffer = NewSize - 1;
        } else {
            *lpcchBuffer = 0;
        }
    }

    return ret;
}

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD   cchBuffer,
    LPWSTR  lpPathBuffer,
    LPWSTR *lppFilePart
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFullPathName\n");
    #endif

    LPSTR szFileName;
    CHAR  szPathBuffer[MAX_PATH];
    LPSTR szFilePart;
    DWORD ret;


    szFileName = ConvertOem(lpFileName);
    if (szFileName == ERR)
        return 0;

    ret = GetFullPathNameA(szFileName, cchBuffer, szPathBuffer, &szFilePart);

    AnsiToUnicode(lpPathBuffer, szPathBuffer, cchBuffer);

    *lppFilePart = lpPathBuffer + (szFilePart - szPathBuffer);

    if (szFileName)
        delete szFileName;

    return ret;
}


DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszFullPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetShortPathName\n");
    #endif

    LPSTR szFullPath;
    CHAR  szShortBuffer[MAX_PATH];
    DWORD ret;


    szFullPath = Convert(lpszFullPath);
    if (szFullPath == ERR)
        return 0;

    if (lpszShortPath == NULL)
    {
        ret = GetShortPathNameA(szFullPath, NULL, cchBuffer);
    }
    else
    {
        ret = GetShortPathNameA(szFullPath, szShortBuffer, sizeof(szShortBuffer));

        if (ret != 0)
        {
            //
            //  Only convert the actual data, not the whole buffer.
            //
            if (cchBuffer > ret + 1)
                cchBuffer = ret + 1;

            AnsiToUnicode(lpszShortPath, szShortBuffer, cchBuffer);
        }
    }

    delete szFullPath;

    return ret;
}


DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )
{
    LPSTR lpszFileName;
    CHAR  szBuffer[MAX_PATH];
    DWORD ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("SearchPath\n");
    #endif

    lpszFileName = Convert(lpFileName);
    if (lpszFileName == ERR)
        return 0;

    ret = SearchPathA(NULL, lpszFileName, NULL, sizeof(szBuffer), szBuffer, NULL);

    AnsiToUnicode(lpBuffer, szBuffer, lstrlenA(szBuffer) + 1);

    delete lpszFileName;

    return ret;
}


ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    )
{
    LPSTR lpszString;
    ATOM  retAtom;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalFindAtom\n");
    #endif

    lpszString = Convert(lpString);
    if (lpszString == ERR)
        return 0;

    retAtom = GlobalFindAtomA(lpszString);

    delete lpszString;

    return retAtom;
}


int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount)
{
    LPSTR lpszClassName = NULL;
    int  ret;

    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetClassName\n");
    #endif

    lpszClassName = (LPSTR) alloca(nMaxCount);
    if (lpszClassName == NULL)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    ret = GetClassNameA(hWnd, lpszClassName, nMaxCount);

    if (ret)
    {
        AnsiToUnicode(lpClassName, lpszClassName, lstrlenA(lpszClassName) + 1);
    }

    return ret;
}


LPWSTR
WINAPI
CharLowerX(
    LPWSTR lpsz)
{
    if (((DWORD)lpsz & 0xffff0000) == 0)
    {
        return (LPWSTR)towlower ((wchar_t)lpsz);
    } else {
        return _wcslwr (lpsz);
    }
}

LPWSTR
WINAPI
CharUpperX(
    LPWSTR lpsz)
{
    if (((DWORD)lpsz & 0xffff0000) == 0)
    {
        return (LPWSTR)towupper ((wchar_t)lpsz);
    } else {
        return _wcsupr (lpsz);
    }
}

BOOL
WINAPI
GetStringTypeX(
    DWORD    dwInfoType,
    LPCWSTR  lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType)
{
    // Convert the source string to MBS. If we don't get the same number
    // of characters, this algorithm doesn't work.

    int OriginalLength = cchSrc == -1 ? lstrlenW (lpSrcStr) + 1 : cchSrc;
    LPSTR lpConvertedString = (LPSTR) alloca(OriginalLength+1);

    if (lpConvertedString == NULL)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (WideCharToMultiByte (CP_ACP,
                             WC_COMPOSITECHECK,
                             lpSrcStr,
                             cchSrc,
                             lpConvertedString,
                             OriginalLength,
                             NULL,
                             NULL) != OriginalLength)
    {
        delete lpConvertedString;
        SetLastError (ERROR_NO_UNICODE_TRANSLATION);
        return FALSE;
    }

    BOOL Result;

    Result = GetStringTypeA (GetThreadLocale (),
                             dwInfoType,
                             lpConvertedString,
                             OriginalLength,
                             lpCharType);
    return Result;
}

BOOL
WINAPI
IsCharAlphaX(
    WCHAR ch)
{
    return iswctype (ch, _UPPER | _LOWER);
}

BOOL
WINAPI
IsCharAlphaNumericX(
    WCHAR ch)
{
    return iswctype (ch, _UPPER | _LOWER | _DIGIT);
}


LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR lpDest = lpString1;

    while (*lpDest) {
        lpDest++;
    }

    while (*lpDest++ = *lpString2++) ;

    return lpString1;
}

int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return wcscmp(lpString1, lpString2);
}

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR lpDest = lpString1;

    while( *lpDest++ = *lpString2++ )
        ;

    return lpString1;
}

LPWSTR
WINAPI
lstrcpynX(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR dst;

    if (iMaxLength)
    {
        dst = lpString1;

        while (iMaxLength && *lpString2)
        {
            *dst++ = *lpString2++;
            iMaxLength--;
        }

        *dst = L'\0';
    }

    return lpString1;
}

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return _wcsicmp(lpString1, lpString2);
}

HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = CreateFileMappingA(
        hFile,
        lpFileMappingAttributes,
        flProtect,
        dwMaximumSizeHigh,
        dwMaximumSizeLow,
        lpszAName);

    delete lpszAName;

    return ret;
}


HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = OpenFileMappingA(
        dwDesiredAccess,
        bInheritHandle,
        lpszAName);

    delete lpszAName;

    return ret;
}

#endif   //  CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\wx86grpa\wx86grpa.cxx ===
/*++                 

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wx86grpa.cpp

Abstract:
    
    Ole interface into Wx86.

    Ole32 and Wx86 interface in similar ways regardless of Wx86 being static
    or dynamic. Ole32 will always receive a notification from whole32
    whenever whole32 is loaded or unloaded from memory. In this notification
    routine ole32 will establish or disestablish its linkage to wx86. In the 
    dynamic Wx86 case Ole32 will also maintain a count of the number of 
    pieces of x86 code in use. These include each load of an x86 dll. 
    Ole32 will load wx86 when the counter transitions from 0 to 1 and 
    unload wx86 when the counter transitions from 1 to 0. This loading or 
    unloading may cause the whole32 notification mechanism to kick in. Note 
    that the whole32 notification mechanism and ole32 reference counter 
    mechanisms are separate.
    
Author:

    29-Sep-1995 AlanWar

Revision History:

--*/

#ifdef WX86OLE

#ifndef UNICODE
#define UNICODE
#endif

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpsapi.h>
}

#include <ole2.h>

#include <wx86grpa.hxx>
#include <wx86pri.h>

CWx86 gcwx86;

void Wx86LoadNotification(BOOL fLoad, PVOID ap)
/*++

Routine Description:

    Whole32 calls this function to inform Ole32 when whole32 is loaded and 
unloaded.

Arguments:

    fLoad is TRUE then whole32 is being loaded into memory

Return Value:

--*/
{
    if (fLoad)
    {
        if (! gcwx86.IsWx86Linked())

        {
            gcwx86.LinkToWx86();
        }
    } else {
        gcwx86.UnlinkFromWx86();
    } 
}

CWx86::CWx86()
/*++

Routine Description:

    Constructor for Ole interface into Wx86. This routine assumes that
    Wx86 is already loaded.

Arguments:

Return Value:

--*/
{
//
// Consults the registry to determine if Wx86 is enabled in the system
// NOTE: this should be changed post SUR to call kernel32 which maintanes
//       this information, Instead of reading the registry each time.
//

    LONG Error;
    HKEY hKey;
    WCHAR ValueBuffer[MAX_PATH];
    DWORD ValueSize;
    DWORD dwType;

    _hModuleWx86 = NULL;
    _apvWholeFuncs = NULL;
	
    // This call should be checked for failure and appropriate action taken; 
    // however, we don't ship Alpha bits anymore so I'm leaving it alone.
    RtlInitializeCriticalSection(&_critsect);
    LinkToWx86();
}

CWx86::~CWx86()
/*++

Routine Description:

    Destructor for Ole interface into Wx86. This routine assumes that
    wx86 is still loaded.

Arguments:

Return Value:

--*/
{
    RtlDeleteCriticalSection(&_critsect);

    if (IsWx86Linked() && _lWx86UseCount > 0)
    {
        // Ole32 is unloading, but it still has Wx86 dynamically loaded.
        // Do we really want to automatically unload Wx86 ??

        UnloadWx86();
        _lWx86UseCount = 0;
    }
    _apvWholeFuncs = NULL;
}


BOOL CWx86::LinkToWx86()
/*++

Routine Description:

    Obtain key entrypoints to wx86.

Arguments:


Return Value:

    TRUE if enabled successfully

--*/
{
    PFNWX86GETOLEFUNCTIONTABLE pfnWx86GetOleFunctionTable;

    _hModuleWx86 = GetModuleHandle(TEXT("wx86.Dll"));

    if (_hModuleWx86 != NULL)
    {
        pfnWx86GetOleFunctionTable = (PFNWX86GETOLEFUNCTIONTABLE)
                                   GetProcAddress(
                                     _hModuleWx86, WX86GETOLEFUNCTIONTABLENAME);

        if (pfnWx86GetOleFunctionTable != NULL)
        {
            _apvWholeFuncs = (*pfnWx86GetOleFunctionTable)();
        }
    }

    return(_apvWholeFuncs != NULL);
}

BOOL CWx86::IsModuleX86(HMODULE hModule)
/*++

Routine Description:

    Determines if module specified is x86 code

Arguments:

    hModule is handle for the module

Return Value:

    TRUE if module marked as x86 code

--*/
{
    PIMAGE_NT_HEADERS NtHeader;

    NtHeader = RtlImageNtHeader(hModule);
    return(NtHeader && NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386);        
}

PFNDLLGETCLASSOBJECT CWx86::TranslateDllGetClassObject(
    PFNDLLGETCLASSOBJECT pv
    )
/*++

Routine Description:

    Translates an x86 entrypoint to DllGetClassObject to a thunk that can
    be called by Risc Ole32.

Arguments:

    pv is the x86 entrypoint returned from GetProcAddress. It is assumed
        to be an x86 address.

Return Value:

    Risc callable entrypoint or NULL if thunk cannot be created

--*/
{
    if (IsWx86Linked())
    {
        return ((WHOLETHUNKDLLGETCLASSOBJECT)(_apvWholeFuncs[WholeThunkDllGetClassObjectIdx]))(pv);
    }
    
    // Wx86 is not loaded so we don't try to create a thunk
    return (PFNDLLGETCLASSOBJECT) NULL;
}

PFNDLLCANUNLOADNOW CWx86::TranslateDllCanUnloadNow(
    PFNDLLCANUNLOADNOW pv
    )
/*++

Routine Description:

    Translates an x86 entrypoint to DllCanUnloadNow to a thunk that can
    be called by Risc Ole32

Arguments:

    pv is the x86 entrypoint returned from GetProcAddress. It is assumed
        to be an x86 address

Return Value:

    Risc callable entrypoint or NULL if thunk cannot be created

--*/
{
    if (IsWx86Linked())
    {
        return ((WHOLETHUNKDLLCANUNLOADNOW)_apvWholeFuncs[WholeThunkDllCanUnloadNowIdx])(pv);
    }
    
    // Wx86 is not loaded so we don't try to create a thunk
    return((PFNDLLCANUNLOADNOW)NULL);
}

void CWx86::SetStubInvokeFlag(UCHAR bFlag)
/*++

Routine Description:

    Set/Reset a flag in the Wx86 thread environment to let the thunk layer
    know that the call is a stub invoked call and allow any in or out
    custom interface pointers to be thunked as IUnknown rather than rejecting
    the call. Since all interface pointer parameters of a stub invoked call 
    must be marshalled or unmarshalled only the IUnknown methods must be
    thunked.

Arguments:

    bFlag is the value to set flag to

Return Value:

--*/
{
    NtCurrentTeb()->Wx86Thread.OleStubInvoked = bFlag;
}

BOOL CWx86::NeedX86PSFactory(IUnknown *punkObj, REFIID riid)
/*++

Routine Description:

    Calls Wx86 to determine if an x86 PSFactory is required.

Arguments:
    punkObj is IUnknown for which a stub would be created
    riid is the IID for which a proxy would need to be created

Return Value:

    TRUE if x86 PSFactory is required

--*/
{
    BOOL b = FALSE;

    if (IsWx86Linked())
    {
        b = ((WHOLENEEDX86PSFACTORY)_apvWholeFuncs[WholeNeedX86PSFactoryIdx])(punkObj, riid);
    }    
    return(b);
}


BOOL CWx86::IsN2XProxy(IUnknown *punk)
/*++

Routine Description:

    Calls Wx86 to determine if punk is actually a Native calling X86 proxy

Arguments:

Return Value:

    TRUE if punk is N2X proxy

--*/
{
    BOOL b = FALSE;

    if (IsWx86Linked())
    {
        b = ((WHOLEISN2XPROXY)_apvWholeFuncs[WholeIsN2XProxyIdx])(punk);
    }    
    return(b);
}

HMODULE CWx86::LoadX86Dll(LPCWSTR ptszPath)
/*++

Routine Description:

    Load in an x86 dll into a risc process

Arguments:

    ptsxPath is the name of the dll

Return Value:
    Previous value of flag

--*/
{
    HMODULE hmod = NULL;

    if (IsWx86Linked())
    {
        hmod = ((PFNWX86LOADX86DLL)_apvWholeFuncs[Wx86LoadX86DllIdx])(ptszPath, LOAD_WITH_ALTERED_SEARCH_PATH);
    }
    return(hmod);
}

BOOL CWx86::FreeX86Dll(HMODULE hmod)
/*++

Routine Description:

    Unload an x86 dll from a risc process

Arguments:

    hmod is the module handle

Return Value:

    result of unload

--*/
{
    BOOL b;

    if (IsWx86Linked())
    {
        b = ((PFNWX86FREEX86DLL)_apvWholeFuncs[Wx86FreeX86DllIdx])(hmod);
    } else {
        b = FreeLibrary(hmod);
    }

    return(b);
}

BOOL CWx86::IsWx86Calling(void)
/*++

Routine Description:

    Returns a flag that is set in the whole32 thunks when a Wx86 thread makes
    an Ole API call.

Arguments:

Return Value:

--*/
{
    BOOL b = FALSE;
    PWX86TIB pwx86tib = Wx86CurrentTib();

    if (pwx86tib != NULL)
    {
        if ( pwx86tib->Flags & WX86FLAG_CALLTHUNKED )
        {
            b = TRUE;
        }
        pwx86tib->Flags &= ~WX86FLAG_CALLTHUNKED;
    }    

    return(b);
}

BOOL CWx86::IsQIFromX86(void)
/*++

Routine Description:

    Returns a flag that is set in the whole32 thunks when a Wx86 thread makes
    a QI call.

Arguments:

Return Value:

--*/
{
    BOOL b = FALSE;
    PWX86TIB pwx86tib = Wx86CurrentTib();

    if (pwx86tib != NULL)
    {
        if ( pwx86tib->Flags & WX86FLAG_QIFROMX86 )
        {
            b = TRUE;
        }
        pwx86tib->Flags &= ~WX86FLAG_QIFROMX86;
    }    

    return(b);
}


BOOL CWx86::SetIsWx86Calling(BOOL bFlag)
/*++

Routine Description:

    Set the flag in the Wx86TIB that would indicate that CoSetState or
    CoGetState was called from a Wx86 thread.

Arguments:


Return Value:

--*/
{
    PWX86TIB pWx86Tib;
    BOOL b = TRUE;

    if (IsWx86Linked())
    {
        pWx86Tib = Wx86CurrentTib();

        if (pWx86Tib != NULL)
        {
            pWx86Tib->Flags |= WX86FLAG_CALLTHUNKED;
        }
    } else {
        b = FALSE;
    }

    return(b);
}


PVOID CWx86::UnmarshalledInSameApt(PVOID pv, REFIID piid)
/*++

Routine Description:

    Call Wx86 to inform it that an interface was unmarshalled in the same
    apartment that it was marshalled. If in this case Wx86 notices that it 
    is an interface that is being passed between a PSThunk pair then it will
    establish a new PSThunk pair for the interface and return the proxy
    pointer. Ole32 should then clean up the ref counts in the tables normally
    but return the new interface pointer.

Arguments:

    pv is the interface that was unmarshalled into the same apartment
    piid is the IID for the interface being unmarshalled

Return Value:

    NULL if wx86 doesn't know about the interface; Ole32 will proceed as
         normal
    (PVOID)-1 if wx86 does know about the interface, but cannot establish
        a PSThunk. Ole should return an error from the Unmarshalling code
    != NULL then PSThunk proxy to return to caller

--*/
{
    if (IsWx86Linked())
    {
        pv = ((WHOLEUNMARSHALLEDINSAMEAPT)_apvWholeFuncs[WholeUnmarshalledInSameApt])(pv, piid);
    } else {
        pv = NULL;
    }    

    return(pv);
}

void CWx86::AggregateProxy(IUnknown *punkControl, IUnknown *punk)
/*++

Routine Description:

    Call Wx86 Ole thunk layer to have it aggreagate punk to punkControl if
punk is a N2X proxy. This needs to be done to ensure that the N2X proxy
represented by punk has the same lifetime as punkControl.

Arguments:

    punkControl is the controlling unknown of the proxy
    punk is the proxy to be aggregated to punkControl


Return Value:


--*/
{
    if (IsWx86Linked())
    {
        ((WHOLEAGGREGATEPROXY)_apvWholeFuncs[WholeAggregateProxyIdx])(punkControl, punk);
    }    
}


BOOL CWx86::ReferenceWx86(void)
/*++

Routine Description:

    This routine is called whenever Ole32 wants to increase its usage
    count on Wx86. In the dynamic case when the usage count transitions
    from 0 to 1 then ole32 will load wx86.

    We can avoid using Interlocked apis since all changes to the reference
    count is occuring within the critical section

Arguments:

Return Value:
    TRUE if Wx86 loaded successfully else FALSE

--*/
{
    BOOL fRet;

    CCritSect ccritsect(&_critsect);

    if (++_lWx86UseCount > 1)
    {
	return(TRUE);     
    } 
    else if (_lWx86UseCount == 1)
    {
        _hModuleWx86 = LoadLibrary(TEXT("wx86.dll"));
        if (_hModuleWx86 != NULL)
        {
            PFNWX86INITIALIZEOLE pfnWx86InitializeOle;

            pfnWx86InitializeOle = (PFNWX86INITIALIZEOLE)GetProcAddress(
                                       _hModuleWx86, WX86INITIALIZEOLENAME);
            if ((pfnWx86InitializeOle == NULL) ||
                ((_apvWholeFuncs = (*pfnWx86InitializeOle)()) == NULL))
            {
                FreeLibrary(_hModuleWx86);
                _hModuleWx86 = NULL;
            }
        }

        if (_hModuleWx86 == NULL)
        {
            _lWx86UseCount--;
            fRet = FALSE;
        } else {
            fRet = TRUE;
        }
    } 
    else /* _lWx86UseCount < 1 */
    {
        fRet = FALSE;
    }

    if (! fRet)
    {
        RtlDeleteCriticalSection(&_critsect);
    }

    return(fRet);
}


void CWx86::DereferenceWx86(void)
/*++

Routine Description:

    This routine is called whenever Ole32 wants to decrease its usage
    count on Wx86. In the dynamic case when the usage count transitions
    from 1 to 0 then ole32 will unload wx86.

    We can avoid using Interlocked apis since all changes to the reference
    count is occuring within the critical section

Arguments:

Return Value:

--*/
{
    CCritSect ccritsect(&_critsect);

    if (--_lWx86UseCount > 0)
    {
	return;     
    }
    else if (_lWx86UseCount == 0)
    {
        UnloadWx86();
    }
    else /* _lWx86UseCount < 0 */
    {
        _lWx86UseCount = 0;
    }
}


void CWx86::UnloadWx86(void)
/*++

Routine Description:

    Disconnect linkage between Ole32 and Wx86 and unload wx86 from memory.    

Arguments:

Return Value:

--*/
{
    PFNWX86DEINITIALIZEOLE pfnWx86DeinitializeOle;

    pfnWx86DeinitializeOle = (PFNWX86DEINITIALIZEOLE)GetProcAddress(
                                _hModuleWx86, WX86DEINITIALIZEOLENAME);
    if (pfnWx86DeinitializeOle != NULL)
    {
        (*pfnWx86DeinitializeOle)();
    }

    FreeLibrary(_hModuleWx86);
    UnlinkFromWx86();
}


CCritSect::CCritSect(RTL_CRITICAL_SECTION *pcritsect)
{
   NTSTATUS status;

   _pcritsect = NULL;
   RtlEnterCriticalSection(pcritsect);
   _pcritsect = pcritsect;
}

CCritSect::~CCritSect()
{
    NTSTATUS status;

    if (_pcritsect != NULL)
    {
        RtlLeaveCriticalSection(_pcritsect);
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\fwd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comcat.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\fwd\catfact.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       d:\nt\private\ole32\comcat\src\catfact.cpp
//
//  Contents:   This is a stub for comcat.dll after it's merged into
//              ole32.dll. It will forward DllGetRegisterServer and
//              DllGetClassObject to ole32.dll, local version of
//              DllCanUnloadNow and DllUnregisterServer is provided.
//
//  Classes:
//
//  Functions:  DllUnregisterServer
//              DllCanUnloadNow
//              DllRegisterServer
//
//  History:    10-Mar-97   YongQu  Created
//+---------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <tchar.h>

#pragma comment(linker, "/export:DllGetClassObject=Ole32.DllGetClassObject,PRIVATE")

// Due to NT bug #314014, we no longer explicitly forward DllRegisterServer
// to ole32.  The reason: ole32 also registers other components (namely storage)
// which access reg keys that cannot be written by non-admin accounts.  Since
// ole32, and by extension comcat, is already registered on the system,
// comcat's DllRegisterServer can be a no-op.

//#pragma comment(linker, "/export:DllRegisterServer=Ole32.DllRegisterServer,PRIVATE")
STDAPI DllRegisterServer()
{
    return S_OK;
}

// can never unload
STDAPI DllCanUnloadNow()
{
    return S_FALSE;
}

// still provide this, but seems to be unnecessary
STDAPI DllUnregisterServer(void)
{
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\catfact.cpp ===
#include "windows.h"
#include "ole2.h"
#include "tchar.h"
#include "catobj.h"

CATEGORYINFO g_catids[NUM_OLDKEYS_SUPPORTED] =
{
    {{0x40FC6ED3,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Embeddable Objects"},
    {{0x40FC6ED4,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Controls"},
    {{0x40FC6ED5,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Automation Objects"},
    {{0x40FC6ED8,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Document Objects"},
    {{0x40FC6ED9,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"_Printable Objects"}
};

extern "C" {
STDAPI ComcatDllRegisterServer(void);
STDAPI ComcatDllUnRegisterServer(void);
}


// Create a new object and return a pointer to it
HRESULT CComCatCF_CreateInstance(IUnknown *pUnkOuter,
                                 REFIID riid, void** ppObject)
{
    HRESULT hr = E_OUTOFMEMORY;

    CComCat* pObj= new CComCat(FALSE);
    if(NULL != pObj)
    {
        hr = pObj->Initialize(pUnkOuter);
        if (SUCCEEDED(hr))
        {
            if (pUnkOuter)
            {
                *ppObject = (LPUNKNOWN)(pObj->m_punkInner);
                pObj->m_punkInner->AddRef();
            }
            else
            {
                hr = pObj->QueryInterface(riid, ppObject);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    return hr;
}

// Create a new object and return a pointer to it, class store
HRESULT CComCatCSCF_CreateInstance(IUnknown *pUnkOuter,
                                 REFIID riid, void** ppObject)
{
    HRESULT hr = E_OUTOFMEMORY;

    CComCat* pObj= new CComCat(TRUE);
    if(NULL != pObj)
    {
        hr = pObj->Initialize(pUnkOuter);
        if (SUCCEEDED(hr))
        {
            if (pUnkOuter)
            {
                *ppObject = (LPUNKNOWN)(pObj->m_punkInner);
                pObj->m_punkInner->AddRef();
            }
            else
            {
                hr = pObj->QueryInterface(riid, ppObject);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    return hr;
}

STDAPI ComcatDllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32,  hKeyComCat;
    DWORD dwDisposition;
    HRESULT hr;
    IClassFactory *pcf = NULL;
    ICatRegister *preg = NULL;

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    _T("CLSID\\{0002E005-0000-0000-C000-000000000046}"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS)
    {
            return E_UNEXPECTED;
    }

    if (RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("Component Categories Manager"), sizeof(_T("Component Categories Manager")))!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }

    if (RegCreateKeyEx(hKeyCLSID,
                    _T("InprocServer32"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }

    TCHAR szName[] = _T("OLE32.DLL");
    if (RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }
    if (RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) _T("Both"), sizeof(_T("Both")))!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }
    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    // RegCreateKeyEx will open the key if it exists
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    SZ_COMCAT,
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyComCat, &dwDisposition)!=ERROR_SUCCESS)
    {
            return E_UNEXPECTED;
    }
    RegCloseKey(hKeyComCat);
    hr = DllGetClassObject(CLSID_StdComponentCategoriesMgr, IID_IClassFactory, (void**)&pcf);
    if(FAILED(hr))
            return hr;
    hr = pcf->CreateInstance(NULL, IID_ICatRegister, (void**)&preg);
    pcf->Release();
    if(FAILED(hr))
            return hr;

    hr = preg->RegisterCategories(NUM_OLDKEYS_SUPPORTED, g_catids);
    preg->Release();

    // Adding the WithCS clsid.
    //-----------------------------
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{0002E006-0000-0000-C000-000000000046}"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
			&hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

	if (RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("Component Categories Manager With Class Store"), sizeof(_T("Component Categories Manager With Class Store")))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

	if (RegCreateKeyEx(hKeyCLSID, 
			_T("InprocServer32"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
			&hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

    if (RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
    if (RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) _T("Both"), sizeof(_T("Both")))!=ERROR_SUCCESS) 
    {
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
	RegCloseKey(hKeyInproc32);
	RegCloseKey(hKeyCLSID);

    return hr;
}

STDAPI ComcatDllUnregisterServer(void)
{
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
           _T("CLSID\\{0002E005-0000-0000-C000-000000000046}\\InprocServer32"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
           _T("CLSID\\{0002E005-0000-0000-C000-000000000046}"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }

    // removing clsid withcs

    if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{0002E006-0000-0000-C000-000000000046}\\InprocServer32"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{0002E006-0000-0000-C000-000000000046}"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\catobj.h ===
#ifndef _COMCATMANAGER_INCLUDE
#define _COMCATMANAGER_INCLUDE

#include "comcat.h"

#if 1 // #ifndef _CHICAGO_
#include "csguid.h"
#include "cscatinf.h"
#endif


#define NUM_OLDKEYS_SUPPORTED 5 // gd


class CComCat : public ICatRegister, public ICatInformation
{
public:
    // IUnknown methods
    HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    // ICatRegister methods
    HRESULT __stdcall RegisterCategories(ULONG cCategories, CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
    HRESULT __stdcall UnRegisterCategories(ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);
    HRESULT __stdcall RegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);
    HRESULT __stdcall UnRegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ]);
    HRESULT __stdcall RegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);
    HRESULT __stdcall UnRegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);

    // ICatInformation methods
    HRESULT __stdcall EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo);
    HRESULT __stdcall GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc);
    HRESULT __stdcall EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired, CATID rgcatidReq[], IEnumGUID **ppenumClsid);
    HRESULT __stdcall IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ]);
    HRESULT __stdcall EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid);
    HRESULT __stdcall EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid);

    static HRESULT IsClassOfCategoriesEx(WCHAR *pwszCLSID, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ]);

    static HRESULT GetCategoryDesc(HKEY hKey, LCID lcid, LPOLESTR *ppszDesc, PLCID plcid);

    friend HRESULT CComCatCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppObject);
    friend HRESULT CComCatCSCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppObject);

private:

    // Helper methods
    static HRESULT GetKey(REFCLSID rclsid, HKEY* phKey);
    static HRESULT EnumCategoriesOfClass(REFCLSID rclsid, LPCTSTR lpszSubKey, BOOL bMapOldKeys, IEnumGUID **ppenumCatid);

    HRESULT RegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ], LPCWSTR szImplReq);
    HRESULT UnRegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ],LPCWSTR szImplReq);
    HRESULT StringConvert(LPTSTR, LPCWSTR, LPCWSTR);
    static HRESULT ConvertStringToLCID(LCID* newlcid,LPTSTR szLCID);

#if 1 // #ifndef _CHICAGO_
    HRESULT GetCsCatInfo();
#endif

    CComCat(BOOL CsFlag);
    HRESULT Initialize(IUnknown* punkOuter);
    ~CComCat();

    class CInnerUnk : public IUnknown
    {
    public:
        // IUnknown methods
        HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
        ULONG   _stdcall AddRef();
        ULONG   _stdcall Release();

        CInnerUnk(CComCat* pObj);

        CComCat* m_pObj;
    } *m_punkInner;


    friend CInnerUnk;

    IUnknown        *m_punkOuter;
    ICatInformation *m_pcsICatInfo;
                    // CS ICatinfo pointer
#if 1 // #ifndef _CHICAGO_
    CRITICAL_SECTION m_csCatInfoInit;
#endif
    ULONG m_dwRefCount;
    BOOL  m_fCsFlag;
    BOOL  m_bLockValid;
};

extern const WCHAR* WSZ_CLSID;
extern const TCHAR* SZ_COMCAT;
extern const WCHAR* WSZ_IMPLCAT;
extern const WCHAR* WSZ_REQCAT;
extern const TCHAR* SZ_OLDKEY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comcat.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\comcat.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <malloc.h>
#include <ole2sp.h>

#include "catobj.h"
#include "tchar.h"

#include "catenum.h"
#include "valid.h"

#define CATID_SIZE 40

#define KEY_STRING_IMPL_CHARS (sizeof("Implemented Categories\\")-1)
#define KEY_STRING_REQ_CHARS (sizeof("Required Categories\\")-1)



//extern BOOL g_bUnicodeAPIs;


const WCHAR *WSZ_CLSID = L"CLSID";
const TCHAR *SZ_COMCAT = _T("Component Categories");
const WCHAR *WSZ_IMPLCAT = L"Implemented Categories";
const WCHAR *WSZ_REQCAT = L"Required Categories";
const TCHAR *SZ_OLDKEY = _T("OldKey");

//const DWORD KEY_STRING_SIZE = 0x2d;
//const DWORD KEY_STRING_IMPL_SIZE = 0x44;
//const DWORD KEY_STRING_REQ_SIZE =  0x41;

CATEGORYINFO g_oldkeyinfo[NUM_OLDKEYS_SUPPORTED] =
                {
                        {{0x40FC6ED3,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Insertable"},
                        {{0x40FC6ED4,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Control"},
                        {{0x40FC6ED5,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Programmable"},
                        {{0x40FC6ED8,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"DocObject"},
                        {{0x40FC6ED9,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Printable"}
                };

//#define CAT_E_CATIDNOEXIST E_UNEXPECTED
//#define CAT_E_NODESCRIPTION E_UNEXPECTED


CComCat::CComCat(BOOL CsFlag)
{
    m_dwRefCount=0;
    m_punkInner=NULL;
    m_punkOuter=NULL;
    m_pcsICatInfo = NULL;
    m_fCsFlag = CsFlag;
    m_bLockValid = FALSE;
}

HRESULT CComCat::Initialize(IUnknown* punkOuter)
{
    if (m_fCsFlag)
    {
        LONG status = RtlInitializeCriticalSection(&m_csCatInfoInit);
        if (!NT_SUCCESS(status))
            return E_OUTOFMEMORY;
        m_bLockValid = TRUE;
    }
    
    m_punkInner = new CInnerUnk(this);
    //m_punkInner = pObj;
    if (NULL == m_punkInner)
    {
        return E_OUTOFMEMORY;
    }
    
    if (punkOuter)
    {
        m_punkOuter=punkOuter;
    }
    else
    {
        m_punkOuter= m_punkInner;
    }
    
    return S_OK;
}

CComCat::~CComCat()
{
    if (NULL != m_punkInner)
    {
        delete m_punkInner;
    }
    
    if (m_fCsFlag && m_bLockValid)
        DeleteCriticalSection(&m_csCatInfoInit);
    
    if (m_pcsICatInfo)
        m_pcsICatInfo->Release();
}

HRESULT CComCat::QueryInterface(REFIID riid, void** ppObject) {
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        return m_punkOuter->QueryInterface(riid, ppObject);
}

ULONG CComCat::AddRef()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        return m_punkOuter->AddRef();
}

ULONG CComCat::Release()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        return m_punkOuter->Release();
}

CComCat::CInnerUnk::CInnerUnk(CComCat* pObj)
{
        m_pObj=pObj;
}

STDMETHODIMP CComCat::CInnerUnk::QueryInterface(REFIID riid, void** ppObject)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (riid==IID_IUnknown)
        {
                *ppObject=m_pObj->m_punkInner;
                m_pObj->m_punkInner->AddRef(); // So that when called by run time (QI, then Release) we don't die
                return S_OK;
        }
        else if(riid==IID_ICatRegister)
        {
                *ppObject=(ICatRegister*) m_pObj;
        }
        else if (riid==IID_ICatInformation)
        {
                *ppObject=(ICatInformation*) m_pObj;
        }
        else
        {
                *ppObject = NULL;
                return E_NOINTERFACE;
        }
        m_pObj->AddRef();
        return S_OK;
}

STDMETHODIMP_(ULONG) CComCat::CInnerUnk::AddRef()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        return InterlockedIncrement((long*) &m_pObj->m_dwRefCount);
}

STDMETHODIMP_(ULONG) CComCat::CInnerUnk::Release()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        ULONG dwRefCount= InterlockedDecrement((long*) &m_pObj->m_dwRefCount);
        if (dwRefCount==0)
        {
                delete m_pObj;
                return 0;
        }
        return dwRefCount;
}

// ICatRegister methods
HRESULT CComCat::RegisterCategories(ULONG cCategories, CATEGORYINFO __RPC_FAR rgCategoryInfo[  ])
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(rgCategoryInfo, sizeof(rgCategoryInfo[0])*cCategories))
        {
                return E_INVALIDARG; // gd
        }

    HRESULT hr = S_OK;
    char szlcid[16];
    WCHAR wszcatid[CATID_SIZE];
    HKEY hkey, hkeyCat;
    LONG        lRet;

        // RegCreateKeyEx will open the key if it exists
        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_COMCAT, 0, 0, 0, KEY_WRITE, NULL, &hkey, NULL))
        {
                return S_FALSE;
        }

        for (ULONG nIndex=0; nIndex<cCategories; nIndex++)
        {
                // Stringize lcid
                wsprintfA(szlcid, "%lX", rgCategoryInfo[nIndex].lcid);

                // Stringize catid
                if (0 == StringFromGUID2(rgCategoryInfo[nIndex].catid, wszcatid, CATID_SIZE))
                {
                        hr = E_OUTOFMEMORY;
                break;
            }

#ifdef UNICODE
//              if (g_bUnicodeAPIs)
                        lRet = RegCreateKeyExW(hkey, wszcatid, 0,0,0, KEY_WRITE, NULL, &hkeyCat, NULL);
#else
//              else
                {
                        char *pszcatid = NULL;
                        int cch = WideCharToMultiByte(CP_ACP, 0, wszcatid, -1, NULL, 0, NULL, NULL);
                        if(cch)
                        {
//                              pszcatid = new char[cch+1];
                                pszcatid = (char *)alloca(cch+1);
//                              if(NULL == pszcatid)
//                              {
//                                      RegCloseKey(hkey);
//                                      hr = E_OUTOFMEMORY;
//                                      break;
//                              }

                                WideCharToMultiByte(CP_ACP, 0, wszcatid, -1, pszcatid, cch+1, NULL, NULL);
                                lRet = RegCreateKeyExA(hkey, pszcatid, 0,0,0, KEY_WRITE, NULL, &hkeyCat, NULL);
//                              delete [] pszcatid;
                        }
                }
#endif
                if (lRet != ERROR_SUCCESS)
                {
                        hr = S_FALSE;
                break;
            }

                // RegSetValueEx overwrites only the value specified.
#ifdef UNICODE
//              if (g_bUnicodeAPIs)
//              {
                        WCHAR wszlcid[50];
                        MultiByteToWideChar(CP_ACP, 0, szlcid, -1, wszlcid, sizeof(wszlcid) / sizeof(WCHAR));
                lRet = RegSetValueExW(hkeyCat, wszlcid, 0, REG_SZ, (LPBYTE) rgCategoryInfo[nIndex].szDescription, (lstrlenW(rgCategoryInfo[nIndex].szDescription)+1)*2);
//              }
#else
//              else
//              {
                    int cch = WideCharToMultiByte(CP_ACP, 0, rgCategoryInfo[nIndex].szDescription, -1, NULL, 0, NULL, NULL);
//                      char *pszDesc = new char[cch+1];
                        char *pszDesc = (char *)alloca(cch+1);
                if (pszDesc != NULL)
                    {
                                WideCharToMultiByte(CP_ACP, 0, rgCategoryInfo[nIndex].szDescription, -1, pszDesc, cch+1, NULL, NULL);
                                lRet = RegSetValueExA(hkeyCat, szlcid, 0, REG_SZ, (LPBYTE) pszDesc, lstrlenA(pszDesc)+1);
//                              delete []pszDesc;
                }
//                  else
//                  {
//                              hr = E_OUTOFMEMORY;
//                              break;
//                      }
//              }
#endif
                RegCloseKey(hkeyCat);
                if (lRet != ERROR_SUCCESS)
                {
                        hr = S_FALSE;
                    break;
                }
        }
        RegCloseKey(hkey);
        return hr;
}

LONG RecursiveRegDeleteKey(HKEY hParentKey, LPSTR szKeyName)
{
        DWORD   dwIndex = 0L;
        char    szSubKeyName[256];
        HKEY    hCurrentKey = NULL;
        DWORD   dwResult;

        if ((dwResult = RegOpenKeyA(hParentKey, szKeyName, &hCurrentKey)) ==
                ERROR_SUCCESS)
        {
                // Remove all subkeys of the key to delete
                while ((dwResult = RegEnumKeyA(hCurrentKey, 0, szSubKeyName, 255)) ==
                        ERROR_SUCCESS)
                {
                        if ((dwResult = RecursiveRegDeleteKey(hCurrentKey,
                                szSubKeyName)) != ERROR_SUCCESS)
                                break;
                }

                // If all went well, we should now be able to delete the requested key
                if ((dwResult == ERROR_NO_MORE_ITEMS) || (dwResult == ERROR_BADKEY))
                {
                        dwResult = RegDeleteKeyA(hParentKey, szKeyName);
                }
                RegCloseKey(hCurrentKey);
        }

    return ERROR_SUCCESS;
}

HRESULT CComCat::UnRegisterCategories(ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories))
        {
                return E_INVALIDARG;
        }

    ULONG nIndex;
    DWORD rc  = NOERROR;
    WCHAR wszcatid[CATID_SIZE];
    char szKey[_MAX_PATH];
        for (nIndex=0; nIndex<cCategories; nIndex++)
        {
        // Stringize catid. not a good return value, but this error will
    // never happen.
        if (0 == StringFromGUID2(rgcatid[nIndex], wszcatid, CATID_SIZE))        //yq
            return E_OUTOFMEMORY;
#ifdef UNICODE
        wsprintfA(szKey, "%S\\%S", SZ_COMCAT, wszcatid);
#else
                wsprintfA(szKey, "%s\\%S", SZ_COMCAT, wszcatid);
#endif
        // RegDeleteKey is not recursive (on NT)
        rc = RecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
        if (rc != ERROR_SUCCESS)
           break;
        }
        return HRESULT_FROM_WIN32(rc);
}

// convert between ANSI and UNICODE
HRESULT CComCat::StringConvert(LPTSTR szKey, LPCWSTR wszguid, LPCWSTR szImplReq)
{
#ifdef UNICODE   //gd
        wsprintf(szKey, _T("%s\\%s\\%s"), WSZ_CLSID, wszguid, szImplReq); //gd
#else
        // %S converts from unicode
    wsprintf(szKey, _T("%S\\%S\\%S"), WSZ_CLSID, wszguid, szImplReq);
#endif

        return S_OK;
}

// Internal method to handle both Impl and Req variations.
HRESULT CComCat::RegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ], LPCWSTR szImplReq)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories))
        {
                return E_INVALIDARG;
        }

    WCHAR wszclsid[CATID_SIZE];
    WCHAR wszguid[CATID_SIZE];
    TCHAR szCatKey[_MAX_PATH];
    DWORD rc ;
    HRESULT hr = S_OK;
    HKEY  hkCatKey;
    HKEY  hKey;
        ULONG nIndex;

        if(0 == cCategories)            //gd
                return S_OK;
    // Stringize clsid
    if (0 == StringFromGUID2(rclsid, wszclsid, CATID_SIZE))     //yq
        return E_OUTOFMEMORY;

#ifdef UNICODE
                wsprintf(szCatKey, _T("%s\\%s"), WSZ_CLSID, wszclsid);
#else
                wsprintf(szCatKey, _T("%S\\%S"), WSZ_CLSID, wszclsid);
#endif

        // HKCR\CLSID\{rclsid} need to exist first.
    if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCatKey, 0, NULL, 0, KEY_WRITE,NULL, &hkCatKey, NULL)))
    {
        return HRESULT_FROM_WIN32(rc) ;
    }
    RegCloseKey(hkCatKey);



        StringConvert((LPTSTR)szCatKey,wszclsid,szImplReq);

    // HKCR\CLSID\{...rclsid...}\Impl/Required Categories =
    // RegCreateKeyEx will open the key if it exists
    if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCatKey, 0, NULL, 0, KEY_WRITE, NULL, &hkCatKey, NULL)))
    {
        return HRESULT_FROM_WIN32(rc) ;
    }

        for (nIndex=0; nIndex<cCategories; nIndex++)
        {
        // check for oldkey type
                for(int i=0;i<NUM_OLDKEYS_SUPPORTED;i++)
                {
                        if(IsEqualGUID(rgcatid[nIndex], g_oldkeyinfo[i].catid))
                        {
                                // we're dealing with oldkey
                                TCHAR szCatKeyOld[_MAX_PATH];
                                StringConvert((LPTSTR)szCatKeyOld,wszclsid,g_oldkeyinfo[i].szDescription);
                                if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCatKeyOld, 0, NULL, 0, KEY_READ, NULL, &hKey, NULL)))
                                {
                                        hr= HRESULT_FROM_WIN32(rc);
                                        break;
                                }
                                RegCloseKey(hKey);
                                break;
                        }
                }
                // Stringize rgcatid[nIndex]
        if (0 == StringFromGUID2(rgcatid[nIndex], wszguid, sizeof(wszguid)/sizeof(TCHAR))) //yq
        {
            hr = E_OUTOFMEMORY;
                        break ; // throw
        }
                TCHAR szCat[_MAX_PATH];
#ifdef UNICODE
                wsprintf(szCat, _T("%s\\%s"), szCatKey, wszguid);
#else
                wsprintf(szCat, _T("%s\\%S"), szCatKey, wszguid);
#endif
        // HKCR\CLSID\{...rclsid...}\Impl/Required Categories\{...rgcatid[nIndex]...} =
        if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCat, 0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL)))
        {
                hr = HRESULT_FROM_WIN32(rc);
            break;
        }
        RegCloseKey(hKey);
        }

    RegCloseKey(hkCatKey);
        return hr;
}

HRESULT CComCat::RegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_IMPLCAT);
}

HRESULT CComCat::UnRegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ],LPCWSTR szImplReq)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories))
        {
                return E_INVALIDARG;
        }

    WCHAR wszclsid[CATID_SIZE];
    WCHAR wszguid[CATID_SIZE];
    TCHAR szCatKey[_MAX_PATH];
    DWORD rc;
    HKEY  hkCatKey;

    // Stringize clsid
    if (0 == StringFromGUID2(rclsid, wszclsid, CATID_SIZE)) //yq
        return E_OUTOFMEMORY;
    StringConvert((LPTSTR)szCatKey,wszclsid,szImplReq);

    // HKCR\CLSID\{...rclsid...}\Impl/Required Categories =
    // RegOpenKeyEx will open the key if it exists
    rc = RegOpenKeyEx(HKEY_CLASSES_ROOT, szCatKey, 0, KEY_ALL_ACCESS, &hkCatKey);
    if (ERROR_SUCCESS != rc)
    {
        return HRESULT_FROM_WIN32(rc);
    }

        ULONG nIndex;
        for (nIndex=0; nIndex<cCategories; nIndex++)
        {
        // check for oldkey type
                for(int i=0;i<NUM_OLDKEYS_SUPPORTED;i++) {
                        if(IsEqualGUID(rgcatid[nIndex], g_oldkeyinfo[i].catid))
                        {
                        // we're deling with oldkey
                                StringConvert((LPTSTR)szCatKey,wszclsid,g_oldkeyinfo[i].szDescription);
                                rc = RegDeleteKey(HKEY_CLASSES_ROOT, szCatKey);
//                              if (ERROR_SUCCESS != rc) //bogus
//                              {
//                                      break;
//                              }
                                break;
                        }
                }
                // Stringize rgcatid[nIndex]
        if (0 == StringFromGUID2(rgcatid[nIndex], wszguid, sizeof(wszguid)/sizeof(TCHAR))) //yq
        {
            return E_OUTOFMEMORY;
        }
                int cch = WideCharToMultiByte(CP_ACP, 0, wszguid, -1, NULL, 0, NULL, NULL);
                char *pszguid = (char *)alloca(cch+1);
//              char *pszguid = new char[cch+1];
//        if (pszguid == NULL)
//                      break;
        WideCharToMultiByte(CP_ACP, 0, wszguid, -1, pszguid, cch+1, NULL, NULL);

        // Delete
        // HKCR\CLSID\{...rclsid...}\Impl/Required Categories\{...rgcatid[nIndex]...}
        rc = RecursiveRegDeleteKey(hkCatKey, pszguid);
//              delete [] pszguid;
        if (rc != ERROR_SUCCESS)
           break;
        }

    RegCloseKey(hkCatKey);
        return HRESULT_FROM_WIN32(rc);
}

HRESULT CComCat::UnRegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_IMPLCAT);
}

HRESULT CComCat::RegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_REQCAT);
}

HRESULT CComCat::UnRegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_REQCAT);
}


// ICatInformation methods
HRESULT CComCat::EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo)
{
        HRESULT hr;
        IEnumCATEGORYINFO  *pcsIEnumCat = NULL;

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidPtrOut(ppenumCategoryInfo, sizeof(*ppenumCategoryInfo)))
        {
                return E_INVALIDARG;
        }
        *ppenumCategoryInfo=NULL;
        CEnumCategories* pEnum=new CEnumCategories;
        if(NULL == pEnum)
                return E_OUTOFMEMORY;

#ifndef _CHICAGO_
	if ((m_fCsFlag) && (!m_pcsICatInfo))
		GetCsCatInfo();
#endif
        // Adding the intialization of CS.-ushaji

        if (m_pcsICatInfo)
        {
                hr = m_pcsICatInfo->EnumCategories(lcid, &pcsIEnumCat);

                if (FAILED(hr))
                {
                        hr = pEnum->Initialize(lcid, NULL);
                }
                else
                {
		   // Make sure SCM can impersonate this
		   hr = CoSetProxyBlanket((IUnknown *)(pcsIEnumCat),
			  RPC_C_AUTHN_WINNT,
			  RPC_C_AUTHZ_NONE, NULL,
			  RPC_C_AUTHN_LEVEL_CONNECT,
			  RPC_C_IMP_LEVEL_DELEGATE,
			  NULL, EOAC_NONE );

                        hr = pEnum->Initialize(lcid, pcsIEnumCat);
                }
        }
        else
        {
                        hr = pEnum->Initialize(lcid, NULL);
        }

        if (FAILED(hr))
                return E_OUTOFMEMORY;
        // Gets the cs enumerators. if it fails even after that, return E_OUTOFMEMORY;

        if (FAILED(pEnum->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenumCategoryInfo)))
        {
                return E_UNEXPECTED;
        }
        return S_OK;
}

HRESULT CComCat::GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rcatid, sizeof(rcatid)))
        {
                return E_INVALIDARG;
        }
        LPOLESTR pCLSID;
        if (FAILED(StringFromCLSID(rcatid, &pCLSID)))
        {
                return E_OUTOFMEMORY;
        }
    if (NULL == ppszDesc)
        return E_INVALIDARG;

        HKEY hKey1, hKey2;
        DWORD dwError;
        dwError=RegOpenKey(HKEY_CLASSES_ROOT, _T("Component Categories"), &hKey1);
        if (dwError!=ERROR_SUCCESS)
        {
                CoTaskMemFree(pCLSID); // gd
                return HRESULT_FROM_WIN32(dwError);
        }

        int cch = WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, NULL, 0, NULL, NULL);
        char *pszCLSID = (char *)alloca(cch+1);
//      char *pszCLSID = new char[cch+1];
//    if (pszCLSID == NULL)
//      {
//              RegCloseKey(hKey1);
//              CoTaskMemFree(pCLSID);
//              return E_OUTOFMEMORY;
//      }
        WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, pszCLSID, cch+1, NULL, NULL);

        dwError=RegOpenKeyA(hKey1, pszCLSID, &hKey2);
//      delete [] pszCLSID;
        if (dwError!=ERROR_SUCCESS)
        {
                HRESULT         hr;
                RegCloseKey(hKey1);
                CoTaskMemFree(pCLSID);

                // if the category is not found locally, search in class store
#ifndef _CHICAGO_
		if ((m_fCsFlag) && (!m_pcsICatInfo))
			GetCsCatInfo();
#endif
                if (m_pcsICatInfo)
                {
                        hr = m_pcsICatInfo->GetCategoryDesc(rcatid, lcid, ppszDesc);
                        if (FAILED(hr))
                        {
                                return CAT_E_CATIDNOEXIST;
                        }
                        else
                                return S_OK;
                }
                else
                        return CAT_E_CATIDNOEXIST;
        }
        RegCloseKey(hKey1);
        CoTaskMemFree(pCLSID);
        HRESULT hRes=CComCat::GetCategoryDesc(hKey2, lcid, ppszDesc, NULL);
        RegCloseKey(hKey2);
        if (FAILED(hRes))
        {
                HRESULT         hr;
                // if this call fails, it gets forwarded to cs and in case of error the old
                // error is returned.

#ifndef _CHICAGO_
		if ((m_fCsFlag) && (!m_pcsICatInfo))
			GetCsCatInfo();
#endif
                if (m_pcsICatInfo)
                {
                        hr = m_pcsICatInfo->GetCategoryDesc(rcatid, lcid, ppszDesc);
                        if (FAILED(hr))
                        {
                                return hRes;
                        }
                        else
                                return S_OK;
                }
                else
                        return hRes;
        }
        return hRes;
}

HRESULT CComCat::EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired, CATID rgcatidReq[], IEnumGUID **ppenumClsid)
{

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if(-1 == cImplemented)
        {
                if(NULL != rgcatidImpl)
                        return E_POINTER;
        }
        else if (!IsValidReadPtrIn(rgcatidImpl, sizeof(rgcatidImpl[0])*cImplemented))
        {
                return E_POINTER;
        }
        if(-1 == cRequired)
        {
                if(NULL != rgcatidReq)
                        return E_POINTER;
        }
        else if (cRequired != 0 && !IsValidReadPtrIn(rgcatidReq, sizeof(rgcatidReq[0])*cRequired))
        {
                return E_POINTER;
        }
        if (!IsValidPtrOut(ppenumClsid, sizeof(*ppenumClsid)))
        {
                return E_INVALIDARG;
        }
        *ppenumClsid=NULL;
        IEnumGUID   *pcsIEnumGuid = NULL;
        HRESULT      hr = S_OK;

        if(0 == cImplemented)   // gd
                return E_INVALIDARG;

#ifndef _CHICAGO_
	if ((m_fCsFlag) && (!m_pcsICatInfo))
		GetCsCatInfo();
#endif

        if (m_pcsICatInfo)
        {
                hr = m_pcsICatInfo->EnumClassesOfCategories(cImplemented, rgcatidImpl,
                                        cRequired, rgcatidReq, &pcsIEnumGuid);
                if (FAILED(hr))
		{
                        pcsIEnumGuid = NULL;
		}
                else
		{
			// Make sure SCM can impersonate this
			hr = CoSetProxyBlanket((IUnknown *)(pcsIEnumGuid),
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_DELEGATE,
                               NULL, EOAC_NONE );
		}			
        }
        else
        {
                pcsIEnumGuid = NULL;
        }

        CEnumClassesOfCategories* pEnum = new CEnumClassesOfCategories;

        if (!pEnum)
        {
                return E_OUTOFMEMORY;
        }

        hr = pEnum->Initialize(cImplemented, rgcatidImpl, cRequired, rgcatidReq, pcsIEnumGuid);

        if(SUCCEEDED(hr))
        {
                hr = pEnum->QueryInterface(IID_IEnumGUID, (void**) ppenumClsid);
        }

        if(FAILED(hr))
        {
                delete pEnum;
        }

        return hr;
}

HRESULT CComCat::IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ])
{
        HRESULT   hr, hr1;

        if(0 == cImplemented) // gd
        {
                return E_INVALIDARG;
        }

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (-1 == cImplemented)
        {
                if(rgcatidImpl != NULL)
                        return E_POINTER;
        }
        else if(!IsValidReadPtrIn(rgcatidImpl, sizeof(rgcatidImpl[0])*cImplemented))
        {
                return E_POINTER;
        }
        if (-1 == cRequired)
        {
                if(rgcatidReq != NULL)
                        return E_POINTER;
        }
        else if(!IsValidReadPtrIn(rgcatidReq, sizeof(rgcatidReq[0])*cRequired))
        {
                return E_POINTER;
        }
        WCHAR wszCLSID[CATID_SIZE];
        if(0 == StringFromGUID2(rclsid, wszCLSID, CATID_SIZE))  //yq
        {
                return E_OUTOFMEMORY;
        }
        hr = IsClassOfCategoriesEx(wszCLSID, cImplemented, rgcatidImpl, cRequired, rgcatidReq);
        // if the local call fails then it is sent to the class store.
        // think this has to be changed to call only if class is not available
        // locally.


        if ((FAILED(hr)) || (hr == S_FALSE))
        {
#ifndef _CHICAGO_
		if ((m_fCsFlag) && (!m_pcsICatInfo))
			GetCsCatInfo();
#endif
                if (m_pcsICatInfo)
                {
                        hr1 = m_pcsICatInfo->IsClassOfCategories(rclsid, cImplemented,
                                                        rgcatidImpl, cRequired, rgcatidReq);
                        if (FAILED(hr1))
                                return hr;
                        return hr1;
                }
        }
        return hr;
}


HRESULT CComCat::IsClassOfCategoriesEx(WCHAR *wszCLSID, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ])
{
        DWORD dwError;
        WCHAR wszKey[MAX_PATH];
        CHAR szKey[MAX_PATH];
        HRESULT hr = S_OK;
        HKEY hKeyCLSID;

        wcscpy(wszKey, WSZ_CLSID);
        wcscat(wszKey, L"\\");
        wcscat(wszKey, wszCLSID);
#ifdef UNICODE
        dwError=RegOpenKey(HKEY_CLASSES_ROOT, wszKey, &hKeyCLSID);
#else
        WideCharToMultiByte(CP_ACP, 0, wszKey, -1, szKey, sizeof(szKey), NULL, NULL);
        dwError=RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKeyCLSID);
#endif
        if (ERROR_SUCCESS != dwError)
                return HRESULT_FROM_WIN32(dwError);
//      wcscat(wszKey, L"\\");

        if ((cImplemented>0) && (cImplemented != -1) )
        {
                BOOL bImplemented = FALSE;
                HKEY hKeyImpl;
                wcscpy(wszKey, WSZ_IMPLCAT);
                wcscat(wszKey, L"\\");

                // loop through rgcatidImpl[] and try to open key
                DWORD dwCatImpl;
                for (dwCatImpl=0; dwCatImpl<cImplemented; dwCatImpl++)
                {
                        WCHAR wszCat[MAX_PATH+1];
                        StringFromGUID2(rgcatidImpl[dwCatImpl], wszCat, sizeof(wszCat)/sizeof(TCHAR));
                        wcscpy(&wszKey[KEY_STRING_IMPL_CHARS], wszCat);

#ifdef UNICODE
                        dwError=RegOpenKey(hKeyCLSID, wszKey, &hKeyImpl);
#else
                        CHAR szKey[MAX_PATH+1];
                        WideCharToMultiByte(CP_ACP, 0, wszKey, -1, szKey, sizeof(szKey), NULL, NULL);
                        dwError=RegOpenKey(hKeyCLSID, szKey, &hKeyImpl);
#endif
                        if(ERROR_SUCCESS == dwError)
                        {
                                        // we got what we came for, blow
                                        RegCloseKey(hKeyImpl);
                                        bImplemented=TRUE;
                                        break;
                        }
                }
                if (!bImplemented)
                {
            // Check for old keys    gd
                        DWORD dwCatImpl;

                        for (dwCatImpl=0; dwCatImpl<cImplemented; dwCatImpl++)
                        {
                                // loop through oldkey hardcoded info and see if match
                                DWORD dwNumOldKeys;
                                for(dwNumOldKeys = 0;dwNumOldKeys<NUM_OLDKEYS_SUPPORTED;dwNumOldKeys++)
                                {
                                        if(IsEqualGUID(rgcatidImpl[dwCatImpl], g_oldkeyinfo[dwNumOldKeys].catid))
                                        {
                                                // We have a match, look for name under HKCR\CLSID\{clsid}\
//                                              wcsncpy(wszKeyOld, wszKey, cnt-1);
//                                              wcscat(wszKeyOld, L"\\");
                                                wcscpy(wszKey, g_oldkeyinfo[dwNumOldKeys].szDescription);
#ifdef UNICODE
                                                dwError = RegOpenKey(hKeyCLSID, wszKey, &hKeyImpl);
#else
                                                CHAR szKey[MAX_PATH+1];
                                                WideCharToMultiByte(CP_ACP, 0, wszKey, -1, szKey, sizeof(szKey), NULL, NULL);
                                                dwError = RegOpenKey(hKeyCLSID, szKey, &hKeyImpl);
#endif
                                                if(ERROR_SUCCESS == dwError)
                                                {
                                                        // we found an old key
                                                        RegCloseKey(hKeyImpl);
                                                        bImplemented=TRUE;
                                                        break;
                                                }
                                        }
                                }
                        }
            if (!bImplemented)
            {
                                hr = S_FALSE;
                                goto BAILOUT;
//                              return S_FALSE;
            }
                }
        }
        if (cRequired != -1)
        {
                HKEY hKeyReq;
                BOOL bRequired=FALSE;
                wcscpy(wszKey, WSZ_REQCAT);
                wcscpy(&wszKey[KEY_STRING_REQ_CHARS-1], L"\\");
                //wcscat(wszKey, L"\\");
#ifdef UNICODE
                dwError=RegOpenKey(hKeyCLSID, wszKey, &hKeyReq);
#else
                CHAR szKey[MAX_PATH+1];
                WideCharToMultiByte(CP_ACP, 0, wszKey, -1, szKey, sizeof(szKey), NULL, NULL);
                dwError=RegOpenKey(hKeyCLSID, szKey, &hKeyReq);
#endif
                if(dwError != ERROR_SUCCESS)
                {
//                      return S_OK;
                        hr = S_OK;
                        goto BAILOUT;
                }
                else
                        RegCloseKey(hKeyReq);

                // Get catid Enum
                IEnumCATID * ppenumCatid;
                CLSID clsid;
                if (GUIDFromString(wszCLSID, &clsid))
                    hr = EnumCategoriesOfClass(clsid, _T("Required Categories"), FALSE, &ppenumCatid);
		else
                    hr = E_FAIL;
                if(FAILED(hr))
                {
                    goto BAILOUT;
                }

                DWORD celtFetched;
                CATID guid[1];
                DWORD dwCatReq;
                // loop through Enum req catids and see if passed in with rgcatidReq
                do
                {
                        bRequired = FALSE;
                        hr = ppenumCatid->Next(1, guid, &celtFetched);
                        if(hr != S_OK)
                        {
                                bRequired = TRUE;
                                break;
                        }
                        // Find match in rgcatidReq
                        for(dwCatReq=0;dwCatReq<cRequired;dwCatReq++)
                        {
                                if(IsEqualGUID(guid[0], rgcatidReq[dwCatReq]))
                                {
                                        bRequired = TRUE;
                                        break;
                                }
                        }
                }while((hr ==S_OK) && bRequired);
                ppenumCatid->Release();
                if (!bRequired)
                {
//                      return S_FALSE;
                        hr = S_FALSE;
                        goto BAILOUT;
                }
        }
        hr = S_OK;
BAILOUT:
        RegCloseKey(hKeyCLSID);
        return hr;
}


HRESULT CComCat::EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
        HRESULT hr, hr1;
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidPtrOut(ppenumCatid, sizeof(*ppenumCatid)))
        {
                return E_INVALIDARG;
        }

        hr = EnumCategoriesOfClass(rclsid, _T("Implemented Categories"), FALSE, ppenumCatid);


        if (FAILED(hr))
        {
#ifndef _CHICAGO_
		if ((m_fCsFlag) && (!m_pcsICatInfo))
			GetCsCatInfo();
#endif
                if (m_pcsICatInfo)
                {
                        hr1 = m_pcsICatInfo->EnumImplCategoriesOfClass(rclsid, ppenumCatid);
                        if (FAILED(hr1))
                                return hr;
                        else
                        {
		            // Make sure SCM can impersonate	
				hr = CoSetProxyBlanket((IUnknown *)(*ppenumCatid),
                	        	        RPC_C_AUTHN_WINNT,
                        	       		RPC_C_AUTHZ_NONE, NULL,
	                               		RPC_C_AUTHN_LEVEL_CONNECT,
        	                       		RPC_C_IMP_LEVEL_DELEGATE,
                	               		NULL, EOAC_NONE );
                        	return hr1;
			}
                }
        }
        return hr;
}

HRESULT CComCat::EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
        HRESULT hr, hr1;

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidPtrOut(ppenumCatid, sizeof(*ppenumCatid)))
        {
                return E_INVALIDARG;
        }
        hr = EnumCategoriesOfClass(rclsid, _T("Required Categories"), FALSE, ppenumCatid);
        // if the class is not found locally.

        if (FAILED(hr))
        {
#ifndef _CHICAGO_
		if ((m_fCsFlag) && (!m_pcsICatInfo))
			GetCsCatInfo();
#endif
                if (m_pcsICatInfo)
                {
                        hr1 = m_pcsICatInfo->EnumReqCategoriesOfClass(rclsid, ppenumCatid);
                    if (FAILED(hr1))
                            return hr;
                    else
                    {
		            // Make sure SCM can impersonate	
			hr = CoSetProxyBlanket((IUnknown *)(*ppenumCatid),
                	        	        RPC_C_AUTHN_WINNT,
                        	       		RPC_C_AUTHZ_NONE, NULL,
	                               		RPC_C_AUTHN_LEVEL_CONNECT,
        	                       		RPC_C_IMP_LEVEL_DELEGATE,
                	               		NULL, EOAC_NONE );
                        return hr1;
		    }
                }
        }
        return hr;
}

HRESULT CComCat::EnumCategoriesOfClass(REFCLSID rclsid, LPCTSTR lpszSubKey, BOOL bMapOldKeys, IEnumGUID **ppenumCatid)
{
        HKEY hKey, hKey1;

        hKey = NULL; 
        hKey1 = NULL;

        HRESULT hRes=GetKey(rclsid, &hKey1);
        if(FAILED(hRes))
            return hRes;

        DWORD dwError;
        dwError=RegOpenKey(hKey1, lpszSubKey, &hKey);
        if (dwError!=ERROR_SUCCESS)
        {
            RegCloseKey(hKey1);
            return HRESULT_FROM_WIN32(dwError);
        }
        RegCloseKey(hKey1);

        *ppenumCatid=NULL;
        CEnumCategoriesOfClass* pEnum=NULL;
        pEnum=new CEnumCategoriesOfClass;
        if (!pEnum || FAILED(pEnum->Initialize(hKey, bMapOldKeys)))
        {
            return E_OUTOFMEMORY;
        }

        if (FAILED(pEnum->QueryInterface(IID_IEnumGUID, (void**) ppenumCatid)))
        {
            delete pEnum;
            return E_UNEXPECTED;
        }
        return S_OK;
}

HRESULT CComCat::GetKey(REFCLSID rclsid, HKEY* phKey)
{
        LPOLESTR pCLSID;
        if (FAILED(StringFromCLSID(rclsid, &pCLSID)))
        {
            return E_OUTOFMEMORY;
        }

        HKEY hKey, hKey1;
        DWORD dwError;
        dwError=RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey);
        if (dwError!=ERROR_SUCCESS)
        {
            CoTaskMemFree(pCLSID); // gd
            return HRESULT_FROM_WIN32(dwError);
        }

        int cch = WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, NULL, 0, NULL, NULL);
        char *pszCLSID = (char *)alloca(cch+1);

        WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, pszCLSID, cch+1, NULL, NULL);

        dwError=RegOpenKeyA(hKey, pszCLSID, &hKey1);
        if (dwError!=ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            CoTaskMemFree(pCLSID);
            return HRESULT_FROM_WIN32(dwError);
        }

        RegCloseKey(hKey);
        CoTaskMemFree(pCLSID);
        *phKey=hKey1;
        return S_OK;
}


HRESULT CComCat::ConvertStringToLCID(LCID* newlcid,LPTSTR szLCID)
{
        LPWSTR  temp = NULL;
        WCHAR wszLCID[30];
#ifdef _UNICODE
                *newlcid = wcstoul(szLCID, &temp, 16);
#else
                MultiByteToWideChar(CP_ACP, 0, szLCID, -1, wszLCID, 40);
                *newlcid = wcstoul(wszLCID, &temp, 16);
#endif
        return S_OK;

}
// Will attempt to use locale specified
// if not found tries default sublang
// if not found tries any matching pri lang
// if not found tries default user locale
// if not found tries default system locale

//  ppszDesc returns Desc found
//  plcid returns lcid found if not NULL
HRESULT CComCat::GetCategoryDesc(HKEY hKey, LCID lcid, LPOLESTR *ppszDesc, LCID *plcid)
{
        TCHAR szLCID[30];
        DWORD dwError;
        LCID newlcid;
        WORD plgid;
        DWORD cb=0;
        DWORD dwNumValues;
        BOOL bSysDefault = FALSE;
        BOOL bUserDefault = FALSE;
        DWORD dwIndex = 0;
        DWORD dwSizeNameBuf = 16;


        newlcid = lcid;
        // How many values?
        dwError = RegQueryInfoKey (
                hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                &dwNumValues,   // address of buffer for number of value entries
                NULL, NULL, NULL, NULL);
        if (dwError)
                {
                        return CAT_E_NODESCRIPTION;
                }
        if(0 == dwNumValues)
                return CAT_E_NODESCRIPTION;

        // if only one, return it
        if(1 == dwNumValues)
        {
                dwError = RegEnumValue(hKey, 0,
                        szLCID,&dwSizeNameBuf,NULL,NULL,NULL,&cb);
                ConvertStringToLCID(&newlcid,(LPTSTR)szLCID);
                goto process;
        }
        wsprintf(szLCID,_T("%X"),lcid);
        // Try locale passed in
        dwError = RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        if(dwError)
        {
                // Get default sublang local
                plgid = PRIMARYLANGID((WORD)lcid);
                newlcid = MAKELCID(MAKELANGID(plgid, SUBLANG_DEFAULT), SORT_DEFAULT);
                wsprintf(szLCID,_T("%X"),newlcid);
                dwError=RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        }
        else
                goto process;

        if (dwError)
        {
                // Enum through to find at least same primary lang
                do{
                        dwSizeNameBuf = 16;
                        dwError = RegEnumValue(hKey, dwIndex,
                                szLCID,&dwSizeNameBuf,NULL,NULL,NULL,&cb);
                        if(ERROR_SUCCESS != dwError)
                                break;
                        ConvertStringToLCID(&newlcid,szLCID);
                        WORD w = PRIMARYLANGID(LANGIDFROMLCID(newlcid));
                        if(w == plgid)
                        {
                                break;
                        }
                        dwIndex++;
                }while(ERROR_NO_MORE_ITEMS != dwError);
        }
        else
                goto process;

        if (dwError)
        {
                // Get User Default
                newlcid = GetUserDefaultLCID();
                wsprintf(szLCID,_T("%X"),newlcid);
                dwError=RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        }
        else
                goto process;

        if (dwError)
        {
                // Get System Default
                newlcid = GetSystemDefaultLCID();
                wsprintf(szLCID,_T("%X"),newlcid);
                dwError=RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        }
        else
                goto process;

        // Get first enum
        if (dwError)
        {
                dwError = RegEnumValue(hKey, 0,
                        szLCID, &dwSizeNameBuf, NULL, NULL, NULL, &cb);

        }
        else
                goto process;

        if (dwError)
        {
                return CAT_E_NODESCRIPTION;
        }
        ConvertStringToLCID(&newlcid,szLCID);   // fix #70030

process:
        *ppszDesc=(LPOLESTR) CoTaskMemAlloc(cb*2);
        if (NULL==*ppszDesc)
        {
                return E_OUTOFMEMORY;
        }

#ifdef UNICODE
                dwError=RegQueryValueExW(hKey, szLCID, NULL, NULL, (LPBYTE)*ppszDesc, &cb);
#else
                LPSTR pTemp=(LPSTR) LocalAlloc(LPTR,cb);
                if (NULL==pTemp)
                {
                        CoTaskMemFree(*ppszDesc);
                        return E_OUTOFMEMORY;
                }
                dwError=RegQueryValueExA(hKey, szLCID, NULL, NULL, (LPBYTE)pTemp, &cb);
                MultiByteToWideChar(CP_ACP, 0, pTemp, -1, *ppszDesc, cb);
//              CoTaskMemFree(pTemp); //gd
                LocalFree(pTemp);
#endif

        if (dwError)
        {
                CoTaskMemFree(*ppszDesc);
                *ppszDesc=NULL;
                return CAT_E_NODESCRIPTION;
        }
        if(plcid)
                *plcid = newlcid;
        return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetCsCatInfo
//
//  Synopsis:   Returns an instantiated ICatInformation interface pointer
//              to the Class Store Co-ordinator object.
//
//
//  Returns:    S_OK - Got a pointer Successfully
//              E_FAIL
//
//--------------------------------------------------------------------------

#ifndef _CHICAGO_
HRESULT CComCat::GetCsCatInfo()
{
        HRESULT hr = S_OK;
        CsCatInfo  *pCsCatInfObj = NULL;

        if (m_pcsICatInfo)
            return hr;

        pCsCatInfObj = new CsCatInfo();

        if (!pCsCatInfObj)
        {
            return E_OUTOFMEMORY;
        }

        EnterCriticalSection(&m_csCatInfoInit);

        if (!m_pcsICatInfo)
            hr = pCsCatInfObj->QueryInterface(IID_ICatInformation,
                                             (void **)&m_pcsICatInfo);
        pCsCatInfObj->Release();

        LeaveCriticalSection(&m_csCatInfoInit);

        return hr;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\catenum.cpp ===
#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <malloc.h>
#include <ole2sp.h>

#include "catenum.h"

#include "catobj.h"

extern const WCHAR *WSZ_CLSID;
extern const TCHAR *SZ_COMCAT;

// CEnumAllCatInfo:
// IUnknown methods
HRESULT CEnumCategories::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCATEGORYINFO)
    {
        *ppObject=(IEnumCATEGORYINFO*) this;
        AddRef();
        return S_OK;
    }

    *ppObject = NULL;
    return E_NOINTERFACE;
}

ULONG CEnumCategories::AddRef()
{
    return InterlockedIncrement((long*) &m_dwRefCount);
}

ULONG CEnumCategories::Release()
{
    ULONG dwRefCount= InterlockedDecrement((long*) &m_dwRefCount);
    if (dwRefCount==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATEGORYINFO methods
HRESULT CEnumCategories::Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched) {

        if (pceltFetched)
        {
                *pceltFetched=0;
        }
        else    // pceltFetched can be NULL when celt == 1) yq
        {
            if (celt > 1)
                return E_INVALIDARG;
        }

        if (!m_hKey)
        {
                return S_FALSE;
        }
        HRESULT hr;
        DWORD dwCount, dwError, dwIndex = 0;
        char szCatID[MAX_PATH+1];
        HKEY hKeyCat = NULL;

        dwCount = 0;
        if (!m_fromcs)
        {
                for (dwCount=0; dwCount<celt; dwCount++)
                {
                        dwError=RegEnumKeyA(m_hKey, m_dwIndex, szCatID, sizeof(szCatID));
                        if (dwError && dwError!=ERROR_NO_MORE_ITEMS)
                        {
                                // need to free strings?
                                return HRESULT_FROM_WIN32(dwError);
                        }
                        if (dwError ==ERROR_NO_MORE_ITEMS)
                        {
                        //----------------------forwarding to class store.
                                m_fromcs = 1;
                                break;
                        }
                        dwError=RegOpenKeyA(m_hKey, szCatID, &hKeyCat);
                        if (dwError)
                        {
                                // need to free strings?
                                return HRESULT_FROM_WIN32(dwError);
                        }
                        WCHAR wszCatID[MAX_PATH+1];
                        MultiByteToWideChar(CP_ACP, 0, szCatID, -1, wszCatID, MAX_PATH+1);

                        if (FALSE == GUIDFromString(wszCatID, &rgelt[dwCount].catid))
                        {
                                RegCloseKey(hKeyCat);
                                // need to free strings?
                                return E_OUTOFMEMORY;
                        }
                        LCID newlcid;
                        LPOLESTR pszDesc = NULL;
                        hr = CComCat::GetCategoryDesc(hKeyCat, m_lcid, &pszDesc, &newlcid);
                        if(SUCCEEDED(hr))
                                wcscpy(rgelt[dwCount].szDescription, pszDesc);
                        else
                                rgelt[dwCount].szDescription[0] = _T('\0'); //fix #69883
                        if(pszDesc)
                                CoTaskMemFree(pszDesc);
                        RegCloseKey(hKeyCat);
                        if (pceltFetched)
                        {
                                (*pceltFetched)++; //gd
                        }
                        m_dwIndex++;
                        rgelt[dwCount].lcid = newlcid; // return locale actually found
                }
        }
        // class store failure is not shown to the outside implementation.
        if (m_fromcs) {
                HRESULT hr;
                ULONG   count;

                if (!m_pcsIEnumCat)
                        return S_FALSE;
                hr = m_pcsIEnumCat->Next(celt-dwCount, rgelt+dwCount, &count);
                if (pceltFetched)
                        *pceltFetched += count;
                if ((FAILED(hr)) || (hr == S_FALSE)) {
                        return S_FALSE;
                }
        }
        return S_OK;
}

HRESULT CEnumCategories::Skip(ULONG celt) {
        //m_dwIndex+=celt;
        DWORD dwCount, dwError;
        char szCatID[MAX_PATH];
        dwCount = 0;
        if (!m_fromcs)
        {
                for (dwCount=0; dwCount<celt; dwCount++)
                {
                        dwError = RegEnumKeyA(m_hKey, m_dwIndex, szCatID, sizeof(szCatID));
                        if (dwError)
                        {
                                        m_fromcs = 1;
                                        break;
                        }
                        else
                        {
                                ++m_dwIndex;
                        }
                }
        }
        if (m_fromcs) {
                HRESULT hr;
                if (!m_pcsIEnumCat)
                        return S_FALSE;
                hr = m_pcsIEnumCat->Skip(celt-dwCount);
                if (FAILED(hr) || (hr == S_FALSE)) {
                        return S_FALSE;
                }
        }
        return S_OK;
}

HRESULT CEnumCategories::Reset(void) {
        m_dwIndex=0;
        m_fromcs = 0;
        if (m_pcsIEnumCat)
                m_pcsIEnumCat->Reset();
        return S_OK;
}

HRESULT CEnumCategories::Clone(IEnumCATEGORYINFO **ppenum)
{
        CEnumCategories*                pClone=NULL;
        IEnumCATEGORYINFO*              pcsIEnumCat;
        HRESULT                                 hr;

        pClone=new CEnumCategories();

        if (!pClone)
        {
                return E_OUTOFMEMORY;
        }
        if (m_pcsIEnumCat)
                if (FAILED(hr = m_pcsIEnumCat->Clone(&pcsIEnumCat)))
		{
                   pcsIEnumCat = NULL;
                }
		else
		{
		   // Make sure SCM can impersonate this
		   hr = CoSetProxyBlanket((IUnknown *)(pcsIEnumCat),
			  RPC_C_AUTHN_WINNT,
			  RPC_C_AUTHZ_NONE, NULL,
			  RPC_C_AUTHN_LEVEL_CONNECT,
			  RPC_C_IMP_LEVEL_DELEGATE,
			  NULL, EOAC_NONE );
		}
        else
                pcsIEnumCat = NULL;

        if (FAILED(pClone->Initialize(m_lcid, pcsIEnumCat)))
        {
                delete pClone;
                return E_UNEXPECTED;
        }

        pClone->m_dwIndex=m_dwIndex;
        pClone->m_fromcs = m_fromcs;

        if (SUCCEEDED(pClone->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenum)))
        {
                return S_OK;
        }
        delete pClone;
        return E_UNEXPECTED;
}

CEnumCategories::CEnumCategories()
{
        m_dwRefCount=0;
        m_hKey=NULL;
        m_dwIndex=0;
//      m_szlcid[0]=0;
        m_lcid=0;
        m_pcsIEnumCat = NULL;
        m_fromcs = 0;
}

HRESULT CEnumCategories::Initialize(LCID lcid, IEnumCATEGORYINFO *pcsEnumCat)
{
        m_lcid=lcid;
//      wsprintfA(m_szlcid, "%X", lcid);
        DWORD dwError;
        dwError=RegOpenKey(HKEY_CLASSES_ROOT, _T("Component Categories"), &m_hKey);
        if (dwError)
        {
                m_hKey=NULL;
        }
        m_dwIndex=0;
        m_pcsIEnumCat = pcsEnumCat;
        return S_OK;
}

CEnumCategories::~CEnumCategories()
{
        if (m_hKey)
        {
                RegCloseKey(m_hKey);
                m_hKey=NULL;
        }
        if (m_pcsIEnumCat)
                m_pcsIEnumCat->Release();
}

// CEnumCategoriesOfClass:
// IUnknown methods
HRESULT CEnumCategoriesOfClass::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCATID)
    {
        *ppObject=(IEnumCATID*) this;
        AddRef();
        return S_OK;
    }
    *ppObject = NULL;
    return E_NOINTERFACE;
}

ULONG CEnumCategoriesOfClass::AddRef()
{
    return InterlockedIncrement((long*) &m_dwRefCount);
}

ULONG CEnumCategoriesOfClass::Release()
{
    ULONG dwRefCount= InterlockedDecrement((long*) &m_dwRefCount);
    if (dwRefCount==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATID methods
HRESULT CEnumCategoriesOfClass::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
        if (pceltFetched)
        {
                *pceltFetched=0;
        }
        else    // pceltFetched can be NULL when celt = 1) yq
        {
            if (celt > 1)
                return E_INVALIDARG;
        }

        if (!m_hKey)
        {
                return S_FALSE;
        }

        DWORD dwCount;
        DWORD dwError;
        char szCatID[40];
        WCHAR uszCatID[40];

        for     (dwCount=0; dwCount<celt; )
        {
                dwError=RegEnumKeyA(m_hKey, m_dwIndex, szCatID, 40);
                if (dwError && dwError!=ERROR_NO_MORE_ITEMS)
                {
                        return HRESULT_FROM_WIN32(dwError);
                }
                if (dwError==ERROR_NO_MORE_ITEMS)
                {
                    if (!m_bMapOldKeys)
            {
                return S_FALSE;
            }
            if (!m_hKeyCats)
            {
                                if (!RegOpenKey(HKEY_CLASSES_ROOT, SZ_COMCAT, &m_hKeyCats))
                                {
                    return S_FALSE;
                }
            }
            dwError=RegEnumKeyA(m_hKeyCats, m_dwOldKeyIndex, szCatID, sizeof(szCatID)/sizeof(TCHAR));
            if (dwError==ERROR_NO_MORE_ITEMS)
            {
                return S_FALSE;
            }
            if (dwError)
            {
                return HRESULT_FROM_WIN32(dwError);
            }
            m_dwOldKeyIndex++;
                }
                MultiByteToWideChar(CP_ACP, 0, szCatID, -1, uszCatID, 40);
                if (GUIDFromString(uszCatID, &rgelt[dwCount]))
                {
                        if (pceltFetched)
                        {
                                (*pceltFetched)++; //gd
                        }
                        dwCount++;
                }
                m_dwIndex++;
        }
        return S_OK;
}

HRESULT CEnumCategoriesOfClass::Skip(ULONG celt)
{
        CATID* pcatid=(CATID*) CoTaskMemAlloc(sizeof(CATID)*celt);
        if (!pcatid)
        {
                return E_OUTOFMEMORY;
        }
        ULONG nFetched=0;
        Next(celt, pcatid, &nFetched);
        CoTaskMemFree(pcatid);
        if (nFetched<celt)
        {
                // redundant MH/GD 8/2/96: CoTaskMemFree(pcatid); // gd
                return S_FALSE;
        }
        return S_OK;
}

HRESULT CEnumCategoriesOfClass::Reset(void)
{
        m_dwIndex=0;
        m_dwOldKeyIndex=0;
        return S_OK;
}

HRESULT CEnumCategoriesOfClass::Clone(IEnumGUID **ppenum)
{
        CEnumCategoriesOfClass* pClone=NULL;
        pClone=new CEnumCategoriesOfClass();

        if (!pClone)
        {
                return E_OUTOFMEMORY;
        }
        if (FAILED(pClone->Initialize(m_hKey, m_bMapOldKeys)))
        {
                delete pClone;
                return E_UNEXPECTED;
        }
        pClone->m_dwIndex=m_dwIndex;
        pClone->m_dwOldKeyIndex=m_dwOldKeyIndex;
        pClone->m_hKeyCats=m_hKeyCats;
        pClone->m_pCloned=(IUnknown*) this;
        pClone->m_pCloned->AddRef(); // yq: missing code here.
        if (SUCCEEDED(pClone->QueryInterface(IID_IEnumGUID, (void**) ppenum)))
        {
                return S_OK;
        }
                delete pClone;

        return E_UNEXPECTED;
}


CEnumCategoriesOfClass::CEnumCategoriesOfClass()
{
        m_dwRefCount=0;

        m_hKey=NULL;
    m_hKeyCats=NULL;
        m_bMapOldKeys=FALSE;
    m_dwIndex=0;
    m_dwOldKeyIndex=0;
        m_pCloned=NULL;
}

HRESULT CEnumCategoriesOfClass::Initialize(HKEY hKey, BOOL bMapOldKeys)
{
        m_hKey=hKey;
        m_bMapOldKeys=bMapOldKeys;
        return S_OK;
}

CEnumCategoriesOfClass::~CEnumCategoriesOfClass()
{
        if (m_pCloned)
        {
                IUnknown* pUnk=m_pCloned;
                m_pCloned=NULL;
                pUnk->Release();
        }
        else
    {
        if (m_hKey)
            {
                    RegCloseKey(m_hKey);
                    m_hKey=NULL;
            }
        if (m_hKeyCats)
            {
                    RegCloseKey(m_hKeyCats);
                    m_hKeyCats=NULL;
            }
    }
}

// CEnumClassesOfCategories:
// IUnknown methods
HRESULT CEnumClassesOfCategories::QueryInterface(REFIID riid, void** ppObject)
{
        if (riid==IID_IUnknown || riid==IID_IEnumCLSID)
        {
                *ppObject=(IEnumCLSID*) this;
        }
        else
        {
                return E_NOINTERFACE;
        }
        AddRef();
        return S_OK;
}

ULONG CEnumClassesOfCategories::AddRef()
{
    return InterlockedIncrement((long*) &m_dwRefCount);
}

ULONG CEnumClassesOfCategories::Release()
{
    ULONG dwRefCount= InterlockedDecrement((long*) &m_dwRefCount);
    if (dwRefCount==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumGUID methods
HRESULT CEnumClassesOfCategories::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
        if (pceltFetched)
        {
                *pceltFetched=0;
        }
        else    // pceltFetched can be NULL when celt = 1) yq
        {
            if (celt > 1)
                return E_INVALIDARG;
        }

        if (!m_hClassKey)
        {
                return S_FALSE;
        }
        DWORD dwCount;
        DWORD dwError;
        TCHAR szCLSID[MAX_PATH+1];
	HRESULT hRes=S_OK;

        szCLSID[0]= 0;
	dwCount = 0;
        if (!m_fromcs)
        {
                for (dwCount=0; dwCount<celt; )
                {
                        dwError=RegEnumKey(m_hClassKey, m_dwIndex, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));
                        if (dwError==ERROR_NO_MORE_ITEMS)
                        {
                                //--------------------------forwarding to class store
                                m_fromcs = 1;
                                break;
                        }

                        if (dwError)
                        {
                                // need to free strings?
                                return HRESULT_FROM_WIN32(dwError);
                        }
#ifdef UNICODE
                        hRes=CComCat::IsClassOfCategoriesEx(szCLSID, m_cImplemented, m_rgcatidImpl, m_cRequired, m_rgcatidReq);
#else
                        WCHAR wszCLSID[MAX_PATH+1];
                        MultiByteToWideChar(CP_ACP, 0, szCLSID, -1, wszCLSID, sizeof(wszCLSID)/sizeof(wszCLSID[0]));
                        hRes=CComCat::IsClassOfCategoriesEx(wszCLSID, m_cImplemented, m_rgcatidImpl, m_cRequired, m_rgcatidReq);
#endif
                        if (FAILED(hRes))
                        {
                                // need to free strings?
                                return hRes;
                        }

                        if (hRes==S_OK)
                        {
                                CLSID clsid;
#ifndef UNICODE
                                WCHAR uszCLSID[MAX_PATH+1];
                                MultiByteToWideChar(CP_ACP, 0, szCLSID, -1, uszCLSID, MAX_PATH+1);

                                if (GUIDFromString(uszCLSID, &clsid))
#else
                                if (GUIDFromString(szCLSID, &clsid))
#endif
                                {
                                        rgelt[dwCount]=clsid;
                                        if (pceltFetched)
                                        {
                                                (*pceltFetched)++;  //gd
                                        }
                                        dwCount++;
                                }
                        }
                        m_dwIndex++;
                }
        }
        if (m_fromcs) {
                ULONG  count;
                HRESULT  hr;

                if (!m_pcsIEnumClsid)
                        return S_FALSE;
                hr = m_pcsIEnumClsid->Next(celt-dwCount, rgelt+dwCount, &count);
                if (pceltFetched)
                        *pceltFetched += count;
                if ((FAILED(hr)) || (hr == S_FALSE)) {
                        return S_FALSE;
                }
        }
        return S_OK;
}

HRESULT CEnumClassesOfCategories::Skip(ULONG celt)
{
        HRESULT hr;
        CATID* pDummy=(CATID*) CoTaskMemAlloc(sizeof(CATID)*celt);
        if (!pDummy)
        {
                return E_OUTOFMEMORY;
        }
        ULONG nFetched=0;
        hr = Next(celt, pDummy, &nFetched);
        CoTaskMemFree(pDummy); // gd
        return hr;
}

HRESULT CEnumClassesOfCategories::Reset(void)
{
        m_dwIndex=0;
        m_fromcs = 0;
        if (m_pcsIEnumClsid)
                m_pcsIEnumClsid->Reset();
        return S_OK;
}

HRESULT CEnumClassesOfCategories::Clone(IEnumGUID **ppenum)
{
        CEnumClassesOfCategories* pClone=NULL;
	HRESULT         hr;
        pClone=new CEnumClassesOfCategories();

        if (!pClone)
        {
                return E_OUTOFMEMORY;
        }
        if (m_pcsIEnumClsid)
	{
            if (FAILED(m_pcsIEnumClsid->Clone(&(pClone->m_pcsIEnumClsid))))
                pClone->m_pcsIEnumClsid = NULL;
	    else
	       // Make sure SCM can impersonate this
	       hr = CoSetProxyBlanket((IUnknown *)(pClone->m_pcsIEnumClsid),
		      RPC_C_AUTHN_WINNT,
		      RPC_C_AUTHZ_NONE, NULL,
		      RPC_C_AUTHN_LEVEL_CONNECT,
		      RPC_C_IMP_LEVEL_DELEGATE,
		      NULL, EOAC_NONE );
	}
        else
                pClone->m_pcsIEnumClsid = NULL;

        pClone->m_cImplemented=m_cImplemented;
        pClone->m_cRequired=m_cRequired;
        pClone->m_rgcatidImpl=m_rgcatidImpl;
        pClone->m_rgcatidReq=m_rgcatidReq;
        pClone->m_hClassKey = m_hClassKey; // gd
        pClone->m_dwIndex=m_dwIndex;
        pClone->m_pCloned=(IUnknown*) this;
        pClone->m_pCloned->AddRef(); // gd

        if (SUCCEEDED(pClone->QueryInterface(IID_IEnumGUID, (void**) ppenum)))
        {
                return S_OK;
        }
        delete pClone;
        return E_UNEXPECTED;
}

CEnumClassesOfCategories::CEnumClassesOfCategories()
{
        m_dwRefCount=NULL;
        m_hClassKey=NULL;
        m_dwIndex=0;

        m_cImplemented=0;
        m_rgcatidImpl=NULL;
        m_cRequired=0;
        m_rgcatidReq=NULL;
        m_pcsIEnumClsid = NULL;
        m_pCloned=NULL;
        m_fromcs = 0;
}

HRESULT CEnumClassesOfCategories::Initialize(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired,
                                                                                         CATID rgcatidReq[], IEnumGUID *pcsIEnumClsid)
{
#ifdef UNICODE
        if (RegOpenKey(HKEY_CLASSES_ROOT, WSZ_CLSID, &m_hClassKey))
#else
        CHAR szClsid[8];
        WideCharToMultiByte(CP_ACP, 0, WSZ_CLSID, -1, szClsid, sizeof(szClsid), NULL, NULL);
        if (RegOpenKey(HKEY_CLASSES_ROOT, szClsid, &m_hClassKey))
#endif
    {
        return E_UNEXPECTED;
    }

//      m_rgcatidImpl=(CATID*) CoTaskMemAlloc((cImplemented+cRequired)*sizeof(CATID));
        if(cImplemented != -1)
        {
                m_rgcatidImpl=(CATID*) CoTaskMemAlloc(cImplemented*sizeof(CATID));
                if (!m_rgcatidImpl)
                {
                        return E_OUTOFMEMORY;
                }
                CopyMemory(m_rgcatidImpl, rgcatidImpl, cImplemented*sizeof(CATID));
        }
        else
                m_rgcatidImpl = NULL;

        if(cRequired != -1)
        {
                m_rgcatidReq=(CATID*) CoTaskMemAlloc(cRequired*sizeof(CATID));
                if (!m_rgcatidReq)
                {
                        return E_OUTOFMEMORY;
                }
                CopyMemory(m_rgcatidReq, rgcatidReq, cRequired*sizeof(CATID));
        }
        else
                m_rgcatidReq = NULL;
        //m_rgcatidReq=&m_rgcatidImpl[cImplemented+1];
    m_cImplemented=cImplemented;
    m_cRequired=cRequired;

        m_pcsIEnumClsid = pcsIEnumClsid;
        return S_OK;
}

CEnumClassesOfCategories::~CEnumClassesOfCategories()
{
        if (m_pCloned)
        {
                IUnknown* pUnk=m_pCloned;
                m_pCloned=NULL;
                pUnk->Release();
        }
        else
        {
                if (m_hClassKey)
                {
                        RegCloseKey(m_hClassKey);
                        m_hClassKey=NULL;
                }

                if (m_rgcatidImpl)
                {
                        CoTaskMemFree(m_rgcatidImpl);
                        m_rgcatidImpl=NULL;
                }
                if (m_rgcatidReq)
                {
                CoTaskMemFree(m_rgcatidReq);
                m_rgcatidReq=NULL;
                }
        }
        //--------------------------------cs Enum interface
        if (m_pcsIEnumClsid)
                m_pcsIEnumClsid->Release();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\catenum.h ===
#ifndef _COMCATMANAGERENUMS_INCLUDE
#define _COMCATMANAGERENUMS_INCLUDE

#include "comcat.h"

class CEnumCategories : public IEnumCATEGORYINFO
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

	// IEnumCATEGORYINFO methods
    HRESULT __stdcall Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched);
	HRESULT __stdcall Skip(ULONG celt);
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumCATEGORYINFO **ppenum);


	CEnumCategories();
	HRESULT Initialize(LCID lcid, IEnumCATEGORYINFO *pcsIEnumCat);
	~CEnumCategories();
private:

	HKEY m_hKey;
	DWORD m_dwIndex;
	LCID m_lcid;
	IEnumCATEGORYINFO *m_pcsIEnumCat;
	int    m_fromcs;
//	char m_szlcid[10];

	ULONG m_dwRefCount;
};

class CEnumCategoriesOfClass : public IEnumCATID
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

	// IEnumGUID methods
    HRESULT __stdcall Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched);
	HRESULT __stdcall Skip(ULONG celt);
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumGUID **ppenum);


	CEnumCategoriesOfClass();
	HRESULT Initialize(HKEY hKey, BOOL bMapOldKeys);
	~CEnumCategoriesOfClass();

private:
	ULONG m_dwRefCount;

	BOOL	m_bMapOldKeys; // indicates if old keys are mapped

	HKEY	m_hKey;			// HKEY containing the catids ("Implemented" or "Required")
	DWORD	m_dwIndex;		// Index to the current subkey within m_hKey

    HKEY    m_hKeyCats;     // HKEY to Ole Keys in SZ_COMCAT
    DWORD   m_dwOldKeyIndex; // Index into mhKeyCats for old categories

	IUnknown* m_pCloned;	// if cloned: keeps original alive (need m_hkey!)
};

class CEnumClassesOfCategories : public IEnumCATID
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

	// IEnumGUID methods
    HRESULT __stdcall Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched);
	HRESULT __stdcall Skip(ULONG celt);
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumGUID **ppenum);

	CEnumClassesOfCategories();
	HRESULT Initialize(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired, 
						CATID rgcatidReq[], IEnumCLSID *pcsIEnumClsid);
	~CEnumClassesOfCategories();

private:
	ULONG m_dwRefCount;

	HKEY	m_hClassKey;	// HKEY to CLSID
	DWORD	m_dwIndex;		// Index to the current CLSID within m_hKey

	ULONG m_cImplemented;
	CATID *m_rgcatidImpl;
	ULONG m_cRequired;
	CATID *m_rgcatidReq;

	IEnumCLSID *m_pcsIEnumClsid;
	int         m_fromcs;

	IUnknown* m_pCloned;	// if cloned: keeps original alive (need m_hkey!)

};

extern ULONG g_dwRefCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\cscatinf.cpp ===
#include <windows.h>
#include <ole2.h>
#include <malloc.h>
#include <ole2sp.h>

#include "catobj.h"

#define MAXCLASSSTORES  1

CsCatInfo::CsCatInfo()
{
   m_uRefs = 1; // no addref required after new
   m_cCalls = 0;
   m_cICatInfo = 0;
   m_pICatInfo = 0;
   m_hInstCstore = NULL;
}

CsCatInfo::~CsCatInfo()
{
   DWORD i;

   for (i = 0; i < m_cICatInfo; i++) {
      m_pICatInfo[i]->Release();
   }

   if (m_hInstCstore)
      FreeLibrary (m_hInstCstore);

   CoTaskMemFree(m_pICatInfo);
}

HRESULT CsCatInfo::QueryInterface(REFIID iid, void **ppv)
{
   if (iid==IID_ICatInformation) {
      *ppv = (ICatInformation *)this;
   }
   else {
      *ppv = NULL;
      return E_NOINTERFACE;
   }
   AddRef();
   return S_OK;
}

ULONG CsCatInfo::AddRef()
{
   return InterlockedIncrement((long *)&m_uRefs);
}

ULONG CsCatInfo::Release()
{
   ULONG dwRefCount = InterlockedDecrement((long *)&m_uRefs);
   if (dwRefCount==0) {
      delete this;
   }
   return dwRefCount;
}

//-----------------------------------------------------------
// This code is repeated in all the following functions.
// Be very careful when modifying this and when changing any of the functions
// below. NOTICE that there is impersonation being done in this MACRO*****
//
#define MACAvailCStoreLOOP                                                      \
    for (i=0; i < m_cICatInfo; i++)                                                     \
    {

//-------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CsCatInfo::EnumCategories(
         LCID lcid,
         IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT                              hr=S_OK;
    ULONG                                i;
    IEnumCATEGORYINFO                   *Enum[MAXCLASSSTORES];
    ULONG                                cEnum = 0;
    CSCMergedEnum<IEnumCATEGORYINFO, CATEGORYINFO> *EnumMerged = NULL;

    *ppenumCategoryInfo = NULL;

    //
    // Get the list of Class Stores for this user
    //

    MACAvailCStoreLOOP
        //
        // Call method on this store
        //
        hr = m_pICatInfo[i]->EnumCategories(lcid, &(Enum[cEnum]));

        if (hr == E_INVALIDARG)
        {
            return hr;
        }

        if (SUCCEEDED(hr))
            cEnum++;
    }

    EnumMerged = new CSCMergedEnum<IEnumCATEGORYINFO, CATEGORYINFO>(IID_IEnumCATEGORYINFO);
    hr = EnumMerged->Initialize(Enum, cEnum);

    if (FAILED(hr))
    {
        for (i = 0; i < cEnum; i++)
            Enum[i]->Release();
        delete EnumMerged;
    }
    else
    {
        hr = EnumMerged->QueryInterface(IID_IEnumCATEGORYINFO, (void **)ppenumCategoryInfo);
        if (FAILED(hr))
            delete EnumMerged;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CsCatInfo::EnumClassesOfCategories(
         ULONG                           cImplemented,
         CATID __RPC_FAR                 rgcatidImpl[  ],
         ULONG                           cRequired,
         CATID __RPC_FAR                 rgcatidReq[  ],
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT              hr;
    ULONG                i;
    IEnumGUID           *Enum[MAXCLASSSTORES];
    ULONG                cEnum = 0;
    CSCMergedEnum<IEnumGUID, CLSID>  *EnumMerged=NULL;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->EnumClassesOfCategories(
                                    cImplemented, rgcatidImpl, cRequired,
                                    rgcatidReq, &(Enum[cEnum]));

        if (hr == E_INVALIDARG)
        {
            return hr;
        }

        if (SUCCEEDED(hr))
            cEnum++;
    }

    EnumMerged = new CSCMergedEnum<IEnumGUID, CLSID>(IID_IEnumCLSID);
    hr = EnumMerged->Initialize(Enum, cEnum);

    if (FAILED(hr))
    {
        for (i = 0; i < cEnum; i++)
            Enum[i]->Release();
        delete EnumMerged;
    }
    else
    {
        hr = EnumMerged->QueryInterface(IID_IEnumCLSID, (void **)ppenumClsid);
        if (FAILED(hr))
            delete EnumMerged;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CsCatInfo::GetCategoryDesc(
         REFCATID rcatid,
         LCID lcid,
         LPWSTR __RPC_FAR *pszDesc)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT    hr, return_hr=CAT_E_CATIDNOEXIST;
    ULONG      i;

    //
    // Get the list of Class Stores for this user
    //

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->GetCategoryDesc(rcatid, lcid, pszDesc);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }

        if (hr == CAT_E_NODESCRIPTION)
            return_hr = CAT_E_NODESCRIPTION;
    }
    return return_hr;
}


HRESULT STDMETHODCALLTYPE CsCatInfo::IsClassOfCategories(
         REFCLSID rclsid,
         ULONG cImplemented,
         CATID __RPC_FAR rgcatidImpl[  ],
         ULONG cRequired,
         CATID __RPC_FAR rgcatidReq[  ])
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr;
    ULONG               i;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->IsClassOfCategories(
                        rclsid, cImplemented, rgcatidImpl, cRequired,
                        rgcatidReq);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }
    }

    return CS_E_CLASS_NOTFOUND;
}


HRESULT STDMETHODCALLTYPE CsCatInfo::EnumImplCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr;
    ULONG               i;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->EnumImplCategoriesOfClass(
                            rclsid, ppenumCatid);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }
    }

    return CS_E_CLASS_NOTFOUND;
}

HRESULT STDMETHODCALLTYPE CsCatInfo::EnumReqCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr;
    ULONG               i;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->EnumReqCategoriesOfClass(
                            rclsid, ppenumCatid);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }
    }

    return CS_E_CLASS_NOTFOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\cscatinf.h ===
class CsCatInfo :
        public ICatInformation
{
public:
  CsCatInfo(void);
  ~CsCatInfo(void);

  // IUnknown
  HRESULT __stdcall QueryInterface(
            REFIID  iid,
            void ** ppv );
  ULONG __stdcall AddRef();
  ULONG __stdcall Release();

// ICatInformation interfaces.---------------------------------------
  HRESULT STDMETHODCALLTYPE EnumCategories(
         LCID lcid,
         IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);

  HRESULT STDMETHODCALLTYPE GetCategoryDesc(
         REFCATID rcatid,
         LCID lcid,
         LPWSTR __RPC_FAR *pszDesc);

  HRESULT STDMETHODCALLTYPE EnumClassesOfCategories(
         ULONG cImplemented,
         CATID __RPC_FAR rgcatidImpl[  ],
         ULONG cRequired,
         CATID __RPC_FAR rgcatidReq[  ],
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);

  HRESULT STDMETHODCALLTYPE IsClassOfCategories(
         REFCLSID rclsid,
         ULONG cImplemented,
         CATID __RPC_FAR rgcatidImpl[  ],
         ULONG cRequired,
         CATID __RPC_FAR rgcatidReq[  ]);

  HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);

  HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);

//---------------------------------------------------------------------

protected:
     unsigned long 	m_uRefs;
     unsigned long 	m_cCalls;
     ICatInformation ** m_pICatInfo;
     unsigned long	m_cICatInfo;
     HINSTANCE          m_hInstCstore;
};


// enumerator classes for the merged enumerators.

template<class ENUM, class RetType>
class CSCMergedEnum : public ENUM
{
private:
    ENUM               **m_pcsEnum;
    ULONG                m_cTotalEnum;
    ULONG                m_dwRefCount;
    ULONG                m_CurrentEnum;
    IID			 m_myiid;

public:
	CSCMergedEnum(IID myIID)
	   :m_myiid(myIID)
	{
	    m_pcsEnum = NULL;
	    m_cTotalEnum = 0;
	    m_CurrentEnum = 0;
	    m_dwRefCount = 0;
	}
	
	~CSCMergedEnum()
	{
	    ULONG    i;
	    for (i = 0; i < m_cTotalEnum; i++)
		m_pcsEnum[i]->Release();
	    CoTaskMemFree(m_pcsEnum);
	}
	
	HRESULT  __stdcall  QueryInterface(REFIID riid,
						    void  * * ppObject)
	{
	    *ppObject = NULL; //gd
	    if ((riid==IID_IUnknown) || (riid==m_myiid))
	    {
		*ppObject=(ENUM *) this;
	    }
	    else
	    {
		return E_NOINTERFACE;
	    }
	    AddRef();
	    return S_OK;
	}
	
	ULONG  __stdcall  AddRef()
	{
	    InterlockedIncrement((long*) &m_dwRefCount);
	    return m_dwRefCount;
	}
	
	ULONG  __stdcall Release()
	{
	    ULONG dwRefCount;
	    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
	    {
		delete this;
		return 0;
	    }
	    return dwRefCount;
	}
	
	HRESULT  __stdcall Next(
		    ULONG             celt,
		    RetType          *rgelt,
		    ULONG            *pceltFetched)
	{
	    ULONG count=0, total = 0;
	    HRESULT hr;
            BOOL fImpersonating;
            
	    fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);

	    for (; m_CurrentEnum < m_cTotalEnum; m_CurrentEnum++)
	    {
		count = 0;
		hr = m_pcsEnum[m_CurrentEnum]->Next(celt, rgelt+total, &count);
	
		if (hr == E_INVALIDARG)
		{
		    if (fImpersonating) 
                        RevertToSelf();
		    return hr;
		}
	
		total += count;
		celt -= count;
	
		if (!celt)
		    break;
	    }
	    if (pceltFetched)
		*pceltFetched = total;
            if (fImpersonating)
                RevertToSelf();
	    if (!celt)
		return S_OK;
	    return S_FALSE;
	}
	
	HRESULT  __stdcall Skip(
		    ULONG             celt)
	{
	    RetType *dummy;
	    ULONG count=0, total = 0;
	    HRESULT    hr = S_OK;
            BOOL fImpersonating;

	    dummy = new RetType[celt];
	
	    fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);

	    for (; m_CurrentEnum < m_cTotalEnum; m_CurrentEnum++)
	    {
		count = 0;
		hr = m_pcsEnum[m_CurrentEnum]->Next(celt, dummy+total, &count);
	
		if (hr == E_INVALIDARG)
		{
		    delete dummy;
                    if (fImpersonating) 
                        RevertToSelf();
		    return hr;
		}
	
		total += count;
		celt -= count;
	
		if (!celt)
		    break;
	    }
	    delete dummy;
            if (fImpersonating) 
                RevertToSelf();
	    if (!celt)
		return S_OK;
	    return S_FALSE;
	}
	
	HRESULT  __stdcall Reset()
	{
	    ULONG i;
            BOOL fImpersonating;

            fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);
            
	    for (i = 0; ((i <= m_CurrentEnum) && (i < m_cTotalEnum)); i++)
		m_pcsEnum[i]->Reset(); // ignoring all error values
	    m_CurrentEnum = 0;
            if (fImpersonating) 
                RevertToSelf();
	    return S_OK;
	}
	
	HRESULT  __stdcall Clone(ENUM **ppenum)
	{
	    ULONG i;
	    CSCMergedEnum<ENUM, RetType> *pClone;
	    ENUM **pcsEnumCloned = (ENUM **)CoTaskMemAlloc(sizeof(ENUM *)*m_cTotalEnum);
            BOOL fImpersonating;

	    fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);

	    pClone = new CSCMergedEnum<ENUM, RetType>(m_myiid);
	    for ( i = 0; i < m_cTotalEnum; i++)
		m_pcsEnum[i]->Clone(pcsEnumCloned+i);
	
	    pClone->Initialize(pcsEnumCloned, m_cTotalEnum);
	    pClone->m_CurrentEnum = m_CurrentEnum;
	    *ppenum = (ENUM *)pClone;
	    pClone->AddRef();

	    if (fImpersonating)
                RevertToSelf();
	    CoTaskMemFree(pcsEnumCloned);
	    return S_OK;
	}
	
	HRESULT  Initialize(ENUM **pcsEnum, ULONG cEnum)
	{
	    ULONG i;
	    m_CurrentEnum = 0;
	    m_pcsEnum = (ENUM **)CoTaskMemAlloc(sizeof(ENUM *)*cEnum);
	    if (!m_pcsEnum)
		return E_OUTOFMEMORY;
	    for (i = 0; i < cEnum; i++)
		m_pcsEnum[i] = pcsEnum[i];
	    m_cTotalEnum = cEnum;
	    return S_OK;
	}			     	
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\comcat\src\guids.cpp ===
#define INITGUID
#include "objbase.h"

#include "comcat.h"

#if 0
const IID IID_IEnumGUID = {0x0002E000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_IEnumCATEGORYINFO = {0x0002E011,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_ICatRegister = {0x0002E012,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_ICatInformation = {0x0002E013,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
#endif

const CLSID CLSID_StdComponentCategoriesMgr = {0x0002E005,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const CLSID CLSID_GblComponentCategoriesMgr = {0x0002E006,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const CATID CATID_Insertable            = {0x40FC6ED3,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_Control               = {0x40FC6ED4,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_Programmable          = {0x40FC6ED5,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_DocObject             = {0x40FC6ED8,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_Printable             = {0x40FC6ED9,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};

/*
const CATID CATID_IsShortcut            = {0x40FC6ED6,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_NeverShowExt          = {0x40FC6ED7,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_RequiresDataPathHost  = {0x0de86a50,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToMoniker     = {0x0de86a51,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToStorage     = {0x0de86a52,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToStreamInit  = {0x0de86a53,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToStream      = {0x0de86a54,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToMemory      = {0x0de86a55,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToFile        = {0x0de86a56,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToPropertyBag = {0x0de86a57,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\comsrgt.cxx ===
///+---------------------------------------------------------------------------
//
//  File:       comsrgt.cxx
//
//  Contents:   Implementation of CCOMSurrogate class for synchronizing access
//              to this process's ISurrogate 
//
//  Functions:  all inline -- see the header file
// 
//  History:    21-Oct-96  t-adame        
//
//----------------------------------------------------------------------------

#include <comsrgt.hxx>

LPSURROGATE CCOMSurrogate::_pSurrogate = NULL;
BOOL CCOMSurrogate::_fNewStyleSurrogate = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\buffer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       buffer.cxx
//
//  Contents:   An ASCII text-buffer for outputting to a debug stream
//
//  Classes:	CTextBufferA
//
//  History:    11-Jul-95   t-stevan    Created
//
//
//----------------------------------------------------------------------------
#include <windows.h>
#include "buffer.hxx"

// *** CTextBufferA ***
//+-------------------------------------------------------------------------
//
//  Member:	CTextBufferA::operator<< (const char *)
//
//  Synopsis:	String Insertion operator
//
//  Arguments:	[pStr]  - string to insert into stream
//
//  Returns:	reference to this stream
//
//	Algorithm: 	inserts pStr into buffer, if not enough room, flushes buffer
//
//  History:	11-Jul-95 t-stevan    Created
//
//--------------------------------------------------------------------------
CTextBufferA &CTextBufferA::operator<<(const char *pStr)
{
	char *pszEnd;

	pszEnd = m_szBuffer+cBufferSize;
	
	// copy until we hit a null byte, flushing the buffer as we go if we fill up
	while((*m_pszPos++ = *pStr++) != '\0')
	{
		if(m_pszPos == pszEnd)
		{
			Flush(); // resets m_pszPos
		}
	}

	// we subtract one from m_pszPos because we don't want the null byte
	// to be printed out!
	m_pszPos--;

	return *this;
}

//+-------------------------------------------------------------------------
//
//  Member:	CTextBufferA::Insert
//
//  Synopsis:	Counted String Insertion operator
//
//  Arguments:	[pStr]  - string to insert into stream
//				[nCount] - number of characters  to insert into stream
//
//
//	Algorithm: 	inserts pStr into buffer, if not enough room, flushes buffer
//
//  History:	11-Jul-95 t-stevan    Created
//
//--------------------------------------------------------------------------
void CTextBufferA::Insert(const char *pStr, size_t nCount)
{
	char *pszEnd;

	pszEnd = m_szBuffer+cBufferSize;
	
	// copy until we hit a null byte, flushing the buffer as we go if we fill up
	while(nCount > 0)
	{
		*m_pszPos++ = *pStr++;
		nCount--;

		if(m_pszPos == pszEnd)
		{
			Flush(); // resets m_pszPos
		}
	}
}

//+-------------------------------------------------------------------------
//
//  Member:	CTextBufferA::Revert
//
//  Synopsis:	Revert to a previous state of the buffer, if there have
//				been no flushes since then
//
//	Arguments:  [bc] - a buffer context to retrieve the previous state from
//
//  History:	11-Jul-95 t-stevan    Created
//
//--------------------------------------------------------------------------
BOOL CTextBufferA::Revert(const BufferContext &bc)
{
	if(bc.wRef == m_wFlushes)
	{
		// we haven't flushed since this snapshot, we can revert
		if(((char *) bc.dwContext) < m_szBuffer || ((char *) bc.dwContext) >= (m_szBuffer+cBufferSize))
		{
			return FALSE; // still can't revert, because the pointer is not correct!
		}

		m_pszPos = (char *) bc.dwContext;

		*(m_pszPos+1) = '\0';

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\catinit.cxx ===
#include <ole2int.h>

STDAPI GetCatalogHelper ( REFIID riid, void** ppv );

// Global catalog reference used in all activation
IComCatalog *gpCatalog = NULL;
IComCatalogSCM *gpCatalogSCM = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   InitializeCatalogIfNecessary
//
//  Synopsis:   Load the catalog DLL and initialize the catalog interface
//              if it hasn't already been done
//
//  Arguments:   none
//
//  Returns:    S_OK            - no errors or inconsistencies found
//              E_OUTOFMEMORY   - couldn't create catalog object
//              FAILED(hr)      - return from CCI() of catalog or
//                                from QI() of catalog for IComCatalogSCM
//
//--------------------------------------------------------------------------

HRESULT InitializeCatalogIfNecessary()
{
    if (gpCatalog != NULL && gpCatalogSCM != NULL)
    {
        return S_OK;
    }

    HRESULT hr = S_OK;
    IComCatalog *pCatalog = NULL;
    IComCatalogSCM *pCatalogSCM = NULL;
    void* pICEPRet = NULL;

    // get the actual catalog object - abort on failure
    hr = GetCatalogHelper (IID_IComCatalog, (void**) &pCatalog);
    if ( FAILED(hr) || pCatalog == NULL)
    {
        ComDebOut((DEB_WARN,
                   "CCI of Catalog failed, hr=0x%x, pCatalog=0x%x",
                    hr, pCatalog));
    }    
    if ( FAILED(hr) )
    {
        return hr;
    }
    if ( pCatalog == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // store the catalog object. guard against races by
    //  releasing if we didn't find a NULL in the variable
    pICEPRet = InterlockedCompareExchangePointer ( (void **) &gpCatalog, (void *) pCatalog, NULL);
    if ( pICEPRet != NULL )
    {
        pCatalog->Release();
    }

    // create the SCM object -- again, abort on failure
    hr = GetCatalogHelper (IID_IComCatalogSCM, (void**) &pCatalogSCM);
    if ( FAILED(hr) || pCatalog == NULL)
    {
        ComDebOut((DEB_WARN,
                   "CCI of Catalog failed, hr=0x%x, pCatalog=0x%x",
                    hr, pCatalog));
    }    
    if ( FAILED(hr) )
    {
        return hr;
    }
    if ( pCatalogSCM == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // store the SCM catalog. Again, if it was already non-NULL, the exchange
    //  didn't happen, and you release the thing you just created.
    pICEPRet = InterlockedCompareExchangePointer ( (void **) &gpCatalogSCM, (void *) pCatalogSCM, NULL );
    if ( pICEPRet != NULL )
    {
        pCatalogSCM->Release();
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   UninitializeCatalog
//
//  Synopsis:   Load the catalog DLL and initialize the catalog interface
//              if it hasn't already been done
//
//  Arguments:   none
//
//  Returns:    S_OK   - no errors or inconsistencies observed here
//
//  Note:        This can only be called from a place like wCoUninitialize(),
//                where you're sure that nobody's using the catalog or doing
//                anything out in the process.
//
//--------------------------------------------------------------------------

HRESULT UninitializeCatalog()
{
    IComCatalog *pCatalog = NULL;
    IComCatalogSCM *pCatalogSCM = NULL;

    pCatalogSCM = (IComCatalogSCM *) InterlockedExchangePointer ((PVOID*)&gpCatalogSCM, NULL);
    if ( pCatalogSCM != NULL )
    {
        pCatalogSCM->Release();
    }

    pCatalog = (IComCatalog *) InterlockedExchangePointer ((PVOID*)&gpCatalog, NULL);
    if ( pCatalog != NULL )
    {
        pCatalog->FlushCache();
        pCatalog->Release();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1
#include <stdarg.h>
#include <stdio.h>
#include <dprintf.h>            // w4printf, w4dprintf prototypes
#include <debnot.h>
#include <olesem.hxx>
#include <windows.h>
#include <netevent.h>
#include <stackwlk.hxx>
#include <asrtcfg.h>
#include <memapi.hxx>

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
BOOL gAssertOnCreate = TRUE;
int ForceAV();

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
          char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}
typedef enum 
    {
    ASSRTCFG_BREAK        = 0x01,
    ASSRTCFG_POPUP        = 0x02,
    ASSRTCFG_DEBUGMESSAGE = 0x04,
    ASSRTCFG_PRINTSTACK   = 0x08,
    ASSRTCFG_USEAV        = 0x10
    } ASSRTCFG;




//+---------------------------------------------------------------------
//
// Class:      CAssertInfo
//
// Synopsis:   Data type to trake assertion and logging parameters
//
// History:    27-Jan-99  MattSmit Created
//
//----------------------------------------------------------------------
class CAssertInfo : public IAssertConfig
{
public:
    CAssertInfo() : _dwFlags(ASSRTCFG_POPUP | ASSRTCFG_DEBUGMESSAGE) {}

    //
    // IUnknown
    //

    STDMETHOD(QueryInterface)(REFIID riid, PVOID * ppv)
    {
        if ((IsEqualIID(riid, IID_IUnknown)) || 
            (IsEqualIID(riid, IID_IAssertConfig)))
        {
            *ppv = this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    STDMETHOD_(ULONG, AddRef)()  { return 1;}
    STDMETHOD_(ULONG, Release)() { return 1;}


    //
    // IConfigAssert
    //

    STDMETHOD(SetBreak)(BOOL f)            { SetFlag(f, ASSRTCFG_BREAK); return S_OK;}
    STDMETHOD(SetPopup)(BOOL f)            { SetFlag(f, ASSRTCFG_POPUP); return S_OK;}
    STDMETHOD(SetDebuggerMessage)(BOOL f)  { SetFlag(f, ASSRTCFG_DEBUGMESSAGE); return S_OK;}
    STDMETHOD(SetPrintStack)(BOOL f)       { SetFlag(f, ASSRTCFG_PRINTSTACK); return S_OK;}
    STDMETHOD(SetUseAV)(BOOL f)            { SetFlag(f, ASSRTCFG_USEAV); return S_OK;}
    STDMETHOD(SetLog)(ASSRTLOGINFO *pLogInfo) { _logInfo = *pLogInfo;  return S_OK;}
    STDMETHOD(SetContextString)(char *psz){ _pszContext = psz; return S_OK;}
    STDMETHOD(SetThreshold)(ULONG cTh)     { _cThreshold = cTh; return S_OK;}

    //
    // helpers
    //
    
    void Win4AssertEx(char const * szFile, int iLine, char const * szMessage);
    int  PopUpError(char const *szMsg, int iLine, char const *szFile);
    void ComposeErrorMessage(char const *szMsg, int iLine, char const *szFile);
    void AppendToFile(char *pszFileName, char const *pwszData);
    void FatalErrorHandler(char *errmsg);
    void LogAssertionFailure(char const * szMessage);
private:

    void SetFlag(BOOL f, DWORD bit)
    {
        _dwFlags = f ? _dwFlags | bit : _dwFlags & ~bit;
    }
    char *GetStack();
    BOOL GetBreak()        {return _dwFlags | ASSRTCFG_BREAK;}
    BOOL GetPopup()        {return _dwFlags | ASSRTCFG_POPUP;}
    BOOL GetDebugMessage() {return _dwFlags | ASSRTCFG_DEBUGMESSAGE;}
    void BreakIntoDebugger()
    {
        if (_dwFlags & ASSRTCFG_USEAV)
            ForceAV();
        else
            DebugBreak();
    }


    DWORD                 _dwFlags;          // what to do when an assertion fails
    ASSRTLOGINFO          _logInfo;          // if/where to write a log entry
    char                 *_pszContext;       // user supplied context string for the log
    char                  _errMessage[128];  // generated error string
    ULONG                 _cThreshold;       // number of assertion to ignore
    ULONG                 _cAssrtFail;       // number of assertion failures so far
};

CAssertInfo gAssertInfo;

//+---------------------------------------------------------------------------
//
//  Method:     Win4AssertEx
//
//  Synopsis:   Called on assertion failure.  Takes appropriate action based 
//              on member variables
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::Win4AssertEx(
                              char const * szFile,
                              int iLine,
                              char const * szMessage)
{
    _cAssrtFail++;
    if (_cAssrtFail < _cThreshold)
    {
        return;
    }
    ComposeErrorMessage(szMessage, iLine, szFile);

    BOOL fBrokeAlready = FALSE;

    if (_dwFlags & ASSRTCFG_DEBUGMESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s\n%s\n", _errMessage, szMessage);
    }

    if (_logInfo.dwDest & ASSRTLOG_FILE)
    {
        AppendToFile(_logInfo.pszFileName, szMessage);
    }

    if (_logInfo.dwDest & ASSRTLOG_NTEVENTLOG)
    {
        LogAssertionFailure(szMessage);
    }

    if (_dwFlags & ASSRTCFG_POPUP)
    {
        int id = PopUpError(szMessage, iLine, szFile);

        if (id == IDCANCEL)
        {
            fBrokeAlready = TRUE;
            BreakIntoDebugger();
        }
    }

    if ((_dwFlags & ASSRTCFG_BREAK) && !fBrokeAlready)
    {
        BreakIntoDebugger();
    }

}

//+------------------------------------------------------------
// Method:      PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int CAssertInfo::PopUpError(char const *szMsg, int iLine, char const *szFile)
{

    int id;
    WCHAR   wszWinsta[64];
    HWINSTA hWinsta;
    DWORD   Size;

    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
    hWinsta = GetProcessWindowStation();
    Size = sizeof(wszWinsta);
    wszWinsta[0] = 0;

    if ( hWinsta )
    {
        (void) GetUserObjectInformation(
                                       hWinsta,
                                       UOI_NAME,
                                       wszWinsta,
                                       Size,
                                       &Size );
    }


    //
    // This makes popups from non-interactive servers/services (including
    // rpcss) visible.
    //
    if ( wszWinsta[0] && (lstrcmpiW(wszWinsta,L"Winsta0") != 0) )
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) _errMessage,
                     dwMessageFlags);
#else
    id = MessageBox(NULL, (char *) szMsg, (LPSTR) _errMessage,
                    dwMessageFlags);
#endif

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+---------------------------------------------------------------------------
//
//  Method:     ComposeErrorMessage
//
//  Synopsis:   Put together a message that contains useful info about the 
//              context of the error
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::ComposeErrorMessage(
                                     char const *szMsg,
                                     int iLine,
                                     char const *szFile)
{

    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char *  pszModuleName;

    BOOL    bStatus;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintfA(_errMessage,"Process: %s File: %s line %u, thread id %d.%d",
              pszModuleName, szFile, iLine, pid, tid);
}


//+---------------------------------------------------------------------------
//
//  Method:     AppendToFile
//
//  Synopsis:   Write assertion failures to a log file.
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::AppendToFile(char *pszFileName, char const *pwszData)
{
    HANDLE hFile = CreateFileA(pszFileName,
                               GENERIC_WRITE,
                               0, 
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        FatalErrorHandler("Could not open log File.");
    }

    
    DWORD ret = SetFilePointer(hFile, 0, 0, FILE_END);
    if (ret == -1)
    {
        FatalErrorHandler("Could not set file pointer.");
    }
    
    DWORD dwBytesWritten;
    BOOL ok = WriteFile(hFile, _errMessage, 
                        lstrlenA(_errMessage),
                        &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }
    
    ok = WriteFile(hFile, "\n", 1,
                        &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }

    ok = WriteFile(hFile, pwszData, 
                   lstrlenA(pwszData),
                   &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }

    ok = WriteFile(hFile, "\n", 1,
                        &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }


    if (_dwFlags & ASSRTCFG_PRINTSTACK)
    {
        char *psz = GetStack();
        if (psz)
        {
            ok = WriteFile(hFile, psz,
                           lstrlenA(psz),
                           &dwBytesWritten, NULL); 

            if (!ok)
            {
                FatalErrorHandler("Could not write to log File.");
            }
            PrivMemFree(psz);
        }
        
    }
    if (_pszContext)
    {
        ok = WriteFile(hFile, pwszData, 
                       lstrlenA(pwszData),
                       &dwBytesWritten, NULL); 

        if (!ok)
        {
            FatalErrorHandler("Could not write to log File.");
        }
        ok = WriteFile(hFile, "\n", 1,
                            &dwBytesWritten, NULL); 

        if (!ok)
        {
            FatalErrorHandler("Could not write to log File.");
        }


    }
    CloseHandle(hFile);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStackExceptionFilter
//
//  Synopsis:   Walk stack and store in a string variable
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------

LONG GetStackExceptionFilter(LPEXCEPTION_POINTERS lpep, char **ppStack)
{
    *ppStack = NULL;
    DWORD dwFault = lpep->ExceptionRecord->ExceptionCode;
    if (dwFault != 0xceadbeef)
    {
        return EXCEPTION_CONTINUE_SEARCH;
    }
    StackWalker resolver(GetCurrentProcess());
    Symbol* symbol = resolver.CreateStackTrace(lpep->ContextRecord);
    SIZE_T nLen = resolver.GetCallStackSize(symbol);
    WCHAR * szStack = new WCHAR[nLen];
    if (szStack)
    {
        resolver.GetCallStack(symbol, nLen, szStack, 20); // No more than 20 lines
        *ppStack = (char *) PrivMemAlloc(nLen);
        wcstombs(*ppStack, szStack, lstrlenW(szStack));
        delete [] szStack;
    }
    

    return EXCEPTION_EXECUTE_HANDLER;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetStack
//
//  Synopsis:   Throws and exception so the filter can get stack info
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
char *CAssertInfo::GetStack()
{
    char *pStack = NULL;
    __try
    {
        RaiseException(0xceadbeef, 0, 0, NULL);
    }
    __except(GetStackExceptionFilter(GetExceptionInformation(), &pStack))
    {
    }
    return pStack;
}

//+---------------------------------------------------------------------------
//
//  Method:     FatalErrorHandler
//
//  Synopsis:   Called when the assertion code itself cannot allocate 
//              enough resources to log the assertion failure.
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::FatalErrorHandler(char *szMessage)
{
    BOOL fBrokeAlready = FALSE;

    lstrcpyA(_errMessage, "Fatal error while processing assertion failure");
    _asdprintf("%s\n%s\n", _errMessage, szMessage);

    if (_dwFlags & ASSRTCFG_POPUP)
    {
        int id = PopUpError(szMessage, __LINE__, __FILE__);

        if (id == IDCANCEL)
        {
            fBrokeAlready = TRUE;
            BreakIntoDebugger();
        }
    }

    if (_dwFlags & ASSRTCFG_BREAK && !fBrokeAlready)
    {
        BreakIntoDebugger();
    }

}

//+---------------------------------------------------------------------------
//
//  Method:     LogAssertionFailure
//
//  Synopsis:   Write and assertion failure to the NT event log
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::LogAssertionFailure(char const * szMessage)
{
    HANDLE  LogHandle;
    char const *  Strings[3]; // array of message strings.

    Strings[0] = _errMessage;
    Strings[1] = szMessage;
    Strings[2] = _pszContext ? _pszContext : "";

    // Get the log handle, then report the event.
    LogHandle = RegisterEventSource( NULL, L"DCOM" );

    if ( LogHandle )
    {
        ReportEventA( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_DCOM_ASSERTION_FAILURE,
                     NULL,
                     3,             // 3 strings passed
                     0,             // 0 bytes of binary
                     Strings,       // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
    else
    {
        FatalErrorHandler("Could not register as event source");
    }
}





//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//


static COleDebugMutexSem mxs;

STDAPI_(void) vdprintf(
                      unsigned long ulCompMask,
                      char const   *pszComp,
                      char const   *ppszfmt,
                      va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                DWORD tid = GetCurrentThreadId();
                DWORD pid = GetCurrentProcessId();
                mxs.Request();
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  are memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03dp> ", pid, tid );
#endif
                w4dprintf("%s: ", pszComp);
                w4vdprintf(ppszfmt, pargs);
                mxs.Release();
            }
        }        
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ForceAV
//
//  Synopsis:   Cause and Access Violation
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
int ForceAV()
{
    return *((int *) 0);
}



//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
                          char const * szFile,
                          int iLine,
                          char const * szMessage)
{
    gAssertInfo.Win4AssertEx(szFile, iLine, szMessage);
}




//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
                unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
               unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadINIFile
//
//  Synopsis:   Get a paremeter value from the win.ini file
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
BOOL ReadINIFile(char * pszKey, BOOL * pVal)
{
    static char szValue[128];
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          pszKey,               // key
                          "",             // default value
                          szValue,              // return buffer
                          128))
    {
        *pVal = (lstrcmpiA(szValue, "yes") == 0) ;
        return TRUE;
    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   AssertDebugInit
//
//  Synopsis:   Initialize the assertion data structure using the win.ini file
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void AssertDebugInit()
{

#define ASSERT_SET(key) \
{ \
    BOOL val; \
    if (ReadINIFile(#key, &val)) \
    { \
       gAssertInfo.Set##key(val); \
    } \
} \

    static char szValue[128];
    ASSERT_SET(Break);
    ASSERT_SET(Popup);
    ASSERT_SET(DebuggerMessage);
    ASSERT_SET(PrintStack);
    ASSERT_SET(UseAV);
    
    ASSRTLOGINFO logInfo;
    memset(&logInfo, 0, sizeof(logInfo));
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          "Log_File",               // key
                          "",             // default value
                          logInfo.pszFileName,              // return buffer
                          MAX_PATH))
    {
        if (lstrcmpA("", logInfo.pszFileName) != 0)
        {
            logInfo.dwDest |= ASSRTLOG_FILE;
        }
    }
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          "Log_NtEventLog",              // key
                          "",             // default value
                          szValue,              // return buffer
                          128))
    {

        logInfo.dwDest |= (lstrcmpiA(szValue, "yes") == 0 )? ASSRTLOG_NTEVENTLOG : 0;
    }
    
    if (logInfo.dwDest)
    {
        gAssertInfo.SetLog(&logInfo);
    }
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          "AssertOnCreate",               // key
                          "",             // default value
                          szValue,              // return   buffer
                          128))
    {
        gAssertOnCreate = FALSE;
    }
    
    
}
//+---------------------------------------------------------------------------
//
//  Function:   CoGetAssertConfig
//
//  Synopsis:   CI for CAssertInfo.  gAssertInfo is a singleton,
//              so just to a QI
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
HRESULT CoGetAssertConfig(REFIID riid, PVOID *ppv)
{
    return gAssertInfo.QueryInterface(riid, ppv);
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

 #endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\ccompapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ccompapi.cxx
//
//  Contents:   common compobj API Worker routines used by com, stg, scm etc
//
//  Classes:
//
//  Functions:
//
//  History:    31-Dec-93   ErikGav     Chicago port
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>
#include <olesem.hxx>

NAME_SEG(CompApi)
ASSERTDATA

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

LPVOID WINAPI PrivHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
BOOL   WINAPI PrivHeapFree (HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);

HANDLE g_hHeap = 0;
HEAP_ALLOC_ROUTINE *pfnHeapAlloc = PrivHeapAlloc;
HEAP_FREE_ROUTINE  *pfnHeapFree  = PrivHeapFree;

//+-------------------------------------------------------------------------
//
//  Function:   PrivHeapAlloc     (internal)
//
//  Synopsis:   Allocate memory from the heap.
//
//  Notes:      This function handles the first call to PrivMemAlloc.
//              This function changes pfnHeapAlloc so that subsequent calls
//              to PrivMemAlloc will go directly to HeapAlloc.
//
//--------------------------------------------------------------------------
LPVOID WINAPI PrivHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
{
    // Fault in g_hHeap if it's not initialized already via MallocInitialize
    if (g_hHeap == NULL)
    {
        g_hHeap = GetProcessHeap();
        if (g_hHeap == NULL)
        {
            return NULL;
        }
    }

    pfnHeapFree  = HeapFree;
    pfnHeapAlloc = HeapAlloc;
    return HeapAlloc(g_hHeap, dwFlags, dwBytes);
}


//+-------------------------------------------------------------------------
//
//  Function:   PrivHeapFree     (internal)
//
//  Synopsis:   Free memory from the heap.
//
//  Notes:      lpMem should always be zero.  We assume that memory
//              freed via PrivMemFree has been allocated via PrivMemAlloc.
//              The first call to PrivMemAlloc changes pfnHeapFree.
//              Subsequent calls to PrivMemFree go directly to HeapFree.
//              Therefore PrivHeapFree should never be called with a
//              non-zero lpMem.
//
//--------------------------------------------------------------------------
BOOL WINAPI PrivHeapFree (HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
    Win4Assert(lpMem == 0 && "PrivMemFree requires PrivMemAlloc.");
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromUUID     (internal)
//
//  Synopsis:   converts UUID into xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//
//  Returns:    Number of characters copied to the buffer.
//
//--------------------------------------------------------------------------
INTERNAL wStringFromUUID(REFGUID rguid, LPWSTR lpsz)
{
    int i;
    LPWSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    for (i = 0; i < sizeof(GuidMap); i++)
    {
	if (GuidMap[i] == '-')
	{
	    *p++ = L'-';
	}
	else
	{
	    *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
	    *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
	}
    }

    *p   = L'\0';

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
static BOOL HexStringToDword(LPCWSTR FAR& lpsz, DWORD FAR& Value,
			     int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
	if (*lpsz >= '0' && *lpsz <= '9')
	    Value = (Value << 4) + *lpsz - '0';
	else if (*lpsz >= 'A' && *lpsz <= 'F')
	    Value = (Value << 4) + *lpsz - 'A' + 10;
	else if (*lpsz >= 'a' && *lpsz <= 'f')
	    Value = (Value << 4) + *lpsz - 'a' + 10;
	else
	    return(FALSE);
    }

    if (chDelim != 0)
	return *lpsz++ == chDelim;
    else
	return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))
	return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
	return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
	return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
	return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//  CODEWORK:  these are common with com\class\compapi.cxx ..
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz++ != '{' )
	return FALSE;

    if (wUUIDFromString(lpsz, pguid) != TRUE)
	return FALSE;

    lpsz +=36;

    if (*lpsz++ != '}' )
	return FALSE;

    if (*lpsz != '\0')	 // check for zero terminated string - test bug #18307
    {
	return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2     (internal)
//
//  Synopsis:   converts GUID into {...} form without leading identifier;
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------
INTERNAL_(int)  wStringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax)
{
    int i;
    LPWSTR p = lpsz;

    if (cbMax < GUIDSTR_MAX)
	return 0;

    *p++ = L'{';

    wStringFromUUID(rguid, p);

    p += 36;

    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}

static const CHAR szDigits[] = "0123456789ABCDEF";
//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2A     (internal)
//
//  Synopsis:   Ansi version of wStringFromGUID2 (for Win95 Optimizations)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

INTERNAL_(int) wStringFromGUID2A(REFGUID rguid, LPSTR lpsz, int cbMax)	// internal
{
    int i;
    LPSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = '{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
	if (GuidMap[i] == '-')
	{
	    *p++ = '-';
	}
	else
	{
	    *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
	    *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
	}
    }
    *p++ = '}';
    *p   = '\0';

    return GUIDSTR_MAX;
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNumA
//
//  Synopsis:   Given a value, and a count of characters, translate
//              the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//              [chChars] -- Number of characters to format
//              [pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    12-Dec-95 KevinRo Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNumA( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
    while (chChars--)
    {
	pchStr[chChars] = (char) szDigits[ulValue & 0xF];
	ulValue = ulValue >> 4;
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNumW
//
//  Synopsis:   Given a value, and a count of characters, translate
//              the value into a hex string. This is the WCHAR version
//
//  Arguments:  [ulValue] -- Value to convert
//              [chChars] -- Number of characters to format
//              [pwcStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    12-Dec-95 KevinRo Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNumW( unsigned long ulValue, unsigned long chChars, WCHAR *pwcStr)
{
    while (chChars--)
    {
	pwcStr[chChars] = (char) wszDigits[ulValue & 0xF];
	ulValue = ulValue >> 4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\makefile.inc ===
DEST_DIR=$(MAKEDIR)\$(O)

$(DEST_DIR)\rwlock_rpcss.obj:   ..\rwlock.cxx
    $(CXX_COMPILER_NAME)  -Fo"$(DEST_DIR)\rwlock_rpcss.obj" $(USE_FC) $(CXX_COMPILER_FLAGS) -D__NOOLETLS__ ..\rwlock.cxx

$(DEST_DIR)\rwlock_ole32.obj:   ..\rwlock.cxx
    $(CXX_COMPILER_NAME)  -Fo"$(DEST_DIR)\rwlock_ole32.obj" $(USE_FC) $(CXX_COMPILER_FLAGS) ..\rwlock.cxx

$(DEST_DIR)\cmrpcss.lib: $(DEST_DIR)\rwlock_rpcss.obj $(DEST_DIR)\common.lib
        lib  /out:$@ $**

$(DEST_DIR)\cmole32.lib: $(DEST_DIR)\rwlock_ole32.obj $(DEST_DIR)\common.lib
        lib  /out:$@ $**

all_common: $(DEST_DIR)\cmrpcss.lib $(DEST_DIR)\cmole32.lib

clean:
          -erase $(DEST_DIR)\rwlock_?????.obj  >NUL 2>NUL
          -erase $(DEST_DIR)\cm?????.lib       >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\eqguid.cxx ===
#define _SYS_GUID_OPERATORS_
#include  <windows.h>
#include  <ole2.h>
#include  <stdlib.h>

//+-------------------------------------------------------------------------
//
//  Function:	IsEqualGUID  (public)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//  Note:
//      Only reason we have this function is because we exported it originally
//      from OLE32.DLL and forgot to take it out when we made it an inline
//      function in objbase.h.  Somebody out there may be relying on it being
//      available.  Internally we must use wIsEqualGUID.
//
//--------------------------------------------------------------------------
#if _MSC_VER < 1200
#undef IsEqualGUID  // undo the #define in objbase.h
extern "C" BOOL  __stdcall IsEqualGUID(GUID &guid1, GUID &guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}
#endif

#if 0
//+-------------------------------------------------------------------------
//
//  Function:	wIsEqualGUID  (internal)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//--------------------------------------------------------------------------

BOOL  __fastcall wIsEqualGUID(REFGUID guid1, REFGUID guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\dynload.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dynload.cxx
//
//  Contents:   APIs from dynamically loaded system dlls. These APIs
//              are rarely used and there are only 1 or 2 per system
//              Dll so we dynamically load the Dll so that we improve
//              the load time of OLE32.DLL
//
//  Functions:  OleWNetGetConnection
//              OleWNetGetUniversalName
//              OleExtractIcon
//              OleGetShellLink
//              OleSymInitialize
//              OleSymCleanup
//              OleSymGetSymFromAddr
//              OleSymUnDName
//
//  History:    10-Jan-95 Rickhi    Created
//              10-Mar-95 BillMo    Added OleGetShellLink-creates a shortcut object.
//              12-Jul-95 t-stevan  Added OleSym* routines
//              22-Nov-95 MikeHill  Use Unicode IShellLink object in NT.
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <shellapi.h>
#include    <imagehlp.h>
#include    <ole2sp.h>
#include    <ole2com.h>

#ifdef _CAIRO_
#include    <shlguid.h>
#endif

// Entry Points from MPR.DLL
HINSTANCE                hInstMPR = NULL;

typedef DWORD (* PFN_WNETGETCONNECTION)(LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength);
PFN_WNETGETCONNECTION    pfnWNetGetConnection = NULL;

#ifdef _CHICAGO_
#define WNETGETCONNECTION_NAME     "WNetGetConnectionA"
#else
#define WNETGETCONNECTION_NAME     "WNetGetConnectionW"
#define WNETGETUNIVERSALNAME_NAME  "WNetGetUniversalNameW"
typedef DWORD (* PFN_WNETGETUNIVERSALNAME)(LPCWSTR szLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize);
PFN_WNETGETUNIVERSALNAME pfnWNetGetUniversalName = NULL;
#endif


// Entry Points from GDI32p.DLL
#ifndef _CHICAGO_
HINSTANCE                hInstGDI32p = NULL;

typedef HBRUSH (* PFN_GDICONVERTBRUSH)(HBRUSH hbrush);
typedef HBRUSH (* PFN_GDICREATELOCALBRUSH)(HBRUSH hbrushRemote);
PFN_GDICONVERTBRUSH                     pfnGdiConvertBrush = NULL;
PFN_GDICREATELOCALBRUSH         pfnGdiCreateLocalBrush = NULL;

#define GDICONVERTBRUSH_NAME       "GdiConvertBrush"
#define GDICREATELOCALBRUSH_NAME   "GdiCreateLocalBrush"
#endif

#ifdef _TRACKLINK_

#ifndef _CAIRO_   // !_CAIRO_
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
DEFINE_SHLGUID(CLSID_ShellLink,         0x00021401L, 0, 0);
#ifdef _CHICAGO_
DEFINE_SHLGUID(IID_IShellLink,          0x000214EEL, 0, 0);
#else
DEFINE_SHLGUID(IID_IShellLink,          0x000214F9L, 0, 0);
#endif // _CHICAGO_
#undef DEFINE_GUID
#endif // !_CAIRO_

IClassFactory *g_pcfShellLink = NULL;
#endif // _TRACKLINK_

#ifdef _CAIRO_
HINSTANCE       hDsys = NULL;
#endif

// Entry Points from SHELL32.DLL
HINSTANCE                hInstSHELL32 = NULL;

typedef HICON (* PFN_EXTRACTICON)(HINSTANCE hInst, LPCTSTR szExeName, UINT nIconIndex);
PFN_EXTRACTICON          pfnExtractIcon = NULL;
#ifdef _CHICAGO_
#define EXTRACTICON_NAME "ExtractIconA"
#else
#define EXTRACTICON_NAME "ExtractIconW"
#endif

typedef HICON (* PFN_EXTRACTASSOCIATEDICON)(HINSTANCE hInst, LPCTSTR szExeName,
            LPWORD pIndex);
PFN_EXTRACTASSOCIATEDICON        pfnExtractAssociatedIcon = NULL;

#ifdef _CHICAGO_
#define EXTRACTASSOCIATEDICON_NAME "ExtractAssociatedIconA"
#else
#define EXTRACTASSOCIATEDICON_NAME "ExtractAssociatedIconW"
#endif

typedef DWORD (* PFN_SHGETFILEINFO)(LPCTSTR pszPath, DWORD dwFileAttributes,
              SHFILEINFO FAR *psfi, UINT cbFileInfo, UINT uFlags);
PFN_SHGETFILEINFO        pfnSHGetFileInfo = NULL;

#ifdef _CHICAGO_
#define SHGETFILEINFO_NAME "SHGetFileInfoA"
#else
#define SHGETFILEINFO_NAME "SHGetFileInfoW"
#endif

// Entry Points from IMAGEHLP.DLL
HINSTANCE                       hInstIMAGEHLP = NULL;

typedef BOOL (*PFN_SYMINITIALIZE)(HANDLE hProcess, LPSTR UserSearchPath,
                                BOOL fInvadeProcess);
PFN_SYMINITIALIZE pfnSymInitialize = NULL;

#define SYMINITIALIZE_NAME "SymInitialize"

typedef BOOL (*PFN_SYMCLEANUP)(HANDLE hProcess);
PFN_SYMCLEANUP pfnSymCleanup = NULL;

#define SYMCLEANUP_NAME "SymCleanup"

typedef BOOL (*PFN_SYMGETSYMFROMADDR)(HANDLE hProcess,
                                DWORD64 dwAddr, PDWORD64 pdwDisplacement, PIMAGEHLP_SYMBOL64 pSym);
PFN_SYMGETSYMFROMADDR pfnSymGetSymFromAddr64 = NULL;

#define SYMGETSYMFROMADDR_NAME "SymGetSymFromAddr64"

typedef BOOL (*PFN_SYMUNDNAME)(PIMAGEHLP_SYMBOL64 sym, LPSTR lpname, DWORD dwmaxLength);
PFN_SYMUNDNAME pfnSymUnDName64 = NULL;

#define SYMUNDNAME_NAME "SymUnDName64"

//+---------------------------------------------------------------------------
//
//  Function:   LoadSystemProc
//
//  Synopsis:   Loads the specified DLL if necessary and finds the specified
//              entry point.
//
//  Returns:    0: the entry point function ptr is valid
//              !0: the entry point function ptr is not valid
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
BOOL LoadSystemProc(LPSTR szDll, LPCSTR szProc,
                    HINSTANCE *phInst, FARPROC *ppfnProc)
{
    if (*phInst == NULL)
    {

        // Dll not loaded yet, load it now.
        if ((*phInst = LoadLibraryA(szDll)) == NULL)
            return GetLastError();
    }

    // load the entry point
    if ((*ppfnProc = GetProcAddress(*phInst, szProc)) == NULL)
        return GetLastError();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeSystemDLLs
//
//  Synopsis:   Frees any system Dlls that we dynamically loaded.
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
void FreeSystemDLLs()
{
    if (hInstMPR)
        FreeLibrary(hInstMPR);

    if (hInstSHELL32)
        FreeLibrary(hInstSHELL32);

#ifndef _CHICAGO_
    if (hInstGDI32p)
        FreeLibrary(hInstGDI32p);
#endif // _CHICAGO_

#ifdef _CAIRO_
    if (hDsys)
            FreeLibrary(hDsys);
#endif // _CAIRO_

        if(hInstIMAGEHLP != NULL && hInstIMAGEHLP != INVALID_HANDLE_VALUE)
        {
                FreeLibrary(hInstIMAGEHLP);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   OleWNetGetConnection
//
//  Synopsis:   OLE internal implementation of WNetGetConnection
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
DWORD OleWNetGetConnection(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
{
    if (pfnWNetGetConnection == NULL)
    {
        DWORD rc = LoadSystemProc("MPR.DLL", WNETGETCONNECTION_NAME,
                          &hInstMPR, (FARPROC *)&pfnWNetGetConnection);
        if (rc != 0)
            return rc;
    }

#ifdef _CHICAGO_
    // For Chicago we need to do the Unicode to Ansi conversions.

    CHAR  szRemote[MAX_PATH];
    CHAR  szLocal[MAX_PATH];

    WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, lpLocalName, -1, szLocal, MAX_PATH, NULL, NULL);

    DWORD rc = (pfnWNetGetConnection)(szLocal, szRemote, lpnLength);

    if (rc == NO_ERROR)
    {
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szRemote, -1, lpRemoteName, lstrlenA(szRemote)+1);
    }

    return rc;
#else

    return (pfnWNetGetConnection)(lpLocalName, lpRemoteName, lpnLength);

#endif
}

#ifndef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   OleWNetGetUniversalName
//
//  Synopsis:   OLE internal implementation of WNetGetUniversalName
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
DWORD OleWNetGetUniversalName(LPCWSTR szLocalPath, DWORD dwInfoLevel,
                              LPVOID lpBuffer, LPDWORD lpBufferSize)
{
    if (pfnWNetGetUniversalName == NULL)
    {
        DWORD rc = LoadSystemProc("MPR.DLL", WNETGETUNIVERSALNAME_NAME,
                          &hInstMPR, (FARPROC *)&pfnWNetGetUniversalName);
        if (rc != 0)
            return rc;
    }

    return (pfnWNetGetUniversalName)(szLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
}
#endif


#ifndef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   OleGdiConvertBrush
//
//  Synopsis:   OLE internal implementation of GdiConvertBrush
//
//  History:    7-Feb-95   GregJen      Created
//
//----------------------------------------------------------------------------
HBRUSH OleGdiConvertBrush(HBRUSH hbrush)
{
    if (pfnGdiConvertBrush == NULL)
    {
        DWORD rc = LoadSystemProc("GDI32P.DLL", GDICONVERTBRUSH_NAME,
                          &hInstGDI32p, (FARPROC *)&pfnGdiConvertBrush);
        if (rc != 0)
            return NULL;
    }

    return (pfnGdiConvertBrush)(hbrush);
}
#endif


#ifndef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   OleGdiCreateLocalBrush
//
//  Synopsis:   OLE internal implementation of GdiConvertBrush
//
//  History:    7-Feb-95   GregJen      Created
//
//----------------------------------------------------------------------------
HBRUSH OleGdiCreateLocalBrush(HBRUSH hbrushRemote)
{
    if (pfnGdiCreateLocalBrush == NULL)
    {
        DWORD rc = LoadSystemProc("GDI32P.DLL", GDICREATELOCALBRUSH_NAME,
                          &hInstGDI32p, (FARPROC *)&pfnGdiCreateLocalBrush);
        if (rc != 0)
            return NULL;
    }

    return (pfnGdiCreateLocalBrush)(hbrushRemote);
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   OleExtractIcon
//
//  Synopsis:   OLE internal implementation of ExtractIcon
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
HICON OleExtractIcon(HINSTANCE hInst, LPCWSTR wszExeName, UINT nIconIndex)
{
    if (pfnExtractIcon == NULL)
    {
        DWORD rc = LoadSystemProc("SHELL32.DLL", EXTRACTICON_NAME,
                          &hInstSHELL32, (FARPROC *)&pfnExtractIcon);
        if (rc != 0)
            return NULL;
    }

#ifdef _CHICAGO_
    // For Chicago, we need to do the Unicode to Ansi conversion

    CHAR    szExeName[MAX_PATH];
    WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wszExeName, -1, szExeName, MAX_PATH, NULL, NULL);

    return (pfnExtractIcon)(hInst, szExeName, nIconIndex);
#else
    return (pfnExtractIcon)(hInst, wszExeName, nIconIndex);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   OleExtractAssociatedIcon
//
//  Synopsis:   OLE internal implementation of ExtractIcon
//
//  History:    225-Jan-95   Alexgo     Created
//
//----------------------------------------------------------------------------
HICON OleExtractAssociatedIcon(HINSTANCE hInst, LPCWSTR pszFileName,
        LPWORD pIndex)
{
    if (pfnExtractAssociatedIcon == NULL)
    {
        DWORD rc = LoadSystemProc("SHELL32.DLL", EXTRACTASSOCIATEDICON_NAME,
                          &hInstSHELL32,
                          (FARPROC *)&pfnExtractAssociatedIcon);
        if (rc != 0)
            return NULL;
    }

#ifdef _CHICAGO_
    // For Chicago, we need to do the Unicode to Ansi conversion

    CHAR    szFileName[MAX_PATH];
    WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, pszFileName, -1, szFileName, MAX_PATH, NULL, NULL);

    return (pfnExtractAssociatedIcon)(hInst, szFileName, pIndex);
#else
    return (pfnExtractAssociatedIcon)(hInst, pszFileName, pIndex);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSHGetFileInfo
//
//  Synopsis:   OLE internal implementation of ExtractIcon
//
//  History:    02-Feb-95   Scottsk     Created
//
//----------------------------------------------------------------------------
DWORD  OleSHGetFileInfo(LPCWSTR pszPath, DWORD dwFileAttributes,
            SHFILEINFO FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
    if (pfnSHGetFileInfo == NULL)
    {
        DWORD rc = LoadSystemProc("SHELL32.DLL", SHGETFILEINFO_NAME,
                          &hInstSHELL32,
                          (FARPROC *)&pfnSHGetFileInfo);
        if (rc != 0)
            return NULL;
    }

// this nested #ifdef is here so that when this functinality is available
// on NT, simply removing the outer #ifdef will do the right thing.
#ifdef _CHICAGO_
    // For Chicago, we need to do the Unicode to Ansi conversion

    CHAR    szPath[MAX_PATH];

    WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, pszPath, -1, szPath, MAX_PATH, NULL, NULL);

    return (pfnSHGetFileInfo)(szPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
#else
    return (pfnSHGetFileInfo)(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   OleGetShellLink
//
//  Synopsis:   Get an instance of the shell's shell link object.
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
VOID * OleGetShellLink()
{
    HRESULT hr;
    VOID *pShellLink;

    if (g_pcfShellLink == NULL)
    {
        LPFNGETCLASSOBJECT pfn;
        DWORD rc = LoadSystemProc("SHELL32.DLL", "DllGetClassObject",
                          &hInstSHELL32,
                          (FARPROC *)&pfn);
        if (rc != 0)
            return NULL;

        hr = (*pfn)(CLSID_ShellLink, IID_IClassFactory, (void**)&g_pcfShellLink);

        if (hr != S_OK)
        {
	   if (hInstSHELL32)
	   {
	      FreeLibrary(hInstSHELL32);
	      hInstSHELL32 = NULL;
	   }

            return(NULL);
        }
    }

    Win4Assert(g_pcfShellLink != NULL);

    hr = g_pcfShellLink->CreateInstance(NULL, IID_IShellLink, &pShellLink);

    return(hr == S_OK ? pShellLink : NULL);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   OleSymInitialize
//
//  Synopsis:   OLE internal implementation of SymInitialize
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymInitialize(HANDLE hProcess,  LPSTR UserSearchPath,
                                                                BOOL fInvadeProcess)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return FALSE;
        }

    if (pfnSymInitialize == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMINITIALIZE_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymInitialize);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return FALSE;
                }
    }

    return (pfnSymInitialize)(hProcess, UserSearchPath, fInvadeProcess);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymCleanup
//
//  Synopsis:   OLE internal implementation of SymCleanup
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymCleanup(HANDLE hProcess)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return FALSE;
        }

    if (pfnSymCleanup == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMCLEANUP_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymCleanup);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return FALSE;
                }
    }

    return (pfnSymCleanup)(hProcess);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymGetSymFromAddr
//
//  Synopsis:   OLE internal implementation of SymGetSymFromAddr
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymGetSymFromAddr(HANDLE hProcess, DWORD64 dwAddr, PDWORD64 pdwDisplacement, PIMAGEHLP_SYMBOL64 pSym)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return NULL;
        }

    if (pfnSymGetSymFromAddr64 == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMGETSYMFROMADDR_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymGetSymFromAddr64);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return NULL;
                }
    }

    return (pfnSymGetSymFromAddr64)(hProcess, dwAddr, pdwDisplacement, pSym);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymUnDName
//
//  Synopsis:   OLE internal implementation of SymUnDName
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymUnDName(PIMAGEHLP_SYMBOL64 pSym, LPSTR lpname, DWORD dwmaxLength)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return FALSE;
        }

    if (pfnSymUnDName64 == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMUNDNAME_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymUnDName64);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return FALSE;
            }
    }

    return (pfnSymUnDName64)(pSym, lpname, dwmaxLength);
}

#ifdef _CAIRO_
//+---------------------------------------------------------------------------
//
//  Function:   GetHandleServerInfo, public
//
//  Synopsis:   Wrapper for DfsGetHandleServerInfo
//
//  Arguments:  same as DfsGetHandleServerInfo
//
//  Returns:    Appropriate status code
//
//  History:    06-Nov-95    Henrylee   created
//
//----------------------------------------------------------------------------

STDAPI GetHandleServerInfo(
    IN HANDLE hFile,
    IN OUT LPWSTR lpServerName,
    IN OUT LPDWORD lpcbServerName,
    IN OUT LPWSTR lpReplSpecificPath,
    IN OUT LPDWORD lpcbReplSpecificPath)
{
    static (*pDfsGetHandleServerInfo)  (HANDLE,
             LPWSTR, LPDWORD, LPWSTR, LPDWORD) = NULL;

    if (hDsys == NULL || pDfsGetHandleServerInfo == NULL)
    {
        DWORD dw = LoadSystemProc ("DSYS.DLL", "DfsGetHandleServerInfo",
                    &hDsys, (FARPROC *) &pDfsGetHandleServerInfo);

        if (dw != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32 (dw);
        }
    }
    
    return (*pDfsGetHandleServerInfo) (hFile,
            lpServerName,
            lpcbServerName,
            lpReplSpecificPath,
            lpcbReplSpecificPath);
}
#endif // _CAIRO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\olescm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olescm.cxx
//
//  Contents:   Functions shared between OLE32 and the SCM
//
//  Classes:
//
//  Functions:
//
//  History:    10-03-95   kevinro   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>

static const WCHAR wszOle32Dll[] = L"OLE32.DLL";

#define OLE32_DLL wszOle32Dll
#define OLE32_BYTE_LEN sizeof(OLE32_DLL)
#define OLE32_CHAR_LEN (sizeof(OLE32_DLL) / sizeof(WCHAR) - 1)

//
// Threading Model Registry Constants
//

const WCHAR wszDllThreadModel[] = L"ThreadingModel";

const WCHAR wszAptModel[]       = L"Apartment";
const WCHAR wszBothModel[]      = L"Both";
const WCHAR wszFreeModel[]      = L"Free";
const WCHAR wszNeutralModel[]   = L"Neutral";

// Thread model match table. The table's first index is the threading
// model of the process and can be either APT_THREADED or
// FREE_THREADED. The second index is any one of the types of threading
// model's for DLLs.
BOOL afThreadModelMatch[2][4] =
    {{TRUE, FALSE, TRUE, TRUE},
     {FALSE, TRUE, FALSE, TRUE}};

//+---------------------------------------------------------------------------
//
//  Function:   CompareDllName
//
//  Synopsis:   Give a DLL path, this sees if the path is equal to a given
//              DLL name or the last component of the is the same as the
//              DLL name.
//
//  Arguments:  [pwszPath] -- DLL path
//              [pwszDllName] -- name of DLL to compare with
//
//  Returns:    TRUE - The input path is equal or its last component is equal
//                     to the input Dll name.
//              FALSE - Not equal at all.
//
//  History:    6-15-95   ricksa    Created
//
//  Notes:      This is a helper function used by the routines that convert
//              ole2.dll to ole32.dll and to convert paths that end in ole32.dll
//              into ole32.dll.
//
//----------------------------------------------------------------------------
BOOL
wCompareDllName(LPCWSTR pwszPath, LPCWSTR pwszDllName, DWORD dwDllNameLen)
{
    BOOL fResult = TRUE;

    if (lstrcmpiW(pwszDllName, pwszPath) != 0)
    {
        // Check if the last component is the same path
        DWORD dwPathLen = lstrlenW(pwszPath);

        if (dwPathLen > dwDllNameLen)
        {
            // Point to the last where the slash would be if the substitute
            // path is the last component
            LPCWSTR pwszLastComponent = pwszPath + dwPathLen - (dwDllNameLen + 1);

            // Is there a slash in that position
            if ((*pwszLastComponent == '\\') || (*pwszLastComponent == '/'))
            {
                // Point to where the last component should be
                pwszLastComponent++;

                // Does the last component match?
                if (lstrcmpiW(pwszLastComponent, pwszDllName) == 0)
                {
                    goto CompareDllName_Exit;
                }
            }
        }

        fResult = FALSE;
    }

CompareDllName_Exit:

    return fResult;
}

//+-------------------------------------------------------------------------
//
//  Function:   wThreadModelMatch
//
//  Synopsis:   Determines whether caller and DLL thread models match
//
//  Arguments:  [dwCallerThreadModel] - Caller thread model
//              [dwDllThreadModel] - DLL thread model
//
//  Returns:    TRUE - DLL can be loaded caller
//              FALSE - DLL cannot be loaded into caller.
//
//  Algorithm:  If the caller's thread model is apartment, then check
//              whether the DLL is one of apartment, single threaded or
//              both threaded. If it is, then return TRUE. Otherwise,
//              for free threading return TRUE if the DLL model is either
//              both or free threaded. If neither of the above is TRUE
//              then return FALSE.
//
//  History:    10-Nov-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL wThreadModelMatch(
    DWORD dwCallerThreadModel,
    DWORD dwDllThreadModel,
    DWORD dwContext)
{
    BOOL fResult = afThreadModelMatch[dwCallerThreadModel] [dwDllThreadModel];

    if (dwContext & CLSCTX_PS_DLL)
    {
        fResult = TRUE;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//
//  Function:   wQueryStripRegValue
//
//  Synopsis:   Get the DLL information for a 32 bit DLL and
//              strip off any leading and trailing "
//
//  Arguments:  [hkey] - class handle
//              [pwszSubKey] - key to open
//              [pwszValue] - where to return data
//              [pcbValue] - length of above buffer in bytes
//
//  Returns:    ERROR_SUCCESS - read DLL path information
//              Other - registry entries could not be found
//
//  Algorithm:  Read the value requested.
//              If first character is not ", exit
//              Otherwise, copy data after quote to beginning of buffer.
//
//
//  History:    05-Jan-94 BillMo     Created
//              26-Sep-95 BruceMa    Support environment variable expansion
//                                    for shell viewers
//
//--------------------------------------------------------------------------

LONG
wQueryStripRegValue(HKEY    hKey,        // handle of key to query
                    LPCWSTR pwszSubKey, // address of name of subkey to query
                    LPWSTR  pwszValue,  // address of buffer for returned string
                    PLONG   pcbValue)    // address of buffer for size of returned string
{
    HKEY  hSubKey;
    DWORD dwType;
    LONG  lErr ;

    Win4Assert(pwszValue != NULL);
    Win4Assert(pcbValue != NULL);

    //
    // Open the subkey if there is a string
    //
    if (pwszSubKey != NULL)
    {
        lErr = RegOpenKeyExW(hKey, pwszSubKey, NULL, KEY_READ, &hSubKey);
    }
    else
    {
        hSubKey = hKey;
        lErr = ERROR_SUCCESS;
    }

    // Read the value into the user's buffer
    if (lErr == ERROR_SUCCESS)
    {
        lErr = RegQueryValueExW(hSubKey, NULL , NULL, &dwType,
                               (BYTE *) pwszValue, (ULONG *) pcbValue);
        if (lErr == ERROR_SUCCESS)
        {
            WCHAR *pwszScan = pwszValue;        // used to scan along string
            WCHAR *pwszDest = pwszValue;        // used as destination when copying

            // if the name is quoted then ...
            if (*pwszScan == '\"')
            {
                pwszScan++;

                // copy all non-quote characters down to base of buffer
                // until end of quoted string
                while (*pwszScan != '\0' && *pwszScan != '\"')
                {
                    *pwszDest++ = *pwszScan++;
                }

                // terminate string and get length in bytes including nul
                *pwszDest++ = '\0';
                *pcbValue = (int)(pwszDest - pwszValue) * sizeof(WCHAR);
            }

            // find first non-white space character
            pwszScan = pwszValue;
            while (_istspace(*pwszScan))
                pwszScan++;

            // if there are no non-white space characters this will be true
            if (*pwszScan == L'\0')
            {
                lErr = ERROR_FILE_NOT_FOUND;
                *pcbValue = 0;
            }

            // Chicago does not support ExpandEnvironmentStrings
#ifndef _CHICAGO_
            // If the value type is REG_EXPAND_SZ then do environment variable
            // expansion
            if (dwType == REG_EXPAND_SZ)
            {
                // Expand any embedded environemnt variable expressions
                WCHAR wszTemp[MAX_PATH];

                lstrcpyW(wszTemp, pwszValue);
                *pcbValue = ExpandEnvironmentStrings(wszTemp, pwszValue,MAX_PATH);
            }
#endif // !_CHICAGO_
        }

        //
        // Only close the sub key if we actually opened it.
        //
        if (hSubKey != hKey)
        {
            RegCloseKey(hSubKey);
        }

    }
    return lErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDllInfo
//
//  Synopsis:   Get the DLL information for a 32 bit DLL
//
//  Arguments:  [hClsRegEntry] - class handle
//              [pwszKey] - key to open
//              [pwszDllName] - where to return DLL path
//              [pclDllName] - length of above buffer
//              [pulDllThreadType] - where to return DLL threading information
//
//  Returns:    ERROR_SUCCESS - read DLL path information
//              Other - registry entries could not be found
//
//  Algorithm:  Open the DLL key. Then read the DLL path name. Finally read
//              the threading model information if it is specified.
//
//  History:    09-Nov-94 Ricksa    Created
//
//--------------------------------------------------------------------------
LONG wGetDllInfo(
    HKEY     hClsRegEntry,
    LPCWSTR  pwszKey,
    LPWSTR   pwszDllName,
    LONG*    pclDllName,
    ULONG*   pulDllThreadType)
{
    HKEY hDllEntry = NULL;

    //
    // Attempt to open the specified registry key.
    //
    
    LONG lerr = RegOpenKeyW(hClsRegEntry, pwszKey, &hDllEntry);
    if (ERROR_SUCCESS == lerr)
    {
        //
        // Try to read the DLL name.
        //
        
        lerr = wQueryStripRegValue(hDllEntry, NULL, pwszDllName, pclDllName);
        if (ERROR_SUCCESS == lerr)
        {
            //
            // A DLL name is registered.  If the DLL is OLE32.DLL, then we
            // know all about and don't have to dig more info from the
            // the registry.  Otherwise, we do need to keep digging.
            //
            
            if (wCompareDllName(pwszDllName, OLE32_DLL, OLE32_CHAR_LEN))
            {
                memcpy(pwszDllName, OLE32_DLL, OLE32_BYTE_LEN);
                *pclDllName       = OLE32_CHAR_LEN;
                *pulDllThreadType = BOTH_THREADED;
            }
            else
            {
                //
                // Assume there is no registry entry.
                //
                
                *pulDllThreadType = SINGLE_THREADED;

                //
                // Buffer to hold entry for the registry data.
                //
                
                WCHAR wszModelBuf[MAX_PATH];
                DWORD cdwModelBuf = sizeof(wszModelBuf);
                DWORD dwRegEntType;

                //
                // Read the DLL threading model from the registry.
                //

                lerr = RegQueryValueExW(hDllEntry, 
                                        wszDllThreadModel, 
                                        NULL,
                                        &dwRegEntType, 
                                        (LPBYTE) &wszModelBuf[0], 
                                        &cdwModelBuf);

                //
                // If there is a thread model descriptor, set the thread
                // type accordingly.
                //
                
                if (ERROR_SUCCESS == lerr)
                {
                    if (REG_SZ != dwRegEntType)
                    {
		       Win4Assert(L"ThreadingModel Key Type incorrect");
		    }                    
                    else if (0 == lstrcmpiW(wszAptModel, wszModelBuf))
                    {
                        //
                        // An APARTMENT model object.
                        //
                        
                        *pulDllThreadType = APT_THREADED;
                    }                    
                    else if (0 == lstrcmpiW(wszBothModel, wszModelBuf))
                    {
                        //
                        // A BOTH model object.
                        //
                        
                        *pulDllThreadType = BOTH_THREADED;
                    }
                    else if (lstrcmpiW(wszFreeModel, wszModelBuf) == 0)
                    {
                        //
                        // A FREE_THREADED model object.
                        //
                        
                        *pulDllThreadType = FREE_THREADED;
                    }
                    else if (0 == lstrcmpiW(wszNeutralModel, wszModelBuf))
                    {
                        //
                        // A NEUTRAL_THREADED object.
                        //
                        
                        *pulDllThreadType = NEUTRAL_THREADED;
                    }
                    else
                    {
		       Win4Assert(L"ThreadingModel Value incorrect");
                    }
                }

                //
                // When we get to this point, we got a DLL entry so we remap
                // any errors to success because they only mean that we could
                // not get a model from the registry.
                //
                
                lerr = ERROR_SUCCESS;
            }
        }
        
        RegCloseKey(hDllEntry);
    }

    return lerr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\olesem.cxx ===
//+---------------------------------------------------------------------------
//
//  File:       olesem.cxx
//
//  Contents:   Implementation of semaphore classes for use in OLE code
//
//  Functions:  COleStaticMutexSem::Destroy
//              COleStaticMutexSem::Request
//              COleStaticMutexSem::Init
//              COleDebugMutexSem::COleDebugMutexSem
//
//  History:    14-Dec-95       Jeffe   Initial entry, derived from
//                                      sem32.hxx by AlexT.
//
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <debnot.h>
#include <olesem.hxx>



//
//      Global state for the mutex package
//

//
//      List of initialized static mutexes (which must be destroyed
//      during DLL exit). We know that PROCESS_ATTACH and PROCESS_DETACH
//      are thread-safe, so we don't protect this list with a critical section.
//

COleStaticMutexSem * g_pInitializedStaticMutexList = NULL;

#if DBG

//
//      Flag used to indicate if we're past executing the C++ constructors
//      during DLL initialization
//

DLL_STATE g_fDllState = DLL_STATE_STATIC_CONSTRUCTING;

#endif






//
//      Semaphore used to protect the creation of other semaphores
//

CRITICAL_SECTION g_OleMutexCreationSem;

//
//      Critical section used as the backup lock when a COleStaticMutexSem
//      cannot be faulted in.
//

CRITICAL_SECTION g_OleGlobalLock;


//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Destroy
//
//  Synopsis:   Releases a semaphore's critical section.
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
void COleStaticMutexSem::Destroy()
{
#if LOCK_PERF==1
    gLockTracker.ReportContention(this, _cs.LockCount, _cs.DebugInfo->ContentionCount, 0 , 0);  //entry,contention counts for writes & reads.
#endif
    if (_fInitialized)
    {
        DeleteCriticalSection (&_cs);
        _fInitialized = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::FastRequest
//
//  Synopsis:   Acquire the semaphore without checking to see if it's
//              initialized. If another thread already has it,
//              wait until it is released.
//
//  History:    14-Dec-1995     Jeffe
//
//  Notes:      You may only use this method on code paths where you're
//              *certain* the semaphore has already been initialized (either
//              by invoking Init, or by calling the Request method).
//              These version's of FastRequest are for debug builds.  The
//              version's for retail builds are inline and are found in
//              olesem.hxx
//
//----------------------------------------------------------------------------
#if DBG==1 || LOCK_PERF==1
void COleStaticMutexSem::FastRequest(const char *pszFile, DWORD dwLine, const char *pszLockName)
{
    Win4Assert (_fInitialized && "You must use Request here, not FastRequest");

#if LOCK_PERF==1
    gLockTracker.WriterWaiting(pszFile, dwLine, pszLockName, this);
#endif

    if (!_fUsingGlobal)
        EnterCriticalSection (&_cs);
    else
        EnterCriticalSection (&g_OleGlobalLock);

#if LOCK_PERF==1
    gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this);
#endif

    Win4Assert(((_dwTid == 0 && _cLocks == 0) || (_dwTid == GetCurrentThreadId() && _cLocks > 0)) && "Inconsistent state!");
    Win4Assert(!(_fTakeOnce && _cLocks > 1) && "Lock taken more than once on same thread.");
    _dwTid = GetCurrentThreadId();
    _cLocks++;
    _pszFile = pszFile;
    _dwLine  = dwLine;
}


void COleStaticMutexSem::FastRequest()
{
    FastRequest("Unknown File", 0L ,"Unknown Lock");
}
#endif //DBG==1 || LOCK_PERF==1


//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Request
//
//  Synopsis:   Acquire the semaphore. If another thread already has it,
//              wait until it is released. Initialize the semaphore if it
//              isn't already initialized.
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
#if DBG==1 || LOCK_PERF==1
void COleStaticMutexSem::Request(const char *pszFile, DWORD dwLine, const char *pszLockName)
{
    if (!_fInitialized && !_fUsingGlobal)
    {
        EnterCriticalSection (&g_OleMutexCreationSem);
        if (!_fInitialized && !_fUsingGlobal) {
            Init();
            if (!_fInitialized) _fUsingGlobal = TRUE;
        }
        LeaveCriticalSection (&g_OleMutexCreationSem);
    }

#if LOCK_PERF==1
    gLockTracker.WriterWaiting(pszFile, dwLine, pszLockName, this);
#endif

    // What do we do if either of these fail?
    if (!_fUsingGlobal)
        EnterCriticalSection (&_cs);
    else
        EnterCriticalSection (&g_OleGlobalLock);

#if LOCK_PERF==1
    gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this); //the tracker takes cares of recursive Lock calls.
#endif

    Win4Assert((((_dwTid == 0 && _cLocks == 0) || (_dwTid == GetCurrentThreadId() && _cLocks > 0)) ||
                (g_fDllState == DLL_STATE_PROCESS_DETACH)) &&
               "Inconsistent State!");
    Win4Assert(!(_fTakeOnce && _cLocks > 1) && "Lock taken more than once on same thread.");

    if(_dwTid != GetCurrentThreadId())
    {
        _cLocks = 0;
        _dwTid  = GetCurrentThreadId();
    }

    // only stamp the file on the
    // 0 -> 1 transition
    if (++_cLocks == 1)
    {
        _pszFile = pszFile;
        _dwLine  = dwLine;
    }
}
#endif  //DBG==1 || LOCK_PERF==1

void COleStaticMutexSem::Request()
{
#if DBG==1 || LOCK_PERF==1
    Request("Unknown File", 0L,"Unknown Lock");
#else
    if (!_fInitialized && !_fUsingGlobal)
    {
        EnterCriticalSection (&g_OleMutexCreationSem);
        if (!_fInitialized && !_fUsingGlobal)
        {
            Init();
            if (!_fInitialized) _fUsingGlobal = TRUE;
        }
        LeaveCriticalSection (&g_OleMutexCreationSem);
    }

    if (!_fUsingGlobal)
        EnterCriticalSection (&_cs);
    else
        EnterCriticalSection (&g_OleGlobalLock);
#endif
}


//+---------------------------------------------------------------------------
//
// Member:      COleStaticMutexSem::AssertHeld
//
// Synopsis:    Check to see if this thread owns the lock, and optionally owns
//              cLocks amount of locks. If not raise an assertion warning.
//
// History:     16-Aug-1996     mattsmit
//
// Notes:       Debug builds only
//----------------------------------------------------------------------------
#if DBG==1
void COleStaticMutexSem::AssertHeld(DWORD cLocks)
{
    Win4Assert(_dwTid == GetCurrentThreadId() && "Lock not held by current thread.");

    if (cLocks == 0)
    {
        Win4Assert(_cLocks > 0 && "Lock held by thread with a nonpositive lock count");
    }
    else
    {
        Win4Assert(_cLocks == cLocks && "Incorrect amount of locks");
    }
}
#endif


//+---------------------------------------------------------------------------
//
// Member:      COleStaticMutexSem::AssertNotHeld
//
// Synopsis:    Check to see if this does not thread own the lock. If it does,
//              raise an assertion warning.
//
// History:     16-Aug-1996     mattsmit
//
// Notes:       Debug builds only
//----------------------------------------------------------------------------
#if DBG==1
void COleStaticMutexSem::AssertNotHeld()
{
    Win4Assert(_dwTid != GetCurrentThreadId() && "Lock held by current thread.");
}
#endif


//+---------------------------------------------------------------------------
//
// Member:      COleStaticMutexSem::AssertTakenOnlyOnce
//
// Synopsis:    Turn on flag to insure this lock is taken only once
//
// History:     16-Aug-1996     mattsmit
//
// Notes:       Debug builds only
//----------------------------------------------------------------------------
#if DBG==1
void COleStaticMutexSem::AssertTakenOnlyOnce()
{
    _fTakeOnce = TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Init
//
//  Synopsis:   Initialize semaphore's critical section
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
HRESULT COleStaticMutexSem::Init()
{
    NTSTATUS status;

    if (_fInitialized)
        return S_OK;

    if (_fUseSpincount)
    {
        DWORD dwSpincount = 500;
        SYSTEM_BASIC_INFORMATION si = {0};
        status = NtQuerySystemInformation(SystemBasicInformation,&si,sizeof(si),NULL);
        if (NT_SUCCESS(status))
            dwSpincount *= si.NumberOfProcessors;

        status = RtlInitializeCriticalSectionAndSpinCount(&_cs, dwSpincount);
    }
    else
    {
        status = RtlInitializeCriticalSection (&_cs);
    }

    _fInitialized = NT_SUCCESS(status);
    if (!_fAutoDestruct)
    {
        //
        //  We don't need to protect this list with a mutex, since it's only
        //  manipulated during DLL attach/detach, which is single threaded by
        //  the platform.
        //

        pNextMutex = g_pInitializedStaticMutexList;
        g_pInitializedStaticMutexList = this;
    }
#if LOCK_PERF==1
    gLockTracker.RegisterLock(this, FALSE /*bReadWrite*/);
#endif

    if (NT_SUCCESS(status))
        return S_OK;
    else
        return HRESULT_FROM_WIN32(status);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Release
//
//  Synopsis:   Release the semaphore.
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
#if DBG==1 || LOCK_PERF==1
void COleStaticMutexSem::Release()
{
    AssertHeld();
    if (--_cLocks == 0)
    {
        Win4Assert((_cContinuous == 0) ||
                   (g_fDllState == DLL_STATE_PROCESS_DETACH));

        _dwTid = 0;
        Win4Assert(_cContinuous==0);
    }
#if LOCK_PERF==1
    gLockTracker.WriterLeaving(this);
#endif
    if (!_fUsingGlobal)
        LeaveCriticalSection (&_cs);
    else
        LeaveCriticalSection (&g_OleGlobalLock);
}
#endif // DBG==1 || LOCK_PERF==1

#ifdef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::ReleaseFn
//
//  Synopsis:   Release the semaphore(non inline version) used only by rpccall.asm
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
void COleStaticMutexSem::ReleaseFn()
{
#if DBG==1
    AssertHeld();
    if (--_cLocks == 0)
    {
        _dwTid = 0;
    }
#endif

    if (!_fUsingGlobal)
        LeaveCriticalSection (&_cs);
    else
        LeaveCriticalSection (&g_OleGlobalLock);
}
#endif



#if DBG==1

//+---------------------------------------------------------------------------
//
//  Member:     COleDebugMutexSem::COleDebugMutexSem
//
//  Synopsis:   Mark the mutex as dynamic...which will prevent it from being
//              added to the static mutex cleanup list on DLL unload.
//
//  History:    14-Dec-1995     Jeffe
//
//  Notes:      We don't care that this has a constructor, as it won't be run
//              in retail builds.
//
//----------------------------------------------------------------------------
COleDebugMutexSem::COleDebugMutexSem()
{
    Win4Assert (g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);
    _fAutoDestruct = TRUE;
    _fInitialized = FALSE;
}

#endif // DBG==1


//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::CMutexSem2
//
//  Synopsis:   Mutex semaphore constructor. This is a 2-phase constructed object.
//             You must call CMutexSem2::Init to fully initialize the object.
//
//  Effects:    Initializes the semaphores data
//
//  History:    19-Mar-01    danroth    Created.
//
//----------------------------------------------------------------------------

CMutexSem2::CMutexSem2(void) : m_fCsInitialized(FALSE)
{
}

BOOL CMutexSem2::FInit()
{
    if (m_fCsInitialized == FALSE) // guard against re-entry
    {
        NTSTATUS status = RtlInitializeCriticalSection(&m_cs);
        if (NT_SUCCESS(status))
        {
    	    m_fCsInitialized = TRUE;
        }
    }
    return m_fCsInitialized;
};

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::~CMutexSem2, public
//
//  Synopsis:   Mutex semaphore destructor
//
//  Effects:    Releases semaphore data
//
//  History:    19-Mar-01    danroth    Created.
//
//----------------------------------------------------------------------------

CMutexSem2::~CMutexSem2(void)
{
    if (m_fCsInitialized == TRUE)
    {
#ifdef _DEBUG
        NTSTATUS status =
#endif
        RtlDeleteCriticalSection(&m_cs); // if RtlDeleteCriticalSection fails, tough luck--we leak. 
#ifdef _DEBUG                       // But I'm asserting for it to see if we ever really hit it.
        Win4Assert(NT_SUCCESS(status));
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::Request, public
//
//  Synopsis:  Enter critical section
//
//  Effects:    Asserts correct owner
//
//  History:    19-Mar-01    danroth    Created.
//
//
//----------------------------------------------------------------------------

void CMutexSem2::Request(void)
{
    Win4Assert(m_fCsInitialized == TRUE);
    if (m_fCsInitialized == TRUE)
	EnterCriticalSection(&m_cs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::Release, public
//
//  Synopsis:   Release semaphore
//
//  Effects:    Leave critical section
//
//  History:    19-Mar-01    danroth    Created.
//
//----------------------------------------------------------------------------

void CMutexSem2::Release(void)
{
    Win4Assert(m_fCsInitialized == TRUE);
    if (m_fCsInitialized == TRUE)
    	LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\oleprint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oleprint.cxx
//
//  Contents:   printf for API/Method trace
//
//  Functions:  oleprintf
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdarg.h>
#include <ole2sp.h>
#include <ole2com.h>
#if DBG==1
#include "outfuncs.h"
#include "oleprint.hxx"

// *** Constants ***
const char *pscTabString = "   "; // 3 space tabs

// *** Types and Enums ***
// Enumeration of basic types
enum
{
    TYP_INT = 0,
    TYP_UNSIGNED,
    TYP_HEX,
    TYP_HEXCAPS,
    TYP_LARGE,
    TYP_BOOL,
    TYP_BOOLCAPS,
    TYP_POINTER,
    TYP_POINTERCAPS,
    TYP_HANDLE,
    TYP_HANDLECAPS,
    TYP_STR,
    TYP_WIDESTR,
    TYP_GUID,
    TYP_STRUCT,
    NO_TYPE
};

// Type of parameter printing functions
typedef void (*ParamFunc) (CTextBufferA &buf, va_list &param,  char *&ppstr);

// Enumeration of Structure types
enum
{
    STRUCT_BIND_OPTS=0,
    STRUCT_DVTARGETDEVICE,
    STRUCT_FORMATETC,
    STRUCT_FILETIME,
    STRUCT_INTERFACEINFO,
    STRUCT_LOGPALETTE,
    STRUCT_MSG,
    STRUCT_OLEINPLACEFRAMEINFO,
    STRUCT_OLEMENUGROUPWIDTHS,
    STRUCT_POINT,
    STRUCT_RECT,
    STRUCT_STGMEDIUM,
    STRUCT_STATSTG,
    STRUCT_SIZE,
    NO_STRUCT
};

// Type of structure printing functions
typedef void (*WriteFunc) (CTextBufferA &buf, void *pParam);

// *** Prototypes ***
// Functions to handle writing out parameters
static void WriteInt(CTextBufferA &buf, va_list &,  char *&);
static void WriteUnsigned(CTextBufferA &buf, va_list &, char *&);
static void WriteHex(CTextBufferA &buf, va_list &, char *&);
static void WriteHexCaps(CTextBufferA &buf, va_list &, char *&);
static void WriteLarge(CTextBufferA &buf, va_list &, char *&);
static void WriteBool(CTextBufferA &buf, va_list &, char *&);
static void WriteBoolCaps(CTextBufferA &buf, va_list &, char *&);
static void WritePointer(CTextBufferA &buf, va_list &, char *&);
static void WritePointerCaps(CTextBufferA &buf, va_list &, char *&);
static void WriteString(CTextBufferA &buf, va_list &, char *&);
static void WriteWideString(CTextBufferA &buf, va_list &, char *&);
static void WriteGUID(CTextBufferA &buf, va_list &, char *&);
static void WriteStruct(CTextBufferA &buf, va_list &, char *&);

// *** Global Data ***
char gPidString[20];

// this table holds the functions for writing base types
static ParamFunc g_pFuncs[] = {WriteInt, WriteUnsigned, WriteHex,
                        WriteHexCaps, WriteLarge, WriteBool,
                        WriteBoolCaps,WritePointer,WritePointerCaps,
                        WriteHex,WriteHexCaps,WriteString,
                        WriteWideString, WriteGUID, WriteStruct,
                        NULL};

// this table starts at 'A' == 65
// This is the base type lookup table -> tells what kind of base type to print out
static const BYTE g_tcLookup[] = {NO_TYPE, TYP_BOOLCAPS, NO_TYPE, TYP_INT, NO_TYPE, // 'A' - 'E'
                            NO_TYPE, NO_TYPE, NO_TYPE, TYP_GUID, NO_TYPE, // 'F' - 'J'
                            NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, // 'K' - 'O'
                            TYP_POINTERCAPS, NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, // 'P' - 'T'
                            TYP_UNSIGNED, NO_TYPE, NO_TYPE, TYP_HEXCAPS, NO_TYPE, // 'U' - 'Y'
                            NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, // 'Z' - '^'
                            NO_TYPE, NO_TYPE, NO_TYPE, TYP_BOOL, NO_TYPE, // '_' - 'c'
                            TYP_INT, NO_TYPE, NO_TYPE, NO_TYPE, TYP_HANDLE, // 'd' - 'h'
                            NO_TYPE, NO_TYPE, NO_TYPE, TYP_LARGE, NO_TYPE, // 'i' - 'm'
                            NO_TYPE, NO_TYPE, TYP_POINTER, NO_TYPE, NO_TYPE, // 'n' - 'r'
                            TYP_STR, TYP_STRUCT, TYP_UNSIGNED, NO_TYPE, TYP_WIDESTR, // 's' - 'w'
                            TYP_HEX, NO_TYPE, NO_TYPE};                    // 'x' - 'z'

// This holds the functions for writing out structures
static WriteFunc g_pStructFuncs[] = {(WriteFunc) WriteBIND_OPTS, (WriteFunc) WriteDVTARGETDEVICE,
                    (WriteFunc) WriteFORMATETC, (WriteFunc) WriteFILETIME,
                    (WriteFunc) WriteINTERFACEINFO, (WriteFunc) WriteLOGPALETTE,
                    (WriteFunc) WriteMSG, (WriteFunc) WriteOLEINPLACEFRAMEINFO,
                    (WriteFunc) WriteOLEMENUGROUPWIDTHS, (WriteFunc) WritePOINT,
                    (WriteFunc) WriteRECT, (WriteFunc) WriteSTGMEDIUM, (WriteFunc) WriteSTATSTG,
                    (WriteFunc) WriteSIZE, NULL };

// this table starts at 'a' == 97
// this table holds what type of structure to print out
static const BYTE g_structLookup[] = {NO_STRUCT, STRUCT_BIND_OPTS, NO_STRUCT, STRUCT_DVTARGETDEVICE,    // 'a' - 'd'
                                        STRUCT_FORMATETC, STRUCT_FILETIME, NO_STRUCT, NO_STRUCT,        // 'e' - 'h'
                                        STRUCT_INTERFACEINFO, NO_STRUCT, NO_STRUCT, STRUCT_LOGPALETTE,  // 'i' - 'l'
                                        STRUCT_MSG, NO_STRUCT, STRUCT_OLEINPLACEFRAMEINFO, STRUCT_POINT,// 'm' - 'p'
                                        NO_STRUCT, STRUCT_RECT, STRUCT_STGMEDIUM, STRUCT_STATSTG ,     // 'q' - 't'
                                        NO_STRUCT, NO_STRUCT, STRUCT_OLEMENUGROUPWIDTHS, NO_STRUCT,     // 'u' - 'x'
                                        NO_STRUCT, STRUCT_SIZE };                                              // 'y' - 'z'

//+---------------------------------------------------------------------------
//
//  Function:   oleprintf
//
//  Synopsis:  Prints out trace information using a given function, given a
//                 nesting depth (for indenting), an API/Method name, a format string,
//             and a variable number of arguments
//
//  Arguments:     [depth]        - nesting/indentation level
//                 [pscApiName]    - name of API/Method traced
//                 [pscFormat]        - format string
//                 [argptr]        - variable argument list
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void __cdecl oleprintf(int depth, const char *pscApiName, const char *pscFormat, va_list argptr)
{
    // buffer all output so that multithreaded traces look right
    CTextBufferA buf;
    char temp[20];
    char *pscPos;

    // first print out the process id
    buf << gPidString;

    buf << '.';

    // now print out the thread id
    _itoa(GetCurrentThreadId(), temp, 10);

    buf << temp;
    buf << "> ";

    // tab to nesting/indent depth
    while(depth-- > 0)
    {
        buf << pscTabString;
    }

    // now print out API name
    buf << pscApiName;

    // now we are ready to print out what was passed
    pscPos = strchr(pscFormat, '%');

    while(pscPos != NULL)
    {
        // insert the text up to the found '%' character into the buffer
        buf.Insert(pscFormat, (int)(pscPos-pscFormat));

        if(*(pscPos+1) == '%') // this is '%%', we only print one '%' and don't print an argument
        {
            buf << *pscPos;
            pscFormat = pscPos+2;
        }
        else
        {
            BYTE argType = NO_TYPE;

            // advance pscPos to type specifier
            pscPos++;

            // we need to take an argument and handle it
            if(*pscPos >= 'A' && *pscPos <= 'z')
            {
                argType = g_tcLookup[*pscPos- 'A'];
            }

            if(argType != NO_TYPE)
            {
                // handle argument
                // function will advance pscPos past format specifier
                g_pFuncs[argType](buf, argptr, pscPos);
            }
            else
            {
                // assume we've got a one character format specifier
                pscPos++;
                // unknown type, assume size of int
                va_arg(argptr, int);
            }

            // advance search pointer past type specifier
            pscFormat = pscPos;
        }

        pscPos = strchr(pscFormat, '%');
    }

    // print out remainder of string
    buf << pscFormat;

    // destructor will flush buffer for us
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHex
//
//  Synopsis:  Prints out a lower case hex value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteHex(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteHexCommon(buf, va_arg(param, unsigned long), FALSE);

    //advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHexCaps
//
//  Synopsis:  Prints out an upper case hex value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteHexCaps(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteHexCommon(buf, va_arg(param, unsigned long), TRUE);

    //advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteInt
//
//  Synopsis:  Prints out a signed integer value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteInt(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteIntCommon(buf, va_arg(param, unsigned int), FALSE);

    // advance pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteUnsigned
//
//  Synopsis:  Prints out a unsigned value, may be 64 bit or 32 bit
//                 depending on next character in format specifier
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteUnsigned(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    switch(*(pFormat+1)) // next character determines type
    {
        case 'd': // 32-bit
        case 'D':
            WriteIntCommon(buf, va_arg(param, unsigned long), TRUE);

            // Advance format pointer
            pFormat+=2;
            break;

        case 'l':  // 64-bit
        case 'L':
            WriteLargeCommon(buf, va_arg(param, __int64 *), TRUE);

            // advance format pointer
            if(*(pFormat+2) == 'd' || *(pFormat+2) == 'D')
            {
                pFormat+=3;
            }
            else
            {
                pFormat+=2;
            }
            break;

        default:
            pFormat++; // assume it's just one char-type specifier
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePointer
//
//  Synopsis:  Prints out a lower case pointer value,
//                 checks to make sure pointer is good value
//                 prints out symbol if a symbol maps to pointer
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePointer(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    if(*(pFormat+1) != 'p')
    {
        WritePointerCommon(buf, va_arg(param, void *), FALSE, FALSE, FALSE);


        pFormat++;
    }
    else
    {
        void **pPointer;
        BufferContext bc;

        // take snapshot of buffer
        buf.SnapShot(bc);

        // write pointer to pointer
        // first validate this pointer
        __try
        {
            pPointer = va_arg(param, void **);

            WritePointerCommon(buf, *pPointer, FALSE, FALSE, FALSE);
        }
        __except(ExceptionFilter(_exception_code()))
        {
            // try to revert buffer
            buf.Revert(bc);

            WritePointerCommon(buf, pPointer, FALSE, TRUE, FALSE);
        }

        pFormat +=2;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePointerCaps
//
//  Synopsis:  Prints out an upper case pointer value,
//                 checks to make sure pointer is good value
//                 prints out symbol if a symbol maps to pointer
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePointerCaps(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WritePointerCommon(buf, va_arg(param, void *), TRUE, FALSE, FALSE);

    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLarge
//
//  Synopsis:  Prints out a 64-bit integer
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteLarge(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteLargeCommon(buf, va_arg(param, __int64 *), FALSE);

    if(*(pFormat+1) == 'd' || *(pFormat+1) == 'D')
    {
        pFormat+=2;
    }
    else
    {
        pFormat++;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBool
//
//  Synopsis:  Prints out a lower case boolean value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBool(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteBoolCommon(buf, va_arg(param, BOOL), FALSE);

    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBoolCaps
//
//  Synopsis:  Prints out an upper case boolean value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBoolCaps(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteBoolCommon(buf, va_arg(param, BOOL), TRUE);

    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteString
//
//  Synopsis:  Prints out an ASCII string
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteString(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteStringCommon(buf, va_arg(param, const char *));

    // Advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteWideString
//
//  Synopsis:  Prints out a UNICODE string, but only supports ASCII characters
//                 if character > 256 is encountered, an "unprintable character" char
//                 is printed
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteWideString(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteWideStringCommon(buf, va_arg(param, const WCHAR *));

    // Advance format pointer
    if(*(pFormat+1) == 's')
    {
        pFormat+=2;
    }
    else
    {
        pFormat++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteGUID
//
//  Synopsis:  Prints out a GUID
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteGUID(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteGUIDCommon(buf, va_arg(param, GUID *));

    // Advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteStuct
//
//  Synopsis:  Prints out a structure. If structure expansion is enabled
//                 expands the structure depending on it's type
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteStruct(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    void *pArg;
    BYTE bType = NO_STRUCT;

    pArg = va_arg(param, void *);

    if(*(pFormat+1) >= 'a' && *(pFormat+1) <= 'z')
    {
        bType = g_structLookup[*(pFormat+1) - 'a'];
    }

    if(bType != NO_STRUCT) // only print out known structures
    {
        BufferContext bc;

        buf.SnapShot(bc); // take a snapshot of the buffer

        __try
        {
            g_pStructFuncs[bType](buf, pArg);
        }
        __except (ExceptionFilter(_exception_code()))
        {
            buf.Revert(bc);                // try to revert to the old buffer

            // bad pointer
            WritePointerCommon(buf, pArg, FALSE, TRUE, FALSE);
        }
    }
    else
    {
        // write out the pointer
        WritePointerCommon(buf, pArg, FALSE, FALSE, FALSE);
    }

    // increment format pointer
    pFormat += 2;
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\lockperf.cxx ===
//+-----------------------------------------------------------------------------
//
//  File:       lockperf.cxx
//
//  Contents:   Implementation of lock monitoring for locks used by ole32.dll
//
//  Classes:    CLockPerfTracker
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
#if LOCK_PERF==1

#include <ole2int.h>
#include <lockperf.hxx>

// gbLockPerf == (Is lock monitoring ON?) 
// (It is possible to turn this on & off multiple times during a single test run.)
// Ideally, it would be good to turn it OFF after proc-attach, let the test
// run for a while and then turn it ON. This will get the startup skew out of
// the way.
BOOL gbLockPerf = TRUE;

// Lock perf tracker. Gathers perf measurements for all locks.
CLockPerfTracker gLockTracker;    

// static member table of the global tracker class.
CFileLineEntry CLockPerfTracker::_FileLineData[MAX_LOCKPERF_FILEENTRY];

// static member table of the global tracker: this keeps a track of shared time.
CLockEntry CLockPerfTracker::_LockData[MAX_LOCKS];

// counts of locks & {file,line} instances tracked.
ULONG CLockPerfTracker::_numLocks;
ULONG CLockPerfTracker::_numCritSecs;

// perf frequency on the system
LARGE_INTEGER CLockPerfTracker::_liFreq;

//Flagged if tables get full
BOOL    gbLockPerfOverflow=FALSE;

//Count of entries in the shared table (code critical sections)
LONG    glFileLine = 0;

//Strings to used to print report
LPSTR   gszLockPerfErr = "##### Error: LockPerfOverFlow!!";
char    gszLockPerfBuf[256];

//Used to debug the perf monitoring code.
#define perfPrint(x)
#if DBG==1
#define LockAssert(X)   if (!(X)) wsprintfA(gszLockPerfBuf,#X ## "\n"),OutputDebugStringA(gszLockPerfBuf);
#else
#define LockAssert(X)
#endif




// **** Functions to manage the Private TLS used by LockPerf *********

// Heap Handle (copied from tls.cxx)
extern  HANDLE    g_hHeap;
#define HEAP_SERIALIZE 0

DWORD gTlsLockPerfIndex = 0xFFFFFFFF;

//345678901234567890123456789012345678901234567890123456789012345678901234567890
//+-----------------------------------------------------------------------------
//
//  Function:   AllocLockPerfPvtTlsData
//
//  Synopsis:   Allocates the Tls data for a thread (at Thread_Attach)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

HRESULT AllocLockPerfPvtTlsData()
{
    void *pMem =  HeapAlloc(g_hHeap, 
                            HEAP_SERIALIZE, 
                            TLS_LOCKPERF_MAX*sizeof(CTlsLockPerf));
    if (!pMem)
    {
        LockAssert(!"Could not alloc private Tls data for LockPerf");
        return E_OUTOFMEMORY;
    }
    LockAssert(gTlsLockPerfIndex!=0xFFFFFFFF);
    memset(pMem, 0, TLS_LOCKPERF_MAX*sizeof(CTlsLockPerf));
    
    TlsSetValue(gTlsLockPerfIndex, pMem);
    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Function:   FreeLockPerfPvtTlsData
//
//  Synopsis:   Frees the Tls data for a thread (at Thread_Detach)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
//  REVIEW: What about cases when DllMain is not called with Thread_Detach?

void FreeLockPerfPvtTlsData()
{
    LockAssert(gTlsLockPerfIndex!=0xFFFFFFFF);
    void *pMem = TlsGetValue(gTlsLockPerfIndex); 
    if (pMem) 
    {
        HeapFree(g_hHeap, HEAP_SERIALIZE, pMem);
    }
}

//**** End: TLS functions ********************************************

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::Init(), public
//
//  Synopsis:   Initializes lock perf data, marking entries as unused.
//              Called during Proc_Attach
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

HRESULT CLockPerfTracker::Init()
{
    QueryPerformanceFrequency(&_liFreq);
    
    // We use lpLockPtr to tell if an entry in these tables is in-use.
    for (int i=0;i<MAX_LOCKPERF_FILEENTRY;i++)
    {
        _FileLineData[i].lpLockPtr = NULL;
    }
    for (i=0; i<MAX_LOCKS; i++)
    {
        _LockData[i].lpLockPtr = NULL;
    }
    _numLocks = 0;
    _numCritSecs = 0;
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::RegisterLock(), public
//
//  Synopsis:   Must be called by the lock creation function. 
//                  lpLockPtr   == this-ptr of the lock (or unique ptr)
//                  bReadWrite  == TRUE for Reader-Writer Locks.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

void CLockPerfTracker::RegisterLock(void *lpLockPtr, BOOL bReadWrite)
{
    BOOL bDone = FALSE;
    int i=0;
    
    while (!bDone)
    {
        while (_LockData[i].lpLockPtr)
        {
            i++;
        }
        LockAssert(i < MAX_LOCKS);
        
        // REVIEW: 64-bit implications of this cast?
        bDone = !(InterlockedCompareExchange((LONG *)&_LockData[i].lpLockPtr, 
                                             (LONG)lpLockPtr, 
                                             NULL));
    }

    _LockData[i].dwTotalWriteWaitTime = 0;
    _LockData[i].dwTotalWriteEntrys = 0;       
    _LockData[i].dwTotalWriteLockTime = 0;
    _LockData[i].pszLockName = NULL;
    
    // REVIEW: These 5 could be skipped for non reader-writer locks?
   _LockData[i].dwSharedTime = 0;
   _LockData[i].dwNumReaders = 0;

   _LockData[i].dwTotalReadWaitTime = 0;
   _LockData[i].dwTotalReadLockTime = 0;
   _LockData[i].dwTotalReadEntrys = 0; 
        
}

//+-----------------------------------------------------------------------------
//
//  Function:   Hash
//
//  Synopsis:   Maps line #s to index in the perf data table.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
ULONG Hash (ULONG line)
{
    //  buckets of 256, 128, 64, 64 totaling to MAX_LOCKPERF_FILEENTRY
    //  this was based on a grep in Ole32 tree for LOCK macro (Sep98):
    //  Call counts: 
    //                              137 from   1 - 1024
    //                              92 from 1024 - 2048
    //                              45 from 2048 - 3072
    //                              28 from 3072 - 4096
    //                              10 from 4096 - 5120
    //                              11 from 5124 - 6144
    //                               8 from 6148 - 7168
    //  highest lineNum was 6872 in marshal.cxx
    //  The Hash function & array size may need updating if the highest lineNum
    //  goes beyond 7176 or if any bucket gets maxed out.

    ULONG base, offset;
    if (line < 1024)
    {
        base = 0;
        offset = line>>2;           //0 to 255
    }
    else if (line < 2048)
    {
        base = 256;
        offset = (line-1024)>>3;    //0 to 127
    }
    else if (line < 3072)
    {
        base = 384;
        offset = (line-2048)>>4;    //0 to 63
    }
    else
    {      //this covers lines from 3072 to 7168
        base = 448;
        offset = (line-3072)>>6;    //0 to 63
    }
    return base+offset;
}



//+-----------------------------------------------------------------------------
//
//  Function:   GetTlsLockPerfEntry
//
//  Synopsis:   Finds the entry in Tls for a lock or returns a free entry
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
CTlsLockPerf *GetTlsLockPerfEntry(void *lpLockPtr)
{
    CTlsLockPerf *lpEntry = NULL, *lpFree = NULL;
    
    CTlsLockPerf *lpCurrent = (CTlsLockPerf *)TlsGetValue(gTlsLockPerfIndex);
    for (int i=0; i<TLS_LOCKPERF_MAX; i++)
    {
        if (lpCurrent->_dwFlags & TLS_LOCKPERF_INUSE)
        {
            if (lpCurrent->_lpLockPtr == lpLockPtr)
            {
                lpEntry = lpCurrent;
                break;
            }
        }
        else if (!lpFree)
        {
            // Remember the first free entry in case we need it.
            lpFree = lpCurrent;
        }
        lpCurrent++;
    }
    return (lpEntry!=NULL) ? lpEntry : lpFree;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReaderWaiting(), public
//
//  Synopsis:   Called by the lock code when a thread attempts to enter
//              a critical section for reading.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::ReaderWaiting(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr)
{
    if (gbLockPerf)
    {
        // Just call WriterWaiting till we need different semantics...
        WriterWaiting(pszFile, 
                      dwLine, 
                      pszLockName, 
                      lpLockPtr, FALSE /*bWriter*/);
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::WriterWaiting(), public
//
//  Synopsis:   Called by the lock code when a thread attempts to enter
//              a critical section for writing.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::WriterWaiting(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr, 
                                     BOOL bWriter /*default TRUE*/)
{
    if (gbLockPerf)
    {  
        CTlsLockPerf *pTlsLP = GetTlsLockPerfEntry(lpLockPtr);

        // Will assert if we are getting more than TLS_LOCKPERF_MAX
        // locks one after another without releasing any.
        LockAssert(pTlsLP);    
    
        if (pTlsLP->_dwFlags & TLS_LOCKPERF_INUSE)         
        {   
            // Recursion on the lock. Request for the lock while holding it.
            // Can't be waiting recursively!
            LockAssert(pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED); 
        }
        else
        {
            ULONG idx;
            ULONG loc = FindOrCreateFileTableEntry(pszFile, 
                                                   dwLine, 
                                                   pszLockName, 
                                                   lpLockPtr, 
                                                   bWriter, 
                                                   &idx);

            LockAssert(loc <  MAX_LOCKPERF_FILEENTRY);
    
            //save table indices in TLS, for quick access later.
            pTlsLP->_loc = loc;
            pTlsLP->_idx = idx;
            pTlsLP->_lpLockPtr = lpLockPtr;
            pTlsLP->_dwFlags = TLS_LOCKPERF_WAITING | TLS_LOCKPERF_INUSE; //new Tls entry!
            pTlsLP->_dwRecursion = 0;   //we set this to 1 upon the first xxxEntered
    
            //store request time in TLS (last thing done to not skew lock wait/use times)
            QueryPerformanceCounter(&pTlsLP->_liRequest);
        }
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReaderEntered(), public
//
//  Synopsis:   Called by lock code when a thread is granted access to 
//              a critical section for reading. 
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
//  REVIEW: Life will be easier for us if we enforce that the lock code 
//  must detect and inform if this is the first reader in the critical 
//  section. (Similarly for the last reader leaving.)
//------------------------------------------------------------------------------
void CLockPerfTracker::ReaderEntered(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr)
{  
    if (gbLockPerf)
    {
        ULONG idx = FindLockTableEntry(lpLockPtr);    
        if (InterlockedIncrement((LONG*)&_LockData[idx].dwNumReaders)==1)
        {
            QueryPerformanceCounter(&_LockData[idx].liEntered);
        }
        // rest of the work is done by WriterEntered
        WriterEntered(pszFile, dwLine, pszLockName, lpLockPtr, /*bWriter*/ FALSE);
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::WriterEntered(), public
//
//  Synopsis:   Called by lock code when a thread is granted access to 
//              a critical section for writing.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::WriterEntered(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr, 
                                     BOOL bWriter /*default TRUE*/)
{
    if (gbLockPerf)
    {
        CTlsLockPerf *pTlsLP = GetTlsLockPerfEntry(lpLockPtr);
    
        /*
        // REVIEW: Should we force lock implementation to call ReaderWaiting/WriterWaiting
        // even if there is no reason to wait? In that case the following assertion is true.
        
        // There has to be an entry, either marked waiting or entered (recursive lock)
        LockAssert( pTlsLP && ((pTlsLP->_dwFlags & TLS_LOCKPERF_WAITING) ||  (pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED)) );
        */

        if (!(pTlsLP->_dwFlags & TLS_LOCKPERF_INUSE))
        {
            // Someone called xxxEntered directly (without calling xxxWaiting)
            ULONG idx;
            ULONG loc = FindOrCreateFileTableEntry(pszFile, 
                                                   dwLine, 
                                                   pszLockName, 
                                                   lpLockPtr, 
                                                   bWriter, 
                                                   &idx);
            LockAssert(loc <  MAX_LOCKPERF_FILEENTRY);
    
            // save the table indices in TLS, for quick access later.
            pTlsLP->_loc = loc;
            pTlsLP->_idx = idx;
            pTlsLP->_lpLockPtr = lpLockPtr;
            pTlsLP->_dwFlags = TLS_LOCKPERF_ENTERED | TLS_LOCKPERF_INUSE;
            pTlsLP->_dwRecursion = 0;
    
            QueryPerformanceCounter(&pTlsLP->_liEntered);
            pTlsLP->_liRequest = pTlsLP->_liEntered;
        }
        else if (pTlsLP->_dwFlags & TLS_LOCKPERF_WAITING)
        {
            QueryPerformanceCounter(&pTlsLP->_liEntered);
            // Not waiting any more.
            pTlsLP->_dwFlags |= TLS_LOCKPERF_ENTERED;
            pTlsLP->_dwFlags &= ~TLS_LOCKPERF_WAITING;
        }
        pTlsLP->_dwRecursion++; // 1 means first level entry (i.e. no recursion)
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReaderLeaving(), public
//
//  Synopsis:   Called by the lock code when a reader is leaving a critical
//              section.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::ReaderLeaving(void *lpLockPtr)
{
    if (gbLockPerf)
    {
        ULONG idx = FindLockTableEntry(lpLockPtr);
    
        LARGE_INTEGER liEntered = _LockData[idx].liEntered;
        if (InterlockedDecrement((LONG*)&_LockData[idx].dwNumReaders) == 0)
        {   
            // Last reader leaving 
            LARGE_INTEGER liDelta, liRem;
            QueryPerformanceCounter(&liDelta);
        
            liDelta = RtlLargeIntegerSubtract(liDelta, liEntered);
            liDelta = RtlExtendedIntegerMultiply(liDelta,1000000);
            liDelta = RtlLargeIntegerDivide(liDelta, _liFreq, &liRem);
        
            LockAssert(liDelta.HighPart == 0); // no one must hold a lock for so long!
            
            // This must be done inter-locked in case someother thread does 
            // a 0->1, 1->0 transition while one thread is in this block.
            InterlockedExchangeAdd((LONG*)&_LockData[idx].dwSharedTime, 
                                   liDelta.LowPart);
        }
    
        //Call WriterLeaving to do the rest.
        WriterLeaving(lpLockPtr);
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::WriterLeaving(), public
//
//  Synopsis:   Called by the lock code when a writer is leaving a critical
//              section.  
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::WriterLeaving(void *lpLockPtr)
{
    if (gbLockPerf)
    {    
        CTlsLockPerf *pTlsLP = GetTlsLockPerfEntry(lpLockPtr); 
    
        // There has be to an entry marked entered!
        LockAssert(pTlsLP && (pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED));
    
        pTlsLP->_dwRecursion--;
    
        if (pTlsLP->_dwRecursion == 0)
        {   
            // The thread is *really* leaving the lock. Do the math!
            LARGE_INTEGER liUnlockTime;
            QueryPerformanceCounter(&liUnlockTime);
            UpdateFileTableEntry(pTlsLP, &liUnlockTime);
            
            // Mark the Tls entry as free.
            pTlsLP->_dwFlags &= ~TLS_LOCKPERF_INUSE;
        }
        else
        {
            // The thread is still in the lock!
            LockAssert(pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED);
        }
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReportContention(), public
//
//  Synopsis:   Must be called by the lock destroy/cleanup function.
//              This is single threaded by definition.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

void CLockPerfTracker::ReportContention(void *lpLockPtr, 
                                        DWORD dwWriteEntrys, 
                                        DWORD dwWriterContention, 
                                        DWORD dwReadEntrys, 
                                        DWORD dwReaderContention)
{
    // This happens during DLL_PROCESS_DETACH hence single-threaded
    for (int i=0; i<MAX_LOCKS; i++)
    {
        if (_LockData[i].lpLockPtr == lpLockPtr)
        {
            _LockData[i].dwWriterContentionCount = dwWriterContention;
            _LockData[i].dwReaderContentionCount = dwReaderContention;

            // These asserts may not be very useful since some locks are entered 
            // before lock monitoring can be started! Also, monitoring can be
            // turned OFF and ON in windows.

            // LockAssert( _LockData[i].dwTotalWriteEntrys ==  dwWriteEntrys);
            // LockAssert( _LockData[i].dwTotalReadEntrys ==  dwReadEntrys);
            break;
        }
    }
    LockAssert( i<MAX_LOCKS );
}

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::FindLockTableEntry(), private
//
//  Synopsis:   Finds the entry for a critical section in the lock table.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
ULONG CLockPerfTracker::FindLockTableEntry(void *lpLockPtr)
{
    for (int idx=0; idx<MAX_LOCKS; idx++)
    {
        if (_LockData[idx].lpLockPtr == lpLockPtr)
        {
            return idx;
        }
    }
    LockAssert(!"Lock not registered for monitoring!");
    return MAX_LOCKS-1; // just to avoid AVs
}

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::FindOrCreateFileTableEntry(), private
//
//  Synopsis:   Finds the entry (or creates one) for a critical section guarded
//              by a lock at a {file, line}.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
ULONG CLockPerfTracker::FindOrCreateFileTableEntry(const char*pszFile, 
                                                   DWORD dwLine, 
                                                   const char* pszLockName, 
                                                   void *lpLockPtr, 
                                                   BOOL bWriter, 
                                                   DWORD *lpLockTableIndex)
{
    BOOL bFoundEntry = FALSE;
    CFileLineEntry *pNewTableEntry  = NULL;
    ULONG loc = Hash(dwLine);

    if (loc >= MAX_LOCKPERF_FILEENTRY)
    {
        LockAssert(!"Lock PerfTable full! Increase size.");
        gbLockPerfOverflow = TRUE;
        loc = MAX_LOCKPERF_FILEENTRY-1;
        goto errRet;
    }

    // If hashing works well this should not take too much time.

    while (!bFoundEntry)
    {
        while (_FileLineData[loc].lpLockPtr && loc<MAX_LOCKPERF_FILEENTRY)
        {
            if ( (_FileLineData[loc].dwLine==dwLine)
                 &&(_FileLineData[loc].pszFile==pszFile) )
            {
                bFoundEntry = TRUE;
                break;  //done
            }
            loc++;
        }
    
        if (loc >= MAX_LOCKPERF_FILEENTRY)
        {
            gbLockPerfOverflow = TRUE;
            loc = MAX_LOCKPERF_FILEENTRY-1;
            goto errRet;
        }
    
        if (!bFoundEntry && !( InterlockedCompareExchange(
                                    (LONG*)&_FileLineData[loc].lpLockPtr, 
                                    (LONG)lpLockPtr, 
                                    NULL) )
           )
        {
            // We are seeing a new critical section in the code base
            bFoundEntry = TRUE;
            pNewTableEntry = &_FileLineData[loc];
            InterlockedIncrement(&glFileLine); // Global count of code CritSec locations
        }
    }

    if (pNewTableEntry)
    {  // finish rest of initialization the entry is secured for this code location.
        // REVIEW: Ignoring races here.
        pNewTableEntry->bWriteCritSec   = bWriter;
        pNewTableEntry->dwNumEntrys     = 0;
        pNewTableEntry->pszLockName     = pszLockName;
        pNewTableEntry->pszFile         = pszFile;
        pNewTableEntry->dwLine          = dwLine;
        pNewTableEntry->dwWaitTime      = 0;
        pNewTableEntry->dwLockedTime    = 0;
        pNewTableEntry->ulLockTableIdx = FindLockTableEntry(lpLockPtr);
    }
errRet:
    *lpLockTableIndex = _FileLineData[loc].ulLockTableIdx;
    return loc;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::UpdateFileTableEntry(), private
//
//  Synopsis:   Adds the waiting time and the locked time for this visit
//              to the cumulative data for the {file,line} entry.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::UpdateFileTableEntry(CTlsLockPerf *pTlsEntry, 
                                            LARGE_INTEGER *pliUnlockTime)
{
    LockAssert( (pTlsEntry->_dwFlags & TLS_LOCKPERF_INUSE)
                && (pTlsEntry->_dwFlags & TLS_LOCKPERF_ENTERED) );

    ULONG idx = pTlsEntry->_idx;
    ULONG loc = pTlsEntry->_loc;

    LockAssert(loc>=0 && loc < MAX_LOCKPERF_FILEENTRY);

    LARGE_INTEGER liRem;

    LARGE_INTEGER liWait = RtlLargeIntegerSubtract(pTlsEntry->_liEntered, 
                                                   pTlsEntry->_liRequest);
    liWait = RtlExtendedIntegerMultiply(liWait,1000000);        
    liWait = RtlLargeIntegerDivide(liWait,_liFreq,&liRem); // liWait is now in micro-seconds

    LockAssert(liWait.HighPart == 0);  // hopefully no one waits for so long!!

    LARGE_INTEGER liLocked = RtlLargeIntegerSubtract(*pliUnlockTime, 
                                                     pTlsEntry->_liEntered);
    liLocked = RtlExtendedIntegerMultiply(liLocked,1000000);
    liLocked = RtlLargeIntegerDivide(liLocked, _liFreq, &liRem);

    LockAssert(liLocked.HighPart == 0); // no one must hold a lock for so long!

    if (_FileLineData[loc].bWriteCritSec)
    {   // Since this is a write location, the lock itself guarantees exclusion
        _FileLineData[loc].dwNumEntrys++;
        _FileLineData[loc].dwWaitTime += liWait.LowPart;  
        _FileLineData[loc].dwLockedTime += liLocked.LowPart;

        /*
        This needs to be here if we wish to compare entry counts reported by
        the lock with our own. For now this is in ProcessPerfData
        _LockData[idx].dwTotalWriteEntrys++;
        _LockData[idx].dwTotalWriteWaitTime += liWait.LowPart;
        _LockData[idx].dwTotalWriteLockTime += liLocked.LowPart;
        */
    }
    else
    {   // This is a read location. 
        // Hence we have to exclude other readers from updating data 
        InterlockedIncrement( (LONG*) &_FileLineData[loc].dwNumEntrys );
        InterlockedExchangeAdd( (LONG*) &_FileLineData[loc].dwWaitTime, liWait.LowPart );  
        InterlockedExchangeAdd( (LONG*) &_FileLineData[loc].dwLockedTime, liLocked.LowPart );

        /*
        This needs to be here if we wish to compare entry counts reported by
        the lock with our own. For now this is in ProcessPerfData
        InterlockedIncrement( (LONG*) &_LockData[idx].dwTotalReadEntrys );
        InterlockedExchangeAdd( (LONG*) &_LockData[idx].dwTotalReadWaitTime, liWait.LowPart );
        InterlockedExchangeAdd( (LONG*) &_LockData[idx].dwTotalReadLockTime, liLocked.LowPart );
        */
    }

#if 0
    // Turn this ON, if you want a live log of every Update.
    wsprintfA(gszLockPerfBuf,"\n Lock at %-25s : line %u : Entry # %u",
                (pTableEntry->pszFile[1]==':') ? pTableEntry->pszFile+24
                                                : pTableEntry->pszFile,
                pTableEntry->dwLine,
                pTableEntry->dwNumEntrys);
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf," Held for: %u mic-sec.",liLockHeld.LowPart);
    OutputDebugStringA(gszLockPerfBuf);
#endif
}

#define HOGLIST_TIME    0
#define HOGLIST_ENTRY   1
#define HOGLIST_AVGTIME 2


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::UpdateHoggers(), private
//
//  Synopsis:   Manages top ten lists. 
//                  This is done only during Proc_detach (hence thread safe!)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::UpdateHoggers(ULONG* hogList, ULONG index, ULONG listType)
{
    int i,j;

    switch (listType)         
    {
    case HOGLIST_TIME:
        for (i=0; i<10; i++)
        {
            if (hogList[i]==-1)
            {
                break;
            }
            else if (_FileLineData[hogList[i]].dwLockedTime 
                        < _FileLineData[index].dwLockedTime)
            {
                break;
            }
        }
        break;

    case HOGLIST_ENTRY:
        for (i=0; i<10; i++)
        {
            if (hogList[i]==-1)
            {
                break;
            }
            else if (_FileLineData[hogList[i]].dwNumEntrys 
                        < _FileLineData[index].dwNumEntrys)
            {
                break;
            }
        }
        break;
    
    case HOGLIST_AVGTIME:
        for (i=0; i<10; i++)
        {
            if (hogList[i]==-1)
            {
                break;
            }
            else if (_FileLineData[hogList[i]].dwAvgTime 
                        < _FileLineData[index].dwAvgTime)
            {
                break;
            }
        }
        break;

    default:
        break;
    }

    if (i<10)
    {
        for (j=9; j>i;j--)
        {
            hogList[j] = hogList[j-1] ;
        }
        hogList[i] = index;
    }
}



//+-----------------------------------------------------------------------------
//
//  Function:   PercentToString
//
//  Synopsis:   Converts numbers like 74326 to "74.33".
//              We do not have float printing support in retail builds.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

//  The percent argument is passed in 1000 times magnified.
char gPerc[7];
inline char *PercentToString(long percent)
{
    //round-off
    percent = percent/10 + ((percent%10 >= 5)?1:0);

    //set to fixed length
    percent+=10000;

    //create room for decimal point (4th char)
    percent = (percent/100)*1000 + (percent%100);

    _itoa(percent,gPerc,10);
    
    gPerc[0] = gPerc[0]-1;  //remove the 10000 we added.
    gPerc[3] = '.';

    return gPerc + (gPerc[0]=='0'? (gPerc[1]=='0'?2:1):0) ;
}



//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::OutputFileTableEntry, private
//
//  Synopsis:   Prints out cumulative data for a {file,line} entry
//              We are doing this during Process_Detach, hence thread-safe.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::OutputFileTableEntry(ULONG index, 
                                            ULONG bByName, 
                                            ULONG percent)
{
    ULONG trimFileName;
    CFileLineEntry *pTableEntry = &_FileLineData[index]; 

    if (pTableEntry->pszFile[1]==':')
    {
        trimFileName = 24;
    }
    else
    {
        trimFileName = 0;
    }
    if (bByName)
    {
        wsprintfA(gszLockPerfBuf,"\n %20s  %4d   %s %6d  %7u  %6s %% ",
                    pTableEntry->pszFile+trimFileName,
                    pTableEntry->dwLine,
                    pTableEntry->bWriteCritSec ? "Write" : " Read", 
                    pTableEntry->dwNumEntrys,
                    pTableEntry->dwLockedTime,
                    PercentToString(percent));

        OutputDebugStringA(gszLockPerfBuf);
    }
    else
    {
        wsprintfA(gszLockPerfBuf,"\n %20s  %4d   %-14.14s %s   %5d   %8u  %8u",
                    pTableEntry->pszFile+trimFileName,
                    pTableEntry->dwLine,
                    pTableEntry->pszLockName,
                    pTableEntry->bWriteCritSec?"Write":" Read", 
                    pTableEntry->dwNumEntrys,
                    pTableEntry->dwLockedTime,
                    pTableEntry->dwAvgTime);
        OutputDebugStringA(gszLockPerfBuf);
    }
}

#define TITLES_1      \
    wsprintfA(gszLockPerfBuf,"\n          File        Line    LockName       Type   Entrys  TotalTime  Avg/Entry"); OutputDebugStringA(gszLockPerfBuf)

#define TITLES_2      \
    wsprintfA(gszLockPerfBuf,"\n          File        Line    Type   Entrys TotalTime  %%-Time "); OutputDebugStringA(gszLockPerfBuf)

#define SEPARATOR_1   \
    wsprintfA(gszLockPerfBuf,"\n ==================== =====   ============   =====  ======  =========  ========="); OutputDebugStringA(gszLockPerfBuf)

#define SEPARATOR_2   \
    wsprintfA(gszLockPerfBuf,"\n ==================== =====   ====== ====== =========  ======"); OutputDebugStringA(gszLockPerfBuf)


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::OutputHoggers(), private
//
//  Synopsis:   Prints out a top ten list given an array of indices for the same.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::OutputHoggers(ULONG *hogList)
{
    TITLES_1;
    SEPARATOR_1;

    for (int i=0; i<10; i++)
    {
        if (hogList[i]!=-1)
        {
            OutputFileTableEntry(hogList[i],0,0);
        }
    }
    SEPARATOR_1;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ProcessPerfData(), public
//
//  Synopsis:   Organizes the perf table data by lockName. 
//              Prints lock summary data, top-ten lists.
//              This is done only during Proc_detach (hence thread safe!)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::ProcessPerfData()
{
    // #### Begin : organize data
    CFileLineEntry  *pTableEntry;

    ULONG hogListTime[10];
    ULONG hogListEntry[10];
    ULONG hogListAvgTime[10];
    
    ULONG iName;
    DWORD totalLockTime = 0;        // lock sharing not reflected!
    DWORD totalRealLockTime = 0;    // takes lock sharing into account!
    DWORD totalLocksCreated = 0;    // some locks may never get used!


    for (int i=0; i<10; i++)
    {
        hogListTime[i] = -1;
        hogListEntry[i] = -1;
        hogListAvgTime[i] = -1;
    }
    
    for (i=0; i<MAX_LOCKPERF_FILEENTRY; i++)
    {
        if (_FileLineData[i].lpLockPtr)
        {
            pTableEntry = &_FileLineData[i];
            if (pTableEntry->dwNumEntrys)
            {
                pTableEntry->dwAvgTime = 
                        pTableEntry->dwLockedTime/pTableEntry->dwNumEntrys;
            }
            else
            {
                pTableEntry->dwAvgTime = 0;
            }
            UpdateHoggers(hogListTime,i, 0);
            UpdateHoggers(hogListEntry,i, 1);
            UpdateHoggers(hogListAvgTime,i, 2);
            _numCritSecs++;

            //REVIEW: how should we take shared time into account?
            totalLockTime = totalLockTime + pTableEntry->dwLockedTime;

            iName = FindLockTableEntry(_FileLineData[i].lpLockPtr);
            if (_LockData[iName].pszLockName==NULL)
            {   
                // First file table entry for this lock
                // We use pszLockName==NULL to tell if a lock got used!
                _LockData[iName].pszLockName = pTableEntry->pszLockName;
                _LockData[iName].dwHead = i;
                _LockData[iName].dwTail = i;

                _numLocks++;
            }
            else
            {   //CritSec is already in our list.
                _FileLineData[_LockData[iName].dwTail].dwNext = i;
                _LockData[iName].dwTail = i;
            }

            if (pTableEntry->bWriteCritSec)
            {
                _LockData[iName].dwTotalWriteLockTime += pTableEntry->dwLockedTime;
                _LockData[iName].dwTotalWriteEntrys += pTableEntry->dwNumEntrys;
                _LockData[iName].dwTotalWriteWaitTime += pTableEntry->dwWaitTime;
            }
            else
            {
                _LockData[iName].dwTotalReadLockTime += pTableEntry->dwLockedTime;
                _LockData[iName].dwTotalReadEntrys += pTableEntry->dwNumEntrys;
                _LockData[iName].dwTotalReadWaitTime += pTableEntry->dwWaitTime;
            }
        }   // if In Use
    }   // for each table entry
    // #### End : organize data

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= LOCK_PERF: TOP TEN LISTS ===========\n");
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= Top Ten Hoggers by total time ===========\n");
    OutputDebugStringA(gszLockPerfBuf);
    OutputHoggers(hogListTime);

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= Top Ten Hoggers by crit-sec Entrys ===========\n");
    OutputDebugStringA(gszLockPerfBuf);
    OutputHoggers(hogListEntry);

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= Top Ten Hoggers by avg time per Entry ===========\n");
    OutputDebugStringA(gszLockPerfBuf);
    OutputHoggers(hogListAvgTime);

    SEPARATOR_1;
    wsprintfA(gszLockPerfBuf,
              "\n\n ============= LOCK_PERF: OVERALL LOCK STATS ===========\n");
    OutputDebugStringA(gszLockPerfBuf);

    for (i=0; i<MAX_LOCKS; i++)
    {
        if (_LockData[i].lpLockPtr)
        {
            totalLocksCreated++;
            if (_LockData[i].pszLockName)
            {
                // lock got used!
                totalRealLockTime += _LockData[i].dwTotalWriteLockTime;
                if (_LockData[i].dwTotalReadEntrys)
                {
                    totalRealLockTime += _LockData[i].dwSharedTime;
                }
            }
        }
    }

    wsprintfA(gszLockPerfBuf,
              "\n\n TOTAL locks created = %u",
              totalLocksCreated);
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf,
              "\n TOTAL locks used    = %u",
              _numLocks);
    OutputDebugStringA(gszLockPerfBuf);
    wsprintfA(gszLockPerfBuf,
              "\n\n TOTAL code critSec areas covered = %u",
              _numCritSecs);
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf,
              "\n\n\n TOTAL time spent in all critSecs = %u micro-sec\n\n",
              totalLockTime);
    OutputDebugStringA(gszLockPerfBuf);
    wsprintfA(gszLockPerfBuf,
              " [This is the sum of individual thread times.\n This does not take overlaps (shared work) into account.]");
    OutputDebugStringA(gszLockPerfBuf);
    
    wsprintfA(gszLockPerfBuf,
              "\n\n\n TOTAL real time spent in all critSecs = %u micro-sec\n\n",
              totalRealLockTime);
    OutputDebugStringA(gszLockPerfBuf);
    wsprintfA(gszLockPerfBuf," [This takes shared time into account.]");
    OutputDebugStringA(gszLockPerfBuf);
        
    wsprintfA(gszLockPerfBuf,
              "\n\n ## Warning ##: The total time counters overflow in about 70 minutes!\n\n");
    OutputDebugStringA(gszLockPerfBuf);
}

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::OutputPerfData(), public
//
//  Synopsis:   Prints out the {file,line} table.
//              This is done only during Proc_detach (hence thread safe!)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::OutputPerfData()
{
    if (glFileLine) //if monitoring was ON at any time!
    {
        if (gbLockPerfOverflow)
        {
            wsprintfA(gszLockPerfBuf,
                      "\n ### Warning: Overflow in lock perf data buffers!\n \
                      ### Increase array sizes and recompile!!\n");
            OutputDebugStringA(gszLockPerfBuf);
        }

        ULONG iStart, iNext, iEnd;
        const char *pszThisFile;
        
        ULONG iName;
        LARGE_INTEGER liPerc, liDiv, liRem ;


        //TITLES_1;
        //SEPARATOR_1;
        ProcessPerfData();


        // #### Begin: output by LockName:
        SEPARATOR_2;

        wsprintfA(gszLockPerfBuf,
                  "\n\n ============= LOCK_PERF: PER LOCK STATS ===========\n");
        OutputDebugStringA(gszLockPerfBuf);
        BOOL bShared;
        int iShared;
        for (iName=0; iName<_numLocks; iName++)
        {
            if (_LockData[iName].pszLockName) { //if the lock got used
            SEPARATOR_2;
            wsprintfA(gszLockPerfBuf,
                      "\n\n\n  #### ++++++++ Summary for %14s , this = %lx ++++++++ ####",
                      _LockData[iName].pszLockName, 
                      (DWORD)_LockData[iName].lpLockPtr);
            OutputDebugStringA(gszLockPerfBuf);

            wsprintfA(gszLockPerfBuf,
                      "\n\n      WrtLockTime:%12u      WrtEntrys:%14u\n      WrtWait:%16u      WrtContention:%10u \n",
                      _LockData[iName].dwTotalWriteLockTime,
                      _LockData[iName].dwTotalWriteEntrys,
                      _LockData[iName].dwTotalWriteWaitTime,
                      _LockData[iName].dwWriterContentionCount);
            OutputDebugStringA(gszLockPerfBuf);

            wsprintfA(gszLockPerfBuf,
                      "\n      RdLockTime:%13u      RdEntrys:%15u\n      RdWait:%17u      RdContention:%11u \n",
                      _LockData[iName].dwTotalReadLockTime,
                      _LockData[iName].dwTotalReadEntrys,
                      _LockData[iName].dwTotalReadWaitTime,
                      _LockData[iName].dwReaderContentionCount);
            OutputDebugStringA(gszLockPerfBuf);
            
            wsprintfA(gszLockPerfBuf,"\n      Shared Read Time:     %10u\n",
                      _LockData[iName].dwSharedTime);
            OutputDebugStringA(gszLockPerfBuf);
            

            TITLES_2;
            SEPARATOR_2;
            iNext = _LockData[iName].dwHead;
            iEnd = _LockData[iName].dwTail;
            while (1)
            {
                liPerc.HighPart = 0;
                liPerc.LowPart = _FileLineData[iNext].dwLockedTime;
                liPerc = RtlExtendedIntegerMultiply(liPerc,100000);
                liDiv.HighPart = 0;
                if (_FileLineData[iNext].bWriteCritSec)
                {
                    liDiv.LowPart = _LockData[iName].dwTotalWriteLockTime;
                }
                else
                {
                    liDiv.LowPart = _LockData[iName].dwTotalReadLockTime;
                }

                liPerc = RtlLargeIntegerDivide(liPerc, liDiv, &liRem);

                OutputFileTableEntry(iNext,1, liPerc.LowPart);
                if (iNext == iEnd)
                    break;
                iNext = _FileLineData[iNext].dwNext;
            }

            SEPARATOR_2;
            wsprintfA(gszLockPerfBuf,
                      "\n ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \n");
            OutputDebugStringA(gszLockPerfBuf);
            }   //if the lock got used!
        }

        SEPARATOR_2;
        // #### End: output by LockName:

        SEPARATOR_1;


#if 0   //This lists lock data by fileNames
        // #### Begin: output by fileName : location:
        wsprintfA(gszLockPerfBuf,
                  "\n\n\n ======= CritSec data listed by FileName: =======\n");
        OutputDebugStringA(gszLockPerfBuf);

        TITLES_1;
        SEPARATOR_1;

        pszThisFile = NULL;
        i=0;
        while (!_FileLineData[i].bInUse)
            i++;
        iNext = i;

        while (iNext < MAX_LOCKPERF_FILEENTRY)
        {
            iStart = iNext;
            iNext = MAX_LOCKPERF_FILEENTRY;
            pszThisFile= _FileLineData[iStart].pszFile;
            for (i=iStart;i<MAX_LOCKPERF_FILEENTRY;i++)
            {
                if (_FileLineData[i].bInUse)
                {
                    if (pszThisFile==_FileLineData[i].pszFile)
                    {
                        OutputFileTableEntry(i,0,0);
                        _FileLineData[i].bInUse = FALSE;
                    }
                    else if (iNext==MAX_LOCKPERF_FILEENTRY)
                    {
                        iNext=i;
                    }
                }
            }
        }
        // #### End: output by fileName : location:
#endif  //0 This lists lock data by fileNames

    }   //if glFileLine  
}

#endif //LOCK_PERF==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\oletype.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oletype.cxx
//
//  Contents:   individual methods for priting OLE types
//
//  Functions:  see oleprint.hxx
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>
#if DBG==1
#include "oleprint.hxx"
#include "sym.hxx"

// temporary string buffer size
#define TEMP_SIZE 64

// our constant strings
const char *pscNullString = "<NULL>";
const char *pscTrue = "true";
const char *pscTRUE = "TRUE";
const char *pscFalse = "false";
const char *pscFALSE = "FALSE";

const char *pscHexPrefix = "0x";
const char *pscPointerPrefix = "<";
const char *pscBadPointerPrefix = "BAD PTR : ";
const char *pscPointerSuffix = ">";

const char *pscStructPrefix = "{ ";
const char *pscStructDelim  = " , ";
const char *pscStructSuffix = " }";

// These functions are in com\util\guid2str.c
extern "C" void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr);
extern "C" int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

// *** Global Data ***
CSym *g_pSym = NULL;            // manage symbol stuff

//+---------------------------------------------------------------------------
//
//  Function:   FormatHex
//
//  Synopsis:  Wrapper around FormatHexNum to control if leading zeros are printed
//
//  Arguments:  [ulValue]               -       DWORD value to print out
//                              [chChars]               -       number of characters to print out, starting from right of number
//                              [fLeadZeros]    -       whether or not to print leading zeros
//                              [pchStr]                -       pointer of string to put printed out value, must have room for
//                                                                      chChars+1 chars (chChars digits and null byte)
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void FormatHex(unsigned long ulValue, unsigned long chChars, BOOL fLeadZeros, char *pchStr)
{
        if(!fLeadZeros)
        {
                unsigned long ulmask = 0xf<<((chChars-1)<<4);

                // determine how many leading zeros there are
                while(!(ulValue & ulmask) && (chChars > 1))
                {
                        chChars--;
                        ulmask >>=4;
                }

                FormatHexNum(ulValue, chChars, pchStr);

                // tag on null byte
                pchStr[chChars] = '\0';

        }
        else
        {
                FormatHexNum(ulValue, chChars, pchStr);

                // tag on null byte
                pchStr[chChars] = '\0';
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   IntToString
//
//  Synopsis:  Prints out a integer to a string (base 10)
//
//  Arguments:  [n]                             -       integer to print out
//                              [pStr]                  -       pointer of string to put printed out value
//                              [nMax]                  -       maximum number of characters
//                              [fUnsigned]             -       whether or not value is unsigned
//
//      Returns:        pStr
//
//  History:    15-Jul-95   t-stevan   Created
//
//      NOtes:          nMax should be enough to hold the printed out string
//----------------------------------------------------------------------------
char *IntToString(unsigned long n, char *pStr, int nMax, BOOL fUnsigned)
{
        char *pChar;
        BOOL fSign= FALSE;
        int nCount;

        //      Special case, n = 0
        if(n == 0)
        {
                *pStr = '0';
                *(pStr+1) = '\0';

                return pStr;
        }

        if(!fUnsigned)
        {
                // if the value is signed, figure out what the sign of it is, and
                // then take absolute value
                if((fSign = ((int) n) < 0))
                {
                        n = -((int)n);
                }
        }


        // initialize pChar to point to the last character in pStr
        pChar = &(pStr[nMax-1]);
        // tag on null byte
        *pChar = '\0';
        pChar--;
        // null byte counts!
        nCount=1;

        //      loop until n == 0
        while(n && nCount <= nMax)
        {
                // write digit
                *pChar = '0'+(char)(n%10);
                // move to next digit
                pChar--;
                // increase digit count
                nCount++;
                // divide n by 10
                n/=10;
        }

        if(nCount > nMax)
        {
                return pStr;    // we failed, but still return pStr
        }

        if(fSign)
        {
                *pStr = '-';    // tag on sign
                memmove(pStr+1, pChar+1, nCount); // move string to front
        }
        else
        {
                memmove(pStr, pChar+1, nCount); // move string to front
        }

        return pStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteIntCommon
//
//  Synopsis:  Common functionality for printing out integer values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fUnsigned]             -       whether or not value is unsigned
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteIntCommon(CTextBufferA &buf, unsigned int param, BOOL fUnsigned)
{
        char temp[TEMP_SIZE];

        IntToString(param, temp, TEMP_SIZE, fUnsigned);
        //      _ltoa((int) param, temp, 10);

        // do write op
        buf << temp;
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePointerCommon
//
//  Synopsis:  Common functionality for printing pointers
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pPointer]              -       pointer to print out
//                              [fCaps]                 -       whether or not to use capitalized hex digits (ABCDEF)
//                              [fKnownBad]             -       whether or not the pointer is known to be bad
//                              [fXlatSym]              -       whether or not we should attempt to address->symbol
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePointerCommon(CTextBufferA &buf, void *pPointer, BOOL fCaps, BOOL fKnownBad, BOOL fXlatSym)
{
        char temp[TEMP_SIZE];

        if(pPointer == NULL)
        {
                buf << pscNullString;
                return;
        }

        if(fKnownBad)
        {
                // we know it's a bad pointer
                buf << pscPointerPrefix;
                buf << pscBadPointerPrefix;
        }
        else
        {
                buf << pscPointerPrefix;

                // validate pointer
                __try
                {
                        // try a read operation
                        temp[0] =       *((char *)pPointer);
                }
                __except (ExceptionFilter(_exception_code()))
                {
                        // bad pointer
                        buf << pscBadPointerPrefix;
                        fKnownBad = TRUE;
                }
        }

        if(!fKnownBad && fXlatSym)
        {
                // see if we can find a symbol for the pointer
                char symbol[MAXNAMELENGTH];
                DWORD64 dwDisplacement;

                if(g_pSym != NULL)
                {
                        if (g_pSym->GetSymNameFromAddr((DWORD64) pPointer, &dwDisplacement, symbol, MAXNAMELENGTH))
                        {
                                // found a symbol. Woo hoo!
                                WriteStringCommon(buf, symbol);

                                if(dwDisplacement != 0)
                                {
                                        buf << '+';

                                        buf << pscHexPrefix;

                                        // no leading zeros
                                        FormatHex((unsigned long) dwDisplacement, 8, FALSE, temp);

                                        buf << temp;
                                }

                                buf << pscPointerSuffix;

                                return;
                        }
                }
        }

        // add the hex prefix
        buf << pscHexPrefix;

        FormatHex((unsigned long) (ULONG_PTR) pPointer, 8, TRUE, temp);

        if(fCaps)
        {
            CharUpperBuffA (temp, lstrlenA (temp));
        }
        else
        {
            CharLowerBuffA (temp, lstrlenA (temp));
        }

        // do write op
        buf << temp;

        // write suffix
        buf << pscPointerSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLargeCommon
//
//  Synopsis:  Common functionality for printing out a 64-bitinteger values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fUnsigned]             -       whether or not value is unsigned (currently ignored)
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//      Note:           currently 64-bit integers are printed out as unsigned hex numbers
//----------------------------------------------------------------------------
void WriteLargeCommon(CTextBufferA &buf, const __int64 *pInt, BOOL fUnsigned)
{
        char temp[TEMP_SIZE];

        __try // catch bad pointers
        {
                // right now we ignore the fUnsigned parameter and print out
                // as an unsigned hex integer
                FormatHex((unsigned long) ((*pInt)>>32), 8, FALSE,  temp);

                buf << pscHexPrefix;
                buf << temp;

                FormatHex((unsigned long) ((*pInt)&0xffffffff), 8, TRUE, temp);

                buf << temp;
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer, just print out the pointer passed
                WritePointerCommon(buf, (void *) pInt, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHexCommon
//
//  Synopsis:  Common functionality for printing out hex integer values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fCaps]                 -       whether or not to print capital hex digits (ABCDEF)
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteHexCommon(CTextBufferA &buf, ULONG param, BOOL fCaps)
{
        char temp[TEMP_SIZE];

        buf << pscHexPrefix;

        // write out number
        FormatHex((unsigned long) param, 8, TRUE, temp);

        if(fCaps)
        {
            CharUpperBuffA (temp, lstrlenA (temp));
        }
        else
        {
            CharLowerBuffA (temp, lstrlenA (temp));
        }

        // do write op
        buf << temp;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBoolCommon
//
//  Synopsis:  Common functionality for printing out boolean values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fCaps]                 -       whether or not to print capital characters
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBoolCommon(CTextBufferA &buf, BOOL param, BOOL fCaps)
{
        const char *pTrue, *pFalse;

        if(fCaps)
        {
                pTrue = pscTRUE;
                pFalse = pscFALSE;
        }
        else
        {
                pTrue = pscTrue;
                pFalse = pscFalse;
        }

        if(param)
        {
                buf << pTrue;
        }
        else
        {
                buf << pFalse;
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteStringCommon
//
//  Synopsis:  Common functionality for printing out ASCII strings
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pString]               -       pointer to ASCII string
//                              [fQuote]                -       whether or not to enclose the string in quotes
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteStringCommon(CTextBufferA &buf, const char *pString, BOOL fQuote)
{
        BufferContext bc;

        // take a snapshot of the buffer first
        buf.SnapShot(bc);

        __try
        {
                if(fQuote)
                {
                        buf << '\"';
                }

                buf << pString;

                if(fQuote)
                {
                        buf << '\"';
                }
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer
                // first try to rever the buffer
                buf.Revert(bc);

                WritePointerCommon(buf, (void *) pString, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteWideStringCommon
//
//  Synopsis:  Common functionality for printing out Unicode strings
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pwsStr]                -       pointer to Unicode string
//                              [fQuote]                -       whether or not to enclose the string in quotes
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteWideStringCommon(CTextBufferA& buf, const WCHAR *pwsStr, BOOL fQuote)
{
        BufferContext bc;

        // take a snapshot of the buffer first
        buf.SnapShot(bc);

        __try
        {
                if(fQuote)
                {
                        buf << '\"';
                }

                while(*pwsStr != 0)
                {
                        if(*pwsStr & 0xff00)
                        {
                                // if high byte has info, set to
                                // 0x13, which is two !'s
                                buf << (char) 0x13;
                        }
                        else
                        {
                                buf << (char) (*pwsStr &0xff);
                        }

                        pwsStr++;
                }

                if(fQuote)
                {
                        buf << '\"';
                }
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer
                // try to revert the buffer
                buf.Revert(bc);

                WritePointerCommon(buf, (void *) pwsStr, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteGUIDCommon
//
//  Synopsis:  Common functionality for printing out GUIDs
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pGUID]                 -       pointer to GUID to print
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteGUIDCommon(CTextBufferA& buf, const GUID *pGUID)
{
        char temp[GUIDSTR_MAX+1];
        BufferContext bc;

        // take a snapshot of the buffer first
        buf.SnapShot(bc);

        __try
        {
                StrFromGUID(*pGUID, temp, GUIDSTR_MAX);

                // tack on null byte
                temp[GUIDSTR_MAX - 1] = '\0';

                // write the string out
                buf << temp;
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer
                // try to revert the buffer
                buf.Revert(bc);

                WritePointerCommon(buf, (void *) pGUID, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteFILETIME
//
//  Synopsis:  Prints out a FILETIME structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pFileTime]             -       pointer to FILETIME structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteFILETIME(CTextBufferA& buf, FILETIME *pFileTime)
{
        SYSTEMTIME sysTime;

        buf << pscStructPrefix;

        if(FileTimeToSystemTime(pFileTime, &sysTime))
        {
                char temp[TEMP_SIZE];

                IntToString(sysTime.wMonth, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << '/';

                IntToString(sysTime.wDay, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << '/';

                IntToString(sysTime.wYear, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << ' ';

                IntToString(sysTime.wHour, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << ':';

                if(sysTime.wMinute == 0)
                {
                        buf << "00";
                }
                else
                {
                        IntToString(sysTime.wMinute, temp, TEMP_SIZE, TRUE);

                        buf << temp;
                }
        }
        else
        {
                buf << "dwLowDateTime= ";

                WriteHexCommon(buf, pFileTime->dwLowDateTime, FALSE);

                buf << pscStructDelim;

                buf << "dwHighDateTime= ";

                WriteHexCommon(buf, pFileTime->dwHighDateTime, FALSE);

        }

        buf << pscStructSuffix;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteRECT
//
//  Synopsis:  Prints out a RECT structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pRECT]         -       pointer to RECT structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteRECT(CTextBufferA& buf, RECT *pRect)
{
        buf << pscStructPrefix;

        buf << "left= ";

        WriteIntCommon(buf, pRect->left, FALSE);

        buf << pscStructDelim;

        buf << "top= ";

        WriteIntCommon(buf, pRect->top, FALSE);

        buf << pscStructDelim;

        buf << "right= ";

        WriteIntCommon(buf, pRect->right, FALSE);

        buf << pscStructDelim;

        buf << "bottom= ";

        WriteIntCommon(buf, pRect->bottom, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSIZE
//
//  Synopsis:  Prints out a SIZE structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pSIZE]         -       pointer to SIZE structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteSIZE(CTextBufferA& buf, SIZE *pSize)
{
        buf << pscStructPrefix;

        buf << "cx= ";

        WriteIntCommon(buf, pSize->cx, FALSE);

        buf << pscStructDelim;

        buf << "cy= ";

        WriteIntCommon(buf, pSize->cy, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLOGPALETTE
//
//  Synopsis:  Prints out a LOGPALETTE structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pLOGPALETTE]           -       pointer to LOGPALETTE structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteLOGPALETTE(CTextBufferA& buf, LOGPALETTE *pPal)
{
        buf << pscStructPrefix;

        buf << "palVersion= ";

        WriteHexCommon(buf, pPal->palVersion, TRUE);

        buf << pscStructDelim;

        buf << "palNumEntries= ";

        WriteIntCommon(buf, pPal->palNumEntries, TRUE);

        buf << pscStructDelim;

        buf << "palPalEntry[]= ";

        WritePointerCommon(buf, pPal->palPalEntry, FALSE, FALSE, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePOINT
//
//  Synopsis:  Prints out a POINT structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pPOINT]                -       pointer to POINT structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePOINT(CTextBufferA& buf, POINT *pPoint)
{
        buf << pscStructPrefix;

        buf << "x= ";

        WriteIntCommon(buf, pPoint->x, FALSE);

        buf << pscStructDelim;

        buf << "y= ";

        WriteIntCommon(buf, pPoint->y, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteMSG
//
//  Synopsis:  Prints out a MSG structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pMSG]          -       pointer to MSG structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteMSG(CTextBufferA& buf, MSG *pMsg)
{
        buf << pscStructPrefix;

        buf << "hwnd= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR) pMsg->hwnd, FALSE);

        buf << pscStructDelim;

        buf << "message= ";

        WriteIntCommon(buf, pMsg->message, TRUE);

        buf << pscStructDelim;

        buf << "wParam= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR)pMsg->wParam, FALSE);

        buf << pscStructDelim;

        buf << "lParam= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR)pMsg->lParam, FALSE);

        buf << pscStructDelim;

        buf << "time= ";

        WriteIntCommon(buf, pMsg->time, TRUE);

        buf << pscStructDelim;

        buf << "pt= ";

        WritePOINT(buf, &(pMsg->pt));

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteTYMED
//
//  Synopsis:  Prints out a TYMED enumeration
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [tymed]                 -       TYMED value
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteTYMED(CTextBufferA &buf, DWORD tymed)
{
        switch(tymed)
        {
                case TYMED_NULL:
                        buf << "TYMED_NULL";
                        break;

                case TYMED_GDI:
                        buf << "TYMED_GDI";
                        break;

                case TYMED_MFPICT:
                        buf << "TYMED_MFPICT";
                        break;

                case TYMED_ENHMF:
                        buf << "TYMED_ENHMF";
                        break;

                case TYMED_HGLOBAL:
                        buf << "TYMED_HGLOBAL";
                        break;

                case TYMED_FILE:
                        buf << "TYMED_FILE";
                        break;

                case TYMED_ISTREAM:
                        buf << "TYMED_ISTREAM";
                        break;

                case TYMED_ISTORAGE:
                        buf << "TYMED_ISTORAGE";
                        break;

                default:
                        {
                                char temp[TEMP_SIZE];

                                _ultoa(tymed, temp, 10);

                                buf << temp;
                        }
                        break;
        } // switch
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSTGMEDIUM
//
//  Synopsis:  Prints out a STGMEDIUM structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pSTGMEDIUM]            -       pointer to STGMEDIUM structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteSTGMEDIUM(CTextBufferA& buf, STGMEDIUM *pStg)
{
        buf << pscStructPrefix;

        buf << "tymed= ";

        WriteTYMED(buf, pStg->tymed);

        buf << pscStructDelim;

        switch(pStg->tymed)
        {
                case TYMED_GDI:
                        buf <<  "hBitmap= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hBitmap, FALSE);
                        break;

                case TYMED_MFPICT:
                        buf << "hMetaFilePict= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hMetaFilePict, FALSE);
                        break;

                case TYMED_ENHMF:
                        buf << "hEnhMetaFile= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hEnhMetaFile, FALSE);
                        break;

                case TYMED_HGLOBAL:
                        buf << "hGlobal= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hGlobal, FALSE);
                        break;

                case TYMED_FILE:
                        buf << "lpszFileName= ";
                        WriteWideStringCommon(buf, pStg->lpszFileName, TRUE);
                        break;

                case TYMED_ISTREAM:
                        buf << "pstm= ";
                        WritePointerCommon(buf, (void *) pStg->pstm, FALSE, FALSE, FALSE);
                        break;

                case TYMED_ISTORAGE:
                        buf << "pstg= ";
                        WritePointerCommon(buf, (void *) pStg->pstg, FALSE, FALSE, FALSE);
                        break;

                default:
                        buf << "?= ????????";
                        break;
        } // switch

        buf << pscStructDelim;

        buf << "pUnkForRelease= ";

        WritePointerCommon(buf, (void *) pStg->pUnkForRelease, FALSE, FALSE, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteFORMATETC
//
//  Synopsis:  Prints out a FORMATETC structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//              [pFORMATETC]            -       pointer to FORMATETC structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteFORMATETC(CTextBufferA& buf, FORMATETC *pETC)
{
        buf << pscStructPrefix;

        // TODO: write out enum?
        buf << "cfFormat= ";

        if (NULL == pETC)
        {
            buf << "NULL";
        }
        else
        {
            WriteIntCommon(buf, pETC->cfFormat, FALSE);

            buf << pscStructDelim;

            buf << "ptd= ";

            WritePointerCommon(buf, (void *) pETC->ptd, FALSE, FALSE, FALSE);

            buf << pscStructDelim;

            buf << "dwAspect= ";

            WriteIntCommon(buf, pETC->dwAspect, TRUE);

            buf << pscStructDelim;

            buf << "lindex= ";

            WriteIntCommon(buf, pETC->lindex, FALSE);

            buf << pscStructDelim;

            buf << "tymed= ";

            WriteTYMED(buf, pETC->tymed);
        }

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteDVTARGETDEVICE
//
//  Synopsis:  Prints out a DVTARGETDEVICE structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pDVTARGETDEVICE]               -       pointer to DVTARGETDEVICE structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteDVTARGETDEVICE(CTextBufferA& buf, DVTARGETDEVICE *ptd)
{
        buf << pscStructPrefix;

        buf << "tdSize= ";

        WriteIntCommon(buf, ptd->tdSize, TRUE);

        buf << pscStructDelim;

        if(ptd->tdDriverNameOffset != 0)
        {
                buf << "tdDriverName= ";

                WriteStringCommon(buf, (const char *) (((BYTE *)ptd)+ptd->tdDriverNameOffset), TRUE);
        }
        else
        {
                buf << "tdDriverNameOffset= 0";
        }

        buf << pscStructDelim;

        if(ptd->tdDeviceNameOffset != 0)
        {
                buf << "tdDeviceName= ";

                WriteStringCommon(buf, (const char *) (((BYTE *)ptd)+ptd->tdDeviceNameOffset), TRUE);
        }
        else
        {
                buf << "tdDeviceNameOffset= 0";
        }

        buf << pscStructDelim;

        if(ptd->tdPortNameOffset != 0)
        {
                buf << "tdPortName= ";

                WriteStringCommon(buf, (const char *) (((BYTE *)ptd)+ptd->tdPortNameOffset), TRUE);
        }
        else
        {
                buf << "tdPortNameOffset= 0";
        }


        buf << pscStructDelim;

        if(ptd->tdExtDevmodeOffset != 0)
        {
                buf << "&tdExtDevmode= ";

                WritePointerCommon(buf, (void *) (((BYTE *)ptd)+ptd->tdExtDevmodeOffset), FALSE, FALSE, FALSE);
        }
        else
        {
                buf << "tdExtDevmodeOffset= 0";
        }

        buf << pscStructSuffix;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBIND_OPTS
//
//  Synopsis:  Prints out a BIND_OPTS structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pBIND_OPTS]            -       pointer to BIND_OPTS structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBIND_OPTS(CTextBufferA& buf, BIND_OPTS *pOpts)
{
        buf << pscStructPrefix;

        buf << "cbStruct= ";

        WriteIntCommon(buf, pOpts->cbStruct, TRUE);

        buf << pscStructDelim;

        buf << "grfFlags= ";

        WriteHexCommon(buf, pOpts->grfFlags, FALSE);

        buf << pscStructDelim;

        buf << "grfMode= ";

        WriteHexCommon(buf, pOpts->grfMode, FALSE);

        buf << pscStructDelim;

        buf << "dwTickCountDeadLine= ";

        WriteIntCommon(buf, pOpts->dwTickCountDeadline, TRUE);

        buf << pscStructSuffix;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSTATSTG
//
//  Synopsis:  Prints out a STATSTG structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pSTATSTG]              -       pointer to STATSTG structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteSTATSTG(CTextBufferA& buf, STATSTG *pStat)
{
        buf << pscStructPrefix;

        buf << "pwcsName= ";

        WriteWideStringCommon(buf, pStat->pwcsName, TRUE);

        buf << pscStructDelim;

        buf << "type= ";

        WriteHexCommon(buf, pStat->type, FALSE);

        buf << pscStructDelim;

        buf << "cbSize= ";

        WriteLargeCommon(buf, (__int64 *) &(pStat->cbSize), TRUE);

        buf << pscStructDelim;

        buf << "mtime= ";

        WriteFILETIME(buf, &(pStat->mtime));

        buf << pscStructDelim;

        buf << "ctime= ";

        WriteFILETIME(buf, &(pStat->ctime));

        buf << pscStructDelim;

        buf << "atime= ";

        WriteFILETIME(buf, &(pStat->atime));

        buf << pscStructDelim;

        buf << "grfMode= ";

        WriteHexCommon(buf, pStat->grfMode, FALSE);

        buf << pscStructDelim;

        buf << "grfLocksSupported= ";

        WriteHexCommon(buf, pStat->grfLocksSupported, FALSE);

        buf << pscStructDelim;

        buf << "clsid= ";

        WriteGUIDCommon(buf, (const GUID *) &(pStat->clsid));

        buf << pscStructDelim;

        buf << "grfStateBits= ";

        WriteHexCommon(buf, pStat->grfStateBits, FALSE);

        buf << pscStructDelim;

        buf << "Reserved= ";

        WriteHexCommon(buf, pStat->reserved, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteOLEINPLACEFRAMEINFO
//
//  Synopsis:  Prints out a OLEINPLACEFRAMEINFO structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pOLEINPLACEFRAMEINFO]          -       pointer to OLEINPLACEFRAMEINFO structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteOLEINPLACEFRAMEINFO(CTextBufferA& buf, OLEINPLACEFRAMEINFO *pInfo)
{
        buf << pscStructPrefix;

        buf << "cb= ";

        WriteIntCommon(buf, pInfo->cb, TRUE);

        buf << pscStructDelim;

        buf << "fMDIApp= ";

        WriteBoolCommon(buf, pInfo->fMDIApp, TRUE);

        buf << pscStructDelim;

        buf << "hwndFrame= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR) pInfo->hwndFrame, FALSE);

        buf << pscStructDelim;

        buf << "haccel= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR) pInfo->haccel, FALSE);

        buf << pscStructDelim,

        buf << "cAccelEntries= ";

        WriteIntCommon(buf, pInfo->cAccelEntries, TRUE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteOLEMENUGROUPWIDTHS
//
//  Synopsis:  Prints out a OLEMENUGROUPWIDTHS structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pOLEMENUGROUPWIDTHS]           -       pointer to OLEMENUGROUPWIDTHS structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteOLEMENUGROUPWIDTHS(CTextBufferA& buf, OLEMENUGROUPWIDTHS *pWidths)
{
        buf << pscStructPrefix;

        for(int i = 0; i < 5; i++)
        {
                WriteIntCommon(buf, pWidths->width[i], FALSE);

                buf << pscStructDelim;
        }

        WriteIntCommon(buf, pWidths->width[5], FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteINTERFACEINFO
//
//  Synopsis:  Prints out a INTERFACEINFO structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pINTERFACEINFO]                -       pointer to INTERFACEINFO structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteINTERFACEINFO(CTextBufferA &buf, INTERFACEINFO *pInfo)
{
        buf << pscStructPrefix;

        buf << "pUnk= ";

        WritePointerCommon(buf, pInfo->pUnk, FALSE, FALSE, FALSE);

        buf << pscStructDelim;

        buf << "iid= ";

        WriteGUIDCommon(buf, (const GUID *) &(pInfo->iid));

        buf << pscStructDelim;

        buf << "wMethod= ";

        WriteIntCommon(buf, pInfo->wMethod, TRUE);

        buf << pscStructSuffix;
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\outfuncs.h ===
#ifndef __OUTFUNCS_H__
#define __OUTFUNCS_H__
// Array of callback functions which will be called to print buffer
#define BUFFER_MAX_FUNCTIONS 5

typedef VOID (*StringOutFunc) (const char *);

#if defined(__cplusplus)
extern "C"
{
#endif
void AddOutputFunction(StringOutFunc pfunc);
void DelOutputFunction(StringOutFunc pfunc);
void CallOutputFunctions(const char *buffer);
void OutputLogFileA(const char *buf);
void WriteToDebugScreen(BOOL flag);
void WriteToLogFile(LPCTSTR lpfn);
void OpenDebugSinks();
void CloseDebugSinks();

#if defined(__cplusplus)
}
#endif

#endif // __OUTFUNCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	proto.h
//
//  Contents:	File used to spoof idl generated h files. Used by NT1x and
//		Chicago builds.
//
//  History:	10-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   06-05-95  SVA   Added support for printing GUIDs.
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"

/* temporary work-around for compiler without 64-bit support */

#ifndef _INTEGRAL_MAX_BITS
#define _INTEGRAL_MAX_BITS  64
#endif  /* _INTEGRAL_MAX_BITS */

/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if defined(_WIN64)
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#elif PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */
#define FL_I64        0x08000     /* __int64 value given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

/* Brief description of the table, since I can't find maketab.c - t-stevan     */
/* Each entry in form 0xYZ. Here Z is a character class used in the macro      */
/* find_char_class defined below. The character classes are defined in the     */
/* CHARTYPE enum. For example, 'I' maps to CH_TYPE. To find a particular entry */
/* Subtract the ASCI value for the space char from the character, and that is  */
/* the index to look up. The Y value is holds state transition information.    */
/* It is used in the macro find_next_state. */
static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x38, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x07, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#if _INTEGRAL_MAX_BITS >= 64
LOCAL(__int64) get_int64_arg(va_list *pargptr);
#endif  /* _INTEGRAL_MAX_BITS >= 64    */

LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif

/* Defines for printing out GUIDs */
#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED

/* This is actually one less than the normal GUIDSTR_MAX */
/* Because we don't tag on a NULL byte */
#define OUTPUT_GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 /* + 1 */)

/* Make sure our buffer size is big enough to hold a GUID */
#if BUFFERSIZE < OUTPUT_GUIDSTR_MAX
#undef BUFFERSIZE
#define BUFFERSIZE OUTPUT_GUIDSTR_MAX
#endif

/* Function used to write a GUID to a string */
int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
        NORMAL_STATE:

            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

            case 'L':
#if !LONGDOUBLE_IS_DOUBLE
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
#endif
                flags |= FL_I64;        /* 'L' => __int64 */
                break;

            case 'I':
                /*
                 * In order to handle the I64 size modifier, we depart from
                 * the simple deterministic state machine. The code below
                 * scans
                 */
                if ( (*format == '6') && (*(format + 1) == '4') ) {
                    format += 2;
                    flags |= FL_I64;    /* I64 => __int64 */
                }
                else {
                    state = ST_NORMAL;
                    goto NORMAL_STATE;
                }
                break;

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
	    case 't':
#ifdef _UNICODE
		flags |= FL_WIDE;
#endif
		break;

            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /*string length*/
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            /* print a GUID */
            case 'I':
            {
                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

			    if (p == NULL)
			    {
			   		/* null ptr passed, use special string */
			   		text = nullstring;
					textlen = strlen(nullstring);
				}
				else
               	{
               		textlen = StrFromGUID(p, buffer, BUFFERSIZE);
               		text = buffer;
				}
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;

#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

#if _INTEGRAL_MAX_BITS >= 64
                unsigned __int64 number;    /* number to convert */
                int digit;              /* ascii value of digit */
                __int64 l;              /* temp long value */
#else  /* _INTEGRAL_MAX_BITS >= 64            */
                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */
#endif  /* _INTEGRAL_MAX_BITS >= 64            */

                /* 1. read argument into l, sign extend as needed */
#if _INTEGRAL_MAX_BITS >= 64
                if (flags & FL_I64)
                    l = get_int64_arg(&argptr);
                else
#endif  /* _INTEGRAL_MAX_BITS >= 64        */

#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

#if _INTEGRAL_MAX_BITS >= 64
                if ( (flags & FL_I64) == 0 ) {
                    /*
                     * Unless printing a full 64-bit value, insure values
                     * here are not in cananical longword format to prevent
                     * the sign extended upper 32-bits from being printed.
                     */
                    number &= 0xffffffff;
                }
#endif  /* _INTEGRAL_MAX_BITS >= 64        */

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif


#if _INTEGRAL_MAX_BITS >= 64
LOCAL(__int64) get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif  /* _INTEGRAL_MAX_BITS >= 64    */

/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}


const wchar_t a_wcDigits[] = L"0123456789ABCDEF";

//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNum
//
//  Synopsis:   Given a value, and a count of characters, translate
//		the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//		[chChars] -- Number of characters to format
//		[pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    5-31-95   t-stevan  Copied and Modified for use in debug output function
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
	while(chChars--)
	{
		pchStr[chChars] = (char) a_wcDigits[ulValue & 0xF];
		ulValue = ulValue >> 4;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   StrFromGUID     (private)
//
//  Synopsis:   Converts a GUID into a string (duh!)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax)  // internal
{
    if (cbMax < OUTPUT_GUIDSTR_MAX)
	return 0;


//   Make the GUID into"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",

    *lpsz++ = '{';
    FormatHexNum( rguid->Data1, 8 , lpsz);
    lpsz += 8;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data2, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data3, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[0], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[1], 2 , lpsz);
    lpsz += 2;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[2], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[3], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[4], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[5], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[6], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[7], 2 , lpsz);
    lpsz += 2;

    *lpsz++ = '}';
    /* We don't want to tag on a NULL char because we don't need to print one out *\
    /* *lpsz = 0; */


    return OUTPUT_GUIDSTR_MAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"
#ifdef _W4DPRINTF_
#include "outfuncs.h"
#endif

#if defined(_W4PRINTF_)
    static HANDLE fh;
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == INVALID_HANDLE_VALUE)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = GetStdHandle(ldummy)) == 0 || fh == INVALID_HANDLE_VALUE)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        CallOutputFunctions(f->pchstart); // funnel through outfuncs
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\rwlock.cxx ===
//+-------------------------------------------------------------------
//
//  File:       RWLock.cxx
//
//  Contents:   Reader writer lock implementation that supports the
//              following features
//                  1. Cheap enough to be used in large numbers
//                     such as per object synchronization.
//                  2. Supports timeout. This is a valuable feature
//                     to detect deadlocks
//                  3. Supports caching of events. This allows
//                     the events to be moved from least contentious
//                     regions to the most contentious regions.
//                     In other words, the number of events needed by
//                     Reader-Writer lockls is bounded by the number
//                     of threads in the process.
//                  4. Supports nested locks by readers and writers
//                  5. Supports spin counts for avoiding context switches
//                     on  multi processor machines.
//                  6. Supports functionality for upgrading to a writer
//                     lock with a return argument that indicates
//                     intermediate writes. Downgrading from a writer
//                     lock restores the state of the lock.
//                  7. Supports functionality to Release Lock for calling
//                     app code. RestoreLock restores the lock state and
//                     indicates intermediate writes.
//                  8. Recovers from most common failures such as creation of
//                     events. In other words, the lock mainitains consistent
//                     internal state and remains usable
//
//
//  Classes:    CRWLock
//              CStaticRWLock
//
//  History:    19-Aug-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include "RWLock.hxx"

// Reader increment
#define READER                 0x00000001
// Max number of readers
#define READERS_MASK           0x000003FF
// Reader being signaled
#define READER_SIGNALED        0x00000400
// Writer being signaled
#define WRITER_SIGNALED        0x00000800
#define WRITER                 0x00001000
// Waiting reader increment
#define WAITING_READER         0x00002000
// Note size of waiting readers must be less
// than or equal to size of readers
#define WAITING_READERS_MASK   0x007FE000
#define WAITING_READERS_SHIFT  13
// Waiting writer increment
#define WAITING_WRITER         0x00800000
// Max number of waiting writers
#define WAITING_WRITERS_MASK   0xFF800000
// Events are being cached
#define CACHING_EVENTS         (READER_SIGNALED | WRITER_SIGNALED)

// Reader lock was upgraded
#define INVALID_COOKIE         0x01
#define UPGRADE_COOKIE         0x02
#define RELEASE_COOKIE         0x04
#define COOKIE_NONE            0x10
#define COOKIE_WRITER          0x20
#define COOKIE_READER          0x40

DWORD gdwDefaultTimeout = INFINITE;
DWORD gdwDefaultSpinCount = 0;
DWORD gdwNumberOfProcessors = 1;
DWORD gdwLockSeqNum = 0;
BOOL fBreakOnErrors = FALSE; 
const DWORD gdwReasonableTimeout = 120000;
const DWORD gdwMaxReaders = READERS_MASK;
const DWORD gdwMaxWaitingReaders = (WAITING_READERS_MASK >> WAITING_READERS_SHIFT);


#ifdef __NOOLETLS__
DWORD gLockTlsIdx;
#endif

#define RWLOCK_FATALFAILURE  1000
#define HEAP_SERIALIZE       0 

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::InitDefaults     public
//
//  Synopsis:   Reads default values from registry
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::InitDefaults()
{
    SYSTEM_INFO system;

    // Obtain number of processors on the system
    GetSystemInfo(&system);
    gdwNumberOfProcessors = system.dwNumberOfProcessors;
    gdwDefaultSpinCount = (gdwNumberOfProcessors > 1) ? 500 : 0;

    // Obtain system wide timeout value
    HKEY hKey;
    LONG lRetVal = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                 "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                                 NULL,
                                 KEY_READ,
                                 &hKey);
    if(lRetVal == ERROR_SUCCESS)
    {
        DWORD dwTimeout, dwSize = sizeof(dwTimeout);

        lRetVal = RegQueryValueExA(hKey,
                                   "CriticalSectionTimeout",
                                   NULL,
                                   NULL,
                                   (LPBYTE) &dwTimeout,
                                   &dwSize);
        if(lRetVal == ERROR_SUCCESS)
        {
            gdwDefaultTimeout = dwTimeout * 2000;
        }
        RegCloseKey(hKey);
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::Cleanup    public
//
//  Synopsis:   Cleansup state
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::Cleanup()
{

#if DBG==1

    if (g_fDllState != DLL_STATE_PROCESS_DETACH)
    {
        // Perform sanity checks if we're not shutting down
        Win4Assert(_dwState == 0);
        Win4Assert(_dwWriterID == 0);
        Win4Assert(_wWriterLevel == 0);
    }
#endif

    if(_hWriterEvent)
        CloseHandle(_hWriterEvent);
    if(_hReaderEvent)
        CloseHandle(_hReaderEvent);

#if LOCK_PERF==1
    gLockTracker.ReportContention(this,
                                  _dwWriterEntryCount,
                                  _dwWriterContentionCount,
                                  _dwReaderEntryCount,
                                  _dwReaderContentionCount);
#endif

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertWriterLockHeld    public
//
//  Synopsis:   Asserts that writer lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertWriterLockHeld()
{
    DWORD dwThreadID = GetCurrentThreadId();

    if(_dwWriterID != dwThreadID)
        Win4Assert(!"Writer lock not held by the current thread");

    return(_dwWriterID == dwThreadID);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertWriterLockNotHeld    public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertWriterLockNotHeld()
{
    DWORD dwThreadID = GetCurrentThreadId();

    if(_dwWriterID == dwThreadID)
        Win4Assert(!"Writer lock held by the current thread");

    return(_dwWriterID != dwThreadID);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderLockHeld    public
//
//  Synopsis:   Asserts that reader lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertReaderLockHeld()
{
    HRESULT hr;
    WORD *pwReaderLevel;
    BOOL fLockHeld = FALSE;

    hr = GetTLSLockData(&pwReaderLevel);
    if((hr == S_OK) && (*pwReaderLevel != 0))
        fLockHeld = TRUE;

    if(fLockHeld == FALSE)
        Win4Assert(!"Reader lock not held by the current thread");

    return(fLockHeld);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderLockNotHeld    public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertReaderLockNotHeld()
{
    HRESULT hr;
    WORD *pwReaderLevel;
    BOOL fLockHeld = FALSE;

    hr = GetTLSLockData(&pwReaderLevel);
    if((hr == S_OK) && (*pwReaderLevel != 0))
        fLockHeld = TRUE;

    if(fLockHeld == TRUE)
        Win4Assert(!"Reader lock held by the current thread");

    return(fLockHeld == FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderOrWriterLockHeld   public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#if DBG==1
BOOL CRWLock::AssertReaderOrWriterLockHeld()
{
    BOOL fLockHeld;

    if(_dwWriterID == GetCurrentThreadId())
    {
        fLockHeld = TRUE;
    }
    else
    {
        HRESULT hr;
        WORD *pwReaderLevel;

        hr = GetTLSLockData(&pwReaderLevel);
        if((hr == S_OK) && (*pwReaderLevel != 0))
            fLockHeld = TRUE;
    }

    Win4Assert(fLockHeld && "Neither Reader nor Writer lock held");

    return(fLockHeld);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ModifyState    public
//
//  Synopsis:   Helper function for updating the state inside the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline DWORD CRWLock::ModifyState(DWORD dwModifyState)
{
    return(InterlockedExchangeAdd((LONG *) &_dwState, dwModifyState));
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWSetEvent    public
//
//  Synopsis:   Helper function for setting an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWSetEvent(HANDLE event)
{
    if(!SetEvent(event))
    {
        Win4Assert(!"SetEvent failed");
        if(fBreakOnErrors)
            DebugBreak();
        TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWResetEvent    public
//
//  Synopsis:   Helper function for resetting an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWResetEvent(HANDLE event)
{
    if(!ResetEvent(event))
    {
        Win4Assert(!"ResetEvent failed");
        if(fBreakOnErrors)
            DebugBreak();
        TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWSleep    public
//
//  Synopsis:   Helper function for calling Sleep. Useful for debugging
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWSleep(DWORD dwTime)
{
    Sleep(dwTime);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseEvents    public
//
//  Synopsis:   Helper function for caching events
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef RWLOCK_FULL_FUNCTIONALITY
void CRWLock::ReleaseEvents()
{
    // Sanity check
    Win4Assert(_wFlags & RWLOCKFLAG_CACHEEVENTS);

    // Ensure that reader and writers have been stalled
    Win4Assert((_dwState & CACHING_EVENTS) == CACHING_EVENTS);

    // Save writer event
    HANDLE hWriterEvent = _hWriterEvent;
    _hWriterEvent = NULL;

    // Save reader event
    HANDLE hReaderEvent = _hReaderEvent;
    _hReaderEvent = NULL;

    // Allow readers and writers to continue
    ModifyState(-(CACHING_EVENTS));

    // Cache events
    // REVIEW: I am closing events for now. What is needed
    //         is an event cache to which the events are
    //         released using InterlockedCompareExchange64
    if(hWriterEvent)
    {
        ComDebOut((DEB_TRACE, "Releasing writer event\n"));
        CloseHandle(hWriterEvent);
    }
    if(hReaderEvent)
    {
        ComDebOut((DEB_TRACE, "Releasing reader event\n"));
        CloseHandle(hReaderEvent);
    }

    return;
}
#endif

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetWriterEvent    public
//
//  Synopsis:   Helper function for obtaining a auto reset event used
//              for serializing writers. It utilizes event cache
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HANDLE CRWLock::GetWriterEvent()
{
    if(_hWriterEvent == NULL)
    {
        HANDLE hWriterEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(hWriterEvent)
        {
            if(InterlockedCompareExchangePointer(&_hWriterEvent, hWriterEvent, NULL))
            {
                CloseHandle(hWriterEvent);
            }
        }
    }

    return(_hWriterEvent);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetReaderEvent    public
//
//  Synopsis:   Helper function for obtaining a manula reset event used
//              by readers to wait when a writer holds the lock.
//              It utilizes event cache
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HANDLE CRWLock::GetReaderEvent()
{
    if(_hReaderEvent == NULL)
    {
        HANDLE hReaderEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if(hReaderEvent)
        {
            if(InterlockedCompareExchangePointer(&_hReaderEvent, hReaderEvent, NULL))
            {
                CloseHandle(hReaderEvent);
            }
        }
    }

    return(_hReaderEvent);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AcquireReaderLock    public
//
//  Synopsis:   Makes the thread a reader. Supports nested reader locks.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   BOOL fReturnErrors,
                                   DWORD dwDesiredTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   const char *pszFile,
                                   DWORD dwLine,
                                   const char *pszLockName
#endif
                                  )
{
    HRESULT hr;
#ifndef RWLOCK_FULL_FUNCTIONALITY
    DWORD dwDesiredTimeout = gdwDefaultTimeout;
#endif

    // Ensure that the lock was initialized
    if(!IsInitialized())
        Initialize();

    // Check if the thread already has writer lock
    if(_dwWriterID == GetCurrentThreadId())
    {
        hr = AcquireWriterLock();
    }
    else
    {
        WORD *pwReaderLevel;

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            if(*pwReaderLevel != 0)
            {
                ++(*pwReaderLevel);
            }
            else
            {
                DWORD dwCurrentState, dwKnownState;
                DWORD dwSpinCount;

                // Initialize
                hr = S_OK;
                dwSpinCount = 0;
                dwCurrentState = _dwState;
                do
                {
                    dwKnownState = dwCurrentState;

                    // Reader need not wait if there are only readers and no writer
                    if((dwKnownState < READERS_MASK) ||
                        (((dwKnownState & READER_SIGNALED) && ((dwKnownState & WRITER) == 0)) &&
                         (((dwKnownState & READERS_MASK) +
                           ((dwKnownState & WAITING_READERS_MASK) >> WAITING_READERS_SHIFT)) <=
                          (READERS_MASK - 2))))
                    {
                        // Add to readers
                        dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                    (dwKnownState + READER),
                                                                    dwKnownState);
                        if(dwCurrentState == dwKnownState)
                        {
                            // One more reader
                            break;
                        }
                    }
                    // Check for too many Readers, or waiting readers
                    else if(((dwKnownState & READERS_MASK) == READERS_MASK) ||
                            ((dwKnownState & WAITING_READERS_MASK) == WAITING_READERS_MASK) ||
                            ((dwKnownState & CACHING_EVENTS) == READER_SIGNALED))
                    {
                        RWSleep(1000);
                        dwSpinCount = 0;
                        dwCurrentState = _dwState;
                    }
                    // Check if events are being cached
#ifdef RWLOCK_FULL_FUNCTIONALITY
                    else if((dwKnownState & CACHING_EVENTS) == CACHING_EVENTS)
                    {
                        if(++dwSpinCount > gdwDefaultSpinCount)
                        {
                            RWSleep(10);
                            dwSpinCount = 0;
                        }
                        dwCurrentState = _dwState;
                    }
#endif
                    // Check spin count
                    else if(++dwSpinCount > gdwDefaultSpinCount)
                    {
                        // Add to waiting readers
                        dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                    (dwKnownState + WAITING_READER),
                                                                    dwKnownState);
                        if(dwCurrentState == dwKnownState)
                        {
                            HANDLE hReaderEvent;
                            DWORD dwStatus;
                            DWORD dwModifyState;

                            // One more waiting reader
#ifdef RWLOCK_STATISTICS
                            InterlockedIncrement((LONG *) &_dwReaderContentionCount);
#endif
#if LOCK_PERF==1
                            gLockTracker.ReaderWaiting(pszFile, dwLine, pszLockName, this);
#endif

                            hReaderEvent = GetReaderEvent();
                            if(hReaderEvent)
                            {
                                dwStatus = WaitForSingleObject(hReaderEvent, dwDesiredTimeout);
                            }
                            else
                            {
                                ComDebOut((DEB_WARN,
                                           "AcquireReaderLock failed to create reader "
                                           "event for RWLock 0x%x\n", this));
                                dwStatus = WAIT_FAILED;
                                hr = RPC_E_OUT_OF_RESOURCES;
                            }

                            if(dwStatus == WAIT_OBJECT_0)
                            {
                                Win4Assert(_dwState & READER_SIGNALED);
                                Win4Assert((_dwState & READERS_MASK) < READERS_MASK);
                                dwModifyState = READER - WAITING_READER;
                            }
                            else
                            {
                                dwModifyState = -WAITING_READER;
                                if(dwStatus == WAIT_TIMEOUT)
                                {
                                    ComDebOut((DEB_WARN,
                                               "Timed out trying to acquire reader lock "
                                               "for RWLock 0x%x\n", this));
                                    hr = RPC_E_TIMEOUT;
                                }
                                else if(SUCCEEDED(hr))
                                {
                                    ComDebOut((DEB_ERROR,
                                               "WaitForSingleObject Failed for "
                                               "RWLock 0x%x\n", this));
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                }
                            }

                            // One less waiting reader and he may have become a reader
                            dwKnownState = ModifyState(dwModifyState);

                            // Check for last signaled waiting reader
                            if(((dwKnownState & WAITING_READERS_MASK) == WAITING_READER) &&
                               (dwKnownState & READER_SIGNALED))
                            {
                                dwModifyState = -READER_SIGNALED;
                                if(dwStatus != WAIT_OBJECT_0)
                                {
                                    if(hReaderEvent == NULL)
                                        hReaderEvent = GetReaderEvent();
                                    Win4Assert(hReaderEvent);
                                    dwStatus = WaitForSingleObject(hReaderEvent, INFINITE);
                                    Win4Assert(dwStatus == WAIT_OBJECT_0);
                                    Win4Assert((_dwState & READERS_MASK) < READERS_MASK);
                                    dwModifyState += READER;
                                    hr = S_OK;
                                }

                                RWResetEvent(hReaderEvent);
                                dwKnownState = ModifyState(dwModifyState);
                            }

                            // Check if the thread became a reader
                            if(dwStatus == WAIT_OBJECT_0)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        dwCurrentState = _dwState;
                    }
                } while(SUCCEEDED(hr));

                // Sanity checks
                if(SUCCEEDED(hr))
                {
                    Win4Assert((_dwState & WRITER) == 0);
                    Win4Assert(_dwState & READERS_MASK);
                    *pwReaderLevel = 1;
#ifdef RWLOCK_STATISTICS
                    InterlockedIncrement((LONG *) &_dwReaderEntryCount);
#endif
#if LOCK_PERF==1
                    gLockTracker.ReaderEntered(pszFile, dwLine, pszLockName, this);
#endif
                }
            }
        }

        // Check failure return
#if RWLOCK_FULL_FUNCTIONALITY
        if(FAILED(hr) && (fReturnErrors == FALSE))
#else
        if(FAILED(hr))
#endif
        {
            Win4Assert(!"Failed to acquire reader lock");
            if(fBreakOnErrors)
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AcquireWriterLock    public
//
//  Synopsis:   Makes the thread a writer. Supports nested writer
//              locks
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::AcquireWriterLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   BOOL fReturnErrors,
                                   DWORD dwDesiredTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   const char *pszFile,
                                   DWORD dwLine,
                                   const char *pszLockName
#endif
                                  )
{
    HRESULT hr = S_OK;
    DWORD dwThreadID = GetCurrentThreadId();
#ifndef RWLOCK_FULL_FUNCTIONALITY
    DWORD dwDesiredTimeout = gdwDefaultTimeout;
#endif

    // Ensure that the lock was initialized
    if(!IsInitialized())
        Initialize();

    // Check if the thread already has writer lock
    if(_dwWriterID == dwThreadID)
    {
        ++_wWriterLevel;
    }
    else
    {
        DWORD dwCurrentState, dwKnownState;
        DWORD dwSpinCount = 0;

        dwCurrentState = _dwState;
        do
        {
            dwKnownState = dwCurrentState;

            // Writer need not wait if there are no readers and writer
            if(dwKnownState == 0)
            {
                // Can be a writer
                dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                            WRITER,
                                                            dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    // Only writer
                    break;
                }
            }
            // Check for too many waiting writers
            else if(((dwKnownState & WAITING_WRITERS_MASK) == WAITING_WRITERS_MASK))
            {
                RWSleep(1000);
                dwSpinCount = 0;
                dwCurrentState = _dwState;
            }
            // Check if events are being cached
#ifdef RWLOCK_FULL_FUNCTIONALITY
            else if((dwKnownState & CACHING_EVENTS) == CACHING_EVENTS)
            {
                if(++dwSpinCount > gdwDefaultSpinCount)
                {
                    RWSleep(10);
                    dwSpinCount = 0;
                }
                dwCurrentState = _dwState;
            }
#endif
            // Check spin count
            else if(++dwSpinCount > gdwDefaultSpinCount)
            {
                // Add to waiting writers
                dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                            (dwKnownState + WAITING_WRITER),
                                                            dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    HANDLE hWriterEvent;
                    DWORD dwStatus;
                    DWORD dwModifyState;
                    BOOL fLoopback;

                    // One more waiting writer
#ifdef RWLOCK_STATISTICS
                    InterlockedIncrement((LONG *) &_dwWriterContentionCount);
#endif
#if LOCK_PERF==1
                    gLockTracker.WriterWaiting(pszFile, dwLine, pszLockName, this);
#endif

                    do
                    {
                        fLoopback = FALSE;
                        hr = S_OK;
                        hWriterEvent = GetWriterEvent();
                        if(hWriterEvent)
                        {
                            dwStatus = WaitForSingleObject(hWriterEvent, dwDesiredTimeout);
                        }
                        else
                        {
                            ComDebOut((DEB_WARN,
                                       "AcquireWriterLock failed to create writer "
                                       "event for RWLock 0x%x\n", this));
                            dwStatus = WAIT_FAILED;
                            hr = RPC_E_OUT_OF_RESOURCES;
                        }

                        if(dwStatus == WAIT_OBJECT_0)
                        {
                            Win4Assert(_dwState & WRITER_SIGNALED);
                            dwModifyState = WRITER - WAITING_WRITER - WRITER_SIGNALED;
                        }
                        else
                        {
                            dwModifyState = -WAITING_WRITER;
                            if(dwStatus == WAIT_TIMEOUT)
                            {
                                ComDebOut((DEB_WARN,
                                           "Timed out trying to acquire writer "
                                           "lock for RWLock 0x%x\n", this));
                                hr = RPC_E_TIMEOUT;
                            }
                            else if(SUCCEEDED(hr))
                            {
                                ComDebOut((DEB_ERROR,
                                           "WaitForSingleObject Failed for "
                                           "RWLock 0x%x\n", this));
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }

                        // One less waiting writer and he may have become a writer
                        dwKnownState = ModifyState(dwModifyState);

                        // Check for last timing out signaled waiting writer
                        if((dwStatus != WAIT_OBJECT_0) &&
                           (dwKnownState & WRITER_SIGNALED) &&
                           ((dwKnownState & WAITING_WRITERS_MASK) == WAITING_WRITER))
                        {
                            fLoopback = TRUE;
                            dwCurrentState = _dwState;
                            do
                            {
                                dwKnownState = dwCurrentState;
                                if(((dwKnownState & WAITING_WRITERS_MASK) == 0) &&
                                   (dwKnownState & WRITER_SIGNALED))
                                {
                                    dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                                (dwKnownState + WAITING_WRITER),
                                                                                dwKnownState);
                                }
                                else
                                {
                                    Win4Assert(FAILED(hr));
                                    fLoopback = FALSE;
                                    break;
                                }
                            } while(dwCurrentState != dwKnownState);
                        }

                        if(fLoopback)
                        {
                            ComDebOut((DEB_WARN,
                                       "Retry of timing out writer for RWLock 0x%x\n",
                                       this));
                            // Reduce the timeout value for retries
                            dwDesiredTimeout = 100;
                        }
                    } while(fLoopback);

                    // Check if the thread became a writer
                    if(dwStatus == WAIT_OBJECT_0)
                        break;
                }
            }
            else
            {
                dwCurrentState = _dwState;
            }
        } while(SUCCEEDED(hr));

        // Sanity checks
        if(SUCCEEDED(hr))
        {
            Win4Assert(_dwState & WRITER);
            Win4Assert((_dwState & WRITER_SIGNALED) == 0);
            Win4Assert((_dwState & READERS_MASK) == 0);
            Win4Assert(_dwWriterID == 0);

            // Save threadid of the writer
            _dwWriterID = dwThreadID;
            _wWriterLevel = 1;
            ++_dwWriterSeqNum;
#ifdef RWLOCK_STATISTICS
            ++_dwWriterEntryCount;
#endif
#if LOCK_PERF==1
            gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this);
#endif
        }
#ifdef RWLOCK_FULL_FUNCTIONALITY
        else if(fReturnErrors == FALSE)
#else
        else
#endif
        {
            Win4Assert(!"Failed to acquire writer lock");
            if(fBreakOnErrors)
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseWriterLock    public
//
//  Synopsis:   Removes the thread as a writer if not a nested
//              call to release the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::ReleaseWriterLock()
{
    HRESULT hr = S_OK;
    DWORD dwThreadID = GetCurrentThreadId();

    // Check validity of caller
    if(_dwWriterID == dwThreadID)
    {
        // Sanity check
        Win4Assert(IsInitialized());

        // Check for nested release
        if(--_wWriterLevel == 0)
        {
            DWORD dwCurrentState, dwKnownState, dwModifyState;
            BOOL fCacheEvents;
            HANDLE hReaderEvent = NULL, hWriterEvent = NULL;

            // Not a writer any more
#if LOCK_PERF==1
            gLockTracker.WriterLeaving(this);
#endif
            _dwWriterID = 0;
            dwCurrentState = _dwState;
            do
            {
                dwKnownState = dwCurrentState;
                dwModifyState = -WRITER;
                fCacheEvents = FALSE;
                if(dwKnownState & WAITING_READERS_MASK)
                {
                    hReaderEvent = GetReaderEvent();
                    if(hReaderEvent == NULL)
                    {
                        ComDebOut((DEB_WARN,
                                   "ReleaseWriterLock failed to create "
                                   "reader event for RWLock 0x%x\n", this));
                        RWSleep(100);
                        dwCurrentState = _dwState;
                        dwKnownState = 0;
                        Win4Assert(dwCurrentState != dwKnownState);
                        continue;
                    }
                    dwModifyState += READER_SIGNALED;
                }
                else if(dwKnownState & WAITING_WRITERS_MASK)
                {
                    hWriterEvent = GetWriterEvent();
                    if(hWriterEvent == NULL)
                    {
                        ComDebOut((DEB_WARN,
                                   "ReleaseWriterLock failed to create "
                                   "writer event for RWLock 0x%x\n", this));
                        RWSleep(100);
                        dwCurrentState = _dwState;
                        dwKnownState = 0;
                        Win4Assert(dwCurrentState != dwKnownState);
                        continue;
                    }
                    dwModifyState += WRITER_SIGNALED;
                }
#ifdef RWLOCK_FULL_FUNCTIONALITY
                else if((_wFlags & RWLOCKFLAG_CACHEEVENTS) &&
                        (dwKnownState == WRITER) &&
                        (_hReaderEvent || _hWriterEvent) &&
                        ((dwKnownState & CACHING_EVENTS) == 0))
                {
                    fCacheEvents = TRUE;
                    dwModifyState += CACHING_EVENTS;
                }
#endif

                // Sanity checks
                Win4Assert((dwKnownState & CACHING_EVENTS) == 0);
                Win4Assert((dwKnownState & READERS_MASK) == 0);

                dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                            (dwKnownState + dwModifyState),
                                                            dwKnownState);
            } while(dwCurrentState != dwKnownState);

            // Check for waiting readers
            if(dwKnownState & WAITING_READERS_MASK)
            {
                Win4Assert(_dwState & READER_SIGNALED);
                Win4Assert(hReaderEvent);
                RWSetEvent(hReaderEvent);
            }
            // Check for waiting writers
            else if(dwKnownState & WAITING_WRITERS_MASK)
            {
                Win4Assert(_dwState & WRITER_SIGNALED);
                Win4Assert(hWriterEvent);
                RWSetEvent(hWriterEvent);
            }
#ifdef RWLOCK_FULL_FUNCTIONALITY
            // Check for the need to release events
            else if(fCacheEvents)
            {
                ReleaseEvents();
            }
#endif
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
        Win4Assert(!"Attempt to release writer lock on a wrong thread");
#ifdef RWLOCK_FULL_FUNCTIONALITY
        if((_wFlags & RWLOCKFLAG_RETURNERRORS) == 0)
#endif
        {
            if(fBreakOnErrors)
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseReaderLock    public
//
//  Synopsis:   Removes the thread as a reader
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::ReleaseReaderLock()
{
    HRESULT hr = S_OK;

    // Check if the thread has writer lock
    if(_dwWriterID == GetCurrentThreadId())
    {
        hr = ReleaseWriterLock();
    }
    else
    {
        WORD *pwReaderLevel;

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            if(*pwReaderLevel > 1)
            {
                --(*pwReaderLevel);
            }
            else if(*pwReaderLevel == 1)
            {
                DWORD dwCurrentState, dwKnownState, dwModifyState;
                BOOL fLastReader, fCacheEvents;
                HANDLE hReaderEvent = NULL, hWriterEvent = NULL;

                // Sanity checks
                Win4Assert((_dwState & WRITER) == 0);
                Win4Assert(_dwState & READERS_MASK);

                // Not a reader any more
                *pwReaderLevel = 0;
                dwCurrentState = _dwState;
                do
                {
                    dwKnownState = dwCurrentState;
                    dwModifyState = -READER;
                    if((dwKnownState & (READERS_MASK | READER_SIGNALED)) == READER)
                    {
                        fLastReader = TRUE;
                        fCacheEvents = FALSE;
                        if(dwKnownState & WAITING_WRITERS_MASK)
                        {
                            hWriterEvent = GetWriterEvent();
                            if(hWriterEvent == NULL)
                            {
                                ComDebOut((DEB_WARN,
                                           "ReleaseReaderLock failed to create "
                                           "writer event for RWLock 0x%x\n", this));
                                RWSleep(100);
                                dwCurrentState = _dwState;
                                dwKnownState = 0;
                                Win4Assert(dwCurrentState != dwKnownState);
                                continue;
                            }
                            dwModifyState += WRITER_SIGNALED;
                        }
                        else if(dwKnownState & WAITING_READERS_MASK)
                        {
                            hReaderEvent = GetReaderEvent();
                            if(hReaderEvent == NULL)
                            {
                                ComDebOut((DEB_WARN,
                                           "ReleaseReaderLock failed to create "
                                           "reader event\n", this));
                                RWSleep(100);
                                dwCurrentState = _dwState;
                                dwKnownState = 0;
                                Win4Assert(dwCurrentState != dwKnownState);
                                continue;
                            }
                            dwModifyState += READER_SIGNALED;
                        }
#ifdef RWLOCK_FULL_FUNCTIONALITY
                        else if((_wFlags & RWLOCKFLAG_CACHEEVENTS) &&
                                (dwKnownState == READER) &&
                                (_hReaderEvent || _hWriterEvent))
                        {
                            fCacheEvents = TRUE;
                            dwModifyState += (WRITER_SIGNALED + READER_SIGNALED);
                        }
#endif
                    }
                    else
                    {
                        fLastReader = FALSE;
                    }

                    // Sanity checks
                    Win4Assert((dwKnownState & WRITER) == 0);
                    Win4Assert(dwKnownState & READERS_MASK);

                    dwCurrentState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                (dwKnownState + dwModifyState),
                                                                dwKnownState);
                } while(dwCurrentState != dwKnownState);

#if LOCK_PERF==1
                gLockTracker.ReaderLeaving(this);
#endif
                // Check for last reader
                if(fLastReader)
                {
                    // Check for waiting writers
                    if(dwKnownState & WAITING_WRITERS_MASK)
                    {
                        Win4Assert(_dwState & WRITER_SIGNALED);
                        Win4Assert(hWriterEvent);
                        RWSetEvent(hWriterEvent);
                    }
                    // Check for waiting readers
                    else if(dwKnownState & WAITING_READERS_MASK)
                    {
                        Win4Assert(_dwState & READER_SIGNALED);
                        Win4Assert(hReaderEvent);
                        RWSetEvent(hReaderEvent);
                    }
#ifdef RWLOCK_FULL_FUNCTIONALITY
                    // Check for the need to release events
                    else if(fCacheEvents)
                    {
                        ReleaseEvents();
                    }
#endif
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
        }

        if(FAILED(hr))
        {
#ifdef RWLOCK_FULL_FUNCTIONALITY
            if((_wFlags & RWLOCKFLAG_RETURNERRORS) == 0)
#endif
            {
                Win4Assert(!"Attempt to release reader lock on a wrong thread");
                if(fBreakOnErrors)
                    DebugBreak();
                TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
            }
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::UpgradeToWriterLock    public
//
//  Synopsis:   Upgrades to a writer lock. It returns a BOOL that
//              indicates intervening writes.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::UpgradeToWriterLock(LockCookie *pLockCookie,
                                     BOOL *pfInterveningWrites
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                     ,
                                     BOOL fReturnErrors,
                                     DWORD dwDesiredTimeout
#endif
#if LOCK_PERF==1
                                     ,
                                     const char *pszFile,
                                     DWORD dwLine,
                                     const char *pszLockName
#endif
                                     )
{
    HRESULT hr;
    DWORD dwThreadID;

    // Initialize the cookie
    memset(pLockCookie, 0, sizeof(LockCookie));
    if(pfInterveningWrites)
        *pfInterveningWrites = TRUE;
    dwThreadID = GetCurrentThreadId();

    // Check if the thread is already a writer
    if(_dwWriterID == dwThreadID)
    {
        // Update cookie state
        pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_WRITER;
        pLockCookie->wWriterLevel = _wWriterLevel;

        // No intevening writes
        if(pfInterveningWrites)
            *pfInterveningWrites = FALSE;

        // Acquire the writer lock again
        hr = AcquireWriterLock();
    }
    else
    {
        WORD *pwReaderLevel;

        // Ensure that the lock was initialized
        if(!IsInitialized())
            Initialize();

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            BOOL fAcquireWriterLock;
            DWORD dwWriterSeqNum = 0;

            // Check if the thread is a reader
            if(*pwReaderLevel != 0)
            {
                // Sanity check
                Win4Assert(_dwState & READERS_MASK);

                // Save lock state in the cookie
                pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_READER;
                pLockCookie->pwReaderLevel = pwReaderLevel;
                pLockCookie->wReaderLevel = *pwReaderLevel;

                // If there is only one reader, try to convert reader to a writer
                DWORD dwKnownState = InterlockedCompareExchange((LONG *) &_dwState,
                                                                WRITER,
                                                                READER);
                if(dwKnownState == READER)
                {
                    // Thread is no longer a reader
                    *pwReaderLevel = 0;

                    // Save threadid of the writer
                    _dwWriterID = dwThreadID;
                    _wWriterLevel = 1;
                    ++_dwWriterSeqNum;
                    fAcquireWriterLock = FALSE;

                    // No intevening writes
                    if(pfInterveningWrites)
                        *pfInterveningWrites = FALSE;
#if RWLOCK_STATISTICS
                    ++_dwWriterEntryCount;
#endif
#if LOCK_PERF==1
                    gLockTracker.ReaderLeaving(this);
                    gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this);
#endif
                }
                else
                {
                    // Note the current sequence number of the writer lock
                    dwWriterSeqNum = _dwWriterSeqNum;

                    // Release the reader lock
                    *pwReaderLevel = 1;
                    hr = ReleaseReaderLock();
                    Win4Assert(SUCCEEDED(hr));
                    fAcquireWriterLock = TRUE;
                }
            }
            else
            {
                fAcquireWriterLock = TRUE;
                pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_NONE;
            }

            // Check for the need to acquire the writer lock
            if(fAcquireWriterLock)
            {
                hr = AcquireWriterLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                       TRUE, dwDesiredTimeout
#if LOCK_PERF==1
                                       ,
#endif
#endif
#if LOCK_PERF==1
                                       pszFile, dwLine, pszLockName
#endif
                                      );
                if(SUCCEEDED(hr))
                {
                    // Check for intevening writes
                    if((_dwWriterSeqNum == (dwWriterSeqNum + 1)) &&
                       pfInterveningWrites)
                        *pfInterveningWrites = FALSE;
                }
                else
                {
                    if(pLockCookie->dwFlags & COOKIE_READER)
                    {
#ifdef RWLOCK_FULL_FUNCTIONALITY
                        DWORD dwTimeout = (dwDesiredTimeout > gdwReasonableTimeout)
                                          ? dwDesiredTimeout
                                          : gdwReasonableTimeout;
#endif

                        HRESULT hr1 = AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                                        FALSE, dwTimeout
#if LOCK_PERF==1
                                                        ,
#endif
#endif
#if LOCK_PERF==1
                                                        pszFile, dwLine, pszLockName
#endif
                                                       );
                        if(SUCCEEDED(hr1))
                        {
                            *pwReaderLevel = pLockCookie->wReaderLevel;
                        }
                        else
                        {
                            Win4Assert(!"Failed to reacquire reader lock");
                            if(fBreakOnErrors)
                                DebugBreak();
                            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
                        }
                    }
                }
            }
        }
    }

    // Check failure return
    if(FAILED(hr))
    {
        pLockCookie->dwFlags = INVALID_COOKIE;
#ifdef RWLOCK_FULL_FUNCTIONALITY
        if(fReturnErrors == FALSE)
        {
            Win4Assert(!"Failed to upgrade the lock");
            if(fBreakOnErrors)
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
#endif
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::DowngradeFromWriterLock   public
//
//  Synopsis:   Downgrades from a writer lock.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::DowngradeFromWriterLock(LockCookie *pLockCookie
#if LOCK_PERF==1
                                         ,
                                         const char *pszFile,
                                         DWORD dwLine,
                                         const char *pszLockName
#endif
                                        )
{
    HRESULT hr = S_OK;

    // Ensure that the cookie is valid
    if(pLockCookie->dwFlags & UPGRADE_COOKIE)
    {
        DWORD dwThreadID = GetCurrentThreadId();

        // Sanity check
        Win4Assert((pLockCookie->pwReaderLevel == NULL) ||
                   (*pLockCookie->pwReaderLevel == 0));

        // Ensure that the thread is a writer
        if(_dwWriterID == dwThreadID)
        {
            // Release the writer lock
            hr = ReleaseWriterLock();
            if(SUCCEEDED(hr))
            {
                // Check if the thread was a writer
                if(_dwWriterID == dwThreadID)
                {
                    // Ensure that the thread was a writer and that
                    // nesting level was restored to the previous
                    // value
                    if(((pLockCookie->dwFlags & COOKIE_WRITER) == 0) ||
                       (pLockCookie->wWriterLevel != _wWriterLevel))
                    {
                        Win4Assert(!"Writer lock incorrectly nested");
                        hr = E_FAIL;
                    }
                }
                // Check if the thread was a reader
                else if(pLockCookie->dwFlags & COOKIE_READER)
                {
#ifdef RWLOCK_FULL_FUNCTIONALITY
                    DWORD dwTimeout = (gdwDefaultTimeout > gdwReasonableTimeout)
                                      ? gdwDefaultTimeout
                                      : gdwReasonableTimeout;
#endif
                    hr = AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                           TRUE, dwTimeout
#if LOCK_PERF==1
                                           ,
#endif
#endif
#if LOCK_PERF==1
                                           pszFile, dwLine, pszLockName
#endif
                                          );
                    if(SUCCEEDED(hr))
                    {
                        *pLockCookie->pwReaderLevel = pLockCookie->wReaderLevel;
                    }
                    else
                    {
                        Win4Assert(!"Failed to reacquire reader lock");
                    }
                }
                else
                {
                    Win4Assert(pLockCookie->dwFlags & COOKIE_NONE);
                }
            }
        }
        else
        {
            Win4Assert(!"Attempt to downgrade writer lock on a wrong thread");
            hr = HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
        }

        // Check failure return
        if(FAILED(hr))
        {
            if(fBreakOnErrors)
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseLock    public
//
//  Synopsis:   Releases the lock held by the current thread
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::ReleaseLock(LockCookie *pLockCookie)
{
    HRESULT hr;

    // Initialize the cookie
    memset(pLockCookie, 0, sizeof(LockCookie));

    // Check if the thread is a writer
    if(_dwWriterID == GetCurrentThreadId())
    {
        // Save lock state in the cookie
        pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_WRITER;
        pLockCookie->dwWriterSeqNum = _dwWriterSeqNum;
        pLockCookie->wWriterLevel = _wWriterLevel;

        // Release the writer lock
        _wWriterLevel = 1;
        hr = ReleaseWriterLock();
        Win4Assert(SUCCEEDED(hr));
    }
    else
    {
        WORD *pwReaderLevel;

        // Ensure that the lock was initialized
        if(!IsInitialized())
            Initialize();

        hr = GetTLSLockData(&pwReaderLevel);
        if(SUCCEEDED(hr))
        {
            // Check if the thread is a reader
            if(*pwReaderLevel != 0)
            {
                // Save lock state in the cookie
                pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_READER;
                pLockCookie->pwReaderLevel = pwReaderLevel;
                pLockCookie->wReaderLevel = *pwReaderLevel;
                pLockCookie->dwWriterSeqNum = _dwWriterSeqNum;

                // Release the reader lock
                *pwReaderLevel = 1;
                hr = ReleaseReaderLock();
                Win4Assert(SUCCEEDED(hr));
            }
            else
            {
                pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_NONE;
            }
        }
        else
        {
            hr = S_OK;
            pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_NONE;
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RestoreLock    public
//
//  Synopsis:   Restore the lock held by the current thread
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CRWLock::RestoreLock(LockCookie *pLockCookie,
                             BOOL *pfInterveningWrites
#if LOCK_PERF==1
                             ,
                             const char *pszFile,
                             DWORD dwLine,
                             const char *pszLockName
#endif
                            )
{
    HRESULT hr = S_OK;

    // Initialize
    if(pfInterveningWrites)
        *pfInterveningWrites = TRUE;

    // Ensure that the cookie is valid
    if(pLockCookie->dwFlags & RELEASE_COOKIE)
    {
        DWORD dwThreadID = GetCurrentThreadId();
#ifdef RWLOCK_FULL_FUNCTIONALITY
        DWORD dwTimeout = (gdwDefaultTimeout > gdwReasonableTimeout)
                          ? gdwDefaultTimeout
                          : gdwReasonableTimeout;
#endif

        // Check if the thread holds reader or writer lock
        if(((pLockCookie->pwReaderLevel != NULL) && (*pLockCookie->pwReaderLevel > 0)) ||
           (_dwWriterID == dwThreadID))
        {
            Win4Assert(!"Thread holds reader or writer lock");
            if(fBreakOnErrors)
                DebugBreak();
            TerminateProcess(GetCurrentProcess(), RWLOCK_FATALFAILURE);
        }
        // Check if the thread was a writer
        else if(pLockCookie->dwFlags & COOKIE_WRITER)
        {
            // Acquire writer lock
            hr = AcquireWriterLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   FALSE, dwTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   pszFile, dwLine, pszLockName
#endif
                                  );
            Win4Assert(SUCCEEDED(hr));
            _wWriterLevel = pLockCookie->wWriterLevel;
            if((_dwWriterSeqNum == (pLockCookie->dwWriterSeqNum + 1)) &&
               pfInterveningWrites)
                *pfInterveningWrites = FALSE;
        }
        // Check if the thread was a reader
        else if(pLockCookie->dwFlags & COOKIE_READER)
        {
            hr = AcquireReaderLock(
#ifdef RWLOCK_FULL_FUNCTIONALITY
                                   FALSE, dwTimeout
#if LOCK_PERF==1
                                   ,
#endif
#endif
#if LOCK_PERF==1
                                   pszFile, dwLine, pszLockName
#endif
                                  );
            Win4Assert(SUCCEEDED(hr));
            *pLockCookie->pwReaderLevel = pLockCookie->wReaderLevel;
            if((_dwWriterSeqNum == (pLockCookie->dwWriterSeqNum + 1)) &&
               pfInterveningWrites)
                *pfInterveningWrites = FALSE;
        }
        else
        {
            Win4Assert(pLockCookie->dwFlags & COOKIE_NONE);
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticRWLock::Initialize     public
//
//  Synopsis:   Initializes state. It is important that the
//              default constructor only Zero out the memory
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
extern CRITICAL_SECTION g_OleMutexCreationSem;
void CStaticRWLock::Initialize()
{
    // Acquire lock creation critical section
    EnterCriticalSection (&g_OleMutexCreationSem);

    // Prevent second initialization
    if(!IsInitialized())
    {
        _dwLockNum = gdwLockSeqNum++;
#if LOCK_PERF==1
        gLockTracker.RegisterLock(this, TRUE);
#endif

        // The initialization should be complete
        // before delegating to the base class
        CRWLock::Initialize();
    }

    // Release lock creation critical section
    LeaveCriticalSection (&g_OleMutexCreationSem);

    return;
}


LockEntry * GetLockEntryFromTLS()
{
    LockEntry *pLockEntry = NULL;
#ifdef __NOOLETLS__
    pLockEntry = (LockEntry *) TlsGetValue(gLockTlsIdx);
    if (!pLockEntry)
    {
        pLockEntry = (LockEntry *) PrivMemAlloc(sizeof(LockEntry));
        if (pLockEntry)
        {
            memset(pLockEntry, 0, sizeof(LockEntry));
            TlsSetValue(gLockTlsIdx, pLockEntry);
        }

    }
#else
    HRESULT hr;
    COleTls Tls(hr);

    if(SUCCEEDED(hr))
    {
        pLockEntry = &(Tls->lockEntry);
    }
#endif
    return pLockEntry;
}


//+-------------------------------------------------------------------
//
//  Method:     CStaticRWLock::GetTLSLockData     private
//
//  Synopsis:   Obtains the data mainitained in TLS for the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CStaticRWLock::GetTLSLockData(WORD **ppwReaderLevel)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Ensure that the lock was initialized
    if(IsInitialized())
    {
        LockEntry *pLockEntry = GetLockEntryFromTLS();
        if (pLockEntry)
        {
            // Compute the quotient and remainder
            DWORD dwSkip = _dwLockNum / LOCKS_PER_ENTRY;
            DWORD dwIndex = _dwLockNum % LOCKS_PER_ENTRY;


            // Skip quotient entries
            while(dwSkip && pLockEntry)
            {
                // Allocate the lock entries if needed
                if(pLockEntry->pNext == NULL)
                {
                    LockEntry *pEntry;
                    pEntry = (LockEntry *) HeapAlloc(g_hHeap, HEAP_SERIALIZE, sizeof(LockEntry));
                    if(pEntry)
                    {
                        memset(pEntry, 0 , sizeof(LockEntry));
                        pEntry = (LockEntry *) InterlockedCompareExchangePointer((void **) &(pLockEntry->pNext),
                                                                                 pEntry,
                                                                                 NULL);
                        if(pEntry)
                            HeapFree(g_hHeap, HEAP_SERIALIZE, pEntry);
                    }
                }

                // Skip to next lock entry
                pLockEntry = pLockEntry->pNext;
                --dwSkip;
            }

            // Check for OOM
            if(pLockEntry)
            {
                *ppwReaderLevel = &(pLockEntry->wReaderLevel[dwIndex]);
                hr = S_OK;
            }
            else
            {
                *ppwReaderLevel = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        *ppwReaderLevel = NULL;
        hr = S_FALSE;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\outfuncs.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       outfuncs.cxx
//
//  Contents:   functions for log/trace output
//
//  Functions:  AddOutputFunction
//              DelOutputFunction
//              CallOutputFunctions
//
//  History:    09-Jan-96   murthys    Created
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdarg.h>
#include <tchar.h>
#if DBG==1
#include "outfuncs.h"

// *** Global Data ***
static StringOutFunc debugscrfn = (StringOutFunc)OutputDebugStringA;
StringOutFunc gpfunc[BUFFER_MAX_FUNCTIONS] = {
                                                (StringOutFunc)OutputDebugStringA,
                                                NULL
                                             };
HANDLE ghLogFile = INVALID_HANDLE_VALUE;
CRITICAL_SECTION g_LogFileCS;
BOOL g_LogFileLockValid = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   AddOutputFunction
//
//  Synopsis:
//
//  Arguments:  [pfunc] --
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void AddOutputFunction(StringOutFunc pfunc)
{
    int i, at = -1;

    for (i = 0; i < BUFFER_MAX_FUNCTIONS; i++)
    {
        if ((at == -1) && (gpfunc[i] == NULL))
        {
            at = i; // Insert it here
        }
        else
        {
            if (gpfunc[i] == pfunc) // check for dups
            {
                return;
            }
        }
    }
    if (at != -1)
    {
        gpfunc[at] = pfunc;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DelOutputFunction
//
//  Synopsis:
//
//  Arguments:  [pfunc]
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DelOutputFunction(StringOutFunc pfunc)
{
    int i;

    for (i = 0; i < BUFFER_MAX_FUNCTIONS; i++)
    {
        if (gpfunc[i] == pfunc)
        {
            gpfunc[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CallOutputFunctions
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CallOutputFunctions(const char *buffer)
{
    int i;

    for (i = 0; i < BUFFER_MAX_FUNCTIONS; i++)
    {
        if (gpfunc[i] != NULL)
        {
            gpfunc[i](buffer);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteToDebugScreen
//
//  Synopsis:
//
//  Arguments:  [flag] - TRUE/FALSE to turn ON/OFF
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void WriteToDebugScreen(BOOL flag)
{
    if (flag)
    {
        AddOutputFunction(debugscrfn);
    }
    else
    {
        DelOutputFunction(debugscrfn);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteToLogFile
//
//  Synopsis:
//
//  Arguments:  [logfile] - path of file to write to
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void WriteToLogFile(LPCTSTR lpfn)
{
    if (!g_LogFileLockValid)
        return;

    EnterCriticalSection(&g_LogFileCS);

    if (ghLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(ghLogFile);
        DelOutputFunction(OutputLogFileA);
        ghLogFile = INVALID_HANDLE_VALUE;
    }
    if ((lpfn) && (lpfn[0] != _TEXT('\0')))
    {
        SECURITY_ATTRIBUTES sattr;

        sattr.nLength = sizeof(sattr);
        sattr.lpSecurityDescriptor = NULL;
        sattr.bInheritHandle = FALSE;

#ifdef _CHICAGO_
        ghLogFile = CreateFileA(lpfn, GENERIC_READ|GENERIC_WRITE,
                               FILE_SHARE_READ|FILE_SHARE_WRITE,
                               &sattr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
#else
        ghLogFile = CreateFile(lpfn, GENERIC_READ|GENERIC_WRITE,
                               FILE_SHARE_READ|FILE_SHARE_WRITE,
                               &sattr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
#endif // _CHICAGO_
        if (ghLogFile == INVALID_HANDLE_VALUE)
        {
            OutputDebugStringA("OLE (WriteToLogFile):Unable to open log file!\n");
        }
        else
        {
            AddOutputFunction(OutputLogFileA);
        }
    }

    LeaveCriticalSection(&g_LogFileCS);
}

//+---------------------------------------------------------------------------
//
//  Function:   OutputLogFileA
//
//  Synopsis:
//
//  Arguments:  [buf] - NULL terminated ANSI string to write
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void OutputLogFileA(const char *buf)
{
    DWORD dwtowrite = strlen(buf);
    DWORD dwwritten;
    LONG loffhigh = 0, lofflow;

    if (!g_LogFileLockValid)
        return;

    EnterCriticalSection(&g_LogFileCS);
    // Goto EOF, Lock, Write and Unlock
    lofflow = (LONG) SetFilePointer(ghLogFile, 0, &loffhigh, FILE_END);
    LockFile(ghLogFile, lofflow, loffhigh, dwtowrite, 0);
    WriteFile(ghLogFile, buf, dwtowrite, &dwwritten, NULL);
    UnlockFile(ghLogFile, lofflow, loffhigh, dwtowrite, 0);
    LeaveCriticalSection(&g_LogFileCS);
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenDebugSinks()
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    26-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void OpenDebugSinks()
{
        // Get LogFile name
        char tmpstr[MAX_PATH];
        DWORD cbtmpstr = sizeof(tmpstr);
        LPTSTR lptstr;

        NTSTATUS status = RtlInitializeCriticalSection(&g_LogFileCS);
        g_LogFileLockValid = NT_SUCCESS(status);
        if (!g_LogFileLockValid)
            return;

        GetProfileStringA("CairOLE InfoLevels", // section
                          "LogFile",               // key
                          "",             // default value
                          tmpstr,              // return buffer
                          cbtmpstr);
        if (tmpstr[0] != '\0')
        {
#ifdef _CHICAGO_
            lptstr = tmpstr;

            WriteToLogFile(lptstr);
#else
            // convert ansi to unicode
            WCHAR wtmpstr[MAX_PATH];

            lptstr = wtmpstr;
            if (MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, tmpstr, -1, wtmpstr, MAX_PATH))
            {
                WriteToLogFile(lptstr);
            }
            else
            {
                OutputDebugStringA("OLE32: MultiByteToWideChar failed for logfile!\n");
            }
#endif
        }

        // See if Debug Screen should be turned off
        GetProfileStringA("CairOLE InfoLevels", // section
                          "DebugScreen",               // key
                          "Yes",             // default value
                          tmpstr,              // return buffer
                          cbtmpstr);
        if ((tmpstr[0] == 'n') || (tmpstr[0] == 'N'))
        {
            WriteToDebugScreen(FALSE);  // turn off output to debugger screen
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseDebugSinks()
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    26-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CloseDebugSinks()
{
        // close log file (if any)
        WriteToLogFile(NULL);
		
        if (g_LogFileLockValid)
        {
            DeleteCriticalSection(&g_LogFileCS);
        }
}
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF


TARGETNAME=   common
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\ih;..;..\..\com\inc;\
              ..\..\idl\public\$(DEST_TREE)\$(O);\
              ..\..\idl\internal\$(DEST_TREE)\$(O);\
              ..\..\idl\private\$(DEST_TREE)\$(O);\
              $(BASE_INC_PATH)

C_DEFINES=    \
              $(C_DEFINES) \
              /D_TRACKLINK_=1

SOURCES=      \
              ..\assert.cxx   \
              ..\ccompapi.cxx \
              ..\dprintf.c    \
              ..\eqguid.cxx   \
              ..\lockperf.cxx \
              ..\olesem.cxx   \
              ..\output.c     \
              ..\printf.c     \
              ..\sprintf.c    \
              ..\buffer.cxx   \
              ..\oleprint.cxx \
              ..\oletype.cxx  \
              ..\dynload.cxx  \
              ..\catinit.cxx  \
              ..\outfuncs.c   \
              ..\trace.cxx    \
              ..\olescm.cxx   \
              ..\stdcf.cxx    \
              ..\comsrgt.cxx  \
              ..\stackwlk.cxx \
              ..\stdidx.cxx


UMTYPE=       windows
NTTARGETFILES=all_common
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\stdcf.cxx ===
//+-------------------------------------------------------------------
//
//  File:       stdcf.cxx
//
//  Contents:   class implementing standard CF for internal OLE classes
//
//  Classes:    CStdClassFactory
//
//  History:    Rickhi      06-24-97    Created
//
//+-------------------------------------------------------------------
#include <ole2int.h>
#include <stdcf.hxx>

// CreateInstance functions for each of the internal classes.
extern HRESULT CGIPTableCF_CreateInstance        (IUnknown *pUnkOuter, REFIID riid, void **ppv);
extern HRESULT CAccessControlCF_CreateInstance   (IUnknown *pUnkOuter, REFIID riid, void **ppv);
extern HRESULT CAsyncActManagerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void **ppv);
extern HRESULT CComCatCF_CreateInstance          (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CComCatCSCF_CreateInstance        (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CItemMonikerCF_CreateInstance     (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CCompositeMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CPackagerMonikerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CAntiMonikerCF_CreateInstance     (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CPointerMonikerCF_CreateInstance  (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CErrorObjectCF_CreateInstance     (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CRpcHelperCF_CreateInstance       (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CObjectContextCF_CreateInstance   (IUnknown *pUnkOuter, REFIID riid, void** ppv);

extern HRESULT CComCatalogCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);

extern HRESULT CStdEventCF_CreateInstance              (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CManualResetEventCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CSynchronizeContainerCF_CreateInstance  (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CFreeThreadedMarshalerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);

extern HRESULT CActivationPropertiesInCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CActivationPropertiesOutCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CInprocActpropsUnmarshallerCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CComActivatorCF_CreateInstance      (IUnknown *pUnkOuter, REFIID riid, void** ppv);
extern HRESULT CAddrControlCF_CreateInstance       (IUnknown *pUnkOuter, REFIID riid, void** ppv);


//+-------------------------------------------------------------------
//  Entry in the global calss objects table. Contains a ptr to a clsid
//  and a ptr to the corresponding CreateInstance function for that
//  clsid.
//+-------------------------------------------------------------------
typedef struct tagCFEntry
{
    const CLSID        *pclsid;         // ptr to clsid
    LPFNCREATEINSTANCE  pfnCI;          // ptr to CreateInstance fn
    DWORD               dwFlags;        // misc flags. see CCF_FLAGS
} CFEntry;

typedef enum tagCCF_FLAGS
{
    CCF_NONE           = 0x0,
    CCF_AGGREGATABLE   = 0x1,           // class is aggregatable
} CCF_FLAGS;


//+-------------------------------------------------------------------
//
//  gInternalClassObjects - table of clsids and the corresponding
//  CreateInstance functions for those clsids. The CI function is
//  passed to the standard implementation of the class factory object.
//
//+-------------------------------------------------------------------
const CFEntry gInternalClassObjects[] =
{
    {&CLSID_StdEvent,                     CStdEventCF_CreateInstance,         CCF_AGGREGATABLE},
    {&CLSID_ManualResetEvent,             CManualResetEventCF_CreateInstance, CCF_AGGREGATABLE},
    {&CLSID_SynchronizeContainer,         CSynchronizeContainerCF_CreateInstance, CCF_AGGREGATABLE},
    {&CLSID_StdGlobalInterfaceTable,      CGIPTableCF_CreateInstance,         CCF_NONE},
    {&CLSID_DCOMAccessControl,            CAccessControlCF_CreateInstance,    CCF_AGGREGATABLE},
    {&CLSID_ErrorObject,                  CErrorObjectCF_CreateInstance,      CCF_NONE},
    {&CLSID_COMCatalog,                   CComCatalogCF_CreateInstance,       CCF_NONE},
    {&CLSID_ItemMoniker,                  CItemMonikerCF_CreateInstance,      CCF_NONE},
    {&CLSID_CompositeMoniker,             CCompositeMonikerCF_CreateInstance, CCF_NONE},
    {&CLSID_PackagerMoniker,              CPackagerMonikerCF_CreateInstance,  CCF_NONE},
    {&CLSID_AntiMoniker,                  CAntiMonikerCF_CreateInstance,      CCF_NONE},
    {&CLSID_PointerMoniker,               CPointerMonikerCF_CreateInstance,   CCF_NONE},
    {&CLSID_StdComponentCategoriesMgr,    CComCatCF_CreateInstance,           CCF_AGGREGATABLE},
    {&CLSID_GblComponentCategoriesMgr,    CComCatCSCF_CreateInstance,         CCF_AGGREGATABLE},
    {&CLSID_RpcHelper,                    CRpcHelperCF_CreateInstance,        CCF_NONE},
    {&CLSID_ObjectContext,                CObjectContextCF_CreateInstance,    CCF_NONE},
    {&CLSID_InProcFreeMarshaler,          CFreeThreadedMarshalerCF_CreateInstance,      CCF_AGGREGATABLE},
    {&CLSID_ActivationPropertiesIn,       CActivationPropertiesInCF_CreateInstance,     CCF_NONE},
    {&CLSID_ActivationPropertiesOut,      CActivationPropertiesOutCF_CreateInstance,    CCF_NONE},
    {&CLSID_InprocActpropsUnmarshaller,   CInprocActpropsUnmarshallerCF_CreateInstance, CCF_NONE},
    {&CLSID_ComActivator,                 CComActivatorCF_CreateInstance,     CCF_NONE},
    {&CLSID_AddrControl,                  CAddrControlCF_CreateInstance,    CCF_NONE},

    {NULL, NULL}
};


//+-------------------------------------------------------------------
//
//  Function:   ComDllGetClassObject
//
//  Synopsis:   Function to return internal class objects.
//
//  Notes:      Uses the gInternalClassObjects table and the
//              CStdClassFactory implementation.
//
//+-------------------------------------------------------------------
INTERNAL ComDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    ComDebOut((DEB_ACTIVATE, "ComDllGetClassObject rclsid:%I riid:%I ppv:%x\n",
              &rclsid, &riid, ppv));

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    int i=0;
    while (gInternalClassObjects[i].pclsid)
    {
        if (InlineIsEqualGUID(*gInternalClassObjects[i].pclsid, rclsid))
        {
            // found a matching CLSID. Create an instance of the std class factory
            // passing in the creatinstance function from the table.
            hr = E_OUTOFMEMORY;
            CStdClassFactory *pCF = new CStdClassFactory(i);
            if (pCF)
            {
                hr = pCF->QueryInterface(riid, ppv);
                pCF->Release();
            }

            break;
        }
        i++;
    }

    ComDebOut((DEB_ACTIVATE, "ComDllGetClassObject hr:%x pv:%x\n", hr, *ppv));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdClassFactory::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::Release, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdClassFactory::Release(void)
{
    ULONG cRefs = (ULONG) InterlockedDecrement((LONG *)&_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdClassFactory::CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class by calling
//              the creation function member variable.
//
//  Notes:      Does the parameter checking here to avoid having to
//              replicate it in all the creation functions.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdClassFactory::CreateInstance(IUnknown *pUnkOuter,
                                              REFIID riid,
                                              void **ppv)
{
    ComDebOut((DEB_ACTIVATE,
       "CStdClassFactory::CreateInstance _dwIndex:%x pUnkOuter:%x riid:%I ppv:%x\n",
       _dwIndex, pUnkOuter, &riid, ppv));

    // Validate the parameters.
    HRESULT hr = E_INVALIDARG;
    if (ppv != NULL)
    {
        *ppv = NULL;

        // If the caller wants to aggregate, only IID_IUnknown may be requested.
        if (pUnkOuter == NULL || IsEqualGUID(IID_IUnknown, riid))
        {
            // check if aggregation desired and supported.
            hr = CLASS_E_NOAGGREGATION;
            if ( pUnkOuter == NULL ||
                (gInternalClassObjects[_dwIndex].dwFlags & CCF_AGGREGATABLE))
            {
                // Create the object instance
                IUnknown *pUnk=NULL;
                hr = (gInternalClassObjects[_dwIndex].pfnCI)(pUnkOuter, riid, (void **)&pUnk);
                if (SUCCEEDED(hr))
                {
                    // get the requested interface
                    hr = pUnk->QueryInterface(riid, ppv);
                    pUnk->Release();
                }
            }
        }
    }

    ComDebOut((DEB_ACTIVATE, "CStdClassFactory::CreateInstance hr:%x *ppv:%x\n",
              hr, *ppv));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\stdidx.cxx ===
#include <ole2int.h>
#include <stdidx.h>

const IID IID_IRemUnknown = {0x00000131,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern "C" BOOL IsInterfaceImplementedByProxy(REFIID riid)
{
    return (
            InlineIsEqualGUID(riid, IID_IMarshal)           ||
            InlineIsEqualGUID(riid, IID_IMarshal2)          ||
            InlineIsEqualGUID(riid, IID_IMultiQI)           ||
            InlineIsEqualGUID(riid, IID_IRemUnknown)        ||
            InlineIsEqualGUID(riid, IID_IClientSecurity)    ||
            InlineIsEqualGUID(riid, IID_ICallFactory)       ||
            InlineIsEqualGUID(riid, IID_IStdIdentity)       ||
            InlineIsEqualGUID(riid, IID_IServerSecurity)    ||
            InlineIsEqualGUID(riid, IID_IRpcOptions)        ||
            InlineIsEqualGUID(riid, IID_IProxyManager)      ||
            InlineIsEqualGUID(riid, IID_IInternalUnknown)
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\stackwlk.cxx ===
#include <ole2int.h>
#include "stackwlk.hxx"

char * mystrdup(const char * sz)
{
	int nLen = lstrlenA(sz) + 1;
    char * tmp = new char[nLen];
	lstrcpyA(tmp, sz);
	return tmp;
}


StackWalker::SymGetModuleInfoFunc		StackWalker::_SymGetModuleInfo;
StackWalker::SymGetSymFromAddrFunc		StackWalker::_SymGetSymFromAddr;
StackWalker::SymLoadModuleFunc			StackWalker::_SymLoadModule;
StackWalker::StackWalkFunc				StackWalker::_StackWalk;
StackWalker::UndecorateSymbolNameFunc	StackWalker::_UndecorateSymbolName;
PFUNCTION_TABLE_ACCESS_ROUTINE				StackWalker::_SymFunctionTableAccess;

StackWalker::StackWalker(HANDLE hProcess)
	: _imageHlpDLL(NULL),
	  _hProcess(hProcess)
{
	_imageHlpDLL = LoadLibrary(L"imagehlp.dll");
	if (_imageHlpDLL != NULL) {
		// Get commonly used Sym* functions.
		if (_StackWalk == NULL) {
			// If one of them are null, assume
			// they all are.  Benign race here.

			_StackWalk = (StackWalkFunc)GetProcAddress(_imageHlpDLL, "StackWalk");
			if (_StackWalk == NULL)
				return;
			_SymGetModuleInfo = (SymGetModuleInfoFunc)GetProcAddress(_imageHlpDLL,
																	 "SymGetModuleInfo");
			if (_SymGetModuleInfo == NULL)
				return;
			_SymGetSymFromAddr = (SymGetSymFromAddrFunc)GetProcAddress(_imageHlpDLL,
																	   "SymGetSymFromAddr");
			if (_SymGetSymFromAddr == NULL)
				return;
			_SymLoadModule = (SymLoadModuleFunc)GetProcAddress(_imageHlpDLL,
															   "SymLoadModule");
			if (_SymLoadModule == NULL)
				return;
			_UndecorateSymbolName = (UndecorateSymbolNameFunc)GetProcAddress(_imageHlpDLL,
																			 "UnDecorateSymbolName");
			if (_UndecorateSymbolName == NULL)
				return;
			_SymFunctionTableAccess = (PFUNCTION_TABLE_ACCESS_ROUTINE)GetProcAddress(_imageHlpDLL,
																						 "SymFunctionTableAccess");
			if (_SymFunctionTableAccess == NULL)
				return;
		}

		// Sym* functions that we're only going to use locally.
		typedef BOOL (__stdcall *SymInitializeFunc)(HANDLE hProcess,
													LPSTR path,
													BOOL invadeProcess);
		typedef DWORD (__stdcall *SymSetOptionsFunc)(DWORD);

		SymInitializeFunc SymInitialize = (SymInitializeFunc)GetProcAddress(_imageHlpDLL,
																			"SymInitialize");
		if (SymInitialize == NULL)
			return;
		SymSetOptionsFunc SymSetOptions = (SymSetOptionsFunc)GetProcAddress(_imageHlpDLL,
																			"SymSetOptions");
		if (SymSetOptions == NULL)
			return;

		if (SymInitialize(hProcess, NULL, FALSE))
			SymSetOptions(0);
	}
}


StackWalker::~StackWalker() {
	if (_imageHlpDLL != NULL) {
		typedef BOOL (__stdcall *SymCleanupFunc)(HANDLE hProcess);

		SymCleanupFunc SymCleanup = (SymCleanupFunc)GetProcAddress(_imageHlpDLL,
																   "SymCleanup");
		if (SymCleanup != NULL)
			SymCleanup(_hProcess);

		FreeLibrary(_imageHlpDLL);
	}
}

DWORD_PTR StackWalker::LoadModule(HANDLE hProcess, DWORD_PTR address) {
    MEMORY_BASIC_INFORMATION mbi;

    if (VirtualQueryEx(hProcess, (void*)address, &mbi, sizeof mbi)) {
        if (mbi.Type & MEM_IMAGE) {
            char module[MAX_PATH];
            DWORD cch = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase,
                                           module,
                                           MAX_PATH);

            // Ignore the return code since we can't do anything with it.
            (void)_SymLoadModule(hProcess,
                                 NULL,
                                 ((cch) ? module : NULL),
                                 NULL,
                                 (DWORD_PTR) mbi.AllocationBase,
                                 0);
            return (DWORD_PTR) mbi.AllocationBase;
        }
    }

    return 0;
}

Symbol* StackWalker::ResolveAddress(DWORD_PTR addr) {
	if (_imageHlpDLL == NULL)
		return NULL;

	// Find out what module the address lies in.
	char* module = NULL;
	IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;

	if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo)) {
		module = moduleInfo.ModuleName;
	}
	else {
		// First attempt failed, load the module info.
		LoadModule(_hProcess, addr);
		if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo))
			module = moduleInfo.ModuleName;
	}

	char* symbolName = NULL;
    char undecoratedName[512];
	IMAGEHLP_SYMBOL* symbolInfo = (IMAGEHLP_SYMBOL*)_alloca(sizeof(IMAGEHLP_SYMBOL) + 512);
	symbolInfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL) + 512;
	symbolInfo->MaxNameLength = 512;
	DWORD_PTR displacement = 0;
	if (_SymGetSymFromAddr(_hProcess, addr, &displacement, symbolInfo)) {
		DWORD flags = UNDNAME_NO_MS_KEYWORDS 
			| UNDNAME_NO_ACCESS_SPECIFIERS
			| UNDNAME_NO_FUNCTION_RETURNS
			| UNDNAME_NO_MEMBER_TYPE;
		if (_UndecorateSymbolName(symbolInfo->Name, undecoratedName, 512, flags))
			symbolName = undecoratedName;
		else
			symbolName = symbolInfo->Name;
	}
	else {
		displacement = addr - moduleInfo.BaseOfImage;
	}

	return new Symbol(module, symbolName, displacement);
}



DWORD_PTR __stdcall StackWalker::GetModuleBase(HANDLE hProcess, DWORD_PTR address) {
    IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;
	
    if (_SymGetModuleInfo(hProcess, address, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
		return LoadModule(hProcess, address);

}

Symbol* StackWalker::CreateStackTrace(CONTEXT* context) {
	if (_imageHlpDLL == NULL)
		return NULL;

	HANDLE hThread = GetCurrentThread();

	DWORD dwMachineType;
	STACKFRAME frame = {0};
	frame.AddrPC.Mode = AddrModeFlat;
#if defined(_M_IX86)
	dwMachineType          = IMAGE_FILE_MACHINE_I386;
	frame.AddrPC.Offset    = context->Eip;  // Program Counter
	
	frame.AddrStack.Offset = context->Esp;  // Stack Pointer
	frame.AddrStack.Mode   = AddrModeFlat;
	frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer
#elif defined(_M_MRX000)
	dwMachineType          = IMAGE_FILE_MACHINE_R4000;
	frame.AddrPC.Offset    = context->Fir;  // Program Counter
#elif defined(_M_ALPHA)
	dwMachineType          = IMAGE_FILE_MACHINE_ALPHA;
	frame.AddrPC.Offset    = (DWORD_PTR) context->Fir;			// Program Counter
	frame.AddrStack.Offset = (DWORD_PTR) context->IntSp;		// Stack Pointer
	frame.AddrFrame.Offset = (DWORD_PTR) context->IntFp;		// Frame Pointer

#elif defined(_M_PPC)
	dwMachineType          = IMAGE_FILE_MACHINE_POWERPC;
	frame.AddrPC.Offset    = context->Iar;  // Program Counter
#elif defined(_M_IA64)     // BUGBUG: check for correctness

	dwMachineType          = IMAGE_FILE_MACHINE_IA64;
	frame.AddrPC.Offset    = context->StIIP;  // Program Counter
	
	frame.AddrStack.Offset = context->IntSp; //Stack Pointer
	frame.AddrStack.Mode   = AddrModeFlat;
    // No Frame pointer information for IA64 (per Intel folks)
	//frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer
#elif defined(_M_AXP64)    // BUGBUG: check for correctness
	dwMachineType          = IMAGE_FILE_MACHINE_AXP64;
	frame.AddrPC.Offset    = (DWORD_PTR) context->Fir;  // Program Counter
	frame.AddrStack.Offset = (DWORD_PTR) context->IntSp;		// Stack Pointer
	frame.AddrFrame.Offset = (DWORD_PTR) context->IntFp;		// Frame Pointer
#elif defined(_M_AMD64)
    dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
    frame.AddrPC.Offset    = (ULONG64) context->Rip;    // Program Counter
    frame.AddrStack.Offset = (ULONG64) context->Rsp;    // Stack Pointer
    frame.AddrFrame.Offset = (ULONG64) context->Rbp;    // Frame Pointer
#else
#error Unknown Target Machine
#endif
	
	// These variables are used to count the number of consecutive frames 
	// with the exact same PC returned by StackWalk().  On the Alpha infinite
	// loops (and infinite lists!) were being caused by StackWalk() never 
	// returning FALSE (see Raid Bug #8354 for details).
	const DWORD dwMaxNumRepetitions = 40;
	DWORD dwRepetitions	= 0;
	ADDRESS addrRepeated = {0, 0, AddrModeFlat};

	// Walk the stack...
	Symbol* prev = NULL;
	Symbol* head = NULL;

	for (;;) {
		if (!_StackWalk(dwMachineType,
						_hProcess,
						hThread,
						&frame,
						&context,
						NULL,
						_SymFunctionTableAccess,
						GetModuleBase,
						NULL))
			break;
		if (frame.AddrPC.Offset == 0)
			break;

		// Check for repeated addresses;  if dwMaxNumRepetitions are found,
		// then we break out of the loop and exit the stack walk
		if (addrRepeated.Offset == frame.AddrPC.Offset &&
			addrRepeated.Mode == frame.AddrPC.Mode) {
			dwRepetitions ++;
			if (dwRepetitions == dwMaxNumRepetitions) {
				break;
			}
		} else {
			dwRepetitions = 0;
			addrRepeated.Offset = frame.AddrPC.Offset;
			addrRepeated.Mode = frame.AddrPC.Mode;
		}

		// There have been reports of StackWalk returning an offset of
		// -1, which SymLoadModule later av's on.   If this happens,
		// we simply skip that frame.
		if (frame.AddrPC.Offset == -1)
			continue;
		
		Symbol* sym = ResolveAddress(frame.AddrPC.Offset);
		if (sym == NULL)
			break;

		// Append this symbol to the previous one, if any.
		if (prev == NULL) {
			prev = sym;
			head = sym;
		}
		else {
			prev->Append(sym);
			prev = sym;
		}
	}

	return head;
}

SIZE_T StackWalker::GetCallStackSize(Symbol* symbol)
{
	SIZE_T nSize = 2; // Start with a "\r\n".
	const char* module = NULL;
	const char* symbolName = NULL;	
	Symbol * sym = symbol;
	while (sym != NULL)
	{
		module = sym->moduleName();
		symbolName = sym->symbolName();	
		nSize += lstrlenA(module);
		nSize += lstrlenA(symbolName);
		nSize += 32; // displacement, spaces, etc.
		sym = sym -> next();
	}

	return nSize;
}
BOOL StackWalker::GetCallStack(Symbol * symbol, SIZE_T nChars, WCHAR * sz, SIZE_T nMaxLines)
{
	if (!symbol || !nChars)
		return FALSE;

	Symbol* sym = symbol;
	
	//	for (int i=0;i<3;i++)
	//	{
	//		Symbol* tmp = sym;
	//		sym = sym->next();
	//		delete tmp;
	//		if (!sym)
	//			break;
	//	}

	const char* module = NULL;
	const char* symbolName = NULL;	
	char * szStack = (char * )PrivMemAlloc(nChars);
	ZeroMemory(szStack, nChars);
	lstrcpyA(szStack, "\r\n"); // Start with a CR-LF.
	Symbol* tmp  = NULL;
	while (sym != NULL && nMaxLines-- > 0) 
	{	
		module = sym->moduleName();
		symbolName = sym->symbolName();			
		if (module != NULL) 
		{
			lstrcatA(szStack, module);
			if (symbolName != NULL)
				lstrcatA(szStack, "!");
		}

		if (symbolName != NULL)
			lstrcatA(szStack, symbolName);

		sym -> AppendDisplacement(szStack);

		lstrcatA(szStack, "\r\n");
		tmp = sym;
		sym = sym->next();
		delete tmp;
	}

	SIZE_T nLen = lstrlenA(szStack);
	nLen++;		
	MultiByteToWideChar(CP_ACP, 0, szStack, (int) nLen, sz, (int) nLen);
	PrivMemFree(szStack);
	return TRUE;
	
}



Symbol::Symbol(const char* moduleName, const char* symbolName, DWORD_PTR displacement)
	: _moduleName(NULL),
	  _symbolName(NULL),
	  _displacement(displacement),
	  _next(NULL)
{
	if (moduleName != NULL)
		_moduleName = mystrdup(moduleName);
	if (symbolName != NULL)
		_symbolName = mystrdup(symbolName);
}

Symbol::~Symbol() {
	delete [] _moduleName;
    delete [] _symbolName;
}

void Symbol::Append(Symbol* sym) {
	_next = sym;
}


#if 0
#include <iostream.h>
DWORD filter(EXCEPTION_POINTERS* exp) {
	StackWalker resolver(GetCurrentProcess());
	Symbol* symbol = resolver.CreateStackTrace(exp->ContextRecord);
	if (symbol == NULL) {
		cout << "Couldn't get stack trace" << endl;
	}
	else {
		cout << "Stack trace:" << endl;

		Symbol* sym = symbol;
		while (sym != NULL) {
			const char* module = sym->moduleName();
			const char* symbolName = sym->symbolName();

			if (module != NULL) {
				cout << module;
				if (symbolName != NULL)
					cout << '!';
			}
			if (symbolName != NULL)
				cout << symbolName;
			cout << "+0x" << hex << sym->displacement() << dec << endl;

			Symbol* tmp = sym;
			sym = sym->next();

			delete tmp;
		}
	}

	return EXCEPTION_EXECUTE_HANDLER;
}


int bar(int x, int* p) {
	*p = x;
	return 5;
}

void foo(int* p) {
	bar(5, p);
}

int main() {
	__try {
		int* p = (int*)0xdeadbeef;
		foo(p);
	}
	__except (filter(GetExceptionInformation())) {

	}

	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\chicago\i386\rpccall.asm ===
title  "Dynamic Linkages to RPCRT4.DLL"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    rpccall.asm
;
; Abstract:
;
;    This module implements functions that dynamically link to
;    RPCRT4.DLL.
;
; Author:
;
;    Murthy Srinivas  7-Nov-1995
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
; Notes:
;
;       This module is dependent on the internal structure of the
;       COleStaticMutexSem object (g_Rpcrt4Sem).  It invokes the
;       COleCommonMutexSem::Request method, as well as invokes
;       COleStaticMutexSem::ReleaseFn.  Any changes to this object
;       may impact this code -- BEWARE!
;
;--
.386p
        .xlist
include callconv.inc
        .list

        extrn   _GetLastError@0:proc
        extrn   _GetProcAddress@8:proc
        extrn   _LoadLibraryA@4:proc
        extrn   _FreeLibrary@4:proc
        extrn   ?Request@COleStaticMutexSem@@QAEXXZ:proc      ; COleStaticMutexSem::Request
        extrn   ?g_Rpcrt4Sem@@3VCOleStaticMutexSem@@A:DWORD   ; COleStaticMutexSem g_Rpcrt4Sem
        extrn   ?ReleaseFn@COleStaticMutexSem@@QAEXXZ:proc    ; COleStaticMutexSem::ReleaseFn


_BSS    SEGMENT DWORD PUBLIC 'BSS'
_BSS    ENDS

CONST   SEGMENT DWORD PUBLIC 'CONST'
CONST   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'
        ASSUME  DS:FLAT, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_DATA   ENDS

EPBlock STRUC
EPAddr  DD      ?
Nameptr DD      ?
ErrRtn  DD      ?
EPBlock ENDS

;
;       Macro to define an RPC entry point that is to be dynamically
;       linked-to
;

RPC_ENTRY macro EntryPoint,N

_DATA   SEGMENT
EntryPoint&Block EPBlock {LoadAndGo,EntryPoint&Name,EntryPoint&Err}
_DATA    ENDS

CONST   SEGMENT
EntryPoint&Name DB '&EntryPoint',0
CONST   ENDS

_TEXT   SEGMENT

        align   dword                           ;;
ifb     <N>
        PUBLICP <_&EntryPoint>
        stdProc <_&EntryPoint>,0,<>             ;;
else
        PUBLICP <_&EntryPoint>,N
        stdProc <_&EntryPoint>,N,<>             ;;
endif
        lea     eax,EntryPoint&Block            ;;  ptr to block for EP
        jmp     DWORD PTR [eax].EPBlock.EPAddr  ;;  first time will jump to
                                                ;;  LoadAndGo.  Subsequently
                                                ;;  will jump to EP in RPCRT4
EntryPoint&Err:                                 ;;
        stdRET  <_&EntryPoint>                  ;;
        stdENDP <_&EntryPoint>                  ;;

_TEXT   ENDS

endm

RPC_VAR_ENTRY macro EntryPoint

_DATA   SEGMENT
EntryPoint&Block EPBlock {LoadAndGo,EntryPoint&Name,EntryPoint&Err}
_DATA   ENDS

CONST   SEGMENT
EntryPoint&Name DB '&EntryPoint',0
CONST   ENDS

_TEXT   SEGMENT

        align   dword                           ;;
        public  _&EntryPoint                    ;;
_&EntryPoint    proc                            ;;
        lea     eax,EntryPoint&Block            ;;  ptr to block for EP
        jmp     DWORD PTR [eax].EPBlock.EPAddr  ;;  first time will jump to
                                                ;;  LoadAndGo.  Subsequently
                                                ;;  will jump to EP in RPCRT4
EntryPoint&Err:                                 ;;
        ret                                     ;;
_&EntryPoint    endp                            ;;

_TEXT   ENDS

endm



        page
        subttl  "Load RPCRT4 Entry Point And Jump"
;++
;
; VOID
; LoadAndGo ()
;
; Routine Description:
;
;    This function dynamically loads and saves the entry point address
;    from RPCRT4.DLL and then jumps to the routine.
;
; Arguments:
;
;    AX - ptr to EPBlock structure
;
; Return Value:
;
;    Whatever the designated routine returns.
;
;--

_BSS    SEGMENT
hLibrary DD 1
_BSS    ENDS

_DATA   SEGMENT
LoadOrGet DD LoadLib
_DATA   ENDS


CONST   SEGMENT
RPCRT4  DB      'RPCRT4.DLL',0
CONST   ENDS

_TEXT   SEGMENT

LoadAndGo:
        push    ebx                     ; save ebx, ecx, edx
        push    ecx                     ;
        push    edx                     ;
        push    eax                     ; save EPBlock address
        mov     ecx, OFFSET FLAT:?g_Rpcrt4Sem@@3VCOleStaticMutexSem@@A ; g_Rpcrt4Sem
        call    ?Request@COleStaticMutexSem@@QAEXXZ ; COleStaticMutexSem::Request
        jmp     DWORD PTR LoadOrGet     ; LoadLib or GetProc

LoadLib:
        lea     eax,RPCRT4              ; load rpcrt4.dll
        push    eax
        call    _LoadLibraryA@4
        or      eax,eax                 ; successful?
        jnz     LoadLibOK               ;
        mov     ecx, OFFSET FLAT:?g_Rpcrt4Sem@@3VCOleStaticMutexSem@@A ; g_Rpcrt4Sem
        call    ?ReleaseFn@COleStaticMutexSem@@QAEXXZ ; COleStaticMutexSem::ReleaseFn
        jmp     GotError                ;
LoadLibOK:
        mov     hLibrary,eax            ; save its module handle
        lea     eax,GetProc             ; next time we won't LoadLib
        mov     LoadOrGet,eax           ;

GetProc:
        mov     ecx, OFFSET FLAT:?g_Rpcrt4Sem@@3VCOleStaticMutexSem@@A ; g_Rpcrt4Sem
        call    ?ReleaseFn@COleStaticMutexSem@@QAEXXZ ; COleStaticMutexSem::ReleaseFn
        pop     eax                     ; restore EPBlock address
        push    eax                     ; save EPBlock address
        push    [eax].EPBlock.NamePtr   ; routine name
        push    hLibrary                ;
        call    _GetProcAddress@8       ; load routine address
        or      eax,eax                 ; successful?
        jz      GotError                ;
        pop     ebx                     ; restore EPBlock Address
        mov     [ebx].EPBlock.EPAddr,eax  ; save routine address in designated location
        pop     edx                     ; restore EDX, ECX, EBX
        pop     ecx                     ;
        pop     ebx                     ;
        jmp     eax                     ; and jump to the routine in rpcrt4.dll

GotError:
        call    _GetLastError@0         ; for debugging only
        pop     eax                     ; restore EPBlock address
        pop     edx                     ;
        pop     ecx                     ;
        pop     ebx                     ;
        push    [eax].EPBlock.ErrRtn    ; set up error return
        mov     eax,8                   ; error return ERROR_NOT_ENOUGH_MEMORY
        ret                             ;
_TEXT   ENDS

_TEXT   SEGMENT

        align   dword

        PUBLICP _FreeRPCRT4             ;
        stdProc _FreeRPCRT4,0,<>        ;
        mov     ecx, OFFSET FLAT:?g_Rpcrt4Sem@@3VCOleStaticMutexSem@@A ; g_Rpcrt4Sem
        call    ?Request@COleStaticMutexSem@@QAEXXZ ; COleStaticMutexSem::Request
        push    hLibrary                ; FreeLibrary
        call    _FreeLibrary@4          ;
        lea     eax,GotError            ; Always return error
        mov     LoadOrGet,eax           ;
        mov     ecx, OFFSET FLAT:?g_Rpcrt4Sem@@3VCOleStaticMutexSem@@A ; g_Rpcrt4Sem
        call    ?ReleaseFn@COleStaticMutexSem@@QAEXXZ ; COleStaticMutexSem::ReleaseFn
        stdRET  _FreeRPCRT4             ;
        stdENDP _FreeRPCRT4             ;

_TEXT   ENDS


;
;       Intercepted Entry points
;

RPC_ENTRY CStdStubBuffer_AddRef,1
RPC_ENTRY CStdStubBuffer_Connect,2
RPC_ENTRY CStdStubBuffer_CountRefs,1
RPC_ENTRY CStdStubBuffer_DebugServerQueryInterface,2
RPC_ENTRY CStdStubBuffer_DebugServerRelease,2
RPC_ENTRY CStdStubBuffer_Disconnect,1
RPC_ENTRY CStdStubBuffer_Invoke,3
RPC_ENTRY CStdStubBuffer_IsIIDSupported,2
RPC_ENTRY CStdStubBuffer_QueryInterface,3
RPC_ENTRY IUnknown_AddRef_Proxy,1
RPC_ENTRY IUnknown_QueryInterface_Proxy,3
RPC_ENTRY IUnknown_Release_Proxy,1
RPC_ENTRY I_RpcAllocate,1
RPC_ENTRY I_RpcBindingInqTransportType,2
RPC_ENTRY I_RpcBindingSetAsync,3
RPC_ENTRY I_RpcFree,1
RPC_ENTRY I_RpcFreeBuffer,1
RPC_ENTRY I_RpcGetBuffer,1
RPC_ENTRY I_RpcGetThreadWindowHandle,1
RPC_ENTRY I_RpcSendReceive,1
RPC_ENTRY I_RpcServerRegisterForwardFunction,1
RPC_ENTRY I_RpcServerStartListening,1
RPC_ENTRY I_RpcServerStopListening,0
RPC_ENTRY I_RpcServerUnregisterEndpointW,2
RPC_ENTRY I_RpcSetThreadParams,3
RPC_ENTRY I_RpcSsDontSerializeContext
RPC_ENTRY I_RpcWindowProc,4
RPC_ENTRY NdrAllocate,2
RPC_ENTRY NDRCContextBinding,1
RPC_ENTRY NDRSContextUnmarshall,2
RPC_ENTRY NdrClearOutParameters,3
RPC_ENTRY NdrCStdStubBuffer_Release,2
RPC_VAR_ENTRY NdrClientCall2
RPC_ENTRY NdrClientContextMarshall,3
RPC_ENTRY NdrClientContextUnmarshall,3
RPC_ENTRY NdrClientInitializeNew,4
RPC_ENTRY NdrComplexArrayBufferSize,3
RPC_ENTRY NdrComplexArrayFree,3
RPC_ENTRY NdrComplexArrayMarshall,3
RPC_ENTRY NdrComplexArrayUnmarshall,4
RPC_ENTRY NdrConformantStringBufferSize,3
RPC_ENTRY NdrConformantStringMarshall,3
RPC_ENTRY NdrConformantStringUnmarshall,4
RPC_ENTRY NdrConformantStructBufferSize,3
RPC_ENTRY NdrConformantStructMarshall,3
RPC_ENTRY NdrConformantStructUnmarshall,4
RPC_ENTRY NdrConformantVaryingArrayBufferSize,3
RPC_ENTRY NdrConformantVaryingArrayMarshall,3
RPC_ENTRY NdrConvert,2
RPC_ENTRY NdrConvert2,3
RPC_ENTRY NdrCStdStubBuffer2_Release,2
RPC_ENTRY NdrDllCanUnloadNow,1
RPC_ENTRY NdrDllGetClassObject,6
RPC_ENTRY NdrDllRegisterProxy,3
RPC_ENTRY NdrDllUnregisterProxy,3
RPC_ENTRY NdrFreeBuffer,1
RPC_ENTRY NdrFullPointerXlatFree,1
RPC_ENTRY NdrFullPointerXlatInit,2
RPC_ENTRY NdrGetBuffer,3
RPC_ENTRY NdrMapCommAndFaultStatus,4
RPC_ENTRY NdrOleAllocate,1
RPC_ENTRY NdrOleFree,1
RPC_ENTRY NdrPointerBufferSize,3
RPC_ENTRY NdrPointerFree,3
RPC_ENTRY NdrPointerMarshall,3
RPC_ENTRY NdrPointerUnmarshall,4
RPC_ENTRY NdrProxyErrorHandler,1
RPC_ENTRY NdrProxyFreeBuffer,2
RPC_ENTRY NdrProxyGetBuffer,2
RPC_ENTRY NdrProxyInitialize,5
RPC_ENTRY NdrProxySendReceive,2
RPC_ENTRY NdrSendReceive,2
RPC_ENTRY NdrServerCall2,1
RPC_ENTRY NdrServerContextMarshall,3
RPC_ENTRY NdrServerContextUnmarshall,1
RPC_ENTRY NdrServerInitializeNew,3
RPC_ENTRY NdrSimpleStructBufferSize,3
RPC_ENTRY NdrSimpleStructMarshall,3
RPC_ENTRY NdrSimpleStructUnmarshall,4
RPC_ENTRY NdrStubCall2,4
RPC_ENTRY NdrStubGetBuffer,3
RPC_ENTRY NdrStubInitialize,4
RPC_ENTRY RpcBindingCopy,2
RPC_ENTRY RpcBindingFree,1
RPC_ENTRY RpcBindingFromStringBindingA,2
RPC_ENTRY RpcBindingFromStringBindingW,2
RPC_ENTRY RpcBindingInqAuthClientA,6
RPC_ENTRY RpcBindingInqAuthClientW,6
RPC_ENTRY RpcBindingInqAuthInfoExW,8
RPC_ENTRY RpcBindingInqAuthInfoW,6
RPC_ENTRY RpcBindingInqObject,2
RPC_ENTRY RpcBindingReset,1
RPC_ENTRY RpcBindingSetAuthInfoA,6
RPC_ENTRY RpcBindingSetAuthInfoExW,7
RPC_ENTRY RpcBindingSetAuthInfoW,6
RPC_ENTRY RpcBindingSetObject,2
RPC_ENTRY RpcBindingToStringBindingW,2
RPC_ENTRY RpcBindingVectorFree,1
RPC_ENTRY RpcImpersonateClient,1
RPC_ENTRY RpcMgmtInqComTimeout,2
RPC_ENTRY RpcMgmtIsServerListening,1
RPC_ENTRY RpcMgmtStopServerListening,1
RPC_ENTRY RpcMgmtWaitServerListen
RPC_ENTRY RpcNetworkIsProtseqValidW,1
RPC_ENTRY RpcRaiseException,1
RPC_ENTRY RpcRevertToSelf
RPC_ENTRY RpcServerInqBindings,1
RPC_ENTRY RpcServerInqDefaultPrincNameA,2
RPC_ENTRY RpcServerInqDefaultPrincNameW,2
RPC_ENTRY RpcServerListen,3
RPC_ENTRY RpcServerRegisterAuthInfoW,4
RPC_ENTRY RpcServerRegisterAuthInfoA,4
RPC_ENTRY RpcServerRegisterIf,3
RPC_ENTRY RpcServerRegisterIfEx,6
RPC_ENTRY RpcServerUnregisterIf,3
RPC_ENTRY RpcServerUseProtseqEpW,4
RPC_ENTRY RpcServerUseProtseqW,3
RPC_ENTRY RpcSmDestroyClientContext,1
RPC_ENTRY RpcStringBindingComposeW,6
RPC_ENTRY RpcStringBindingParseW,6
RPC_ENTRY RpcStringFreeW,1
RPC_ENTRY RpcStringFreeA,1
RPC_ENTRY TowerExplode,6
RPC_ENTRY UuidCreate,1
RPC_ENTRY MesHandleFree,1
RPC_ENTRY MesEncodeFixedBufferHandleCreate,4
RPC_ENTRY MesBufferHandleReset,6
RPC_ENTRY MesDecodeBufferHandleCreate,3
RPC_ENTRY NdrMesTypeAlignSize,4
RPC_ENTRY NdrMesTypeEncode,4
RPC_ENTRY NdrMesTypeDecode,4


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\crt0dat.c ===
/***
*crt0dat.c - 32-bit C run-time initialization/termination routines
*
*	Copyright (c) 1986-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module contains the routines _cinit, exit, and _exit
*	for C run-time startup and termination.  _cinit and exit
*	are called from the _astart code in crt0.asm.
*	This module also defines several data variables used by the
*	runtime.
*
*	[NOTE: Lock segment definitions are at end of module.]
*
*	*** FLOATING POINT INITIALIZATION AND TERMINATION ARE NOT ***
*	*** YET IMPLEMENTED IN THIS FILE			  ***
*
*Revision History:
*	06-28-89  PHG	Module created, based on asm version
*	04-09-90  GJF	Added #include <cruntime.h>. Made calling type
*			explicit (_CALLTYPE1 or _CALLTYPE4). Also, fixed
*			the copyright.
*	04-10-90  GJF	Fixed compiler warnings (-W3).
*	05-21-90  GJF	Added #undef _NFILE_ (temporary hack) and fixed the
*			indents.
*	08-31-90  GJF	Removed 32 from API names.
*	09-25-90  GJF	Merged tree version with local (8-31 and 5-21 changes).
*	10-08-90  GJF	New-style function declarators.
*	10-12-90  GJF	Removed divide by 0 stuff.
*	10-18-90  GJF	Added _pipech[] array.
*	11-05-90  GJF	Added _umaskval.
*	12-04-90  GJF	Added _osfinfo[] definition for Win32 target. Note that
*			the Win32 support is still incomplete!
*	12-04-90  SRW	Changed to include <oscalls.h> instead of <doscalls.h>
*	12-04-90  SRW	Added _osfile back for win32.  Changed _osfinfo from
*			an array of structures to an array of 32-bit handles
*			(_osfhnd)
*	12-28-90  SRW	Added _CRUISER_ conditional around pack pragmas
*	01-29-91  GJF	ANSI naming.
*       01-29-91  SRW   Added call to GetFileType [_WIN32_]
*	02-18-91  SRW	Removed duplicate defintion of _NFILE_ (see os2dll.h)
*	04-04-91  GJF	Added definitions for _base[version|major|minor]
*			(_WIN32_).
*	04-08-91  GJF	Temporary hack for Win32/DOS folks - added HeapDestroy
*			call to doexit to tear down the OS heap used by C
*			heap.
*	04-09-91  PNT   Added _MAC_ conditional
*	04-26-91  SRW	Removed level 3 warnings
*	07-16-91  GJF	Added fp initialization test-and-call [_WIN32_].
*	07-26-91  GJF	Revised initialization and termination stuff. In
*			particular, removed need for win32ini.c [_WIN32_].
*	08-07-91  GJF	Added init. for FORTRAN runtime, if present [_WIN32_].
*	08-21-91  GJF	Test _prmtmp against NULL, not _prmtmp().
*	08-21-91  JCR	Added _exitflag, _endstdio, _cpumode, etc.
*	09-09-91  GJF	Revised _doinitterm for C++ init. support and to make
*			_onexit/atexit compatible with C++ needs.
*	09-16-91  GJF	Must test __onexitend before calling _doinitterm.
*	10-29-91  GJF	Force in floating point initialization for MIPS
*			compiler [_WIN32_].
*	11-13-91  GJF	FORTRAN needs _onexit/atexit init. before call thru
*			_pFFinit.
*	01-10-92  GJF	Merged. Also, added _C_Termination_Done [_WIN32_].
*	02-13-92  GJF	Moved all lowio initialization to ioinit.c for Win32.
*	03-12-92  SKS	Major changes to initialization/termination scheme
*	04-16-92  DJM   POSIX support.
*	04-17-92  SKS	Export _initterm() for CRTDLL model
*	05-07-92  DJM	Removed _exit() from POSIX build.
*	06-03-92  GJF	Temporarily restored call to FORTRAN init.
*	08-26-92  SKS	Add _osver, _winver, _winmajor, _winminor
*	08-28-92  GJF	Use unistd.h for POSIX build.
*	09-02-92  SKS	Fix _onexit table traversal to be LIFO.
*			Since table is built forward (my changes 03-12-92)
*			the table must be traversed in reverse order.
*	10-30-92  TVB	Force in floating point initialization for ALPHA
*			compiler as was done for MIPS. [_WIN32_].
*	11-12-92  SKS	Remove hard-coded call to FORTRAN initializer
*	05-11-93  SKS	_C_Termination_Done is now used by DLLs in LIBC/LIBCMT
*			models, not just in CRTDLL.DLL.
*			Remove obsolete variable _child.
*       07-16-93  SRW   ALPHA Merge
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <os2dll.h>


/* callable exit flag */
char _exitflag = 0;

/*
 * flag indicating if C runtime termination has been done. set if exit,
 * _exit, _cexit or _c_exit has been called. checked when _CRTDLL_INIT
 * or user DLL's _CRT_INIT is called with DLL_PROCESS_DETACH.
 */
int _C_Termination_Done = FALSE;

/*
 * useful type for initialization and termination declarations
 */
typedef void (_CALLTYPE1 *PF)(void);


/*
 * NOTE: THE USE OF THE POINTERS DECLARED BELOW DEPENDS ON THE PROPERTIES
 * OF C COMMUNAL VARIABLES. SPECIFICALLY, THEY ARE NON-NULL IFF THERE EXISTS
 * A DEFINITION ELSEWHERE INITIALIZING THEM TO NON-NULL VALUES.
 */

/*
 * pointers to initialization functions
 */

PF _FPinit;			/* floating point init. */

/*
 * pointers to initialization sections
 */

extern PF __xi_a[], __xi_z[];	/* C initializers */
extern PF __xc_a[], __xc_z[];	/* C++ initializers */
extern PF __xp_a[], __xp_z[];	/* C pre-terminators */
extern PF __xt_a[], __xt_z[];	/* C terminators */

#if	defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
/*
 * For MIPS or ALPHA compilers, must explicitly force in and call the floating
 * point initialization (those system always have floating-point hardware).
 */
extern void _CALLTYPE1 _fpmath(void);
#endif

/*
 * pointers to the start and finish of the _onexit/atexit table
 */
PF *__onexitbegin;
PF *__onexitend;


/*
 * static (internal) function that walks a table of function pointers,
 * calling each entry between the two pointers, skipping NULL entries
 *
 * Needs to be exported for CRT DLL so that C++ initializers in the
 * client EXE / DLLs can be initialized
 */

void _CALLTYPE4 _initterm(PF *, PF *);


#pragma data_seg()

/***
*_cinit - C initialization
*
*Purpose:
*	This routine performs the shared DOS and Windows initialization.
*	The following order of initialization must be preserved -
*
ifdef	MTHREAD
*	0.	Call OS2 to bump max file count (mthread only)
endif
*	1.	Check for devices for file handles 0 - 2
*	2.	Integer divide interrupt vector setup
*	3.	General C initializer routines
*
*Entry:
*	No parameters: Called from __crtstart and assumes data
*	set up correctly there.
*
*Exit:
*	Initializes C runtime data.
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE1 _cinit (
	void
	)
{

	/*
	 * initialize floating point package, if present
	 */
#if	defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
	/*
	 * The Mips, Alpha, and PPC compilers don't emit external reference to
         * _fltused. Therefore, must always force in the floating point
         * initialization.
	 */
	_fpmath();
#else
	if ( _FPinit != NULL )
		(*_FPinit)();
#endif

	/*
	 * do initializations
	 */
	_initterm( __xi_a, __xi_z );

	/*
	 * do C++ initializations
	 */
	_initterm( __xc_a, __xc_z );


}


/***
*exit(status), _exit(status), _cexit(void), _c_exit(void) - C termination
*
*Purpose:
*
*	Entry points:
*
*		exit(code):  Performs all the C termination functions
*			and terminates the process with the return code
*			supplied by the user.
*
*		_exit(code):  Performs a quick exit routine that does not
*			do certain 'high-level' exit processing.  The _exit
*			routine terminates the process with the return code
*			supplied by the user.
*
*		_cexit():  Performs the same C lib termination processing
*			as exit(code) but returns control to the caller
*			when done (i.e., does NOT terminate the process).
*
*		_c_exit():  Performs the same C lib termination processing
*			as _exit(code) but returns control to the caller
*			when done (i.e., does NOT terminate the process).
*
*	Termination actions:
*
*		exit(), _cexit():
*
*		1.	call user's terminator routines
*		2.	call C runtime preterminators
*
*		_exit(), _c_exit():
*
*		3.	call C runtime terminators
*		4.	return to DOS or caller
*
*	Notes:
*
*	The termination sequence is complicated due to the multiple entry
*	points sharing the common code body while having different entry/exit
*	sequences.
*
*	Multi-thread notes:
*
*	1. exit() should NEVER be called when mthread locks are held.
*	   The exit() routine can make calls that try to get mthread locks.
*
*	2. _exit()/_c_exit() can be called from anywhere, with or without locks held.
*	   Thus, _exit() can NEVER try to get locks (otherwise, deadlock
*	   may occur).	_exit() should always 'work' (i.e., the process
*	   should always terminate successfully).
*
*	3. Only one thread is allowed into the exit code (see _lockexit()
*	   and _unlockexit() routines).
*
*Entry:
*	exit(), _exit()
*		int status - exit status (0-255)
*
*	_cexit(), _c_exit()
*		<no input>
*
*Exit:
*	exit(), _exit()
*		<EXIT to DOS>
*
*	_cexit(), _c_exit()
*		Return to caller
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

/* worker routine prototype */
static void _CALLTYPE4 doexit (int code, int quick, int retcaller);

void _CALLTYPE1 exit (
	int code
	)
{
	doexit(code, 0, 0);	/* full term, kill process */
}

#ifndef _POSIX_

void _CALLTYPE1 _exit (
	int code
	)
{
	doexit(code, 1, 0);	/* quick term, kill process */
}

void _CALLTYPE1 _cexit (
	void
	)
{
	doexit(0, 0, 1);	/* full term, return to caller */
}

void _CALLTYPE1 _c_exit (
	void
	)
{
	doexit(0, 1, 1);	/* quick term, return to caller */
}

#endif  /* _POSIX_ */


static void _CALLTYPE4 doexit (
	int code,
	int quick,
	int retcaller
	)
{
	_lockexit();		/* assure only 1 thread in exit path */


	/* save callable exit flag (for use by terminators) */
	_exitflag = (char) retcaller;  /* 0 = term, !0 = callable exit */

	if (!quick) {

		/*
		 * do _onexit/atexit() terminators
		 * (if there are any)
		 *
		 * These terminators MUST be executed in reverse order (LIFO)!
		 *
		 * NOTE:
		 *	This code assumes that __onexitbegin points
		 *	to the first valid onexit() entry and that
		 *	__onexitend points past the last valid entry.
		 *	If __onexitbegin == __onexitend, the table
		 *	is empty and there are no routines to call.
		 */

		if (__onexitbegin) {
			PF * pfend = __onexitend;
		
			while ( -- pfend >= __onexitbegin )
			/*
			 * if current table entry is non-NULL,
			 * call thru it.
			 */
			if ( *pfend != NULL )
				(**pfend)();
		}

		/*
		 * do pre-terminators
		 */
		_initterm(__xp_a, __xp_z);
	}

	/*
	 * do terminators
	 */
	_initterm(__xt_a, __xt_z);


/********** FLOATING POINT TERMINATION SHOULD GO HERE ************/

	/* return to OS/2 or to caller */
	if (retcaller) {
		_unlockexit();	    /* unlock the exit code path */
		return;
	}

        ExitProcess(code);

}

/***
* _lockexit - Aquire the exit code lock
*
*Purpose:
*	Makes sure only one thread is in the exit code at a time.
*	If a thread is already in the exit code, it must be allowed
*	to continue.  All other threads must pend.
*
*	Notes:
*
*	(1) It is legal for a thread that already has the lock to
*	try and get it again(!).  That is, consider the following
*	sequence:
*
*		(a) program calls exit()
*		(b) thread locks exit code
*		(c) user onexit() routine calls _exit()
*		(d) same thread tries to lock exit code
*
*	Since _exit() must ALWAYS be able to work (i.e., can be called
*	from anywhere with no regard for locking), we must make sure the
*	program does not deadlock at step (d) above.
*
*	(2) If a thread executing exit() or _exit() aquires the exit lock,
*	other threads trying to get the lock will pend forever.  That is,
*	since exit() and _exit() terminate the process, there is not need
*	for them to unlock the exit code path.
*
*	(3) Note that onexit()/atexit() routines call _lockexit/_unlockexit
*	to protect mthread access to the onexit table.
*
*	(4) The _lockexit/_unlockexit routines are very complicated in 286
*	OS/2 since a thread that held a lock could not request the lock again.
*	The 32-bit OS/2 semaphore calls DO allow a single thread to aquire the
*	same lock multiple times* thus, this version is straight forward.
*
*Entry: <none>
*
*Exit:
*	Calling thread has exit code path locked on return.
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE1 _lockexit (
	void
	)
{
	_mlock(_EXIT_LOCK1);
}

/***
* _unlockexit - Release exit code lock
*
*Purpose:
*	[See _lockexit() description above.]
*
*	This routine is called by _cexit(), _c_exit(), and onexit()/atexit().
*	The exit() and _exit() routines never unlock the exit code path since
*	they are terminating the process.
*
*Entry:
*	Exit code path is unlocked.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE1 _unlockexit (
	void
	)
{
	_munlock(_EXIT_LOCK1);
}


/***
* static void _initterm(PF * pfbegin, PF * pfend) - call entries in
*	function pointer table
*
*Purpose:
*	Walk a table of function pointers, calling each entry, as follows:
*
*		1. walk from beginning to end, pfunctbl is assumed to point
*		   to the beginning of the table, which is currently a null entry,
*		   as is the end entry.
*		2. skip NULL entries
*		3. stop walking when the end of the table is encountered
*
*Entry:
*	PF *pfbegin	- pointer to the beginning of the table (first valid entry).
*	PF *pfend	- pointer to the end of the table (after last valid entry).
*
*Exit:
*	No return value
*
*Notes:
*	This routine must be exported in the CRT DLL model so that the client
*	EXE and client DLL(s) can call it to initialize their C++ constructors.
*
*Exceptions:
*	If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

void _CALLTYPE4 _initterm (
	PF * pfbegin,
	PF * pfend
	)
{
	/*
	 * walk the table of function pointers from the bottom up, until
	 * the end is encountered.  Do not skip the first entry.  The initial
	 * value of pfbegin points to the first valid entry.  Do not try to
	 * execute what pfend points to.  Only entries before pfend are valid.
	 */
	while ( pfbegin < pfend )
	{
		/*
		 * if current table entry is non-NULL, call thru it.
		 */
		if ( *pfbegin != NULL )
			(**pfbegin)();
		++pfbegin;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\crt0init.c ===
/***
*crt0init.c - Initialization segment declarations.
*
*	Copyright (c) 1992-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Do initialization segment declarations.
*
*Notes:
*	In the 16-bit C world, the X*B and X*E segments were empty except for
*	a label.  This will not work with COFF since COFF throws out empty
*	sections.  Therefore we must put a zero value in them.	(Zero because
*	the routine to traverse the initializers will skip over zero entries.)
*
*Revision History:
*	03-19-92  SKS	Module created.
*	03-24-92  SKS	Added MIPS support (NO_UNDERSCORE)
*	08-06-92  SKS	Revised to use new section names and macros
*	10-19-93  SKS	Add .DiRECTiVE section for MIPS, too!
*	10-28-93  GJF	Rewritten in C
*	10-28-94  SKS	Add user32.lib as a default library
*	02-27-95  CFW	Remove user32.lib as a default library
*
*******************************************************************************/

#ifdef	_MSC_VER


#include <stdio.h>
#include <internal.h>

#pragma data_seg(".CRT$XIA")
_PVFV __xi_a[] = { NULL };


#pragma data_seg(".CRT$XIZ")
_PVFV __xi_z[] = { NULL };


#pragma data_seg(".CRT$XCA")
_PVFV __xc_a[] = { NULL };


#pragma data_seg(".CRT$XCZ")
_PVFV __xc_z[] = { NULL };


#pragma data_seg(".CRT$XPA")
_PVFV __xp_a[] = { NULL };


#pragma data_seg(".CRT$XPZ")
_PVFV __xp_z[] = { NULL };


#pragma data_seg(".CRT$XTA")
_PVFV __xt_a[] = { NULL };


#pragma data_seg(".CRT$XTZ")
_PVFV __xt_z[] = { NULL };
#pragma data_seg()	/* reset */


#pragma comment(linker, "-merge:.CRT=.data")

#endif	/* _MSC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\trace.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       trace.cxx
//
//  Contents:   TraceInfo functions
//
//  History:    14-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
#include <stdarg.h>
#include <ole2int.h>
#if DBG==1

#ifdef FLAT
#include <sem.hxx>
#include <dllsem.hxx>
#endif // FLAT

#include "oleprint.hxx"
#include "sym.hxx"

// *** Global data ***
DWORD g_dwInfoLevel = INF_OFF;
extern CSym *g_pSym;
extern char gPidString[];

//+---------------------------------------------------------------------------
//
//  Function:   TraceInfoEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              trace information is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int TraceInfoEnabled()
{
    return g_dwInfoLevel & INF_BASE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceCmnEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              cmn api information is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int TraceCmnEnabled()
{
    return g_dwInfoLevel & INF_CMN;
}

//+---------------------------------------------------------------------------
//
//  Function:   SymInfoEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              symbol information is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int SymInfoEnabled()
{
    return g_dwInfoLevel & INF_SYM;
}

//+---------------------------------------------------------------------------
//
//  Function:   StructInfoEnabled
//
//  Synopsis:   Checks our trace info level to see if output of
//              expanded structures is enabled
//
//  Arguments:  (none)
//
//  Returns:    > 0 if enabled, 0 if not
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
inline int StructInfoEnabled()
{
    return g_dwInfoLevel & INF_STRUCT;
}

//+---------------------------------------------------------------------------
//
//  Function:   TLSIncTraceNestingLevel
//
//  Synopsis:   Returns the current nesting level, then increments it
//
//  Returns:    nesting level for OLETRACE
//
//  History:    13-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
inline LONG TLSIncTraceNestingLevel()
{
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        return (tls->cTraceNestingLevel)++;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   TLSDecTraceNestingLevel
//
//  Synopsis:   Decrement and return nesting level
//
//  Returns:    nesting level for OLETRACE
//
//  History:    13-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
inline LONG TLSDecTraceNestingLevel()
{
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
    {
        return --(tls->cTraceNestingLevel);
    }

    return 0;
}

// *** Inline Functions
//+---------------------------------------------------------------------------
//
//  Function:   IsAPIID
//
//  Synopsis:   Returns whether or not an 32-bit ID is a API ID
//
//  Arguments:  [dwID]  -   32-bit ID
//
//  Returns:    TRUE if it is an API ID, FALSE otherwise
//
//  History:    04-Aug-95   t-stevan   Created
//
//----------------------------------------------------------------------------
BOOL IsAPIID(DWORD dwID)
{
    return !(dwID>>16);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNameFromAPIID
//
//  Synopsis:   Returns a pointer to a string containing the API name
//
//  Arguments:  [dwID]  -   API ID
//
//  Returns:    Pointer to a string
//
//  History:    04-Aug-95   t-stevan   Created
//
//----------------------------------------------------------------------------
const char *GetNameFromAPIID(DWORD dwID)
{
    return (g_ppNameTables[dwID>>16])[dwID&0xffff];
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNameFromOBJID
//
//  Synopsis:   Returns a pointer to a string containing the object/method name
//
//  Arguments:  [dwID]  -   32-bit ID
//
//  Returns:    Pointer to a string
//
//  History:    04-Aug-95   t-stevan   Created
//
//----------------------------------------------------------------------------
const char *GetNameFromOBJID(DWORD dwID, IUnknown *pUnk, char *pBuf)
{
    wsprintfA(pBuf, "%s(%x)->%s", g_pscInterfaceNames[dwID>>16], pUnk, (g_ppNameTables[dwID>>16])[dwID&0xffff]);

    return pBuf;
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracein
//
//  Synopsis:   Prints trace information for API/Method-entry
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracein(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    va_start(args, dwID);

    iNestingLevel = TLSIncTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                        GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracecmnin
//
//  Synopsis:   Prints trace information for API/Method-entry
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracecmnin(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    if (!TraceCmnEnabled())
    {
        return;
    }

    va_start(args, dwID);

    iNestingLevel = TLSIncTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                        GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletraceout
//
//  Synopsis:   Prints trace information for API/Method-exit. assuming
//                return value is an HRESULT
//
//  Arguments:  [dwID]            -    API/Method ID
//              [hr]              -    return value
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletraceout(DWORD dwID, HRESULT hr)
{
    _oletraceoutex(dwID, RETURNFMT("%x"), hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracecmnout
//
//  Synopsis:   Prints trace information for API/Method-exit. assuming
//                return value is an HRESULT
//
//  Arguments:  [dwID]            -    API/Method ID
//              [hr]              -    return value
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracecmnout(DWORD dwID, HRESULT hr)
{
    _oletracecmnoutex(dwID, RETURNFMT("%x"), hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletraceoutex
//
//  Synopsis:   Prints trace information for API/Method-exit, using given
//                format string for return value
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletraceoutex(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    va_start(args, dwID);

    iNestingLevel = TLSDecTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                       GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   _oletracecmnoutex
//
//  Synopsis:   Prints trace information for API/Method-exit, using given
//                format string for return value
//
//  Arguments:  [dwID]            -    API/Method ID
//
//  Returns:    nothing
//
//  History:    14-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void _oletracecmnoutex(DWORD dwID, ...)
{
    const char *pscFormat;
    va_list args;
    int iNestingLevel;

    if (!TraceCmnEnabled())
    {
        return;
    }

    va_start(args, dwID);

    iNestingLevel = TLSDecTraceNestingLevel();

    if(TraceInfoEnabled())
    {
        if(IsAPIID(dwID))
        {
            // This is an API
            pscFormat = va_arg(args, const char*);

            oleprintf(iNestingLevel,
                       GetNameFromAPIID(dwID), pscFormat, args);
        }
        else
        {
            IUnknown *pUnk;
            char szTemp[128];

            // This is an object/method call
            pUnk = va_arg(args, IUnknown *);

            pscFormat = va_arg(args, const char *);

            oleprintf(iNestingLevel,
                        GetNameFromOBJID(dwID, pUnk, szTemp), pscFormat, args);
        }
    }

    va_end(args);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeTraceInfo
//
//  Synopsis:   Initializes the trace information's global variables,
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void InitializeTraceInfo()
{
    // get Pid string once
    _itoa(GetCurrentProcessId(), gPidString, 10);

    if(TraceInfoEnabled() && SymInfoEnabled())
    {
        // Initialize the symbol information
        // CAUTION:  This is very expensive to turn on!
        g_pSym = new CSym();
    }

}

void SetTraceInfoLevel(DWORD dwLevel)
{
    g_dwInfoLevel = dwLevel;

    if(TraceInfoEnabled() && (g_pSym == NULL) && SymInfoEnabled())
    {
        // Initialize the symbol information
        g_pSym = new CSym();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupTraceInfo
//
//  Synopsis:   Cleans up trace information's global variables
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void CleanupTraceInfo()
{
    if(g_pSym != NULL)
    {
        delete g_pSym;
    }
    WriteToLogFile(NULL); // Stop writing to log file
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\ctype.c ===
/***
*ctype.c - _ctype definition file
*
*	Copyright (c) 1989-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	_ctype definition file of character classification data.  This file
*	initializes the array used by the character classification macros
*	in ctype.h.
*
*Revision History:
*	06-08-89  PHG	Module created, based on asm version
*	08-28-89  JCR	Corrected _ctype declaration to match ctype.h
*	04-06-90  GJF	Added #include <cruntime.h>. Also, fixed the copyright.
*	10-08-91  ETC	_ctype table is unsigned short under _INTL.
*	11-11-91  ETC	Declare _pctype and _pwctype under _INTL.
*	12-16-91  ETC	Make ctype table width independent of _INTL, use
*			_NEWCTYPETABLE for short table, else char.
*	04-06-92  KRS	Remove _INTL switches.
*  01-19-03  CFW  Move to _NEWCTYPETABLE, remove switch.
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>

const unsigned short * _pctype = _ctype+1;  /* pointer to table for char's    */
const unsigned short * _pwctype = _ctype+1; /* pointer to table for wchar_t's */

const unsigned short  _VARTYPE1 _ctype[257] = {
	0,			/* -1 EOF   */
	_CONTROL,		/* 00 (NUL) */
	_CONTROL,		/* 01 (SOH) */
	_CONTROL,		/* 02 (STX) */
	_CONTROL,		/* 03 (ETX) */
	_CONTROL,		/* 04 (EOT) */
	_CONTROL,		/* 05 (ENQ) */
	_CONTROL,		/* 06 (ACK) */
	_CONTROL,		/* 07 (BEL) */
	_CONTROL,		/* 08 (BS)  */
	_SPACE+_CONTROL,	/* 09 (HT)  */
	_SPACE+_CONTROL,	/* 0A (LF)  */
	_SPACE+_CONTROL,	/* 0B (VT)  */
	_SPACE+_CONTROL,	/* 0C (FF)  */
	_SPACE+_CONTROL,	/* 0D (CR)  */
	_CONTROL,		/* 0E (SI)  */
	_CONTROL,		/* 0F (SO)  */
	_CONTROL,		/* 10 (DLE) */
	_CONTROL,		/* 11 (DC1) */
	_CONTROL,		/* 12 (DC2) */
	_CONTROL,		/* 13 (DC3) */
	_CONTROL,		/* 14 (DC4) */
	_CONTROL,		/* 15 (NAK) */
	_CONTROL,		/* 16 (SYN) */
	_CONTROL,		/* 17 (ETB) */
	_CONTROL,		/* 18 (CAN) */
	_CONTROL,		/* 19 (EM)  */
	_CONTROL,		/* 1A (SUB) */
	_CONTROL,		/* 1B (ESC) */
	_CONTROL,		/* 1C (FS)  */
	_CONTROL,		/* 1D (GS)  */
	_CONTROL,		/* 1E (RS)  */
	_CONTROL,		/* 1F (US)  */
	_SPACE+_BLANK,		/* 20 SPACE */
	_PUNCT, 		/* 21 !     */
	_PUNCT, 		/* 22 "     */
	_PUNCT, 		/* 23 #     */
	_PUNCT, 		/* 24 $     */
	_PUNCT, 		/* 25 %     */
	_PUNCT, 		/* 26 &     */
	_PUNCT, 		/* 27 '     */
	_PUNCT, 		/* 28 (     */
	_PUNCT, 		/* 29 )     */
	_PUNCT, 		/* 2A *     */
	_PUNCT, 		/* 2B +     */
	_PUNCT, 		/* 2C ,     */
	_PUNCT, 		/* 2D -     */
	_PUNCT, 		/* 2E .     */
	_PUNCT, 		/* 2F /     */
	_DIGIT+_HEX,		/* 30 0     */
	_DIGIT+_HEX,		/* 31 1     */
	_DIGIT+_HEX,		/* 32 2     */
	_DIGIT+_HEX,		/* 33 3     */
	_DIGIT+_HEX,		/* 34 4     */
	_DIGIT+_HEX,		/* 35 5     */
	_DIGIT+_HEX,		/* 36 6     */
	_DIGIT+_HEX,		/* 37 7     */
	_DIGIT+_HEX,		/* 38 8     */
	_DIGIT+_HEX,		/* 39 9     */
	_PUNCT, 		/* 3A :     */
	_PUNCT, 		/* 3B ;     */
	_PUNCT, 		/* 3C <     */
	_PUNCT, 		/* 3D =     */
	_PUNCT, 		/* 3E >     */
	_PUNCT, 		/* 3F ?     */
	_PUNCT, 		/* 40 @     */
	_UPPER+_HEX,		/* 41 A     */
	_UPPER+_HEX,		/* 42 B     */
	_UPPER+_HEX,		/* 43 C     */
	_UPPER+_HEX,		/* 44 D     */
	_UPPER+_HEX,		/* 45 E     */
	_UPPER+_HEX,		/* 46 F     */
	_UPPER, 		/* 47 G     */
	_UPPER, 		/* 48 H     */
	_UPPER, 		/* 49 I     */
	_UPPER, 		/* 4A J     */
	_UPPER, 		/* 4B K     */
	_UPPER, 		/* 4C L     */
	_UPPER, 		/* 4D M     */
	_UPPER, 		/* 4E N     */
	_UPPER, 		/* 4F O     */
	_UPPER, 		/* 50 P     */
	_UPPER, 		/* 51 Q     */
	_UPPER, 		/* 52 R     */
	_UPPER, 		/* 53 S     */
	_UPPER, 		/* 54 T     */
	_UPPER, 		/* 55 U     */
	_UPPER, 		/* 56 V     */
	_UPPER, 		/* 57 W     */
	_UPPER, 		/* 58 X     */
	_UPPER, 		/* 59 Y     */
	_UPPER, 		/* 5A Z     */
	_PUNCT, 		/* 5B [     */
	_PUNCT, 		/* 5C \     */
	_PUNCT, 		/* 5D ]     */
	_PUNCT, 		/* 5E ^     */
	_PUNCT, 		/* 5F _     */
	_PUNCT, 		/* 60 `     */
	_LOWER+_HEX,		/* 61 a     */
	_LOWER+_HEX,		/* 62 b     */
	_LOWER+_HEX,		/* 63 c     */
	_LOWER+_HEX,		/* 64 d     */
	_LOWER+_HEX,		/* 65 e     */
	_LOWER+_HEX,		/* 66 f     */
	_LOWER, 		/* 67 g     */
	_LOWER, 		/* 68 h     */
	_LOWER, 		/* 69 i     */
	_LOWER, 		/* 6A j     */
	_LOWER, 		/* 6B k     */
	_LOWER, 		/* 6C l     */
	_LOWER, 		/* 6D m     */
	_LOWER, 		/* 6E n     */
	_LOWER, 		/* 6F o     */
	_LOWER, 		/* 70 p     */
	_LOWER, 		/* 71 q     */
	_LOWER, 		/* 72 r     */
	_LOWER, 		/* 73 s     */
	_LOWER, 		/* 74 t     */
	_LOWER, 		/* 75 u     */
	_LOWER, 		/* 76 v     */
	_LOWER, 		/* 77 w     */
	_LOWER, 		/* 78 x     */
	_LOWER, 		/* 79 y     */
	_LOWER, 		/* 7A z     */
	_PUNCT, 		/* 7B {     */
	_PUNCT, 		/* 7C |     */
	_PUNCT, 		/* 7D }     */
	_PUNCT, 		/* 7E ~     */
	_CONTROL,		/* 7F (DEL) */
	/* and the rest are 0... */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\cruntime.h ===
/***
*cruntime.h - definitions specific to the target operating system and
*       hardware
*
*       Copyright (c) 1990-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header file contains widely used definitions specific to the
*       host operating system and hardware. It is included by every C source
*       and most every other header file.
*       [Internal]
*
*Revision History:
*       02-27-90   GJF  File created
*       03-06-90   GJF  Added register macros (REG1,...,etc.)
*       04-11-90   GJF  Set _CALLTYPE1 and _CALLTYPE4 to _stdcall.
*       10-30-90   GJF  Added macros defining variable args interface.
*       10-31-90   GJF  Added definition of _JBLEN (from setjmp.h).
*       11-13-90   GJF  Revised #ifdef-s, now use symbolic constants
*                       representing target OS and target processor, with
*                       #error directives for unsupported targets. Note the
*                       general grouping of only OS-dependent definitions
*                       followed by OS and processor dependent definitions.
*       02-25-91   SRW  Move _JBLEN definition back to setjmp.h [_WIN32_]
*       04-09-91   PNT  Added _MAC_ definitions
*       05-09-91   GJF  Restored _JBLEN definitions. Also fixed the macros
*                       defining the target processor so both Stevewo's stuff
*                       and mine would work.
*       05-13-91   GJF  Changed _CALLTYPE1 and _CALLTYPE4 to _cdecl for
*                       Cruiser (_CRUISER_).
*       08-28-91   JCR  ANSI keywords
*       11-01-91   GDP  _JBLEN back to setjmp.h, stdarg macros back to stdarg.h
*       03-30-92   DJM  POSIX support.
*       08-07-92   GJF  Revised various macros.
*       09-08-92   GJF  Restored definition of _MIPS_ (temporarily).
*       11-09-92   GJF  Revised preprocessing conditionals for MIPS.
*       01-09-93   SRW  Remove usage of MIPS and ALPHA to conform to ANSI
*                       Use _MIPS_ and _ALPHA_ instead.
*       02-01-93   GJF  Removed support for C6-386.
*
****/

#ifndef _INC_CRUNTIME

/*
 * Some CRT sources have code conditioned on _MIPS_. Continue to define
 * _MIPS_ when MIPS is defined until these sources are fixed.
 */
#if defined(MIPS) && !defined(_MIPS_)
#define _MIPS_
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif

/*
 * Old function calling type and variable type qualifier macros
 */
#define _CALLTYPE1  __cdecl
#define _CALLTYPE2  __cdecl
#define _CALLTYPE4  __cdecl
#define _VARTYPE1


#ifdef  _CRUISER_

/*
 * DEFINITIONS FOR CRUISER (AKA OS/2 2.0).
 */

#define _CALLTYPE3      __syscall       /* OS API functions */


/*
 * Macros for register variable declarations
 */

#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

/*
 * Macros for varargs support
 */

#define _VA_LIST_T  char *

#else   /* ndef _CRUISER_ */

#ifdef  _WIN32_

/*
 * DEFINITIONS FOR WIN32
 */

#ifdef	_ALPHA_
#define _VA_LIST_T \
    struct { \
        char *a0;       /* pointer to first homed integer argument */ \
        int offset;     /* byte offset of next parameter */ \
    }
#else
#define _VA_LIST_T  char *
#endif

#if defined(_M_IX86)
/*
 * 386/486
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#elif defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
/*
 * MIPS or ALPHA
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#define REG5    register
#define REG6    register
#define REG7    register
#define REG8    register
#define REG9    register

#else

#error ERROR - SUPPORT FOR WIN32 NT-X86, NT-MIPS, NT-ALPHA, AND NT-PPC ONLY

#endif

#else   /* ndef _WIN32_ */

#ifdef _POSIX_
/*
 * DEFINITIONS FOR POSIX
 */


#ifdef _ALPHA_

#define _VA_LIST_T \
    struct { \
        char *a0;       /* pointer to first homed integer argument */ \
        int offset;     /* byte offset of next parameter */ \
    }
#else

#define _VA_LIST_T  char *

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _VA_START(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define _VA_ARG(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _VA_END(ap) ap = (va_list)0

#endif

#if defined(_M_IX86)
/*
 * 386/486
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#elif defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
/*
 * MIPS/Alpha/PPC
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#define REG5    register
#define REG6    register
#define REG7    register
#define REG8    register
#define REG9    register

#else

#error ERROR - SUPPORT FOR POSIX NT-X86, NT-MIPS, NT-ALPHA, AND NT_PPC ONLY

#endif

#else   /* ndef _POSIX_ */

#ifdef  _MAC_

/*
 * DEFINITIONS FOR MAC.
 */

/*
 * Macros for register variable declarations
 */

#define REG1
#define REG2
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

/*
 * Macros for varargs support
 */

#define _VA_LIST_T  char *

#else   /* ndef _MAC_ */

#error ERROR - ONLY CRUISER, WIN32, OR MAC TARGET SUPPORTED!

#endif  /* _MAC_ */

#endif  /* _WIN32_ */

#endif  /* _POSIX_ */

#endif  /* _CRUISER_ */

#define _INC_CRUNTIME
#endif  /* _INC_CRUNTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;	Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines the current memory model being used.
;
;Revision History:
;	08-04-88  SJM	Initial version to handle all four memory models
;			in 16-bit mode and small model in 32-bit mode
;	08-08-88  JCR	Added CPDIST, ?WIN, PCS, ISHIFT/LSHIFT, OS2,
;			DNPTR/DFPTR, DFLOAT/DDOUBLE/DLDOUBLE
;	08-16-88  PHG	Added FPES, LFPES, CBI, ZXAL, ZXBL, ZXCL, ZXDL
;	08-17-88  JCR	Added CAXDX, modified FPSIZE
;	08-20-88  PHG	Added diagnostic messages, removed 386 16-bit support
;			and 386 large code/data support, added mucho comments,
;			PSS now defined as es: only if SS_NEQ_GROUP defined
;	08-24-88  JCR	Added RBXSAVE and RBXONLY for use in 'proc uses'
;	08-25-88  JCR	Added savereg macro, removed rbxsave/rbxonly...
;	08-26-88  GJF	Added codeseg (text) macro
;	09-15-88  JCR	Corrected savelist/reglist macro to go with new MASM
;	09-21-88  WAJ	Added JS*, static*, global*, and label*, and lab macros
;	09-22-88  JCR	Change 'plm' to 'pascal' in label macro
;	09-26-88  WAJ	Added PUSH16 which will do a 16 bit push in a USE32 seg.
;	09-28-88  WAJ	Added CPWORD and DPWORD
;	09-29-88  WAJ	Added JMPFAR16 macro
;	10-12-88  JCR	Made PCS evaluate to 'cs:' for 16/32 stub testbed
;	04-24-89  JCR	Added 'assume seg:flat' for 386 to avoid masm/link bug
;	05-25-89  GJF	Added APIEXT, a macro that expands to the proper extrn
;			declaration for an API function
;	06-13-89  JCR	Added 'flat:' to DCPTR and DDPTR
;	09-15-89  JCR	Added DCPTR? and DDPTR?, always use "FLAT" not "flat"
;	10-27-92  SKS	Miscellaneous minor changes for MASM 6.10 compatibility
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86		8086/8088 processor
;   -DI286		80286 processor
;   -DI386		80386 processor with 32-bit code/data segment
;
;   -Dmem_S		Small memory model   (near code, near data)
;   -Dmem_M		Medium memory model  (far code, near data)
;   -Dmem_C		Compact memory model (near code, fat data)
;   -Dmem_L		Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP	SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu 			86, 286, or 386
;   sizeC			code distance; 1 = far code, 0 = near code
;   sizeD			data distance; 1 = far data, 0 = near data
;   mmodel			english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE 	size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE	size of float, double, long double
;   NPSIZE, FPSIZE		size of near/far pointers
;   CPSIZE, DPSIZE		size of code/data pointers
;   ISHIFT, LSHIFT		bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx, 	expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ			jump when rcx is zero
;   CBI 			convert byte to int (al to rax)
;   CAXDX			convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL	zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES			load data pointer with ES or DS
;   PDS, PES			segment overrides when pointer loaded as above
;   PCS, PSS			segment override to get at code/stack segment
;   LFPDS, LFPES		load far pointer with ES or DS
;   FPDS, FPES			segment overrides when pointer loaded as above
;   CPTR			data type of code pointer
;   CPDIST			distance of code (near/far)
;   DNPTR, DFPTR		define near/far pointer
;   DCPTR, DDPTR		define code/data pointer
;   DCPTR?, DDPTR?		define uninitialized code/data pointer
;   CPWORD, DPWORD		data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD 	data type of int, long, short
;   DINT, DLONG, DSHORT 	define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE	define float, double, long double
; Offsets:
;   codeoffset, dataoffset	offsets from code and data segments
; API calls:
;   APIDIST			distance of API calls (near/far)
;   APIEXT ApiName		extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg			define/declare code segment
;   error <msg> 		stop assembly with message
;   display <msg>		display a message, unless QUIET defined
;   savelist [<reg> ...]	init list of regs to be save by 'proc uses'
;   _if cond <instruction>	assemble instruction only if cond is TRUE
;   _ife cond <instruction>	assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>	assemble instruction only if symbol defined
;   _ifnd symbol <instruction>	assemble instruction only if symbol not defined
;
;   lab  LabelName		assembles to "LabelName:" If DEBUG is defined
;				LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)	assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat	 defines a static variable of type *
;   global* Name, InitialValue, Repeat	 defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}	 defines a label of type *
;
;   PUSH16  SegmentReg		pushes 16 bits in a use32 segment
;   JMPFAR16  label		will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>	-    Output message and generate error

error	MACRO	msg
if2			;; only on pass 2 can we generate errors
	%out	**********************************************************
	%out	*** E r r o r  --  msg
	%out	**********************************************************
	.err
endif
        ENDM

; display msg	-    Output message unless QUIET defined

display MACRO	msg
ifndef QUIET		;; only when quiet flag not set
if1			;; and on pass 1, then display message
	%out msg
endif
endif
	ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;					       push  ds
;					   endif

_if	MACRO	cond,text
    if	cond
	text
    endif
	ENDM

_ife	MACRO	cond,text
    ife cond
	text
    endif
	ENDM

_ifd	MACRO	cond,text
    ifdef   cond
	text
    endif
	ENDM

_ifnd	MACRO	cond,text
    ifndef  cond
	text
    endif
	ENDM

; set windows flag to 0

	?WIN	equ	0	; disable windows-specific code

; check for MTHREAD, requires 286 or greater processor

ifdef MTHREAD
ifndef I386
ifndef I286
; MTHREAD implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
	; Medium model
	sizeC	equ	1
	sizeD	equ	0
	mmodel	equ	<Medium>
elseifdef  mem_C
	; Compact model
	sizeC	equ	0
	sizeD	equ	1
	mmodel	equ	<Compact>
elseifdef  mem_L
	; Large model
	sizeC	equ	1
	sizeD	equ	1
	mmodel	equ	<Large>
else
	; Small model - default
	sizeC	equ	0
	sizeD	equ	0
	mmodel	equ	<Small>
endif

; Process processor arguments

ifdef	    I286
	display <Processor:		80286>
	cpu equ 286
	.286
elseifdef   I386
	display <Processor:		80386>
	cpu equ 386
	OS2   equ <>	; Define "OS2" since 386 can only run on that OS
	.386
else
	display <Processor:		8086/8088>
	cpu equ 86
	.8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
	error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
	error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
	error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%	display <Memory model:		mmodel>
%	.model	mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef	I386
	; ensure that MASM recognizes 'FLAT'
	assume	gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>	 ; convert byte to int (al to rax)
    CAXDX equ <cdq>		 ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>	 ; zero extend al
    ZXBL  equ <movzx ebx, bl>	 ; zero extend bl
    ZXCL  equ <movzx ecx, cl>	 ; zero extend cl
    ZXDL  equ <movzx edx, dl>	 ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>		 ; convert byte to int (al to rax)
    CAXDX equ <cwd>		 ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>	 ; zero extend al
    ZXBL  equ <xor bh, bh>	 ; zero extend bl
    ZXCL  equ <xor ch, ch>	 ; zero extend cl
    ZXDL  equ <xor dh, dh>	 ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>		; large code model or non-386
else
 IF 1	;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <> 		; 386 small code model
 ENDIF	;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>		; SS != DS
else
    PSS   equ <>		; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset	equ <offset FLAT:>
    dataoffset	equ <offset FLAT:>
else
    codeoffset	equ <offset @code:>
    dataoffset	equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386	 ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>
if @Version LT 600
    SWORD   equ <word>
endif

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>		; near pointer
    DFPTR equ <dd>		; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>		; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>		; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword> 	; code pointers are dwords
    DPWORD  equ <dword> 	; data pointers are dwords

    APIDIST equ <near>		; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:near
endm

else	;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>
if @Version LT 600
    SWORD   equ <word>
endif

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>		; near pointer
    DFPTR equ <dd>		; far pointer

    if sizeC
	DCPTR	equ <dd>       ; 16 bit segment and 16 bit offset
	DCPTR?	equ <dd>
	CPSIZE	equ 4
	CPDIST	equ <far>      ; code pointers are far
	CPTR	equ <far ptr>
	CPWORD	equ <dword>    ; code pointers are dwords
    else
	DCPTR	equ <dw>       ; 16 bit offset only
	DCPTR?	equ <dw>
	CPSIZE	equ 2
	CPDIST	equ <near>     ; code pointers are near
	CPTR	equ <near ptr>
	CPWORD	equ <word>     ; code pointers are words
    endif

    if sizeD
	DDPTR	equ <dd>
	DDPTR?	equ <dd>
	DPSIZE	equ 4
	DPWORD	equ <dword>    ; data pointers are dwords
    else
	DDPTR	equ <dw>
	DDPTR?	equ <dw>
	DPSIZE	equ 2
	DPWORD	equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>		; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:far
endm

endif	; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ	4	; float
DBLSIZE  equ	8	; double
LDBLSIZE equ	10	; long double

DFLOAT	 equ	<dd>
DDOUBLE  equ	<dq>
DLDOUBLE equ	<dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;	reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;	reglist = text string of registers that can be passed to the 'uses'
;	option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
	local	ws, listsize
	ws	catstr	< >		; whitespace char

	IFNDEF	I386
	 rbx equ <>			; 8086/286 don't save rbx
	ENDIF

	IFNB	    <reg4>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
	ELSEIFNB    <reg3>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws
	ELSEIFNB    <reg2>
	 reglist     catstr  reg1, ws, reg2, ws,       ws
	ELSEIFNB    <reg1>
	 reglist     catstr  reg1, ws,	     ws,       ws
	ELSE
	 reglist     catstr  <>
	ENDIF

	listsize sizestr reglist	; size of register list

	IF	listsize LE 3		; if list is only the 3 ws chars...
	 reglist catstr  <>
	ENDIF

	IFNDEF	I386
	 rbx equ <bx>			; restore rbx
	ENDIF

	ENDM	; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;	.code _TEXT	; for large code models
;	.code		; for small code models
;	assume	cs:FLAT ; for 386
;	assume	ds:FLAT ; for 386
;	assume	es:FLAT ; for 386
;	assume	ss:FLAT ; for 386
;

codeseg MACRO

if	sizeC
	.code _TEXT
else
	.code
endif

ifdef	I386
if	@Version LT 600
	assume	cs:FLAT
endif	;@Version LT 600
	assume	ds:FLAT
	assume	es:FLAT
	assume	ss:FLAT
endif

	ENDM

;***************************************************************
;*
;*  Debug lab macro
;*
;***************************************************************

lab	macro name
ifdef	DEBUG
    public  pascal name	    ;; define label public for Symdeb
endif
name:
	endm


;***************************************************************
;*
;*  Conditional jump short macros
;*
;***************************************************************


	irp	x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x	equ   <j&x short>
	endm


;***************************************************************
;*
;*  Global data definition macros
;*
;*  Usage:
;*	globalI   Name, InitialValue, Repeat
;*
;***************************************************************


MakeGlobal  macro   suffix, DataType	    ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public	name
ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeGlobal	T, dt			; globalT
    MakeGlobal	Q, dq			; globalQ
    MakeGlobal	D, dd			; globalD
    MakeGlobal	W, dw			; globalW
    MakeGlobal	B, db			; globalB

%   MakeGlobal	I, <DINT>		; globalI

%   MakeGlobal	DP, <DDPTR>		; globalDP
%   MakeGlobal	CP, <DCPTR>		; globalCP
%   MakeGlobal	FP, <DFPTR>		; globalFP
%   MakeGlobal	NP, <DNPTR>		; globalNP



;***************************************************************
;*
;*  Static data definition macros
;*
;*  Usage:
;*	staticI   Name, InitialValue, Repeat
;*
;***************************************************************


MakeStatic  macro   suffix, DataType	    ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name			    ;; make statics public if DEBUG
endif

ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeStatic	T, dt			; staticT
    MakeStatic	Q, dq			; staticQ
    MakeStatic	D, dd			; staticD
    MakeStatic	W, dw			; staticW
    MakeStatic	B, db			; staticB

%   MakeStatic	I, <DINT>		; staticI

%   MakeStatic	DP, <DDPTR>		; staticDP
%   MakeStatic	CP, <DCPTR>		; staticCP
%   MakeStatic	FP, <DFPTR>		; staticFP
%   MakeStatic	NP, <DNPTR>		; staticNP

;***************************************************************
;*
;*  Label definition macros
;*
;************