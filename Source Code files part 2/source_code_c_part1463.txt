dict+i*BUCKETSIZE) == 0)
            {
            // remove the rear of stem in the LenDict
                __DelStemN(stem, ulspos, dict[(i+1)*BUCKETSIZE-1]+1);
                return i;
            }
        }            
    }        
    return -1;
}

//   Restore the part of stem which is removed in FindWord
void LenDict::RestWord(char *stem,
                       int &ulspos,
                       int restindex)
{
    for (int i=0;  ;i++)
    {
        if (dict[restindex*BUCKETSIZE+i] == 0)  
        {
            break;
        }            
        ulspos++;
        stem[ulspos] = dict[restindex*BUCKETSIZE+i];
    }
    stem[ulspos+1] = NULLCHAR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basefunc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <string.h>
#include <memory.h>
#include "basecore.hpp"

void hugestrcpy(char  *, char  *);
void hugememcpy(char  *, char  *, long);
void hugememset(char  *, long);
void hugestrcat(char  *, char  *);
int  hugestrcmp(char  *, char  *);

void hugestrcpy(    char  *dest,
                    char  *src)
{
    while (*src)    *dest++ = *src++;

    *dest = 0x00;
}

// ------------------------------------------------------------------------------------
//
// ------------------------------------------------------------------------------------
void hugememcpy(    char  *dest,
                    char  *src,
                    long cnt)
{
    long    i;

    i = 0L;

    while (i < cnt)
    {
        dest[i] = src[i];
        i++;
    }
}

// ------------------------------------------------------------------------------------
//
// ------------------------------------------------------------------------------------
void hugememset(    char  *str,
                    long size)
{
    while (size--)  *str++ = 0x00;
}

// ------------------------------------------------------------------------------------
//
// ------------------------------------------------------------------------------------
void hugestrcat(    char  *dest,
                    char  *src)
{
    while (*dest)   dest++;

    while (*src)    *dest++ = *src++;

    *dest = 0x00;
}

// ------------------------------------------------------------------------------------
//
// ------------------------------------------------------------------------------------
int hugestrcmp(char  *str1, char  *str2)
{
    while (*str1)
    {
        if (*str1 != *str2) return (*str1 - *str2);

        str1++;
        str2++;
    }
    return 0;
}



// ------------------------------------------------------
//
// ------------------------------------------------------
int PrintBit(unsigned char data)
{
    char    bitstring[9];

    for (int i = 0; i < 8; i++) bitstring[7-i] = (GetBit(data, i) == 0) ? '0' : '1';

    bitstring[8] = NULLCHAR;

    return SUCCESS;
}

// ----------------------------------------------------------------------
//
// ----------------------------------------------------------------------
BOOL GetBit( unsigned char data, 
            int pos)          // pos : 0, 1, 2, ..., 7
{
    char    mask = 0x01;

    return ((data & (mask << pos)) == 0) ? FALSE : TRUE;
}

// ----------------------------------------------------------------------
//
// ----------------------------------------------------------------------
void SetBit(    unsigned char &data, 
                int pos, 
                int newitem)  // newitem : 0, 1
{
    char mask = 0x01;

    if (newitem == 1)   data = data | (mask << pos);
    else                data = data & ~(mask << pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basecore.hpp ===
//////////////////////////////////////////////////
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// File    : basecore.hpp
// Project : NLP Base project
// Purpose : NLP Base Engine prototype
//////////////////////////////////////////////////
#include "basedef.hpp"
#include "basedict.hpp"
#include "convert.hpp"

////////////////////////////////////////////////////////////////




//                                                            

//                  ...ALS, PLS, ULS         ........LME      

////////////////////////////////////////////////////////////////
#define    LME      ending[LMEPOS]
#define    ULS      stem[ULSPOS]
#define    AUXULS   aux_stem[AUX_ULSPOS]
#define    AUXLME   aux_ending[AUX_LMEPOS]

                                        
BOOL  GetBit(unsigned char, int);        // pos : 0, 1, 2, ..., 7
                                        // Generator
void SetBit(unsigned char *, int, int); // newitem : 0, 1
int  PrintBit(unsigned char);

class   BaseEngine 
{
//  CheckStack  CheckTag;
    BOOL        ACT_C,      // action code 7th bit : consonant
                ACT_V,      // action code 6th bit : vowel
                ACT_N_V,    // action code 5th bit : noun & verb
                ACT_P_A,    // action code 4th bit : pronoun & adjective
                ACT_N_E,    
                ACT_SS,     
                ACT_KE;     

    int         ULSPOS,     
                LMEPOS;     

    BOOL        AUX_ACT_C,  
                AUX_ACT_V,  
                AUX_ACT_VB, 
                AUX_ACT_AD, 
                AUX_ACT_J,  
                AUX_ACT_SS; 

    int         AUX_ULSPOS, 
                AUX_LMEPOS; 

    CODECONVERT Conv;
    int        wcount;        // number of separated word    
    char    lrgsz [400];

    public:
        WORD vbuf [400];
        BaseEngine(void) {}
        int NLP_Get_Ending(char  *, char  *, int  *, int);   
        int NLP_Num_Proc(char  *);
        int NLP_CheckSuja(char  *, int);
        int NLP_NCV_Proc(char  *, char  *);
        int NLP_Fix_Proc(char *, char *);

        int NLP_KTC_Proc(char  *, char *);
        int NLP_Machine_T(char  *, char  *);
        int NLP_Jap_Proc(char  *, char  *);
        int NLP_Dap_Proc(char  *);
        int NLP_Gop_Proc(char  *);
        int NLP_Manha_Proc(char  *);
        int NLP_Manhaeci_Proc(char  *);               

        int NLP_VCV_Check(char  *, char  *);
        int NLP_VCV_Proc(char  *, char  *);
        int NLP_Blocking(char  *, char  *);
        int NLP_Block_Comm(char  *, char  *);    
        
// by hjw : 95/3/6
        int NLP_Irr_01(char  *, char  *);
//        int NLP_Irr_01(char  *);
        int NLP_Irr_KN(char  *, char  *);
        int NLP_Irr_KN_Vl(char  *);
        int NLP_Machine_A(char  *, char  *);
        int NLP_Irr_KS(char  *, char  *);
        int NLP_Irr_KM(char  *);
        int NLP_Irr_KRadj(char  *, char  *);
        int NLP_Irr_KRvb(char  *, char  *);
        int NLP_Irr_KI_KR(char  *, char  *);
        int NLP_Irr_KI_V(char  *, char  *);
        int NLP_Irr_OPS(char  *, char  *);
        int NLP_Irr_KI(char  *, char  *);        

        int NLP_SS_Proc(char  *, char  *);
        int NLP_SS_Vl(char  *, char  *);
        int NLP_SS_Vu_irr(char  *, char  *);
        int NLP_SS_Vu_jap(char  *, char  *);
        int NLP_SS_Vu_mrg(char  *, char  *);
        int NLP_SS_Vnj(char  *, char  *);
        int NLP_SS_Vhk(char  *, char  *);
        int NLP_SS_Vho(char  *, char  *);
        int NLP_SS_Vo_KH(char  *, char  *);
        int NLP_SS_Vp(char  *);
        int NLP_SS_Vo(char  *, char  *);
        int NLP_SS_Vil(char  *);
        int NLP_SS_Vul(char  *);
        int NLP_SS_Vj_KR(char  *);
        int NLP_SS_Vj(char  *);
        int NLP_SS_Vk(char  *, char  *);
    
        int NLP_AUX_Find(char  *, char);  
// added by hjw : 95/3/3        
        int NLP_GET_AUX(char  *, char  *, char) ;        
// hjw : 95/3/9
//        int NLP_HAP_ADJ(char  *);
//        int NLP_HAP_VERB(char  *);
//         
        int NLP_AUX_VCV_Check(char  *, char  *);
        int NLP_AUX_Blocking(char  *, char  *);
        int NLP_AUX_IRR_01(char  *);
        int NLP_AUX_IRR_KN(char  *);
        int NLP_AUX_IRR_KR(char  *);
        int NLP_AUX_IRR_KI_KR(char  *, char  *);
        int NLP_AUX_IRR_KI_V(char  *, char  *);
        int NLP_AUX_SS_Vu(char  *);
        int NLP_AUX_SS_Vnj(char  *);
        int NLP_AUX_SS_Vhk(char  *);
        int NLP_AUX_SS_Vo(char  *);
        int NLP_AUX_SS_Vp(char  *);
        int NLP_AUX_SS_Vil(char  *);
        int NLP_AUX_SS_Vul(char  *);
        int NLP_AUX_SS_Vj_KR(char  *);
        int NLP_AUX_SS_Vj(char  *);
        int NLP_AUX_SS_Vk(char  *);


        int NLP_Cikha_Proc(char  *);        
        int NLP_Cikha_Conditions(char  *, char  *);
        int NLP_Cikha_SS(char  *, char  *);
        int NLP_Cikha_SS_Vl(char  *, char  *);
        int NLP_Cikha_SS_Vu_irr(char  *, char  *);
        int NLP_Cikha_SS_Vu_jap(char  *, char  *);
        int NLP_Cikha_SS_Vu_mrg(char  *, char  *);
        int NLP_Cikha_SS_Vnj(char  *, char  *);
        int NLP_Cikha_SS_Vhk(char  *, char  *);
        int NLP_Cikha_SS_Vho(char  *, char  *);
        int NLP_Cikha_SS_Vo_KH(char  *, char  *);
        int NLP_Cikha_SS_Vp(char  *);
        int NLP_Cikha_SS_Vo(char  *, char  *);
        int NLP_Cikha_SS_Vil(char  *);
        int NLP_Cikha_SS_Vul(char  *);
        int NLP_Cikha_SS_Vj_KR(char  *);
        int NLP_Cikha_SS_Vj(char  *);
        int NLP_Cikha_SS_Vk(char  *, char  *);        

        // by dhyu
        void GetStemEnding (char *, char *, char *, int);
        void RestoreEnding (char *, char *);
        int NLP_BASE_NOUN(LPCSTR, char *);
        int NLP_BASE_VERB(LPCSTR, char *);
        int NLP_BASE_ALONE(LPCSTR, char *);
        int NLP_BASE_COMPOUND (LPCSTR, char *);
        int NLP_Find_Pronoun (char *, char *);                
        int NLP_BASE_AFFIX(LPCSTR, char *);
        
        
        
        inline int  __IsDefStem(int ulspos, int num) 
        { return (ulspos-num>=0) ? 1 : 0; }
        inline int  __IsDefEnd(int lmepos, int num) 
        { return (lmepos-num>=0) ? 1 : 0; }
        inline void __DelStem1(char  *stem, int *ulspos) 
        { stem[(*ulspos)--]=0; }
        inline void __DelStem2(char  *stem, int *ulspos) 
        { stem[(*ulspos)--]=0; stem[(*ulspos)--]=0; }
        inline void __DelStemN(char  *stem, int  *ulspos, int num) 
        { stem[(*ulspos)-num+1] = 0;        (*ulspos) -= num; }
        inline void __AddStem1(char  *stem, int *ulspos, char ch) 
        { stem[++(*ulspos)]=ch; stem[(*ulspos)+1]=0; }
        inline void __RepStem1(char  *stem, int ulspos, char ch) 
        { stem[ulspos]=ch; }
        inline void __AddStem2(char  *stem, int *ulspos, char ch1, char ch2) 
        { stem[++(*ulspos)]=ch1; stem[++(*ulspos)]=ch2; stem[(*ulspos)+1]=0; }
        inline void __RepStem2(char  *stem, int ulspos, char ch1, char ch2) 
        { stem[ulspos-1]=ch1; stem[ulspos]=ch2; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\baseirr.cpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// FILE NAME       : BASEIRR.CPP
// FUNCTION        : BASE ENGINE FUNCTION COLLECTION (IRREGUL PROCESS)
//                 : NLP Base Engine Function
// =========================================================================
#include "baseirr.hpp"
#include "basegbl.hpp"
#include "MainDict.h"

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Irr_01() 
//  Parameters      : char  *stem :  
//                    char  *ending :

//  Call Functions  : 
//  Description     :   
//  Return Value    : Irr01_VALID :                 
//                    Irr01_INVALID :
//                    Dap_Proc : 
//                    MORECHECK :
//                    BT :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_01( char  *stem, char  *ending) 
{
    char    tmp[80];
    int        temp, luls;
                
    lstrcpy (tmp, stem);
    luls = ULSPOS;
          
    if(__IsDefStem(luls, 1) == 1 && stem[luls-1] == __K_I && stem[luls] == __V_n)  
    {                           
        temp = luls;
        __AddStem1(stem, &temp, __K_R);   
        luls = temp;
        if(ACT_N_V == 1) 
        {
            for (int i = 0; i < 5 ; i++)    
            {
                if(strcmp(stem, INRBuf[i]) == 0)  
                {
                    char tstem [80];
                    Conv.INS2HAN (stem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;    
                    return Irr_VERB_VALID;
                }                    
            }    
            if(LME == __K_B)                
            {
                return INVALID;    
            }  
            __DelStem2(stem, &temp);          
            luls = temp;                    
            __RepStem1(stem, luls, __K_B);   
            if(FindIrrWord(stem, _IV_BM) & FINAL)   
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;                             
            }
            if(strcmp(stem, TemDop) == 0)
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;
            }     
            __RepStem1(stem, luls, __K_I);           
            __AddStem2(stem, &temp, __V_n, __K_R);    
            luls = temp;                    
        }
        if(ACT_P_A == 1) 
        {                                                        
            for (int i = 0; i < 4; i++)     
            {
                if(strcmp(stem, INRBuf2[i]) == 0)  
                {
                    char tstem [80];
                    Conv.INS2HAN (stem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_ADJECTIVE;
                    return Irr_ADJ_VALID;        
                }   
            }                    
            if(LME == __K_B)                
            {
                return INVALID;    
            }  
            __DelStem2(stem, &temp);          
            luls = temp;                    
            __RepStem1(stem, luls, __K_B);   
            if(FindIrrWord(stem, _RA_B) & FINAL)    
            {
                return INVALID;                            
            }
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }
            if(NLP_Dap_Proc(stem) == Dap_VALID) 
            {
                return Irr_Dap_VALID;                            
            }                
        }
        return BT;            
    }                
    if(__IsDefStem(luls, 1) == 1 && stem[luls-1] == __K_I && stem[luls] == __V_h) 
    {                                                           
        if(ACT_N_V == 1) 
        {
            temp = luls;
            __DelStem1(stem, &temp);
            luls = temp;
            __RepStem1(stem, luls, __K_B);    
            if(FindIrrWord(stem, _IV_BP) & FINAL) 
            {                                               
                if(strcmp(stem, TemDop) == 0)     
                {
                    return INVALID;
                }                    
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;
            } 
        }             
        return BT; 
    }
    return MORECHECK;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Irr_KN() 
//  Parameters      : char  *stem : 
//                    char  *ending :

//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KN( char  *stem, 
                            char  *ending) 
{
    char    tmp[80];                    
    int        temp, luls;

    lstrcpy (tmp, stem);
    luls = ULSPOS;

    if(ACT_C == 1 && ACT_V == 0)       // ACT_CV == 10 
    {
        return INVALID;
    }                              
    if(strcmp(ending, TempNjRk) == 0)                    
    {
        return INVALID;
    }                          
    
    if (ULS >= __V_k)
    {
        temp = luls;
        __AddStem1(stem, &temp, __K_R);                           
        luls = temp;                       
        if(ACT_N_V == 1) 
        {                                                       
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _VERB) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;
            }            
        }            
        if(ACT_P_A == 1) 
        {                                                       
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }                      
            __RepStem1(stem, luls, __K_H);                     
            if(FindIrrWord(stem, _IA_HP) & FINAL ||    
                FindIrrWord(stem, _IA_HM) & FINAL)      
            {            
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }
            if(__IsDefEnd(LMEPOS, 1) == 1 && __IsDefEnd(LMEPOS, 2) == 0 &&
            (ending[LMEPOS-1] == __V_l || ending[LMEPOS-1] == __V_k))   
            {            
                //-------------------------------------------------
                return Irr_KN_Vl;
            }        
            return BT;    
        }        
        temp = luls;
        __DelStem1(stem, &temp); 
        luls = temp;
    }

    if(__IsDefEnd(LMEPOS, 2) == 1 && 
        ending[LMEPOS-2] == __K_N && ending[LMEPOS-1] == __V_m) 
    {        
        //----------------------------------------
        return Irr_OPS;
    }
    return BT;
}                                                       

// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KN_Vl(  char  *stem) 
{
    char    tmp[80];
    int        temp, luls;
                
    lstrcpy (tmp, stem);
    luls = ULSPOS;

    if(__IsDefStem(luls, 1) == 1 && 
        stem[luls-1] == __K_I && stem[luls] == __V_n) 
    {                                           
        temp = luls;
        __DelStem1(stem, &temp);
        luls = temp;
        __RepStem1(stem, luls, __K_B);           
        if(FindIrrWord(stem, _IV_BM) & FINAL)  
        {            
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Irr_VERB_VALID;               
        }
        if(strcmp(stem, TemDop) == 0)          
        {        
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Irr_VERB_VALID;
        }
        if(FindIrrWord(stem, _RA_B) & FINAL)  
        {
            return INVALID;             
        }                 
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Irr_ADJ_VALID;
        }              
        if(NLP_Dap_Proc(stem) < INVALID)
        {
            return Irr_Dap_VALID;        
        }            
        return BT;
    }
    if(__IsDefStem(luls, 1) == 1 && 
        stem[luls-1] == __K_I && stem[luls] == __V_h) 
    {                                           
        temp = luls;
        __DelStem1(stem, &temp);
        luls = temp;
        __RepStem1(stem, luls, __K_B);           
        if(FindIrrWord(stem, _IV_BP) & FINAL) 
        {                                       
            if(strcmp(stem, TemDop) == 0)      
            {
                return INVALID;
            }                
            else
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;
            }                
        }
    }        
    return BT;
}
                    
//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Machine_A() 
//  Parameters      : char  *stem : 
//                    char  *ending :

//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Machine_A(  char  *stem, 
                                char  *ending) 
{
    char    tmp[80];                  
    int        temp, luls;

    lstrcpy (tmp, stem);
    luls = ULSPOS;

    temp = luls;
    __AddStem1(stem, &temp, __K_R);  
    luls = temp;
    
    if(ACT_N_V == 1)   
    {             
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Irr_VERB_VALID;
        }            
    }
    if(ACT_P_A == 1) 
    {               
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Irr_ADJ_VALID;
        }            
        __RepStem1(stem, luls, __K_H); 
        if(FindIrrWord(stem, _IA_HP) & FINAL ||    
            FindIrrWord(stem, _IA_HM) & FINAL)      
        {            
        if (LME == __K_B)
            return INVALID;
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Irr_ADJ_VALID;
        }            
    }
    return BT;
}

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Irr_KS() 
//  Parameters      : char  *stem : 
//                    char  *ending :

//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KS( char  *stem,
                            char  *ending) 
{
    char    tmp[80];                     
    int        temp, luls;

    if (ULS >= __V_k)
    {
        lstrcpy (tmp, stem);
        luls = ULSPOS;

        temp = luls;
        __AddStem1(stem, &temp, __K_R);           
        luls = temp;      
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Irr_VERB_VALID;
        }
    }
    return BT;
}

// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KM( char  *stem) 
{
    char    tmp[80];
    int        temp, luls;
                
    lstrcpy (tmp, stem);
    luls = ULSPOS;

     if(ACT_P_A == 1) 
    {
        temp = luls;
        __AddStem1(stem, &temp, __K_H);  
        luls = temp;
        if(FindIrrWord(stem, _IA_HP) & FINAL ||    
            FindIrrWord(stem, _IA_HM) & FINAL)      
        {            
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Irr_ADJ_VALID;
        }        
        return BT;
    }
    return INVALID;
}    
// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KRadj(  char  *stem,
                                char  *ending) 
{
    char    tmp[80];
    int        temp, luls;
                
    lstrcpy (tmp, stem);
    luls = ULSPOS;

    
    if(ending[LMEPOS-1] == __V_k)  
    {
            return BT;
    } 
    temp = luls;
    __AddStem1(stem, &temp, __K_H);      
    luls = temp;
 
    if(FindIrrWord(stem, _IA_HP) & FINAL   ||  
        FindIrrWord(stem, _IA_HM) & FINAL)      
    {        
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return Irr_ADJ_VALID;
    } 
    return BT;
}
// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KRvb(   char  *stem,
                                char  *ending) 
{
    char    tmp[80];  
    int        temp, luls;
                            
    lstrcpy (tmp, stem);
    luls = ULSPOS;

    if(ending[LMEPOS-1] == __V_j) 
    {                       
        if(ULS == __K_R) 
        {                   
            temp = luls;
            __AddStem1(stem, &temp, __V_m);  
            luls = temp;            
            if(FindIrrWord(stem, _IV_RmM) & FINAL)  
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;
            }                
            if(FindIrrWord(stem, _IA_RmM) & FINAL)   
            {                
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;           
            }                                                
            temp = luls;
            __DelStem1(stem, &temp);
            __AddStem2(stem, &temp, __K_R, __V_m);
            luls = temp;
            if(FindIrrWord(stem, _IV_OmM) & FINAL)  // (v8-)
            {   
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;
            }
            return BT;
        }
        if(FindIrrWord(stem, _IA_Rj) & FINAL)       
        {            
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Irr_ADJ_VALID;                                   
        }
    }
    else if(ending[LMEPOS-1] == __V_k) 
    {                       
        if(ULS == __K_R)
        {        
            if(__IsDefEnd(LMEPOS, 2) == 0 ||   
                (__IsDefEnd(LMEPOS, 3) == 1 && 
                ending[LMEPOS-3] == __V_h && ending[LMEPOS-2] == __K_D) ||
                (__IsDefEnd(LMEPOS, 3) == 1 && 
                ending[LMEPOS-3] == __V_i && ending[LMEPOS-2] == __K_I))
            {                
                temp = luls;
                __AddStem1(stem, &temp, __V_m);    
                luls = temp;
                if(FindIrrWord(stem, _IV_RmP) & FINAL)    
                {
                    char tstem [80];
                    Conv.INS2HAN (stem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_VERB;
                    return Irr_VERB_VALID;
                }                    
                if(FindIrrWord(stem, _IA_RmP) & FINAL)     
                {   
                    char tstem [80];
                    Conv.INS2HAN (stem, tstem, codeWanSeong);
                    lstrcat (lrgsz, tstem);
                    vbuf [wcount++] = POS_ADJECTIVE;
                    return Irr_ADJ_VALID;                 
                }
                return BT;
            }
        }                            
        if(__IsDefEnd(LMEPOS, 2) == 0 ||
            (__IsDefEnd(LMEPOS, 3) == 1 && 
            ending[LMEPOS-3] == __V_h && ending[LMEPOS-2] == __K_D))
        {            
            return SS;
        }            
    }
    return BT;
}                                    
// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KI_KR(  char  *stem,
                                char  *ending) 
{
    char    tmp[80];
    int        luls;
                
    lstrcpy (tmp, stem);
    luls = ULSPOS;

    
    if(ACT_N_V == 1) 
    {
        __RepStem1(stem, ULSPOS, __K_D);     
                                            
        if(ending[LMEPOS-1] == __V_j) 
        {                                   
            if(FindIrrWord(stem, _IV_DM) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;      
            }
            return BT;
        }            
        if(ending[LMEPOS-1] == __V_k) 
        {                                   
            if(FindIrrWord(stem, _IV_DP) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;                           
            }
            return BT;
        }
        if(FindIrrWord(stem, _IV_DP) & FINAL ||    
            FindIrrWord(stem, _IV_DM) & FINAL)      
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Irr_VERB_VALID;
        } 
    }        
    return BT;
}
// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KI_V(   char  *stem,
                                char  *ending) 
{
    char    tmp[80];
    int        temp, luls;
    
    lstrcpy (tmp, stem);
    luls = ULSPOS;

    
    if(ACT_N_V == 1) 
    {
        temp = luls;
        __AddStem1(stem, &temp, __K_S);       
        luls = temp;        
        if(ending[LMEPOS-1] == __V_j) 
        {                                   
            if(FindIrrWord(stem, _IV_SM) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;       
            }                
            return BT;
        }            
        if(ending[LMEPOS-1] == __V_k) 
        {                                   
            if(FindIrrWord(stem, _IV_SP) & FINAL) 
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;       
            }
            temp = luls;
            __DelStem1(stem, &temp);
            __AddStem2(stem, &temp, __K_I, __V_m);
            luls = temp;                 
            if(FindIrrWord(stem, _IV_OmP) & FINAL)  
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return Irr_VERB_VALID;       //v8+
            }
            return BT;
        }
        if(FindIrrWord(stem, _IV_SP) & FINAL ||     
            FindIrrWord(stem, _IV_SM) & FINAL)       
        {            
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return Irr_VERB_VALID;
        }            
    }
    if(__IsDefEnd(LMEPOS, 1) == 1 && ending[LMEPOS-1] == __V_m)    
    {
        if(strcmp(stem, TempNa) == 0)      
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return Irr_ADJ_VALID;
        }
    }
    return BT;
}
// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Irr_OPS() 
//  Parameters      : char  *stem : 
//                    char  *ending :
//  Summary         :
//  Call Functions  : 
//  Description     :   
//  Return Value    :
//                             
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_OPS(char  *stem,
                            char  *ending) 
{
    char    tmp[80];
    int     res, luls;            
                
    lstrcpy (tmp, stem);
    luls = ULSPOS; 

    if(__IsDefEnd(LMEPOS, 3) == 0)     // nx3 == null
    {                           
        if(__IsDefStem(luls, 3) == 1 && 
            stem[luls] == __K_S && stem[luls-1] == __K_B &&
            stem[luls-2] == __V_j && stem[luls-3] == __K_I )  
        {       
            if(FindIrrWord(stem, _YOP) & FINAL)  
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }                         
        }                
        if(__IsDefStem(luls, 2) == 1 && 
            stem[luls] == __K_S_D && stem[luls-1] == __V_l && stem[luls-2] == __K_I ) 
        {            
            if(FindIrrWord(stem, _ISS) & FINAL) 
            {                                  
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }
            if((res = NLP_AUX_Find(stem, 1)) < INVALID)
            {                                   
                return res + Irr_AUX;
            }              
        }
        if(__IsDefStem(luls, 1) == 1 && ULS == __V_o && stem[luls-1] == __K_H)  
        {            
            return INVALID;
        }    
        if(ULS == __V_hk || ULS == __V_ho)      
        {
            return INVALID;
        }   
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            return INVALID;
        }  
        return SS;
    }                                           
    if(ending[LMEPOS-3] >= __V_k ||            
        ending[LMEPOS-3] == __K_J ||            
        ending[LMEPOS-3] == __K_B ||            
        (__IsDefEnd(LMEPOS, 4) == 1 &&
        ending[LMEPOS-3] == __K_D  && ending[LMEPOS-4] == __V_p) || 
        (__IsDefEnd(LMEPOS, 3) == 1 && 
        ending[LMEPOS-3] == __K_G))             
    {

        if(__IsDefStem(luls, 3) == 1 && 
            stem[luls] == __K_S && stem[luls-1] == __K_B &&
            stem[luls-2] == __V_j && stem[luls-3] == __K_I )   
        {       
            if(FindIrrWord(stem, _YOP) & FINAL) 
            {   
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }             
        }                
//        if(__IsDefStem(luls, 3) == 1 && 
        if(__IsDefStem(luls, 2) == 1 && 
            stem[luls] == __K_S_D && stem[luls-1] == __V_l && stem[luls-2] == __K_I ) 
        {            
            if(FindIrrWord(stem, _ISS) & FINAL) 
            {                                  
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return Irr_ADJ_VALID;
            }
            if((res = NLP_AUX_Find(stem, 1)) < INVALID)
            {                                   
                return res + Irr_AUX;
            }                   
        }
    }
    return BT;
}                         

//----------------------------------------------------------------------------------------------
//
//  Function Name   : NLP_Irr_KI() 
//  Parameters      : char  *stem : 
//                    char  *ending :
//  Summary         : IEUNG Irregular
//  Call Functions  : 
//  Description     :   
//  Return Value    :
//
//----------------------------------------------------------------------------------------------
int BaseEngine::NLP_Irr_KI(char  *stem, 
                           char  *ending)
{
    char    tmp[80], tmpstem [80], tmpending [40];                  
    int     res, temp, luls;

    lstrcpy (tmp, stem);
    luls = ULSPOS;

    temp = luls;
    __AddStem1(stem, &temp, __K_R);  // add "RIEUL" to stem
    luls = temp;
    
    if(ACT_N_V == 1)   
    {               
        Conv.INS2HAN (stem, tmpstem, codeWanSeong);
        if (FindSilsaWord (tmpstem) & _VERB) 
        {
            lstrcat (lrgsz, tmpstem);
            vbuf [wcount++] = POS_VERB;
            lstrcat (lrgsz, "+");
            Conv.INR2HAN (ending, tmpending, codeWanSeong);
            lstrcat (lrgsz, tmpending);
            vbuf [wcount++] = POS_ENDING;
            lstrcat (lrgsz, "\t");
            return Irr_VERB_VALID;
        }            
    }
    if(ACT_P_A == 1) 
    {               
        Conv.INS2HAN (stem, tmpstem, codeWanSeong);
        if (FindSilsaWord (tmpstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tmpstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            lstrcat (lrgsz, "+");
            Conv.INR2HAN (ending, tmpending, codeWanSeong);
            lstrcat (lrgsz, tmpending);
            vbuf [wcount++] = POS_ENDING;
            lstrcat (lrgsz, "\t");
            return Irr_ADJ_VALID;
        }            
        __RepStem1(stem, luls, __K_H); // "RIEUL" > "HIEUH"
        if(FindIrrWord(stem, _IA_HP) & FINAL ||    // HIEUH irregular positive & _ADJECTIVE (A5+)
            FindIrrWord(stem, _IA_HM) & FINAL)     // HIEUH irregular negative & _ADJECTIVE (A5-)
        {            
            Conv.INS2HAN (stem, tmpstem, codeWanSeong);
            lstrcat (lrgsz, tmpstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            lstrcat (lrgsz, "+");
            Conv.INR2HAN (ending, tmpending, codeWanSeong);
            lstrcat (lrgsz, tmpending);
            vbuf [wcount++] = POS_ENDING;
            lstrcat (lrgsz, "\t");
            return Irr_ADJ_VALID;
        }            
    }        
    if(ACT_N_V == 1)   
    {               
        if((res = NLP_AUX_Find(stem, 0)) < INVALID)
        {
            lstrcat (lrgsz, "+");
            Conv.INR2HAN (ending, tmpending, codeWanSeong);
            lstrcat (lrgsz, tmpending);
            vbuf [wcount++] = POS_ENDING;
            lstrcat (lrgsz, "\t");
            return res + Irr_AUX;
        }    
    }            
    return BT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\baseirr.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#include <string.h>
#include "basecore.hpp"

static char INRBuf[5][10] = 
        {                            
               {__K_J,  __V_k, __K_C, __V_j, __K_I, __V_n, __K_R,     0, 0, 6}, 
               {__K_G,  __V_j, __K_M, __K_G, __V_l, __K_I, __V_n, __K_R, 0, 7}, 
               {__K_G, __V_nl, __K_I, __V_n, __K_R,     0,     0,     0, 0, 4}, 
               {__K_I,  __V_l, __K_I, __V_n, __K_R,     0,     0,     0, 0, 4}, 
               {__K_I,  __V_n, __K_R,     0,     0,     0,     0,     0, 0, 2}  
        };
static char INRBuf2[4][7] = 
        {
               {__K_G,   __V_l, __K_I, __V_n, __K_R, 0, 4}, 
               {__K_G_D, __V_l, __K_I, __V_n, __K_R, 0, 4}, 
               {__K_G,   __V_i, __K_I, __V_n, __K_R, 0, 4}, 
               {__K_G_D, __V_i, __K_I, __V_n, __K_R, 0, 4}  
        };
char    TemDop[] = {__K_D, __V_h, __K_B, 0}; 

char    TempNa[] = {__K_N, __V_k, 0};        

// hjw : 95/3/7                                                    
char TempNjRk[] = {__V_k, __K_R, __V_j, __K_N, 0};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basemain.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#include <stdlib.h>
#include <string.h>
#include <io.h>
#include "basecore.hpp"
#include "basegbl.hpp"

#define TOSSI   1
#define END     0
#define SPACE   0x20

int NLP_Ge_Proc( char far *);

char    TempIkNl[] = {__K_I, __V_k, __K_N, __V_l, 0};        

char    TempJap[3][7] = 
        {
            {__K_J, __V_p, __K_G, __V_u, __K_I, __V_l, 0}, 
            {__K_I, __V_u, __K_N, __K_I, __V_l,     0, 0}, 
            {__K_I, __V_l,     0,     0,     0,     0, 0}  
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basesub.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#include <stdlib.h>
#include <string.h>
#include <io.h>
#include "basecore.hpp"

char    TempNoun[3][3] = 
        {
            {__K_N, __V_p, 0}, 
            {__K_J, __V_p, 0}, 
            {__K_N, __V_o, 0}  
        };
           

char TempNumNoun[] =
{
        __K_H,  __V_k, __K_G,   __K_N, __V_u, __K_N, 0, 5,   
        __K_I,  __V_u, __K_N,   __K_D, __V_o,     0, 0, 4,   
        __K_N,  __V_u, __K_N,   __K_D, __V_o,     0, 0, 4,   
        __K_J,  __V_n, __K_I,   __K_D, __V_o,     0, 0, 4,   
        __K_B,  __V_n, __K_N,   __K_D, __V_o,     0, 0, 4,   
        __K_S,  __V_h, __K_D,   __V_o,     0,     0, 0, 3,   
        __K_D,  __V_o, __K_D,   __V_o,     0,     0, 0, 3,   
        __K_S,  __V_k, __K_D,   __V_k, __K_N,     0, 0, 4,   
        __K_G,  __V_n, __K_N,   __K_D, __V_k, __K_N, 0, 5,   
        __K_I,  __V_u, __K_D,   __V_k, __K_N,     0, 0, 4,   
        __K_N,  __V_u, __K_N,       0,     0,     0, 0, 2,   
        __K_G,  __V_o, __K_I,  __V_nj, __K_R,     0, 0, 4,   
        __K_I, __V_nj, __K_R,       0,     0,     0, 0, 2,   
        __K_I, __V_nj, __K_N,       0,     0,     0, 0, 2,   
        __K_I,  __V_l, __K_R,       0,     0,     0, 0, 2,   
        __K_B,  __V_n, __K_N,       0,     0,     0, 0, 2,   

        __K_N,  __V_u, __K_N, __K_J_D, __V_o,     0, 0, 4,   
        __K_I,  __V_l, __K_R, __K_J_D, __V_o,     0, 0, 4,   

        __K_J,  __V_n, __K_J_D, __V_o,     0,     0, 0, 4,   

        __K_B,  __V_j, __K_N,       0,     0,     0, 0, 2,   
        __K_B,  __V_k, __K_N,       0,     0,     0, 0, 2,   
        __K_D,  __V_k, __K_N,       0,     0,     0, 0, 2,   
        __K_G,  __V_m, __K_B,       0,     0,     0, 0, 2,   
        __K_C,  __V_m, __K_I,       0,     0,     0, 0, 2,   
        __K_H,  __V_k, __K_I,       0,     0,     0, 0, 2,   
        __K_J,  __V_k, __K_I,       0,     0,     0, 0, 2,   
        __K_P,  __V_u, __K_N,       0,     0,     0, 0, 2,   
        __K_C,  __V_h,     0,       0,     0,     0, 0, 1,   
        __K_S,  __V_l,     0,       0,     0,     0, 0, 1,   
        __K_D,  __V_o,     0,       0,     0,     0, 0, 1,   
        __K_H, __V_hl,     0,       0,     0,     0, 0, 1,   
        __K_G, __V_hk,     0,       0,     0,     0, 0, 1    
};      

char TempJumpNum[] =
{
        __K_G,__V_u,__K_I, 0, 2,     
        __K_M,__V_k,__K_N, 0, 2,     
        __K_I,__V_j,__K_G, 0, 2,     
        __K_J,__V_h,    0, 0, 1,     
        __K_H,__V_o,    0, 0, 1      
    };

char TempSujaNum[] =
{
        __K_I, __V_l, __K_R,     0,     0,     0, 0, 2,     
        __K_I, __V_l,     0,     0,     0,     0, 0, 1,     
        __K_S, __V_k, __K_M,     0,     0,     0, 0, 2,     
        __K_S, __V_k,     0,     0,     0,     0, 0, 1,     
        __K_I, __V_h,     0,     0,     0,     0, 0, 1,     
        __K_I, __V_b, __K_G,     0,     0,     0, 0, 2,     
        __K_C, __V_l, __K_R,     0,     0,     0, 0, 2,     
        __K_P, __V_k, __K_R,     0,     0,     0, 0, 2,     
        __K_G, __V_n,     0,     0,     0,     0, 0, 1,     
        __K_H, __V_k, __K_N, __V_k,     0,     0, 0, 3,     
        __K_D, __V_n, __K_R,     0,     0,     0, 0, 2,     
        __K_S, __V_p, __K_S,     0,     0,     0, 0, 2,     
        __K_N, __V_p, __K_S,     0,     0,     0, 0, 2,     
        __K_D, __V_k, __K_S, __V_j, __K_S,     0, 0, 4,     
        __K_I, __V_u, __K_S, __V_j, __K_S,     0, 0, 4,     
        __K_I, __V_l, __K_R, __K_G, __V_h, __K_B, 0, 5,     
        __K_I, __V_u, __K_D, __V_j, __K_R, __K_B, 0, 5,     
        __K_I, __V_k, __K_H, __V_h, __K_B,     0, 0, 4,     
        __K_I, __V_u, __K_R,     0,     0,     0, 0, 2,     
        __K_S, __V_m, __K_M, __V_n, __K_R,     0, 0, 4,     
        __K_S, __V_j, __K_R, __V_m, __K_N,     0, 0, 4,     
        __K_M, __V_k, __K_H, __V_m, __K_N,     0, 0, 4,     
        __K_S, __V_nl, __K_N,    0,     0,     0, 0, 2,     
        __K_I, __V_P, __K_S, __V_n, __K_N,     0, 0, 4,     
        __K_I, __V_l, __K_R, __K_H, __V_m, __K_N, 0, 5,     
        __K_I, __V_u, __K_D, __V_m, __K_N,     0, 0, 4,     
        __K_I, __V_k, __K_H, __V_m, __K_N,     0, 0, 4      
};
char TempBaseNum[] =
{
        __K_S,__V_l,__K_B, 0, 2,     
        __K_B,__V_o,__K_G, 0, 2,     
        __K_C,__V_j,__K_N, 0, 2      
};

static char DoubleNum[8][7] =
{
        { __K_I,__V_l,__K_R,__K_I,__V_l,    0, 0 },   
        { __K_I,__V_l,__K_S,__V_k,__K_M,    0, 0 },   
        { __K_S,__V_k,__K_M,__K_S,__V_k,    0, 0 },   
        { __K_S,__V_k,__K_I,__V_h,    0,    0, 0 },   
        { __K_I,__V_h,__K_I,__V_b,__K_G,    0, 0 },   
        { __K_I,__V_b,__K_G,__K_C,__V_l,__K_R, 0 },   
        { __K_C,__V_l,__K_R,__K_P,__V_k,__K_R, 0 },   
        { __K_P,__V_k,__K_R,__K_G,__V_n,    0, 0 }    
};

static char TempPrefix[] = {
                  __K_D, __V_o,     0, 0, 1,  
                  __K_B, __V_l,     0, 0, 1,  
                  __K_S, __V_l, __K_N, 0, 2,  
                  __K_J, __V_o,     0, 0, 1,  
                  __K_J, __V_n,     0, 0, 1,  
                  __K_C, __V_h, __K_I, 0, 2,  
                  __K_H, __V_u, __K_N, 0, 2,  
                  __K_J, __V_j, __K_N, 0, 2,  
                  __K_P, __V_l,     0, 0, 1   
}; 

char TempSuffixOut[] = {
 __K_D,   __V_m, __K_R, __K_G,   __V_k, __K_N, 0, 5,  
 __K_D,   __V_m, __K_R, __K_I,   __V_y, __K_I, 0, 5,  
 __K_D,   __V_m, __K_R, __K_S_D, __V_l, __K_G, 0, 5,  

 __K_D,   __V_m, __K_R, __K_J_D, __V_m, __K_M, 0, 5,  

 __K_G,   __V_k, __K_N,       0,     0,     0, 0, 2,  
 __K_I,   __V_y, __K_I,       0,     0,     0, 0, 2,  
 __K_S_D, __V_l, __K_G,       0,     0,     0, 0, 2,  

 __K_J_D, __V_m, __K_M,       0,     0,     0, 0, 2   

};

LenDict JumpNum;
LenDict SujaNum;
LenDict BaseNum;
//LenDict NumNoun(TempNumNoun, 8, 35);
LenDict NumNoun;
LenDict Suffix;

int PrefixCheck(char *, char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basess.cpp ===
// =========================================================================
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// FILE NAME        : BASESS.CPP
// Function         : BASE ENGINE FUNCTION COLLECTION (SS PROCESS)
//                  : NLP Base Engine Function
// =========================================================================

#include "basecore.hpp"
#include "basegbl.hpp"
#include "MainDict.h"

char    TempIlRm[] = {__K_I, __V_l, __K_R, __V_m, 0}; 

// ----------------------------------------------------------------------
//
//  SSANGSIOS : Main
//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Proc(char  *stem,
                            char  *ending) 
{
    char    tmp[80];
    int     luls;
            
    luls = ULSPOS;
    lstrcpy(tmp,stem);

    switch (ULS)
    {
        // We may not use this routine after testing.
    /*
        case __V_l :        // "I"
            return NLP_SS_Vl(stem, ending); */
        case __V_u :        // "YEO"                    
            if(__IsDefStem(ULSPOS, 1) == 1 && stem[ULSPOS-1] == __K_I) // PLS="IEUNG" :stem=..."YEO" 
            {                                       
                return NLP_SS_Vu_mrg(stem, ending);
            }
            else
            {
                return NLP_SS_Vu_irr(stem, ending);
            }                
        case __V_nj :       //  "WEO"
            return NLP_SS_Vnj(stem, ending); 
        case __V_hk :       // "WA"
            return NLP_SS_Vhk(stem, ending);  
        case __V_ho :       // "WAE"
            return NLP_SS_Vho(stem, ending);
        case __V_o :        // "AE"
            if(__IsDefStem(ULSPOS, 1) == 1 && stem[ULSPOS-1] == __K_H) // PLS="HIEUH" 
            {
                return NLP_SS_Vo_KH(stem, ending);                        
            }    
            else    
            {
                return NLP_SS_Vo(stem, ending);
            }                
        case __V_p :        // "E"
            return NLP_SS_Vp(stem);
        case __V_O :        // "YAE"
            return NLP_SS_Vil(stem);
        case __V_P :        // "YE"
            return NLP_SS_Vul(stem);
        case __V_j :        // "EO"
            if(__IsDefStem(ULSPOS, 1) == 1 && stem[ULSPOS-1] == __K_R) // PLS="RIEUR" 
            {
                return NLP_SS_Vj_KR(stem);
            }                
            else    
            {
                return NLP_SS_Vj(stem);                       
            }                
        case __V_k :        // "A"
            return NLP_SS_Vk(stem, ending);
        case __V_np :       // "WE"
            if(__IsDefStem(ULSPOS, 1) == 1 && __IsDefStem(ULSPOS, 2) == 0 &&
                stem[ULSPOS-1] == __K_G_D) // PLS=SSANGKIYEOK
            {                
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_VERB;
                return SS_VERB_VALID;
            }
            return INVALID;
        default :   return BT;
    }
}    
/*
// ----------------------------------------------------------------------
//
//  SSANGSIOS : vowel "I"
//
// ----------------------------------------------------------------------  
int BaseEngine::NLP_SS_Vl(char  *stem,
                          char  *ending) 
{
    char    dummyl[1], 
            temp[1], 
            rULSPOS;                     
    int     res;
                
    rULSPOS = ULSPOS;
    
    if(__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_I ) // PLS="I"
    {                                                           
        if(__IsDefEnd(LMEPOS, 0) == 1 && ending[LMEPOS] == __K_S_D)  // LME = SSANGSIOS
        {                                                       
            temp[0] = rULSPOS;
            __AddStem1(stem, temp, __K_S_D);                 // Add SSANGSIOS to predicate
            rULSPOS = temp[0];                
            
            if(FindIrrWord(stem, _ISS) & FINAL)
            {
                char tstem [80];
                Conv.INS2HAN (stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_ADJECTIVE;
                return SS_ADJ_VALID;
            }                       
            if((res = NLP_AUX_Find(stem, 1)) < INVALID)    // Adjective
            {
                return res + SS_AUX;
            }                
        }
        return INVALID;          
    }
    return BT;
}
*/
// ----------------------------------------------------------------------
//
//  SSANGSIOS : vowel "U" (Contraction)
//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vu_mrg(char  *stem,
                              char  *ending) 
{
    int     res, temp, rULSPOS;
                
    rULSPOS = ULSPOS;
    
    if(__IsDefStem(rULSPOS, 3) == 1 && 
        stem[rULSPOS-3] == __K_H && stem[rULSPOS-2] == __V_k ) //.ALS == 'HA'
    {        
        temp = rULSPOS;
        __DelStem2(stem, &temp);                                  // remove 'YEO'
        rULSPOS = temp;
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;
        }            
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }                          
        if((res = NLP_Manha_Proc(stem)) < INVALID)    
        {
            if(res == Manha_VALID)
            {
                return SS_Manha_VALID;
            }
            else if(res == Yenha_VALID)
            {
                return SS_Yenha_VALID;
            }                                                                                                           
        }
        else if(NLP_Cikha_Proc(stem) < INVALID)
        {
            return SS_Cikha_VALID;
        }    
        if((res = NLP_AUX_Find(stem, 0)) < INVALID)    // auxiliary verb
        {
            return res +  SS_AUX;             
        }            
        if((res = NLP_AUX_Find(stem, 1)) < INVALID)    // auxiliary adjective
        {
            return res + SS_AUX;
        }              
        return BT;
    }                
    __RepStem1(stem, rULSPOS, __V_l);                            // "YEO" > "I"
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }        
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _ADJECTIVE) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }    
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)
    {
        return res + SS_AUX;
    }       
    if(ACT_N_E == 1)
    {
        if(stem[rULSPOS-2] >= __V_k)   
        {                  
            temp = rULSPOS;
            __DelStem2(stem, &temp);  // remvoe "I"
            rULSPOS = temp;                            
            if((res = NLP_Machine_T(stem, ending)) < INVALID)    
            {
                return res + SS_T;                       
            } 
        }
    }    
    return BT;
}

// ----------------------------------------------------------------------
//
//  SSANGSIOS : vowel "YEO" (YEO irregular)
//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vu_irr(char  *stem,
                              char  *ending) 
{
    int     res, rULSPOS;
            
    rULSPOS = ULSPOS;
    
    if(FindIrrWord(stem, _ZUV_YO) & FINAL)  
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;                                     
    }
    __RepStem1(stem, rULSPOS, __V_l);                        
    
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;   
    }
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _ADJECTIVE) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;    
    }                     
    if(NLP_Manhaeci_Proc(stem) < INVALID)    
    {   
        return SS_Manhaeci_VALID;                    
    }                      
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)  
    {
        return res + SS_AUX;                        
    }    
    if((res = NLP_AUX_Find(stem, 1)) < INVALID)  
    {
        return res + SS_AUX;
    }        
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vnj(char  *stem,
                           char  *ending) 
{
    int     res, temp, rULSPOS;
            
    rULSPOS = ULSPOS;

    __RepStem1(stem, rULSPOS, __V_n);        
    
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }         
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)
    {
        return res + SS_AUX;
    }     
    if(__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_I) 
    {                                                               
        temp = rULSPOS;
        __DelStem1(stem, &temp);
        rULSPOS = temp;
        __RepStem1(stem, rULSPOS, __K_B);                        
        if(FindIrrWord(stem, _IV_BM) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;
        }
        if(FindIrrWord(stem, _RA_B) & FINAL)    
        {
            return INVALID;
        }
        if(FindIrrWord(stem, _IA_BP) & FINAL)   
        {
            return INVALID;
        }
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }
        if(NLP_Dap_Proc(stem) < INVALID) 
        {
            return SS_Dap_VALID;
        }    
    }
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vhk(char  *stem,
                           char  *ending) 
{
    int     res, temp, rULSPOS;
            
    rULSPOS = ULSPOS;

    __RepStem1(stem, ULSPOS, __V_h);                 
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }    
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)
    {
        return res + SS_AUX;
    }
    if(__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_I) 
    {                                                   
        temp = rULSPOS;
        __DelStem1(stem, &temp);
        rULSPOS = temp;
        __RepStem1(stem, rULSPOS, __K_B);            
        if(FindIrrWord(stem, _IV_BP) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;                                  
        }
        if(FindIrrWord(stem, _IA_BP) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;                                   
        }       
    }
    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vho(char  *stem,
                           char  *ending) 
{
    int     res, rULSPOS;
            
    rULSPOS = ULSPOS;

    __RepStem1(stem, rULSPOS, __V_hl);           
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }                                                     
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _ADJECTIVE) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }      
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)     
    {
        return res + SS_AUX;
    }      
    return BT;
}       

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vo_KH(char  *stem,
                             char  *ending) 
{
    int     res, rULSPOS;
            
    rULSPOS = ULSPOS;

    __RepStem1(stem, rULSPOS, __V_k);            
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }             
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _ADJECTIVE) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }             
    if((res = NLP_Manha_Proc(stem)) < INVALID)
    {
        if(res == Manha_VALID)    
        {
            return SS_Manha_VALID;
        }   
        else if(res == Yenha_VALID)
        {
            return SS_Yenha_VALID;
        }                        
    }        
    else if(NLP_Cikha_Proc(stem) < INVALID)    
    {
        return SS_Cikha_VALID;
    }       
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)     
    {
        return res + SS_AUX;
    }
    if((res = NLP_AUX_Find(stem, 1)) != MORECHECK)    
    {
        return res + SS_AUX;
    }                                         
    return BT;
}                                             

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vo(char  *stem,
                          char  *ending) 
{
    int     res, temp, rULSPOS;
            
    rULSPOS = ULSPOS;
    char tstem [80];
    Conv.INS2HAN (stem, tstem, codeWanSeong);
    if (FindSilsaWord (tstem) & _VERB) 
    {
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }                                                                       
    if(FindIrrWord(stem, _ZUA_AE) & FINAL)  
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)     
    {
        return res + SS_AUX;
    }
    __RepStem1(stem, rULSPOS, __V_k);    
    temp = rULSPOS;
    __AddStem1(stem, &temp, __K_H);                           
    rULSPOS = temp;    
    if(FindIrrWord(stem, _IA_HP) & FINAL)   
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;                                       
    }                
    __RepStem2(stem, rULSPOS, __V_j, __K_H);                 
    if(FindIrrWord(stem, _IA_HM) & FINAL)   
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;                                       
    }                
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vp(  char  *stem) 
{
    int     temp, rULSPOS;
    
    rULSPOS = ULSPOS;

    if(FindIrrWord(stem, _ZUV_E) & FINAL)   
    {                                                           
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;                                       
    }            
    if(FindIrrWord(stem, _ZUA_E) & FINAL)   
    {                                                        
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;                                                            
    }                
    __RepStem1(stem, rULSPOS, __V_j);    
    temp = rULSPOS;
    __AddStem1(stem, &temp, __K_H);                           
    rULSPOS = temp;
    if(FindIrrWord(stem, _IA_HM) & FINAL)   
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vil( char  *stem) 
{
    int        temp, rULSPOS;
    
    rULSPOS = ULSPOS;

    if(__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_I) 
    {                                                               
        __RepStem1(stem, rULSPOS, __V_i);         
        temp = rULSPOS;
        __AddStem1(stem, &temp, __K_H);                           
        rULSPOS = temp;
        if(FindIrrWord(stem, _IA_HP) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }
        __RepStem2(stem, rULSPOS, __V_u, __K_H);                 
        if(FindIrrWord(stem, _IA_HM) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }
    }
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vul( char  *stem) 
{
    int     temp, rULSPOS;
    
    rULSPOS = ULSPOS;

    if(__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_I) 
    {                                                               
        __RepStem1(stem, rULSPOS, __V_u);
        temp = rULSPOS;
        __AddStem1(stem, &temp, __K_H);                           
        rULSPOS = temp;                  
        if(FindIrrWord(stem, _IA_HM) & FINAL)   
        {                                                        
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;                                      
        }            
    }    
    return BT;
}   

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vj_KR( char  *stem) 
{
    int     temp, rULSPOS;
    
    rULSPOS = ULSPOS;

    temp = rULSPOS;
    __DelStem2(stem, &temp);                                      
    rULSPOS = temp;

    if(__IsDefStem(rULSPOS, 1) == 1 && 
        stem[rULSPOS-1] == __K_R && stem[rULSPOS] == __V_m)   
    {                                                               
        if(strcmp(stem, TempIlRm) == 0)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;
        }
        if(FindIrrWord(stem, _IA_Rj) & FINAL)   
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }    
        return BT;        
    }
    if(stem[rULSPOS] == __K_R) 
    {                                           
        temp = rULSPOS;
        __AddStem1(stem, &temp, __V_m);         
        rULSPOS = temp;
        if(FindIrrWord(stem, _IV_RmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;
        }
        if(FindIrrWord(stem, _IA_RmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }                         
        temp = rULSPOS;
        __DelStem1(stem, &temp);                
        __AddStem2(stem, &temp, __K_R, __V_m);  
        rULSPOS = temp;
        if(FindIrrWord(stem, _IV_OmM) & FINAL)  
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;
        } 
        return BT;
    }
    temp = rULSPOS;
    __AddStem2(stem, &temp, __K_R, __V_m);      
    rULSPOS = temp;                    
    if(FindIrrWord(stem, _IV_OmM) & FINAL)      //v8-
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }                
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vj( char  *stem) 
{
    int     rULSPOS;
    char    PHieph_U[3]={'\xC7', '\xAA',0}; 
    
    rULSPOS = ULSPOS;

    if(__IsDefStem(rULSPOS, 1) == 1 && __IsDefStem(rULSPOS, 2) == 0 && 
        stem[rULSPOS-1] == __K_P && stem[rULSPOS] == __V_j)   
    {        
        lstrcat (lrgsz,PHieph_U);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }                
    if(FindIrrWord(stem, _ZUV_O) & FINAL)       
    {   
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;                                       
    }
    __RepStem1(stem, rULSPOS, __V_m);                            
    if(FindIrrWord(stem, _IV_OmM) & FINAL)      
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }
    if(FindIrrWord(stem, _IA_OmM) & FINAL)      
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }
    return BT;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_SS_Vk(  char  *stem,
                            char  *ending) 
{
    int     res, temp, rULSPOS;
            
    rULSPOS = ULSPOS;
    
    if(FindIrrWord(stem, _ZUV_A) & FINAL)  
    {                                               
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;                                 
    }       
    if(__IsDefStem(rULSPOS, 1) == 1 && stem[rULSPOS-1] == __K_H)    
    {
        return BT;
    }                
    if(FindIrrWord(stem, _ZUA_A) & FINAL)  
    {                                               
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;                               
    }
    if((res = NLP_AUX_Find(stem, 0)) < INVALID)
    {
        return res + SS_AUX;
    }       
    if(__IsDefStem(rULSPOS, 2) == 1 &&
        stem[rULSPOS-1] == __K_R &&      
        stem[rULSPOS-2] == __K_R)        
    {                                                         
        temp = rULSPOS;
        __DelStem2(stem, &temp);                          
        __AddStem1(stem, &temp, __V_m);                   
        rULSPOS = temp;
        if(FindIrrWord(stem, _IV_RmP) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            return SS_VERB_VALID;
        }
        if(FindIrrWord(stem, _IA_RmP) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (stem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_ADJECTIVE;
            return SS_ADJ_VALID;
        }            
        return BT;
    }
    __RepStem1(stem, rULSPOS, __V_m);                        
    if(FindIrrWord(stem, _IV_OmP) & FINAL)  
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_VERB;
        return SS_VERB_VALID;
    }            
    if(FindIrrWord(stem, _IA_OmP) & FINAL)  
    {
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_ADJECTIVE;
        return SS_ADJ_VALID;
    }                    
    if(NLP_Gop_Proc(stem) < INVALID) 
    {
        return SS_Gop_VALID;
    }  
    return BT;     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basegbl.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

// GLOBAL  VARIABLES

const int  _IA_BP   = 0,  // a3+     PIEUP irregular light adjective
           _RA_B    = 1,  // a3r     PIEUP irregular dark adjective
           _IA_HP   = 2,  // a5+     HIEUP irregular light adjective
           _IA_HM   = 3,  // a5-     HIEUP irregular dark adjective
           _IA_RmP  = 4,  // a6+     REU irregular light adjective
           _IA_RmM  = 5,  // a6-     REU irregular dark adjective
           _IA_Rj   = 6,  // a7      REO irregular adjective
           _IA_OmP  = 7,  // a8+     EU irregular light adjective
           _IA_OmM  = 8,  // a8-     EU irregular dark adjective
           _ISS     = 9,  // iss     '..ISS'predicate
           _IV_Gj   = 10, // v0      GEORA irregular verb
           _IV_Nj   = 11, // v1      NEORA irregular verb
           _IV_DP   = 12, // v2+     TIEUT irregular light verb
           _IV_DM   = 13, // v2-     TIEUT irregular dark verb
           _RV_D    = 14, // v2r     TIEUT regular verb
           _IV_BP   = 15, // v3+     PIEUP irregular light verb
           _IV_BM   = 16, // v3-     PIEUP irregular dark verb
           _IV_SP   = 17, // v4+     SIOS irregular light verb
           _IV_SM   = 18, // v4-     SIOS irregular dark verb
           _IV_RmP  = 19, // v6+     REU irregular light verb
           _IV_RmM  = 20, // v6-     REU irregular dark verb
           _IV_Rj   = 21, // v7      REO irregular verb
           _IV_OmP  = 22, // v8+     EU irregular light verb
           _IV_OmM  = 23, // v8-     EU irregular dark verb
           _YOP     = 24, // yop     '..YEOBS'predicate
           _ZPN     = 25, // zpn     pronoun (irregular dictionary)
           _ZUA_A   = 26, // zua_a   '...A'form adjective dictionary
           _ZUA_AE  = 27, // zua_ae  '...AE'form adjective dictionary
           _ZUA_E   = 28, // zua_e   '...E'form adjective dictionary
           _ZUV_A   = 29, // zuv_a   '...A'form verb dictionary
           _ZUV_E   = 30, // zuv_e   '...E'form verb dictionary
           _ZUV_O   = 31, // zuv_o   '...A'form verb dictionary
           _ZUV_YO  = 32, // zuv_yo  '...YEO'form verb dictionary
           _ZZNUM   = 33, 
           _ZZUV_CH = 34, // '...CHI' form verb dictionary
           _ZZUA_CH = 35; // '...CHI' form adjective dictionary
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basemain.cpp ===
// =========================================================================
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// File Name : BASEMAIN.CPP
// Function  : BASE ENGINE Handler
//           : NLP Base Engine
// =========================================================================
#include "basemain.hpp"
#include "convert.hpp"
#include "MainDict.h"




/*---------------------------------------------------------------------------
        %%Function : GetStemEnding
        %%Contact : dhyu

 ---------------------------------------------------------------------------*/
void BaseEngine::GetStemEnding (char *incode, char *stem, char *ending, int position)
{
    int codelen = lstrlen (incode) - 1;

    LMEPOS = position;
    lstrcpy (stem, incode);

    if (LMEPOS == -1)
    {
        ULSPOS = codelen;
        ending [0] = NULLCHAR;
    }
    else
    {
        if (LMEPOS == codelen)
        {
            ULSPOS = -1;
            stem [0] = NULLCHAR;
        }
        else
        {
            ULSPOS = lstrlen(incode) - LMEPOS - 2;
            stem[ULSPOS+1] = NULLCHAR;
        }
        // ending have a reverse order.
        for (int k = 0, j = lstrlen(incode) - 1; k <= LMEPOS; j--, k++)
            ending [k] = incode [j];
        ending [k] = NULLCHAR;
    }

}

int BaseEngine::NLP_BASE_NOUN (LPCSTR    d, char *rstrings)
{
   char     Act[10], ostem[80], 
            oending[40], incode [100], stem [100], ending [40];
                
    int     bt, sp[10];
    
    CODECONVERT Conv;
    wcount = 0;

    memset(incode, NULLCHAR, 100);
    memset(Act, NULLCHAR, 10);
    memset(lrgsz, NULLCHAR, 400);

    for (int i = 0; i < 10; i++)    sp[i] = 0x0000;
        
    if(Conv.HAN2INS((char *)d, incode, codeWanSeong) != SUCCESS)
    {                                                   // KS -> Incode
        return 99;
    }
   
    bt = NLP_Get_Ending(incode, Act, sp, TOSSI);        

    // for (i = bt - 1; i >= 0; i--)
    for (i = 0; i < bt; i++)                         
    {
        GetStemEnding (incode, stem, ending, sp [i]);

        ACT_C    = GetBit(Act [i], 7);    // consonant
        ACT_V    = GetBit(Act [i], 6);    // vowel
        ACT_N_V = GetBit(Act [i], 5);    
        ACT_P_A = GetBit(Act [i], 4);    
        ACT_N_E = GetBit(Act [i], 3);

        memset(ostem, NULLCHAR, 80);
        memset(oending, NULLCHAR, 40);

        Conv.INR2HAN(ending, oending, codeWanSeong);
        Conv.INS2HAN(stem, ostem, codeWanSeong);          // incode -> ks

        if(__IsDefEnd(LMEPOS, 1) == 1 && 
            ending[LMEPOS] == __K_G && ending[LMEPOS-1] == __V_p)
        {        
            if(NLP_Ge_Proc(stem) != BT)
            {                                               
                lstrcat(lrgsz, ostem);
                lstrcat(lrgsz, "+");
                lstrcat(lrgsz, oending);
                lstrcat(lrgsz, "\t");
                vbuf[wcount++] = POS_PRONOUN;  
                vbuf[wcount++] = POS_TOSSI;
            }
            continue;
        }            

    if (NLP_NCV_Proc(stem, ending) != NCV_VALID)
        continue;



    if (FindSilsaWord (ostem) & _NOUN) 
        {                                                       // searching the noun dictionary
            lstrcat(lrgsz, ostem);
            vbuf[wcount++] = POS_NOUN;
            if (lstrlen (oending) > 0)
            {
                lstrcat(lrgsz, "+");
                lstrcat(lrgsz, oending);
                vbuf[wcount++] = POS_TOSSI;
            }
            lstrcat(lrgsz, "\t");
        }
        
        if(i == 0 || ACT_P_A == 1) 
        {
            if (NLP_Find_Pronoun (stem, ending) == VALID)
            {   
                if (lstrlen (oending) > 0)
                {
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    vbuf[wcount++] = POS_TOSSI;
                }
                lstrcat(lrgsz, "\t");
            }
        }
        if(i == 0 || ACT_N_E == 1) 
        {
            if(NLP_Num_Proc(stem) != BT)   
            {                               
                lstrcat(lrgsz, ostem);
                vbuf[wcount++] = POS_NUMBER;
                if (lstrlen (oending) > 0)
                {
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    vbuf[wcount++] = POS_TOSSI;
                }
                lstrcat(lrgsz, "\t");
            } 
            continue;           // backtracking
        }
    }    
    
    
    lstrcpy (rstrings, lrgsz);

    return wcount;
}

int BaseEngine::NLP_BASE_AFFIX (LPCSTR    d, char *rstrings)
{
   char     Act[10], oending [40], incode [100], stem [100], ending [40];
                
    int     bt,     
            ret,
            sp[10];
    
    CODECONVERT Conv;
    wcount = 0;

    memset(incode, NULLCHAR, 100);
    memset(Act, NULLCHAR, 10);
    memset(lrgsz, NULLCHAR, 400);

    for (int i = 0; i < 10; i++)    sp[i] = 0x0000;
        
    if(Conv.HAN2INS((char *)d, incode, codeWanSeong) != SUCCESS)
    {                                                   // KS -> Incode
        return 99;
    }
   
    bt = NLP_Get_Ending(incode, Act, sp, TOSSI);        

    // for (i = bt - 1; i >= 0; i--)
    for (i = 0; i < bt; i++)                         
    {
        GetStemEnding (incode, stem, ending, sp [i]);

        ACT_C    = GetBit(Act [i], 7);    // consonant
        ACT_V    = GetBit(Act [i], 6);    // vowel
        ACT_N_V = GetBit(Act [i], 5);    
        ACT_P_A = GetBit(Act [i], 4);    
        ACT_N_E = GetBit(Act [i], 3);


        if (NLP_NCV_Proc(stem, ending) != NCV_VALID)
            continue;

        memset(oending, NULLCHAR, 40);
        Conv.INR2HAN(ending, oending, codeWanSeong);

        ret = NLP_Fix_Proc(stem, ending);
        switch (ret)
        {
            case Deol_VALID :
            case Pref_VALID :
            case Suf_VALID :
            case PreSuf_VALID :
                if (lstrlen(oending) > 0)
                {
                    lstrcat (lrgsz, "+");
                    lstrcat (lrgsz, oending);
                    vbuf [wcount++] = POS_TOSSI;
                }
                lstrcat(lrgsz, "\t");
            case BT :   continue;       // backtracking            
        }                            
    }    
    
    
    lstrcpy (rstrings, lrgsz);

    return wcount;
}

int BaseEngine::NLP_BASE_ALONE(LPCSTR     d, char *rstrings)
{
    char    incode [100];
    CODECONVERT Conv;

    memset(incode, NULLCHAR, 100);
    memset(lrgsz, NULLCHAR, 400);
    wcount = 0;

    if(Conv.HAN2INS((char *)d, incode, codeWanSeong) != SUCCESS)
    {                                                   // KS -> Incode
        return 99;
    }
   
    // check whether input word is ADVERB, or not
    if (FindSilsaWord (d) & _ALONE) 
    {                                                   
        lstrcat(lrgsz, d);
        lstrcat(lrgsz, "\t");
        vbuf[wcount++] = POS_ADVERB;
    }

    lstrcpy (rstrings, lrgsz);

    return wcount;
}

int BaseEngine::NLP_BASE_VERB (LPCSTR    d, char *rstrings)
{
    char    index[1], 
            AUX_Flag, tmp[80],
            Act[10], ostem[80], 
            oending[40], incode [100], stem [100], ending [40], rending [40];
            
    int     bt,     
            ret,
            rt,
            sp[10], temp, luls;
    
    CODECONVERT Conv;
    wcount = 0;

    memset(Act, NULLCHAR, 10);
    memset(incode, NULLCHAR, 100);
    memset(lrgsz, NULLCHAR, 400);
    for (int i = 0; i < 10; i++)    sp[i] = 0x0000;
    
    if(Conv.HAN2INS((char *)d, incode, codeWanSeong) != SUCCESS)
    {                                                   // KS -> Incode
        return 99;
    }

    bt = NLP_Get_Ending(incode, Act, sp, END);          
    int codelen = lstrlen(incode) - 1;
    for (i = bt-1; i >= 0; i--)                         
    {
        memset(ostem, NULLCHAR, 80);      
        memset(oending, NULLCHAR, 40);
    
        GetStemEnding (incode, stem, ending, sp [i]);
    
        if (lstrlen (stem) == 0)
            continue;
        
        ACT_C   = GetBit(Act[i], 7);    
        ACT_V   = GetBit(Act[i], 6);    
        ACT_N_V = GetBit(Act[i], 5);    
        ACT_P_A = GetBit(Act[i], 4);    
        ACT_N_E = GetBit(Act[i], 3);    
        ACT_SS  = GetBit(Act[i], 2);    
        ACT_KE  = GetBit(Act[i], 1);    

        RestoreEnding (ending, rending);
        Conv.INR2HAN(rending, oending, codeWanSeong);
        Conv.INS2HAN(stem, ostem, codeWanSeong);          // incode -> ks

        lstrcpy(tmp, stem);
        luls = ULSPOS;
         
        
        if(ACT_SS == 1)
        {
            if((ret = NLP_SS_Proc(stem, ending)) < INVALID)       // VALID               
            {
                if (lstrlen (oending) > 0)
                {
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    vbuf [wcount++] = POS_ENDING;
                }
                lstrcat(lrgsz, "\t");
            }                
            continue;           
        }         
        
        
        if(i == 0)
        {
            break;
        }                          
        
        
        if(ACT_KE == 1)
        {
            if((ret = NLP_KTC_Proc(stem, ending)) == BT)       // backtracking
            {
                continue; 
            }   
        }          
        
        
        ret = NLP_VCV_Check (stem, ending);
        if(ret < INVALID)
        {                       
            AUX_Flag = 0;
            
            if(ACT_N_V == 1)
            {   
                
                if (FindSilsaWord (ostem) & _VERB) 
                {                    
                    lstrcat(lrgsz, ostem);
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    lstrcat(lrgsz, "\t");
                    vbuf[wcount++] = POS_VERB;
                    vbuf[wcount++] = POS_ENDING;
                    AUX_Flag = 1;
                }            
            }             
            
            if(ACT_P_A == 1)
            {   
                
                if (FindSilsaWord (ostem) & _ADJECTIVE) 
                {
                    lstrcat(lrgsz, ostem);
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    lstrcat(lrgsz, "\t");
                    vbuf[wcount++] = POS_ADJECTIVE;
                    vbuf[wcount++] = POS_ENDING;
                    AUX_Flag = 1;
                }      
                if(NLP_Dap_Proc(stem) == Dap_VALID)
                { 
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");
                    AUX_Flag = 1;
                }                        
                if(NLP_Gop_Proc(stem) == Gop_VALID)
                {
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");
                    AUX_Flag = 1;
                }                        
                if((rt = NLP_Manha_Proc(stem)) < INVALID)
                {
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");
                    AUX_Flag = 1;
                }                        
                if((rt = NLP_Manhaeci_Proc(stem)) == Manhaeci_VALID)
                {
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");
                    AUX_Flag = 1;
                }                
                if((rt = NLP_Cikha_Proc(stem)) < INVALID)
                {
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;     
                    }
                    lstrcat(lrgsz, "\t");
                }                    
            }
            // AUX_FLOW         
            if(AUX_Flag == 0)
            {
                if(ACT_N_V == 1)    
                {   
                    if((rt = NLP_AUX_Find(stem, 0)) < INVALID)
                    {  
                        if (lstrlen (oending) > 0)
                        {
                            lstrcat(lrgsz, "+");
                            lstrcat(lrgsz, oending);
                            vbuf[wcount++] = POS_ENDING;
                        }
                        lstrcat(lrgsz, "\t");
                    }     
                }                                        
                if(ACT_P_A == 1)    
                {   
                    if((rt = NLP_AUX_Find(stem, 1)) < INVALID)
                    {  
                        if (lstrlen (oending) > 0)
                        {
                            lstrcat(lrgsz, "+");
                            lstrcat(lrgsz, oending);
                            vbuf[wcount++] = POS_ENDING;
                        }
                        lstrcat(lrgsz, "\t");
                    }               
                }                            
            }                
        }                        
        else if (ret != MORECHECK)
            continue;        // against consonant-vowel harmony

        
        if(ACT_N_E == 1)
        {
            if(strcmp(stem, TempIkNl) == 0)          
            {
                lstrcat(lrgsz, ostem);
                lstrcat(lrgsz, "+");
                lstrcat(lrgsz, oending);
                lstrcat(lrgsz, "\t");
                vbuf[wcount++] = POS_VERB; //Jap_VALID;
                vbuf[wcount++] = POS_ENDING;
            }
            if(__IsDefStem(ULSPOS, 1) == 1 && 
                stem[ULSPOS-1] == __K_I && stem[ULSPOS] == __V_l)   
            {                                       
                
                if(__IsDefStem(ULSPOS, 2) == 1 && stem[ULSPOS-2] == __K_M)  
                {                                                                                  
                    sp[i] = LMEPOS+3;   
                    Act[i] = 0x70;      // action:01-110-00-0
                    i++;                       
                    if(__IsDefStem(ULSPOS, 4) == 1 && 
                        stem[ULSPOS-4] == __K_I && stem[ULSPOS-3] == __V_m)    
                    {                        
                        sp[i] = LMEPOS+5;               
                        Act[i] = (unsigned char)0xB0;   // action:10 110 00 0   
                        i++;
                    }                                               
                }
                temp = ULSPOS;
                __DelStem2(stem, &temp); 
                ULSPOS = temp;

                
                
                
                if((ret = NLP_Machine_T(stem, ending)) < INVALID)
                {       
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");       
                } 
                
                temp = ULSPOS;
                __AddStem2(stem, &temp, __K_I, __V_l);       
                ULSPOS = temp;            
                if(__IsDefEnd(LMEPOS, 1) == 1 && 
                    ending[LMEPOS] == __K_I && ending[LMEPOS-1] == __V_j)   
                {                              
                    
                    
                    for (int i = 0; i < 3; i++)
                    {
                        if(strcmp(stem, TempJap[i]) == 0) 
                        {
                            lstrcat(lrgsz, ostem);
                            lstrcat(lrgsz, "+");
                            lstrcat(lrgsz, oending);
                            lstrcat(lrgsz, "\t");
                            vbuf[wcount++] = POS_VERB; //VERB_VALID;
                            vbuf[wcount++] = POS_ENDING;
                        }
                    }
                    continue;  
                }                                     
                
                index[0] = 'm';
                if (FindSilsaWord (ostem) & _NOUN) 
                {
                    lstrcat(lrgsz, ostem);
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    lstrcat(lrgsz, "\t");
                    vbuf[wcount++] = POS_NOUN; //Jap_NOUN_VALID;
                    vbuf[wcount++] = POS_ENDING;
                }            
                if((ret = NLP_Fix_Proc(stem, ending)) < INVALID) 
                {
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");   
                }                                     
                if (NLP_Find_Pronoun (stem, ending) == VALID)
                {   
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_TOSSI;
                    }
                    lstrcat(lrgsz, "\t");
                }
                if((ret = NLP_Num_Proc(stem)) < INVALID)     
                {
                    lstrcat(lrgsz, ostem);
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    lstrcat(lrgsz, "\t");
                    vbuf[wcount++] = POS_NUMBER; //Jap_NUM_VALID;
                    vbuf[wcount++] = POS_ENDING;
                }   
                continue;       // backtracking
            }
            else if( /*ACT_Z != 1 &&  */                    // ACT_Z != 1
                     ULS >= __V_k &&                    
                     !(__IsDefEnd(LMEPOS, 1) == 1 && 
                     ending[LMEPOS] == __K_I && ending[LMEPOS-1] == __V_j)) 
                                    
                                    
            {                                    
                if((ret = NLP_Machine_T(stem, ending)) < INVALID)
                {       
                    if (lstrlen (oending) > 0)
                    {
                        lstrcat(lrgsz, "+");
                        lstrcat(lrgsz, oending);
                        vbuf[wcount++] = POS_ENDING;
                    }
                    lstrcat(lrgsz, "\t");       
                } 
            }
        }
        lstrcpy(tmp, stem);
        luls = ULSPOS;
                      
        
        if(ACT_C == 0 && ACT_V == 1) 
        {
// by hjw : 95/3/6        
            if((ret = NLP_Irr_01(stem, ending)) < INVALID)
            {
                if (lstrlen (oending) > 0)
                {
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    vbuf[wcount++] = POS_ENDING;
                }
                lstrcat(lrgsz, "\t");
                continue;
            }                                     
        }

        lstrcpy (stem, tmp);
        ret = BT;
        switch(LME)
        {
            case __K_N :
                if((ret = NLP_Irr_KN(stem, ending)) == Irr_KN_Vl)
                {
                    ret = NLP_Irr_KN_Vl(stem);
                }
                if(ret == Irr_OPS)
                {
                    if((ret = NLP_Irr_OPS(stem, ending)) == SS)
                    {
                        if((ret = NLP_SS_Proc(stem, ending)) == BT) 
                        {
                            continue;
                        }                            
                        if(ret < INVALID)   
                        {
                            ret += Irr_SS;    
                        }                            
                    }   
                }                    
                break;
            case __K_B :
                ret = NLP_Machine_A(stem, ending);              
                break;
// hjw : 95/3/17
            case __K_S :
                if(ACT_C == 1)      // ATC_C == 1
                {         
                    ret = NLP_Irr_KS(stem, ending);
                }                    
                else if(ULS >= __V_k) 
                {
                    ret = NLP_Machine_A(stem, ending);                     
                }                        
                break;     
            case __K_M :
                ret = NLP_Irr_KM(stem);
                break;
            case __K_R :
                if(__IsDefEnd(LMEPOS, 1) == 0 || ending[LMEPOS-1] < __V_k)
                {
                    ret = NLP_Machine_A(stem,ending);
                    
                    if (ret != BT)
                    {
                        if (lstrlen (oending) > 0)
                        {
                            lstrcat(lrgsz, "+");
                            lstrcat(lrgsz, oending);
                            vbuf[wcount++] = POS_ENDING;
                        }
                        lstrcat(lrgsz, "\t");
                    }
                    
                }
                if(ACT_P_A == 1)   
                {
                    ret = NLP_Irr_KRadj(stem, ending);
                    if (ret != BT)
                    {
                        if (lstrlen (oending) > 0)
                        {
                            lstrcat(lrgsz, "+");
                            lstrcat(lrgsz, oending);
                            vbuf[wcount++] = POS_ENDING;
                        }
                        lstrcat(lrgsz, "\t");
                    }
                }
                if(ACT_N_V == 1)   
                {                        
                    if((ret = NLP_Irr_KRvb(stem, ending)) == SS)
                    {
                        if((ret = NLP_SS_Proc(stem, ending)) == BT)    
                        {
                            continue;
                        } 
                        if(ret < INVALID)
                        {
                            ret += Irr_SS;
                        }                              
                    }                            
                }
                break;
            case __K_I :                                                                            
                if(__IsDefEnd(LMEPOS, 1) == 1 && (ending[LMEPOS-1] == __V_h || 
                    ending[LMEPOS-1] == __V_hl || ending[LMEPOS-1] == __V_l ))
                {
                    if(ULS >= __V_k)   
                    {
                        ret = NLP_Irr_KI(stem,rending);
                    }                            
                    else    
                    {
                        continue;
                    }                        
                }
                if(ULS == __K_R)   
                {
                    ret = NLP_Irr_KI_KR(stem, ending);
                }                    
                if(ULS >= __V_k)   
                {
                    ret = NLP_Irr_KI_V(stem, ending);
                }                    
                break;
            default :   
                continue;
        }
        if(ret >= INVALID)   
        {
            continue;
        }            
        if(ret >= VALID)
        {
            if (lstrlen (oending) > 0)
            {
                lstrcat(lrgsz, "+");
                lstrcat(lrgsz, oending);
                vbuf[wcount++] = POS_ENDING;
            }
            lstrcat(lrgsz, "\t");
        }                
    }

    lstrcpy (rstrings, lrgsz);

    return wcount;
}

// made by dhyu 1996. 2
// look into mrfgen01.txt to know details
void BaseEngine::RestoreEnding (char *ending, char *rending)
{
    int len = lstrlen (ending); // ending has reverse order.
    lstrcpy (rending, ending);

    if (lstrlen (ending) == 0)
        return;

    if (ACT_SS)        // insert "IEUNG, EO" to the first of ending 
    {
        rending [len] = __V_j;
        rending [len+1] = __K_I;
        rending [len+2] = '\0';

        return;
    }

    if (ACT_C && ACT_V)    //CV == 11
    {
        if (ending [len - 1] == __K_I && ending [len - 2] == __V_k)
            rending [len - 2] = __V_j;

        return;
    }

    if (!ACT_C && ACT_V == TRUE)      // CV == 01
    {
        switch (ending [len - 1])
        {
            case __K_B :
                rending [len] = __V_m;        // insert "SIOS, EU" to the first of ending
                rending [len+1] = __K_S;
                rending [len+2] = '\0';
                return ;
            case __K_R :
                if (len == 2 && ending [0] == __V_k) // if ending is "ra" , insert "IEUNG EO" to the first of ending
                {
                    rending [len] = __V_j;
                    rending [len+1] = __K_I;
                    rending [len+2] = '\0';
                    return;
                }
                break;
            case __K_I :
                if (ending [len - 2] == __V_y) // if ending is "yo",
                {
                    rending [len] = __V_j;
                    rending [len+1] = __K_I;
                    rending [len+2] = '\0';
                    return;
                }
                break;
            case __K_N :
                if (!ACT_C && ACT_V && ACT_N_V && !ACT_P_A && !ACT_P_A && !ACT_N_E && !ACT_SS && !ACT_KE)
                {
                    rending [len] = __V_m;
                    rending [len+1] = __K_N;
                    rending [len+2] = '\0';
                    return;
                }
        }
            
        rending [len] = __V_m;     // insert "IEUNG, EU" to the first of ending
        rending [len+1] = __K_I;
        rending [len+2] = '\0';

        return;
    }
    
    // "KE-TO-CHI" ending and copula is processed with stem together.
    
    return;
}

// To process compound noun, we use the window which size is 4 characters.
// We decrease the size until we found noun.
// However we don't decrease it less than 2 characters.
// made by dhyu --- 1996. 3
int BaseEngine::NLP_BASE_COMPOUND (LPCSTR    d, char *rstrings)
{
    char    Act[10], ostem[80], oending[40],
            incode [100], stem [100], ending [40];
                
    int     bt,     
           sp[10];
    BOOL found;

    CODECONVERT Conv;

    memset(incode, NULLCHAR, 100);
    memset(Act, NULLCHAR, 10);

    for (int i = 0; i < 10; i++)    sp[i] = 0x0000;
        
    if(Conv.HAN2INS((char *)d, incode, codeWanSeong) != SUCCESS)
        return 0;
    
   
    bt = NLP_Get_Ending(incode, Act, sp, TOSSI);       

    for (i = bt-1; i >= bt-3 && i >= 0; i--)                       
    //for (i = 0; i < bt; i++)
    {
        GetStemEnding (incode, stem, ending, sp [i]);

        ACT_C    = GetBit(Act [i], 7);    // consonant
        ACT_V    = GetBit(Act [i], 6);    // vowel
        ACT_N_V = GetBit(Act [i], 5);    
        ACT_P_A = GetBit(Act [i], 4);    
        ACT_N_E = GetBit(Act [i], 3);

        if (NLP_NCV_Proc(stem, ending) == NCV_VALID)
        {
            memset(ostem, NULLCHAR, 80);      
            memset(oending, NULLCHAR, 40);
            Conv.INR2HAN(ending, oending, codeWanSeong);
            Conv.INS2HAN(stem, ostem, codeWanSeong);          // incode -> ks
            
            wcount = 0;
            memset (lrgsz, NULLCHAR, 400);
            // Window size is 4 charaters (8 byte)
            char window [9], inwindow [25];
            memset (window, '\0', 9);
            char *next = ostem;
            found = TRUE;
            while (lstrlen (next) > 8)        
            {
                found = FALSE;
                memcpy (window, next, 8);
                for (int j = 7; j >= 3; j -= 2)
                {
                    if (FindSilsaWord (window) & _NOUN) 
                    {                                            // searching the noun dictionary
                        lstrcat(lrgsz, window);
                        vbuf[wcount++] = POS_NOUN;
                        lstrcat(lrgsz, "+");
                        found = TRUE;
                        break;
                    }
                    window [j] = '\0';
                    window [j-1] = '\0';
                }
                if (!found)
                {
                    // if "GYEOM" is the first character in window
                    Conv.HAN2INS (next, inwindow, codeWanSeong);
                    if ((inwindow [0] == __K_G && inwindow [1] == __V_u && inwindow [2] == __K_M) ||
                        (inwindow [0] == __K_M && inwindow [1] == __V_l && inwindow [2] == __K_C))
                    {
                        memcpy (window, next, 2);
                        window [2] = '\0';
                        lstrcat(lrgsz, window);
                        vbuf [wcount++] = POS_ADVERB;
                        lstrcat(lrgsz, "+");
                        found = TRUE;
                        next += 2;
                    }
                    else
                        break; 
                }
                else
                    next += (j+1);
            }

            if (!found)
                continue;
            else
            {
                if (FindSilsaWord (next) & _NOUN)
                {
                    lstrcat (lrgsz, next);
                    vbuf[wcount++] = POS_NOUN;
                }
                else
                {
                    switch (lstrlen(next))
                    {
                    case 8 : 
                        // if the size of last winow is 4, we divide it into same size two. 
                        memcpy (window, next, 4);
                        window [4] = '\0';
                        Conv.HAN2INS (window, inwindow, codeWanSeong);
        
                        found = FALSE;
                        if (FindSilsaWord (window) & _NOUN) 
                        {                                            // searching the noun dictionary
                            Conv.HAN2INS(next+4, inwindow, codeWanSeong);
                            if (FindSilsaWord (next+4) & _NOUN) 
                            {
                                lstrcat(lrgsz, window);
                                vbuf[wcount++] = POS_NOUN;
                                lstrcat(lrgsz, "+");
                                lstrcat(lrgsz, next+4);
                                vbuf[wcount++] = POS_NOUN;
                                found = TRUE;
                            }
                        }
                        if (!found)
                        {
                            // if "GYEOM" is the first character in window
                            if ((inwindow [0] == __K_G && inwindow [1] == __V_u && inwindow [2] == __K_M) ||
                                (inwindow [0] == __K_M && inwindow [1] == __V_l && inwindow [2] == __K_C))
                            {
                                memcpy (window, next, 8);
                                window [9] = '\0';
                                if (FindSilsaWord (window) & _NOUN) 
                                {
                                    memcpy (window, next, 2);
                                    window [2] = '\0';
                                    lstrcat(lrgsz, window);
                                    vbuf [wcount++] = POS_ADVERB;
                                    lstrcat(lrgsz, "+");
                                    lstrcat(lrgsz, next+2);
                                    vbuf [wcount++] = POS_NOUN;
                                }
                            }
                            else 
                            {
                                // if "DEUNG" is the last character
                                Conv.HAN2INS (next+6, inwindow, codeWanSeong);
                                if ((inwindow [0] == __K_D && inwindow [1] == __V_m && inwindow [2] == __K_I) ||
                                    (inwindow [0] == __K_G && inwindow [1] == __V_k && inwindow [2] == __K_M) ||
                                    (inwindow [0] == __K_G && inwindow [1] == __V_k && inwindow [2] == __K_B && inwindow [3] == __K_S) ||
                                    (inwindow [0] == __K_G && inwindow [1] == __V_P) ||
                                    (inwindow [0] == __K_C && inwindow [1] == __V_o && inwindow [2] == __K_G))

                                {
                                    memcpy (window, next, 6);
                                    window [6] = '\0';
                                    if (FindSilsaWord (window) & _NOUN) 
                                    {
                                        lstrcat (lrgsz, window);
                                        vbuf [wcount++] = POS_NOUN;
                                        lstrcat (lrgsz, "+");
                                        lstrcat (lrgsz, next+6);
                                        vbuf [wcount++] = POS_NOUN;
                                    }
                                    else
                                    {
                                        // if "DEUNG,DEUNG" is the part
                                        Conv.HAN2INS (next+4, inwindow, codeWanSeong);
                                        if (inwindow [0] == __K_D && inwindow [1] == __V_m && inwindow [2] == __K_I)
                                        {
                                            memcpy (window, next, 4);
                                            window [4] = '\0';
                                            if (FindSilsaWord (window) & _NOUN) 
                                            {
                                                lstrcat (lrgsz, window);
                                                vbuf [wcount++] = POS_NOUN;
                                                lstrcat (lrgsz, "+");
                                                lstrcat (lrgsz, next+4);
                                                vbuf [wcount++] = POS_NOUN;
                                            }
                                            else
                                                continue;
                                        }
                                        else
                                            continue;
                                    }
                                }
                                else
                                    continue;
                            }
                        }
                        break;
                    case 6 :
                        Conv.HAN2INS (next, inwindow, codeWanSeong);
                        /*
                        if (FindSilsaWord (next) & _NOUN) 
                        {
                            lstrcat (lrgsz, next);
                            vbuf[wcount++] = POS_NOUN;
                        }
                        else
                        {
                        */
                            // if "GYEOM" is the first character in window
                            if ((inwindow [0] == __K_G && inwindow [1] == __V_u && inwindow [2] == __K_M) ||
                                (inwindow [0] == __K_M && inwindow [1] == __V_l && inwindow [2] == __K_C)) 
                            {
                                if (FindSilsaWord (next+2) & _NOUN) 
                                {
                                    memcpy (window, next, 2);
                                    window [2] = '\0';
                                    lstrcat(lrgsz, window);
                                    vbuf [wcount++] = POS_ADVERB;
                                    lstrcat(lrgsz, "+");
                                    lstrcat(lrgsz, next+2);
                                    vbuf [wcount++] = POS_NOUN;
                                }
                                else
                                    continue;
                            }
                            else
                            {
                                // if "DEUNG" is the last character
                                Conv.HAN2INS (next+4, inwindow, codeWanSeong);
                                if (inwindow [0] == __K_D && inwindow [1] == __V_m && inwindow [2] == __K_I)
                                {
                                    memcpy (window, next, 4);
                                    window [4] = '\0';
                                    if (FindSilsaWord (window) & _NOUN) 
                                    {
                                        lstrcat (lrgsz, window);
                                        vbuf [wcount++] = POS_NOUN;
                                        lstrcat (lrgsz, "+");
                                        lstrcat (lrgsz, next+4);
                                        vbuf [wcount++] = POS_NOUN;
                                    }
                                    else
                                        continue;
                                }
                                else
                                    continue;
                            }
                        //}
                        break;
                        /*
                    case 4 :

                        if (FindSilsaWord (next) & _NOUN) 
                        {
                            lstrcat (lrgsz, next);
                            vbuf[wcount++] = POS_NOUN;
                            if (lstrlen (oending) > 0)
                            {
                                lstrcat(lrgsz, "+");
                                lstrcat(lrgsz, oending);
                                vbuf[wcount++] = POS_TOSSI;
                            }
                        }
                        else
                            continue;
                        break;                    
                        */
                    default :
                        continue;
                    }
                }
                if (lstrlen (oending) > 0)
                {
                    lstrcat(lrgsz, "+");
                    lstrcat(lrgsz, oending);
                    vbuf[wcount++] = POS_TOSSI;
                }
                lstrcat(lrgsz, "\t");
                        
                lstrcpy (rstrings, lrgsz);

                return wcount;
            }
        }
    }

    lstrcpy (rstrings, "\0");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basevsub.cpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// FILE NAME        : BASEVSUB.CPP
// Function         : BASE ENGINE FUNCTION COLLECTION (VERB PROCESS)
//                  : NLP Base Engine Function
// =========================================================================
#include "basevsub.hpp"
#include "basegbl.hpp"
#include "MainDict.h"

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_KTC_Proc(char  *stem, char *ending)      
{
    char    tmpstem[80], tmpending [80], tmpstring [80];
    int     temp;
            
    temp = ULSPOS;
    lstrcpy(tmpstem, stem);
    __AddStem2(tmpstem, &temp, __K_H, __V_k);    
    lstrcpy (tmpending, ending);

    int len = lstrlen(tmpending) - 1;
    switch (tmpending [len])        // inserted by dhyu 1996.2
    {
        case __K_K : tmpending [len] = __K_G; break;
        case __K_T : tmpending [len] = __K_D; break;
        case __K_C : tmpending [len] = __K_J; break;
    }
    Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
    if (FindSilsaWord (tmpstring) & _VERB) 
    {
        lstrcat (lrgsz, tmpstring);
        vbuf [wcount++] = POS_VERB;
        lstrcat (lrgsz, "+");
        Conv.INR2HAN (tmpending, tmpstring, codeWanSeong);
        lstrcat (lrgsz, tmpstring);
        vbuf [wcount++] = POS_ENDING;
        lstrcat (lrgsz, "\t");
        return KTC_VERB_VALID;                   
    }
    if(ACT_P_A == 1) 
    {
        Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
        if (FindSilsaWord (tmpstring) & _ADJECTIVE) 
        {
            lstrcat (lrgsz, tmpstring);
            vbuf [wcount++] = POS_ADJECTIVE;
            lstrcat (lrgsz, "+");
            Conv.INR2HAN (tmpending, tmpstring, codeWanSeong);
            lstrcat (lrgsz, tmpstring);
            vbuf [wcount++] = POS_ENDING;
            lstrcat (lrgsz, "\t");
            return KTC_ADJ_VALID;
        }            
        else    
        {
            return BT;
        }            
    }

    return INVALID;                            
}

// ----------------------------------------------------------------------
//

//
// modified by dhyu 1996.2
// ----------------------------------------------------------------------
int BaseEngine::NLP_Machine_T(char  *stem,
                              char  *ending) 
{
    char    bending[80], 
            index[1],
            tmpstem[80],
            tmpstring [80];
    int     ret, ulspos; 

    memset(bending, NULL, 80);

    lstrcpy(tmpstem, stem);    

    ulspos = lstrlen(tmpstem)-1;
    
    int B_index = B_Dict.FindWord(tmpstem, ulspos);
    if(B_index != -1) 
    {                   // if the rear of stem is 'BBUN'
        if(ulspos == -1)     // if the whole stem is only 'BBUN'
        {
            Conv.INS2HAN (stem, tmpstring, codeWanSeong);
            lstrcat (lrgsz, tmpstring);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Ieung_I);   
            vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
            return NOUN_VALID;   
        }                   
        index[0] = 'm';
        Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
        if (FindSilsaWord (tmpstring) & _NOUN) 
        {
            lstrcat (lrgsz, tmpstring);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, SangP_U_N);  
            vbuf [wcount++] = POS_TOSSI;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Ieung_I);   
            vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
            return NOUN_VALID;
        }            
        if((ret = NLP_Fix_Proc(tmpstem, ending)) < INVALID) 
        {
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, SangP_U_N);  
            vbuf [wcount++] = POS_TOSSI;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Ieung_I);   
            vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
            return ret;        
        }  
        if(FindIrrWord(tmpstem, _ZPN) & FINAL)     // Pronoun
        {
            Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
            lstrcat (lrgsz, tmpstring);
            vbuf [wcount++] = POS_PRONOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, SangP_U_N);  
            vbuf [wcount++] = POS_TOSSI;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Ieung_I);   
            vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
            return PRON_VALID;
        }              
        if(NLP_Num_Proc(tmpstem) < INVALID)
        {
            Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
            lstrcat (lrgsz, tmpstring);
            vbuf [wcount++] = POS_NUMBER;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, SangP_U_N);  
            vbuf [wcount++] = POS_TOSSI;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Ieung_I);   
            vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
            return NUM_VALID;
        }     
// hjw : 95/3/176                     
        if(tmpstem[ulspos] == __K_R)      
        {
            return INVALID;
        }            
        return MORECHECK;
    }

    
    int T_index = T_Dict.FindWord(tmpstem, ulspos); 
                                                    
    index[0] = 'm';
    Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
    if (FindSilsaWord (tmpstring) & _NOUN) 
    {
        lstrcat (lrgsz, tmpstring);
        vbuf [wcount++] = POS_NOUN;
        lstrcat (lrgsz, "+");
        lstrcat (lrgsz, Ieung_I);   
        vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
        return NOUN_VALID;
    }                          
    if((ret = NLP_Fix_Proc(tmpstem, ending)) < INVALID) 
    {
        return ret;
    }                                           
    if(FindIrrWord(tmpstem, _ZPN) & FINAL) 
    {
        Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
        lstrcat (lrgsz, tmpstring);
        vbuf [wcount++] = POS_PRONOUN;
        lstrcat (lrgsz, "+");
        lstrcat (lrgsz, Ieung_I);   
        vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
        return PRON_VALID;
    }
    if(NLP_Num_Proc(tmpstem) < INVALID)
    {
        Conv.INS2HAN (tmpstem, tmpstring, codeWanSeong);
        lstrcat (lrgsz, tmpstring);
        vbuf [wcount++] = POS_NUMBER;
        lstrcat (lrgsz, "+");
        lstrcat (lrgsz, Ieung_I);   
        vbuf [wcount++] = POS_OTHERS | COPULA_OTHERS;
        return NUM_VALID;
    }    
    return MORECHECK;        
}
// ----------------------------------------------------------------------
//


//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Dap_Proc(char  *stem) 
{
    char    tmpstem[80],
            index[1],
            tmp [80];
    int        ulspos, temp;
            
    lstrcpy(tmpstem, stem);
    ulspos = lstrlen(tmpstem)-1;
    _itoa (lstrlen (stem), tmp, 10);
    if(Dap.FindWord(tmpstem, ulspos) != -1) 
    {
        _itoa (lstrlen (tmpstem), tmp, 10);
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)    
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Tikeut_A_P);   
            vbuf [wcount++] = POS_SUFFIX;
            return Dap_VALID;
        }                    
        if(FindIrrWord(tmpstem, _ZPN) & FINAL)     
        {
            char tstem [80];
            Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_PRONOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, Tikeut_A_P);   
            vbuf [wcount++] = POS_SUFFIX;
            return Dap_VALID;
        }
        if(__IsDefStem(ulspos, 2) == 1 && 
            tmpstem[ulspos-2] == __K_D && tmpstem[ulspos-1] == __V_m && tmpstem[ulspos] == __K_R) 
        {
            temp = ulspos;
            __DelStemN(tmpstem, &temp, 3); 
            ulspos = temp;
            index[0] = 'm';            
            char tstem [80];
            Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _NOUN) 
            {
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_NOUN;
                lstrcat (lrgsz, "+");
                lstrcat (lrgsz, Tikeut_A_P);   
                vbuf [wcount++] = POS_SUFFIX;
                return Dap_VALID;
            }                
        }
    }
    return MORECHECK;                        
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Gop_Proc(char  *stem) 
{
    char    tmpstem[80];
    int        temp, ulspos;
                
    lstrcpy(tmpstem, stem);
    ulspos = lstrlen(tmpstem)-1;

    if(__IsDefStem(ulspos, 3) == 1 && 
        tmpstem[ulspos-3] == __K_G && tmpstem[ulspos-2] == __V_h && 
        tmpstem[ulspos-1] == __K_P && tmpstem[ulspos] == __V_m) 
    {                                                       
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 4);
        ulspos = temp;
        char tstem [80];
        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _VERB) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_VERB;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, KO_PHEU);   
            vbuf [wcount++] = POS_SUFFIX;
            return Gop_VALID;
        }            
    }
    return MORECHECK;
}
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Manha_Proc(char  *stem) 
{
    char    index[1], tmpstem[80];
    int        temp, ulspos;

    lstrcpy(tmpstem, stem);
    ulspos = lstrlen(tmpstem)-1;
                
    if(__IsDefStem(ulspos, 4) == 1 && 
        tmpstem[ulspos-4] == __K_M && tmpstem[ulspos-3] == __V_k && tmpstem[ulspos-2] == __K_N &&
        tmpstem[ulspos-1] == __K_H && tmpstem[ulspos] == __V_k) 
    {                               
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 5);  
        ulspos = temp;
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)    
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, MAN_HA);  
            vbuf [wcount++] = POS_SUFFIX;
            return Manha_VALID;
        }
        if(FindIrrWord(tmpstem, _ZPN) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_PRONOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, MAN_HA);  
            vbuf [wcount++] = POS_SUFFIX;
            return Manha_VALID;        
        }
    }
    if(__IsDefStem(ulspos, 4) == 1 && 
        tmpstem[ulspos-4] == __K_I && tmpstem[ulspos-3] == __V_u && tmpstem[ulspos-2] == __K_N && 
        tmpstem[ulspos-1] == __K_H && tmpstem[ulspos] == __V_k) 
    {                                   
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 5);
        ulspos = temp;
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)    
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, IYEON_HA);   
            vbuf [wcount++] = POS_SUFFIX;
            return Yenha_VALID;
        }
        if(FindIrrWord(tmpstem, _ZPN) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_PRONOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, IYEON_HA);   
            vbuf [wcount++] = POS_SUFFIX;
            return Yenha_VALID;        
        }            
    }
    return MORECHECK;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Manhaeci_Proc(char  *stem) 
{
    char    index[1], tmpstem[80];
    int        temp, ulspos;

    lstrcpy(tmpstem, stem);
    ulspos = lstrlen(tmpstem)-1;
                
    if(__IsDefStem(ulspos, 6) == 1 && 
        tmpstem[ulspos-6] == __K_M && tmpstem[ulspos-5] == __V_k && tmpstem[ulspos-4] == __K_N &&
        tmpstem[ulspos-3] == __K_H && tmpstem[ulspos-2] == __V_o && 
        tmpstem[ulspos-1] == __K_J && tmpstem[ulspos] == __V_l)  
    {                               
        temp = ulspos;
        __DelStemN(tmpstem, &temp, 7);  
        ulspos = temp;
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN) 
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, MAN_HAE_CI);  
            vbuf [wcount++] = POS_SUFFIX;
            return Manhaeci_VALID;        
        }
        if(FindIrrWord(tmpstem, _ZPN) & FINAL) 
        {
            char tstem [80];
            Conv.INS2HAN (tmpstem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_PRONOUN;
            lstrcat (lrgsz, "+");
            lstrcat (lrgsz, MAN_HAE_CI);  
            vbuf [wcount++] = POS_SUFFIX;
            return Manhaeci_VALID;        
        }            
    }
    return MORECHECK;
} 

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_VCV_Proc(char  *stem,
                             char  *ending) 
{
    char    r_vowel = NULLCHAR,
            tmpend[80],
            tmpstem[80];
            
    int     lenuls, ulspos, lmepos;
    
    lstrcpy(tmpstem, stem);
    lstrcpy(tmpend, ending);
    ulspos = lstrlen(tmpstem) - 1;
    lmepos = lstrlen(tmpend) - 1;
     
    lenuls = lstrlen(tmpstem) - 1;
    
    if(__IsDefEnd(lmepos, 1) == 1 && 
        tmpend[lmepos] == __K_I && tmpend[lmepos-1] == __V_j) 
    {                                       
        for (int i = lenuls; i >= 0; i--)  
            if(tmpstem[i] >= __V_k) 
            {
                r_vowel = tmpstem[i];
                break;
            }
            
        if(r_vowel == __V_h || r_vowel == __V_k || r_vowel == __V_i)   
            return INVALID;
        
        if(tmpstem[lenuls] == __V_j) return MORECHECK; 

        return VCV_VALID;
    }
    if(__IsDefEnd(lmepos, 1) == 1 && 
        tmpend[lmepos] == __K_I && tmpend[lmepos-1] == __V_k) 
    {                                               
        for (int i = lenuls; i >= 0; i--)          
            if(tmpstem[i] >= __V_k) 
            {
                r_vowel = tmpstem[i];
                break;
            }
                
        if(r_vowel == __V_h || r_vowel == __V_k || r_vowel == __V_i)       
        {                                           
            if(tmpstem[lenuls] == __V_k)   return MORECHECK;   
            else    return VCV_VALID;
        }
        return INVALID;
    }        
    return VCV_VALID;
}                       

// ----------------------------------------------------------------------
//



//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Blocking(char  *stem,
                             char  *ending) 
{
    char    tmpstem[80],
            tmpend[80];
    int     lmepos,
            lULSPOS;
        
    lstrcpy(tmpstem, stem);
    lstrcpy(tmpend, ending);
    lULSPOS = lstrlen(tmpstem) - 1;
    lmepos = LMEPOS;

    switch (LME)    
    {
        case __K_N :
            if(strcmp(tmpend, TempRa[1]) == 0) 
            {
                if(FindIrrWord(stem, _IV_Nj) & FINAL)  
                {
                   return Bloc_VALID;
                }        
                return INVALID;           
            }        
            if(tmpstem[lULSPOS] == __K_R)  
            {
                return INVALID;
            }
            if(FindIrrWord(tmpstem, _IA_HP) & FINAL || 
                FindIrrWord(tmpstem, _IA_HM) & FINAL)   
            {                
                return INVALID;
            }                
            if(__IsDefStem(lULSPOS, 2) == 1 && tmpstem[lULSPOS] == __K_S_D && 
               tmpstem[lULSPOS-1] == __V_l && tmpstem[lULSPOS-2] == __K_I)  
            {
                if(__IsDefEnd(lmepos, 4) == 1 && 
                   ending[lmepos] == __K_N && ending[lmepos-1] == __V_m &&
                   ending[lmepos-2] == __K_N && ending[lmepos-3] == __K_G &&
                   ending[lmepos-4] == __V_n)           
                {
                    return INVALID;
                }                               
            }                         
            return Bloc_VALID;
        case __K_S :
            if(tmpstem[lULSPOS] == __K_R) 
            {
                return INVALID;
            }
            return Bloc_VALID;          
        case __K_I :                
            if(__IsDefEnd(lmepos, 1) == 1 &&
                (tmpend[lmepos-1] == __V_h || tmpend[lmepos-1] == __V_l || 
                 tmpend[lmepos-1] == __V_hl)) 
            {                           
                if(tmpstem[lULSPOS] == __K_R) 
                {
                    return INVALID;
                }
                return Bloc_VALID;
            }
            if(__IsDefEnd(lmepos, 2) == 1 && 
                tmpend[lmepos-1] == __V_m && tmpend[lmepos-2] == __K_N) 
            {                           

                if((__IsDefStem(lULSPOS, 3) == 1 && 
                    strcmp(tmpstem+(lULSPOS-3), Tempiss[0]) == 0) || 
                    (__IsDefStem(lULSPOS, 2) == 1 && 
                    strcmp(tmpstem+(lULSPOS-2), Tempiss[1]) == 0))   
                {                                               
                    if(__IsDefEnd(lmepos, 3) == 1 && tmpend[lmepos-3] == __V_k)  
                    {
                        return Bloc_VALID;
                    }
                    if(__IsDefEnd(lmepos, 3) == 1 && tmpend[lmepos-3] == __V_l)  
                    {
                        if(__IsDefEnd(lmepos, 5) == 1 && 
                            tmpend[lmepos-4] == __K_R && tmpend[lmepos-5] == __V_k) 
                        {                                
                            return INVALID;             
                        }
                        return Bloc_VALID;
                    }
                    return INVALID;
                }
            }
            return Block_Comm;
    }
    if(strcmp(tmpend, TempRa[0]) == 0)     
    {
        if(FindIrrWord(tmpstem, _IV_Gj) & FINAL)  
        {
            return Bloc_VALID;
        }        
        return INVALID;
    }        

    return Bloc_VALID;
}
 
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Block_Comm(char  *stem,
                               char  *ending) 
{
    int     StemPos, 
            EndPos;
    char    tmp[80],
            end[80]; 
    
    lstrcpy(tmp, stem);
    lstrcpy(end, ending);
    EndPos = lstrlen(end) - 1;
    StemPos = lstrlen(tmp) - 1;    
    
    switch (tmp[StemPos]) 
    {
        case __V_k : 
            if(__IsDefStem(StemPos, 1) == 1 && stem[StemPos-1] == __K_H)   
                return INVALID;
            
            break;
        case __V_m : 
            return INVALID;
        case __V_n : 
            if(__IsDefStem(StemPos, 1) == 1 && stem[StemPos-1] == __K_I)    
                return INVALID;

            if(strcmp(tmp, TempBC) == 0) 
                return INVALID;
            
            break;
        case __K_H : 
            if(FindIrrWord(tmp, _IA_HP) & FINAL ||     
                FindIrrWord(tmp, _IA_HM) & FINAL)       
                return INVALID;
            
            break;
        case __K_B : 
            if(FindIrrWord(tmp, _RA_B) & FINAL)        
            {
                return Bloc_VALID;
            }

            char tstem [80];
            Conv.INS2HAN (tmp, tstem, codeWanSeong);
            if (FindSilsaWord (tstem) & _ADJECTIVE) 
                return INVALID;

            if(__IsDefStem(StemPos, 2) == 1 && 
                tmp[StemPos-2] == __K_D && tmp[StemPos-1]==__V_k)       
                return INVALID;

            if(FindIrrWord(tmp, _IV_BM) & FINAL ||     
                FindIrrWord(tmp, _IV_BP) & FINAL)       
                return INVALID;

            break;                
        case __K_S : 
            if(FindIrrWord(tmp, _IV_SP) & FINAL ||     
                FindIrrWord(tmp, _IV_SM) & FINAL)       
                return INVALID;
            
            break;
        case __K_D : 
            if(FindIrrWord(tmp, _IV_DP) & FINAL)       
            {
                if(FindIrrWord(tmp, _RV_D) & FINAL)    // V2R
                {
                    return Bloc_VALID;
                }
             
                return INVALID;
            }
            if(FindIrrWord(tmp, _IV_DM) & FINAL)       
            {
                if(FindIrrWord(tmp, _RV_D) & FINAL)    // V2R
                {
                    return Bloc_VALID;
                }

                return INVALID;
            }
            break;
    }

    return Bloc_VALID;
}                             
// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_VCV_Check(char  *stem,
                              char  *ending) 
{
    char    tmp[80],
            end[80]; 
            
    int     ret, luls, llme;
        
    lstrcpy(tmp, stem);
    lstrcpy(end, ending);
    llme = LMEPOS;
    luls = ULSPOS;    
    
    if(ACT_C == 1 && ACT_V == 1)
    {
        if((ret = NLP_VCV_Proc(stem, ending)) == VCV_VALID)    
            if((ret = NLP_Blocking(stem, ending)) == Block_Comm)
                ret = NLP_Block_Comm(stem, ending);
    
        return ret;
    }        
    if(ACT_C == 1 && ACT_V == 0)
    {
        if(ULS >= __V_k || ULS == __K_R)             
            return MORECHECK;
        else    
        {
            if((ret = NLP_VCV_Proc(stem, ending)) == VCV_VALID)    
                if((ret = NLP_Blocking(stem, ending)) == Block_Comm)
                    ret = NLP_Block_Comm(stem, ending);
    
            return ret;
        }                
    }
    if(__IsDefEnd(llme , 3) == 1 && 
        end[llme] == __K_G && end[llme-1] == __V_j && 
        end[llme-2] == __K_R && end[llme-3] == __V_k)  
    {
        if((ret = NLP_Blocking(stem, ending)) == Block_Comm)
            ret = NLP_Block_Comm(stem, ending);

        return ret;
    }            
    if(__IsDefEnd(llme , 3) == 1 && 
        end[llme] == __K_N && end[llme-1] == __V_j && 
        end[llme-2] == __K_R && end[llme-3] == __V_k)  
    {
        if((ret = NLP_Blocking(stem, ending)) == Block_Comm)
            ret = NLP_Block_Comm(stem, ending);

        return ret;
    }            
    if(ULS >= __V_k || ULS == __K_R)      
    {
        if((ret = NLP_VCV_Proc(stem, ending)) == VCV_VALID)    
            if((ret = NLP_Blocking(stem, ending)) == Block_Comm)
                ret = NLP_Block_Comm(stem, ending);

        return ret;
    }            
    return MORECHECK;
}             

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_AUX_VCV_Check(char  *stem,
                                  char  *ending) 
{
    char    tmp[80],
            end[80];             
    int     ret, luls, llme;
        
    lstrcpy(tmp, stem);
    lstrcpy(end, ending);
    llme = AUX_LMEPOS;
    luls = AUX_ULSPOS;    
    
    if(AUX_ACT_C == 1 && AUX_ACT_V == 1)
    {
        if((ret = NLP_VCV_Proc(stem, ending)) == VCV_VALID)    
        {
            if((ret = NLP_AUX_Blocking(stem, ending)) == Block_Comm)
            {
                ret = NLP_Block_Comm(stem, ending);
            }
        }    
        return ret;
    }        
    if(AUX_ACT_C == 1 && AUX_ACT_V == 0)
    {
        if(stem[luls] >= __V_k || stem[luls] == __K_R)             
        {
            return MORECHECK;
        }            
        else    
        {
            if((ret = NLP_VCV_Proc(stem, ending)) == VCV_VALID)    
            {
                if((ret = NLP_AUX_Blocking(stem, ending)) == Block_Comm)
                {
                    ret = NLP_Block_Comm(stem, ending);
                }
            }    
            return ret;
        }                
    }
    if(stem[luls] >= __V_k || stem[luls] == __K_R)      
    {
        if((ret = NLP_VCV_Proc(stem, ending)) == VCV_VALID)    
        {
            if((ret = NLP_AUX_Blocking(stem, ending)) == Block_Comm)
            {
                ret = NLP_Block_Comm(stem, ending);
            }
        }
        return ret;
    }            
    return MORECHECK;
}   

// -------------------------------------------------------------------------------------
//

//
// -------------------------------------------------------------------------------------
int BaseEngine::NLP_AUX_Blocking(char  *aux_stem, 
                                 char  *aux_ending)
{
    char    tmp[80],
            end[80];
    int     lEND,
            lAUXULS;
            
    lstrcpy (tmp, aux_stem);
    lstrcpy (end, aux_ending);
    lAUXULS = AUX_ULSPOS;
    lEND = AUX_LMEPOS;
          
    switch (AUXLME)          
    {
        case __K_N :
            if(tmp[lAUXULS] == __K_R)  
            {
                return INVALID;
            }
            return Bloc_VALID;
        case __K_I :   
            if(__IsDefEnd(lEND, 2) == 1 && 
                end[lEND-1] == __V_m && end[lEND-2] == __K_N) 
            {                                   
// Temp -> Tempiss : by hjw 95/3/3
                if((__IsDefStem(lAUXULS, 3) == 1 && 
                     strcmp(tmp+(lAUXULS-3), Tempiss[0]) == 0) ||      
                    (__IsDefStem(lAUXULS, 2) == 1 && 
                     strcmp(tmp+(lAUXULS-2), Tempiss[1]) == 0) )       
                {                     
                    return INVALID;
                }                    
            }
            return Block_Comm;
    }
    return Bloc_VALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basesub.cpp ===
// =========================================================================
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// FILE NAME        : BASESUB.CPP
// Function         : BASE ENGINE FUNCTION COLLECTION
//                  : NLP Base Engine Function
// =========================================================================
#include "basesub.hpp"
#include "basegbl.hpp"
#include "stemkor.h"
#include "MainDict.h"

// ------------------------------------------------------------------------
//

//
// ------------------------------------------------------------------------
int NLP_Ge_Proc( char  *stem )
{
    for (int i = 0; i < 3; i++)
        if(strcmp(stem, TempNoun[i]) == 0)    return PRON_VALID;

    return BT;
}

// ------------------------------------------------------------------------
//

//
// ------------------------------------------------------------------------
int BaseEngine::NLP_Get_Ending( char  *incode,
                                char  *Act,
                                int   *sp,
                                int   Endflag)
{
    char    ending[40];
    BYTE    action;
    int     res,
            j = 1,
            codelen = lstrlen(incode) - 1;

    memset(ending, NULL, 40);

    sp[0] = -1;

    if(Endflag == 1)
        Act[0] = (unsigned char)0xf8;  // if there is no tossi : action code 1111-1000
    else
        Act[0] = 0x74;                   // if there is no endin : action code 0111-0100

    for (int i = 0; i <= codelen; i++)
    {
        ending[i] = incode[codelen-i];
        ending[i+1] = NULLCHAR;

        if(Endflag == 1)
            res = FindHeosaWord(ending, _TOSSI, &action);
        else
            res = FindHeosaWord(ending, _ENDING, &action);

        switch (res)
        {
        case FINAL :
        case FINAL_MORE :
            Act[j] = action;
            sp[j++] = i;                    // LMEPOS
            continue;
        case FALSE_MORE :
            continue;
        case NOT_FOUND :
            break;
        }
        break;
    }

    if (Endflag == 1 && sp [0] == 1)
    {
        sp [0] = 1;
        sp [1] = -1;
        Act [0] = Act [1];
        Act [1] = (unsigned char)0xf8;
    }


    Act[j] = NULL;
    sp[j] = NULL;

    return j;
}

// ------------------------------------------------------------------------
//

//
// ------------------------------------------------------------------------
int BaseEngine::NLP_Num_Proc(   char  *stem)
{
    char    t_stem[80];
    int        t_ulspos;


    if(ULSPOS == -1)  return BT;

    memset(t_stem, NULL, 80);
    lstrcpy(t_stem, stem);
    t_ulspos = lstrlen(t_stem)-1;


    int n = NumNoun.FindWord(t_stem, t_ulspos);


    if(n != -1)
    {
        if(NLP_CheckSuja(t_stem, t_ulspos) == VALID)   return NUM_VALID;
        else    return BT;
    }

    if(FindIrrWord(t_stem, _ZZNUM) & FINAL
        ) return NUM_VALID;

    if(NLP_CheckSuja(t_stem, t_ulspos) == VALID)   return NUM_VALID;

    return BT;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_CheckSuja(  char  *stem,
                                int ulspos)
{
    enum    STATE {_BASE, _NUM} currentstate;
            currentstate = _BASE;




    enum    OPERATION {_START, _NOSTART} currentphase;
            currentphase = _START;




    char    currentbase = -1;


    char    tempbase = -1;

    JumpNum.FindWord(stem, ulspos);



    for ( ; ulspos >= 0; )
    {
        switch (currentstate)
        {
            case _BASE :

                tempbase = (char)BaseNum.FindWord(stem, ulspos,currentbase+1);


                if(tempbase != -1)
                {
                    currentstate = _BASE;
                    currentbase = tempbase;

                    if(currentphase == _START)
                    {

                        for (int i = 0; i < 8; i++)
                            if(strcmp(stem,DoubleNum[i]) == 0)    return VALID;

                        currentphase = _NOSTART;
                    }
                    break;
                }
                if(currentphase == _START)
                {

                    for (int i = 0; i < 8; i++)
                        if(strcmp(stem, DoubleNum[i]) == 0)   return VALID;

                    currentphase = _NOSTART;
                    break;
                }
                if(SujaNum.FindWord(stem, ulspos) != -1)
                {
                    currentstate = _NUM;
                    break;
                }

                return INVALID;
            case _NUM :

                tempbase = (char)BaseNum.FindWord(stem, ulspos, currentbase+1);


                if(tempbase != -1)
                {
                    currentstate = _BASE;
                    currentbase = tempbase;
                    break;
                }

                return INVALID;
         }
    }
    return VALID;
}

// ----------------------------------------------------------------------
//

//
// ----------------------------------------------------------------------
int BaseEngine::NLP_NCV_Proc(   char  *stem,
                                char  *ending)
{
    int    lULS;

    lULS = lstrlen(stem) - 1;

    if(ACT_C == 1 && ACT_V == 1)   return NCV_VALID;

    if(ACT_C == 0 && ACT_V == 1)
    {
        if(stem[lULS] >= __V_k)    return NCV_VALID;

        if(LME == __K_R && ending[LMEPOS-1] == __V_h &&
            __IsDefEnd(LMEPOS, 1) == 1)
            if(stem[lULS] == __K_R)    return NCV_VALID;

        return BT;
    }

    if(stem[lULS] >= __V_k)    return BT;

    if(stem[lULS] == __K_R && __IsDefEnd(LMEPOS, 3) == 1 &&
        ending[LMEPOS] == __K_I && ending[LMEPOS-1] == __V_m &&
        ending[LMEPOS-2] == __K_R && ending[LMEPOS-3] == __V_h) return BT;


    return NCV_VALID;
}

// ----------------------------------------------------------------------
//
//  To process affix
//
// ----------------------------------------------------------------------
int BaseEngine::NLP_Fix_Proc(char  *stem, char  *ending)
{
    char    prestem[80],
            bufstem[80],
            suffix [80],
            prefix [80],
            index[1];
    int     ulspos, temp;

    prefix [0] = '\0';
    suffix [0] = '\0';
    lstrcpy(prestem, stem);
    ulspos = ULSPOS;

    if(__IsDefStem(ULSPOS, 2) == 1 &&
       prestem[ULSPOS-2] == __K_D && prestem[ULSPOS-1] == __V_m && prestem[ULSPOS] == __K_R)
    {
        if(lstrlen(ending) == 0 || ACT_P_A == 1)   // sp == 0 || ACT_P_A == 1
        {

            if(FindIrrWord(stem, _ZPN) & FINAL)
            {
                int len = lstrlen (stem);
                memcpy (suffix, stem+len-3, 4);
                stem [len-3] = '\0';
                char tstem [80];
                Conv.INS2HAN(stem, tstem, codeWanSeong);
                lstrcat (lrgsz, tstem);
                vbuf [wcount++] = POS_PRONOUN;
                lstrcat (lrgsz, "+");
                Conv.INS2HAN(suffix, tstem, codeWanSeong);
                lstrcat(lrgsz, tstem);
                vbuf [wcount++] = POS_SUFFIX;
                return Deol_VALID;
            }
        }
        temp = ulspos;
        __DelStemN(prestem, &temp, 3);
        ulspos = temp;
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (prestem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)
        {
            int len = lstrlen (stem);
            memcpy  (suffix, stem+len-3, 4);
            lstrcpy (stem, prestem);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            Conv.INS2HAN(suffix, tstem, codeWanSeong);
            lstrcat(lrgsz, tstem);
            vbuf [wcount++] = POS_SUFFIX;
            return Deol_VALID;
        }
        return MORECHECK;
    }

    if(PrefixCheck(prestem, bufstem) != -1)
    {
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (bufstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)
        {
            int len = lstrlen(stem) - lstrlen(bufstem);
            memcpy (prefix, stem, len);
            prefix [len] = '\0';
            lstrcpy (stem, bufstem);
            Conv.INS2HAN(prefix, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_PREFIX;
            lstrcat (lrgsz, "+");
            Conv.INS2HAN(stem, tstem, codeWanSeong);
            lstrcat(lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            return Pref_VALID;
        }
    }

    if(Suffix.FindWord(prestem, ulspos) != -1)
    {
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (prestem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)
        {
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            Conv.INS2HAN(stem+lstrlen(prestem), tstem, codeWanSeong);
            lstrcat(lrgsz, tstem);
            vbuf [wcount++] = POS_SUFFIX;
            return Suf_VALID;
        }
    }

    lstrcpy(prestem, stem);
    ulspos = ULSPOS;
    if(Suffix.FindWord(prestem, ulspos) != -1 &&
       PrefixCheck(prestem, bufstem) != -1)
    {
        index[0] = 'm';
        char tstem [80];
        Conv.INS2HAN (bufstem, tstem, codeWanSeong);
        if (FindSilsaWord (tstem) & _NOUN)
        {
            prestem [lstrlen(prestem) - lstrlen(bufstem)] = 0;
            Conv.INS2HAN(prestem, tstem, codeWanSeong);
            lstrcat (lrgsz, tstem);
            vbuf [wcount++] = POS_PREFIX;
            lstrcat (lrgsz, "+");
            Conv.INS2HAN(bufstem, tstem, codeWanSeong);
            lstrcat(lrgsz, tstem);
            vbuf [wcount++] = POS_NOUN;
            lstrcat (lrgsz, "+");
            Conv.INS2HAN(stem + lstrlen (prestem) + lstrlen (bufstem), tstem, codeWanSeong);
            lstrcat(lrgsz, tstem);
            vbuf [wcount++] = POS_SUFFIX;
            return PreSuf_VALID;
        }
    }
    return MORECHECK;
}

int BaseEngine::NLP_Find_Pronoun(char  *stem, char  *ending)
{
    if(FindIrrWord(stem, _ZPN) & FINAL)
    {
        if ((ending [0] == __V_k && ending [1] == __K_G) ||
        (ending [0] == __V_p && ending [1] == __K_G))
        {
            if ((stem [0] == __K_N && stem [1] == __V_j) ||
                (stem [0] == __K_N && stem [1] == __V_k) ||
                (stem [0] == __K_J && stem [1] == __V_j))
            {
                return MORECHECK;
            }
            else if (stem [0] == __K_N && stem [1] == __V_o)
            {
                stem [1] = __V_k;
            }
            else if (stem [0] == __K_N && stem [1] == __V_p)
            {
                stem [1] = __V_j;
            }
            else if (stem [0] == __K_J && stem [1] == __V_p)
            {
                stem [1] = __V_j;
            }
        }
        else
        {
            int len = lstrlen (stem) - 1;

            if (len > 4 && stem [len] == __K_D && stem [len - 1] == __V_m && stem [len - 2] == __K_R)
                stem [len-2] = '\0';
        }
        char tstem [80];
        Conv.INS2HAN (stem, tstem, codeWanSeong);
        lstrcat (lrgsz, tstem);
        vbuf [wcount++] = POS_PRONOUN;
        return VALID;
    }

    return MORECHECK;
}

// ------------------------------------------------------------------
//

//
// ------------------------------------------------------------------
int PrefixCheck(char  *stem,
                char  *prestem)
{
    int     i,
            j,
            l,
            PreLen,
            WordLen;
    char    buf1[5],
            buf2[5];

    i = 0;
    PreLen = 9;
    WordLen = 5;

    while (i < PreLen)
    {
        j = TempPrefix[(i*WordLen)+4];
        memset(buf1, NULL, 5);

        for (l = 0; l <= j; l++)    buf1[l] = TempPrefix[(i*WordLen)+l];

        memset(buf2, NULL, 5);

        for (l = 0; l <= j; l++)    buf2[l] = stem[l];

        if(strcmp(buf1, buf2) == 0)
        {                           //found
            j = 0;
            memset(prestem, NULL, 80);

            while (stem[l] != 0x00) prestem[j++] = stem[l++];

            return 1;
        }
        i++;
    }
    return -1;
}

void SetSilHeosa (int ivalue, WORD *rvalue)
{
    switch (ivalue&0x0f00)
    {
        case POS_NOUN : ivalue |= wtSilsa; break;
        case POS_VERB : ivalue |= wtSilsa; break;
        case POS_SUFFIX :
            if ((ivalue&0x00ff) == DEOL_SUFFIX)
                ivalue |= wtHeosa;
            else
                ivalue |= wtSilsa;
            break;
        case POS_PREFIX : ivalue |= wtSilsa;    break;
        case POS_ADJECTIVE : ivalue |= wtSilsa; break;
        case POS_PRONOUN : ivalue |= wtSilsa;   break;
        case POS_NUMBER : ivalue |= wtSilsa;    break;
        case POS_AUXADJ : ivalue |= wtHeosa;    break;
        case POS_AUXVERB : ivalue |= wtHeosa;   break;
        case POS_OTHERS : ivalue |= wtHeosa;    break;
        case POS_TOSSI : ivalue |= wtHeosa;     break;
        case POS_ENDING : ivalue |= wtHeosa;    break;
        case POS_SPECIFIER : ivalue |= wtHeosa; break;
    }

    *rvalue = (WORD)ivalue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\basevsub.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#include <stdlib.h>
#include <string.h>
#include <io.h>
#include "basecore.hpp"


char    bTemp[] = {__K_B_D, __V_n, __K_N, 0, 2}; 
char    TempRa[2][5] = 
        {
            {__V_k,__K_R,__V_j,__K_G,0},    
            {__V_k,__K_R,__V_j,__K_N,0}     
        };
char    Tempiss[2][5] = 
        {
            {__K_I,__V_j,__K_B,  __K_S, 0},    
            {__K_I,__V_l,__K_S_D,    0, 0}     
        };
char    TempBC[] = {__K_P, __V_n, 0};


char TempETC[] = {
        __K_I,  __V_p, __K_S, __V_j, __K_B, __V_n, __K_T, __V_j, 0, 7,     
        __K_S,  __V_j, __K_B, __V_n, __K_T, __V_j,     0,     0, 0, 5,     
        __K_I,  __V_p, __K_S, __V_j, __K_M, __V_k, __K_N,     0, 0, 6,     
        __K_D,  __V_o, __K_R, __V_h,     0,     0,     0,     0, 0, 3,     
        __K_I,  __V_p, __K_S, __V_j,     0,     0,     0,     0, 0, 3,     
        __K_B,  __V_n, __K_T, __V_j,     0,     0,     0,     0, 0, 3,     
        __K_G_D,__V_k, __K_J, __V_l,     0,     0,     0,     0, 0, 3      
};

char    TempDap[] = {__K_D, __V_k, __K_B, 0, 2};   

// change some hard code of DBCS string to char array.

char SangP_U_N[3] ={'\xBB','\xD3',0};               
char Ieung_I[3]   ={'\xC0','\xCC',0};               
char Tikeut_A_P[3]={'\xB4','\xE4',0};               
char KO_PHEU[5]   ={'\xB0','\xED','\xC7','\xC1',0}; 
char MAN_HA[5]    ={'\xB8','\xB8','\xC7','\xCF',0}; 
char IYEON_HA[5]  ={'\xBF','\xAC','\xC7','\xCF',0}; 
char MAN_HAE_CI[7]={'\xB8','\xB8','\xC7','\xD8','\xC1','\xF6',0};
                                                   
                                                     
LenDict B_Dict;
LenDict T_Dict;
LenDict Dap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\cho2in.hpp ===
// =========================================================================
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
// =========================================================================

#define CHO        20
#define CHUNG    22
#define CHONG    28

static char     MapI2[CHUNG] = {' ',23,24,25,26,27,28,29,30,31,33,34,35,36,37,38,39,40,41,42,43,44};
static char     MapI3[CHONG][3] = {' ',0x00,0x00,   
                            1,0x00,0x00,         // KIYEOK
                            2,0x00,0x00,         // SSANGKIYEOK
                            1,13,0x00,           // KIYEOK-SIOS
                            3,0x00,0x00,         // NIEUN
                            3,16,0x00,           // NIEUN-CIEUC
                            3,22,0x00,           // NIEUN-HIEUH
                            5,0x00,0x00,         // TIKEUT
                            7,0x00,0x00,         // RIEUL
                            7,1,0x00,            // RIEUL-KIYEOK
                            7,10,0x00,              // RIEUL-MIEUM
                            7,11,0x00,           // RIEUL-PIEUP
                            7,13,0x00,              // RIEUL-SIOS
                            7,20,0x00,              // RIEUL-THIEUTH
                            7,21,0x00,              // RIEUL-PIEUPH
                            7,22,0x00,              // RIEUL-HIEUH
                            10,0x00,0x00,          // MIEUM
                            11,0x00,0x00,         // PIEUP
                            11,13,0x00,          // PIEUP-SIOS
                            13,0x00,0x00,        // SIOS
                            14,0x00,0x00,        // SSANGSIOS
                            15,0x00,0x00,        // IEUNG
                            16,0x00,0x00,           // CIEUC
                            18,0x00,0x00,        // CHIEUCH
                            19,0x00,0x00,        // KHIEUKH
                            20,0x00,0x00,        // THIEUTH
                            21,0x00,0x00,        // PIEUPH
                            22,0x00,0x00,        // HIEUH
                        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\convert.cpp ===
//////////////////////////////////////////////////
//
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// File    : CONVERT.CPP
// Project : Project SIK
//
//////////////////////////////////////////////////

#define _UNICODE
#include <string.h>
#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>

#include "convert.hpp"
#include "cho2in.hpp"
#include "basedef.hpp"
#include "stemkor.h"
#include "unitoint.h"

void CODECONVERT::AppendIN(char  *s, char  *d, int  &wordptr)



{
        for (int j = 0; s[j] != 0; j++)
                d[wordptr++] = s[j];
        d[wordptr] = NULLCHAR;
}

void CODECONVERT::ReverseIN(char  *w, char  *rw)

{
        int i = lstrlen(w) - 1;

        for (int j = 0; j <= i; j++)
                rw[j] = w[i-j];
        rw[j] = NULLCHAR;
}

void CODECONVERT::AppendHAN(WCHAR s, WCHAR *d, int  &wordptr)



{
        d[wordptr++] = s;
        d[wordptr] = NULLCHAR;
}

void CODECONVERT::ReverseHAN(WCHAR *w, WCHAR *rw)

{
        int i = wcslen(w) - 1;

        for (int j = 0; j <= i; j++) {
                rw[j] = w[i-j];
        }
        rw[j] = NULLCHAR;
}

int CODECONVERT::HAN2INS(char  *wansung, char  *internal, int code)

{

    if(code == codeWanSeong)
    {
        LPWSTR unicode;
        int len;

        len = MultiByteToWideChar(UWANSUNG_CODE_PAGE, 0, wansung, -1, NULL, 0);
        unicode = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * len);
// add a check for this point
        if (unicode == NULL ) {
           return FALSE;
        }

        len = MultiByteToWideChar (UWANSUNG_CODE_PAGE, 0, wansung, -1, unicode, len);
        UniToInternal(unicode, internal, len-1);

// we must free the memory.
        LocalFree(unicode);
    }
    else
        return FALSE;

    return SUCCESS;
}

int CODECONVERT::HAN2INR(char  *h, char  *rc, int code)

{
    char c[80];

    _fmemset(c, NULL, 80);
    if (HAN2INS(h, c, code) == SUCCESS)
    {
        ReverseIN(c, rc);
        return SUCCESS;
    }
    else
    {
        return FAIL;
    }
}





// Commented by hjw
int CODECONVERT::INR2HAN(char  *c, char  *h, int code)

{
    char flag=NULLCHAR;
    char incode[5], rcode[5];
    WCHAR rh[80], hcode, unicode [80];

    _fmemset(incode, NULL, 5);
    _fmemset(rcode, NULL, 5);

    rh [0] = 0;

    int WP = 0, i = 0;

    int wordptr = 0;
    while (c[WP] != NULLCHAR)
    {
        incode[i] = c[WP++];
        if (incode[i] < __V_k)
        {
            if ((flag == 1) || (c[WP] == 0))
            {
                incode[i+1] = NULLCHAR; i = 0; flag = 0;
            }
            else
            {
                i++;
            }
        }
        else
        {
            if ((c[WP] == 0) || (c[WP] >= __V_k))
            {
                incode[i+1] = NULLCHAR; i = 0; flag = 0;
            }
            else
            {
                flag = 1;       i++;
            }
        }

        if (i == 0)
        {
            ReverseIN(incode, rcode);
            IN2UNI(rcode, &hcode);
            AppendHAN(hcode, rh, wordptr);
        }
    }
    ReverseHAN(rh, unicode);
    if (code == codeWanSeong)
    {
      WideCharToMultiByte (UWANSUNG_CODE_PAGE, 0, unicode, -1, h, wcslen (unicode)*2+1, NULL, NULL);
    }

    return SUCCESS;
}

int CODECONVERT::INS2HAN(char  *c, char  *h, int code)

{
    char rc[80];

    _fmemset(rc, NULL, 80);
    ReverseIN(c, rc);
    if(INR2HAN(rc, h, code) == FAIL)
    {
        return FAIL;
    }
    return SUCCESS;
}


// Cho sung mapping table
static
WORD ChoSungUniTable[] =
{
    0x0000,                // Fill code
    0xAC00,                // KIYEOK            1
    0xAE4C,                // SSANGKIYEOK       2
    0xB098,                // NIEUN             3
    0x0000,                // SSANGNIEUN        4    // not used
    0xB2E4,                // TIKEUT            5
    0xB530,                // SSANGTIKEUT       6
    0xB77C,                // RIEUL             7
    0x0000,                // SSANGRIEUL        8    // not used
    0x0000,                // not defined       9
    0xB9C8,                // MIEUM            10
    0xBC14,                // PIEUP            11
    0xBE60,                // SSANGPIEUP       12
    0xC0AC,                // SIOS             13
    0xC2F8,                // SSANGSIOS        14
    0xC544,                // IEUNG            15
    0xC790,                // CIEUC            16
    0xC9DC,                // SSANGCIEUC       17
    0xCC28,                // CHIEUCH          18
    0xCE74,                // KHIEUKH          19
    0xD0C0,                // THIEUTH          20
    0xD30C,                // PHIEUPH          21
    0xD558,                // HIEUH            22
};

// Cho sung mapping table
static
WORD JamoUniTable[] =
{
    0x0000,                // Fill code
    0x3131,                // KIYEOK            1
    0x3132,                // SSANGKIYEOK       2
    0x3134,                // NIEUN             3
    0x0000,                // SSANGNIEUN        4    // not used
    0x3137,                // TIKEUT            5
    0x3138,                // SSANGTIKEUT       6
    0x3139,                // RIEUL             7
    0x0000,                // SSANGRIEUL        8    // not used
    0x0000,                // not defined       9
    0x3141,                // MIEUM            10
    0x3142,                // PIEUP            11
    0x3143,                // SSANGPIEUP       12
    0x3145,                // SIOS             13
    0x3146,                // SSANGSIOS        14
    0x3147,                // IEUNG            15
    0x3148,                // CIEUC            16
    0x3149,                // SSANGCIEUC       17
    0x314A,                // CHIEUCH          18
    0x314B,                // KHIEUKH          19
    0x314C,                // THIEUTH          20
    0x314D,                // PHIEUPH          21
    0x314E,                // HIEUH            22

    0x314F,                // A                23
    0x3150,                // AE               24
    0x3151,                // YA               25
    0x3152,                // YAE              26
    0x3153,                // EO               27
    0x3154,                // E                28
    0x3155,                // YEO              29
    0x3156,                // YE               30
    0x3157,                // O                31
    0x3158,                // WA               33
    0x3159,                // WAE              34
    0x315A,                // OE               35
    0x315B,                // YO               36
    0x315C,                // U                37
    0x315D,                // WEO              38
    0x315E,                // WE               39
    0x315F,                // WI               40
    0x3160,                // YU               41
    0x3161,                // EU               42
    0x3162,                // YI               43
    0x3163                 // I                44
};


int CODECONVERT::IN2UNI(char  *c, WORD *wch)
{
    if (lstrlen(c) > 1 && c [0] < __V_k && c [1] >= __V_k)
    {
        *wch = ChoSungUniTable [(int) c [0]];
        char stTmp [3];

        for (int i2 = 0; i2 < CHUNG; i2++)
            if (MapI2 [i2] == c [1])
                break;

        *wch += (i2 - 1) * CHONG;

        if (lstrlen(c) > 2)
        {
            stTmp[0]=c[2];
            stTmp[1]=c[3];
            stTmp[2]='\0';
            for(int i3 = 0;i3 < CHONG;i3 ++)
                if (! (strcmp(MapI3[i3], stTmp)))
                {
                    *wch += (WORD)i3;
                    break;
                }
        }

    }
    else if (lstrlen (c) == 1)
        *wch = JamoUniTable [(int) c [0]];


    // BUG : SSANGJAMO

    return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\bsfiledict.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
//#include "stdafx.h"

#include "pch.cxx"

#include "BSDict.h"
#ifdef _INSTRUMENT
#include "clog.h"
#endif

#include "Hash.h"
static    CWordHash    wordHash;

BYTE CDoubleFileBSDict::lpBuffer[MAX_BUFFER_SIZE];
BYTE *CDoubleFileBSDict::lpCurIndex;

void CDoubleFileBSDict::LoadIndex(HANDLE hInput)
{
    DWORD    readBytes;
//    _ASSERT(hInput != NULL);

    // read index header
    LoadIndexHeader(hInput);

    // Alloc indexes
    hIndex = GlobalAlloc(GPTR, GetIndexSize() * GetNumOfBlocks());
    Assert( hIndex != NULL );
    lpIndex = (BYTE *)GlobalLock(hIndex);
    Assert( lpIndex != NULL);
    // read indexes
    ReadFile(hInput, lpIndex, GetIndexSize() * GetNumOfBlocks(), &readBytes, NULL);
}

void CDoubleFileBSDict::LoadIndexHeader(HANDLE hInput)
{
    DWORD readBytes;
    ReadFile(hInput, m_pIndexHeader, sizeof(_IndexHeader), &readBytes, NULL);
//    _ASSERT(readBytes == sizeof(_IndexHeader));
}

int CDoubleFileBSDict::FindWord(HANDLE hDict, DWORD fpBlock, LPCTSTR lpStr)
{
    int indexNum;
    BYTE pumsa = 0;
    DWORD readBytes;
    int  numWords, wordNum;
    static int      curBufferWordLen, curBufIndexNum;


//#ifdef _INSTRUMENT
//numOfComp =0;
//#endif

    indexNum =  FindIndex(lpStr, 0, GetNumOfBlocks()-1, &pumsa);

    if (pumsa) return pumsa;
    else {
        // Search Cache Block
    #ifdef _INSTRUMENT
        _Log.IncreaseTotalAccess(lpStr);
    #endif
        if (wordHash.Find(lpStr, &pumsa)==TRUE) {
        #ifdef _INSTRUMENT
            _Log.IncreaseHit();
        #endif
            if (pumsa)    // if word found in cache
                return pumsa;
            else return 0;
        } else {
            // Check if aleady in buffer
            if ( (curBufferWordLen == GetWordLen()) && (curBufIndexNum == indexNum) )
            #ifdef _INSTRUMENT
                _Log.IncreaseHit();
            #else
                ;
            #endif
            else {
                // read a candidate block 
                SetFilePointer(hDict, fpBlock + indexNum*GetBlockSize(), 0, FILE_BEGIN);
                ReadFile(hDict, lpBuffer, GetBlockSize(), &readBytes, 0);
                curBufferWordLen = GetWordLen(); curBufIndexNum = indexNum;
                #ifdef _INSTRUMENT
                    _Log.IncreaseFail();
                #endif
            }
        }
        numWords = *(WORD*)(lpCurIndex+GetIndexSize() - sizeof(WORD));
        if ( (wordNum = FindBlock(lpStr, 0, numWords-1))!=-1) {
            pumsa = *(lpBuffer+numWords*GetWordByteLen() + wordNum);
            //
            wordHash.Add(lpStr, pumsa);
            // 
            return pumsa;
        }
        else {
            wordHash.Add(lpStr, pumsa);
            return 0;
        }
    }
    return 0;
}

int CDoubleFileBSDict::FindIndex(LPCTSTR lpWord, int left, int right, BYTE *pumsa)
{
    int middle, flag;
    
    while (left < right) {
        middle = (left+right)>>1;
        lpCurIndex = lpIndex + middle * GetIndexSize();
        switch ( (flag = Comp(LPCTSTR(lpCurIndex), lpWord)) ) {
        case -1 : left = middle + 1;
                  break;
        case  0 : *pumsa = *(lpCurIndex + GetWordByteLen());
                  return middle;
        case  1 : right = middle - 1;
        }
    }
    
    lpCurIndex = lpIndex + left * GetIndexSize();
    if ( (flag = Comp(LPCTSTR(lpCurIndex), lpWord)) == 0) {
        *pumsa = *(lpCurIndex + GetWordByteLen());
        return left;
    }

    if (left && flag==1) {
        lpCurIndex -= GetIndexSize();
        return left-1;
    } else 
        return left;
}

int CDoubleFileBSDict::FindBlock(LPCTSTR lpWord, int left, int right)
{
    int middle;

    while (left <= right) {
        middle = (left+right)>>1;
        switch ( Comp(LPCTSTR(lpBuffer+middle*GetWordByteLen()), lpWord) ) {
        case -1 : left = middle + 1;
                  break;
        case  0 : return middle;
        case  1 : right = middle - 1;
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\compose.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// COMPOSE.CPP
//        These funtions is to compose the word with stem and ending.
//        If you want to understand more details, get the flow chart.
//        made by dhyu 1996. 2
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "basedef.hpp"
#include "basedict.hpp"
#include "basegbl.hpp"
#include "ReadHeosaDict.h"

/*
extern char far _IA_BP,     // a3+      : PIEUP irregular light adjective
            far _RA_B,      // a3r      : PIEUP regular light adjective
            far _IA_HP,     // a5+      : HIEUH irregular light adjective
            far _IA_HM,     // a5-      : HIEUH irregular dark adjective
            far _IA_RmP,    // a6+      : REU irregular light adjective
            far _IA_RmM,    // a6-      : REU irregular dark adjective
            far _IA_Rj,     // a7       : REO irregular adjective
            far _IA_OmP,    // a8+      : EU irregular light adjective
            far _IA_OmM,    // a8-      : EU irregular dark adjective
            far _IV_DP,     // v2+      : TIEUT irregular light verb
            far _IV_DM,     // v2-      : TIEUT irregular dark verb
            far _IV_Gj,     // v0       : GEORA irregular verb
            far _IV_Nj,     // v1       : NEORA irregular verb
            far _RV_D,      // v2r      : TIEUT regular verb
            far _IV_BP,     // v3+      : PIEUP irregular light verb
            far _IV_BM,     // v3-      : PIEUP irregular dark verb
            far _IV_SP,     // v4+      : SIOS irregular light verb
            far _IV_SM,     // v4-      : SIOS irregular dark verb
            far _IV_RmP,    // v6+      : REU irregular light verb
            far _IV_RmM,    // v6-      : REU irregular dark verb
            far _IV_Rj,     // v7       : REO irregular verb
            far _IV_OmP,    // v8+      : EU irregular light verb
            far _IV_OmM;    // v8-      : EU irregular dark verb
*/
// check wether right most vowel of stem is light vowel, or not
// stem should be reverse order
BOOL CheckRightMostStemVowel (char *stem)
{
    char vowel;

    if (stem [0] < __V_k)    
        vowel = stem [1];
    else
        vowel = stem [0];

    switch (vowel)
    {
        case __V_k :
        case __V_i :
        case __V_h : return TRUE;
    }

    return FALSE;
}

int Compose_RIEUL_Irregular (char *stem, char *ending)
{
    int i, len;
    char *inheosa;

    if (stem [0] == __K_R)
    {
        switch (ending [0])
        {
            case __K_I :
                switch (ending [1])
                   {
                        case __V_j :
                            if (CheckRightMostStemVowel (stem))            // vowel harmony
                                ending [1] = __V_k;
                            return COMPOSED;
                        case __V_m :
                            if (ending [2] != __K_M)
                                memmove (stem, stem + 1, lstrlen (stem)); // remove "RIEUL"            
                            memmove (ending, ending + 2, lstrlen (ending+1));    // remove "IEUNG, EU"
                            return COMPOSED;
                        default : return COMPOSE_ERROR;
                   }
            case __K_S :
                memmove (stem, stem + 1, lstrlen (stem)); // remove "RIEUL"
                if (ending [1] == __V_m)
                    memmove (ending, ending + 2, lstrlen (ending+1));    // remove "SIOS, EU"
                return COMPOSED;
            case __K_N :
                memmove (stem, stem + 1, lstrlen (stem)); // remove "RIEUL"
                len = lstrlen(ending);
                inheosa = new char [len+1];
                for (i = 0; i < len; i++)
                    inheosa [i] = ending [len-1-i];
                inheosa [i] = '\0';
                BYTE action;
                FindHeosaWord (inheosa, _ENDING, &action);
                if ((action & 0x80) && !(action & 0x40)) // if CV = 10
                    memmove (ending, ending + 2, lstrlen (ending+1));    // remove "NIEUN, EU"
                return COMPOSED;
            case __K_G :
            case __K_D :
            case __K_J : return COMPOSED;
            default : return COMPOSE_ERROR;
        }
    }

    return NOT_COMPOSED;
}
    
int Compose_HIEUH_Irregular (char *stem, char *ending)
{

    if (stem [0] == __K_H)
    {
        int len = lstrlen(stem);
        char * inheosa = new char [len+1];
        for (int i = 0; i < len; i++)
            inheosa [i] = stem [len-1-i];
        inheosa [i] = '\0';
        switch (ending [0])
        {
            case __K_I :
                if (FindIrrWord(inheosa, _IA_HP) & FINAL ||   // HIEUH irregular light adjective (A5+)
                    FindIrrWord(inheosa, _IA_HM) & FINAL)     // HIEUH irregular dark adjective (A5-)
                {            
                    switch (ending [1])
                    {
                        case __V_j :                                 // "IEUNG, EO"
                            memmove (stem, stem+1, lstrlen(stem));    // remove "HIEUH"
                            memmove (ending, ending + 2, lstrlen (ending+1));    // remove "IEUNG, EO"
                            switch (stem [0])
                            {
                                case __V_k : stem [0] = __V_o; return COMPOSED;
                                case __V_j : stem [0] = __V_p; return COMPOSED;
                                case __V_i : stem [0] = __V_O; return COMPOSED;
                                case __V_u : stem [0] = __V_P; return COMPOSED;
                                default : return COMPOSE_ERROR;
                            }
                        case __V_m :                                            // "IEUNG, EU"
                            memmove (stem, stem+1, lstrlen(stem));                // remove "HIEUH"
                            memmove (ending, ending + 2, lstrlen (ending+1));    // remove "IEUNG, EU"
                            return COMPOSED;
                        default :    
                            return COMPOSE_ERROR;
                    }
                }
                switch (ending [1])
                {
                    case __V_j :    
                        if (CheckRightMostStemVowel (stem))            // vowel harmony
                            ending [1] = __V_k;
                        return COMPOSED;
                    case __V_m :    return COMPOSED;
                    default :        return COMPOSE_ERROR;
                }
            case __K_N :                                // "NIEUN"
                if (FindIrrWord(inheosa, _IA_HP) & FINAL ||   // HIEUH irregular light adjective (A5+)
                    FindIrrWord(inheosa, _IA_HM) & FINAL)     // HIEUH irregular dark adjective (A5-)
                    memmove (stem, stem+1, lstrlen(stem));            // remove "HIEUH"
                return COMPOSED;
            case __K_G :
            case __K_S :
            case __K_J : return COMPOSED;
            default : return COMPOSE_ERROR;
        }        
    }

    return NOT_COMPOSED;
}


int Compose_PIEUP_Irregular (char *stem, char *ending)
{
    if (stem [0] == __K_B)
    {
        int len = lstrlen(stem);
        char * inheosa = new char [len+1];
        for (int i = 0; i < len; i++)
            inheosa [i] = stem [len-1-i];
        inheosa [i] = '\0';
        if    (FindIrrWord(inheosa, _IV_BP) & FINAL || // PIEUP irregular light verb (V3+)
             FindIrrWord(inheosa, _IA_BP) & FINAL)   // PIEUP irregular light adjective (A3+)
        {
            if (ending [0] == __K_I)
            {
                if (ending [1] == __V_j)
                {
                    // "PIEUP, IEUNG, EO" --> "IEUNG, WA"
                    memmove (stem, stem+1, lstrlen(stem));
                    ending [1] = __V_hk;
                    return COMPOSED;
                }
                if (ending [1] == __V_m)            // "IEUNG, EU"
                {
                    // "PIEUP, IEUNG, EU" --> "IEUNG, U"
                    memmove (stem, stem+1, lstrlen(stem));            // remove "PIEUP"
                    ending [1] = __V_n;
                    return COMPOSED;
                }
            }
            return COMPOSED;
        }
        char Temp [] = {
            __K_G_D, __V_h, __K_B,     0, 0, 1,
            __K_B,   __V_k, __K_R, __K_B, 0, 2,
            __K_B_D, __V_h, __K_B,     0, 0, 1,
            __K_S_D, __V_l, __K_B,     0, 0, 1,
            __K_I,   __V_j, __K_B,     0, 0, 1,
            __K_I,   __V_l, __K_B,     0, 0, 1,
            __K_J,   __V_k, __K_B,     0, 0, 1,
            __K_J,   __V_j, __K_B,     0, 0, 1,
            __K_J,   __V_l, __K_B,     0, 0, 1
        };

        LenDict RV_B (Temp, 6, 9);
        int eulpos = lstrlen (inheosa) - 1;
        if (FindIrrWord(inheosa, _RA_B) & FINAL ||    // PIEUP regular adjective (a3r)
            RV_B.FindWord(inheosa, eulpos) != -1)            // PIEUP regular verb
        {
            if (ending [0] == __K_I && ending [1] == __V_j)            // "IEUNG, EO"
            {
                if (CheckRightMostStemVowel (stem))                        // vowel harmony
                    ending [1] = __V_k;
            }
            return COMPOSED;
        }
        if (ending [0] == __K_I)
        {
            if (ending [1] == __V_j)
            {
                // "PIEUP, IEUNG, EO" --> "IEUNG, WA"
                memmove (stem, stem+1, lstrlen(stem));
                ending [1] = __V_hk;
                return COMPOSED;
            }
            if (ending [0] == __K_I && ending [1] == __V_m)            // "IEUNG, EU"
            {
                memmove (stem, stem+1, lstrlen(stem));            // remove "HIEUH"
                memmove (ending, ending + 2, lstrlen (ending+1));    // "IEUNG, EU" --> "IEUNG"
                return COMPOSED;
            }
        }
        return COMPOSED;
    }

    return NOT_COMPOSED;
}

int Compose_TIEUT_Irregular (char *stem, char *ending)
{
    int i, len;
    char *inheosa;

    if (stem [0] == __K_D)
    {
        if (ending [0] == __K_I)
        {
            switch (ending [1])
            {
                case __V_j :            // "EO"
                    if (CheckRightMostStemVowel (stem))                        // vowel harmony
                        ending [1] = __V_k;
                case __V_m :            // "EU"
                    len = lstrlen(stem);
                    inheosa = new char [len+1];
                    for (i = 0; i < len; i++)
                        inheosa [i] = stem [len-1-i];
                    inheosa [i] = '\0';
                    if (FindIrrWord(inheosa, _IV_DP) & FINAL ||   // TIEUT irregular light verb (V2+)
                        FindIrrWord(inheosa, _IV_DM) & FINAL)     // TIEUT irregular dark verb (V2-)
                    {            
                        stem [0] = __K_R;
                    }
                    return COMPOSED;
                default : return COMPOSE_ERROR;
            }

        }

        return COMPOSED;
    }

    return NOT_COMPOSED;
}

int Compose_SIOS_Irregular (char *stem, char *ending)
{
    int len, i;
    char *inheosa;

    if (stem [0] == __K_S)
    {
        if (ending [0] == __K_I)
        {
            switch (ending [1])
            {
                case __V_j :            // "EO"
                    if (CheckRightMostStemVowel (stem))                        // vowel harmony
                        ending [1] = __V_k;
                case __V_m :            // "EU"
                    len = lstrlen(stem);
                    inheosa = new char [len+1];
                    for (i = 0; i < len; i++)
                        inheosa [i] = stem [len-1-i];
                    inheosa [i] = '\0';
                    if (FindIrrWord(inheosa, _IV_SP) & FINAL ||   // SIOS irregular light verb (V2+)
                        FindIrrWord(inheosa, _IV_SM) & FINAL)     // SIOS irregular dark verb (V2-)
                    {            
                        memmove (stem, stem+1, lstrlen(stem));        // remove SIOS
                    }
                    return COMPOSED;
                default : return COMPOSE_ERROR;
            }

        }

        return COMPOSED;
    }

    return NOT_COMPOSED;
}

BOOL Compose_YEO_Irregular (char *stem, char *ending)
{

    if (stem [0] == __K_H && stem [1] == __V_k)                    // The last of stem is "HA"
    {
        if (ending [0] == __K_I && ending [1] == __V_m)            // The first of ending is "EU"
            memmove (ending, ending + 2, lstrlen (ending+1));    // remove "IEUNG, EU"
        if (ending [0] == __K_I && ending [1] == __V_j)
        {
            memmove (stem, stem+1, lstrlen (stem));            // remove "A" : the last letter of stem
            // "IEUNG, EO" --> "AE"
            memmove (ending, ending+1, lstrlen (ending));
            ending [0] = __V_o;
        }

        return TRUE;
    }

    return FALSE;
}

void Compose_EU_Irregular (char *stem, char *ending)
{
    int len = lstrlen(stem);
    char * inheosa = new char [len+1];
    for (int i = 0; i < len; i++)
        inheosa [i] = stem [len-1-i];
    inheosa [i] = '\0';
    if (FindIrrWord(inheosa, _IV_OmP) & FINAL ||    // EU irregular light verb (V8+)
        FindIrrWord(inheosa, _IA_OmP) & FINAL ||    // EU irregular light adjective (A8+)
        FindIrrWord(inheosa, _IV_OmM) & FINAL ||    // EU irregular dark verb (V8-)
        FindIrrWord(inheosa, _IA_OmM) & FINAL)    // EU irregular dark adjective (A8-)
    {
        if (ending [0] == __K_I && ending [1] == __V_j)
        {
            if (CheckRightMostStemVowel (stem))                // vowel harmony
                ending [1] = __V_k;
            memmove (stem, stem+1, lstrlen(stem));
            memmove (ending, ending+1, lstrlen(ending));
        }
    }
}

BOOL Compose_REO_REU_Irregular (char *stem, char *ending)
{

    if (stem [0] == __V_m)                    // The last letter of stem is "EU"
    {
        int len = lstrlen(stem);
        char * inheosa = new char [len+1];
        for (int i = 0; i < len; i++)
            inheosa [i] = stem [len-1-i];
        inheosa [i] = '\0';
        if (stem [1] == __K_R)
        {
            if (FindIrrWord(inheosa, _IV_Rj) & FINAL ||   // REO irregular verb (V7)
                FindIrrWord(inheosa, _IA_Rj) & FINAL)     // REO irregular adjective (A7)
            {            
                if (ending [0] == __K_I)
                {
                    switch (ending [1])
                    {
                        case __V_j :    
                            ending [0] = __K_R;
                            break;
                        case __V_m :
                            memmove (ending, ending+2, lstrlen(ending+1));
                            break;
                    }
                }

                return TRUE;
            }
            if (FindIrrWord(inheosa, _IV_RmP) & FINAL ||    // REU irregular light verb (V6+)
                FindIrrWord(inheosa, _IA_RmP) & FINAL ||    // REU irregular light adjective (A6+)
                FindIrrWord(inheosa, _IV_RmM) & FINAL ||    // REU irregular dark verb (V6-)
                FindIrrWord(inheosa, _IA_RmM) & FINAL)        // REU irregular dark adjective (A6-)
            {            
                if (ending [0] == __K_I)
                {
                    switch (ending [1])
                    {
                        case __V_j :    
                            if (CheckRightMostStemVowel (stem))                // vowel harmony
                                ending [1] = __V_k;
                            ending [0] = __K_R;
                            break;
                        case __V_m :
                            memmove (ending, ending+2, lstrlen(ending+1));
                            break;
                    }
                }

                return TRUE;        
            }

            return TRUE;
        }
        Compose_EU_Irregular (stem, ending);
        return TRUE;
    }

    return FALSE;
}

BOOL Compose_U_Irregular (char *stem, char *ending)
{

    if (stem [0] == __K_P && stem [1] == __V_n)                    // The last of stem is "PU"
    {
        if (ending [0] == __K_I && ending [1] == __V_m)            // The first of ending is "EU"
            memmove (ending, ending + 2, lstrlen (ending+1));    // remove "IEUNG, EU"
        if (ending [0] == __K_I && ending [1] == __V_j)
        {
            memmove (stem, stem+1, lstrlen (stem));            // remove "U" : the last letter of stem
            memmove (ending, ending+1, lstrlen (ending));        // remove "IEUNG"
        }

        return TRUE;
    }

    return FALSE;
}

BOOL Compose_GEORA_Irregular (char *stem, char *ending)
{

    if (ending [0] == __K_I && ending [1] == __V_j && ending [2] == __K_R && ending [3] == __V_k)    // The last of stem is "GEORA"
    {
        int len = lstrlen(stem);
        char * inheosa = new char [len+1];
        for (int i = 0; i < len; i++)
            inheosa [i] = stem [len-1-i];
        inheosa [i] = '\0';
        if (FindIrrWord(inheosa, _IV_Gj) & FINAL)   // GEORA irregular verb (V0)
        {
            ending [0] = __K_G;
            return TRUE;
        }

        if (FindIrrWord(inheosa, _IV_Nj) & FINAL)   // NEORA irregular verb (V1)
        {            
            ending [0] = __K_N;
            return TRUE;
        }

        if (CheckRightMostStemVowel (stem))                        // vowel harmony
            ending [1] = __V_k;

        return TRUE;
    }

    return FALSE;
}

void Contraction (char *stem, char *ending)
{
    if (CheckRightMostStemVowel (stem))                        // vowel harmony
        ending [1] = __V_k;
    
    switch (stem [0])
    {
        case __V_k :    // the last letter of stem is "A"
            memmove (ending, ending+2, lstrlen(ending+2));
            return;
        case __V_j :    // the last letter of stem is "EO"
            memmove (ending, ending+2, lstrlen(ending+2));
            return;
        case __V_h :
            if (stem [1] == __K_I)    // the last character of stem is "O"
            {
                stem [0] = __V_hk;
                memmove (ending, ending+2, lstrlen(ending+1));
            }
            return;
        case __V_n :
            stem [0] = __V_nj;
            memmove (ending, ending+2, lstrlen(ending+1));
            return;
        case __V_hl :
            if (stem [1] == __K_D)    // the last character of stem is "DOE"
            {
                stem [0] = __V_hl;
                memmove (ending, ending+2, lstrlen(ending+1));
            }
            return;
        case __V_l :
            if (stem [1] == __K_I)
            {

            }
    }

}

BOOL Compose_Regular (char * stem, char *ending)
{
    if (stem [0] < __V_k)        // if the last letter of stem is consonant
    {
        if (ending [0] == __K_I && ending [1] == __V_j)    // the first character of ending is "EO"
        {
            if (CheckRightMostStemVowel (stem))                        // vowel harmony
                ending [1] = __V_k;
        }
        return TRUE;
    }
    
    if (ending [0] == __K_I && ending [1] == __V_j)
    {
        if (CheckRightMostStemVowel (stem))                        // vowel harmony
                ending [1] = __V_k;
        Contraction (stem, ending);
        return TRUE;
    }

    if (ending [0] == __K_I && ending [1] == __V_m)
        memmove (ending, ending + 2, lstrlen (ending+1));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\bsdict.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
// BSDict.h :
//
// Owner  : ChaeSeong Lim, HET MSCH RND (e-mail:cslim@microsoft.com)
//
// History : 1996/Mar
/////////////////////////////////////////////////////////////////////////////

#ifndef __DOUBLEBSDICT_H__
#define __DOUBLEBSDICT_H__

#if !defined (_UNICODE) && !defined (_MBCS)
#error _UNICODE or _MBCS is required.
#endif

// Maximun number of length dictionary in the silsa dict. (currently use 9)
#define MAX_LENGTH_DICT    9        // You should check word hash size in hash.h
                                // Currently using 20 byte long buffer can
                                // contain 18 byte(9 chars) length word.
#define MAX_BUFFER_SIZE    2048

/////////////////////////////////////////////////////////////////////////////
//  _IndexHeader will used as a index Header
struct _IndexHeader {
    // 16 bytes
    BYTE wordLen;
    BYTE reserved;
    UINT indexSize, blockSize;
    WORD numOfBlocks;
    UINT numberOfWords;

_IndexHeader() {
        wordLen = 0; indexSize = blockSize = 0; numOfBlocks = 0;
        numberOfWords = 0; reserved = 0;
    }
_IndexHeader(BYTE _wordLen, UINT _blockSize, UINT _indexSize) {
        wordLen = _wordLen;
        indexSize = _indexSize;
                //content word size(bytes) + pumsa(2) + index(2) + numOfWords(8);
        blockSize = _blockSize;
        numOfBlocks = 0;
        numberOfWords = 0; reserved = 0;
    }
};

#define SILSA_DICT_HEADER_SIZE 1024
//#define COPYRIGHT_STR "Copyright (C) 1996 Hangul Engineering Team. Microsoft Korea(MSCH). All rights reserved.\nVer 2.0 1996/3"
struct  _DictHeader {
    //char COPYRIGHT_HEADER[150];
    WORD    numOfLenDict;
    DWORD    iBlock;
    _DictHeader() {
        numOfLenDict=0; iBlock=0;
        //memset(COPYRIGHT_HEADER, '\0', sizeof(COPYRIGHT_HEADER));
        //strcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
        //COPYRIGHT_HEADER[strlen(COPYRIGHT_HEADER)+1] = '\032';
        //numOfLenDict=0; iBlock=0;
    }
};

//#define DICT_HEADER_SIZE    16
//#define INDEX_HEADER_SIZE    20

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CDoubleBSDict

class CDoubleBSDict {
public:
// Constructor
    // m_wordLen denote number of real two byte word. not byte length
    CDoubleBSDict() {
        m_pIndexHeader = new _IndexHeader;
        hIndex = 0;
    }
    CDoubleBSDict(int wordLen, int blockSize) {
        m_pIndexHeader = new _IndexHeader((BYTE)wordLen, blockSize,
                             (wordLen << 1) + 2 + sizeof(WORD)*2); // index size
        hIndex = 0;
    }

// Attributes


// Operations
    //virtual void Delete(const _TCHAR *key) = 0;
    //virtual BOOL Find(const _TCHAR *) = 0;
    int GetNumOfBlocks() { return m_pIndexHeader->numOfBlocks; }
    int GetBlockSize() { return m_pIndexHeader->blockSize; }
    int GetIndexSize() { return m_pIndexHeader->indexSize; }

    int GetWordLen() { return m_pIndexHeader->wordLen; }
    int GetWordByteLen() { return ((m_pIndexHeader->wordLen)<<1); }

// Implementations
protected:
    _IndexHeader    *m_pIndexHeader;
    HGLOBAL            hIndex;

public:
    // Destructor
    ~CDoubleBSDict() {
        if (m_pIndexHeader) delete m_pIndexHeader;
        if (hIndex) GlobalFree(hIndex);
    }

};

/////////////////////////////////////////////////////////////////////////////
// CDoubleMemDict class

class CDoubleMemBSDict : public CDoubleBSDict {
public:
// Constructor
    CDoubleMemBSDict() { hBlocks = 0; }

    CDoubleMemBSDict(int wordSize, int blockSize)
                    : CDoubleBSDict(wordSize, blockSize) { hBlocks = 0; }

// Attributes

// Operations
    void BuildFromTextFile(LPCTSTR lpfilename);
    DWORD WriteIndex(HANDLE hOut);
    DWORD WriteBlocks(HANDLE hOut);

    //void Delete(const _TCHAR *key);


    // Implementations
protected:
    HGLOBAL hBlocks;
    HANDLE    hInput;
    UINT    m_maxWordsInBlock;
    int        m_readPerOnce;

    int    ReadWord(BYTE *contentWord, int *pumsa);
    void    ReadBlock(int blockNumber, int *readNum, int *readUniQue);
    BOOL    AllocIndexNBlock();

private:

public:
    // Destructor
    ~CDoubleMemBSDict();

};

class BlockCache;
/////////////////////////////////////////////////////////////////////////////
// CDoubleFileBSDict class

class CDoubleFileBSDict : public CDoubleBSDict {
public:
// Constructor
    CDoubleFileBSDict() : CDoubleBSDict() { }

    CDoubleFileBSDict(int wordSize, int blockSize)
                    : CDoubleBSDict(wordSize, blockSize) { }

// Attributes

// Operations
    void LoadIndex(HANDLE hInput);
    int FindWord(HANDLE hDict, DWORD fpBlock, LPCTSTR lpWord);

// Implementations
protected:
    void LoadIndexHeader(HANDLE hInput);
    int FindIndex(LPCTSTR lpWord, int left, int right, BYTE *pumsa);
    int FindBlock(LPCTSTR lpWord, int left, int right);
    int Comp(LPCTSTR lpMiddle, LPCTSTR lpWord);

    BYTE *lpIndex;

private:
    static BYTE lpBuffer[MAX_BUFFER_SIZE];
    static BYTE *lpCurIndex;

public:
    // Destructor
    ~CDoubleFileBSDict() { }

};

/////////////////////////////////////////////////////////////////////////////
// CDoubleFileBSDict class inline fuction

inline
int CDoubleFileBSDict::Comp(LPCTSTR lpMiddle, LPCTSTR lpWord )
{
#ifdef _MBCS
    for (int i=0; i<GetWordByteLen(); i++) {
#elif _UNICODE
    for (int i=0; i<GetWordLen(); i++) {
#endif
        int test = *(lpMiddle+i) - *(lpWord+i);
        if (test<0) return -1;
        else
            if (test>0) return 1;
    }
    return 0;
}

#endif // !__DOUBLEBSDICT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\convert.hpp ===
//////////////////////////////////////////////////
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// File    : CONVERT.HPP
// Project : project SIK
// Purpose : KS <---> IN code conversion class definition
//////////////////////////////////////////////////

#if !defined (__CONVERT_HPP)
#define  __CONVERT_HPP   1


#define UWANSUNG_CODE_PAGE 949
#define JOHAP_CODE_PAGE    1361

#define codeWanSeong 0        // if we use unicode, this should be removed.
#define codeChoHab   1

class  CODECONVERT {
    public:
        int           CodeLen;
                          
        CODECONVERT()  {};
        ~CODECONVERT()   {};                  

        int HAN2INR(char  *, char  *, int) ;      // Hangeul code --> internal reverse string
        int HAN2INS(char  *, char  *, int) ;       // Hangeul code --> internal string
        int INR2HAN(char  *, char  *, int) ;      // internal reverse string--> Hangeul code
        int INS2HAN(char  *, char  *, int) ;       // internal string --> Hangeul code
        
        void ReverseIN(char  *, char  *) ; 
        
    private:
        void ReverseHAN(WCHAR *, WCHAR *) ;          

        void AppendIN(char *, char  *, int  &) ;
        void AppendHAN(WCHAR, WCHAR *, int  &) ;

        int ChoHab2INChar(char  *, char  *) ;    // one char conversion(KS-->internal)
        int IN2ChoHabChar(char  *, char  *) ;    // one char conversion(internal-->KS)

        int IN2UNI(char *c, WORD *wch);
        
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\hanguljaso.h ===
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
#ifndef __HJASO_H__
#define __HJASO_H__

#define NUMBER_OF_CHOSUNG            19
#define NUMBER_OF_JUNGSUNG            21
#define NUMBER_OF_JONGSUNG            28    // include fill code

#define HANGUL_COMP_JAMO_START        0x3131
#define HANGUL_COMP_JAMO_END        0x3163
#define HANGUL_COMP_JAMO_START_FILL    0x3130
#define HANGUL_COMP_JAMO_SIOT        0x3145
#define HANGUL_START                0xAC00
#define HANGUL_END                    0xD7A3

///////////////////////////////////////////
// HANGUL Jaso difinitions

// ChoSung
#define _KIYEOK_            1        
#define _SSANGKIYEOK_        2        
#define _NIEUN_                3        
//#define _SSANGNIEUN_        4     not used
#define _TIKEUT_            5        
#define _SSANGTIKEUT_        6        
#define _RIEUL_                7        
//#define _SSANGRIEUL_        8     not used
// fill
#define _MIEUM_                10        
#define _PIEUP_                11        
#define _SSANGPIEUP_        12        
#define _SIOS_                13        
#define _SSANGSIOS_            14        
#define _IEUNG_                15        
#define _CIEUC_                16        
#define _SSANGCIEUC_        17        
#define _CHIEUCH_            18        
#define _KHIEUKH_            19        
#define _THIEUTH_            20        
#define _PHIEUPH_            21        
#define _HIEUH_                22        
// JungSung
#define _A_                    23        
#define _AE_                24        
#define _YA_                25        
#define _YAE_                26        
#define _EO_                27        
#define _E_                    28        
#define _YEO_                29        
#define _YE_                30        
#define _O_                    31        
//fill
#define _WA_                33        
#define _WAE_                34        
#define _OE_                35        
#define _YO_                36        
#define _U_                    37        
#define _WEO_                38        
#define _WE_                39        
#define _WI_                40        
#define _YU_                41        
#define _EU_                42        
#define _YI_                43        
#define _I_                    44        
////////////////////////////////////////

#endif // !__HJASO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\ctplus0.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//              28-Aug-97   weibz       Add Hanguel char support
//
//---------------------------------------------------------------------------


//#include <windows.h>
//#include "ctplus0.h"

#include "pch.cxx"


//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,CH,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,CH,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          //  FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,VC,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,VC,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2000-2007
        WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,CH,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          //  3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    10-Sep-97   Weibz
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(VC);  // including Hangul
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeExW( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN ),
                                  CT_CTYPE1,
                                  &wc2,
                                  1,
                                  &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole CJK Range as Kanji
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

            //
            // Treat All Gaiji as Kanji Char, too
            //
            if ((wc >= 0xE000) && (wc < 0xE758)) {
                return(IC);
            }

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // Treat Hanguel Region as hanguel char.

            if ((wc >= 0xac00) && (wc <= 0xd7a3)) {
               return(HG);
            }

            // If it's not interesting return CH as default;
            return(CH);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\fsadict.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// CFSADict.h : 
//
// Owner  : ChaeSeong Lim, HET MSCH RND (e-mail:cslim@microsoft.com)
//             
// History : 1996/April
/////////////////////////////////////////////////////////////////////////////
#ifndef __FSADICT_H__
#define __FSADICT_H__

#if !defined (_UNICODE) && !defined (_MBCS)
#error _UNICODE or _MBCS is required.
#endif

// !!!-- NOTICE --- !!! When you modify MAX_CHAR, 
// You must also modify in both FSADict.h and TransTable.h.
#define        MAX_CHARS    45        // total 40 tokens. reserve token number 0
                                // For backward comppatibility added 4

class CFSADict {
public:
// Constructor
    CFSADict(HANDLE fHandle, UINT sparseMatSize, UINT actSize); 

// Attributes


// Operations    
    virtual WORD Find(LPCSTR lpWord, BYTE *actCode);

// Implementations
protected:
    LPSTR    lpBuffer;
    LPSTR    lpActBuffer;

public:
// Destructor
    ~CFSADict();
private:

};

class CFSAIrrDict : public CFSADict{
public:
// Constructor
    CFSAIrrDict(HANDLE fHandle, DWORD size) : CFSADict(fHandle, size, 0) { }

// Attributes


// Operations    
    WORD Find(LPCSTR lpWord);

// Implementations
protected:
    
public:
// Destructor
    ~CFSAIrrDict() {}
private:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       exports.cxx
//
//  Contents:   Code to export word breaker class factories
//
//  History:     weibz,   9-10-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include <classid.hxx>
#include <wbclassf.hxx>
#include <stemcf.hxx>

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE
DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

//    __try {

        switch ( cid.Data1 ) {

        // Korean language wordbreaker
        //
        case 0x31b7c920:
           if ( cid == CLSID_Korean_Default_WBreaker ) {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Korean language stemmer
        //
        case 0x37c84fa0:
           if ( cid == CLSID_Korean_Default_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        default:
             sc = E_NOINTERFACE;
        }
 /*   } __except(1) {

        if ( pResult )
            pResult->Release();

        sc = E_UNEXPECTED;
    }  */

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:     weibz,   9-10-1997   created 
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\ctplus0.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//              28-Aug-97   Weibz       Add Hanguel char
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC       0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC       0x03                             // Katakana char
#define WS       0x04                             // Word seperator
#define VC       0x05                             // Hankaku (variant) char
#define PS       0x06                             // Phrase seperator
#define CH       0x07                             // Code page 0 - ASCII Char.
#define HG       0x08                             // Hanguel Char.

BYTE
GetCharType(WCHAR wc);

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START       = 0x00,
   CT_HIRAGANA    = 0x01,
   CT_KANJI       = 0x02,
   CT_KATAKANA    = 0x03,
   CT_WORD_SEP    = 0x04,
   CT_HANKAKU     = 0x05,
   CT_PHRASE_SEP  = 0x06,
   CT_ROMAJI      = 0x07,
   CT_HANGUEL     = 0x08,
} CT;


// Declare node types transitions
// Intuitively frequency ordered
//
typedef enum _WT {
   WT_START       = 0x00,
   WT_WORD_SEP    = 0x01,
   WT_PHRASE_SEP  = 0x02,
   WT_ROMAJI      = 0x03,
   WT_HANGUEL     = 0x04,
   WT_REACHEND    = 0x05,
} WT;


#define CT_MAX    0x09

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\fsadict.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
//#include "stdafx.h"
#include "pch.cxx"
#include "FSADict.h"
//#include "TransTable.h"
#include "ReadHeosaDict.h"

CFSADict::CFSADict(HANDLE fHandle, UINT sparseMatSize, UINT actSize)
{
    DWORD NumOfBytesRead;

    lpBuffer = (LPSTR)GlobalAlloc(GPTR, sparseMatSize);
    Assert(lpBuffer != NULL );
    ReadFile(fHandle, lpBuffer, sparseMatSize, &NumOfBytesRead, 0);
//    _ASSERT(sparseMatSize == NumOfBytesRead);

    if (actSize) {
        lpActBuffer = (LPSTR)GlobalAlloc(GPTR, actSize);
        Assert(lpActBuffer != NULL);
        ReadFile(fHandle, lpActBuffer, actSize, &NumOfBytesRead, 0);
//        _ASSERT(actSize == NumOfBytesRead);
    } else lpActBuffer = 0;
}

CFSADict::~CFSADict()
{
    GlobalFree(lpBuffer);
    if (lpActBuffer)
        GlobalFree(lpActBuffer);
}

WORD CFSADict::Find(LPCSTR lpWord, BYTE *actCode)
{
    WORD base, delta;
    WORD hashVal=0;
    WORD ret;
    //BYTE c;

    base = delta = 0;
    //delta = ((WORD)(*lpWord) -'A') * 3;
    //base = *(WORD *)(lpBuffer + base + delta+1);
    //lpWord++;

    while(*lpWord) {
        if ((BYTE)*(lpBuffer + base + MAX_CHARS*5) == FINAL) return NOT_FOUND;

        // if not start state.(input token 0 not used)
        //if (base) 

        delta = ((WORD)(*lpWord)) * 5;
        if ( (*(lpBuffer + base + delta)) != (int) (*lpWord) )
            return NOT_FOUND;
        hashVal += *(WORD*)(lpBuffer + base + delta + 3);
    
        base = *(WORD *)(lpBuffer + base + delta + 1);

        if (base==0) return NOT_FOUND;
        lpWord++;
    }

    //c = (BYTE)*(lpBuffer + base + MAX_CHARS*3);
    ret = *(WORD*)(lpBuffer + base + MAX_CHARS*5);
    if (ret & FINAL)
        *actCode = *(lpActBuffer + hashVal);
    return ret;
}


WORD CFSAIrrDict::Find(LPCSTR lpWord)
{
    WORD base, delta;
    //WORD ret;
    //BYTE c;

    base = delta = 0;
    //delta = ((WORD)(*lpWord) -'A') * 3;
    //base = *(WORD *)(lpBuffer + base + delta+1);
    //lpWord++;

    while(*lpWord) {
        if ((BYTE)*(lpBuffer + base + MAX_CHARS*3)==FINAL) return NOT_FOUND;

        // if not start state.(input token 0 not used)
        delta = ((WORD)(*lpWord)) * 3;
        if ( (*(lpBuffer + base + delta)) != (int) (*lpWord) )
            return NOT_FOUND;
        base = *(WORD *)(lpBuffer + base + delta + 1);

        if (base==0) return NOT_FOUND;
        lpWord++;
    }

    //c = (BYTE)*(lpBuffer + base + MAX_CHARS*3);
    return *(WORD *)(lpBuffer + base + MAX_CHARS*3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\hash.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// Hash.h : 
//
// Owner  : ChaeSeong Lim, HET MSCH RND (e-mail:cslim@microsoft.com)
//             
// History : 1996/May
/////////////////////////////////////////////////////////////////////////////
#ifndef __HASH_H__
#define __HASH_H__

#if !defined (_UNICODE) && !defined (_MBCS)
#error _UNICODE or _MBCS is required.
#endif

#include <tchar.h>

#define OYONG_HASHSIZE    5501        // current num of words = 3657
/////////////////////////////////////////////////////////////////////////////
// CHash

class CHash {
public:
// Constructor
    CHash() {}
    
// Attributes

// Operations    
    virtual void Add(LPCTSTR) {}
    virtual BOOL Find(LPCTSTR) { return FALSE; }
    virtual void Delete(LPCTSTR) {}

// Implementations
protected:
    virtual UINT Hash(const _TXCHAR *key);    // UINT = 32 bit unsigned
        
public:
    // Destructor
    virtual ~CHash() { }
};

/////////////////////////////////////////////////////////////////////////////
// CHash inline fuctions

// Hash fuction
inline UINT CHash::Hash(const _TXCHAR *key)
{
    UINT hashValue = 0, g;
    
    while (*key) {
        hashValue = (hashValue << 4) + *key++;
        if (g = hashValue & 0xF0000000) {
            hashValue ^= g >> 24;
            hashValue &= ~g;
        }
    }
    return hashValue % OYONG_HASHSIZE;
}

#ifdef _DIC_BUILD_
/////////////////////////////////////////////////////////////////////////////
// CMemHash inline fuctions

class COyongMakeHash : public CHash {
public:
// Constructor
    COyongMakeHash() { 
        for (int i=0; i<OYONG_HASHSIZE; i++) bufArray[i] = 0;
    }
    
    struct CElement {
        CElement(LPCTSTR _incorrectStr, LPCTSTR _correctStr, BYTE _pumsa) {
            incorrectStr    = _incorrectStr;
            correctStr[0]    = _correctStr;
            Pumsa[0]        = _pumsa;
            numOfCorrectStr = 1;
        }
        void Append(LPCTSTR _correctStr, BYTE _pumsa) {
            correctStr[numOfCorrectStr]    = _correctStr;
            Pumsa[numOfCorrectStr]        = _pumsa;
            numOfCorrectStr++;
        }
        CString    incorrectStr;
        BYTE    numOfCorrectStr;
        CString correctStr[10];        // Max # of correct strings is 10
        BYTE    Pumsa[10];
    };
    
// Attributes

// Operations    
    void Add(LPCTSTR incorrectStr, LPCTSTR correctStr, BYTE pumsa);
    void WriteDict(HANDLE hOut);
    //BOOL Find(LPCTSTR);
    
// Implementations
protected:
    CElement    *bufArray[OYONG_HASHSIZE];
        
public:
    // Destructor
    ~COyongMakeHash();
};

#endif    // _DIC_BUILD_

/////////////////////////////////////////////////////////////////////////////
// COyongHash Class

class COyongHash : public CHash {
public:
// Constructor
    COyongHash(HANDLE hDict, UINT hashSize, UINT bufferSize);
    COyongHash() {}
    
// Attributes

// Operations    
    //void Add(LPCTSTR);
    BOOL Find(LPCTSTR searchWord, BYTE pumsa, LPTSTR correctWord);
    
// Implementations
protected:
    UINT    m_hashSize, m_bufferSize;
    WORD    *m_lpHashTable;
    char    *m_lpBuf;

public:
    // Destructor
    ~COyongHash();
};

#define WORD_HASH_SIZE    2003// 1009, 2003, 4007
/////////////////////////////////////////////////////////////////////////////
// COyongHash Class

class CWordHash : public CHash {
public:
// Constructor
    CWordHash() {}
        
// Attributes

// Operations    
    //void Add(LPCTSTR);
    BOOL Find(LPCTSTR searchWord, BYTE *pumsa);
    void Add(LPCTSTR searchWord, BYTE pumsa);

// Implementations
protected:
    UINT Hash(const _TXCHAR *key);    // UINT = 32 bit unsigned
    static BYTE    m_lpHashTable[WORD_HASH_SIZE][20];

public:
    // Destructor
    ~CWordHash() {}
};

// Hash fuction
inline 
UINT CWordHash::Hash(const _TXCHAR *key)
{
    UINT hashValue = 0, g;
    
    while (*key) {
        hashValue = (hashValue << 4) + *key++;
        if (g = hashValue & 0xF0000000) {
            hashValue ^= g >> 24;
            hashValue &= ~g;
        }
    }
    return hashValue % WORD_HASH_SIZE;
}

inline
void CWordHash::Add(LPCTSTR searchWord, BYTE pumsa)
{
    UINT hashVal = CWordHash::Hash((const _TXCHAR*)searchWord);
    memset(m_lpHashTable[hashVal], '\0', 20);
    _tcscpy((LPTSTR)m_lpHashTable[hashVal], searchWord);
    m_lpHashTable[hashVal][19] = pumsa;
}

#endif    // !__HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\heosadictheader.h ===
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
#ifndef __HEOSADICTHEADER_H__
#define __HEOSADICTHEADER_H__

#define HEOSA_DICT_HEADER_SIZE 1024
#define NUM_OF_HEOSA_DICT    4    // Ssi-Keut, ToSsi, AuxVerb, AuxAd  // Irregular
#define NUM_OF_IRR_DICT        36    // Number of irregular type is 36

//#define COPYRIGHT_STR "Copyright (C) 1996 Hangul Engineering Team. Microsoft Korea(MSCH). All rights reserved.\nVer 2.0 1996/3"

struct  _HeosaDictHeader {
    //char COPYRIGHT_HEADER[150];
    UINT    iStart;
    UINT    heosaDictSparseMatSize[NUM_OF_HEOSA_DICT];        // 4 Heosa + 36 IrrDict
    UINT    heosaDictActionSize[NUM_OF_HEOSA_DICT];
    UINT    irrDictSize[NUM_OF_IRR_DICT];
    _HeosaDictHeader() { 
        //memset(COPYRIGHT_HEADER, '\0', sizeof(COPYRIGHT_HEADER));
        //strcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
        //COPYRIGHT_HEADER[strlen(COPYRIGHT_HEADER)+1] = '\032';
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <cierror.h>
#include <query.h>
#include <except.hxx>

#include "assert.h"

#include  "stemkor.h"
#include  "ctplus0.h"

#undef Assert
#define Assert(a)

// Base services
//

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\pumsa.h ===
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
#ifndef __PUMSA_H__
#define __PUMSA_H__

/////////////////////////////////////////////////////////////////////////////
//  Declaration of PumSa bit information

const BYTE _NOUN            =    0x01;
const BYTE _VERB            =    0x02;
const BYTE _ALONE            =    0x04;
const BYTE _ADJECTIVE        =    0x08;
const BYTE _PRONOUN            =    0x10;
const BYTE _NUM                =    0x20;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\init.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 - 1999, Microsoft Corporation.
//
//  Routine:    DllMain
//
//  Returns:    True if successful, else False.
//
//  History:    Weibz, 10-Sep-1997,  created it.
//
//---------------------------------------------------------------------------

#include <pch.cxx>

#include    "basecore.hpp"
#include    "basecode.hpp"
#include    "basedef.hpp"
#include    "basegbl.hpp"
#include    "MainDict.h"

#include    "stemkor.h"

HSTM             g_hStm;
BOOL             g_fLoad;
CRITICAL_SECTION ThCritSect;

extern char TempJumpNum[], TempSujaNum[],TempBaseNum[];
extern char TempNumNoun[], TempSuffixOut[];
extern char bTemp[], TempETC[], TempDap[];
extern LenDict JumpNum;
extern LenDict SujaNum;
extern LenDict BaseNum;
extern LenDict NumNoun;
extern LenDict Suffix;
extern LenDict B_Dict;
extern LenDict T_Dict;
extern LenDict Dap;

BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason)
    {
       case DLL_PROCESS_ATTACH :

          DisableThreadLibraryCalls(hDLL);
          InitializeCriticalSection (&ThCritSect);

          JumpNum.InitLenDict(TempJumpNum, 5, 5);
          SujaNum.InitLenDict(TempSujaNum, 8, 27);
          BaseNum.InitLenDict(TempBaseNum, 5, 3);
          NumNoun.InitLenDict(TempNumNoun, 8, 32);
          Suffix.InitLenDict(TempSuffixOut, 8, 8);
          B_Dict.InitLenDict(bTemp, 5, 1);
          T_Dict.InitLenDict(TempETC, 10, 7);
          Dap.InitLenDict(TempDap, 5, 1);

          g_fLoad = FALSE;

#ifdef KORDBG
          OutputDebugString("\nKorwbrkr: DLL_PROCESS_ATTACH\n");
#endif

#ifdef KORDBG
          OutputDebugString("\nInit is OK\n");
#endif

          break ;


       case DLL_THREAD_ATTACH:
            break;
       case DLL_THREAD_DETACH:
            break;
       case DLL_PROCESS_DETACH  :


            if  (g_fLoad) {
                StemmerCloseMdr(g_hStm);
                StemmerTerminate(g_hStm);
            }

            DeleteCriticalSection (&ThCritSect);
            break ;
      }   //switch

      return TRUE ;
}

BOOL StemInit()
{
    if ( g_fLoad )
        return TRUE;

    EnterCriticalSection( &ThCritSect );

    do
    {
        // Someone else got here first.

        if ( g_fLoad )
            break;

        SRC src;
        HKEY    KeyStemm;
        DWORD   dwType, dwSize;
        char    lpszTemp[MAX_PATH],szSysPath[MAX_PATH];

        src = StemmerInit(&g_hStm);

        if (src != NULL)
        {
            #ifdef KORDBG
                OutputDebugString("Korwbrkr: StemmerInit( ) returns error\n");
            #endif
            break;
        }

        src = StemmerSetOption(g_hStm,SO_NOUNPHRASE|SO_ALONE|SO_AUXILIARY |
                         SO_COMPOUND | SO_SUFFIX | SO_NP_NOUN |SO_NP_PRONOUN |
                         SO_NP_NUMBER | SO_NP_DEPENDENT | SO_SUFFIX_JEOG);

        if ( src != NULL )
        {
            #ifdef KORDBG
                OutputDebugString("Korwbrkr: StemmerSetOption( )returns error\n");
            #endif
            break;
        }


        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,STEMMERKEY,
                           0L,
                           KEY_QUERY_VALUE,
                           &KeyStemm ) == ERROR_SUCCESS )
        {

            dwSize = MAX_PATH;

            if ( (RegQueryValueEx(KeyStemm,
                                  STEM_DICTIONARY,
                                  (LPDWORD)NULL,
                                  &dwType,
                                  (LPBYTE)lpszTemp,
                                  &dwSize) == ERROR_SUCCESS)
                 && (dwType==REG_SZ) )
            {

                lpszTemp [dwSize] = '\0';

                GetSystemDirectory( szSysPath, sizeof(szSysPath)/sizeof(szSysPath[0]) );
                strcat(szSysPath, "\\");
                strcat(szSysPath, lpszTemp);

                #ifdef KORDBG
                    OutputDebugString("Korwbrkr: the dict is ");
                    OutputDebugString(szSysPath);
                #endif

                src = StemmerOpenMdr(g_hStm,szSysPath);
                if ( src != NULL )
                {
                    #ifdef KORDBG
                        OutputDebugString("Korwbrkr: StemmerOpenMdr returns err\n");
                    #endif
                    RegCloseKey (KeyStemm);
                    break;
                }
            }
            else
            {
                #ifdef KORDBG
                    OutputDebugString("Korwbrkr: RegQueryValueEx returns err\n");
                #endif

                RegCloseKey( KeyStemm );
                break;
             }

             RegCloseKey (KeyStemm);
        }
        else
        {
            #ifdef KORDBG
                OutputDebugString("Korwbrkr:RegOpenKeyEx returns error\n");
            #endif

            break;
        }

        g_fLoad = TRUE;

    } while ( FALSE );

    LeaveCriticalSection( &ThCritSect );

    return g_fLoad;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\iwbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       IWBreak.cxx
//
//  Contents:   Korean  Word Breaker glue code
//
//  History:   weibz,   10-Sep-1997   created
//
//----------------------------------------------------------------------------

#include <pch.cxx>

#include "iwbreak.hxx"

#define   MAXFORMS    20

extern long              gulcInstances;
extern HSTM              g_hStm;
extern BOOL              g_fLoad;
//extern CRITICAL_SECTION  ThCritSect;

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{

    InterlockedIncrement( &gulcInstances );

}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );


}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IWordBreaker = D53552C8-77E3-101A-B552-08002B33B0E6
    //                    --------
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Assert( (IID_IWordBreaker.Data1 & 0x000000FF) == 0xC8 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 )
    {
    case 0x00000000:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0xD53552C8:
        if ( memcmp( &IID_IWordBreaker, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IWordBreaker *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;


    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if ( NULL == pfLicense )
       return E_INVALIDARG;


    if (IsBadWritePtr(pfLicense, sizeof(DWORD)))
        return E_INVALIDARG;

    if ( !StemInit() )
        return LANGUAGE_E_DATABASE_NOT_FOUND;

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;


    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{

    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";


    if ( NULL == ppwcsLicense )  {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  History:    10-Sep-1997, WeibZ,       Created.
//
//  Notes:      Since the input buffer may be greater than MAX_II_BUFFER_LEN
//              we process the buffer in chunks of length MAX_II_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreaker::BreakText( TEXT_SOURCE *pTextSource,
                                                 IWordSink *pWordSink,
                                                 IPhraseSink *pPhraseSink )
{
    SCODE sc = S_OK;
    ULONG cwc;
    WT    Type;
    BOOL  Ret_ProcToken;



    if (  NULL == pTextSource ) {
//       OutputDebugString("\nPTextSources is Null\n");
       return E_INVALIDARG;
    }

    if ( NULL == pWordSink )
    {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }

    // BUGBUG, need to normalize nums within T-Hammer, pass as flag?

    // turn on noun phrase analysis if there is a phrase sink
    if ( 0 != pPhraseSink )
    {
        // BUGBUG, do we need to pass a separate flag to T-Hammer for this?
        // ignore the phrase sink for now
        // return sc;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
       return S_OK;
    }

    Assert( pTextSource->iCur < pTextSource->iEnd );


    __try
    {
        do
        {
            while ( pTextSource->iCur < pTextSource->iEnd )
            {

                cwc = pTextSource->iEnd - pTextSource->iCur;

                Tokenize( cwc, TRUE, pTextSource, &Type);

                if ( Type != WT_REACHEND )
                {
                    Ret_ProcToken = ProcessTokens( pTextSource, Type,
                                                   pWordSink, pPhraseSink );

                    if ( !Ret_ProcToken ) {
                       // Process_Tokens return FALSE, so return here
                       return E_UNEXPECTED;
                    }

                    pTextSource->iCur += _cchTextProcessed;
                }
                else
                    break;

            }


        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );

        while ( pTextSource->iCur < pTextSource->iEnd )
        {

           cwc = pTextSource->iEnd - pTextSource->iCur;

           Tokenize( cwc, FALSE, pTextSource, &Type);

           Ret_ProcToken = ProcessTokens( pTextSource, Type,
                                          pWordSink, pPhraseSink );

           if ( !Ret_ProcToken ) {
              // Process_Tokens return FALSE, so return here
              return E_UNEXPECTED;
           }

           pTextSource->iCur += _cchTextProcessed;
       }

    } __except(1) {

       sc = E_UNEXPECTED;
   }

    return sc;
}



void CWordBreaker::Tokenize( unsigned    cwc,
               BOOL        bMoreText,
               TEXT_SOURCE *pTextSource,
               WT          *Type)
{

    ULONG i;
    BYTE  ct;
    BOOL  fRomanWord = FALSE;
    BOOL  fHanguelWord = FALSE;
    CONST WCHAR *pwcInput, *pwcStem;


    _cchTextProcessed = 0;
    *Type =  WT_START;

    pwcStem = pwcInput = pTextSource->awcBuffer + pTextSource->iCur;

    for (i=0; i< cwc; i++, pwcInput++) {

           ct = GetCharType(*pwcInput);

           if ( (ct != WS) && (ct != PS) && (ct != HG) )
                ct = CH;


           switch (ct) {
             case CH :
                   // check to see if there is a Hanguel word before this char
                   if (fHanguelWord) {
                      _cchTextProcessed = (DWORD)(pwcInput - pwcStem);
                      return;
                   }

                   if (!fRomanWord) {
                      pwcStem = pwcInput;
                      fRomanWord = TRUE;
                      *Type = WT_ROMAJI;
                   }
                   break;
             case HG :

                   // check to see if there is an English word before this char
                   if ( fRomanWord ) {
                      _cchTextProcessed = (DWORD)(pwcInput - pwcStem);
                      return;
                   }

                   if (!fHanguelWord) {
                      pwcStem = pwcInput;
                      fHanguelWord = TRUE;
                      *Type = WT_HANGUEL;
                   }
                   break;
             case WS :
                   if (fRomanWord || fHanguelWord) {
                      _cchTextProcessed = (DWORD)(pwcInput - pwcStem);
                      return;
                   }
                   *Type = WT_WORD_SEP;
                   _cchTextProcessed = 1;
                   return;

             case PS :
                  if (fRomanWord || fHanguelWord) {
                     _cchTextProcessed = (DWORD)(pwcInput - pwcStem);
                     return;
                  }
                   *Type = WT_PHRASE_SEP;
                   _cchTextProcessed = 1;
                   return;

           }
   }

   if ( bMoreText ) {
      _cchTextProcessed = 0;
      *Type = WT_REACHEND;
   }
   else
      _cchTextProcessed = cwc;

}


BOOL CWordBreaker::ProcessTokens( TEXT_SOURCE *pTextSource,
                                  WT           Type,
                                  IWordSink   *pWordSink,
                                  IPhraseSink *pPhraseSink )
{

    CONST WCHAR  *pwcStem;

    if ( Type == WT_PHRASE_SEP)
    {
        pWordSink->PutBreak (WORDREP_BREAK_EOS);
        return TRUE;
    }

    if ( Type == WT_ROMAJI)
    {
        ULONG  i;

        pwcStem = pTextSource->awcBuffer + pTextSource->iCur;

        #ifdef KORDBG
        OutputDebugString("\n");
        for (i=0; i< _cchTextProcessed; i++)
        {
            char  ctmp[2];

            ctmp[0] = pwcStem[i] & 0xff;
            ctmp[1] = '\0';
            OutputDebugString(ctmp);
        }
        OutputDebugString("  ");
        #endif

        (pWordSink->PutWord)(_cchTextProcessed,
                             pwcStem,
                             _cchTextProcessed,
                             pTextSource->iCur);
        return TRUE;
    }

    if ( Type == WT_HANGUEL )
    {
        WCHAR TokenWord[80];
        ULONG i;
        WDOB  sob;

//      EnterCriticalSection(&ThCritSect);

        sob.wordlist = (LPWSTR)LocalAlloc(LPTR, 200);
        sob.sch = 200;


        if (sob.wordlist == NULL )
            return FALSE;

        pwcStem = pTextSource->awcBuffer + pTextSource->iCur;


        for (i=0; i<_cchTextProcessed; i++)
        {
            #ifdef KORDBG
            WORD  wtmp;
            char  ctmp[80];

            wtmp = pwcStem[i];
            sprintf(ctmp, "%4x ", wtmp);
            OutputDebugString(ctmp);
            #endif

            TokenWord[i] = pwcStem[i];
        }

        TokenWord[_cchTextProcessed] = L'\0';

        #ifdef KORDBG
        OutputDebugString("\nBefore StemmerDecomposeW\n");
        #endif

        if (StemmerDecomposeW(g_hStm, TokenWord, &sob) == NULL)
        {
            ULONG   wInLexLen;
            WORD    winfo;
            ULONG   num, len, j, k;
            WCHAR   *pWordList, *pVerb;
            ULONG   NumEf;
            BOOL    fExist;
            WCHAR   *pwszStart[MAXFORMS];

            NumEf = 0;

            do
            {
                num = sob.num;
                pWordList = sob.wordlist;

                for (j=0; j<num; j++)
                {
                    len = wcslen(pWordList);
                    memcpy(&winfo,pWordList+len+1,2);

                    switch (winfo & 0x0f00)
                    {
                    case POS_NOUN :
                    case POS_ADJECTIVE :
                    case POS_PRONOUN :
                    case POS_ADVERB :
                    case POS_NUMBER :

                        fExist = FALSE;
                        for (k=0; k<NumEf; k++)
                        {
                            if ( wcscmp(pWordList,pwszStart[k]) == 0 )
                                fExist = TRUE;
                        }

                        if ( !fExist )   // this stem does not exist so far.
                        {
                            // it will contain:  WordList 00 Winfo, so the length
                            // should be len + 2 = len + 1 + 1.

                            pwszStart[NumEf]=(LPWSTR)LocalAlloc(LPTR,(len+2)*sizeof(WCHAR));

                            if ( pwszStart[NumEf] == NULL )
                            {
                                // alloc error, so return here
                                if (sob.wordlist)
                                    LocalFree(sob.wordlist);

                                for (k=0; k<NumEf; k++)
                                {
                                    if ( pwszStart[k] != NULL)
                                        LocalFree(pwszStart[k]);
                                }

                                return FALSE;
                            }


                            wcscpy(pwszStart[NumEf], pWordList);
                            pwszStart[NumEf][len] = L'\0';
                            pwszStart[NumEf][len+1] = winfo & 0x0f00 ;

                            NumEf++;

                        }

                        break;

                    case POS_VERB :   // for Verb, we will handle it specially.
                                      // Append a  flag char Da (U+B2E4) to
                                      // the root form of a verb word.

                        fExist = FALSE;


                        // it will contain:  WordList <Da> 00.
                        // so the length should be len + 2 = len + 1 + 1.

                        pVerb = (LPWSTR)LocalAlloc(LPTR, (len+2)*sizeof(WCHAR));

                        if  (pVerb == NULL )
                        {
                            if (sob.wordlist)
                                LocalFree(sob.wordlist);

                            for (k=0; k<NumEf; k++)
                            {
                                if ( pwszStart[k] != NULL )
                                    LocalFree(pwszStart[k]);
                            }

                            return FALSE;
                        }

                        wcscpy(pVerb, pWordList);

                        pVerb[len] = VERBCHAR;
                        pVerb[len+1] = L'\0';

                        for (k=0; k<NumEf; k++)
                        {
                            if ( wcscmp(pVerb,pwszStart[k]) == 0 )
                                fExist = TRUE;
                        }

                        if ( !fExist )   // this stem does not exist so far.
                        {

                            // it will contain:  Wordlist <Da> 00 Winfo.
                            // so the length should be len+3 = len + 1 + 1 + 1.

                            pwszStart[NumEf]=(LPWSTR)LocalAlloc(LPTR,(len+3)*sizeof(WCHAR));

                            if ( pwszStart[NumEf] == NULL )
                            {
                                // alloc error, so return here
                                if (sob.wordlist)
                                    LocalFree(sob.wordlist);

                                if ( pVerb != NULL )
                                    LocalFree(pVerb);

                                for (k=0; k<NumEf; k++)
                                {
                                    if ( pwszStart[k] != NULL)
                                        LocalFree(pwszStart[k]);
                                }

                                return FALSE;
                            }

                            wcscpy(pwszStart[NumEf], pVerb);
                            pwszStart[NumEf][len+1] = L'\0';
                            pwszStart[NumEf][len+2] = winfo & 0x0f00;

                            NumEf++;
                        }

                        if ( pVerb != NULL )
                            LocalFree(pVerb);

                        break;

                    case POS_AUXVERB :
                    case POS_AUXADJ :
                    case POS_SPECIFIER :
                    case POS_PREFIX :

                        break;
                    }

                    pWordList += len + 3;
                }
            } while (StemmerDecomposeMoreW(g_hStm, TokenWord, &sob) == NULL) ;

            //
            // BUGBUG: Can this legitimately happen?  We're seeing it indexing microsoft.com.
            //

            if ( 0 == NumEf )
            {
                #if DBG == 1
                OutputDebugString( "BOGUS WORD: " );

                for ( WCHAR * pwc = &TokenWord[0]; 0 != *pwc; pwc++ )
                {
                    char ctmp[6];
                    sprintf(ctmp, "%4x ", *pwc);
                    OutputDebugString(ctmp);
                }

                OutputDebugString( "\n" );
                #endif

                return TRUE;
            }

            if ( !_fQuery )
            {
                for (i=0; i< (NumEf-1); i++ )
                {
                    wInLexLen = wcslen(pwszStart[i]);
                    pWordSink->PutAltWord(wInLexLen,
                                          pwszStart[i],
                                          _cchTextProcessed,
                                          pTextSource->iCur);
                }

                // handle the last one.
                wInLexLen = wcslen(pwszStart[NumEf-1]);
                pWordSink->PutWord(wInLexLen,
                                   pwszStart[NumEf-1],
                                   _cchTextProcessed,
                                   pTextSource->iCur);

            }
            else
            {
                if ( NumEf == 1 )
                {
                    // handle this only one.
                    wInLexLen = wcslen(pwszStart[NumEf-1]);
                    pWordSink->PutWord(wInLexLen,
                                       pwszStart[NumEf-1],
                                       _cchTextProcessed,
                                       pTextSource->iCur);
                }
                else
                {
                    ULONG   uNum_Noun;
                    ULONG   uIndex[MAXFORMS];

                    uNum_Noun = 0;

                    for (i=0; i<NumEf; i++)
                    {
                        wInLexLen = wcslen(pwszStart[i]);

                        if ( (pwszStart[i][wInLexLen+1] == POS_NOUN) ||
                             (pwszStart[i][wInLexLen+1] == POS_PRONOUN) ||
                             (pwszStart[i][wInLexLen+1] == POS_NUMBER)  )
                        {
                            uIndex[uNum_Noun] = i;
                            uNum_Noun ++;
                        }
                    }

                    if ( uNum_Noun == 0 )
                    {
                        // there is no Noun form

                        for (i=0; i< (NumEf-1); i++ )
                        {
                            wInLexLen = wcslen(pwszStart[i]);
                            pWordSink->PutAltWord(wInLexLen,
                                                  pwszStart[i],
                                                  _cchTextProcessed,
                                                  pTextSource->iCur);
                        }

                        // handle the last one.
                        wInLexLen = wcslen(pwszStart[NumEf-1]);
                        pWordSink->PutWord(wInLexLen,
                                           pwszStart[NumEf-1],
                                          _cchTextProcessed,
                                          pTextSource->iCur);
                    }

                    if (uNum_Noun == 1)
                    {
                        // there is only One Noun, and we just use this one to query.
                        ULONG   index;

                        index = uIndex[0];
                        wInLexLen = wcslen(pwszStart[index]);
                        pWordSink->PutWord(wInLexLen,
                                           pwszStart[index],
                                           _cchTextProcessed,
                                           pTextSource->iCur);
                    }

                    if ( uNum_Noun > 1 )
                    {
                        // there are more than one Noun, Use all those Noun to query.

                        ULONG   index;

                        for (i=0; i<uNum_Noun-1; i++)
                        {
                            index = uIndex[i];
                            wInLexLen = wcslen(pwszStart[index]);
                            pWordSink->PutAltWord(wInLexLen,
                                                  pwszStart[index],
                                                 _cchTextProcessed,
                                                 pTextSource->iCur);
                        }

                        // handle the last Noun.

                        index = uIndex[uNum_Noun-1];
                        wInLexLen = wcslen(pwszStart[index]);
                        pWordSink->PutWord(wInLexLen,
                                           pwszStart[index],
                                           _cchTextProcessed,
                                           pTextSource->iCur);
                    }
                }
            }

            #ifdef KORDBG
            {
                char  ctmp[80];

                OutputDebugString("\nStemmerDecomposeW Correct\n");
                OutputDebugString(" the Num of Stemm is ");
                sprintf(ctmp, "%4x ", NumEf);
                OutputDebugString(ctmp);
                OutputDebugString("\n");
            }

            for (i=0; i< NumEf; i++)
            {
                WORD  wtmp;
                char  ctmp[80];

                wInLexLen = wcslen(pwszStart[i]);
                for (j=0; j<wInLexLen; j++)
                {
                    wtmp = pwszStart[i][j];
                    sprintf(ctmp, "%4x ", wtmp);
                    OutputDebugString(ctmp);
                }
                OutputDebugString("  Type: ");

                wtmp = pwszStart[i][wInLexLen+1];
                wtmp = wtmp & 0x0f00;

                sprintf(ctmp, "%4x \n", wtmp);
                OutputDebugString(ctmp);
            }

            OutputDebugString("\n");
            #endif

            // Free the memory.
            for (i=0; i<NumEf; i++)
            {
                if ( pwszStart[i] != NULL )
                    LocalFree(pwszStart[i]);
            }
        }
        else
        {
            #ifdef KORDBG
            OutputDebugString("\nStemmerDecomposeW NOT right\n");
            for (i=0; i<_cchTextProcessed; i++)
            {
                WORD  wtmp;
                char  ctmp[80];

                wtmp = TokenWord[i];
                sprintf(ctmp, "%4x ", wtmp);
                OutputDebugString(ctmp);
            }
            #endif

            pWordSink->PutWord(_cchTextProcessed,
                               TokenWord,
                               _cchTextProcessed,
                               pTextSource->iCur);
        }

        LocalFree(sob.wordlist);
//      LeaveCriticalSection (&ThCritSect);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\maindict.h ===
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
#ifndef __MAINDICT_H__
#define __MAINDICT_H__

#include "Pumsa.h"
#include "ReadSilsaDict.h"
#include "ReadHeosaDict.h"

#ifndef _NO_OYONG_DICT_
    #include "ReadOyongDict.h"    // enable not loading oyong dict for stemmer
#endif

#define MAIN_DICT_HEADER_SIZE 1024
#define COPYRIGHT_STR "Copyright (C) 1996 Hangul Engineering Team. Microsoft Corporation(MSCH). All rights reserved.\n"

struct  _MainDictHeader {
    char    COPYRIGHT_HEADER[150];
    WORD    LexType;
    WORD    Version;
    DWORD    iSilsa;    // seek point
    DWORD    iHeosa;
    DWORD    iOyong;
    DWORD    reserved[5];
    _MainDictHeader() { 
        Version = 0;
        iSilsa = iHeosa = iOyong = 0;
        memset(reserved, '\0', sizeof(reserved));
        memset(COPYRIGHT_HEADER, '\0', sizeof(COPYRIGHT_HEADER));
        strcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
        COPYRIGHT_HEADER[strlen(COPYRIGHT_HEADER)+1] = '\032';
    }
};

extern BOOL VerifyMainDict(LPSTR lpszLexFileName);
extern BOOL OpenMainDict(LPSTR lpszLexFileName);
extern void CloseMainDict();

#endif // __MAINDICT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\maindict.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////

//#include "stdafx.h"
#include "pch.cxx"
#include "MainDict.h"

static    HANDLE hMainDict=0;
///////////////////////////////////////////////////////////////////////////
// Check if aleady opened. If a processe load multiple DLL it can occur
static WORD DictOpenCount = 0;

BOOL VerifyMainDict(LPSTR lpszLexFileName)
{
    _MainDictHeader mainDictHeader;
    DWORD readBytes;
    HANDLE hDict;

    hDict = CreateFile(lpszLexFileName, GENERIC_READ, FILE_SHARE_READ, 0,
                                    OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);

    if (hDict==INVALID_HANDLE_VALUE)
        return FALSE;

    ReadFile(hDict, &mainDictHeader, sizeof(_MainDictHeader), &readBytes, 0);
    if (readBytes==0 || strcmp(COPYRIGHT_STR, mainDictHeader.COPYRIGHT_HEADER)!=0) {
        CloseHandle(hDict);
        return FALSE;
    }

    CloseHandle(hDict);
    return TRUE;
}

BOOL OpenMainDict(LPSTR lpszLexFileName)
{
    _MainDictHeader mainDictHeader;
    DWORD readBytes;

    if (DictOpenCount) {
        DictOpenCount++;    // Incerease reference count
        return TRUE;
    }

    hMainDict = CreateFile(lpszLexFileName,
                           GENERIC_READ, FILE_SHARE_READ,
                           0,
                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,
                           0);

    if (hMainDict != INVALID_HANDLE_VALUE) {
        ReadFile(hMainDict,
                 &mainDictHeader,
                 sizeof(_MainDictHeader),
                 &readBytes,
                 0);

        if (strcmp(COPYRIGHT_STR, mainDictHeader.COPYRIGHT_HEADER) == 0) {
            SetFilePointer(hMainDict, MAIN_DICT_HEADER_SIZE, 0, FILE_BEGIN);
            if (OpenSilsaDict(hMainDict, mainDictHeader.iSilsa) != FALSE) {
                if (OpenHeosaDict(hMainDict, mainDictHeader.iHeosa) != FALSE) {

#ifndef _NO_OYONG_DICT_
                    if (OpenOyongDict(hMainDict, mainDictHeader.iOyong) == FALSE) {
                        CloseHeosaDict();

                    } else {
#endif
                        DictOpenCount = 1;
                        return TRUE;

#ifndef _NO_OYONG_DICT_
                    }
#endif
                }

                CloseSilsaDict();
            }
        }

        CloseHandle(hMainDict);
    }

    return FALSE;
}

void CloseMainDict()
{
    DictOpenCount--;
    if (DictOpenCount==0) {
        CloseSilsaDict();
        CloseHeosaDict();
    #ifndef _NO_OYONG_DICT_
        CloseOyongDict();
    #endif
        CloseHandle(hMainDict);
        hMainDict = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\readheosadict.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
//#include "stdafx.h"
#include "pch.cxx"
#include <winnls.h>
#include "ReadHeosaDict.h"

// Ssi-Ggut, Tossi, AuxVerb, AuxAdj dictionary
static CFSADict        *heosaDicts[NUM_OF_HEOSA_DICT];
static CFSAIrrDict    *irrDicts[NUM_OF_IRR_DICT];

BOOL OpenHeosaDict(HANDLE hDict, DWORD offset)
{
    DWORD    readBytes;
    //HANDLE    hDict;
    int i;
    _HeosaDictHeader dictHeader;

    //hDict = CreateFile(lpFileName, GENERIC_READ, 0, 0, 
    //                OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);
    //if (hDict==INVALID_HANDLE_VALUE) return FALSE;

    // Read Header
    SetFilePointer(hDict, offset, 0, FILE_BEGIN);
    ReadFile(hDict, &dictHeader, sizeof(_HeosaDictHeader), &readBytes, 0);
    //if (strcmp(COPYRIGHT_STR, dictHeader.COPYRIGHT_HEADER)!=0) return FALSE;
     SetFilePointer(hDict, offset + dictHeader.iStart, 0, FILE_BEGIN);

    // Open 4 Heosa dicts
    for (i=0; i<NUM_OF_HEOSA_DICT; i++)
        heosaDicts[i] = new CFSADict(hDict, dictHeader.heosaDictSparseMatSize[i], 
                                    dictHeader.heosaDictActionSize[i]);

    // oOpen 36 irrgular dicts
    for (i=0; i<NUM_OF_IRR_DICT; i++)
         irrDicts[i] = new CFSAIrrDict(hDict, dictHeader.irrDictSize[i]);    
    //CloseHandle(hDict);
    return TRUE;
}

void CloseHeosaDict()
{
    int i;

    for (i=0; i<NUM_OF_HEOSA_DICT; i++)
        delete heosaDicts[i];

    for (i=0; i<NUM_OF_IRR_DICT; i++)
         delete irrDicts[i];
}

/////////////////////////////////////////////////////////////////////////////
// Find word from Heosa dict.
int FindHeosaWord(LPCSTR lpWord, BYTE heosaPumsa, BYTE *actCode)
{
    return(heosaDicts[heosaPumsa]->Find(lpWord, actCode));
}

int FindIrrWord(LPCSTR lpWord, int irrCode)
{
    return irrDicts[irrCode]->Find(lpWord);
}


/*
int FindHeosaWord(LPCSTR lpWord, BYTE heosaPumsa, BYTE *actCode)
{
    char        invInternal[256];
    int ret;


#ifdef _MBCS    
    WCHAR        uni[256];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCTSTR)lpWord, -1, uni, 256);
    UniToInvInternal(uni, invInternal, wcslen(uni));
#elif _UNICODE
    UniToInvInternal(lpWord, invInternal, wcslen(uni));
#endif

    ret = heosaDicts[heosaPumsa]->Find(invInternal, actCode);
    //*actCode = BYTE((ret & 0xFF00)>>8);
    return ret;
    
}

/////////////////////////////////////////////////////////////////////////////
// Find word from Irregular dict.
int FindIrrWord(LPCSTR lpWord, int irrCode)
{
    char        internal[256];
        
#ifdef _MBCS    
    WCHAR        uni[256];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCTSTR)lpWord, -1, uni, 256);
    UniToInternal(uni, internal, wcslen(uni));
#elif _UNICODE
    UniToInternal(lpWord, internal, wcslen(uni));
#endif
    return irrDicts[irrCode]->Find(internal);
    
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\readsilsadict.h ===
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
#ifndef __READSILSADICT_H__
#define __READSILSADICT_H__

#include "BSDict.h"
/////////////////////////////////////////////////////////////////////////////
// Global Fuction for silsa dict
BOOL OpenSilsaDict(HANDLE hDict, DWORD offset=0);
void CloseSilsaDict();
int FindSilsaWord(LPCTSTR lpWord);

#endif // !__READSILSADICT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by STEMKOR.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\readheosadict.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// ReadHeosaDict.h : 
//
// Owner  : ChaeSeong Lim, HET MSCH RND (e-mail:cslim@microsoft.com)
//             
// History : 1996/Mar
/////////////////////////////////////////////////////////////////////////////
#ifndef __READHEOSADICT_H__
#define __READHEOSADICT_H__

#include "FSADict.h"
#include "HeosaDictHeader.h"
#include "UniToInt.h"

#define FINAL        1        // 00000001
#define FINAL_MORE    3        // 00000011

#define NOT_FOUND    4        // 00000100
#define FALSE_MORE 12        // 00001100

/////////////////////////////////////////////////////////////////////////////
//  Declaration of PumSa
enum _heoSaPumsa { _ENDING, _TOSSI, _AUXVERB, _AUXADJ };

/////////////////////////////////////////////////////////////////////////////
//  Global Access functions
BOOL OpenHeosaDict(HANDLE hDict, DWORD offset=0);
void CloseHeosaDict();
int FindHeosaWord(LPCSTR lpWord, BYTE heosaPumsa, BYTE *actCode);
int FindIrrWord(LPCSTR lpWord, int irrCode);

#endif // !__READHEOSADICT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\readsilsadict.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// Global fuction for writing to file
//#include "stdafx.h"
#include "pch.cxx"
#include "ReadSilsaDict.h"

static CDoubleFileBSDict *LenDicts[MAX_LENGTH_DICT];
// points to block in the dictionary file.
static _DictHeader    dictHeader;
static HANDLE        hDict;
static DWORD        fpLengthDicBlock[MAX_LENGTH_DICT];

/////////////////////////////////////////////////////////////////////////////
// Open and Read Silsa dictionary index
// offset : offset from start of MainDict to Sialsa Dict.
//            for one lex dict.
BOOL OpenSilsaDict(HANDLE _hDict, DWORD offset)
{
    DWORD    readBytes;

    hDict = _hDict;

//    hDict = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, 0, 
//                    OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, 0);

    //ReadFile(hDict, &stamp, strlen(dictHeader.COPYRIGHT_HEADER), &readBytes, 0);
    //stamp[strlen(COPYRIGHT_HEADER)] = 0;
    //if (strcmp(COPYRIGHT_HEADER, stamp)!=0) return FALSE;

    SetFilePointer(hDict, offset, 0, FILE_BEGIN);    
    ReadFile(hDict, &dictHeader, sizeof(_DictHeader), &readBytes, 0);
    //if (strcmp(COPYRIGHT_STR, dictHeader.COPYRIGHT_HEADER)!=0) return FALSE;
    SetFilePointer(hDict, offset+SILSA_DICT_HEADER_SIZE, 0, FILE_BEGIN);
    
    LenDicts[0] = new CDoubleFileBSDict();
    LenDicts[0]->LoadIndex(hDict);
    fpLengthDicBlock[0] = offset + dictHeader.iBlock;

    for (int i=1; i<dictHeader.numOfLenDict; i++) {
        LenDicts[i] = new CDoubleFileBSDict();
        LenDicts[i]->LoadIndex(hDict);
        fpLengthDicBlock[i] = fpLengthDicBlock[i-1] + LenDicts[i-1]->GetBlockSize() * 
                                            LenDicts[i-1]->GetNumOfBlocks();
    }

    return TRUE;
}

void CloseSilsaDict()
{
    if (hDict) {
        //CloseHandle(hDict);
        for (int i=0; i<dictHeader.numOfLenDict; i++) {
            delete LenDicts[i];
            LenDicts[i] = 0;
        }
    }
    hDict = 0;
}

/////////////////////////////////////////////////////////////////////////////
// Find word from silsa dict.
int FindSilsaWord(LPCTSTR lpWord)
{
#ifdef _MBCS
    int wordLen = strlen(lpWord)>>1;
#elif _UNICODE
    int wordLen = lstrlen(lpWord);
#endif
    if (wordLen>MAX_LENGTH_DICT || wordLen <= 0) return 0;
    return LenDicts[wordLen-1]->FindWord(hDict, fpLengthDicBlock[wordLen-1], lpWord);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>            // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\stemcf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       stemcf.cxx
//
//  Contents:   Stemmer class factory
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "stemcf.hxx"
#include "stemmer.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CStemmerCF
//
//  Synopsis:   Stemmer class factory constructor
//
//--------------------------------------------------------------------------

CStemmerCF::CStemmerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::~CStemmerCF
//
//  Synopsis:   Stemmer class factory destructor
//
//--------------------------------------------------------------------------

CStemmerCF::~CStemmerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( riid == IID_IClassFactory )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CreateInstance
//
//  Synopsis:   Creates new CStemmer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::CreateInstance( IUnknown * pUnkOuter,
                                                    REFIID riid,
                                                    void  * * ppvObject )
{
    CStemmer *pIUnk = 0;
    SCODE sc = S_OK;

    __try
    {
        pIUnk = new CStemmer( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998 - 1999, Microsoft Corporation.
//
// File:        Register.cxx
//
// Contents:    Self-registration for Word Breaker /Stemmer.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
// Registry constants
//

WCHAR const wszClsWordBreak[] = L"{31b7c920-2880-11d0-8d51-00a0c908dbf1}";
WCHAR const wszClsStemmer[] = L"{37c84fa0-d3db-11d0-8d51-00a0c908dbf1}";

WCHAR const wszCILang[] = L"System\\CurrentControlSet\\Control\\ContentIndex\\Language";

WCHAR const wszThisLang[] = L"Korean_Default";

WCHAR const wszClsidPath[]   = L"CLSID";

WCHAR const * aThisLangKeyValue[] = {
               L"WBreakerClass",             wszClsWordBreak,
               L"StemmerClass",              wszClsStemmer,
               L"StemmerDictionary",         L"korwbrkr.lex"};

DWORD  dwLocale = 1042;

WCHAR const *aWBClassKeyValue[] = {
        wszClsWordBreak,   0,                 L"Korean_Default Word Breaker",
        L"InprocServer32", 0,                 L"korwbrkr.dll",
        0,                 L"ThreadingModel", L"Both",
};

WCHAR const *aSTClassKeyValue[] = {
         wszClsStemmer,   0,                  L"Korean_Default Stemmer",
        L"InprocServer32", 0,                 L"korwbrkr.dll",
        0,                 L"ThreadingModel", L"Both",
};


//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created 
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    const  HKEY HKeyInvalid = 0;
    WCHAR  wcTemp[MAX_PATH];
    DWORD  dwDisposition;
    LONG   sc;
    HKEY   hKey;
    UINT   i;
    DWORD  dwNumofValues, dwNumofKeys; 

    //
    // Create Sub-key <My Lang> in ContentIndex\Lang section
    //

    wcscpy(wcTemp, wszCILang);
    wcscat(wcTemp, L"\\");
    wcscat(wcTemp, wszThisLang);

    hKey = HKeyInvalid;

    sc = RegCreateKeyExW( HKEY_LOCAL_MACHINE,  // Root
                         wcTemp,               // Sub key
                         0,                    // Reserved
                         0,                    // Class
                         0,                    // Flags
                         KEY_ALL_ACCESS,       // Access
                         0,                    // Security
                         &hKey,                // Handle
                         &dwDisposition );     // Disposition

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        return E_UNEXPECTED;
    }

    //
    // Delete vaules for this sub-key
    //


    for (i=0; i < sizeof(aThisLangKeyValue)/sizeof(aThisLangKeyValue[0]); i+=2)
    {
        sc = RegDeleteValueW(hKey,                           // Key
                             aThisLangKeyValue[i]);          // Name

        if ( ERROR_SUCCESS != sc )
        {
             sc = HRESULT_FROM_WIN32( sc );
             if ( HKeyInvalid != hKey )
             {
                RegCloseKey( hKey );
                hKey = HKeyInvalid;
             }

             return E_UNEXPECTED;
        }
    }

    sc = RegDeleteValueW(hKey,                           // Key
                         L"Locale");                     // Name

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }

   
    dwNumofValues=0;
    dwNumofKeys=0;

    sc = RegQueryInfoKeyW( hKey,          // Hkey 
                           NULL,          // Buffer for class string
                           NULL,          // Size of class string buffer
                           NULL,          // reserved
                           &dwNumofKeys,  // for number of subkeys
                           NULL,          // longest subkey name length
                           NULL,          // For longest class string length
                           &dwNumofValues,// For number of value entries
                           NULL,          // For longest value name length
                           NULL,          // longest value data length  
                           NULL,          // For security descriptor length
                           NULL );        // For last write time); 

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }

    if ( (dwNumofValues == 0) && (dwNumofKeys==0) ) {

       // There is no value and sub-key under this key,
       //
       // So Delete the sub-key for this sub-Lang.
       //

       if ( HKeyInvalid != hKey )
       {
          RegCloseKey( hKey );
          hKey = HKeyInvalid;
       }

       wcscpy(wcTemp, wszCILang);

       sc = RegCreateKeyExW(HKEY_LOCAL_MACHINE,   // Root
                            wcTemp,               // Sub key
                            0,                    // Reserved
                            0,                    // Class
                            0,                    // Flags
                            KEY_ALL_ACCESS,       // Access
                            0,                    // Security
                            &hKey,                // Handle
                            &dwDisposition );     // Disposition

       if ( ERROR_SUCCESS != sc )
       {
           sc = HRESULT_FROM_WIN32( sc );
           return E_UNEXPECTED;
       }

       sc = RegDeleteKeyW( hKey,                 // Root
                           wszThisLang);         // Subkey String

       if ( ERROR_SUCCESS != sc )
       {
          sc = HRESULT_FROM_WIN32( sc );
          if ( HKeyInvalid != hKey )
          {
              RegCloseKey( hKey );
              hKey = HKeyInvalid;
          }

          return E_UNEXPECTED;
       }
    
    }

    if ( HKeyInvalid != hKey )
    {
        RegCloseKey( hKey );
        hKey = HKeyInvalid;
    }

    //
    // Then Delete class entry :  Word Breaker and Stemmer.
    //

    wcscpy( wcTemp, wszClsidPath );
    wcscat( wcTemp, L"\\");
    wcscat( wcTemp, wszClsWordBreak); 

    sc = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                          wcTemp,               // Sub key
                          0,                    // Reserved
                          0,                    // Class
                          0,                    // Flags
                          KEY_ALL_ACCESS,       // Access
                          0,                    // Security
                          &hKey,                // Handle
                          &dwDisposition );     // Disposition

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
           RegCloseKey( hKey );
           hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }

    sc = RegDeleteKeyW(hKey, L"InprocServer32"); 

    if ( ERROR_SUCCESS != sc )
    {
         sc = HRESULT_FROM_WIN32( sc );
         if ( HKeyInvalid != hKey )
         {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
         }

         return E_UNEXPECTED;
    }

    if ( HKeyInvalid != hKey )
    {
        RegCloseKey( hKey );
        hKey = HKeyInvalid;
    }

    wcscpy( wcTemp, wszClsidPath );
    wcscat( wcTemp, L"\\");
    wcscat( wcTemp, wszClsStemmer);

    sc = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                          wcTemp,               // Sub key
                          0,                    // Reserved
                          0,                    // Class
                          0,                    // Flags
                          KEY_ALL_ACCESS,       // Access
                          0,                    // Security
                          &hKey,                // Handle
                          &dwDisposition );     // Disposition

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
           RegCloseKey( hKey );
           hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }

    sc = RegDeleteKeyW(hKey, L"InprocServer32");

    if ( ERROR_SUCCESS != sc )
    {
         sc = HRESULT_FROM_WIN32( sc );
         if ( HKeyInvalid != hKey )
         {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
         }

         return E_UNEXPECTED;
    }

    if ( HKeyInvalid != hKey )
    {
        RegCloseKey( hKey );
        hKey = HKeyInvalid;
    }

    wcscpy( wcTemp, wszClsidPath );

    sc = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                          wcTemp,               // Sub key
                          0,                    // Reserved
                          0,                    // Class
                          0,                    // Flags
                          KEY_ALL_ACCESS,       // Access
                          0,                    // Security
                          &hKey,                // Handle
                          &dwDisposition );     // Disposition

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
           RegCloseKey( hKey );
           hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }

    sc = RegDeleteKeyW(hKey, wszClsWordBreak);

    if ( ERROR_SUCCESS != sc )
    {
         sc = HRESULT_FROM_WIN32( sc );
         if ( HKeyInvalid != hKey )
         {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
         }

         return E_UNEXPECTED;
    }
 

    sc = RegDeleteKeyW(hKey, wszClsStemmer);

    if ( ERROR_SUCCESS != sc )
    {
         sc = HRESULT_FROM_WIN32( sc );
         if ( HKeyInvalid != hKey )
         {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
         }

         return E_UNEXPECTED;
    }

    if ( HKeyInvalid != hKey )
        RegCloseKey( hKey );

    return S_OK;

}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{

    const  HKEY HKeyInvalid = 0;
    WCHAR  wcTemp[MAX_PATH];
    DWORD  dwDisposition;
    LONG   sc;
    HKEY   hKey;
    UINT   i;

    //
    // Create Sub-key <My language> in ContentIndex\Lang section
    //

    hKey = HKeyInvalid;

    wcscpy(wcTemp, wszCILang);
    wcscat(wcTemp, L"\\");
    wcscat(wcTemp, wszThisLang);

    sc = RegCreateKeyExW( HKEY_LOCAL_MACHINE,  // Root
                         wcTemp,               // Sub key
                         0,                    // Reserved
                         0,                    // Class
                         0,                    // Flags
                         KEY_ALL_ACCESS,       // Access
                         0,                    // Security
                         &hKey,                // Handle
                         &dwDisposition );     // Disposition

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }

    //  
    // Add vaules for this sub-key
    //
        

    for (i=0; i < sizeof(aThisLangKeyValue)/sizeof(aThisLangKeyValue[0]); i+=2)
    {
        sc = RegSetValueExW( hKey,                           // Key
                             aThisLangKeyValue[i],           // Name
                             0,                              // Reserved
                             REG_SZ,                         // Type
                             (BYTE *)aThisLangKeyValue[i+1], // Value
                             (1 + wcslen(aThisLangKeyValue[i+1])) *
                                 sizeof(WCHAR) );            // Size

        if ( ERROR_SUCCESS != sc )
        {
             sc = HRESULT_FROM_WIN32( sc );
             if ( HKeyInvalid != hKey )
             {
                RegCloseKey( hKey );
                hKey = HKeyInvalid;
             }

             return E_UNEXPECTED;
        }
    }

    sc = RegSetValueExW( hKey,                           // Key
                         L"Locale",                      // Name
                         0,                              // Reserved
                         REG_DWORD,                      // Type
                         (BYTE *)&dwLocale,              // Value
                         sizeof(DWORD));                 // Size 

    if ( ERROR_SUCCESS != sc )
    {
        sc = HRESULT_FROM_WIN32( sc );
        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }

        return E_UNEXPECTED;
    }


    if ( HKeyInvalid != hKey )
    {
        RegCloseKey( hKey );
        hKey = HKeyInvalid;
    }

    //
    // Then create class entry :  Word Breaker and Stemmer.
    //

    //  For Word Breaker setting

    wcscpy( wcTemp, wszClsidPath );

    for (i=0; i < sizeof(aWBClassKeyValue)/sizeof(aWBClassKeyValue[0]); i+=3)
    {
        if ( 0 != aWBClassKeyValue[i] )
        {
            wcscat( wcTemp, L"\\" );
            wcscat( wcTemp, aWBClassKeyValue[i] );
        }

        sc = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                             wcTemp,               // Sub key
                             0,                    // Reserved
                             0,                    // Class
                             0,                    // Flags
                             KEY_ALL_ACCESS,       // Access
                             0,                    // Security
                             &hKey,                // Handle
                             &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            if ( HKeyInvalid != hKey )
            {
               RegCloseKey( hKey );
               hKey = HKeyInvalid;
            }

            return E_UNEXPECTED;
        }

        sc = RegSetValueExW( hKey,                          // Key
                            aWBClassKeyValue[i+1],         // Name
                            0,                             // Reserved
                            REG_SZ,                        // Type
                            (BYTE *)aWBClassKeyValue[i+2], // Value
                            (1 + wcslen(aWBClassKeyValue[i+2])) *
                                sizeof(WCHAR) );           // Size

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            if ( HKeyInvalid != hKey )
            {
               RegCloseKey( hKey );
               hKey = HKeyInvalid;
            }

            return E_UNEXPECTED;
        }

        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }
    }

    if ( HKeyInvalid != hKey )
        RegCloseKey( hKey );

    // For Stemmer setting

    wcscpy( wcTemp, wszClsidPath );

    for (i=0; i < sizeof(aSTClassKeyValue)/sizeof(aSTClassKeyValue[0]); i+=3)
    {
        if ( 0 != aSTClassKeyValue[i] )
        {
            wcscat( wcTemp, L"\\" );
            wcscat( wcTemp, aSTClassKeyValue[i] );
        }

        sc = RegCreateKeyExW( HKEY_CLASSES_ROOT,    // Root
                             wcTemp,               // Sub key
                             0,                    // Reserved
                             0,                    // Class
                             0,                    // Flags
                             KEY_ALL_ACCESS,       // Access
                             0,                    // Security
                             &hKey,                // Handle
                             &dwDisposition );     // Disposition

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            if ( HKeyInvalid != hKey )
            {
               RegCloseKey( hKey );
               hKey = HKeyInvalid;
            }

            return E_UNEXPECTED;
        }

        sc = RegSetValueExW( hKey,                          // Key
                            aSTClassKeyValue[i+1],         // Name
                            0,                             // Reserved
                            REG_SZ,                        // Type
                            (BYTE *)aSTClassKeyValue[i+2], // Value
                            (1 + wcslen(aSTClassKeyValue[i+2])) *
                                sizeof(WCHAR) );           // Size

        if ( ERROR_SUCCESS != sc )
        {
            sc = HRESULT_FROM_WIN32( sc );
            if ( HKeyInvalid != hKey )
            {
               RegCloseKey( hKey );
               hKey = HKeyInvalid;
            }

            return E_UNEXPECTED;
        }

        if ( HKeyInvalid != hKey )
        {
            RegCloseKey( hKey );
            hKey = HKeyInvalid;
        }
    }

    if ( HKeyInvalid != hKey )
        RegCloseKey( hKey );


    if ( FAILED(sc) )
    {
        DllUnregisterServer();
        return E_UNEXPECTED;
    }
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\unitoint.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
// UniToInvInt.h : 
//
// Owner  : ChaeSeong Lim, HET MSCH RND (e-mail:cslim@microsoft.com)
//             
// History : 1996/April
//
// Convert unicode hangul to reversed internal format.
/////////////////////////////////////////////////////////////////////////////
#ifndef __UNITOINVINT_H__
#define __UNITOINVINT_H__

// Convert from Unicode Hangul to Inversed internal code decomposed by jaso.
BOOL UniToInvInternal(LPCWSTR lpUniStr, LPSTR lpIntStr, int BufLength);
BOOL UniToInternal(LPCWSTR lpUniStr, LPSTR lpIntStr, int BufLength);
BOOL InternalToUni(LPCSTR lpInternal, LPWSTR lpUniStr, int BufLength);

#endif    // !__UNITOINVINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\stemmer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       stemmer.cxx
//
//  Contents:   Korean Stemmer
//
//  History:    weibz,   10-Sep-1997   created
//
//----------------------------------------------------------------------------

#include <pch.cxx>

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( riid == IID_IStemmer )
            pUnkTemp = (IUnknown *)(IStemmer *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense )
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD)))
        return E_INVALIDARG;

    if ( !StemInit() )
        return LANGUAGE_E_DATABASE_NOT_FOUND;

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";

    if ( NULL == ppwcsLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwcInBuf,
    ULONG cwc,
    IStemSink *pStemSink )
{
    INT nReturn;
    SCODE sc = S_OK;

#ifdef KORDBG
    ULONG  i;
    OutputDebugString("\n Stemword\n");
    for (i=0; i<cwc; i++)
    {
          WORD  wtmp;
          char  ctmp[80];

          wtmp = pwcInBuf[i];
          sprintf(ctmp, "%4x ", wtmp);
          OutputDebugString(ctmp);
    }
#endif

    if ( NULL == pStemSink  || NULL == pwcInBuf) {
        return E_FAIL;
    }

    // Currently, Korean stemmer doesn't make inflection form for tripolli.
    pStemSink->PutWord (pwcInBuf, cwc);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\wordhash.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
//#include "stdafx.h"
#include "pch.cxx"

#include "Hash.h"

//#ifdef _INSTRUMENT
//#include "clog.h"
//#endif

BYTE    CWordHash::m_lpHashTable[WORD_HASH_SIZE][20];

BOOL CWordHash::Find(LPCTSTR searchWord, BYTE *pumsa)
{
    UINT hashVal ;

    hashVal=CWordHash::Hash((const _TXCHAR*)searchWord);

//#ifdef _INSTRUMENT
//    _Log.IncreaseTotalAccess(searchWord);
//#endif

    if (lstrcmp((LPCTSTR)m_lpHashTable[hashVal], searchWord)==0) {
        *pumsa = m_lpHashTable[hashVal][19];
        //#ifdef _INSTRUMENT
        //    _Log.IncreaseHit();
        //#endif
        return TRUE;
    }
//#ifdef _INSTRUMENT
//    _Log.IncreaseFail();
//#endif
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\wbclassf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       wbclassf.cxx
//
//  Contents:   Word Breaker class factory
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "wbclassf.hxx"
#include "iwbreak.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory constructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::CWordBreakerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::~CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory destructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::~CWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreakerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1& 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF ) {
    case 0x00:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( memcmp( &IID_IClassFactory, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject )
{
    CWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    if (NULL != pUnkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return E_NOINTERFACE;
    }

    __try 
    {
        pIUnk = new CWordBreaker( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\stemkor.h ===
/*
 *  Copyright (C) 1997 - 1998, Microsoft Corporation.  All Rights Reserved.
 *
 * STEMKOR.H - API entry header file for Korean Stemmer API
 *
 * See korstem.doc for details
 * Date - 1996 Jan. made by dhyu
 */

#ifndef STEMKOR_H
#define STEMKOR_H

typedef ULONG_PTR      HSTM;        /* Stemmer ID type */
typedef unsigned int   UINT;
typedef unsigned int   SRC;            /* stemmer return code */
typedef unsigned short USHORT;

/* Major Options */
#define SO_NOUNPHRASE    0x00000001
#define SO_PREDICATE     0x00000002
#define SO_ALONE         0x00000004
#define SO_AUXILIARY     0x0000000a    /* SO_PREDICATE | 0x00000008 */
#define SO_COMPOUND      0x00000011    /* SO_NOUNPHRASE | 0x00000010 */
#define SO_SUFFIX        0x00000021    /* SO_NOUNPHRASE | 0x00000020 */

/* Minor Options : If major options are not set, this options don't have no meaning.
         Some minor options also can be inserted anytime.
/* If SO_NOUNPHRASE is not defined, the following four have no meaning. */
#define SO_NP_NOUN        0x00000100
#define SO_NP_PRONOUN     0x00000200
#define SO_NP_NUMBER      0x00000400
#define SO_NP_DEPENDENT   0x00000800
#define SO_NP_PROPER      0x00001000

/* If SO_SUFFIX is not define, the following have no meaning.
   In future, thease can be inserted. I don't know which suffix is inserted yet. */
#define SO_SUFFIX_JEOG        0x00002000


typedef struct tagDecomposeOutBuffer {
    LPSTR wordlist;                /* pointer to the result
                                    format : word\0word_info\0word\0word_info\0 ... */
    unsigned short num;                /* the number of saperated words */
    unsigned short sch;                /* total space of chars in wordlist
                                        application should assign this value */
    unsigned short len;                /* returned byte contains the result */
}DOB;

typedef struct tagDecomposeOutBufferW {
    LPWSTR wordlist;

    unsigned short num;
    unsigned short sch;
    unsigned short len;
}WDOB;

typedef DOB * LPDOB;
typedef WDOB * LPWDOB;

typedef struct tagComposeInputBuffer {
    LPSTR silsa;
    LPSTR heosa;
    WORD pos;
}CIB;

typedef struct tagComposeInputBufferW {
    LPWSTR silsa;
    LPWSTR heosa;
    WORD pos;
}WCIB;

#ifdef _UNICODE
#define LPTDOB LPWDOB
#define TCIB    WCIB
#define TDOB    WDOB
#else
#define LPTDOB LPDOB
#define TCIB    CIB
#define TDOB    DOB
#endif

typedef WORD FAR PASCAL FNDECOMPOSE (LPDOB);
typedef FNDECOMPOSE FAR *LPFNDECOMPOSE;

typedef WORD FAR PASCAL FNDECOMPOSEW (LPWDOB);
typedef FNDECOMPOSEW FAR *LPFNDECOMPOSEW;

// Word Info : two byte
/* Word Info : most left 4 bits of high byte */
#define                wtINVALID              0xffff
#define                wtSilsa                0x8000
#define                wtHeosa                0x0000

/* general POS (a part of speech) info : right 4 bits of high byte */
#define                POS_NOUN             0x0100
#define                POS_VERB             0x0200
#define                POS_ADJECTIVE        0x0300
#define                POS_PRONOUN          0x0400
#define                POS_TOSSI            0x0500
#define                POS_ENDING           0x0600
#define                POS_ADVERB           0x0700
#define                POS_SUFFIX           0x0800
#define                POS_AUXVERB          0x0900
#define                POS_AUXADJ           0x0a00
#define                POS_SPECIFIER        0x0b00
#define                POS_NUMBER           0x0c00
#define                POS_PREFIX           0x0d00
#define                POS_OTHERS           0x0f00

/* low byte : more detail POS info
    ---  more word infos will be inserted in the near future */
#define                DEOL_SUFFIX          0x0001
#define                COPULA_OTHERS        0x0002
#define                PROPER_NOUN          0x0003

/* Flag define for StemmerIsEnding */
#define                IS_ENDING            0x0001
#define                IS_TOSSI             0x0002

/* return code : Low Byte SRC */
#define srcOOM                            1
#define srcInvalid                        2    /* Unknown word */
#define srcModuleError                    3    /* Something wrong with parameters, or state of stemmer module */
#define srcIOErrorMdr                     4
#define srcIOErrorUdr                     5
#define srcNoMoreResult                   6
#define    srcComposeError                7


/* Minor Error Codes. Not set unless major code also set. */
/* High Byte of SRC word var. */
#define srcModuleAlreadyBusy      (128<<16)   /* For non-reentrant code */
#define srcInvalidID              (129<<16)   /* Not yet inited or already terminated.*/
#define srcExcessBuffer           (130<<16)   /* return buffer size is smaller than needed */
#define srcInvalidMdr             (131<<16)   /* Mdr not registered with spell session */
#define srcInvalidUdr             (132<<16)   /* Udr not registered with spell session */
#define srcInvalidMainDict        (134<<16)   /* Specified dictionary not correct format */
#define srcOperNotMatchedUserDict (135<<16)   /* Illegal operation for user dictionary type. */
#define srcFileReadError          (136<<16)   /* Generic read error */
#define srcFileWriteError         (137<<16)   /* Generic write error */
#define srcFileCreateError        (138<<16)   /* Generic create error */
#define srcFileShareError         (139<<16)   /* Generic share error */
#define srcModuleNotTerminated    (140<<16)   /* Module not able to be terminated completely.*/
#define srcUserDictFull           (141<<16)   /* Could not update Udr without exceeding limit.*/
#define srcInvalidUdrEntry        (142<<16)   /* invalid chars in string(s) */
#define srcMdrCountExceeded       (144<<16)   /* Too many Mdr references */
#define srcUdrCountExceeded       (145<<16)   /* Too many udr references */
#define srcFileOpenError          (146<<16)   /* Generic Open error */
#define srcFileTooLargeError      (147<<16)      /* Generic file too large error */
#define srcUdrReadOnly            (148<<16)   /* Attempt to add to or write RO udr */

#define WINSRC    SRC
//------------------------- FUNCTION LIST -----------------------------------
extern WINSRC    StemmerInit           (HSTM  *);
extern WINSRC    StemmerSetOption      (HSTM, UINT);
extern WINSRC    StemmerGetOption      (HSTM, UINT *);
extern WINSRC     StemmerDecompose     (HSTM, LPCSTR, LPDOB);
extern WINSRC     StemmerDecomposeW    (HSTM, LPCWSTR, LPWDOB);
extern WINSRC    StemmerDecomposeMore  (HSTM, LPCSTR, LPDOB);
extern WINSRC    StemmerDecomposeMoreW (HSTM, LPCWSTR, LPWDOB);
extern WINSRC    StemmerEnumDecompose  (HSTM, LPCSTR, LPDOB, LPFNDECOMPOSE);
extern WINSRC    StemmerEnumDecomposeW (HSTM, LPCWSTR, LPWDOB, LPFNDECOMPOSE);
extern WINSRC    StemmerCompose        (HSTM, CIB, LPSTR);
extern WINSRC    StemmerComposeW       (HSTM, WCIB, LPWSTR);
extern WINSRC    StemmerCompare        (HSTM, LPCSTR, LPCSTR, LPSTR, LPSTR, LPSTR, WORD *);
extern WINSRC    StemmerCompareW       (HSTM, LPCWSTR, LPCWSTR, LPWSTR, LPWSTR, LPWSTR, WORD *);
extern WINSRC    StemmerOpenMdr        (HSTM, char *);
extern WINSRC    StemmerCloseMdr       (HSTM);
extern WINSRC    StemmerTerminate      (HSTM);
extern WINSRC    StemmerOpenUdr        (HSTM, LPCSTR);
extern WINSRC    StemmerCloseUdr       (HSTM);
extern WINSRC    StemmerIsEnding       (HSTM, LPCSTR, UINT, BOOL *);
extern WINSRC    StemmerIsEndingW      (HSTM, LPCWSTR, UINT, BOOL *);

#define STEMMERKEY  "SYSTEM\\currentcontrolset\\control\\ContentIndex\\Language\\Korean_Default"
#define STEM_DICTIONARY  "StemmerDictionary"

BOOL StemInit();

#endif /* STEMKOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor\unitoint.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
//#include "stdafx.h"
#include "pch.cxx"
#include "UniToInt.h"

#define NUMBER_OF_CHOSUNG             19
#define NUMBER_OF_JUNGSUNG            21
#define NUMBER_OF_JONGSUNG            28    // include fill code

#define HANGUL_COMP_JAMO_START        0x3131
#define HANGUL_COMP_JAMO_END          0x3163
#define HANGUL_COMP_JAMO_START_FILL   0x3130
#define HANGUL_COMP_JAMO_SIOT         0x3145
#define HANGUL_START                  0xAC00
#define HANGUL_END                    0xD7A3

///////////////////////////////////////////
// HANGUL Jaso difinitions

// ChoSung
#define KIYEOK            1
#define SSANGKIYEOK       2
#define NIEUN             3
#define SSANGNIEUN        4    // not used
#define TIKEUT            5
#define SSANGTIKEUT       6
#define RIEUL             7
#define SSANGRIEUL        8    // not used
#define MIEUM            10
#define PIEUP            11
#define SSANGPIEUP       12
#define SIOS             13
#define SSANGSIOS        14
#define IEUNG            15
#define CIEUC            16
#define SSANGCIEUC       17
#define CHIEUCH          18
#define KHIEUKH          19
#define THIEUTH          20
#define PHIEUPH          21
#define HIEUH            22
// JungSung
#define A                23
#define AE               24
#define YA               25
#define YAE              26
#define EO               27
#define E                28
#define YEO              29
#define YE               30
#define O                31
#define WA               33
#define WAE              34
#define OE               35
#define YO               36
#define U                37
#define WEO              38
#define WE               39
#define WI               40
#define YU               41
#define EU               42
#define YI               43
#define I                44
////////////////////////////////////////

// Cho sung mapping table
static 
BYTE ChoSungMapTable[19] = 
{
    KIYEOK,        SSANGKIYEOK,
    NIEUN,        
    TIKEUT,        SSANGTIKEUT,
    RIEUL,
    MIEUM,    
    PIEUP,         SSANGPIEUP,
    SIOS,          SSANGSIOS,
    IEUNG,
    CIEUC,         SSANGCIEUC,
    CHIEUCH,
    KHIEUKH,
    THIEUTH,
    PHIEUPH,
    HIEUH,
};

// Jung sung mapping table
static 
BYTE JungSungMapTable[21] = 
{
    A, AE, YA, YAE, EO, E, YEO, YE, O, WA, WAE, OE, YO, U, WEO, WE, WI, YU, EU, YI, I,
};

// Jong sung mapping table
static 
BYTE JongSungMapTable[28][2] = 
{
    { 0,              0       },        // Fill
    { KIYEOK,         0       },
    { SSANGKIYEOK,    0       },
    { KIYEOK,         SIOS    },
    { NIEUN,          0       },
    { NIEUN,          CIEUC   },
    { NIEUN,          HIEUH   },
    { TIKEUT,         0       },
    { RIEUL,          0       },
    { RIEUL,          KIYEOK  },
    { RIEUL,          MIEUM   },
    { RIEUL,          PIEUP   },
    { RIEUL,          SIOS    },
    { RIEUL,          THIEUTH },
    { RIEUL,          PHIEUPH },
    { RIEUL,          HIEUH   },
    { MIEUM,          0       },
    { PIEUP,          0       },
    { PIEUP,          SIOS    },
    { SIOS,           0       }, 
    { SSANGSIOS,      0       }, 
    { IEUNG,          0       },    
    { CIEUC,          0       },    
    { CHIEUCH,        0       },
    { KHIEUKH,        0       },
    { THIEUTH,        0       },
    { PHIEUPH,        0       },
    { HIEUH,          0       }
};

static
BYTE JamoMapTable[51][2] =
{
    { KIYEOK,              0      },
    { SSANGKIYEOK,         0      },
    { KIYEOK,              SIOS   },
    { NIEUN,               0      },
    { NIEUN,               CIEUC  },
    { NIEUN,               HIEUH  },
    { TIKEUT,              0      },    
    { SSANGTIKEUT,         0      },
    { RIEUL,               0      },
    { RIEUL,               KIYEOK },
    { RIEUL,               MIEUM  },
    { RIEUL,               PIEUP  },
    { RIEUL,               SIOS   },
    { RIEUL,               THIEUTH },
    { RIEUL,               PHIEUPH },
    { RIEUL,               HIEUH  },
    { MIEUM,               0      },
    { PIEUP,               0      },
    { SSANGPIEUP,          0      },
    { PIEUP,               SIOS   },
    { SIOS,                0      }, 
    { SSANGSIOS,           0      }, 
    { IEUNG,               0      },    
    { CIEUC,               0      },
    { SSANGCIEUC,          0      },
    { CHIEUCH,             0      },
    { KHIEUKH,             0      },
    { THIEUTH,             0      },
    { PHIEUPH,             0      },
    { HIEUH,               0      },
    //
    { A,                0    },
    { AE,                0    },
    { YA,                0    },
    { YAE,                0    },
    { EO,                0    },
    { E,                0    },
    { YEO,                0    },
    { YE,                0    },
    { O,                0    },
    { WA,                0    },
    { WAE,                0    },
    { OE,                0    },
    { YO,                0    },
    { U,                0    },
    { WEO,                0    },
    { WE,                0    },
    { WI,                0    },
    { YU,                0    },
    { EU,                0    },
    { YI,                0    },
    { I,                0    }
};

inline static
void ChosungToInternal(BYTE jamo, LPSTR lpIntStr, int &idx)
{
    lpIntStr[idx++] = ChoSungMapTable[jamo];
}

inline static
void JungsungToInternal(BYTE jamo, LPSTR lpIntStr, int &idx)
{
    lpIntStr[idx++] = JungSungMapTable[jamo];
}


inline static
void JongsungToInternal(BYTE jamo, LPSTR lpIntStr, int &idx)
{
    if (jamo) {
        lpIntStr[idx++] = JongSungMapTable[jamo][0];
        if (JongSungMapTable[jamo][1])
            lpIntStr[idx++] = JongSungMapTable[jamo][1];
    }
}

inline static
void JamoToInternal(BYTE jamo, LPSTR lpIntStr, int &idx)
{
    lpIntStr[idx++] = JamoMapTable[jamo][0];
    if (JamoMapTable[jamo][1])
        lpIntStr[idx++] = JamoMapTable[jamo][1];
}


///////////////////////////////////////////////////////////////////////
BOOL UniToInvInternal(LPCWSTR lpUniStr, LPSTR _lpIntStr, int strLength)
{
    int i, j, idx=0;
    char lpIntStr[256];    // buffer is fixed (dangerous but quick and dirty method)

    for (i=0; i<strLength; i++) 
    {
        if (lpUniStr[i] <= HANGUL_COMP_JAMO_END && lpUniStr[i] >= HANGUL_COMP_JAMO_START) 
        {
            JamoToInternal(BYTE(lpUniStr[i]-HANGUL_COMP_JAMO_START), lpIntStr, idx);
            continue;
        } 
        ChosungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / 
                                    (NUMBER_OF_JONGSUNG*NUMBER_OF_JUNGSUNG) ),
                                    lpIntStr, idx );
            
        JungsungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / NUMBER_OF_JONGSUNG
                                                                % NUMBER_OF_JUNGSUNG ),
                                    lpIntStr, idx );

        JongsungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) % NUMBER_OF_JONGSUNG ),
                                    //+ NUMBER_OF_CHOSUNG + NUMBER_OF_JUNGSUNG),
                                  lpIntStr, idx );    //jongsung
    }

    // inverse processing
    for (i=0, j=idx-1; i<idx; i++, j--) 
        _lpIntStr[j] =  lpIntStr[i];
    _lpIntStr[idx] = 0;
    return TRUE;
}

BOOL UniToInternal(LPCWSTR lpUniStr, LPSTR lpIntStr, int strLength)
{
    int i, idx=0;
//    char lpIntStr[256];    // buffer is fixed (dangerous but quick and dirty method)

    for (i=0; i<strLength; i++) 
    {
        if (lpUniStr[i] <= HANGUL_COMP_JAMO_END && lpUniStr[i] >= HANGUL_COMP_JAMO_START) 
        {
            JamoToInternal(BYTE(lpUniStr[i]-HANGUL_COMP_JAMO_START), lpIntStr, idx);
            continue;
        } 
        ChosungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / 
                                    (NUMBER_OF_JONGSUNG*NUMBER_OF_JUNGSUNG) ),
                                    lpIntStr, idx );
            
        JungsungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / NUMBER_OF_JONGSUNG
                                                            % NUMBER_OF_JUNGSUNG),
                                    lpIntStr, idx );

        JongsungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) % NUMBER_OF_JONGSUNG ),
                                    //+ NUMBER_OF_CHOSUNG + NUMBER_OF_JUNGSUNG),
                                  lpIntStr, idx );    //jongsung
    }
    lpIntStr[idx] = 0;

    return TRUE;
}

/*
BOOL UniToInvInternal(LPCWSTR lpUniStr, LPSTR _lpIntStr, int strLength)
{
    int i, j, idx=0;
    char lpIntStr[256];    // buffer is fixed (dangerous but quick and dirty method)

    for (i=0; i<strLength; i++) 
    {
        if (lpUniStr[i] <= HANGUL_COMP_JAMO_END && lpUniStr[i] >= HANGUL_COMP_JAMO_START) 
        {
            if (lpUniStr[i] <= HANGUL_COMP_JAMO_SIOT)
                JamoToInternal(lpUniStr[i], lpIntStr, idx);
            else lpIntStr[idx++] = BYTE(lpUniStr[i] - HANGUL_COMP_JAMO_SIOT + 10);
            continue;
        } 
        lpIntStr[idx++] = BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / 
                                    (NUMBER_OF_JONGSUNG*NUMBER_OF_JUNGSUNG) ) + 1;//chosung
            
        lpIntStr[idx++] = BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / NUMBER_OF_JONGSUNG
                                % NUMBER_OF_JUNGSUNG + NUMBER_OF_CHOSUNG ) + 1;    //jungsung

        JongsungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) % NUMBER_OF_JONGSUNG ),
                                    //+ NUMBER_OF_CHOSUNG + NUMBER_OF_JUNGSUNG),
                                  lpIntStr, idx );    //jongsung
    }

    // inverse processing
    for (i=0, j=idx-1; i<idx; i++, j--) 
        _lpIntStr[j] =  lpIntStr[i];
    _lpIntStr[idx] = 0;
    return TRUE;
}

BOOL UniToInternal(LPCWSTR lpUniStr, LPSTR lpIntStr, int strLength)
{
    int i, idx=0;
//    char lpIntStr[256];    // buffer is fixed (dangerous but quick and dirty method)

    for (i=0; i<strLength; i++) 
    {
        if (lpUniStr[i] <= HANGUL_COMP_JAMO_END && lpUniStr[i] >= HANGUL_COMP_JAMO_START) 
        {
            if (lpUniStr[i] <= HANGUL_COMP_JAMO_SIOT)
                JamoToInternal(lpUniStr[i], lpIntStr, idx);
            else lpIntStr[idx++] = BYTE(lpUniStr[i] - HANGUL_COMP_JAMO_SIOT + 10);
            continue;
        } 
        lpIntStr[idx++] = BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / 
                                    (NUMBER_OF_JONGSUNG*NUMBER_OF_JUNGSUNG) ) + 1;//chosung
            
        lpIntStr[idx++] = BYTE( (WORD)(lpUniStr[i]-HANGUL_START) / NUMBER_OF_JONGSUNG
                                % NUMBER_OF_JUNGSUNG + NUMBER_OF_CHOSUNG ) + 1;    //jungsung

        JongsungToInternal(BYTE( (WORD)(lpUniStr[i]-HANGUL_START) % NUMBER_OF_JONGSUNG ),
                                    //+ NUMBER_OF_CHOSUNG + NUMBER_OF_JUNGSUNG),
                                  lpIntStr, idx );    //jongsung
    }
    lpIntStr[idx] = 0;

    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\analyze.cpp ===
// Analyze.cpp
//
// main CHART PARSING routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  31 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Analyze.h"
#include "Lookup.h"
#include "Morpho.h"
#include "unikor.h"
#include "GuessIndex.h"
#include "WbData.h"
#include "Token.h"

//////////////////////////////////////////////////////////////////////////////
// Definitions

// threshold for making index terms
const int THRESHOLD_MAKE_INDEX	= 3; 
const int LENGTH_MAKE_INDEX     = 4;

//////////////////////////////////////////////////////////////////////////////
// Function Declarations

BOOL PreFiltering(const WCHAR *pwzToken, int cchInput, WCHAR wchLast, CIndexInfo *pIndexInfo);
BOOL PreProcessingLeafNode(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool);

BOOL MakeCombinedRecord(PARSE_INFO *pPI, int nLeftRec, int nRightRec, float fWeight);

BOOL MakeIndexTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing);

BOOL MakeQueryTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing);

BOOL TraverseIndexString(PARSE_INFO *pPI, BOOL fOnlySuffix, WORD_REC *pWordRec, CIndexInfo *pIndexInfo);

BOOL TraverseQueryString(PARSE_INFO *pPI, WORD_REC *pWordRec, WCHAR *pwzSeqTerm, int cchSeqTerm);


//////////////////////////////////////////////////////////////////////////////
// Function Implementation

// AnalyzeString
//
// lookup & process CHART PARSING (index time)
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  fQuery      	-> (BOOL) query flag
//  pwzInput		-> (const WCHAR*) input string to analyze (NOT decomposed)
//  cchInput		-> (int) length of input string to analyze
//  cwcSrcPos		-> (int) original source start position
//  pIndexList		-> (CIndexList *) output index list
//  wchLast			-> (WCHAR) last character of previous token
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 12APR00  bhshin  added PreFiltering
// 30MAR00  bhshin  began
BOOL AnalyzeString(PARSE_INFO *pPI,
				   BOOL fQuery, 
				   const WCHAR *pwzInput, 
				   int cchInput,
				   int cwcSrcPos,
			       CIndexInfo *pIndexInfo,
				   WCHAR wchLast)
{
	CLeafChartPool LeafChartPool;
	CEndChartPool EndChartPool;
	BOOL fNeedGuessing;
	WCHAR wchStart, wchEnd;

	if (cchInput > MAX_INPUT_TOKEN)
		return TRUE;
		
	InitAnalyze(pPI);

	// copy input string to process
	pPI->pwzInputString = new WCHAR[cchInput+1];
	if (pPI->pwzInputString == NULL)
		goto ErrorReturn;

	wcsncpy(pPI->pwzInputString, pwzInput, cchInput);
	pPI->pwzInputString[cchInput] = L'\0';

	// check string inside group
	if (cwcSrcPos > 0)
	{
		wchStart = *(pwzInput - 1);
		wchEnd = *(pwzInput + cchInput);
		
		// check inside group string
		if (fIsGroupStart(wchStart) && fIsGroupEnd(wchEnd))
		{
			// add index and keep going
			pIndexInfo->AddIndex(pPI->pwzInputString, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
			WB_LOG_ADD_INDEX(pPI->pwzInputString, cchInput, INDEX_INSIDE_GROUP);
		}
	}

	// check pre-filtering
	if (PreFiltering(pPI->pwzInputString, cchInput, wchLast, pIndexInfo))
	{
		// stop processing
		UninitAnalyze(pPI);
		return TRUE; 
	}

	// normalize string
	pPI->pwzSourceString = new WCHAR[cchInput*3+1];
	if (pPI->pwzSourceString == NULL)
		goto ErrorReturn;
	
	pPI->rgCharInfo = new CHAR_INFO_REC[cchInput*3+1];
	if (pPI->rgCharInfo == NULL)
		goto ErrorReturn;

	decompose_jamo(pPI->pwzSourceString, pPI->pwzInputString, pPI->rgCharInfo, cchInput*3+1);

	pPI->nLen = wcslen(pPI->pwzSourceString);
    pPI->nMaxLT = pPI->nLen-1;

	// person's name guessing
	GuessPersonName(pPI, pIndexInfo);

	// index time lookup (lookup all pos)
	if (!DictionaryLookup(pPI, pwzInput, cchInput, FALSE))
		goto ErrorReturn;

	if (!IntializeLeafChartPool(pPI, &LeafChartPool))
		goto ErrorReturn;

	if (!PreProcessingLeafNode(pPI, &LeafChartPool))
		goto ErrorReturn;

	if (!ChartParsing(pPI, &LeafChartPool, &EndChartPool))
		goto ErrorReturn;

	if (fQuery)
	{
		if (!MakeQueryTerms(pPI, &EndChartPool, pIndexInfo, &fNeedGuessing))
			goto ErrorReturn;
	}
	else
	{
		if (!MakeIndexTerms(pPI, &EndChartPool, pIndexInfo, &fNeedGuessing))
			goto ErrorReturn;
	}
	
	// if no all cover record, then guess index term
	if (fNeedGuessing)
	{
		GuessIndexTerms(pPI, &LeafChartPool, pIndexInfo);
	}
	else
	{
		// all cover but no index term (verb/adj/Ix) -> add itself
		if (pIndexInfo->IsEmpty())
		{
			WB_LOG_ROOT_INDEX(L"", TRUE);
			
			pIndexInfo->AddIndex(pwzInput, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
			WB_LOG_ADD_INDEX(pwzInput, cchInput, INDEX_PARSE);
		}
	}

	UninitAnalyze(pPI);

	return TRUE;

ErrorReturn:
	UninitAnalyze(pPI);

	return FALSE;
}

// InitAnalyze
//
// init the parse state struct required for parsing
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//          <- (PARSE_INFO*) initialized parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void InitAnalyze(PARSE_INFO *pPI)
{
	pPI->pwzInputString = NULL;
    pPI->pwzSourceString = NULL;

    pPI->rgCharInfo = NULL;

    pPI->nMaxLT = 0;

    InitRecords(pPI);
}

// UninitAnalyze
//
// clean up the parse state struct
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void UninitAnalyze(PARSE_INFO *pPI)
{
    UninitRecords(pPI);
    
    if (pPI->pwzInputString != NULL)
    {
        delete [] pPI->pwzInputString;
    }

    if (pPI->pwzSourceString != NULL)
    {
        delete [] pPI->pwzSourceString;
    }

    if (pPI->rgCharInfo != NULL)
    {
		delete [] pPI->rgCharInfo;
	}
}

// PreFiltering
//
// check filtered token with automata
//
// Parameters:
//  pwzToken	-> (const WCHAR*) current token string (NULL terminated)
//  cchInput	-> (int) length of input string to analyze
//  wchLast		-> (WCHAR) last character of previous token
//  pIndexInfo	-> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if it's filtered, otherwise return FALSE
//
// 20APR00  bhshin  added single length processing
// 14APR00  bhshin  began
BOOL PreFiltering(const WCHAR *pwzToken, int cchInput, WCHAR wchLast, CIndexInfo *pIndexInfo)
{
	WCHAR wzInput[MAX_INDEX_STRING+2];
	WCHAR *pwzInput;
	WCHAR wchPrev, wchCurr;
	BOOL fStop, fResult;

	// single length processing
	if (cchInput == 1) 
	{
		pIndexInfo->AddIndex(pwzToken, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
		WB_LOG_ADD_INDEX(pwzToken, cchInput, INDEX_PREFILTER);

		return TRUE;
	}

	if (wchLast == L'\0')
		return FALSE;

	// make string to check automata
	wzInput[0] = wchLast;
	wcscpy(wzInput+1, pwzToken);

	// automata
	pwzInput = wzInput;

	fResult = FALSE;
	fStop = FALSE;
	wchPrev = L'\0';

	// <...()> <, , , >
	// <...> <, , , >
	// <...> <, , , >
	// <...> <, >
	while (*pwzInput != L'\0')
	{
		wchCurr = *pwzInput;
		
		switch (wchPrev)
		{
		case 0x0000: // NULL
			// wchCurr != (   )
			if (wchCurr != 0xC744 && wchCurr != 0xB97C && wchCurr != 0xC5D0 && wchCurr != 0xB85C)
			{
				WCHAR wzLast[2];
				WCHAR wzDecomp[4];
				int cchDecomp;
				CHAR_INFO_REC rgCharInfo[4];

				wzLast[0] = wchCurr;
				wzLast[1] = L'\0';
				
				decompose_jamo(wzDecomp, wzLast, rgCharInfo, 4);
				cchDecomp = wcslen(wzDecomp);
				
				if (cchDecomp == 0)
					break;
					
				wchCurr = wzDecomp[cchDecomp-1];
				
				// check jong seong 
				if (wchCurr != 0x11AF)
					fStop = TRUE;
			}
			break;
		case 0xC744: // 
		case 0xB97C: // 
			if (wchCurr != 0xC704) // 
				fStop = TRUE;
			break;
		case 0xC5D0: // 
			if (wchCurr != 0xB300) // 
				fStop = TRUE;
			break;
		case 0xB85C: // 
			if (wchCurr != 0xC778) // 
				fStop = TRUE;
			break;
		case 0xC704: // 
		case 0xB300: // 
		case 0xC778: // 
			if (wchCurr == 0xD55C || wchCurr == 0xD574) //  
				fResult = TRUE;
			else if (wchCurr != 0xD558) // 
				fStop = TRUE;
			break;
		case 0xD574: // 
			if (wchCurr != 0xC11C) // 
				fStop = TRUE;
			break;
		case 0xD558: // 
			if (wchCurr == 0xC5EC) // 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0x11AF: // jong seong 
			if (wchCurr == 0xC218) // 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xC218:
			if (wchCurr != 0xB97C) // 
				fStop = TRUE;
			break;
		default:
			fStop = TRUE;
			break;
		}

		if (fStop)
			return FALSE; // not filtered

		wchPrev = wchCurr;

		pwzInput++;
	}

	ATLTRACE("BLOCK: PreFiltering\n");

	return fResult; // filter string
}

// IntializeLeafChartPool
//
// init Leaf Chart Pool & copy records of PI into LeafChart
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool <- (CLeafChartPool*) ptr to Leaf Chart Pool
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 31MAR00  bhshin  began
BOOL IntializeLeafChartPool(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool)
{
	int curr;

	if (pPI == NULL || pLeafChartPool == NULL)
		return FALSE;

	if (!pLeafChartPool->Initialize(pPI))
		return FALSE;

	// copy all the Record ID into CLeafChartPool
	for (curr = MIN_RECORD; curr < pPI->nCurrRec; curr++)
	{
		if (pLeafChartPool->AddRecord(curr) < MIN_RECORD)
			return FALSE;
	}

	return TRUE;
}

// PreProcessingLeafNode
//
// pre processing leaf chart pool
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool <- (CLeafChartPool*) ptr to Leaf Chart Pool
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 31MAR00  bhshin  began
BOOL PreProcessingLeafNode(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool)
{
	int i;
	int curr, next;
	int currSub, nextSub;
	WORD_REC *pWordRec, *pRecSub;
	BYTE bPOS;
	int nFT, nLT;
	int nMaxEnding, iMaxEnding;
	int nMaxParticle, iMaxParticle;
	int cchFuncWord;

	if (pPI == NULL || pLeafChartPool == NULL)
		return FALSE;

	// traverse all the record of LeafChartPool
	for (i = 0; i < pPI->nLen; i++)
	{
		curr = pLeafChartPool->GetFTHead(i);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;
			
			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat
			nFT = pWordRec->nFT;
			nLT = pWordRec->nLT;

			// delete NOUN/IJ records which have unmatched character boundary
			if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NO || bPOS == POS_NN || 
				bPOS == POS_IJ || bPOS == POS_IX)
			{
				if (!pPI->rgCharInfo[nFT].fValidStart || !pPI->rgCharInfo[nLT].fValidEnd)
					pLeafChartPool->DeleteRecord(curr);
			}
			// delete single length particle which is inside words
			else if (bPOS == POS_POSP)
			{
				if (compose_length(pWordRec->wzIndex) == 1 && 
					nLT != pPI->nLen-1)
					pLeafChartPool->DeleteRecord(curr);
			}
			
			// delete POS_NO record inside POS_NF record
			if (bPOS == POS_NF)
			{
				for (int j = nFT; j < nLT; j++)
				{
					currSub = pLeafChartPool->GetFTHead(j);

					while (currSub)
					{
						nextSub = pLeafChartPool->GetFTNext(currSub);

						pRecSub = pLeafChartPool->GetWordRec(currSub);
						if (pRecSub == NULL)
							return FALSE;
						
						// currently, RightCat == LeftCat
						if (pRecSub->nLT < nLT && HIBYTE(pRecSub->nRightCat) == POS_NO)
							pLeafChartPool->DeleteRecord(currSub);

						currSub = nextSub;
					}
				}
			}
			
			curr = next;
		}
	}

	// find the longest ENDING/PARTICLE from the end of word
	nMaxEnding = 0;
	iMaxEnding = 0; 
	nMaxParticle = 0;
	iMaxParticle = 0; 

	for (i = pPI->nLen-1; i >= 0; i--)
	{
		curr = pLeafChartPool->GetLTHead(i);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetLTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;

			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat
			nFT = pWordRec->nFT;
			nLT = pWordRec->nLT;

			cchFuncWord = nLT - nFT + 1;
			
			if (bPOS == POS_FUNCW)
			{
				if (cchFuncWord > nMaxEnding)
				{
					nMaxEnding = cchFuncWord;
					iMaxEnding = curr;
				}
			}
			else if (bPOS == POS_POSP)
			{
				if (cchFuncWord > nMaxParticle)
				{
					nMaxParticle = cchFuncWord;
					iMaxParticle = curr;
				}
			}

			curr = next;
		}
	}

	// remove ENDING with same FT of longest functional record
	if (iMaxEnding != 0)
	{
		pWordRec = pLeafChartPool->GetWordRec(iMaxEnding);
		if (pWordRec == NULL)
			return FALSE;
		
		nFT = pWordRec->nFT;
		nLT = pWordRec->nLT;

		curr = pLeafChartPool->GetFTHead(nFT);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			if (curr == iMaxEnding)
			{
				curr = next;
				continue;
			}

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;

			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat
			
			// skip same length record
			if (nLT != pWordRec->nLT && bPOS == POS_FUNCW)
			{
				pLeafChartPool->DeleteRecord(curr);				
			}

			curr = next;
		}		
	}

	// remove PARTICLE with same FT of longest functional record
	if (iMaxParticle != 0)
	{
		pWordRec = pLeafChartPool->GetWordRec(iMaxParticle);
		if (pWordRec == NULL)
			return FALSE;
		
		nFT = pWordRec->nFT;
		nLT = pWordRec->nLT;

		curr = pLeafChartPool->GetFTHead(nFT);
		
		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			if (curr == iMaxParticle)
			{
				curr = next;
				continue;
			}

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				return FALSE;

			bPOS = HIBYTE(pWordRec->nRightCat); // currently, RightCat == LeftCat

			// skip same length record
			if (nLT != pWordRec->nLT && bPOS == POS_POSP)
			{
				pLeafChartPool->DeleteRecord(curr);				
			}

			curr = next;
		}		
	}
	
	return TRUE;
}

// ChartParsing
//
// implement chart parsing algorithm
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pEndChartPool   -> (CEndChartPool*) analyzed End Chart Pool
//  fQuery    -> (BOOL) query time flag
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL ChartParsing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, 
				  CEndChartPool *pEndChartPool, BOOL fQuery /*=FALSE*/)
{
	int nRightRec, nLeftRec, nRecordID;
	float fWeight;
	WORD_REC *pRightRec;
	int nFT;
	int i, curr;

	if (pPI == NULL || pLeafChartPool == NULL || pEndChartPool == NULL)
		return FALSE;

	if (!pEndChartPool->Initialize(pPI))
		return FALSE;

	for (i = 1; i <= pPI->nLen; i++)
	{
		CActiveChartPool ActiveChartPool;
		
		if (!InitializeActiveChartPool(pPI, pLeafChartPool, i,
									   &ActiveChartPool, pEndChartPool))
		{
			return FALSE;
		}

		while (!ActiveChartPool.IsEmpty())
		{
			nRightRec = ActiveChartPool.Pop();
			pRightRec = &pPI->rgWordRec[nRightRec];
			
			nFT = pRightRec->nFT;

			// FT is zero, then combine's meaningless.
			if (nFT == 0)
				continue;

			if (!CheckValidFinal(pPI, pRightRec))
				continue;

			// LT of combined record is (FT-1)
			curr = pEndChartPool->GetLTHead(nFT-1);

			while (curr != 0)
			{
				nLeftRec = pEndChartPool->GetRecordID(curr);

				fWeight = CheckMorphotactics(pPI, nLeftRec, nRightRec, fQuery);
				if (fWeight != WEIGHT_NOT_MATCH)
				{
					nRecordID = MakeCombinedRecord(pPI, nLeftRec, nRightRec, fWeight);
					if (nRecordID >= MIN_RECORD)
					{
						ActiveChartPool.Push(nRecordID);
						pEndChartPool->AddRecord(nRecordID);
					}
				}

				curr = pEndChartPool->GetLTNext(curr);
			}
		}
	}

	return TRUE;
}

// InitializeActiveChartPool
//
// copy LT records of LeafChart into ActiveChart/EndChart
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pActiveChartPool -> (CActiveChartPool*) ptr to Active Chart Pool
//  pEndChartPool -> (CEndChartPool*) ptr to End Chart Pool
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 31MAR00  bhshin  began
BOOL InitializeActiveChartPool(PARSE_INFO *pPI, 
							   CLeafChartPool *pLeafChartPool,
							   int nLT,
							   CActiveChartPool *pActiveChartPool,
							   CEndChartPool *pEndChartPool)
{
	int curr;
	int nRecordID;
	
	if (pPI == NULL || pLeafChartPool == NULL ||
		pActiveChartPool == NULL || pEndChartPool == NULL)
		return FALSE;

	// intialize Active Chart Pool
	if (!pActiveChartPool->Initialize())
		return FALSE;
	
	// get the LT records of LeafChart
	curr = pLeafChartPool->GetLTHead(nLT);
	while (curr != 0)
	{
		nRecordID = pLeafChartPool->GetRecordID(curr);

		// add it to Active/End Chart Pool
		if (pActiveChartPool->Push(nRecordID) < MIN_RECORD)
			return FALSE;

		if (pEndChartPool->AddRecord(nRecordID) < MIN_RECORD)
			return FALSE;

		curr = pLeafChartPool->GetLTNext(curr);
	}

	return TRUE;
}

// MakeCombinedRecord
//
// check morphotactics & return corresponding weight value
//
// Parameters:
// pPI	     -> (PARSE_INFO*) ptr to parse-info struct
// nLeftRec  -> (int) left side record ID
// nRightRec -> (int) right side record ID
// fWeight   -> (float) new weight value
//
// Result:
//  (int) record ID of record pool, if faild, return 0
//
// 31MAR00  bhshin  began
int MakeCombinedRecord(PARSE_INFO *pPI, int nLeftRec, int nRightRec, float fWeight)
{
	WORD_REC *pLeftRec = NULL;
	WORD_REC *pRightRec = NULL;
	RECORD_INFO rec;
	BYTE bLeftPOS, bRightPOS;
	WCHAR wzIndex[MAX_INDEX_STRING];
	WCHAR *pwzIndex;
	
	if (pPI == NULL)
		return 0;
	
	if (nLeftRec < MIN_RECORD || nLeftRec >= pPI->nCurrRec)
		return 0;

	if (nRightRec < MIN_RECORD || nRightRec >= pPI->nCurrRec)
		return 0;

	pLeftRec = &pPI->rgWordRec[nLeftRec];
	pRightRec = &pPI->rgWordRec[nRightRec];

	rec.fWeight = fWeight;
	rec.nFT = pLeftRec->nFT;
	rec.nLT = pRightRec->nLT;
	rec.nDict = DICT_ADDED;
	rec.nLeftCat = pLeftRec->nLeftCat;
	rec.nRightCat = pRightRec->nRightCat;
	
	bLeftPOS = HIBYTE(pLeftRec->nLeftCat);
	bRightPOS = HIBYTE(pRightRec->nLeftCat);

	rec.nLeftChild = (unsigned short)nLeftRec;
	rec.nRightChild = (unsigned short)nRightRec;

	// add noun childs records number
	rec.cNounRec = pLeftRec->cNounRec + pRightRec->cNounRec;

	// check # of NO record
	rec.cNoRec = pLeftRec->cNoRec + pRightRec->cNoRec;

	// if it has more than 2 No record, then return
	if (rec.cNoRec > 2)
		return 0;

	// WB combine only successive No case.
	if (pLeftRec->cNoRec == 1 && pRightRec->cNoRec == 1)
	{
		if (HIBYTE(pLeftRec->nRightCat) != POS_NO ||
			HIBYTE(pRightRec->nLeftCat) != POS_NO)
			return 0;
	}

	// make combined index string
	// <index> = <left><.><right>
	int i = 0;

	pwzIndex = pLeftRec->wzIndex;
	
	// recordB is VA && recordA is FUNCW(ending) &&
	// Lemma(recordA) starts with "  "
	// string = Lemma(recordB) + "  "
	if (bLeftPOS == POS_VA && bRightPOS == POS_FUNCW && pLeftRec->nFT == 0)
	{
		// copy left index term
		while (*pwzIndex != L'\0')
		{
			if (*pwzIndex != L'.')
				wzIndex[i++] = *pwzIndex;

			pwzIndex++;
		}

		//  case
		if (pRightRec->wzIndex[0] == 0x11B7)
		{
			wzIndex[i++] = 0x11B7;
			goto Exit;
		}
		//  case
		else if (pRightRec->wzIndex[0] == 0x110B &&
			     pRightRec->wzIndex[1] == 0x1173 &&
				 pRightRec->wzIndex[2] == 0x11B7)
		{
			wzIndex[i++] = 0x110B;
			wzIndex[i++] = 0x1173;
			wzIndex[i++] = 0x11B7;
			goto Exit;
		}
		//  case
		else if (pRightRec->wzIndex[0] == 0x1100 &&
			     pRightRec->wzIndex[1] == 0x1175 &&
				 !fIsJongSeong(pRightRec->wzIndex[2]))
		{
			wzIndex[i++] = 0x1100;
			wzIndex[i++] = 0x1175;
			goto Exit;
		}
		else
		{
			i = 0; // undo forwarding copy
		}
	}

	if (i == 0)
	{
		if (bLeftPOS == POS_FUNCW || bLeftPOS == POS_POSP ||
			bLeftPOS == POS_VA || bLeftPOS == POS_IX)
		{
			wzIndex[i++] = L'X';
		}
		else
		{
			// remove <.> from left index string
			while (*pwzIndex != L'\0')
			{
				if (*pwzIndex != L'.')
					wzIndex[i++] = *pwzIndex;

				pwzIndex++;
			}
		}
	}

	wzIndex[i++] = L'.';

	pwzIndex = pRightRec->wzIndex;

	if (bRightPOS == POS_FUNCW || bRightPOS == POS_POSP ||
		bRightPOS == POS_VA || bRightPOS == POS_IX)
	{
		wzIndex[i++] = L'X';
	}
	else
	{
		// remove <.> from right index string
		while (*pwzIndex != L'\0')
		{
			if (*pwzIndex != L'.')
				wzIndex[i++] = *pwzIndex;

			pwzIndex++;
		}
	}

Exit:

	wzIndex[i] = L'\0';

	rec.pwzIndex = wzIndex;

	return AddRecord(pPI, &rec);
}

// MakeIndexTerms
//
// make index term (index time)
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pEndChartPool   -> (CEndChartPool*) analyzed End Chart Pool
//  pIndexInfo		-> (CIndexInfo *) output index list
//  pfNeedGuessing  -> (BOOL*) output need to guess flag
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 06APR00  bhshin  began
BOOL MakeIndexTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing)
{
	int nLTMaxLen;
	int curr;
	WORD_REC *pWordRec;
	int cchRecord;
	float fBestWeight = 0;
	int cMinNoRec;
	BOOL fOnlySuffix = FALSE;

	// intialize guessing flag
	*pfNeedGuessing = TRUE;

	if (pPI == NULL || pEndChartPool == NULL)
		return FALSE;

	// if all cover record exist, then make index term
	nLTMaxLen = pEndChartPool->GetLTMaxLen(pPI->nMaxLT);

	// make index terms for all cover records
	if (nLTMaxLen < pPI->nLen)
		return TRUE;

	// LT of EndChartPool increasing length order
	curr = pEndChartPool->GetLTHead(pPI->nMaxLT);
	while (curr != 0)
	{
		pWordRec = pEndChartPool->GetWordRec(curr);
		if (pWordRec == NULL)
			break;

		if (!CheckValidFinal(pPI, pWordRec))
		{
			curr = pEndChartPool->GetLTNext(curr);
			continue;
		}

		cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

		// get index string from tree traverse 
		if (cchRecord == nLTMaxLen && pWordRec->fWeight > THRESHOLD_MAKE_INDEX)
		{
			// Now, we find index terms. DO NOT guessing
			*pfNeedGuessing = FALSE;
			
			float fWeight = pWordRec->fWeight;
			int cNoRec = pWordRec->cNoRec;

			if (fBestWeight == 0)
			{
				fBestWeight = fWeight;
				cMinNoRec = cNoRec;
			}
			
			// we just traverse best weight list
			if (fWeight == fBestWeight && cMinNoRec == cNoRec)
			{
				WB_LOG_ROOT_INDEX(pWordRec->wzIndex, TRUE); // root
				TraverseIndexString(pPI, fOnlySuffix, pWordRec, pIndexInfo);

				// on index time, just pick up suffix on processing other than best
				if (pIndexInfo->IsEmpty() == FALSE)
				{
					fOnlySuffix = TRUE;
				}
			}
		}

		curr = pEndChartPool->GetLTNext(curr);
	}

	return TRUE;
}

// TraverseIndexString
//
// get the index string from tree traversing
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  fOnlySuffix -> (BOOL) process only suffix (nFT == 0)
//  pWordRec    -> (WORD_REC*) parent WORD RECORD
//  pIndexInfo	-> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 07APR00  bhshin  began
BOOL TraverseIndexString(PARSE_INFO *pPI, BOOL fOnlySuffix, WORD_REC *pWordRec, CIndexInfo *pIndexInfo)
{
	WCHAR *pwzIndex;
	BYTE bPOS;
	WCHAR wzDecomp[MAX_INDEX_STRING*3+1];
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int cchIndex, cchRecord;
	int nLeft, nRight;
	WORD_REC *pWordLeft, *pWordRight;
	int nPrevX, nMiddleX, nLastX, idx;
	int nFT, nLT;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	if (pPI->rgCharInfo == NULL)
	{
		ATLTRACE("Character Info is NULL\n");
		return FALSE;
	}

	if (fOnlySuffix)
	{
		if (pWordRec->nFT > 0)
			return TRUE;
	}
	
	nLeft = pWordRec->nLeftChild;
	nRight = pWordRec->nRightChild;

	// if it has child node, then don't add index term 
	if (nLeft != 0 || nRight != 0)
	{
		// go to child traversing
		// recursively traverse Left/Right child
		if (nLeft != 0)
		{
			pWordLeft = &pPI->rgWordRec[nLeft];

			WB_LOG_ROOT_INDEX(pWordLeft->wzIndex, FALSE); // child
			TraverseIndexString(pPI, fOnlySuffix, pWordLeft, pIndexInfo);
		}

		if (nRight != 0)
		{
			pWordRight = &pPI->rgWordRec[nRight];

			WB_LOG_ROOT_INDEX(pWordRight->wzIndex, FALSE); // child
			TraverseIndexString(pPI, fOnlySuffix, pWordRight, pIndexInfo);
		}

		return TRUE;	
	}

	bPOS = HIBYTE(pWordRec->nLeftCat);

	// copy index string
	pwzIndex = pWordRec->wzIndex;

	// remove connection character(.) and functional character(X)
	nPrevX = 0;
	nMiddleX = 0;
	nLastX = 0;
	idx = 0;
	while (*pwzIndex != L'\0')
	{
		// check the existence of X
		if (*pwzIndex == L'X')
		{
			if (idx == 0)
				nPrevX++;
			else
				nLastX++;
		}
		else if (*pwzIndex != L'.')
		{
			// valid hangul jamo
			wzDecomp[idx++] = *pwzIndex;

			// check middle X
			nMiddleX = nLastX;
			nLastX = 0;
		}

		pwzIndex++;
	}
	wzDecomp[idx] = L'\0';

	compose_jamo(wzIndex, wzDecomp, MAX_INDEX_STRING);

	cchIndex = wcslen(wzIndex);
	cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

	// lengh one index term
	if (cchIndex == 1)
	{
		// it should not have leading X or position of last X should be 1
		if (nPrevX > 0 || nLastX > 1)
			return TRUE;
	}

	// 1. it should not have middle X
	// 2. zero index string is not allowed
	if (nMiddleX == 0 && cchIndex > 0)
	{
		if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NO || bPOS == POS_NN || bPOS == POS_IJ ||
			(bPOS == POS_VA && pWordRec->nLeftChild > 0 && pWordRec->nRightChild > 0))
		{
			nFT = pPI->rgCharInfo[pWordRec->nFT].nToken;
			nLT = pPI->rgCharInfo[pWordRec->nLT].nToken;

			pIndexInfo->AddIndex(wzIndex, cchIndex, pWordRec->fWeight, nFT, nLT);		
			WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_PARSE);
		}
	}

	return TRUE;
}

// MakeQueryTerms
//
// make index term (query time)
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pEndChartPool   -> (CEndChartPool*) analyzed End Chart Pool
//  pIndexInfo		-> (CIndexInfo *) output index list
//  pfNeedGuessing  -> (BOOL*) output need to guess flag
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 04DEC00  bhshin  began
BOOL MakeQueryTerms(PARSE_INFO *pPI, CEndChartPool *pEndChartPool,
					CIndexInfo *pIndexInfo, BOOL *pfNeedGuessing)
{
	int nLTMaxLen;
	int curr;
	WORD_REC *pWordRec;
	int cchRecord;
	float fBestWeight = 0;
	int cMinNoRec;
	BOOL fOnlySuffix = FALSE;
	WCHAR wzIndex[MAX_INDEX_STRING*2];
	int cchIndex, nFT, nLT;

	// intialize guessing flag
	*pfNeedGuessing = TRUE;

	if (pPI == NULL || pEndChartPool == NULL)
		return FALSE;

	// if all cover record exist, then make index term
	nLTMaxLen = pEndChartPool->GetLTMaxLen(pPI->nMaxLT);

	// make index terms for all cover records
	if (nLTMaxLen < pPI->nLen)
		return TRUE;

	// LT of EndChartPool increasing length order
	curr = pEndChartPool->GetLTHead(pPI->nMaxLT);
	while (curr != 0)
	{
		pWordRec = pEndChartPool->GetWordRec(curr);
		if (pWordRec == NULL)
			break;

		if (!CheckValidFinal(pPI, pWordRec))
		{
			curr = pEndChartPool->GetLTNext(curr);
			continue;
		}

		cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

		// get index string from tree traverse 
		if (cchRecord == nLTMaxLen && pWordRec->fWeight > THRESHOLD_MAKE_INDEX)
		{
			// Now, we find index terms. DO NOT guessing
			*pfNeedGuessing = FALSE;
			
			float fWeight = pWordRec->fWeight;
			int cNoRec = pWordRec->cNoRec;

			if (fBestWeight == 0)
			{
				fBestWeight = fWeight;
				cMinNoRec = cNoRec;
			}
			
			// we just traverse best weight list
			if (fWeight == fBestWeight && cMinNoRec == cNoRec)
			{
				wzIndex[0] = L'\0';
				
				TraverseQueryString(pPI, pWordRec, wzIndex, MAX_INDEX_STRING*2);

				cchIndex = wcslen(wzIndex);
				if (cchIndex > 0)
				{
					nFT = pPI->rgCharInfo[pWordRec->nFT].nToken;
					nLT = pPI->rgCharInfo[pWordRec->nLT].nToken;

					pIndexInfo->AddIndex(wzIndex, cchIndex, pWordRec->fWeight, nFT, nLT);		
					WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_PARSE);
				}
			}
		}

		curr = pEndChartPool->GetLTNext(curr);
	}

	return TRUE;
}


// TraverseQueryString
//
// get the query string from tree traversing
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec    -> (WORD_REC*) parent WORD RECORD
//  pwzSeqTerm  -> (WCHAR *) output sequence index term buffer
//  cchSeqTerm -> (int) output buffer size
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 04DEC00  bhshin  began
BOOL TraverseQueryString(PARSE_INFO *pPI, WORD_REC *pWordRec, WCHAR *pwzSeqTerm, int cchSeqTerm)
{
	WCHAR *pwzIndex;
	BYTE bPOS;
	WCHAR wzDecomp[MAX_INDEX_STRING*3+1];
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int cchIndex, cchRecord;
	int nLeft, nRight;
	WORD_REC *pWordLeft, *pWordRight;
	int nPrevX, nMiddleX, nLastX, idx;
	int cchPrevSeqTerm;
	int nFT;
	WCHAR wchIndex;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	if (pPI->rgCharInfo == NULL)
	{
		ATLTRACE("Character Info is NULL\n");
		return FALSE;
	}

	nLeft = pWordRec->nLeftChild;
	nRight = pWordRec->nRightChild;

	// if it has child node, then don't add index term 
	if (nLeft != 0 || nRight != 0)
	{
		// go to child traversing
		// recursively traverse Left/Right child
		if (nLeft != 0)
		{
			pWordLeft = &pPI->rgWordRec[nLeft];

			WB_LOG_ROOT_INDEX(pWordLeft->wzIndex, FALSE); // child
			TraverseQueryString(pPI, pWordLeft, pwzSeqTerm, cchSeqTerm);
		}

		if (nRight != 0)
		{
			pWordRight = &pPI->rgWordRec[nRight];

			WB_LOG_ROOT_INDEX(pWordRight->wzIndex, FALSE); // child
			TraverseQueryString(pPI, pWordRight, pwzSeqTerm, cchSeqTerm);
		}

		return TRUE;	
	}

	bPOS = HIBYTE(pWordRec->nLeftCat);

	// copy index string
	pwzIndex = pWordRec->wzIndex;

	// remove connection character(.) and functional character(X)
	nPrevX = 0;
	nMiddleX = 0;
	nLastX = 0;
	idx = 0;
	while (*pwzIndex != L'\0')
	{
		// check the existence of X
		if (*pwzIndex == L'X')
		{
			if (idx == 0)
				nPrevX++;
			else
				nLastX++;
		}
		else if (*pwzIndex != L'.')
		{
			// valid hangul jamo
			wzDecomp[idx++] = *pwzIndex;

			// check middle X
			nMiddleX = nLastX;
			nLastX = 0;
		}

		pwzIndex++;
	}
	wzDecomp[idx] = L'\0';

	compose_jamo(wzIndex, wzDecomp, MAX_INDEX_STRING);

	cchIndex = wcslen(wzIndex);
	cchRecord = pWordRec->nLT - pWordRec->nFT + 1;

	// lengh one index term
	if (cchIndex == 1)
	{
		// it should not have leading X or position of last X should be 1
		if (nPrevX > 0 || nLastX > 1)
			return TRUE;
	}

	// 1. it should not have middle X
	// 2. zero index string is not allowed
	if (nMiddleX == 0 && cchIndex > 0)
	{
		if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NO || bPOS == POS_NN || bPOS == POS_IJ ||
			(bPOS == POS_VA && pWordRec->nLeftChild > 0 && pWordRec->nRightChild > 0))
		{
			// check buffer size
			cchPrevSeqTerm = wcslen(pwzSeqTerm);
			
			if (cchSeqTerm <= cchPrevSeqTerm + cchIndex)
				return FALSE; // output buffer too small

			// add conjoining symbol TAB
			if (cchPrevSeqTerm > 1 && cchIndex > 1)
				wcscat(pwzSeqTerm, L"\t");

			if (cchIndex == 1)
			{
				nFT = pWordRec->nFT;
				wchIndex = wzIndex[0];

				// check [,] suffix case, then just remove it
				if (nFT > 0 && (wchIndex == 0xB4E4 || wchIndex == 0xBFD0))
					return TRUE;
			}

			// concat index term
			wcscat(pwzSeqTerm, wzIndex);
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\ctplus.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//              28-Aug-97   Weibz       Add Hanguel char
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC       0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC       0x03                             // Katakana char
#define WS       0x04                             // Word seperator
#define VC       0x05                             // Hankaku (variant) char
#define PS       0x06                             // Phrase seperator
#define CH       0x07                             // Code page 0 - ASCII Char.
#define HG       0x08                             // Hanguel Char.

BYTE
GetCharType(WCHAR wc);

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START       = 0x00,
   CT_HIRAGANA    = 0x01,
   CT_KANJI       = 0x02,
   CT_KATAKANA    = 0x03,
   CT_WORD_SEP    = 0x04,
   CT_HANKAKU     = 0x05,
   CT_PHRASE_SEP  = 0x06,
   CT_ROMAJI      = 0x07,
   CT_HANGUEL     = 0x08,
} CT;


// Declare node types transitions
// Intuitively frequency ordered
//
typedef enum _WT {
   WT_START       = 0x00,
   WT_WORD_SEP    = 0x01,
   WT_PHRASE_SEP  = 0x02,
   WT_ROMAJI      = 0x03,
   WT_HANGUEL     = 0x04,
   WT_REACHEND    = 0x05,
} WT;


#define CT_MAX    0x09

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\analyze.h ===
// Analyze.h
//
// main CHART PARSING routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  31 MAR 2000	  bhshin	created

#ifndef _ANALYZE_H
#define _ANALYZE_H

#include "IndexRec.h"
#include "ChartPool.h"

BOOL AnalyzeString(PARSE_INFO *pPI, 
				   BOOL fQuery, 
				   const WCHAR *pwzInput, 
				   int cchInput,
				   int cwcSrcPos,
			       CIndexInfo *pIndexInfo,
				   WCHAR wchLast);

void InitAnalyze(PARSE_INFO *pPI);
void UninitAnalyze(PARSE_INFO *pPI);

BOOL IntializeLeafChartPool(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool);
BOOL InitializeActiveChartPool(PARSE_INFO *pPI, 
							   CLeafChartPool *pLeafChartPool,
							   int nLT,
							   CActiveChartPool *pActiveChartPool,
							   CEndChartPool *pEndChartPool);


BOOL ChartParsing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, 
				  CEndChartPool *pEndChartPool, BOOL fQuery = FALSE);

#endif // #ifndef _ANALYZE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\chart.cpp ===
// Chart.cpp
// CChartPool class implementation
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  22 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Chart.h"
#include "Unikor.h"

CChartPool::CChartPool()
{
	m_rgChartRec = NULL; 

	m_nMaxRec = 0; 	
	m_nCurrRec = 0; 

	m_Order = SORT_ASCEND;
}

CChartPool::~CChartPool()
{
	Uninitialize();
}

BOOL CChartPool::Initialize(SORT_ORDER Order)
{
	m_Order = Order;

    if (m_rgChartRec == NULL)
	{
		m_nMaxRec = RECORD_CLUMP_SIZE;
		m_rgChartRec = (CHART_REC*)malloc(m_nMaxRec * sizeof(CHART_REC));
		if (m_rgChartRec == NULL)
		{
			m_nMaxRec = 0;
			return FALSE;
		}
	}

	m_nCurrRec = MIN_RECORD;

	m_idxHead = 0;	

	return TRUE;
}

void CChartPool::Uninitialize()
{
	m_nMaxRec = 0;

	if (m_rgChartRec != NULL)
		free(m_rgChartRec);
	m_rgChartRec = NULL;
}

int CChartPool::GetNextIndex(int nRecord)
{
	if (m_rgChartRec == NULL)
		return 0;

	if (nRecord >= m_nCurrRec)
		return 0;

	return m_rgChartRec[nRecord].nNext;
}

CHART_REC* CChartPool::GetRecord(int nRecord)
{
	if (m_rgChartRec == NULL)
		return NULL;

	if (nRecord >= m_nCurrRec)
		return NULL;

	return &m_rgChartRec[nRecord];	
}

BOOL CChartPool::AddRecord(RECORD_INFO *pRec)
{
    int nNewRecord;
    int nFT, nLT, nDict;
	int nLeftCat, nRightCat;
	int nLeftChild, nRightChild;
    const WCHAR *pwzIndex;
	int curr;

    nFT = pRec->nFT;
    nLT = pRec->nLT;
    nDict = pRec->nDict;
	nLeftCat = pRec->nLeftCat;
	nRightCat = pRec->nRightCat;
	nLeftChild = pRec->nLeftChild;
	nRightChild = pRec->nRightChild;
	pwzIndex = pRec->pwzIndex;

    if (m_rgChartRec == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return FALSE;
	}

    // make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
        // alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgChartRec, nNewSize * sizeof(CHART_REC));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return FALSE;
        }

        m_rgChartRec = (CHART_REC*)pNew;
        m_nMaxRec = nNewSize;
	}

	// make sure this isn't a duplicate of another record
	curr = m_idxHead;
    ATLASSERT(curr < m_nCurrRec);
	while (curr != 0)
	{
		if (m_rgChartRec[curr].nFT == nFT && m_rgChartRec[curr].nLT == nLT)
		{
			// verify that everything matches
			if (m_rgChartRec[curr].nLeftCat == nLeftCat
				&& m_rgChartRec[curr].nRightCat == nRightCat
				&& m_rgChartRec[curr].nLeftChild == nLeftChild
				&& m_rgChartRec[curr].nRightChild == nRightChild
                && !wcscmp(m_rgChartRec[curr].wzIndex, pwzIndex)
			   )
			{
				return TRUE; 
			}
		}

		curr = m_rgChartRec[curr].nNext;
	}

    nNewRecord = m_nCurrRec;
    m_nCurrRec++;

	m_rgChartRec[nNewRecord].nFT = nFT;
	m_rgChartRec[nNewRecord].nLT = nLT;
	m_rgChartRec[nNewRecord].nDict = nDict;
	m_rgChartRec[nNewRecord].nLeftCat = nLeftCat;
	m_rgChartRec[nNewRecord].nRightCat = nRightCat;
	m_rgChartRec[nNewRecord].nLeftChild = 0;
	m_rgChartRec[nNewRecord].nRightChild = 0;
	wcscpy(m_rgChartRec[nNewRecord].wzIndex, pwzIndex);

	// add record to length order list
	AddToList(nNewRecord);

	return TRUE;
}

BOOL CChartPool::AddRecord(int nLeftRec, int nRightRec)
{
	RECORD_INFO rec;
	WCHAR wzIndex[MAX_INDEX_STRING];
	CHART_REC *pLeftRec, *pRightRec;

	if (nLeftRec >= m_nCurrRec || nRightRec >= m_nCurrRec)
		return FALSE;

	pLeftRec = &m_rgChartRec[nLeftRec];
	pRightRec = &m_rgChartRec[nRightRec];

	if (pLeftRec == NULL || pRightRec == NULL)
		return FALSE;

	rec.nFT = pLeftRec->nFT;
	rec.nLT = pRightRec->nLT;
	rec.nDict = DICT_ADDED;
	rec.nLeftCat = pLeftRec->nLeftCat;
	rec.nRightCat = pRightRec->nRightCat;
	rec.nLeftChild = 0;
	rec.nRightChild = 0;

	if (rec.nRightCat == POS_POSP)
	{
		wcscpy(wzIndex, pLeftRec->wzIndex);
		//wcscat(wzIndex, L".");
	}
	else
	{
		ATLASSERT(rec.nRightCat == POS_FUNCW);

		wcscpy(wzIndex, L"");
		//wcscpy(wzIndex, L".");
	}

	rec.pwzIndex = wzIndex;

	return AddRecord(&rec);
}

void CChartPool::DeleteRecord(int nRecord)
{
	if (m_rgChartRec == NULL)
		return;

	if (nRecord >= m_nCurrRec)
		return;

	if (m_rgChartRec[nRecord].nDict == DICT_DELETED)
		return;

	RemoveFromList(nRecord);

	m_rgChartRec[nRecord].nDict = DICT_DELETED;
}

void CChartPool::DeleteSubRecord(int nRecord)
{
	int nFT, nLT;	
	int nSubFT, nSubLT;
	int curr, next;

	ATLASSERT(nRecord < m_nCurrRec);

	nFT = m_rgChartRec[nRecord].nFT;
	nLT = m_rgChartRec[nRecord].nLT;

	curr = m_idxHead;
	while (curr != 0)
	{
		nSubFT = m_rgChartRec[curr].nFT;
		nSubLT = m_rgChartRec[curr].nLT;

		next = m_rgChartRec[curr].nNext;

		if (curr != nRecord && nSubFT >= nFT && nSubLT <= nLT)
		{
			DeleteRecord(curr);
		}

		curr = next;
	}
}

void CChartPool::DeleteSubRecord(int nFT, int nLT, BYTE bPOS)
{
	int nSubFT, nSubLT;
	int curr, next;

	curr = m_idxHead;
	while (curr != 0)
	{
		nSubFT = m_rgChartRec[curr].nFT;
		nSubLT = m_rgChartRec[curr].nLT;

		next = m_rgChartRec[curr].nNext;

		// don't remove exact FT/LT record, we just delete 'sub'-record
		if ((nSubFT != nFT || nSubLT != nLT) && nSubFT >= nFT && nSubLT <= nLT)
		{
			if (m_rgChartRec[curr].nLeftCat == m_rgChartRec[curr].nRightCat &&
				HIBYTE(m_rgChartRec[curr].nRightCat) == bPOS)
			{
				DeleteRecord(curr);
			}
		}

		curr = next;
	}
}

void CChartPool::AddToList(int nRecord)
{
	int curr, prev;
	int fDone;
	int cchIndex;

    ATLASSERT(nRecord < m_nCurrRec);

    cchIndex = compose_length(m_rgChartRec[nRecord].wzIndex);
    
    curr = m_idxHead;
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		if (curr != 0 && compose_length(m_rgChartRec[curr].wzIndex) > cchIndex)
		{
			// go to next record
			prev = curr;
			curr = m_rgChartRec[curr].nNext;
            ATLASSERT(curr < m_nCurrRec);
		}
		else
		{
			// insert record here
			if (prev == -1)
			{
				// add before beginning of list
				m_rgChartRec[nRecord].nNext = m_idxHead;
				m_idxHead = nRecord;
			}
			else
			{
				// insert in middle (or end) of list
				m_rgChartRec[nRecord].nNext = m_rgChartRec[prev].nNext;
				m_rgChartRec[prev].nNext = nRecord;
			}
			fDone = TRUE;
		}
	}
}

void CChartPool::RemoveFromList(int nRecord)
{
	int curr,next;

    ATLASSERT(nRecord < m_nCurrRec);
	
    curr = m_idxHead;
	if (curr == nRecord)
	{
		m_idxHead = m_rgChartRec[nRecord].nNext;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgChartRec[curr].nNext;
			if (next == nRecord)
			{
				m_rgChartRec[curr].nNext = m_rgChartRec[nRecord].nNext;
				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\chartpool.h ===
// ChartPool.h
//
// Leaf/End/Active ChartPool declaration
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#ifndef _CHART_POOL_H
#define _CHART_POOL_H

// =======================
// LEAF CHART POOL
// =======================

typedef struct _tagLeafChart
{
	int nRecordID;
	int nFTNext;
	int nLTNext;
	unsigned char nDict;
} LEAF_CHART;

class CLeafChartPool
{
// member data
private:
	PARSE_INFO *m_pPI;

	LEAF_CHART *m_rgLeafChart;
	int m_nMaxRec;  // # of allocated records in m_rgLeafChart
	int m_nCurrRec; // next empty space in m_rgLeafChart
	
	int *m_rgnFTHead;
	int *m_rgnLTHead;

	int m_nMaxTokenAlloc;
	
// constructor & desctructor
public:
	CLeafChartPool();
	~CLeafChartPool();

	BOOL Initialize(PARSE_INFO *pPI);
	void Uninitialize();

// attribute
public:
	LEAF_CHART* GetLeafChart(int nChartID);
	int GetRecordID(int nChartID);
	WORD_REC* GetWordRec(int nChartID);
	
	int GetFTHead(int nFT);
	int GetFTNext(int nChartID);

	int GetLTHead(int nLT);
	int GetLTNext(int nChartID);

// operator
public:
	int AddRecord(int nRecordID);
	int AddRecord(RECORD_INFO *pRec);

	void DeleteRecord(int nChartID);

	void AddToFTList(int nChartID);
	void AddToLTList(int nChartID);

	void RemoveFromFTList(int nChartID);
	void RemoveFromLTList(int nChartID);
};

// =======================
// END CHART POOL
// =======================

typedef struct _tagEndChart
{
	int nRecordID;
	int nLTNext;
	unsigned char nDict;
} END_CHART;

class CEndChartPool
{
// member data
private:
	PARSE_INFO *m_pPI;

	END_CHART *m_rgEndChart; 
	int m_nMaxRec;  // # of allocated records in m_rgEndChart
	int m_nCurrRec; // next empty space in m_rgEndChart
	
	int *m_rgnLTHead;
	int *m_rgnLTMaxLen; // MAX_LENGTH for each LT

	int m_nMaxTokenAlloc;
	
// constructor & desctructor
public:
	CEndChartPool();
	~CEndChartPool();

	BOOL Initialize(PARSE_INFO *pPI);
	void Uninitialize();

// attribute
public:
	END_CHART* GetEndChart(int nChartID);
	int GetRecordID(int nChartID);
	WORD_REC* GetWordRec(int nChartID);
		
	int GetLTHead(int nLT);
	int GetLTMaxLen(int nLT);
	
	int GetLTNext(int nChartID);

// operator
public:
	int AddRecord(int nRecordID);
	int AddRecord(RECORD_INFO *pRec);
	
	void DeleteRecord(int nChartID);

	void AddToLTList(int nChartID);
	void RemoveFromLTList(int nChartID);
};

// =======================
// ACTIVE CHART POOL
// =======================

class CActiveChartPool
{
// member data
private:
	int *m_rgnRecordID;
	int m_nMaxRec;  // # of allocated records in m_rgnRecordID
	
	int m_nCurrRec; // next empty space in m_rgnRecordID
	int m_nHeadRec; // next pop position

// constructor & desctructor
public:
	CActiveChartPool();
	~CActiveChartPool();

	BOOL Initialize();
	void Uninitialize();

// attribute
public:
	BOOL IsEmpty() { return (m_nHeadRec >= m_nCurrRec) ? TRUE : FALSE; }

// operator
public:
	int Push(int nRecordID);
	int Pop();
};

#endif // #ifndef _CHART_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\chart.h ===
// Chart.h
// CChartPool class declaration
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  22 MAR 2000	  bhshin	created

#ifndef _CHART_POOL_H
#define _CHART_POOL_H

// CHART REC structure
// =====================
typedef struct tagCHART_REC
{
	int nFT, nLT;
	int nDict;
	int nLeftCat, nRightCat;
	int nLeftChild, nRightChild;
	WCHAR wzIndex[MAX_INDEX_STRING];
	int nNext;
} CHART_REC;

// CChartPool structure
// =====================
class CChartPool
{
// public enumeration
public:
	// sorting order
	enum SORT_ORDER {
		SORT_ASCEND,
		SORT_DESCNED,
	};

// member data
protected:
	CHART_REC *m_rgChartRec; // array of chart records

	int m_nMaxRec; 	// # of allocated records in pWordRec
	int m_nCurrRec; // next empty space in pWordRec
	int m_idxHead;	// head index in the sorted list with record length 

	SORT_ORDER m_Order;

// constructor & desctructor
public:
	CChartPool();
	~CChartPool();

	BOOL Initialize(SORT_ORDER Order);
	void Uninitialize(void);

// attribute
public:
	int GetHeadIndex(void) { return m_idxHead; }
	int GetNextIndex(int nRecord);

	CHART_REC* GetRecord(int nRecord); // 1 based index
	int GetCurrRecord(void) { return m_nCurrRec; } // total record number

// operators
public:
	BOOL AddRecord(RECORD_INFO *pRec);
	BOOL AddRecord(int nLeftRec, int nRightRec);

	void DeleteRecord(int nRecord);

	void DeleteSubRecord(int nRecord);
	void DeleteSubRecord(int nFT, int nLT, BYTE bPOS);

// internal operators
protected:
	void AddToList(int nRecord);
	void RemoveFromList(int nRecord);
};

#endif // #ifndef _CHART_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\cierror.h ===
#ifndef _CIERROR_H_
#define _CIERROR_H_
#ifndef FACILITY_WINDOWS
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COFAIL           0x3
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: NOT_AN_ERROR1
//
// MessageText:
//
//  NOTE:  This dummy error message is necessary to force MC to output
//         the above defines inside the FACILITY_WINDOWS guard instead
//         of leaving it empty.
//
#define NOT_AN_ERROR1                    ((HRESULT)0x00081600L)

#endif // FACILITY_WINDOWS
//
// Range 0x1600-0x1850 is reserved by Content Index.
//
//
// Codes 0x1600-0x164f are reserved for QUERY
//
//
// MessageId: QUERY_E_FAILED
//
// MessageText:
//
//  Call failed for unknown reason.
//
#define QUERY_E_FAILED                   ((HRESULT)0x80041600L)

//
// MessageId: QUERY_E_INVALIDQUERY
//
// MessageText:
//
//  Invalid parameter.
//
#define QUERY_E_INVALIDQUERY             ((HRESULT)0x80041601L)

//
// MessageId: QUERY_E_INVALIDRESTRICTION
//
// MessageText:
//
//  The query restriction could not be parsed.
//
#define QUERY_E_INVALIDRESTRICTION       ((HRESULT)0x80041602L)

//
// MessageId: QUERY_E_INVALIDSORT
//
// MessageText:
//
//  An invalid sort order was requested.
//
#define QUERY_E_INVALIDSORT              ((HRESULT)0x80041603L)

//
// MessageId: QUERY_E_INVALIDCATEGORIZE
//
// MessageText:
//
//  An invalid categorization order was requested.
//
#define QUERY_E_INVALIDCATEGORIZE        ((HRESULT)0x80041604L)

//
// MessageId: QUERY_E_ALLNOISE
//
// MessageText:
//
//  The query contained only ignored words.
//
#define QUERY_E_ALLNOISE                 ((HRESULT)0x80041605L)

//
// MessageId: QUERY_E_TOOCOMPLEX
//
// MessageText:
//
//  The query was too complex to be executed.
//
#define QUERY_E_TOOCOMPLEX               ((HRESULT)0x80041606L)

//
// MessageId: QUERY_E_TIMEDOUT
//
// MessageText:
//
//  The query exceeded its execution time limit.
//
#define QUERY_E_TIMEDOUT                 ((HRESULT)0x80041607L)

//
// MessageId: QUERY_E_DUPLICATE_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is a duplicate.
//
#define QUERY_E_DUPLICATE_OUTPUT_COLUMN  ((HRESULT)0x80041608L)

//
// MessageId: QUERY_E_INVALID_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is not valid.
//
#define QUERY_E_INVALID_OUTPUT_COLUMN    ((HRESULT)0x80041609L)

//
// MessageId: QUERY_E_INVALID_DIRECTORY
//
// MessageText:
//
//  Invalid directory name.
//
#define QUERY_E_INVALID_DIRECTORY        ((HRESULT)0x8004160AL)

//
// MessageId: QUERY_E_DIR_ON_REMOVABLE_DRIVE
//
// MessageText:
//
//  Specified directory is on a removable medium.
//
#define QUERY_E_DIR_ON_REMOVABLE_DRIVE   ((HRESULT)0x8004160BL)

//
// MessageId: QUERY_S_NO_QUERY
//
// MessageText:
//
//  The catalog is in a state where indexing continues, but queries are not allowed.
//
#define QUERY_S_NO_QUERY                 ((HRESULT)0x8004160CL)

//
// Codes 0x1650-0x167f are reserved for qutil error codes
//
//
// MessageId: QPLIST_E_CANT_OPEN_FILE
//
// MessageText:
//
//  Can not open file.
//
#define QPLIST_E_CANT_OPEN_FILE          ((HRESULT)0x80041651L)

//
// MessageId: QPLIST_E_READ_ERROR
//
// MessageText:
//
//  Read error in file.
//
#define QPLIST_E_READ_ERROR              ((HRESULT)0x80041652L)

//
// MessageId: QPLIST_E_EXPECTING_NAME
//
// MessageText:
//
//  Expecting property name.
//
#define QPLIST_E_EXPECTING_NAME          ((HRESULT)0x80041653L)

//
// MessageId: QPLIST_E_EXPECTING_TYPE
//
// MessageText:
//
//  Expecting type specifier.
//
#define QPLIST_E_EXPECTING_TYPE          ((HRESULT)0x80041654L)

//
// MessageId: QPLIST_E_UNRECOGNIZED_TYPE
//
// MessageText:
//
//  Unrecognized type.
//
#define QPLIST_E_UNRECOGNIZED_TYPE       ((HRESULT)0x80041655L)

//
// MessageId: QPLIST_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPLIST_E_EXPECTING_INTEGER       ((HRESULT)0x80041656L)

//
// MessageId: QPLIST_E_EXPECTING_CLOSE_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis.
//
#define QPLIST_E_EXPECTING_CLOSE_PAREN   ((HRESULT)0x80041657L)

//
// MessageId: QPLIST_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPLIST_E_EXPECTING_GUID          ((HRESULT)0x80041658L)

//
// MessageId: QPLIST_E_BAD_GUID
//
// MessageText:
//
//  Invalid guid.
//
#define QPLIST_E_BAD_GUID                ((HRESULT)0x80041659L)

//
// MessageId: QPLIST_E_EXPECTING_PROP_SPEC
//
// MessageText:
//
//  Expecting property specifier.
//
#define QPLIST_E_EXPECTING_PROP_SPEC     ((HRESULT)0x8004165AL)

//
// MessageId: QPLIST_E_CANT_SET_PROPERTY
//
// MessageText:
//
//  Failed to set property name.
//
#define QPLIST_E_CANT_SET_PROPERTY       ((HRESULT)0x8004165BL)

//
// MessageId: QPLIST_E_DUPLICATE
//
// MessageText:
//
//  Duplicate property name.
//
#define QPLIST_E_DUPLICATE               ((HRESULT)0x8004165CL)

//
// MessageId: QPLIST_E_VECTORBYREF_USED_ALONE
//
// MessageText:
//
//  DBTYPE_VECTOR or DBTYPE_BYREF used alone.
//
#define QPLIST_E_VECTORBYREF_USED_ALONE  ((HRESULT)0x8004165DL)

//
// MessageId: QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE
//
// MessageText:
//
//  DBTYPE_BYREF must be used with DBTYPE_STR, DBTYPE_WSTR, DBTYPE_GUID
//   or DBTYPE_UI1 types.
//
#define QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE ((HRESULT)0x8004165EL)

//
// MessageId: QPARSE_E_UNEXPECTED_NOT
//
// MessageText:
//
//  Unexpected NOT operator.
//
#define QPARSE_E_UNEXPECTED_NOT          ((HRESULT)0x80041660L)

//
// MessageId: QPARSE_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPARSE_E_EXPECTING_INTEGER       ((HRESULT)0x80041661L)

//
// MessageId: QPARSE_E_EXPECTING_REAL
//
// MessageText:
//
//  Expecting real number.
//
#define QPARSE_E_EXPECTING_REAL          ((HRESULT)0x80041662L)

//
// MessageId: QPARSE_E_EXPECTING_DATE
//
// MessageText:
//
//  Expecting date.
//
#define QPARSE_E_EXPECTING_DATE          ((HRESULT)0x80041663L)

//
// MessageId: QPARSE_E_EXPECTING_CURRENCY
//
// MessageText:
//
//  Expecting currency.
//
#define QPARSE_E_EXPECTING_CURRENCY      ((HRESULT)0x80041664L)

//
// MessageId: QPARSE_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPARSE_E_EXPECTING_GUID          ((HRESULT)0x80041665L)

//
// MessageId: QPARSE_E_EXPECTING_BRACE
//
// MessageText:
//
//  Expecting closing square bracket ']'.
//
#define QPARSE_E_EXPECTING_BRACE         ((HRESULT)0x80041666L)

//
// MessageId: QPARSE_E_EXPECTING_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis ')'.
//
#define QPARSE_E_EXPECTING_PAREN         ((HRESULT)0x80041667L)

//
// MessageId: QPARSE_E_EXPECTING_PROPERTY
//
// MessageText:
//
//  Expecting property name.
//
#define QPARSE_E_EXPECTING_PROPERTY      ((HRESULT)0x80041668L)

//
// MessageId: QPARSE_E_NOT_YET_IMPLEMENTED
//
// MessageText:
//
//  Not yet implemented.
//
#define QPARSE_E_NOT_YET_IMPLEMENTED     ((HRESULT)0x80041669L)

//
// MessageId: QPARSE_E_EXPECTING_PHRASE
//
// MessageText:
//
//  Expecting phrase.
//
#define QPARSE_E_EXPECTING_PHRASE        ((HRESULT)0x8004166AL)

//
// MessageId: QPARSE_E_UNSUPPORTED_PROPERTY_TYPE
//
// MessageText:
//
//  Unsupported property type.
//
#define QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ((HRESULT)0x8004166BL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX
//
// MessageText:
//
//  Expecting regular expression.
//
#define QPARSE_E_EXPECTING_REGEX         ((HRESULT)0x8004166CL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX_PROPERTY
//
// MessageText:
//
//  Regular expressions require a property of type string.
//
#define QPARSE_E_EXPECTING_REGEX_PROPERTY ((HRESULT)0x8004166DL)

//
// MessageId: QPARSE_E_INVALID_LITERAL
//
// MessageText:
//
//  Invalid literal.
//
#define QPARSE_E_INVALID_LITERAL         ((HRESULT)0x8004166EL)

//
// MessageId: QPARSE_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  No such property.
//
#define QPARSE_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004166FL)

//
// MessageId: QPARSE_E_EXPECTING_EOS
//
// MessageText:
//
//  Expecting end of string.
//
#define QPARSE_E_EXPECTING_EOS           ((HRESULT)0x80041670L)

//
// MessageId: QPARSE_E_EXPECTING_COMMA
//
// MessageText:
//
//  Expecting comma.
//
#define QPARSE_E_EXPECTING_COMMA         ((HRESULT)0x80041671L)

//
// MessageId: QPARSE_E_UNEXPECTED_EOS
//
// MessageText:
//
//  Unexpected end of string.
//
#define QPARSE_E_UNEXPECTED_EOS          ((HRESULT)0x80041672L)

//
// MessageId: QPARSE_E_WEIGHT_OUT_OF_RANGE
//
// MessageText:
//
//  Weight must be between 0 and 1000 in short form queries and between 0.0 and 1.0 in long form queries.
//
#define QPARSE_E_WEIGHT_OUT_OF_RANGE     ((HRESULT)0x80041673L)

//
// MessageId: QPARSE_E_NO_SUCH_SORT_PROPERTY
//
// MessageText:
//
//  An invalid property was found in the sort specification.
//
#define QPARSE_E_NO_SUCH_SORT_PROPERTY   ((HRESULT)0x80041674L)

//
// MessageId: QPARSE_E_INVALID_SORT_ORDER
//
// MessageText:
//
//  An invalid sort order was specified.  Only [a] and [d] are supported.
//
#define QPARSE_E_INVALID_SORT_ORDER      ((HRESULT)0x80041675L)

//
// MessageId: QUTIL_E_CANT_CONVERT_VROOT
//
// MessageText:
//
//  Couldn't convert a virtual path to a physical path.
//
#define QUTIL_E_CANT_CONVERT_VROOT       ((HRESULT)0x80041676L)

//
// MessageId: QPARSE_E_INVALID_GROUPING
//
// MessageText:
//
//  An unsupported grouping type was specified.
//
#define QPARSE_E_INVALID_GROUPING        ((HRESULT)0x80041677L)

//
// MessageId: QUTIL_E_INVALID_CODEPAGE
//
// MessageText:
//
//  Invalid CiCodepage was specified.
//
#define QUTIL_E_INVALID_CODEPAGE         ((HRESULT)0xC0041678L)

//
// MessageId: QPLIST_S_DUPLICATE
//
// MessageText:
//
//  Exact duplicate property defined.
//
#define QPLIST_S_DUPLICATE               ((HRESULT)0x00041679L)

//
// MessageId: QPARSE_E_INVALID_QUERY
//
// MessageText:
//
//  Invalid query.
//
#define QPARSE_E_INVALID_QUERY           ((HRESULT)0x8004167AL)

//
// MessageId: QPARSE_E_INVALID_RANKMETHOD
//
// MessageText:
//
//  Invalid rank method.
//
#define QPARSE_E_INVALID_RANKMETHOD      ((HRESULT)0x8004167BL)

//
// 0x1680 - 0x169F are Filter daemon error codes
//
//
// MessageId: FDAEMON_W_WORDLISTFULL
//
// MessageText:
//
//  Wordlist has reached maximum size.  Additional documents should not be filtered.
//
#define FDAEMON_W_WORDLISTFULL           ((HRESULT)0x00041680L)

//
// MessageId: FDAEMON_E_LOWRESOURCE
//
// MessageText:
//
//  The system is running out of one of more resources needed for filtering, usually memory.
//
#define FDAEMON_E_LOWRESOURCE            ((HRESULT)0x80041681L)

//
// MessageId: FDAEMON_E_FATALERROR
//
// MessageText:
//
//  A critical error occurred during document filtering.  Consult system administrator.
//
#define FDAEMON_E_FATALERROR             ((HRESULT)0x80041682L)

//
// MessageId: FDAEMON_E_PARTITIONDELETED
//
// MessageText:
//
//  Documents not stored in content index because partition has been deleted.
//
#define FDAEMON_E_PARTITIONDELETED       ((HRESULT)0x80041683L)

//
// MessageId: FDAEMON_E_CHANGEUPDATEFAILED
//
// MessageText:
//
//  Documents not stored in content index because update of changelist failed.
//
#define FDAEMON_E_CHANGEUPDATEFAILED     ((HRESULT)0x80041684L)

//
// MessageId: FDAEMON_W_EMPTYWORDLIST
//
// MessageText:
//
//  Final wordlist was empty.
//
#define FDAEMON_W_EMPTYWORDLIST          ((HRESULT)0x00041685L)

//
// MessageId: FDAEMON_E_WORDLISTCOMMITFAILED
//
// MessageText:
//
//  Commit of wordlist failed.  Data not available for query.
//
#define FDAEMON_E_WORDLISTCOMMITFAILED   ((HRESULT)0x80041686L)

//
// MessageId: FDAEMON_E_NOWORDLIST
//
// MessageText:
//
//  No wordlist is being constructed.  May happen after fatal filter error.
//
#define FDAEMON_E_NOWORDLIST             ((HRESULT)0x80041687L)

//
// MessageId: FDAEMON_E_TOOMANYFILTEREDBLOCKS
//
// MessageText:
//
//  During document filtering the limit on buffers has been exceeded.
//
#define FDAEMON_E_TOOMANYFILTEREDBLOCKS  ((HRESULT)0x80041688L)

//
// ISearch error codes
//
//
// MessageId: SEARCH_S_NOMOREHITS
//
// MessageText:
//
//  End of hits has been reached.
//
#define SEARCH_S_NOMOREHITS              ((HRESULT)0x000416A0L)

//
// MessageId: SEARCH_E_NOMONIKER
//
// MessageText:
//
//  Retrival of hits as monikers is not supported (by filter passed into Init).
//
#define SEARCH_E_NOMONIKER               ((HRESULT)0x800416A1L)

//
// MessageId: SEARCH_E_NOREGION
//
// MessageText:
//
//  Retrival of hits as filter regions is not supported (by filter passed into Init).
//
#define SEARCH_E_NOREGION                ((HRESULT)0x800416A2L)

//
// Filter error codes
//
//
// MessageId: FILTER_E_TOO_BIG
//
// MessageText:
//
//  File is too large to filter.
//
#define FILTER_E_TOO_BIG                 ((HRESULT)0x80041730L)

//
// MessageId: FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A partial content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041731L)

//
// MessageId: FILTER_S_FULL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A full content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_FULL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041732L)

//
// MessageId: FILTER_S_CONTENTSCAN_DELAYED
//
// MessageText:
//
//  A content scan of the disk needs to be scheduled for execution later.
//
#define FILTER_S_CONTENTSCAN_DELAYED     ((HRESULT)0x00041733L)

//
// MessageId: FILTER_E_CONTENTINDEXCORRUPT
//
// MessageText:
//
//  The content index is corrupt. A content scan will to be scheduled after chkdsk or autochk is run.
//
#define FILTER_E_CONTENTINDEXCORRUPT     ((HRESULT)0xC0041734L)

//
// MessageId: FILTER_S_DISK_FULL
//
// MessageText:
//
//  The disk is getting full.
//
#define FILTER_S_DISK_FULL               ((HRESULT)0x00041735L)

//
// MessageId: FILTER_E_ALREADY_OPEN
//
// MessageText:
//
//  A file is already open. Cannot open another one while a file is open.
//
#define FILTER_E_ALREADY_OPEN            ((HRESULT)0x80041736L)

//
// MessageId: FILTER_E_UNREACHABLE
//
// MessageText:
//
//  The file is not reachable.
//
#define FILTER_E_UNREACHABLE             ((HRESULT)0x80041737L)

//
// MessageId: FILTER_E_IN_USE
//
// MessageText:
//
//  The document is in use by another process.
//
#define FILTER_E_IN_USE                  ((HRESULT)0x80041738L)

//
// MessageId: FILTER_E_NOT_OPEN
//
// MessageText:
//
//  The document is not opened.
//
#define FILTER_E_NOT_OPEN                ((HRESULT)0x80041739L)

//
// MessageId: FILTER_S_NO_PROPSETS
//
// MessageText:
//
//  The document has no property sets.
//
#define FILTER_S_NO_PROPSETS             ((HRESULT)0x0004173AL)

//
// MessageId: FILTER_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  There is no property with the given GUID.
//
#define FILTER_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004173BL)

//
// MessageId: FILTER_S_NO_SECURITY_DESCRIPTOR
//
// MessageText:
//
//  The document has no security descriptor.
//
#define FILTER_S_NO_SECURITY_DESCRIPTOR  ((HRESULT)0x0004173CL)

//
// MessageId: FILTER_E_OFFLINE
//
// MessageText:
//
//  The document is offline.
//
#define FILTER_E_OFFLINE                 ((HRESULT)0x8004173DL)

//
// MessageId: FILTER_E_PARTIALLY_FILTERED
//
// MessageText:
//
//  The document was too large to filter in its entirety.  Portions of the document were not emitted.
//
#define FILTER_E_PARTIALLY_FILTERED      ((HRESULT)0x8004173EL)

//
// Word breaker error codes
//
//
// MessageId: WBREAK_E_END_OF_TEXT
//
// MessageText:
//
//  End of text reached in text source.
//
#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

//
// MessageId: LANGUAGE_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by word sink.
//
#define LANGUAGE_S_LARGE_WORD            ((HRESULT)0x00041781L)

//
// MessageId: WBREAK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define WBREAK_E_QUERY_ONLY              ((HRESULT)0x80041782L)

//
// MessageId: WBREAK_E_BUFFER_TOO_SMALL
//
// MessageText:
//
//  Buffer too small to hold composed phrase.
//
#define WBREAK_E_BUFFER_TOO_SMALL        ((HRESULT)0x80041783L)

//
// MessageId: LANGUAGE_E_DATABASE_NOT_FOUND
//
// MessageText:
//
//  Langauge database/cache file could not be found.
//
#define LANGUAGE_E_DATABASE_NOT_FOUND    ((HRESULT)0x80041784L)

//
// MessageId: WBREAK_E_INIT_FAILED
//
// MessageText:
//
//  Initialization of word breaker failed.
//
#define WBREAK_E_INIT_FAILED             ((HRESULT)0x80041785L)

//
// MessageId: PSINK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define PSINK_E_QUERY_ONLY               ((HRESULT)0x80041790L)

//
// MessageId: PSINK_E_INDEX_ONLY
//
// MessageText:
//
//  Feature only available in index mode.
//
#define PSINK_E_INDEX_ONLY               ((HRESULT)0x80041791L)

//
// MessageId: PSINK_E_LARGE_ATTACHMENT
//
// MessageText:
//
//  Attachment type beyond valid range.
//
#define PSINK_E_LARGE_ATTACHMENT         ((HRESULT)0x80041792L)

//
// MessageId: PSINK_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by phrase sink.
//
#define PSINK_S_LARGE_WORD               ((HRESULT)0x00041793L)

//
// Content Index Framework Error Codes
//
//
// MessageId: CI_CORRUPT_DATABASE
//
// MessageText:
//
//  The content index is corrupt.
//
#define CI_CORRUPT_DATABASE              ((HRESULT)0xC0041800L)

//
// MessageId: CI_CORRUPT_CATALOG
//
// MessageText:
//
//  The content index meta data is corrupt.
//
#define CI_CORRUPT_CATALOG               ((HRESULT)0xC0041801L)

//
// MessageId: CI_INVALID_PARTITION
//
// MessageText:
//
//  The content index partition is invalid.
//
#define CI_INVALID_PARTITION             ((HRESULT)0xC0041802L)

//
// MessageId: CI_INVALID_PRIORITY
//
// MessageText:
//
//  The priority is invalid.
//
#define CI_INVALID_PRIORITY              ((HRESULT)0xC0041803L)

//
// MessageId: CI_NO_STARTING_KEY
//
// MessageText:
//
//  There is no starting key.
//
#define CI_NO_STARTING_KEY               ((HRESULT)0xC0041804L)

//
// MessageId: CI_OUT_OF_INDEX_IDS
//
// MessageText:
//
//  The content index is out of index ids.
//
#define CI_OUT_OF_INDEX_IDS              ((HRESULT)0xC0041805L)

//
// MessageId: CI_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_NO_CATALOG                    ((HRESULT)0xC0041806L)

//
// MessageId: CI_CORRUPT_FILTER_BUFFER
//
// MessageText:
//
//  The filter buffer is corrupt.
//
#define CI_CORRUPT_FILTER_BUFFER         ((HRESULT)0xC0041807L)

//
// MessageId: CI_INVALID_INDEX
//
// MessageText:
//
//  The index is invalid.
//
#define CI_INVALID_INDEX                 ((HRESULT)0xC0041808L)

//
// MessageId: CI_PROPSTORE_INCONSISTENCY
//
// MessageText:
//
//  Inconsistency in property store detected.
//
#define CI_PROPSTORE_INCONSISTENCY       ((HRESULT)0xC0041809L)

//
// MessageId: CI_E_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object is already initialzed.
//
#define CI_E_ALREADY_INITIALIZED         ((HRESULT)0x8004180AL)

//
// MessageId: CI_E_NOT_INITIALIZED
//
// MessageText:
//
//  The object is not initialzed.
//
#define CI_E_NOT_INITIALIZED             ((HRESULT)0x8004180BL)

//
// MessageId: CI_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The buffer is too small.
//
#define CI_E_BUFFERTOOSMALL              ((HRESULT)0x8004180CL)

//
// MessageId: CI_E_PROPERTY_NOT_CACHED
//
// MessageText:
//
//  The given property is not cached.
//
#define CI_E_PROPERTY_NOT_CACHED         ((HRESULT)0x8004180DL)

//
// MessageId: CI_S_WORKID_DELETED
//
// MessageText:
//
//  The workid is deleted.
//
#define CI_S_WORKID_DELETED              ((HRESULT)0x0004180EL)

//
// MessageId: CI_E_INVALID_STATE
//
// MessageText:
//
//  The object is not in a valid state.
//
#define CI_E_INVALID_STATE               ((HRESULT)0x8004180FL)

//
// MessageId: CI_E_FILTERING_DISABLED
//
// MessageText:
//
//  Filtering is disabled in this content index.
//
#define CI_E_FILTERING_DISABLED          ((HRESULT)0x80041810L)

//
// MessageId: CI_E_DISK_FULL
//
// MessageText:
//
//  The disk is full and the specified operation cannot be done.
//
#define CI_E_DISK_FULL                   ((HRESULT)0x80041811L)

//
// MessageId: CI_E_SHUTDOWN
//
// MessageText:
//
//  Content Index has been shutdown.
//
#define CI_E_SHUTDOWN                    ((HRESULT)0x80041812L)

//
// MessageId: CI_E_WORKID_NOTVALID
//
// MessageText:
//
//  The workid is not valid.
//
#define CI_E_WORKID_NOTVALID             ((HRESULT)0x80041813L)

//
// MessageId: CI_S_END_OF_ENUMERATION
//
// MessageText:
//
//  There are no more documents to enumerate.
//
#define CI_S_END_OF_ENUMERATION          ((HRESULT)0x00041814L)    

//
// MessageId: CI_E_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define CI_E_NOT_FOUND                   ((HRESULT)0x80041815L)

//
// MessageId: CI_E_USE_DEFAULT_PID
//
// MessageText:
//
//  The passed-in property id is not supported.
//
#define CI_E_USE_DEFAULT_PID             ((HRESULT)0x80041816L)

//
// MessageId: CI_E_DUPLICATE_NOTIFICATION
//
// MessageText:
//
//  There were two notifications for the same workid.
//
#define CI_E_DUPLICATE_NOTIFICATION      ((HRESULT)0x80041817L)

//
// MessageId: CI_E_UPDATES_DISABLED
//
// MessageText:
//
//  A document update was rejected because updates were disabled.
//
#define CI_E_UPDATES_DISABLED            ((HRESULT)0x80041818L)

//
// MessageId: CI_E_INVALID_FLAGS_COMBINATION
//
// MessageText:
//
//  The combination of flags specified is invalid.
//
#define CI_E_INVALID_FLAGS_COMBINATION   ((HRESULT)0x80041819L)

//
// MessageId: CI_E_OUTOFSEQ_INCREMENT_DATA
//
// MessageText:
//
//  The incremental data given to Load is not valid. It may be out of sequence.
//
#define CI_E_OUTOFSEQ_INCREMENT_DATA     ((HRESULT)0x8004181AL)

//
// MessageId: CI_E_SHARING_VIOLATION
//
// MessageText:
//
//  A sharing or locking violation caused a failure.
//
#define CI_E_SHARING_VIOLATION           ((HRESULT)0x8004181BL)

//
// MessageId: CI_E_LOGON_FAILURE
//
// MessageText:
//
//  A logon permission violation caused a failure.
//
#define CI_E_LOGON_FAILURE               ((HRESULT)0x8004181CL)

//
// MessageId: CI_E_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_E_NO_CATALOG                  ((HRESULT)0x8004181DL)

//
// MessageId: CI_E_STRANGE_PAGEORSECTOR_SIZE
//
// MessageText:
//
//  Page size is not an integral multiple of the sector size of the volume where index is located.
//
#define CI_E_STRANGE_PAGEORSECTOR_SIZE   ((HRESULT)0x8004181EL)

//
// MessageId: CI_E_TIMEOUT
//
// MessageText:
//
//  Service is too busy.
//
#define CI_E_TIMEOUT                     ((HRESULT)0x8004181FL)

//
// MessageId: CI_E_NOT_RUNNING
//
// MessageText:
//
//  Service is not running.
//
#define CI_E_NOT_RUNNING                 ((HRESULT)0x80041820L)

//
// MessageId: CI_INCORRECT_VERSION
//
// MessageText:
//
//  The content index data on disk is for the wrong version.
//
#define CI_INCORRECT_VERSION             ((HRESULT)0xC0041821L)

//
// MessageId: CI_E_ENUMERATION_STARTED
//
// MessageText:
//
//  Enumeration has already been started for this query.
//
#define CI_E_ENUMERATION_STARTED         ((HRESULT)0xC0041822L)

//
// MessageId: CI_E_PROPERTY_TOOLARGE
//
// MessageText:
//
//  The specified variable length property is too large for the property cache.
//
#define CI_E_PROPERTY_TOOLARGE           ((HRESULT)0xC0041823L)

//
// MessageId: CI_E_CLIENT_FILTER_ABORT
//
// MessageText:
//
//  Filtering of object was aborted by client.
//
#define CI_E_CLIENT_FILTER_ABORT         ((HRESULT)0xC0041824L)

//
// MessageId: CI_S_NO_DOCSTORE
//
// MessageText:
//
//  For administrative connections from client without association to a docstore.
//
#define CI_S_NO_DOCSTORE                 ((HRESULT)0x00041825L)

//
// MessageId: CI_S_CAT_STOPPED
//
// MessageText:
//
//  The catalog has been stopped.
//
#define CI_S_CAT_STOPPED                 ((HRESULT)0x00041826L)

//
// MessageId: CI_E_CARDINALITY_MISMATCH
//
// MessageText:
//
//  Mismatch in cardinality of machine(s)/catalog(s)/scope(s).
//
#define CI_E_CARDINALITY_MISMATCH        ((HRESULT)0x80041827L)

//
// MessageId: CI_E_CONFIG_DISK_FULL
//
// MessageText:
//
//  The disk has reached its configured space limit.
//
#define CI_E_CONFIG_DISK_FULL            ((HRESULT)0x80041828L)

#endif // _CIERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\globals.h ===
// globals.h
// global structure decalrations
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  02 JUN 2000   bhshin    add cNounRec, cNoRec entry in WORD_REC
//  30 MAR 2000	  bhshin	created

#define MAX_INPUT_TOKEN     16

#define MAX_ENTRY_LENGTH	128
#define MAX_INDEX_STRING	128

typedef unsigned int Bit;

// RECORD structure info
// =====================
typedef struct {
	WCHAR wzIndex[MAX_INDEX_STRING]; // index string
	unsigned short nFT, nLT;		 // first and last token/char in input sentence
	unsigned char nDict;			 // dict source info (see DICT_* below)
	unsigned short nLeftCat;		 // left side CAT (CAT -> POS|Infl)
	unsigned short nRightCat;		 // right side CAT
	unsigned short nLeftChild;		 // left child record
	unsigned short nRightChild;		 // right child record
	float fWeight;					 // record weight value
	int cNounRec;					 // number of (Nf, Nc, Nn) record
	int cNoRec;						 // number of No record
} WORD_REC, *pWORD_REC;


// CHAR_INFO_REC structure
// =======================
typedef struct {
    union {
        // having a separate mask allows us to quickly init these values
        unsigned char mask;
        struct {
            Bit fValidStart : 1;    // pre-composed jamo starting char
            Bit fValidEnd : 1;      // pre-composed jamo ending char
        };
    };
    unsigned short nToken;
} CHAR_INFO_REC, *pCHAR_INFO_REC;


// MAPFILE structure
// =================
typedef struct {
    HANDLE hFile;
    HANDLE hFileMapping;
    void *pvData;
} MAPFILE, *pMAPFILE;


// PARSE INFO structure
// ====================
typedef struct {
    // pointer to original (unmodified) input string
    WCHAR *pwzInputString;

    // input string with normalizations
    WCHAR *pwzSourceString;

    // ptr to CharInfo array
    // a '1' in this array indicates that the character position is a valid
    // start position for records
    // (maps 1-1 with pwzSourceString)
    CHAR_INFO_REC *rgCharInfo;

    // source(normalized) string length
    int nLen;

    // largest valid LT value
    int nMaxLT;

    // the lexicon (mapped into memory)
    MAPFILE lexicon;

    // record management
    // =================
    // array of records
	WORD_REC *rgWordRec;

	// # of allocated records in pWordRec
	int nMaxRec;
	// next empty space in pWordRec
	int nCurrRec;

} PARSE_INFO, *pPARSE_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\chartpool.cpp ===
// ChartPool.cpp
//
// Leaf/End/Active ChartPool implementation
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "ChartPool.h"

// =======================
// LEAF CHART POOL
// =======================

// CLeafChartPool::CLeafChartPool
//
// constructor of CLeafChartPool
//
// Parameters:
//  (void)
//
// Result:
//  (void)
//
// 30MAR00  bhshin  began
CLeafChartPool::CLeafChartPool()
{
	m_pPI = NULL;

	m_rgLeafChart = NULL;
	m_nMaxRec = 0;
	m_nCurrRec = 0; 
	
	m_rgnFTHead = NULL;
	m_rgnLTHead = NULL;

	m_nMaxTokenAlloc = 0;
}

// CLeafChartPool::~CLeafChartPool
//
// destructor of CLeafChartPool
//
// Parameters:
//  (void)
//
// Result:
//  (void)
//
// 30MAR00  bhshin  began
CLeafChartPool::~CLeafChartPool()
{
	// uninitialize in destructor
	Uninitialize();
}

// CLeafChartPool::Initialize
//
// intialize LeafChartPool newly
//
// Parameters:
//  pPI	-> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL CLeafChartPool::Initialize(PARSE_INFO *pPI)
{
	int i;
	int nTokens;
	
	if (pPI == NULL)
		return FALSE;

    // allocate new m_rgLeafChart
    if (m_rgLeafChart != NULL)
		free(m_rgLeafChart);

	m_nMaxRec = RECORD_INITIAL_SIZE;
    m_rgLeafChart = (LEAF_CHART*)malloc(m_nMaxRec * sizeof(LEAF_CHART));
    if (m_rgLeafChart == NULL)
    {
        m_nMaxRec = 0;
        return FALSE;
    }

	m_nCurrRec = MIN_RECORD;

    // allocate new FT/LT token arrays
    nTokens = wcslen(pPI->pwzSourceString) + 2;

	if (m_rgnFTHead != NULL)
        free(m_rgnFTHead);
    if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
        
    m_nMaxTokenAlloc = nTokens;
    m_rgnFTHead = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));
    m_rgnLTHead = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));

    if (m_rgnFTHead == NULL || m_rgnLTHead == NULL)
    {
		m_nMaxTokenAlloc = 0;
        return FALSE;
    }
	
	for (i = 0; i < m_nMaxTokenAlloc; i++)
	{
		m_rgnFTHead[i] = 0;
		m_rgnLTHead[i] = 0;
	}

	// save PARSE_INFO structure
	m_pPI = pPI;

	return TRUE;
}

// CLeafChartPool::Uninitialize
//
// un-intialize LeafChartPool
//
// Parameters:
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::Uninitialize()
{
	m_nMaxRec = 0;
	m_nCurrRec = 0;

	if (m_rgLeafChart != NULL)
		free(m_rgLeafChart);
	m_rgLeafChart = NULL;

	m_nMaxTokenAlloc = 0;

    if (m_rgnFTHead != NULL)
        free(m_rgnFTHead);
    m_rgnFTHead = NULL;
    
	if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
    m_rgnLTHead = NULL;
}

// CLeafChartPool::GetLeafChart
//
// get the record given ChartID
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart 
//
// Result:
//  (LEAF_CHART*) NULL if error occurs, otherwise LEAF_CHART pointer
//
// 30MAR00  bhshin  began
LEAF_CHART* CLeafChartPool::GetLeafChart(int nChartID)
{
	// check chart ID overflow
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	return &m_rgLeafChart[nChartID];
}

// CLeafChartPool::GetRecordID
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart 
//
// Result:
//  (int) 0 if error occurs, otherwise record id
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetRecordID(int nChartID)
{
	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return 0;

	return m_rgLeafChart[nChartID].nRecordID;
}

// CLeafChartPool::GetWordRec
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart 
//
// Result:
//  (WORD_REC*) NULL if error occurs, otherwise WORD_REC pointer
//
// 30MAR00  bhshin  began
WORD_REC* CLeafChartPool::GetWordRec(int nChartID)
{
	int nRecordID;

	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	nRecordID = m_rgLeafChart[nChartID].nRecordID;

	// check record ID
	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
		return NULL;

	return &m_pPI->rgWordRec[nRecordID];
}

// CLeafChartPool::GetFTHead
//
// get the chart ID of FT head 
//
// Parameters:
// nFT -> (int) FT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetFTHead(int nFT)
{
	if (nFT < 0 || nFT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnFTHead[nFT];
}

// CLeafChartPool::GetFTNext
//
// get the chart ID of FT next record
//
// Parameters:
// nChartID -> (int) chart ID
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetFTNext(int nChartID)
{
	LEAF_CHART *pLeafChart;

	pLeafChart = GetLeafChart(nChartID);
	if (pLeafChart == NULL)
		return 0;

	return pLeafChart->nFTNext;
}

// CLeafChartPool::GetLTHead
//
// get the chart ID of LT head 
//
// Parameters:
// nLT -> (int) LT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetLTHead(int nLT)
{
	if (nLT < 0 || nLT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnLTHead[nLT];
}

// CLeafChartPool::GetLTNext
//
// get the chart ID of LT next record
//
// Parameters:
// nChartID -> (int) chart ID
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CLeafChartPool::GetLTNext(int nChartID)
{
	LEAF_CHART *pLeafChart;

	pLeafChart = GetLeafChart(nChartID);
	if (pLeafChart == NULL)
		return 0;

	return pLeafChart->nLTNext;
}

// CLeafChartPool::AddRecord
//
// add a record into LeaftChartPool
//
// Parameters:
// nRecordID -> (int) record ID of rgWordRec 
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CLeafChartPool::AddRecord(int nRecordID)
{
    int nNewRecord;
	int curr;
	WORD_REC *pWordRec;

    if (m_rgLeafChart == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return 0;
	}

	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	pWordRec = &m_pPI->rgWordRec[nRecordID];
	if (pWordRec == NULL)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	// make sure this isn't a duplicate of another record
	for (curr = MIN_RECORD; curr < m_nCurrRec; curr++)
	{
		if (m_rgLeafChart[curr].nRecordID == nRecordID)
		{
			return curr; 
		}
	}

    // make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
        ATLTRACE("memory realloc in LeafChartPool\n");
		
		// alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgLeafChart, nNewSize * sizeof(LEAF_CHART));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        m_rgLeafChart = (LEAF_CHART*)pNew;
        m_nMaxRec = nNewSize;
	}

    nNewRecord = m_nCurrRec;
    m_nCurrRec++;

	m_rgLeafChart[nNewRecord].nRecordID = nRecordID;
	m_rgLeafChart[nNewRecord].nDict = DICT_FOUND;

	AddToFTList(nNewRecord);
	AddToLTList(nNewRecord);
	
	return nNewRecord;
}

// CLeafChartPool::AddRecord
//
// add a record into LeaftChartPool
//
// Parameters:
// pRec    -> (RECORD_INFO*) ptr to record info struct for new record
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CLeafChartPool::AddRecord(RECORD_INFO *pRec)
{
	// first, add record into record pool
	int nRecord = ::AddRecord(m_pPI, pRec);

	if (nRecord < MIN_RECORD)
	{
		// error occurs
		return nRecord;
	}

	return AddRecord(nRecord);
}

// CLeafChartPool::DeleteRecord
//
// delete a record into LeaftChartPool
//
// Parameters:
// nChartID -> (int) ID of m_rgLeafChart
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
void CLeafChartPool::DeleteRecord(int nChartID)
{
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return; // invalid chart ID

	if (m_rgLeafChart[nChartID].nDict == DICT_DELETED)
		return;

	RemoveFromFTList(nChartID);
	RemoveFromLTList(nChartID);

	m_rgLeafChart[nChartID].nDict = DICT_DELETED;
}

// CLeafChartPool::AddToFTList
//
// add the record to the appropriate FT list.
// note that this list is sorted in order of decreasing LT. (decreasing length)
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::AddToFTList(int nChartID)
{
	int curr, prev;
	int fDone;
	int nFT, nLT;
	WORD_REC *pWordRec;

	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;
    
    curr = m_rgnFTHead[nFT];
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		pWordRec = GetWordRec(curr);

		if (curr != 0 && pWordRec != NULL && pWordRec->nLT < nLT)
		{
			// go to next record
			prev = curr;
			curr = m_rgLeafChart[curr].nFTNext;
            ATLASSERT(curr < m_nCurrRec);
		}
		else
		{
			// insert record here
			if (prev == -1)
			{
				// add before beginning of list
				m_rgLeafChart[nChartID].nFTNext = m_rgnFTHead[nFT];
				m_rgnFTHead[nFT] = nChartID;
			}
			else
			{
				// insert in middle (or end) of list
				m_rgLeafChart[nChartID].nFTNext = m_rgLeafChart[prev].nFTNext;
				m_rgLeafChart[prev].nFTNext = nChartID;
			}
			fDone = TRUE;
		}
	}
}

// CLeafChartPool::AddToLTList
//
// add the record to the appropriate LT list.
// note that this list is sorted in order of increasing FT. (decreasing length)
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::AddToLTList(int nChartID)
{
	int curr, prev;
	int fDone;
	int nFT, nLT;
	WORD_REC *pWordRec;

	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;
    
    curr = m_rgnLTHead[nLT];
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		pWordRec = GetWordRec(curr);

		if (curr != 0 && pWordRec != NULL && pWordRec->nFT > nFT)
		{
			// go to next record
			prev = curr;
			curr = m_rgLeafChart[curr].nLTNext;
            ATLASSERT(curr < m_nCurrRec);
		}
		else
		{
			// insert record here
			if (prev == -1)
			{
				// add before beginning of list
				m_rgLeafChart[nChartID].nLTNext = m_rgnLTHead[nLT];
				m_rgnLTHead[nLT] = nChartID;
			}
			else
			{
				// insert in middle (or end) of list
				m_rgLeafChart[nChartID].nLTNext = m_rgLeafChart[prev].nLTNext;
				m_rgLeafChart[prev].nLTNext = nChartID;
			}
			fDone = TRUE;
		}
	}
}

// CLeafChartPool::RemoveFromFTList
//
// remove the given record from its FT list
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::RemoveFromFTList(int nChartID)
{
	int curr, next;
	int nFT;
	WORD_REC *pWordRec;

    ATLASSERT(nChartID < m_nCurrRec);
	
	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;

    curr = m_rgnFTHead[nFT];
	if (curr == nChartID)
	{
		m_rgnFTHead[nFT] = m_rgLeafChart[nChartID].nFTNext;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgLeafChart[curr].nFTNext;
			if (next == nChartID)
			{
				m_rgLeafChart[curr].nFTNext = m_rgLeafChart[nChartID].nFTNext;
				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}

// CLeafChartPool::RemoveFromLTList
//
// remove the given record from its LT list
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CLeafChartPool::RemoveFromLTList(int nChartID)
{
	int curr, next;
	int nLT;
	WORD_REC *pWordRec;

    ATLASSERT(nChartID < m_nCurrRec);
	
	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nLT = pWordRec->nLT;

    ATLASSERT(nChartID < m_nCurrRec);

    curr = m_rgnLTHead[nLT];
	if (curr == nChartID)
	{
		m_rgnLTHead[nLT] = m_rgLeafChart[nChartID].nLTNext;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgLeafChart[curr].nLTNext;
			if (next == nChartID)
			{
				m_rgLeafChart[curr].nLTNext = m_rgLeafChart[nChartID].nLTNext;
				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}

// =======================
// END CHART POOL
// =======================

// CEndChartPool::CEndChartPool
//
// constructor of CEndChartPool
//
// 30MAR00  bhshin  began
CEndChartPool::CEndChartPool()
{
	m_pPI = NULL;

	m_rgEndChart = NULL;
	m_nMaxRec = 0;
	m_nCurrRec = 0; 
	
	m_rgnLTHead = NULL;
	m_rgnLTMaxLen = NULL;

	m_nMaxTokenAlloc = 0;
}

// CEndChartPool::~CEndChartPool
//
// destructor of CEndChartPool
//
// 30MAR00  bhshin  began
CEndChartPool::~CEndChartPool()
{
	// uninitialize in destructor
	Uninitialize();
}

// CEndChartPool::Initialize
//
// intialize EndChartPool newly
//
// Parameters:
//  pPI	-> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL CEndChartPool::Initialize(PARSE_INFO *pPI)
{
	int i;
	int nTokens;
	
	if (pPI == NULL)
		return FALSE;

    // allocate new m_rgEndChart
    if (m_rgEndChart != NULL)
		free(m_rgEndChart);

	m_nMaxRec = RECORD_INITIAL_SIZE;
    m_rgEndChart = (END_CHART*)malloc(m_nMaxRec * sizeof(END_CHART));
    if (m_rgEndChart == NULL)
    {
        m_nMaxRec = 0;
        return FALSE;
    }

	m_nCurrRec = MIN_RECORD;

    // allocate new FT/LT token arrays
    nTokens = wcslen(pPI->pwzSourceString) + 2;

    if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
	if (m_rgnLTMaxLen != NULL)
		free(m_rgnLTMaxLen);

    m_nMaxTokenAlloc = nTokens;
    m_rgnLTHead = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));
	m_rgnLTMaxLen = (int*)malloc(m_nMaxTokenAlloc * sizeof(int));

    if (m_rgnLTHead == NULL || m_rgnLTMaxLen == NULL)
    {
		m_nMaxTokenAlloc = 0;
        return FALSE;
    }
	
	for (i = 0; i < m_nMaxTokenAlloc; i++)
	{
		m_rgnLTHead[i] = 0;
		m_rgnLTMaxLen[i] = 0;
	}

	// save PARSE_INFO structure
	m_pPI = pPI;

	return TRUE;
}

// CEndChartPool::Uninitialize
//
// un-intialize EndChartPool
//
// Parameters:
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CEndChartPool::Uninitialize()
{
	m_nMaxRec = 0;
	m_nCurrRec = 0;

	if (m_rgEndChart != NULL)
		free(m_rgEndChart);
	m_rgEndChart = NULL;

	m_nMaxTokenAlloc = 0;

	if (m_rgnLTHead != NULL)
        free(m_rgnLTHead);
    m_rgnLTHead = NULL;

	if (m_rgnLTMaxLen != NULL)
		free(m_rgnLTMaxLen);
	m_rgnLTMaxLen = NULL;
}

// CEndChartPool::GetEndChart
//
// get the record given ChartID
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart 
//
// Result:
//  (END_CHART*) NULL if error occurs, otherwise END_CHART pointer
//
// 30MAR00  bhshin  began
END_CHART* CEndChartPool::GetEndChart(int nChartID)
{
	// check chart ID overflow
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	return &m_rgEndChart[nChartID];
}

// CEndChartPool::GetRecordID
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart 
//
// Result:
//  (int) 0 if error occurs, otherwise record id
//
// 30MAR00  bhshin  began
int CEndChartPool::GetRecordID(int nChartID)
{
	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return 0;

	return m_rgEndChart[nChartID].nRecordID;
}

// CEndChartPool::GetWordRec
//
// get the record given RecordID
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart 
//
// Result:
//  (WORD_REC*) NULL if error occurs, otherwise WORD_REC pointer
//
// 30MAR00  bhshin  began
WORD_REC* CEndChartPool::GetWordRec(int nChartID)
{
	int nRecordID;

	// check chart ID 
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return NULL;

	nRecordID = m_rgEndChart[nChartID].nRecordID;

	// check record ID
	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
		return NULL;

	return &m_pPI->rgWordRec[nRecordID];
}

// CEndChartPool::GetLTHead
//
// get the chart ID of LT head 
//
// Parameters:
// nLT -> (int) LT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CEndChartPool::GetLTHead(int nLT)
{
	if (nLT < 0 || nLT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnLTHead[nLT];
}

// CEndChartPool::GetLTMaxLen
//
// get the maximum length given LT
//
// Parameters:
// nLT -> (int) LT value
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 06APR00  bhshin  began
int CEndChartPool::GetLTMaxLen(int nLT)
{
	if (nLT < 0 || nLT >= m_nMaxTokenAlloc)
		return 0;

	return m_rgnLTMaxLen[nLT];
}

// CEndChartPool::GetLTNext
//
// get the chart ID of LT next record
//
// Parameters:
// nChartID -> (int) chart ID
//
// Result:
//  (int) 0 if error occurs or empty, otherwise chart ID
//
// 30MAR00  bhshin  began
int CEndChartPool::GetLTNext(int nChartID)
{
	END_CHART *pEndChart;

	pEndChart = GetEndChart(nChartID);
	if (pEndChart == NULL)
		return 0;

	return pEndChart->nLTNext;
}

// CEndChartPool::AddRecord
//
// add a record into LeaftChartPool
//
// Parameters:
// nRecordID -> (int) record ID of rgWordRec 
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CEndChartPool::AddRecord(int nRecordID)
{
    int nNewRecord;
	int curr;
	WORD_REC *pWordRec;

    if (m_rgEndChart == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return 0;
	}

	if (nRecordID < MIN_RECORD || nRecordID >= m_pPI->nCurrRec)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	pWordRec = &m_pPI->rgWordRec[nRecordID];
	if (pWordRec == NULL)
	{
		ATLTRACE("Invalid Record ID\n");
		return 0;
	}

	// make sure this isn't a duplicate of another record
	for (curr = MIN_RECORD; curr < m_nCurrRec; curr++)
	{
		if (m_rgEndChart[curr].nRecordID == nRecordID)
		{
			return curr; 
		}
	}

    // make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
		ATLTRACE("memory realloc in EndChartPool\n");

        // alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgEndChart, nNewSize * sizeof(END_CHART));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        m_rgEndChart = (END_CHART*)pNew;
        m_nMaxRec = nNewSize;
	}

    nNewRecord = m_nCurrRec;
    m_nCurrRec++;

	m_rgEndChart[nNewRecord].nRecordID = nRecordID;
	m_rgEndChart[nNewRecord].nDict = DICT_FOUND;

	AddToLTList(nNewRecord);
	
	return nNewRecord;
}

// CEndChartPool::AddRecord
//
// add a new record into LeaftChartPool
//
// Parameters:
// pRec    -> (RECORD_INFO*) ptr to record info struct for new record
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
int CEndChartPool::AddRecord(RECORD_INFO *pRec)
{
	// first, add record into record pool
	int nRecord = ::AddRecord(m_pPI, pRec);

	if (nRecord < MIN_RECORD)
	{
		// error occurs
		return nRecord;
	}

	return AddRecord(nRecord);
}

// CEndChartPool::DeleteRecord
//
// delete a record into LeaftChartPool
//
// Parameters:
// nChartID -> (int) ID of m_rgEndChart
//
// Result:
//  (int) 0 if error occurs, otherwise return index
//
// 30MAR00  bhshin  began
void CEndChartPool::DeleteRecord(int nChartID)
{
	if (nChartID < MIN_RECORD || nChartID >= m_nCurrRec)
		return; // invalid chart ID

	if (m_rgEndChart[nChartID].nDict == DICT_DELETED)
		return;

	RemoveFromLTList(nChartID);

	m_rgEndChart[nChartID].nDict = DICT_DELETED;
}

// CEndChartPool::AddToLTList
//
// add the record to the appropriate LT list.
// note that this list is sorted 
// in order of decreasing weight & increasing # of No
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 02JUN00  bhshin  changed sort order
// 30MAR00  bhshin  began
void CEndChartPool::AddToLTList(int nChartID)
{
	int curr, prev;
	int fDone;
	int nFT, nLT;
	float fWeight;
	int cNoRec;
	WORD_REC *pWordRec;

	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;

	fWeight = pWordRec->fWeight;
	cNoRec = pWordRec->cNoRec;

	// check LTMaxLen
	if (m_rgnLTMaxLen[nLT] < nLT-nFT+1)
	{
		m_rgnLTMaxLen[nLT] = nLT-nFT+1;
	}
    
    curr = m_rgnLTHead[nLT];
	prev = -1;
	fDone = FALSE;
	while (!fDone)
	{
        ATLASSERT(curr < m_nCurrRec);

		pWordRec = GetWordRec(curr);

		if (curr != 0 && pWordRec != NULL && pWordRec->fWeight >= fWeight)
		{
			if (pWordRec->fWeight > fWeight || pWordRec->cNoRec < cNoRec)
			{
				// go to next record
				prev = curr;
				curr = m_rgEndChart[curr].nLTNext;
				ATLASSERT(curr < m_nCurrRec);

				continue;
			}
		}

		// otherwise, insert record here
		if (prev == -1)
		{
			// add before beginning of list
			m_rgEndChart[nChartID].nLTNext = m_rgnLTHead[nLT];
			m_rgnLTHead[nLT] = nChartID;
		}
		else
		{
			// insert in middle (or end) of list
			m_rgEndChart[nChartID].nLTNext = m_rgEndChart[prev].nLTNext;
			m_rgEndChart[prev].nLTNext = nChartID;
		}

		fDone = TRUE;
	}
}

// CEndChartPool::RemoveFromLTList
//
// remove the given record from its LT list
// 
// Parameters:
//  nChartID -> (int) index of the LeafChart
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CEndChartPool::RemoveFromLTList(int nChartID)
{
	int curr, next;
	int nFT, nLT;
	WORD_REC *pWordRec;
	BOOL fUpdateLTMaxLen = FALSE;

    ATLASSERT(nChartID < m_nCurrRec);
	
	pWordRec = GetWordRec(nChartID);
	if (pWordRec == NULL)
		return;

	nFT = pWordRec->nFT;
	nLT = pWordRec->nLT;

    ATLASSERT(nChartID < m_nCurrRec);

	// LTMaxLen need to be update?
	// if final node, then change LTMaxLen
	if (m_rgEndChart[nChartID].nLTNext == 0)
		fUpdateLTMaxLen = TRUE;

    curr = m_rgnLTHead[nLT];
	if (curr == nChartID)
	{
		m_rgnLTHead[nLT] = m_rgEndChart[nChartID].nLTNext;

		if (fUpdateLTMaxLen)		
			m_rgnLTMaxLen[nLT] = 0;
	}
	else
	{
        ATLASSERT(curr < m_nCurrRec);
		while (curr != 0)
		{
			next = m_rgEndChart[curr].nLTNext;
			if (next == nChartID)
			{
				m_rgEndChart[curr].nLTNext = m_rgEndChart[nChartID].nLTNext;
		
				if (fUpdateLTMaxLen)		
				{
					pWordRec = GetWordRec(curr);
					if (pWordRec == NULL)
						return;
					m_rgnLTMaxLen[nLT] = pWordRec->nLT-pWordRec->nFT+1;
				}

				break;
			}
			curr = next;
            ATLASSERT(curr < m_nCurrRec);
		}
	}
}

// =======================
// ACTIVE CHART POOL
// =======================

// CActiveChartPool::CActiveChartPool
//
// constructor of CActiveChartPool
//
// 30MAR00  bhshin  began
CActiveChartPool::CActiveChartPool()
{
	m_rgnRecordID = NULL;
	
	m_nMaxRec = 0;
	m_nCurrRec = 0;
}

// CActiveChartPool::~CActiveChartPool
//
// destructor of CActiveChartPool
//
// 30MAR00  bhshin  began
CActiveChartPool::~CActiveChartPool()
{
	// uninitialize in destructor
	Uninitialize();
}

// CActiveChartPool::Initialize
//
// intialize rgnRecordID
//
// Parameters:
//  (NONE)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL CActiveChartPool::Initialize()
{
    // allocate new m_rgnRecordID
    if (m_rgnRecordID != NULL)
		free(m_rgnRecordID);

	m_nCurrRec = MIN_RECORD;
	m_nHeadRec = MIN_RECORD;

	m_nMaxRec = RECORD_INITIAL_SIZE;

    m_rgnRecordID = (int*)malloc(m_nMaxRec * sizeof(int));
    if (m_rgnRecordID == NULL)
    {
        m_nMaxRec = 0;
        return FALSE;
    }

	return TRUE;
}

// CActiveChartPool::Uninitialize
//
// un-intialize m_rgnRecordID
//
// Parameters:
//	(NONE)
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
void CActiveChartPool::Uninitialize()
{
	m_nMaxRec = 0;
	m_nCurrRec = 0;
	m_nHeadRec = 0;

	if (m_rgnRecordID != NULL)
		free(m_rgnRecordID);

	m_rgnRecordID = NULL;
}

// CActiveChartPool::Push
//
// add Record ID
//
// Parameters:
//  nRecordID  -> (int) record ID of record pool
//
// Result:
//  (void) 
//
// 30MAR00  bhshin  began
int CActiveChartPool::Push(int nRecordID)
{
    int nNewRecord;

	// make sure there's enough room for the new record
	if (m_nCurrRec >= m_nMaxRec)
	{
		ATLTRACE("memory realloc in ActiveChartPool\n");
        
		// alloc some more space in the array
        int nNewSize = m_nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(m_rgnRecordID, nNewSize * sizeof(int));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        m_rgnRecordID = (int*)pNew;
        m_nMaxRec = nNewSize;
	}

	nNewRecord = m_nCurrRec;
	m_nCurrRec++;

	m_rgnRecordID[nNewRecord] = nRecordID;

	return nNewRecord;
}

// CActiveChartPool::Pop
//
// get a Record ID and remove it
//
// Parameters:
//	(NONE)
//
// Result:
//  (int) record id, if emtry then 0
//
// 30MAR00  bhshin  began
int CActiveChartPool::Pop()
{
	int nRecordID;

	if (m_nHeadRec >= m_nCurrRec)
	{
		// empty case
		nRecordID = 0;
	}
	else
	{
		nRecordID = m_rgnRecordID[m_nHeadRec];
		m_nHeadRec++;
	}

	return nRecordID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\guessindex.h ===
// GuessIndex.h
//
// guessing index terms
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  21 MAR 2000  bhshin     convert CIndexList into CIndexInfo
//  10 APR 2000	  bhshin	created

#ifndef _GUESS_INDEX_H
#define _GUESS_INDEX_H

#include "IndexRec.h"

BOOL GuessIndexTerms(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo);

void GuessPersonName(PARSE_INFO *pPI, CIndexInfo *pIndexInfo);

#endif // #ifndef _GUESS_INDEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\ctplus.c ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//              28-Aug-97   weibz       Add Hanguel char support
//				02-Aug-00   bhshin		changed type from CH to WS (right single quote, _)
//
//---------------------------------------------------------------------------


#include <windows.h>
#include "ctplus.h"


//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,WS,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,WS,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          //  FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,WS,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,WS,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2000-2007
        WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,CH,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          //  3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    10-Sep-97   Weibz
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(CH);  // full width currency
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeExW( MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN ),
                                  CT_CTYPE1,
                                  &wc2,
                                  1,
                                  &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole Hanja as Non-Hangul character
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

			// compatibility range
			if ((wc >= 0xF900) && (wc <= 0xFAFF)) {
				return (IC);
			}

			// extensionA
			if ((wc >= 0x3400) && (wc <= 0x4DB5)) {
				return (IC);
			}

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // Treat Hanguel Region as hanguel char.
            if ((wc >= 0xac00) && (wc <= 0xd7a3)) {
               return(HG);
            }

			// Treat Hanguel jamo range as hanguel char.
            if ((wc >= 0x3131) && (wc <= 0x318E)) {
               return(HG);
            }

            // If it's not interesting return PS as default
			// NOTE: This means that these characters are not handled by WBr.
            return(PS);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\guessindex.cpp ===
// GuessIndex.cpp
//
// guessing index terms
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  21 MAR 2000  bhshin     convert CIndexList into CIndexInfo
//  10 APR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "ChartPool.h"
#include "GuessIndex.h"
#include "unikor.h"
#include "Morpho.h"
#include "WbData.h"
#include "Lookup.h"
#include "LexInfo.h"
#include "_kor_name.h"
#include "uni.h"
#include <math.h>

//////////////////////////////////////////////////////////////////////////////
// Threshold for Korean name guessing

#define THRESHOLD_TWO_NAME	  37
#define THRESHOLD_ONE_NAME	  37

//////////////////////////////////////////////////////////////////////////////
// Particle pattern needed to check C/V

#define POSP_NEED_V			  1
#define POSP_NEED_C			  2

//////////////////////////////////////////////////////////////////////////////
// Particle pattern needed to check C/V

// , 
#define HANGUL_NEUN			0xB294
#define HANGUL_REUL			0xB97C

// , , , , 
#define HANGUL_NIM			0xB2D8
#define HANGUL_SSI			0xC528
#define HANGUL_DEUL			0xB4E4
#define HANGUL_MICH			0xBC0F 
#define HANGUL_DEUNG		0xB4F1 

//////////////////////////////////////////////////////////////////////////////
// Post position of name

//   
static const WCHAR POSP_OF_NAME[]   = L"\xC758\xB9CC\xB3C4";
//    
static const WCHAR POSP_OF_NAME_V[] = L"\xB791\xB098\xAC00\xC640";
//  
static const WCHAR POSP_OF_NAME_C[] = L"\xC774\xACFC";

#define HANGUL_RANG			0xB791

//////////////////////////////////////////////////////////////////////////////
// Bit mask for Trigram tag value
// (2bit) + TRIGRAM(10bit) + BIGRAM(10bit) + UNIGRAM(10BIT)

const ULONG BIT_MASK_TRIGRAM = 0x3FF00000;
const ULONG BIT_MASK_BIGRAM	= 0x000FFC00;
const ULONG BIT_MASK_UNIGRAM = 0x000003FF;

//////////////////////////////////////////////////////////////////////////////
// Costants for guessing index

const float WEIGHT_GUESS_INDEX	 =	20;

//////////////////////////////////////////////////////////////////////////////
// Internal function declarations

int MakeIndexStr(const WCHAR *pwzSrc, int cchSrc, WCHAR *pwzDst, int nMaxDst);

BOOL GuessNounIndexTerm(PARSE_INFO *pPI, int nMaxFT, int nMaxLT, 
					    CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo);

BOOL ExistParticleRecord(PARSE_INFO *pPI, int nStart, int nEnd, CLeafChartPool *pLeafChartPool);

BOOL CheckGuessing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo);

BOOL IsKoreanPersonName(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput);

//////////////////////////////////////////////////////////////////////////////
// Function implementations

// GuessIndexTerms
//
// guessing index terms
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pIndexInfo	   -> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL GuessIndexTerms(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo)
{
	int curr, next;
	WORD_REC *pWordRec;
	BYTE bPOS;
	int nFT, nLT;
	int nToken;
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int cchIndex;
	WCHAR wchLast;

	if (pPI == NULL || pLeafChartPool == NULL || pIndexInfo == NULL)
		return FALSE;

	// Check whether the input is worth for Guessing or Not
	if (!CheckGuessing(pPI, pLeafChartPool, pIndexInfo))
		return TRUE;

	// guessing index terms for all input
	cchIndex = wcslen(pPI->pwzInputString);
	wchLast = pPI->pwzInputString[cchIndex-1];
	
	//  STEP1:
	// gusessing index terms for all STRING
	if (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL)
	{
		pIndexInfo->AddIndex(pPI->pwzInputString, cchIndex, WEIGHT_GUESS_INDEX, 0, cchIndex-1);
		WB_LOG_ADD_INDEX(pPI->pwzInputString, cchIndex, INDEX_GUESS_NOUN);
	}

	// STEP1-1:
	// according to post-position, add guessing index terms 
	// if (last character of STRING in {  } )
    //    index_terms(STRING);
    //    index_terms(STRING-{/})
	if (cchIndex > 1 && (wchLast == HANGUL_MICH || wchLast == HANGUL_DEUNG))
	{
		pIndexInfo->AddIndex(pPI->pwzInputString, cchIndex, WEIGHT_GUESS_INDEX, 0, cchIndex-1);
		WB_LOG_ADD_INDEX(pPI->pwzInputString, cchIndex, INDEX_GUESS_NOUN);

		pIndexInfo->AddIndex(pPI->pwzInputString, cchIndex-1, WEIGHT_GUESS_INDEX, 0, cchIndex-2);
		WB_LOG_ADD_INDEX(pPI->pwzInputString, cchIndex-1, INDEX_GUESS_NOUN);
	}

	GuessNounIndexTerm(pPI, 0, pPI->nMaxLT, pLeafChartPool, pIndexInfo);

	/*
	// find fiducial Noun in LeafChartPool
	for (int i = pPI->nLen; i >= 0; i--)
	{
		// if it don't match character boundary, then skip
		if (!pPI->rgCharInfo[i].fValidStart)
			continue;		
		
		curr = pLeafChartPool->GetFTHead(i);

		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				break;

			curr = next;

			bPOS = HIBYTE(pWordRec->nLeftCat);
			nFT = pWordRec->nFT;
			nLT = pWordRec->nLT;

			if (!pPI->rgCharInfo[nLT].fValidEnd)
				continue;
			
			if (bPOS == POS_NF)
			{
				// add this NF record as index terms
				cchIndex = MakeIndexStr(pWordRec->wzIndex, wcslen(pWordRec->wzIndex), wzIndex, MAX_INDEX_STRING);
				wchLast = wzIndex[cchIndex-1];

				if (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL)
				{
					nToken = pPI->rgCharInfo[nFT].nToken;

					pIndexList->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
					WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
				}

				// Rear rest string case				
				if (nLT < pPI->nMaxLT)
				{
					// make index term with rear rest string
					WCHAR *pwzRest = pPI->pwzSourceString + nLT + 1;

					// 1. NF is front record
					// 2. RearRestString & RearRestString is not Particle/CopulaEnding 
					if (nFT == 0 && !ExistParticleRecord(pPI, nLT + 1, pPI->nMaxLT, pLeafChartPool))
					{
						cchIndex = MakeIndexStr(pwzRest, wcslen(pwzRest), wzIndex, MAX_INDEX_STRING);
						wchLast = wzIndex[cchIndex-1];

						if (cchIndex > 1 && (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL))
						{
							nToken = pPI->rgCharInfo[nLT+1].nToken;

							pIndexList->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
							WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
						}

						GuessNounIndexTerm(pPI, nLT + 1, pPI->nMaxLT, pLeafChartPool, pIndexList);
					}
				}
				
				// Front rest string case
				if (i > 0)
				{
					// make index term with rest string
					cchIndex = MakeIndexStr(pPI->pwzSourceString, i, wzIndex, MAX_INDEX_STRING);
					wchLast = wzIndex[cchIndex-1];

					if (cchIndex > 1 && (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL))
					{	
						pIndexList->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, 0, cchIndex-1);
						WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
					}
				}

				break; // go to next FT
			}
		}
	}
	*/
	
	return TRUE;
}

// MakeIndexStr
//
// make composed index string from decomposed string
//
// Parameters:
//  pwzSrc	   -> (const WCHAR*) ptr to input decomposed string
//  cchSrc	   -> (int) size of input string
//  pwzDst     -> (WCHAR*) ptr to output buffer
//  nMaxDst    -> (int) size of output buffer
//
// Result:
//  (int) character length of composed output
//
// 10APR00  bhshin  began
int MakeIndexStr(const WCHAR *pwzSrc, int cchSrc, WCHAR *pwzDst, int nMaxDst)
{
	WCHAR wzDecomp[MAX_INDEX_STRING*3+1];

	ZeroMemory(wzDecomp, sizeof(WCHAR)*(MAX_INDEX_STRING*3+1));

	// compose index string
	wcsncpy(wzDecomp, pwzSrc, cchSrc);

	return compose_jamo(pwzDst, wzDecomp, nMaxDst);
}

// GuessNounIndexTerm
//
// remove particle from the end of words and guess noun index term
//
// Parameters:
// pPI			  -> (PARSE_INFO*) ptr to parse-info struct
// nMaxFT		  -> (int) 
// nMaxLT		  -> (int) 
// pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
// pIndexInfo	  -> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL GuessNounIndexTerm(PARSE_INFO *pPI, int nMaxFT, int nMaxLT, 
					    CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo)
{
	int curr, next;
	WORD_REC *pWordRec;
	BYTE bPOS, bPattern;
	int nLT;
	WCHAR wzIndex[MAX_INDEX_STRING];
	int cchIndex;
	WCHAR wchLast, wchPrevLast, wchFinal;
	int nToken;

	if (pPI == NULL)
		return FALSE;

	if (pLeafChartPool == NULL)
		return FALSE;

	if (pIndexInfo == NULL)
		return FALSE;

	for (int i = nMaxLT; i >= nMaxFT; i--)
	{
		// if it don't match character boundary, then skip
		if (!pPI->rgCharInfo[i].fValidStart)
			continue;
		
		// need for C/V check
		wchFinal = *(pPI->pwzSourceString + i - 1);

		curr = pLeafChartPool->GetFTHead(i);

		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				break;

			bPOS = HIBYTE(pWordRec->nLeftCat);
			bPattern = LOBYTE(pWordRec->nLeftCat);

			nLT = pWordRec->nLT;

			// looking for particle covering from i to end of input
			if (nLT == nMaxLT && (bPOS == POS_POSP || IsCopulaEnding(pPI, pWordRec->nLeftCat)))
			{
				// In Particle case, check Consonent/Vowel condition
				if (bPOS == POS_POSP && i > 0)
				{
					if ((bPattern == POSP_NEED_V && !fIsJungSeong(wchFinal)) ||
					    (bPattern == POSP_NEED_C && !fIsJongSeong(wchFinal)))
					{
						// C/V condition mismatched, then go to next
						curr = next;
						continue;
					}
				}
				
				// make index term with string from nMaxFT to i-nMaxFT
				cchIndex = MakeIndexStr(pPI->pwzSourceString + nMaxFT, i-nMaxFT, wzIndex, MAX_INDEX_STRING);
				if (cchIndex > 1)
				{
					wchLast = wzIndex[cchIndex-1];
					
					if (wchLast != HANGUL_NEUN && wchLast != HANGUL_REUL)
					{
						nToken = pPI->rgCharInfo[nMaxFT].nToken;

						pIndexInfo->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
						WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NOUN);
					}

					wchPrevLast = wzIndex[cchIndex-2];
					
					if ((wchLast == HANGUL_NIM || wchLast == HANGUL_SSI || wchLast == HANGUL_DEUL) &&
						(wchPrevLast != HANGUL_NEUN && wchPrevLast != HANGUL_REUL))
					{
						wzIndex[cchIndex-1] = L'\0';

						nToken = pPI->rgCharInfo[nMaxFT].nToken;
						
						pIndexInfo->AddIndex(wzIndex, cchIndex-1, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-2);
						WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NOUN);
					}
				}
				else if (cchIndex == 1)
				{
					nToken = pPI->rgCharInfo[nMaxFT].nToken;

					pIndexInfo->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
					WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NOUN);
				}

				break; // go to next FT
			}

			curr = next;
		}
	}

	return TRUE;
}

// ExistParticleRecord
//
// looking for Particle/CopulaEnding record covering from Start to End
//
// Parameters:
// pPI		  -> (PARSE_INFO*) ptr to parse-info struct
// nStart	  -> (int) 
// nEnd		  -> (int) 
// pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//
// Result:
//  (BOOL) TRUE if found, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL ExistParticleRecord(PARSE_INFO *pPI, int nStart, int nEnd, CLeafChartPool *pLeafChartPool)
{
	int curr;
	WORD_REC *pWordRec;
	int nLT;
	BYTE bPOS;
	
	if (pPI == NULL || pLeafChartPool == NULL)
		return FALSE;

	curr = pLeafChartPool->GetFTHead(nStart);
	while (curr != 0)
	{
		pWordRec = pLeafChartPool->GetWordRec(curr);
		if (pWordRec == NULL)
			continue;

		curr = pLeafChartPool->GetFTNext(curr);

		nLT = pWordRec->nLT;

		// record covering from Start to End found 
		if (nLT == nEnd)
		{
			bPOS = HIBYTE(pWordRec->nLeftCat);

			// Particle or Copula Ending
			if (bPOS == POS_POSP || IsCopulaEnding(pPI, pWordRec->nLeftCat))
				return TRUE;
		}
	}

	return FALSE;
}

// CheckGuessing
//
// Check whether the input is worth for Guessing or Not
//
// Parameters:
//  pPI			   -> (PARSE_INFO*) ptr to parse-info struct
//  pLeafChartPool -> (CLeafChartPool*) ptr to Leaf Chart Pool
//  pIndexInfo	   -> (CIndexInfo *) output index list
//
// Result:
//  (BOOL) TRUE if guessing needed, otherwise return FALSE
//
// 10APR00  bhshin  began
BOOL CheckGuessing(PARSE_INFO *pPI, CLeafChartPool *pLeafChartPool, CIndexInfo *pIndexInfo)
{
	int curr, next;
	WORD_REC *pWordRec;
	WCHAR wzIndex[MAX_INDEX_STRING];
	int cchIndex;
	int nToken;
	
	// If there is no jongseong (11BB), (11AD), (11B6), (CC2E), (C796) then guessing needed.
	if (wcsrchr(pPI->pwzSourceString, 0x11BB) == NULL &&
		wcsrchr(pPI->pwzSourceString, 0x11AD) == NULL &&
		wcsrchr(pPI->pwzSourceString, 0x11B6) == NULL &&
		wcsrchr(pPI->pwzInputString, 0xCC2E) == NULL &&
		wcsrchr(pPI->pwzInputString, 0xC796) == NULL)
		return TRUE; // guessing needed

	// make index terms for each Nf records in LeafChartPool
	// find fiducial Noun in LeafChartPool
	for (int i = pPI->nLen; i >= 0; i--)
	{
		// if it don't match character boundary, then skip
		if (!pPI->rgCharInfo[i].fValidStart)
			continue;		
		
		curr = pLeafChartPool->GetFTHead(i);

		while (curr != 0)
		{
			next = pLeafChartPool->GetFTNext(curr);

			pWordRec = pLeafChartPool->GetWordRec(curr);
			if (pWordRec == NULL)
				break;

			curr = next;

			if (HIBYTE(pWordRec->nLeftCat) == POS_NF)
			{
				// add this NF record as index terms
				cchIndex = MakeIndexStr(pWordRec->wzIndex, wcslen(pWordRec->wzIndex), wzIndex, MAX_INDEX_STRING);

				nToken = pPI->rgCharInfo[pWordRec->nFT].nToken;			

				pIndexInfo->AddIndex(wzIndex, cchIndex, WEIGHT_GUESS_INDEX, nToken, nToken+cchIndex-1);
				WB_LOG_ADD_INDEX(wzIndex, cchIndex, INDEX_GUESS_NF);
			}
		}
	}
	
	return FALSE;
}

// GuessPersonName
//
// recognize whether it can be a name or not
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  pIndexInfo  -> (CIndexInfo *) output index list
//
// Result:
//  (int) string length if it can be a person's name, othewise return 0
//
// 05JUN00  bhshin  change retrun type
// 02MAY00  bhshin  use probability result
// 20APR00  bhshin  began
void GuessPersonName(PARSE_INFO *pPI, CIndexInfo *pIndexInfo)
{
	WCHAR wchLast;
	WCHAR *pwzFind;
	const WCHAR *pwzInput;
	const WCHAR *pwzSource;
	int cchInput, cchName, cchSource;

	if (pPI == NULL)
		return;

	pwzInput = pPI->pwzInputString;
	pwzSource = pPI->pwzSourceString;

	cchInput = wcslen(pwzInput);

	if (cchInput >= 3)
	{
		pwzFind = wcschr(pwzInput, HANGUL_SSI);
		
		if (pwzFind != NULL)
		{
			cchName = (int)(pwzFind - pwzInput);
			return;
		}
	}

	// just handle length 2,3,4 case
	if (cchInput < 2 || cchInput > 5)
		return;

	wchLast = pwzInput[cchInput-1];
	if (wchLast == HANGUL_REUL || wchLast == HANGUL_NEUN)
		return;

	// looking for jongseong (11BB)
	if (wcsrchr(pwzSource, 0x11BB) != NULL)
		return;

	// check if original string is name
	if (cchInput <= 4)
	{
		if (IsKoreanPersonName(pPI, pwzInput, cchInput))
		{
			pIndexInfo->AddIndex(pwzInput, cchInput, WEIGHT_HARD_MATCH, 0, cchInput-1);
			WB_LOG_ADD_INDEX(pwzInput, cchInput, INDEX_GUESS_NAME);
		}
	}

	cchName = cchInput;
	cchSource = wcslen(pwzSource);

	if (cchInput >= 3 && cchInput <= 5 && cchSource > 4)
	{
		// looking for name posp

		if (wcsrchr(POSP_OF_NAME, wchLast) != NULL)
		{
			cchName--;
		}
		else if (wcsrchr(POSP_OF_NAME_V, wchLast) != NULL)
		{
			//  case
			if (wchLast == HANGUL_RANG && fIsV(pwzSource[cchSource-4]))
				cchName--;
			else if (fIsV(pwzSource[cchSource-3]))
				cchName--;
		}
		else if (wcsrchr(POSP_OF_NAME_C, wchLast) != NULL)
		{
			cchSource = wcslen(pwzSource);

			if (fIsC(pwzSource[cchSource-3]))
				cchName--;
		}
	}

	// we handle just length 2,3,4 name.
	if (cchName > 4)
		return;

	if (cchName < cchInput)
	{
		if (IsKoreanPersonName(pPI, pwzInput, cchName))
		{
			pIndexInfo->AddIndex(pwzInput, cchName, WEIGHT_HARD_MATCH, 0, cchName-1);
			WB_LOG_ADD_INDEX(pwzInput, cchName, INDEX_GUESS_NAME);
		}
	}
}

// IsKoreanPersonName
//
// get the probability of korean name
//
// Parameters:
//  pPI			 -> (PARSE_INFO*) ptr to parse-info struct
//  pwzInput	-> (const WCHAR*) current input string (NULL terminated)
//  cchInput	-> (int) length of input string to analyze
//
// Result:
//  (BOOL) TRUE if it can be a person's name, othewise return FALSE
//
// 02MAY00  bhshin  began
BOOL IsKoreanPersonName(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput)
{
	LEXICON_HEADER *pLex;
	unsigned char *pKorName;
	unsigned char *pTrigramTag;
	TRIECTRL *pTrieLast, *pTrieUni, *pTrieBi, *pTrieTri;
	WCHAR wzLastName[5];
	WCHAR wzName[5];
	const WCHAR *pwzName;
	const WCHAR *pwzLastName; 
	const WCHAR *pwzFirstName;
	int cchLast, cchFirst;
	ULONG ulFreq, ulTri, ulBi, ulUni;
	int nIndex;
	double fRetProb, fProb;
	ULONG rgTotal[3] = {TOTAL_KORNAME_TRIGRAM, TOTAL_KORNAME_BIGRAM, TOTAL_KORNAME_UNIGRAM};
	double rgWeight[3] = {0.1, 0.4, 0.5};

	pTrieLast = NULL;
	pTrieUni = NULL;
	pTrieBi = NULL;
	pTrieTri = NULL;

	if (pPI == NULL)
		return FALSE;

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return FALSE;

	pKorName = (unsigned char*)pLex;
	pKorName += pLex->rgnLastName;

	pTrieLast = TrieInit((LPBYTE)pKorName);
	if (pTrieLast == NULL)
		goto Exit;
	
	pKorName = (unsigned char*)pLex;
	pKorName += pLex->rgnNameUnigram;

	pTrieUni = TrieInit((LPBYTE)pKorName);
	if (pTrieUni == NULL)
		goto Exit;

	pKorName = (unsigned char*)pLex;
	pKorName += pLex->rgnNameBigram;

	pTrieBi = TrieInit((LPBYTE)pKorName);
	if (pTrieBi == NULL)
		goto Exit;

	pKorName = (unsigned char*)pLex;
	pKorName += pLex->rgnNameTrigram;

	pTrieTri = TrieInit((LPBYTE)pKorName);
	if (pTrieTri == NULL)
		goto Exit;

	pTrigramTag = (unsigned char*)pLex;
	pTrigramTag += pLex->rngTrigramTag;

	// last name
	fProb = 0;

	if (cchInput == 2)
	{
		wzLastName[0] = *pwzInput;
		wzLastName[1] = L'\0';

		if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
			goto Exit;

		if (ulFreq == 0)
			goto Exit;

		fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

		pwzFirstName = pwzInput + 1;
	}
	else if (cchInput == 3) // length 3 case
	{
		wzLastName[0] = *pwzInput;
		wzLastName[1] = L'\0';

		if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
			goto Exit;

		if (ulFreq == 0)
		{
			// guess length 2 last name

			wcsncpy(wzLastName, pwzInput, 2);
			wzLastName[2] = L'\0';
			
			if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
				goto Exit;

			if (ulFreq == 0)
				goto Exit;

			fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

			pwzFirstName = pwzInput + 2;
		}
		else
		{
			fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

			pwzFirstName = pwzInput + 1;
		}
	}
	else if (cchInput == 4)
	{
		// guess length 2 last name
		wcsncpy(wzLastName, pwzInput, 2);
		wzLastName[2] = L'\0';

		if (!LookupNameFrequency(pTrieLast, wzLastName, &ulFreq))
			goto Exit;

		if (ulFreq == 0)
			goto Exit;

		fProb = (double)ulFreq / TOTAL_KORNAME_LASTNAME;

		pwzFirstName = pwzInput + 2;
	}

	if (fProb == 0)
		goto Exit;

	fRetProb = log(fProb);
	
	pwzLastName = wzLastName;

	cchLast = wcslen(pwzLastName);
	cchFirst = cchInput - cchLast;

	ATLASSERT(cchLast == 1 || cchLast == 2);
	ATLASSERT(cchFirst == 1 || cchFirst == 2);

	// first -> [*][Last][First1]
	wzName[0] = L'*';
	wcscpy(wzName+1, pwzLastName);
	wzName[cchLast+1] = *pwzFirstName;
	wzName[cchLast+2] = L'\0';

	pwzName = wzName;

	fProb = 0;

	if (!LookupNameIndex(pTrieTri, pwzName, &nIndex))
		goto Exit;

	if (nIndex != -1)
	{
		LookupTrigramTag(pTrigramTag, nIndex, &ulTri, &ulBi, &ulUni);

		fProb += rgWeight[0] * (double)ulTri / rgTotal[0];
		fProb += rgWeight[1] * (double)ulBi / rgTotal[1];
		fProb += rgWeight[2] * (double)ulUni / rgTotal[2];
	}
	else
	{
		pwzName++; // skip *

		if (!LookupNameFrequency(pTrieBi, pwzName, &ulFreq))
			goto Exit;

		fProb += rgWeight[1] * (double)ulFreq / rgTotal[1];

		pwzName += cchLast; // skip [Last]

		if (!LookupNameFrequency(pTrieUni, pwzName, &ulFreq))
			goto Exit;

		fProb += rgWeight[2] * (double)ulFreq / rgTotal[2];
	}

	if (fProb == 0)
		goto Exit;

	fRetProb += log(fProb);

	// second -> [Last][First1][First2]
	if (cchFirst == 2)
	{
		wcscpy(wzName, pwzLastName);
		wzName[cchLast] = *pwzFirstName;
		wzName[cchLast+1] = *(pwzFirstName+1);
		wzName[cchLast+2] = L'\0';

		pwzName = wzName;
	
		fProb = 0;

		if (!LookupNameIndex(pTrieTri, pwzName, &nIndex))
			goto Exit;

		if (nIndex != -1)
		{
			LookupTrigramTag(pTrigramTag, nIndex, &ulTri, &ulBi, &ulUni);

			fProb += rgWeight[0] * (double)ulTri / rgTotal[0];
			fProb += rgWeight[1] * (double)ulBi / rgTotal[1];
			fProb += rgWeight[2] * (double)ulUni / rgTotal[2];
		}
		else
		{
			pwzName += cchLast; // skip [Last]
			
			if (!LookupNameFrequency(pTrieBi, pwzName, &ulFreq))
				goto Exit;

			fProb += rgWeight[1] * (double)ulFreq / rgTotal[1];

			pwzName++; // skip [First1]

			if (!LookupNameFrequency(pTrieUni, pwzName, &ulFreq))
				goto Exit;

			fProb += rgWeight[2] * (double)ulFreq / rgTotal[2];
		}

		if (fProb == 0)
			goto Exit;
		
		fRetProb += log(fProb);
	}

	// third -> [First1][First2][*] or [Last][First1][*]
	if (cchFirst == 2)
	{
		wcscpy(wzName, pwzFirstName);
		wzName[cchFirst] = L'*';
		wzName[cchFirst+1] = L'\0';
	}
	else // cchFirst == 1
	{
		ATLASSERT(cchFirst == 1);
		
		wcscpy(wzName, pwzLastName);
		wzName[cchLast] = *pwzFirstName;
		wzName[cchLast+1] = L'*';
		wzName[cchLast+2] = L'\0';
	}

	pwzName = wzName;
		
	fProb = 0;

	if (!LookupNameIndex(pTrieTri, pwzName, &nIndex))
		goto Exit;

	if (nIndex != -1)
	{
		LookupTrigramTag(pTrigramTag, nIndex, &ulTri, &ulBi, &ulUni);

		fProb += rgWeight[0] * (double)ulTri / rgTotal[0];
		fProb += rgWeight[1] * (double)ulBi / rgTotal[1];
		fProb += rgWeight[2] * (double)ulUni / rgTotal[2];
	}
	else
	{
		if (cchFirst == 1)
			pwzName += cchLast;
		else
			pwzName++;
		
		if (!LookupNameFrequency(pTrieBi, pwzName, &ulFreq))
			goto Exit;

		fProb = rgWeight[1] * (float)ulFreq / rgTotal[1];
	}

	if (fProb == 0)
		goto Exit;
	
	fRetProb += log(fProb);

	// make positive value
	fRetProb *= -1;

	TrieFree(pTrieLast);
	TrieFree(pTrieUni);
	TrieFree(pTrieBi);
	TrieFree(pTrieTri);

	// check threshold
	if (cchFirst == 2)
	{
		if (fRetProb < THRESHOLD_TWO_NAME)
			return TRUE;
		else
			return FALSE;
	}
	else // cchFirst == 1
	{
		ATLASSERT(cchFirst == 1);
		
		if (fRetProb < THRESHOLD_ONE_NAME)
			return TRUE;
		else
			return FALSE;
	}

Exit:
	if (pTrieLast != NULL)
		TrieFree(pTrieLast);

	if (pTrieUni != NULL)
		TrieFree(pTrieUni);
	
	if (pTrieBi != NULL)
		TrieFree(pTrieBi);
	
	if (pTrieTri != NULL)
		TrieFree(pTrieTri);

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\indexlist.cpp ===
// IndexList.cpp
//
// final index term list
// 
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  7 APR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IndexList.h"
#include "Morpho.h"

// CIndexList::IsExistIndex
//
// check if index term already exist.
//
// Parameters:
//  pwzIndex	-> (const WCHAR*) index string
//
// Result:
//  (BOOL)
//
// 06SEP00  bhshin  began
BOOL CIndexList::IsExistIndex(const WCHAR *pwzIndex)
{
	INDEX_LIST::iterator it, itStart, itEnd;

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		// found duplicate index term
		if (wcscmp(it->m_wzIndex, pwzIndex) == 0)
			return TRUE;
	}

	return FALSE;
}

// CIndexList::AddIndex
//
// add index term information 
//
// Parameters:
//  pwzIndex	-> (const WCHAR*) index string
//  cchIndex    -> (int) length of index string
//  nWeight     -> (int) weight value of index record
//  nFT         -> (int) first position of original input
//	nLT			-> (int) last position of original input
//
// Result:
//  (void)
//
// 23NOV00  bhshin  handle leading romaji case
// 07APR00  bhshin  began
void CIndexList::AddIndex(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT)
{
	INDEX_LIST::iterator it;
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int nLTAdd = nLT;
	
	// check index string length
	if (cchIndex >= MAX_INDEX_STRING)
		return;

	wcsncpy(wzIndex, pwzIndex, cchIndex);
	wzIndex[cchIndex] = L'\0';

	if (nLT > 0 && m_cchRomaji > 0)
		nLTAdd += m_cchRomaji;

	// conjoin leading romaji & index string
	if (nFT == 0 && m_cchRomaji == 1)
	{
		WCHAR wzMerge[MAX_INDEX_STRING+1];

		// check index string length
		if (m_cchRomaji + cchIndex >= MAX_INDEX_STRING)
			return;

		wcscpy(wzMerge, m_wzRomaji);
		wcscat(wzMerge, wzIndex);

		if (IsExistIndex(wzMerge))
			return;

		CIndexTerm IndexRomaji(wzMerge, cchIndex + m_cchRomaji, fWeight, nFT, nLTAdd);
		m_listIndex.insert(m_listIndex.end(), IndexRomaji);

		WB_LOG_ADD_INDEX(wzMerge, cchIndex + m_cchRomaji, INDEX_SYMBOL);

		// remove prefix
		if (m_cchPrefix > 0)
		{
			CIndexTerm IndexRomaji(wzMerge + m_cchPrefix,
								   cchIndex + m_cchRomaji - m_cchPrefix, 
								   fWeight, 
								   nFT + m_cchPrefix, 
								   nLTAdd);
								   
			m_listIndex.insert(m_listIndex.end(), IndexRomaji);

			WB_LOG_ADD_INDEX(wzMerge + m_cchPrefix, cchIndex + m_cchRomaji - m_cchPrefix, INDEX_SYMBOL);
		}
	}
	else
	{
		if (IsExistIndex(wzIndex))
			return;

		CIndexTerm IndexTerm(wzIndex, cchIndex, fWeight, nFT + m_cchRomaji, nLTAdd);

		m_listIndex.insert(m_listIndex.end(), IndexTerm);

		if (m_cchRomaji > 1 && m_fAddRomaji == FALSE)
		{
			CIndexTerm IndexRomaji(m_wzRomaji, m_cchRomaji, WEIGHT_HARD_MATCH, 0, m_cchRomaji-1);
			m_listIndex.insert(m_listIndex.end(), IndexRomaji);

			WB_LOG_ADD_INDEX(m_wzRomaji, m_cchRomaji, INDEX_SYMBOL);

			// remove prefix
			if (m_cchPrefix > 0)
			{
				CIndexTerm IndexRomaji(m_wzRomaji + m_cchPrefix,
								   	   m_cchRomaji - m_cchPrefix, 
								       WEIGHT_HARD_MATCH, 
								   	   m_cchPrefix, 
								       m_cchRomaji-m_cchPrefix-1);
								   
				m_listIndex.insert(m_listIndex.end(), IndexRomaji);

				WB_LOG_ADD_INDEX(m_wzRomaji + m_cchPrefix, m_cchRomaji - m_cchPrefix, INDEX_SYMBOL);
			}

			m_fAddRomaji = TRUE;
		}
	}

	return;
}

// CIndexList::PutIndexList
//
// call IWordSink::PutWord with collected index terms
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 07APR00  bhshin  began
BOOL CIndexList::PutIndexList()
{
	INDEX_LIST::iterator it;

	if (m_pWordSink == NULL)
		return FALSE;

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		m_pWordSink->PutWord(it->m_cchIndex, it->m_wzIndex, 
							 m_cchTextProcessed, m_cwcSrcPos);
	}

	return TRUE;
}

// CIndexList::MakeAndPutSymbolIndex
//
// make merged index term and put word
//
// Parameters:
//  pwzLeading  -> (const WCHAR*) leading string if exist
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 25JUL00  bhshin  began
BOOL CIndexList::MakeAndPutSymbolIndex(const WCHAR *pwzLeading, int nFT/*=0*/)
{
	INDEX_LIST::iterator it;
	int cchLeading = 0;
	WCHAR wzIndex[MAX_INDEX_STRING+1];

	if (m_pWordSink == NULL)
		return FALSE;

	if (pwzLeading == NULL)
		return FALSE;		
		
	cchLeading = wcslen(pwzLeading);

	WB_LOG_ROOT_INDEX(L"", TRUE); // set root empty

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		if (it->m_nFT == nFT)
		{
			// add symbol merged term
			int cchIndex = wcslen(it->m_wzIndex);

			if ((cchLeading + cchIndex) < MAX_INDEX_STRING)
			{
				wcscpy(wzIndex, pwzLeading);
				wcscat(wzIndex, it->m_wzIndex);
				
				m_pWordSink->PutWord(it->m_cchIndex + cchLeading, wzIndex, 
									 m_cchTextProcessed, m_cwcSrcPos);

				WB_LOG_ADD_INDEX(wzIndex, it->m_cchIndex + cchLeading, INDEX_SYMBOL);
			}
		}
	}

	return TRUE;
}

// CIndexList::InsertFinalIndex
//
// search index term starting with given FT and insert it to final list
//
// Parameters:
//  nFT  -> (int) first pos of index term
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 22NOV00  bhshin  began
BOOL CIndexList::InsertFinalIndex(int nFT)
{
	INDEX_LIST::iterator it;
	INDEX_LIST::iterator itFinal;
	BOOL fInsert;

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		if (it->m_cchIndex == 0)
			continue;

		// FT match index found
		if (it->m_nFT == nFT)
		{
			CIndexTerm IndexTerm(it->m_wzIndex,
			                     it->m_cchIndex, 
			                     it->m_fWeight, 
			                     it->m_nFT,
			                     it->m_nLT); 		

			
			// search inserting position. final list ordered by increamental length.
			fInsert = FALSE;
			for(itFinal = m_listFinal.begin(); itFinal != m_listFinal.end(); itFinal++)
			{
				if (itFinal->m_nFT != nFT)
					continue;

				if (it->m_cchIndex < itFinal->m_cchIndex)
				{
					m_listFinal.insert(itFinal, IndexTerm);

					fInsert = TRUE;
					break;
				}
			}

			if (!fInsert)
			{
				m_listFinal.push_back(IndexTerm);
			}
		}
	}
	
	return TRUE;
}

// CIndexList::PutFinalIndexList
//
// make final index list to put word
//
// Parameters:
//  lpcwzSrc -> (LPCWSTR) source string to get source pos
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 22NOV00  bhshin  began
BOOL CIndexList::PutFinalIndexList(LPCWSTR lpcwzSrc)
{
	INDEX_LIST::iterator it, itNext;
	int nNextFT;
	WCHAR *pwzFind;
	int cchProcessed, cwcSrcPos;

	if (m_pWordSink == NULL)
		return FALSE;

	// fill final index list
	for (int i = 0; i < m_cchTextProcessed; i++)
	{
		InsertFinalIndex(i);	
	}
	
	// put final index list
	for (it = m_listFinal.begin(); it != m_listFinal.end(); it++)
	{
		if (it->m_cchIndex == 0)
			continue;

		// get next FT
		itNext = it;
		itNext++;
		
		if (itNext == m_listFinal.end())
			nNextFT = -1;
		else
			nNextFT = itNext->m_nFT;

		pwzFind = wcsstr(lpcwzSrc, it->m_wzIndex);
		if (pwzFind == NULL)
			continue;
			
		cwcSrcPos = m_cwcSrcPos + (pwzFind - lpcwzSrc);
		cchProcessed = m_cchTextProcessed - (pwzFind - lpcwzSrc);

		if (it->m_nFT != nNextFT)
		{
			m_pWordSink->PutWord(it->m_cchIndex, it->m_wzIndex, 
							 	 it->m_cchIndex, cwcSrcPos);
		}
		else
		{
			m_pWordSink->PutAltWord(it->m_cchIndex, it->m_wzIndex, 
							 	    it->m_cchIndex, cwcSrcPos);
		}
	}
	
	return TRUE;
}

// CIndexList::SetRomajiInfo
//
// make final index list to put word
//
// Parameters:
//  pwzRomaji -> (WCHAR*) leading romaji string
//  cchRomaji -> (int) length of romaji string
//  cchPrefix -> (int) length of prefix (ex, http://)
//
// Result:
//  (void)
//
// 23NOV00  bhshin  began
void CIndexList::SetRomajiInfo(WCHAR *pwzRomaji, int cchRomaji, int cchPrefix)
{
	if (pwzRomaji == NULL)
	{
		m_wzRomaji[0] = L'\0';
		m_cchRomaji = 0;
		m_cchPrefix = 0;
	}
	else
	{
		wcscpy(m_wzRomaji, pwzRomaji); 
		m_cchRomaji = cchRomaji; 
		m_cchPrefix = cchPrefix; 
	}
}

// CIndexList::FindAndMergeIndexTerm
//
// find index term matching FT, LT
//
// Parameters:
//	itSrc -> (INDEX_LIST::iterator) index term to merge 
//	nFT   -> (int) FT position
//  nLT   -> (int) LT position
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 24NOV00  bhshin  began
BOOL CIndexList::FindAndMergeIndexTerm(INDEX_LIST::iterator itSrc, int nFT, 
int nLT)
{
	INDEX_LIST::iterator it;
	WCHAR wchIndex;
	int cchIndex;
	int nFTAdd, nLTAdd;
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	BOOL fFound = FALSE;

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		if (nFT != -1)
		{
			if (it->m_nFT != nFT)
				continue;
		}

		if (nLT != -1)
		{
			if (it->m_nLT != nLT)
				continue;
		}

		// found it

		// check [,] suffix case, then don't merge and just add itself
		if (it->m_nFT > 0 && it->m_cchIndex == 1)
		{
			wchIndex = it->m_wzIndex[0];
				
			if (wchIndex == 0xB4E4 || wchIndex == 0xBFD0)
			{
				WB_LOG_ADD_INDEX(itSrc->m_wzIndex, itSrc->m_cchIndex, INDEX_PARSE);
				continue;
			}
		}

		// check buffer size
		cchIndex = wcslen(it->m_wzIndex);
		if (cchIndex + 1 >= MAX_INDEX_STRING)
			continue;
			
		if (cchIndex == 0)
			continue;
			
		if (itSrc->m_nFT == 0)
		{
			wcscpy(wzIndex, itSrc->m_wzIndex);
			wcscat(wzIndex, it->m_wzIndex);

			nFTAdd = itSrc->m_nFT;
			nLTAdd = it->m_nLT;
		}
		else
		{
			wcscpy(wzIndex, it->m_wzIndex);
			wcscat(wzIndex, itSrc->m_wzIndex);

			nFTAdd = it->m_nFT;
			nLTAdd = itSrc->m_nLT;
		}

		fFound = TRUE;

		// check it dupliate index exist
		if (!IsExistIndex(wzIndex))
		{
			WB_LOG_ADD_INDEX(wzIndex, cchIndex+1, INDEX_PARSE);
				
			// add merged one
			CIndexTerm IndexTerm(wzIndex, 
			                     cchIndex+1, 
			                     it->m_fWeight,
			                     nFTAdd,
			                     nLTAdd); 		

			m_listIndex.push_back(IndexTerm);			
		}
	}

	return fFound;
}

// CIndexList::MakeSingleLengthMergedIndex
//
// make single length merged index term (MSN search)
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 30AUG00  bhshin  began
BOOL CIndexList::MakeSingleLengthMergedIndex()
{
	INDEX_LIST::iterator it;
	int nFT;
	WCHAR wchIndex;
	BOOL fFound;

	if (m_pWordSink == NULL)
		return FALSE;

	WB_LOG_ROOT_INDEX(L"", TRUE); // set root empty

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		if (it->m_cchIndex == 1)
		{
			WB_LOG_REMOVE_INDEX(it->m_wzIndex);			

			nFT = it->m_nFT;

			wchIndex = it->m_wzIndex[0];
			
			// check [,] suffix case, then just remove it
			if (nFT > 0 && (wchIndex == 0xB4E4 || wchIndex == 0xBFD0))
			{
				it->m_cchIndex = 0;
				it->m_wzIndex[0] = L'\0';
				it->m_nFT = -1;
				it->m_nLT = -1;
				continue;
			}
			
			// find conjoined term 
			// make merged term and put it
			fFound = FALSE;
			if (nFT == 0 && it->m_nLT != -1)
				fFound = FindAndMergeIndexTerm(it, it->m_nLT+1, -1);
			else
				fFound = FindAndMergeIndexTerm(it, -1, nFT-1);

			if (fFound)
			{
				// don't erase 'it'. 
				// instead, assign empty value
				it->m_cchIndex = 0;
				it->m_wzIndex[0] = L'\0';
				it->m_nFT = -1;
				it->m_nLT = -1;
			}
		}
	}

	return TRUE;
}

// CIndexList::MakeSeqIndexList
//
// make final sequence index list
//
// Parameters:
//	nFT        -> (int) matching FT pos
//	plistFinal -> (INDEX_LIST*) previous sequence list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 13NOV00  bhshin  began
BOOL CIndexList::MakeSeqIndexList(int nFT/*=0*/, INDEX_LIST *plistFinal/*=NULL*/)
{
	INDEX_LIST::iterator it;
	BOOL fFound = FALSE;

	for (it = m_listIndex.begin(); it != m_listIndex.end(); it++)
	{
		INDEX_LIST listTemp;
		
		if (it->m_cchIndex == 0)
			continue;
		
		if (it->m_nFT != nFT)
			continue;

		fFound = TRUE;

		if (plistFinal != NULL)
			listTemp = *plistFinal;

		CIndexTerm IndexTerm(it->m_wzIndex, it->m_cchIndex, it->m_fWeight, it->m_nFT, it->m_nLT); 

		listTemp.insert(listTemp.end(), IndexTerm);

		if (it->m_nLT >= m_cchTextProcessed-1 || it->m_nLT == -1)
			m_listFinal.insert(m_listFinal.end(), listTemp.begin(), listTemp.end());
		else
			MakeSeqIndexList(it->m_nLT+1, &listTemp);
	}

	if (!fFound && plistFinal != NULL)
		m_listFinal.insert(m_listFinal.end(), plistFinal->begin(), plistFinal->end()
);

	return TRUE;
}

// CIndexList::PutQueryIndexList
//
// call IWordSink::PutWord with collected index terms for Query time
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 07APR00  bhshin  began
BOOL CIndexList::PutQueryIndexList()
{
	INDEX_LIST::iterator it;
	WCHAR *pwzIndex;
	int cchIndex;
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	
	int cPhrase = GetCount();

	if (m_pWordSink == NULL)
		return FALSE;

	// put query index terms
	for (it = m_listFinal.begin(); it != m_listFinal.end(); it++)
	{
		if (it->m_nFT == 0 && cPhrase > 1)
			m_pWordSink->StartAltPhrase();

		cchIndex = 0;
		pwzIndex = it->m_wzIndex;
		while (*pwzIndex != L'\0')
		{
			if (*pwzIndex == L'\t')
			{
				if (cchIndex > 0)
				{
					wzIndex[cchIndex] = L'\0';
	
					m_pWordSink->PutWord(cchIndex, wzIndex, 
							 	 		 m_cchTextProcessed, m_cwcSrcPos);

					cchIndex = 0;
				}
			}
			else
			{
				wzIndex[cchIndex++] = *pwzIndex;
			}

			pwzIndex++;
		}
			
		if (cchIndex > 0)
		{
			wzIndex[cchIndex] = L'\0';
	
			m_pWordSink->PutWord(cchIndex, wzIndex, 
							 	 m_cchTextProcessed, m_cwcSrcPos);
		}
	}

	if (cPhrase > 1)
		m_pWordSink->EndAltPhrase();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\indexlist.h ===
// IndexList.h
//
// final index term list
// 
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  7 APR 2000	  bhshin	created

#ifndef _INDEX_LIST_H
#define _INDEX_LIST_H

#pragma warning(disable:4786)
#include <list>

using namespace std;

class CIndexTerm
{
// member data
public:
	WCHAR m_wzIndex[MAX_INDEX_STRING+1]; // index string
	int   m_cchIndex; // length of index string
	float m_fWeight;  // weight of index term 
	int   m_nFT;	  // first position of original input
	int   m_nLT;	  // last position of original input

// constructor
public:
	CIndexTerm()
	{
		m_wzIndex[0] = L'\0';
		m_cchIndex = 0;
		m_fWeight = 0;
		m_nFT = 0;
		m_nLT = 0;
	}

	CIndexTerm(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT)
	{
		if (pwzIndex != NULL && cchIndex <= MAX_INDEX_STRING)
		{
			wcsncpy(m_wzIndex, pwzIndex, cchIndex);
			m_wzIndex[cchIndex] = L'\0';
		}
		else
		{
			m_wzIndex[0] = L'\0';
			cchIndex = 0;
		}

		m_nFT = nFT;
		m_nLT = nLT;
		m_cchIndex = cchIndex;
		m_fWeight = fWeight;
	}
};

// type definition of index term VECTOR container
typedef list<CIndexTerm> INDEX_LIST;

class CIndexList
{
// member data
public:
	INDEX_LIST	 m_listIndex;
	int			 m_cchTextProcessed;
	int			 m_cwcSrcPos;
	IWordSink	*m_pWordSink; 
	IPhraseSink	*m_pPhraseSink;

	INDEX_LIST	 m_listFinal; 	// final index list for PutWord
	
	WCHAR		 m_wzRomaji[MAX_INDEX_STRING+1];
	int			 m_cchRomaji;
	int			 m_cchPrefix;

	BOOL		 m_fAddRomaji;

// constructor
public:
	CIndexList()
	{
		m_cchTextProcessed = 0;
		m_cwcSrcPos = 0;
		m_pWordSink = NULL;
		m_pPhraseSink = NULL;

		m_wzRomaji[0] = L'\0';
		m_cchRomaji = 0;
		m_cchPrefix = 0;

		m_fAddRomaji = FALSE;
	}

	CIndexList(int cchTextProcessed, int cwcSrcPos, IWordSink *pWordSink, IPhraseSink *pPhraseSink)
	{
		m_cchTextProcessed = cchTextProcessed;
		m_cwcSrcPos = cwcSrcPos;
		m_pWordSink = pWordSink;
		m_pPhraseSink = pPhraseSink;

		m_wzRomaji[0] = L'\0';
		m_cchRomaji = 0;
		m_cchPrefix = 0;

		m_fAddRomaji = FALSE;
	}

// attribute
public:
	int GetCount(void) { return m_listIndex.size(); }
	BOOL IsEmpty(void) { return m_listIndex.empty(); }

	void SetRomajiInfo(WCHAR *pwzRomaji, int cchRomaji, int cchPrefix);

// operator
public:
	BOOL IsExistIndex(const WCHAR *pwzIndex);
	void AddIndex(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT);
	BOOL PutIndexList();
	BOOL MakeAndPutSymbolIndex(const WCHAR *pwzLeading, int nFT = 0);

	BOOL InsertFinalIndex(int nFT);
	BOOL PutFinalIndexList(LPCWSTR lpcwzSrc);

	BOOL FindAndMergeIndexTerm(INDEX_LIST::iterator itSrc, int nFT, int nLT);
	BOOL MakeSingleLengthMergedIndex();
	BOOL MakeSeqIndexList(int nFT=0, INDEX_LIST *plistFinal=NULL);

	BOOL MakeQueryIndexList();
	BOOL PutQueryIndexList();
};


#endif // #ifndef _INDEX_LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\indexrec.cpp ===
// IndexRec.cpp
//
// final index record & lists
// 
// Copyright 2001 Microsoft Corp.
//
// Modification History:
//  19 MAR 2001	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IndexRec.h"
#include "Morpho.h"

// the number of records (in prgIndexRec) that we should allocate in a clump.
// this is used whenever we need to re-alloc the array
#define RECORD_CLUMP_SIZE   100

//======================================================
// CRecList
//======================================================

// CRecList::CRecList
//
// constructor
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 20MAR01  bhshin  began
CRecList::CRecList()
{
	m_prgnRecID = NULL; 
	m_nMaxRec = 0; 
	m_nCurrRec = MIN_RECORD; 
}

// CRecList::~CRecList
//
// destructor
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 20MAR01  bhshin  began
CRecList::~CRecList()
{
	Uninitialize(); 
}

// CRecList::Initialize
//
// initialize CRecList
//
// Parameters:
//  (NONE)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CRecList::Initialize(void)
{
	m_nCurrRec = MIN_RECORD; 

    // allocate new IndexRec
    if (m_prgnRecID == NULL)
    {
        m_nMaxRec = RECORD_CLUMP_SIZE;
        m_prgnRecID = (int*)malloc(m_nMaxRec * sizeof(int));
        if (m_prgnRecID == NULL)
        {
            m_nMaxRec = 0;
            return FALSE;
        }
    }

	return TRUE;
}

// CRecList::Uninitialize
//
// unitialize CRecList
//
// Parameters:
//  (NONE)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
void CRecList::Uninitialize(void)
{
    // free IndexRec
    if (m_prgnRecID != NULL)
    {
		free(m_prgnRecID);
		m_prgnRecID = NULL;
    }

	m_nMaxRec = 0; 
	m_nCurrRec = MIN_RECORD; 
}

// CRecList::AddRec
//
// add record id
//
// Parameters:
//  nRecID -> (int) record id
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CRecList::AddRec(int nRecID)
{
	int *prgnRecID;
	int nMaxRec;

	if (m_prgnRecID == NULL)
		return FALSE;

	// make sure if there is enough room for new record (maximum 3 records can be added)
	if (m_nMaxRec <= m_nCurrRec)
	{
        nMaxRec = m_nMaxRec + RECORD_CLUMP_SIZE;
        
        prgnRecID = (int*)realloc(m_prgnRecID, nMaxRec * sizeof(int));
        if (prgnRecID == NULL)
            return FALSE;

		m_nMaxRec = nMaxRec;
        m_prgnRecID = prgnRecID;
	}

	m_prgnRecID[m_nCurrRec] = nRecID;
	m_nCurrRec++;

	return TRUE;
}

// CRecList::operator =
//
// assign operator
//
// Parameters:
//  objRecList -> (CRecList&)
//
// Result:
//  (CRecList&)
//
// 20MAR01  bhshin  began
CRecList& CRecList::operator = (CRecList& objRecList)
{
	int nRecord, nRecID;

	// re-initialize this
	Uninitialize();
	if (!Initialize())
		throw 0;
	
	for (nRecord = MIN_RECORD; nRecord < objRecList.m_nCurrRec; nRecord++)
	{
		nRecID = objRecList.m_prgnRecID[nRecord];
		if (!AddRec(nRecID))
			throw 0;
	}

	return *this;
}

// CRecList::operator +=
//
// unary sum operator
//
// Parameters:
//  objRecList -> (CRecList&)
//
// Result:
//  (CRecList&)
//
// 20MAR01  bhshin  began
CRecList& CRecList::operator += (CRecList& objRecList)
{
	int nRecord, nRecID;
	
	for (nRecord = MIN_RECORD; nRecord < objRecList.m_nCurrRec; nRecord++)
	{
		nRecID = objRecList.m_prgnRecID[nRecord];
		if (!AddRec(nRecID))
			throw 0;
	}

	return *this;
}


//======================================================
// CIndexInfo
//======================================================

// CIndexInfo::CIndexInfo
//
// default constructor of CIndexRec
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 19MAR01  bhshin  began
CIndexInfo::CIndexInfo()
{
	m_prgIndexRec = NULL;
	m_nMaxRec = 0;
	m_nCurrRec = MIN_RECORD;

	m_cchTextProcessed = 0;
	m_cwcSrcPos = 0;
	m_pWordSink = NULL; 
	m_pPhraseSink = NULL;

	m_wzRomaji[0] = L'\0';
	m_cchRomaji = 0;
	m_cchPrefix = 0;
	m_fAddRomaji = FALSE;

	m_nFinalHead = 0;
}

// CIndexInfo::~CIndexInfo
//
// destructor of CIndexRec
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 19MAR01  bhshin  began
CIndexInfo::~CIndexInfo()
{
	Uninitialize();
}

// CIndexInfo::IsExistIndex
//
// check if index term already exist.
//
// Parameters:
//  pwzIndex	-> (const WCHAR*) index string
//
// Result:
//  (BOOL)
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::IsExistIndex(const WCHAR *pwzIndex)
{
	for (int i = MIN_RECORD; i < m_nCurrRec; i++)
	{
		// found duplicate index term
		if (wcscmp(m_prgIndexRec[i].wzIndex, pwzIndex) == 0)
			return TRUE;
	}

	return FALSE;
}

// CIndexInfo::SetRomajiInfo
//
// make final index list to put word
//
// Parameters:
//  pwzRomaji -> (WCHAR*) leading romaji string
//  cchRomaji -> (int) length of romaji string
//  cchPrefix -> (int) length of prefix (ex, http://)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::SetRomajiInfo(WCHAR *pwzRomaji, int cchRomaji, int cchPrefix)
{
	if (pwzRomaji == NULL || cchRomaji > MAX_INDEX_STRING)
	{
		m_wzRomaji[0] = L'\0';
		m_cchRomaji = 0;
		m_cchPrefix = 0;

		return FALSE;
	}

	wcsncpy(m_wzRomaji, pwzRomaji, cchRomaji);
	m_wzRomaji[cchRomaji] = L'\0';
	m_cchRomaji = cchRomaji; 
	m_cchPrefix = cchPrefix; 

	return TRUE;
}

// CIndexInfo::Initialize
//
// initialize all the members of CIndexRec
//
// Parameters:
//  cchTextProcessed -> (int) length of text processed
//  cwcSrcPos       -> (int) position value of source string
//  pWordSink       -> (IWordSink) IWordSink for PutWord/PutAltWord
//  pPhraseSink      -> (IPhraseSink) IPhraseSink for PutWord/PutAltWord
//
// Result:
//  (BOOL) TRUE if it succeeds to initialize
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::Initialize(int cchTextProcessed, int cwcSrcPos, IWordSink *pWordSink, IPhraseSink *pPhraseSink)
{
	// parameter validations
	if (cchTextProcessed <= 0 || cwcSrcPos < 0)
		return FALSE;

	if (pWordSink == NULL)
		return FALSE;

    // allocate new IndexRec
    if (m_prgIndexRec == NULL)
    {
        m_nMaxRec = RECORD_CLUMP_SIZE;
        m_prgIndexRec = (INDEX_REC*)malloc(m_nMaxRec * sizeof(INDEX_REC));
        if (m_prgIndexRec == NULL)
        {
            m_nMaxRec = 0;
            return FALSE;
        }
    }

	m_cchTextProcessed = cchTextProcessed;
	m_cwcSrcPos = cwcSrcPos;
	m_pWordSink = pWordSink;
	m_pPhraseSink = pPhraseSink;

	return TRUE;
}

// CIndexInfo::Uninitialize
//
// initialize all the members of CIndexRec
//
// Parameters:
//  (NONE)
//
// Result:
//  (NONE)
//
// 19MAR01  bhshin  began
void CIndexInfo::Uninitialize()
{
    // free IndexRec
    if (m_prgIndexRec != NULL)
    {
		free(m_prgIndexRec);
		m_prgIndexRec = NULL;
    }

	m_nMaxRec = 0;
	m_nCurrRec = 0;

	m_cchTextProcessed = 0;
	m_cwcSrcPos = 0;
	m_pWordSink = NULL; 
	m_pPhraseSink = NULL;

	m_wzRomaji[0] = L'\0';
	m_cchRomaji = 0;
	m_cchPrefix = 0;
	m_fAddRomaji = FALSE;

	m_nFinalHead = 0;
}


// CIndexInfo::AddIndex
//
// add index term information 
//
// Parameters:
//  pwzIndex	-> (const WCHAR*) index string
//  cchIndex    -> (int) length of index string
//  nFT         -> (int) first position of original input
//	nLT			-> (int) last position of original input
//  fWeight      -> (float) weight value of index record
//
// Result:
//  (BOOL)
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::AddIndex(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT)
{
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	int nMaxRec, nNewRec;
	INDEX_REC *prgIndexRec;
	int nLTAdd;

	// parameter validation
	if (pwzIndex == 0 || cchIndex <= 0) 
		return FALSE;

	if (nFT < 0 || nLT < 0 || fWeight < 0)
		return FALSE;

	if ((m_cchRomaji + cchIndex) > MAX_INDEX_STRING)
		return FALSE;
	
	// make sure if there is enough room for new record (maximum 3 records can be added)
	if (m_nMaxRec <= m_nCurrRec + 3)
	{
        nMaxRec = m_nMaxRec + RECORD_CLUMP_SIZE;
        
        prgIndexRec = (INDEX_REC*)realloc(m_prgIndexRec, nMaxRec * sizeof(INDEX_REC));
        if (prgIndexRec == NULL)
            return FALSE;

		m_nMaxRec = nMaxRec;
        m_prgIndexRec = prgIndexRec;
	}

	// set up index string and correct LT value
	wcsncpy(wzIndex, pwzIndex, cchIndex);
	wzIndex[cchIndex] = L'\0';

	nLTAdd = nLT;
	if (nLT >= 0 && m_cchRomaji > 0)
		nLTAdd += m_cchRomaji;

	// if added record is leading one and there is just length one romaji, 
	// then conjoin leading romaji & leading index string, and add merged term
	if (nFT == 0 && m_cchRomaji == 1)
	{
		WCHAR wzMerge[MAX_INDEX_STRING+1];

		wcscpy(wzMerge, m_wzRomaji);
		wcscat(wzMerge, wzIndex);

		if (!IsExistIndex(wzMerge))
		{
			// add index term
			nNewRec = m_nCurrRec;
			m_nCurrRec++;
		
			wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzMerge);
			m_prgIndexRec[nNewRec].cchIndex = cchIndex + m_cchRomaji;
			m_prgIndexRec[nNewRec].nFT = nFT;
			m_prgIndexRec[nNewRec].nLT = nLTAdd;
			m_prgIndexRec[nNewRec].fWeight = fWeight;
			m_prgIndexRec[nNewRec].nNext = 0;
		
			WB_LOG_ADD_INDEX(wzMerge, cchIndex + m_cchRomaji, INDEX_SYMBOL);

			ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
		}

		// add index term removing prefix
		if (m_cchPrefix > 0)
		{
			// add index term
			if (!IsExistIndex(wzMerge + m_cchPrefix))
			{
				nNewRec = m_nCurrRec;
				m_nCurrRec++;

				wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzMerge + m_cchPrefix);
				m_prgIndexRec[nNewRec].cchIndex = cchIndex + m_cchRomaji - m_cchPrefix;
				m_prgIndexRec[nNewRec].nFT = nFT + m_cchPrefix;
				m_prgIndexRec[nNewRec].nLT = nLTAdd;
				m_prgIndexRec[nNewRec].fWeight = fWeight;
				m_prgIndexRec[nNewRec].nNext = 0;

				WB_LOG_ADD_INDEX(wzMerge + m_cchPrefix, cchIndex + m_cchRomaji - m_cchPrefix, INDEX_SYMBOL);

				ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
			}
		}
	}
	else
	{
		if (!IsExistIndex(wzIndex))
		{

			// add index term
			nNewRec = m_nCurrRec;
			m_nCurrRec++;

			wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzIndex);
			m_prgIndexRec[nNewRec].cchIndex = cchIndex;
			m_prgIndexRec[nNewRec].nFT = nFT + m_cchRomaji;
			m_prgIndexRec[nNewRec].nLT = nLTAdd;
			m_prgIndexRec[nNewRec].fWeight = fWeight;
			m_prgIndexRec[nNewRec].nNext = 0;

			ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
		}
		
		// if there is a romaji and it has not added yet, then add it just one time
		if (m_cchRomaji > 1 && m_fAddRomaji == FALSE)
		{
			if (!IsExistIndex(m_wzRomaji))
			{
				// add index term
				nNewRec = m_nCurrRec;
				m_nCurrRec++;

				wcscpy(m_prgIndexRec[nNewRec].wzIndex, m_wzRomaji);
				m_prgIndexRec[nNewRec].cchIndex = m_cchRomaji;
				m_prgIndexRec[nNewRec].nFT = 0;
				m_prgIndexRec[nNewRec].nLT = m_cchRomaji - 1;
				m_prgIndexRec[nNewRec].fWeight = WEIGHT_HARD_MATCH;
				m_prgIndexRec[nNewRec].nNext = 0;

				WB_LOG_ADD_INDEX(m_wzRomaji, m_cchRomaji, INDEX_SYMBOL);

				ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
			}
			
			// if there is a prefix, then add index term removing the prefix
			if (m_cchPrefix > 0)
			{
				if (!IsExistIndex(m_wzRomaji + m_cchPrefix))
				{
					// add index term
					nNewRec = m_nCurrRec;
					m_nCurrRec++;

					wcscpy(m_prgIndexRec[nNewRec].wzIndex, m_wzRomaji + m_cchPrefix);
					m_prgIndexRec[nNewRec].cchIndex = m_cchRomaji - m_cchPrefix;
					m_prgIndexRec[nNewRec].nFT = m_cchPrefix;
					m_prgIndexRec[nNewRec].nLT = m_cchRomaji-m_cchPrefix-1;
					m_prgIndexRec[nNewRec].fWeight = WEIGHT_HARD_MATCH;
					m_prgIndexRec[nNewRec].nNext = 0;

					WB_LOG_ADD_INDEX(m_wzRomaji + m_cchPrefix, m_cchRomaji - m_cchPrefix, INDEX_SYMBOL);

					ATLASSERT(m_prgIndexRec[nNewRec].nFT <= m_prgIndexRec[nNewRec].nLT);
				}
			}

			m_fAddRomaji = TRUE;
		}
	}

	return TRUE;
}

// CIndexInfo::FindAndMergeIndexTerm
//
// find index term matching FT, LT
//
// Parameters:
//	pIndexSrc -> (INDEX_REC *) index term to merge 
//	nFT   -> (int) FT position, -1 means don't care
//  nLT   -> (int) LT position, -1 means don't care
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::FindAndMergeIndexTerm(INDEX_REC *pIndexSrc, int nFT, int nLT)
{
	INDEX_REC *pIndexRec;
	WCHAR wchIndex;
	int cchIndex;
	int nFTAdd, nLTAdd;
	int nNewRec;
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	BOOL fFound = FALSE;

	if (pIndexSrc == NULL)
		return FALSE;

	if (nFT < 0 && nLT < 0)
		return FALSE;

	for (int i = MIN_RECORD; i < m_nCurrRec; i++)
	{
		pIndexRec = &m_prgIndexRec[i];

		if (pIndexRec->cchIndex == 0)
			continue;

		if (nFT != -1 && pIndexRec->nFT != nFT)
			continue;

		if (nLT != -1 && pIndexRec->nLT != nLT)
			continue;

		// found it

		// check [,] suffix case, then don't merge and just add itself
		if (pIndexRec->nFT > 0 && pIndexRec->cchIndex == 1)
		{
			wchIndex = pIndexRec->wzIndex[0];
			if (wchIndex == 0xB4E4 || wchIndex == 0xBFD0)
				continue;
		}

		// check buffer size
		cchIndex = wcslen(pIndexRec->wzIndex);
		if (cchIndex == 0 || cchIndex + 1 >= MAX_INDEX_STRING)
			continue;
			
		if (pIndexSrc->nFT == 0)
		{
			wcscpy(wzIndex, pIndexSrc->wzIndex);
			wcscat(wzIndex, pIndexRec->wzIndex);

			nFTAdd = pIndexSrc->nFT;
			nLTAdd = pIndexRec->nLT;
		}
		else
		{
			wcscpy(wzIndex, pIndexRec->wzIndex);
			wcscat(wzIndex, pIndexSrc->wzIndex);

			nFTAdd = pIndexRec->nFT;
			nLTAdd = pIndexSrc->nLT;
		}

		fFound = TRUE;

		// check it dupliate index exist
		if (!IsExistIndex(wzIndex))
		{
			WB_LOG_ADD_INDEX(wzIndex, cchIndex+1, INDEX_PARSE);
				
			// add merged one
			nNewRec = m_nCurrRec;
			m_nCurrRec++;

			wcscpy(m_prgIndexRec[nNewRec].wzIndex, wzIndex);
			m_prgIndexRec[nNewRec].cchIndex = cchIndex+1;
			m_prgIndexRec[nNewRec].nFT = nFTAdd;
			m_prgIndexRec[nNewRec].nLT = nLTAdd;
			m_prgIndexRec[nNewRec].fWeight = pIndexSrc->fWeight;
			m_prgIndexRec[nNewRec].nNext = 0;
		}
	}

	return fFound;
}

// CIndexInfo::MakeSingleLengthMergedIndex
//
// make single length merged index term (MSN search)
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::MakeSingleLengthMergedIndex()
{
	INDEX_REC *pIndexRec;
	int nFT;
	WCHAR wchIndex;
	BOOL fFound;

	if (m_pWordSink == NULL)
		return FALSE;

	WB_LOG_ROOT_INDEX(L"", TRUE); // set root empty

	for (int i = MIN_RECORD; i < m_nCurrRec; i++)
	{
		pIndexRec = &m_prgIndexRec[i];

		if (pIndexRec->cchIndex == 1)
		{
			WB_LOG_REMOVE_INDEX(pIndexRec->wzIndex);			

			nFT = pIndexRec->nFT;

			wchIndex = pIndexRec->wzIndex[0];
			
			// check [,] suffix case, then just remove it
			if ((wchIndex == 0xB4E4 || wchIndex == 0xBFD0) && nFT > 0)
			{
				// make it empty
				pIndexRec->cchIndex = 0;
				pIndexRec->wzIndex[0] = L'\0';
				pIndexRec->nFT = 0;
				pIndexRec->nLT = 0;
				pIndexRec->nNext = 0;

				continue;
			}
			
			// find conjoined term and make merged term and put it
			fFound = FALSE;
			
			if (nFT == 0 && pIndexRec->nLT != -1)
				fFound = FindAndMergeIndexTerm(pIndexRec, pIndexRec->nLT + 1, -1);
			else
				fFound = FindAndMergeIndexTerm(pIndexRec, -1, nFT-1);

			if (fFound)
			{
				// make it empty
				pIndexRec->cchIndex = 0;
				pIndexRec->wzIndex[0] = L'\0';
				pIndexRec->nFT = 0;
				pIndexRec->nLT = 0;
				pIndexRec->nNext = 0;

				continue;
			}
		}
	}

	return TRUE;
}

// CIndexInfo::InsertFinalIndex
//
// search index term starting with given FT and insert it to final list
//
// Parameters:
//  nFT  -> (int) first pos of index term
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::InsertFinalIndex(int nFT)
{
	INDEX_REC *pIndexRec;
	int cchIndex, nCurr, nPrev;
	BOOL fInsert;

	for (int nRecord = MIN_RECORD; nRecord < m_nCurrRec; nRecord++)
	{
		pIndexRec = &m_prgIndexRec[nRecord];

		cchIndex = pIndexRec->cchIndex;
		if (cchIndex == 0)
			continue; // skip removed entry

		if (pIndexRec->nFT != nFT)
			continue; // FT match index found
		
		// search inserting position. final list ordered by increamental length.
		nCurr = m_nFinalHead;
		nPrev = -1;
		fInsert = FALSE;
		while (!fInsert)
		{
			if (nCurr != 0) 
			{
				if (m_prgIndexRec[nCurr].nFT != nFT || cchIndex > m_prgIndexRec[nCurr].cchIndex)
				{
					nPrev = nCurr;
					nCurr = m_prgIndexRec[nCurr].nNext;
					continue;
				}
			}		

			// insert it
			if (nPrev == -1)
			{
				pIndexRec->nNext = m_nFinalHead;
				m_nFinalHead = nRecord;
			}
			else
			{
				pIndexRec->nNext = m_prgIndexRec[nPrev].nNext;
				m_prgIndexRec[nPrev].nNext = nRecord;
			}

			fInsert = TRUE;
		}
	}
	
	return TRUE;
}

// CIndexInfo::PutFinalIndexList
//
// put word final index list (index time)
//
// Parameters:
//  lpcwzSrc -> (LPCWSTR) source string to get source pos
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 19MAR01  bhshin  began
BOOL CIndexInfo::PutFinalIndexList(LPCWSTR lpcwzSrc)
{
	int nCurr, nNext;
	int nNextFT;
	WCHAR *pwzFind;
	int cchProcessed, cwcSrcPos;
	INDEX_REC *pIndexRec;

	if (m_pWordSink == NULL)
		return FALSE;

	// fill final index list
	for (int i = 0; i < m_cchTextProcessed; i++)
	{
		InsertFinalIndex(i);	
	}
	
	// put final index list
	nCurr = m_nFinalHead;
	while (nCurr != 0)
	{
		ATLASSERT(nCurr < m_nCurrRec);

		pIndexRec = &m_prgIndexRec[nCurr];

		// skip removed record
		if (pIndexRec->cchIndex == 0)
			continue; 

		// check if index term has substring or not
		pwzFind = wcsstr(lpcwzSrc, pIndexRec->wzIndex);
		if (pwzFind == NULL)
			continue;
			
		cwcSrcPos = m_cwcSrcPos + (int)(pwzFind - lpcwzSrc);
		cchProcessed = m_cchTextProcessed - (int)(pwzFind - lpcwzSrc);

		// get next FT
		nNext = pIndexRec->nNext;
		if (nNext == 0)
			nNextFT = -1;
		else
			nNextFT = m_prgIndexRec[nNext].nFT;

		if (pIndexRec->nFT != nNextFT)
		{
			m_pWordSink->PutWord(pIndexRec->cchIndex, pIndexRec->wzIndex, 
							 	 pIndexRec->cchIndex, cwcSrcPos);
		}
		else
		{
			m_pWordSink->PutAltWord(pIndexRec->cchIndex, pIndexRec->wzIndex, 
							 	    pIndexRec->cchIndex, cwcSrcPos);
		}

		nCurr = pIndexRec->nNext;
	}
	
	return TRUE;
}


// CIndexInfo::MakeSeqIndexList
//
// make final sequence index list
//
// Parameters:
//	nFT        -> (int) matching FT pos
//	plistFinal    -> (CRecList*) previous sequence list
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CIndexInfo::MakeSeqIndexList(int nFT/*=0*/, CRecList *plistFinal/*=NULL*/)
{
	int nRecord;
	INDEX_REC *pIndexRec;
	BOOL fFound = FALSE;

	for (nRecord = MIN_RECORD; nRecord < m_nCurrRec; nRecord++)
	{
		CRecList listTemp;

		pIndexRec = &m_prgIndexRec[nRecord];

		// skip removed entry & skip not FT matching entry
		if (pIndexRec->cchIndex != 0 && pIndexRec->nFT == nFT)
		{
			fFound = TRUE;

			try
			{
				if (pIndexRec->nLT >= m_cchTextProcessed-1)
				{
					if (plistFinal == NULL)
					{
						m_FinalRecList.AddRec(nRecord);
					}
					else
					{
						listTemp = *plistFinal;

						if (!listTemp.AddRec(nRecord))
							return FALSE;

						m_FinalRecList += listTemp;
					}
				}
				else
				{
					if (plistFinal == NULL)
					{
						if (!listTemp.Initialize())
							return FALSE;
					}
					else
					{
						listTemp = *plistFinal;
					}

					if (!listTemp.AddRec(nRecord))
						return FALSE;

					if (!MakeSeqIndexList(pIndexRec->nLT + 1, &listTemp))
						return FALSE;
				}
			}
			catch (...)
			{
				return FALSE;
			}
		}
	}

	if (!fFound && plistFinal != NULL)
	{
		try
		{
			m_FinalRecList += *plistFinal;
		}
		catch(...)
		{
			return FALSE;
		}
	}

	return TRUE;
}


// CIndexInfo::PutQueryIndexList
//
// call IWordSink::PutWord with collected index terms for Query time
//
// Parameters:
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 20MAR01  bhshin  began
BOOL CIndexInfo::PutQueryIndexList()
{
	int nRecordID;
	INDEX_REC *pIndexRec;
	WCHAR *pwzIndex;
	int cchIndex;
	WCHAR wzIndex[MAX_INDEX_STRING+1];
	
	if (m_pWordSink == NULL)
		return FALSE;

	if (!m_FinalRecList.Initialize())
		return FALSE;

	if (!MakeSeqIndexList())
		return FALSE;
	
	// put query index terms
	for (int i = MIN_RECORD; i < m_FinalRecList.m_nCurrRec; i++)
	{
		nRecordID = m_FinalRecList.m_prgnRecID[i];

		if (nRecordID < MIN_RECORD || nRecordID >= m_nCurrRec)
			return FALSE; // invalid record id

		pIndexRec = &m_prgIndexRec[nRecordID];

		if (pIndexRec->nFT == 0 && m_nCurrRec > MIN_RECORD+1)
			m_pWordSink->StartAltPhrase();

		cchIndex = 0;
		pwzIndex = pIndexRec->wzIndex;
		while (*pwzIndex != L'\0')
		{
			if (*pwzIndex == L'\t')
			{
				if (cchIndex > 0)
				{
					wzIndex[cchIndex] = L'\0';
					m_pWordSink->PutWord(cchIndex, wzIndex, 
							 	 		 m_cchTextProcessed, m_cwcSrcPos);

					cchIndex = 0;
				}
			}
			else
			{
				wzIndex[cchIndex++] = *pwzIndex;
			}

			pwzIndex++;
		}
			
		if (cchIndex > 0)
		{
			wzIndex[cchIndex] = L'\0';
			m_pWordSink->PutWord(cchIndex, wzIndex, 
							 	 m_cchTextProcessed, m_cwcSrcPos);
		}
	}

	if (m_nCurrRec > MIN_RECORD+1)
		m_pWordSink->EndAltPhrase();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\istemmer.h ===
// IStemmer.h : Declaration of the CStemmer

#ifndef __STEMMER_H_
#define __STEMMER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStemmer
class ATL_NO_VTABLE CStemmer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStemmer, &CLSID_Stemmer>,
	public IStemmer
{
public:
	CStemmer()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STEMMER)
DECLARE_NOT_AGGREGATABLE(CStemmer)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CStemmer)
	COM_INTERFACE_ENTRY(IStemmer)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IStemmer
public:
	STDMETHOD(GetLicenseToUse)(/*[out]*/ const WCHAR ** ppwcsLicense);
	STDMETHOD(StemWord)(/*[in]*/ WCHAR const * pwcInBuf, /*[in]*/ ULONG cwc, /*[in]*/ IStemSink * pStemSink);
	STDMETHOD(Init)(/*[in]*/ ULONG ulMaxTokenSize, /*[out]*/ BOOL *pfLicense);
};

#endif //__STEMMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\iwbreak.h ===
// IWBreak.h
//
// CWordBreak declaration
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  12 APR 2000   bhshin    added WordBreak operator
//  30 MAR 2000	  bhshin	created

#ifndef __WORDBREAKER_H_
#define __WORDBREAKER_H_

#include "resource.h"       // main symbols
extern "C"
{
#include "ctplus.h"			// WT
}

class CIndexInfo;
/////////////////////////////////////////////////////////////////////////////
// CWordBreaker

class ATL_NO_VTABLE CWordBreaker : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWordBreaker, &CLSID_WordBreaker>,
	public IWordBreaker
{
public:
	CWordBreaker()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WORDBREAKER)
DECLARE_NOT_AGGREGATABLE(CWordBreaker)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CWordBreaker)
	COM_INTERFACE_ENTRY(IWordBreaker)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IWordBreaker
public:
	STDMETHOD(GetLicenseToUse)(/*[out]*/ const WCHAR ** ppwcsLicense);
	STDMETHOD(ComposePhrase)(/*[in]*/ const WCHAR *pwcNoun, /*[in]*/ ULONG cwcNoun, /*[in]*/ const WCHAR *pwcModifier, /*[in]*/ ULONG cwcModifier, /*[in]*/ ULONG ulAttachmentType, /*[out]*/ WCHAR *pwcPhrase, /*[out]*/ ULONG *pcwcPhrase );
	STDMETHOD(BreakText)(/*[in]*/ TEXT_SOURCE *pTextSource, /*[in]*/ IWordSink *pWordSink, /*[in]*/ IPhraseSink *pPhraseSink);
	STDMETHOD(Init)(/*[in]*/ BOOL fQuery, /*[in]*/ ULONG ulMaxTokenSize, /*[out]*/ BOOL *pfLicense);

// Operator
public:
	int WordBreak(TEXT_SOURCE *pTextSource, WT Type, 
		          int cchTextProcessed, int cchHanguel,
		          IWordSink *pWordSink, IPhraseSink *pPhraseSink,
				  WCHAR *pwchLast);

	void AnalyzeRomaji(const WCHAR *pwcStem, int cchStem,
					   int iCur, int cchProcessed, int cchHanguel,
					   CIndexInfo *pIndexInfo, int *pcchPrefix);
						  
// Member data
protected:
	PARSE_INFO	m_PI;
	BOOL		m_fQuery;
	ULONG		m_ulMaxTokenSize;
};

#endif //__WORDBREAKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\iwbreak.cpp ===
// IWBreak.cpp
//
// CWordBreak implementation
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  18 APR 2000   bhshin    added WordBreak destructor
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IWBreak.h"
#include "Lex.h"
#include "Token.h"
#include "Record.h"
#include "Analyze.h"
#include "IndexRec.h"
#include "unikor.h"
#include "Morpho.h"

extern CRITICAL_SECTION g_CritSect;
extern MAPFILE g_LexMap;
extern BOOL g_fLoaded;

/////////////////////////////////////////////////////////////////////////////
// CWordBreaker member functions

// CWordBreaker::Init
//
// intialize WordBreaker object & lexicon
//
// Parameters:
//  fQuery			-> (BOOL) query time flag
//  ulMaxTokenSize  -> (ULONG) maximum input token length
//  *pfLicense		<- (BOOL*) always return TRUE
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::Init(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense)
{
	if (pfLicense == NULL)
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD)))
        return E_INVALIDARG;

	// store intitializing information
	m_fQuery = fQuery;
	m_ulMaxTokenSize = ulMaxTokenSize;

    *pfLicense = TRUE;

	if (!g_fLoaded)
	{
		// load lexicon file
		ATLTRACE(L"Load lexicon...\r\n");

		if (!InitLexicon(&g_LexMap))
			return LANGUAGE_E_DATABASE_NOT_FOUND;

		g_fLoaded = TRUE;
	}

	m_PI.lexicon = g_LexMap;

	WB_LOG_PRINT_HEADER(fQuery);

	return S_OK;
}

// CWordBreaker::BreakText
//
// main word breaking method
//
// Parameters:
//  pTextSource		-> (TEXT_SOURCE*) pointer to the structure of source text
//  pWordSink		-> (IWordSink*) pointer to the word sink
//  pPhraseSink     -> (IPhraseSink*) pointer to the phrase sink
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::BreakText(TEXT_SOURCE *pTextSource, IWordSink *pWordSink, IPhraseSink *pPhraseSink)
{
	WT Type;
	int cchTextProcessed, cchProcessed, cchHanguel;
	WCHAR wchLast = L'\0';

	if (pTextSource == NULL)
		return E_INVALIDARG;

	if (pWordSink == NULL)
		return S_OK;

	if (pTextSource->iCur == pTextSource->iEnd)
		return S_OK;

	ATLASSERT(pTextSource->iCur < pTextSource->iEnd);

    do
    {
        while (pTextSource->iCur < pTextSource->iEnd)
        {
			Tokenize(TRUE, pTextSource, pTextSource->iCur, &Type, &cchTextProcessed, &cchHanguel);

			if (Type == WT_REACHEND)
				break;

			cchProcessed = WordBreak(pTextSource, Type, cchTextProcessed, cchHanguel, pWordSink, pPhraseSink, &wchLast);
			if (cchProcessed < 0)
				return E_UNEXPECTED;

			pTextSource->iCur += cchProcessed;
		}

    } while (SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)));

    while ( pTextSource->iCur < pTextSource->iEnd )
	{
		Tokenize(FALSE, pTextSource, pTextSource->iCur, &Type, &cchTextProcessed, &cchHanguel);
       
		cchProcessed = WordBreak(pTextSource, Type, cchTextProcessed, cchHanguel, pWordSink, pPhraseSink, &wchLast);
		if (cchProcessed < 0)
			return E_UNEXPECTED;

		pTextSource->iCur += cchProcessed;
	}
	
	return S_OK;
}

// CWordBreaker::ComposePhrase
//
// convert a noun and modifier back into a source phrase (NOT USED)
//
// Parameters:
//  pwcNoun			 -> (const WCHAR*) input noun
//  cwcNoun			 -> (ULONG) length of input noun
//  pwcModifier      -> (const WCHAR *)  input modifier
//  cwcModifier		 -> (ULONG) length of input modifier
//  ulAttachmentType -> (ULONG) value about the method of composition
//  pwcPhrase        -> (WCHAR *) pointer to the returned buffer
//  pcwcPhrase		 -> (ULONG *) length of returned string
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::ComposePhrase(const WCHAR *pwcNoun, ULONG cwcNoun, const WCHAR *pwcModifier, ULONG cwcModifier, ULONG ulAttachmentType, WCHAR *pwcPhrase, ULONG *pcwcPhrase)
{
    if (m_fQuery)
        return E_NOTIMPL;
    
    return WBREAK_E_QUERY_ONLY;
}

// CWordBreaker::GetLicenseToUse
//
// return license information
//
// Parameters:
//  ppwcsLicense  -> (const WCHAR **) output pointer to the license information
//
// Result:
//  (HRESULT) 
//
// 30MAR00  bhshin  began
STDMETHODIMP CWordBreaker::GetLicenseToUse(const WCHAR ** ppwcsLicense)
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-2000";

    if (ppwcsLicense == NULL)  
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) 
        return E_INVALIDARG;

    *ppwcsLicense = wcsCopyright;
    
	return S_OK;
}

// CWordBreaker::WordBreak
//
// main hangul word breaking operator
//
// Parameters:
//  pTextSource		 -> (TEXT_SOURCE*) pointer to the structure of source text
//  Type			 -> (WT) word token type
//  cchTextProcessed -> (int) input length to process
//  cchHanguel       -> (int) hangul token length (hanguel+romaji case only)
//  pWordSink		 -> (IWordSink*) pointer to the word sink
//  pPhraseSink      -> (IPhraseSink*) pointer to the phrase sink
//  pwchLast		 -> (WCHAR*) input & output last character of previous token
//
// Result:
//  (int) -1 if error occurs, text length to process
//
// 30MAR00  bhshin  began
int CWordBreaker::WordBreak(TEXT_SOURCE *pTextSource, WT Type, 
							int cchTextProcessed, int cchHanguel,
							IWordSink *pWordSink, IPhraseSink *pPhraseSink,
							WCHAR *pwchLast)
{
	const WCHAR *pwcStem;
	int iCur;
	int cchToken, cchProcessed, cchHg;
	int cchPrefix;
	
	ATLASSERT(cchTextProcessed > 0);
	
	if (cchTextProcessed <= 0)
		return -1;

	iCur = pTextSource->iCur;
	pwcStem = pTextSource->awcBuffer + iCur;
	cchProcessed = cchTextProcessed;
	cchToken = cchTextProcessed;

	// check too long token 
	if (cchToken > (int)m_ulMaxTokenSize || cchToken > MAX_INDEX_STRING)
	{
		cchProcessed = (m_ulMaxTokenSize < MAX_INDEX_STRING) ? m_ulMaxTokenSize : MAX_INDEX_STRING;

		pWordSink->PutWord(cchProcessed,
						   pwcStem,
						   cchProcessed,
						   pTextSource->iCur);

		return cchProcessed;
	}
	
	//=================================================
	// query & index time
	//=================================================

	if (Type == WT_PHRASE_SEP)
	{
		// phrase separator
		*pwchLast = L'\0';

		pWordSink->PutBreak(WORDREP_BREAK_EOS);
	}
	else if (Type == WT_WORD_SEP)
	{
		if (!fIsWhiteSpace(*pwcStem))
			*pwchLast = L'\0';
		
		// Korean WB do not add EOW.
	}
	else if (Type == WT_ROMAJI)
	{
		// symbol, alphabet, hanja, romaji + hanguel

		// get next token
		iCur += cchToken;
		Tokenize(FALSE, pTextSource, iCur, &Type, &cchToken, &cchHg);

		if (Type == WT_ROMAJI)
		{
			if (cchHg > 0)
			{
				// romaji+(hanguel+romaji) case -> put word itself
				cchProcessed += cchToken;
				iCur += cchToken;
				cchProcessed += GetWordPhrase(FALSE, pTextSource, iCur);

				WB_LOG_START(pwcStem, cchProcessed);

				pWordSink->PutWord(cchProcessed,
								   pwcStem,
								   cchProcessed,
								   pTextSource->iCur);

				WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_SYMBOL);
			}
			else
			{
				WB_LOG_START(pwcStem, cchProcessed);
				
				// {romaj}{romaj} case : -> breaking first {romaji}
				CIndexInfo IndexInfo;

				if (!IndexInfo.Initialize(cchProcessed, pTextSource->iCur, pWordSink, pPhraseSink))
					goto ErrorReturn;

				AnalyzeRomaji(pwcStem, cchProcessed, pTextSource->iCur, cchProcessed, 
				              cchHanguel, &IndexInfo, &cchPrefix);

				if (m_fQuery)
				{
					IndexInfo.AddIndex(pwcStem, cchProcessed+cchToken, WEIGHT_HARD_MATCH, 0, cchProcessed+cchToken-1);
					WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_QUERY);

					if (!IndexInfo.PutQueryIndexList())
						goto ErrorReturn;
				}
				else
				{
					if (!IndexInfo.PutFinalIndexList(pTextSource->awcBuffer + pTextSource->iCur))
						goto ErrorReturn;
				}
			}
		}
		else if (Type == WT_HANGUEL)
		{
			// romaji(hanguel+romaji) + hanguel case
			WCHAR wzRomaji[MAX_INDEX_STRING+1];
			int cchRomaji;

			cchRomaji = (cchProcessed > MAX_INDEX_STRING) ? MAX_INDEX_STRING : cchProcessed;

			wcsncpy(wzRomaji, pwcStem, cchRomaji);
			wzRomaji[cchRomaji] = L'\0';

			WB_LOG_START(pwcStem, cchProcessed+cchToken);
			
			cchProcessed += cchToken;
			
			// start position include romanji
			CIndexInfo IndexInfo;

			if (!IndexInfo.Initialize(cchProcessed, pTextSource->iCur, pWordSink, pPhraseSink))
				goto ErrorReturn;

			if (cchHanguel > 0)
			{
				AnalyzeRomaji(pwcStem, cchRomaji, pTextSource->iCur, cchRomaji, 
					         cchHanguel, &IndexInfo, &cchPrefix);
			}
			else
			{
				cchPrefix = CheckURLPrefix(pwcStem, cchProcessed-cchToken);
			}

			// analyze string starts from last hangul
			pwcStem = pTextSource->awcBuffer + iCur;

			if (cchRomaji > 0)
				IndexInfo.SetRomajiInfo(wzRomaji, cchRomaji, cchPrefix);

			// analyze string always with indexing mode on symbol processing
			if (!AnalyzeString(&m_PI, m_fQuery, pwcStem, cchToken, iCur, &IndexInfo, *pwchLast))
				goto ErrorReturn;

			if (m_fQuery)
			{
				if (cchRomaji > 0)
					IndexInfo.SetRomajiInfo(NULL, 0, 0);	

				IndexInfo.AddIndex(pTextSource->awcBuffer + pTextSource->iCur, cchProcessed, WEIGHT_HARD_MATCH, 0, cchProcessed+cchToken-1);
				WB_LOG_ADD_INDEX(pTextSource->awcBuffer + pTextSource->iCur, cchProcessed, INDEX_QUERY);

				if (!IndexInfo.PutQueryIndexList())
					goto ErrorReturn;
			}
			else
			{
				if (!IndexInfo.MakeSingleLengthMergedIndex())
					goto ErrorReturn;
				
				if (!IndexInfo.PutFinalIndexList(pTextSource->awcBuffer + pTextSource->iCur))
					goto ErrorReturn;
			}
			
			*pwchLast = *(pwcStem + cchToken - 1);
		}
		else // next: WT_START, WT_PHRASE_SEP, WT_WORD_SEP, WT_REACHEND
		{
			WB_LOG_START(pwcStem, cchProcessed);
			
			CIndexInfo IndexInfo;

			if (!IndexInfo.Initialize(cchProcessed, pTextSource->iCur, pWordSink, pPhraseSink))
				goto ErrorReturn;

			AnalyzeRomaji(pwcStem, cchProcessed, pTextSource->iCur, cchProcessed, 
				          cchHanguel, &IndexInfo, &cchPrefix);

			if (m_fQuery)
			{
				IndexInfo.AddIndex(pwcStem, cchProcessed, WEIGHT_HARD_MATCH, 0, cchProcessed-1);
				WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_QUERY);

				if (!IndexInfo.PutQueryIndexList())
					goto ErrorReturn;
			}
			else
			{
				if (!IndexInfo.PutFinalIndexList(pTextSource->awcBuffer + pTextSource->iCur))
					goto ErrorReturn;
			}
		}
	}
	else if (Type == WT_HANGUEL)
	{
		// hangul input

		WB_LOG_START(pwcStem, cchProcessed);
		
		CIndexInfo IndexInfo;

		if (!IndexInfo.Initialize(cchProcessed, iCur, pWordSink, pPhraseSink))
			goto ErrorReturn;

		if (!AnalyzeString(&m_PI, m_fQuery, pwcStem, cchProcessed, iCur, &IndexInfo, *pwchLast))
			goto ErrorReturn;

		if (m_fQuery)
		{
			IndexInfo.AddIndex(pwcStem, cchProcessed, WEIGHT_HARD_MATCH, 0, cchProcessed-1);
			WB_LOG_ADD_INDEX(pwcStem, cchProcessed, INDEX_QUERY);

			if (!IndexInfo.PutQueryIndexList())
				goto ErrorReturn;
		}
		else
		{
			if (!IndexInfo.MakeSingleLengthMergedIndex())
				goto ErrorReturn;
			
			if (!IndexInfo.PutFinalIndexList(pwcStem))
				goto ErrorReturn;
		}
	
		*pwchLast = *(pwcStem + cchProcessed - 1);
	}

	WB_LOG_PRINT_ALL();
	WB_LOG_END();
	
	return cchProcessed;

ErrorReturn:

	WB_LOG_END();
	
	return -1;
}

// CWordBreaker::AnalyzeRomaji
//
// helper function for romaji token wordbreaking
//
// Parameters:
//  pwcStem		     -> (const WCHAR*) input token string
//  cchStem          -> (int) length of input romaji token
//  iCur             -> (int) source string position
//  cchProcessed     -> (int) input length to process
//  cchHanguel       -> (int) hangul token length (hanguel+romaji case only)
//  pIndexInfo		-> (CIndexInfo *) output index list
//  pcchPrefix       -> (int*) output prefix length
//
// Result:
//  (void) 
//
// 23NOV00  bhshin  began
void CWordBreaker::AnalyzeRomaji(const WCHAR *pwcStem, int cchStem,
								 int iCur, int cchProcessed, int cchHanguel,
							     CIndexInfo *pIndexInfo, int *pcchPrefix)
{
	int cchPrefix = 0;
	
	// hanguel+romaji case
	if (cchHanguel < cchProcessed)
	{
		// hanguel
		if (cchHanguel > 0)
		{
			pIndexInfo->AddIndex(pwcStem, cchHanguel, WEIGHT_HARD_MATCH, 0, cchHanguel-1);
			WB_LOG_ADD_INDEX(pwcStem, cchHanguel, INDEX_SYMBOL);
		}

		// romaji
		if ((cchStem-cchHanguel) > 0)
		{
			pIndexInfo->AddIndex(pwcStem + cchHanguel, cchStem - cchHanguel, WEIGHT_HARD_MATCH, cchHanguel, cchStem-1);
			WB_LOG_ADD_INDEX(pwcStem + cchHanguel, cchStem - cchHanguel, INDEX_SYMBOL);
		}
	}

	if (cchHanguel == 1 || (cchStem-cchHanguel) == 1) 
	{
		// romaji(hangul+romaji)
		pIndexInfo->AddIndex(pwcStem, cchStem, WEIGHT_HARD_MATCH, 0, cchStem-1);
		WB_LOG_ADD_INDEX(pwcStem, cchStem, INDEX_SYMBOL);
	}
	
	// check URL prefix
	cchPrefix = CheckURLPrefix(pwcStem, cchProcessed);
	if (cchPrefix > 0 && cchPrefix < cchProcessed)
	{
		pIndexInfo->AddIndex(pwcStem + cchPrefix, cchStem - cchPrefix, WEIGHT_HARD_MATCH, cchPrefix, cchStem-1);
		WB_LOG_ADD_INDEX(pwcStem + cchPrefix, cchStem - cchPrefix, INDEX_SYMBOL);
	}

	*pcchPrefix = cchPrefix; // return it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\istemmer.cpp ===
// IStemmer.cpp
//
// CStemmer implementation
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  10 MAY 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "IStemmer.h"
#include <stdio.h>

/////////////////////////////////////////////////////////////////////////////
// CStemmer

// CStemmer::Init
//
// intialize WordBreaker object & lexicon
//
// Parameters:
//  ulMaxTokenSize  -> (ULONG) maximum input token length
//  *pfLicense		<- (BOOL*) always return TRUE
//
// Result:
//  (HRESULT) 
//
// 10MAY00  bhshin  began
STDMETHODIMP CStemmer::Init(ULONG ulMaxTokenSize, BOOL *pfLicense)
{
    if (pfLicense == NULL)
       return E_INVALIDARG;

    if (IsBadWritePtr(pfLicense, sizeof(DWORD)))
        return E_INVALIDARG;

    *pfLicense = TRUE;

	return S_OK;
}

// CStemmer::StemWord
//
// main stemming method
//
// Parameters:
//  pTextSource		-> (WCHAR const*) input string for stemming
//  cwc				-> (ULONG) input string length to process
//  pStemSink       -> (IStemSink*) pointer to the stem sink
//
// Result:
//  (HRESULT) 
//
// 10MAY00  bhshin  began
STDMETHODIMP CStemmer::StemWord(WCHAR const * pwcInBuf, ULONG cwc, IStemSink * pStemSink)
{
	if (pStemSink == NULL || pwcInBuf == NULL)
	{
		return E_FAIL;
	}
	
	pStemSink->PutWord(pwcInBuf, cwc);

	return S_OK;
}

// CStemmer::GetLicenseToUse
//
// return license information
//
// Parameters:
//  ppwcsLicense  -> (const WCHAR **) output pointer to the license information
//
// Result:
//  (HRESULT) 
//
// 10MAY00  bhshin  began
STDMETHODIMP CStemmer::GetLicenseToUse(const WCHAR ** ppwcsLicense)
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-2000";

    if (ppwcsLicense == NULL)  
       return E_INVALIDARG;

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) 
        return E_INVALIDARG;

    *ppwcsLicense = wcsCopyright;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\indexrec.h ===
// IndexRec.h
//
// final index record & lists
// 
// Copyright 2001 Microsoft Corp.
//
// Modification History:
//  19 MAR 2001	  bhshin	created

#ifndef _INDEX_REC_H
#define _INDEX_REC_H

// INDEX_REC
//
// index term information structure
// 
// 19MAR01  bhshin  began
typedef struct
{
	WCHAR wzIndex[MAX_INDEX_STRING+1]; // index string
	int cchIndex; // length of index string
	int nFT;   	 // first position of original input
	int nLT;  	 // last position of original input
	float fWeight; // weight of index term 

	int nNext;	 // next INDEX_REC index for final list
} INDEX_REC, *pINDEX_REC;


// CRecList
//
// container of INDEX_REC id's
//
// 20MAR01  bhshin  began
class CRecList
{
// member data
public:
	int *m_prgnRecID; 
	int m_nMaxRec; // # of allocated record
	int m_nCurrRec; // next empty space of m_prgnRecID

// default constructor & destructor
public:
	CRecList();
	~CRecList(); 

// operators
public:
	// initializer & uninitializer
	//==================
	BOOL Initialize(void);
	void Uninitialize(void);

	BOOL AddRec(int nRecID);

	// operators
	//==================
	CRecList& operator = (CRecList& objRecList);
	CRecList& operator += (CRecList& objRecList);
	
};


// the index of the first "real" record (0 is reserved)
#define MIN_RECORD  1

// CIndexInfo
//
// container of INDEX_REC structure
// 
// 19MAR01  bhshin  began
class CIndexInfo
{
// member data
public:
	// record management
	//==================
	INDEX_REC *m_prgIndexRec; // array of INDEX_REC
	int m_nMaxRec; // # of allocated record
	int m_nCurrRec; // next empty space of prgIndexRec

	// PutWord/PutAltWord 
	//==================
	int m_cchTextProcessed; // length of text processed
	int m_cwcSrcPos; // position value of source string
	IWordSink *m_pWordSink; 
	IPhraseSink *m_pPhraseSink;

	// symbol processing
	//==================
	WCHAR m_wzRomaji[MAX_INDEX_STRING+1]; // romaji string
	int m_cchRomaji; // length of romaji
	int m_cchPrefix; // the prefix length
	BOOL m_fAddRomaji; // flag if romaji is added or not

	// final list head index
	//==================
	int m_nFinalHead;

	// final sequence index list
	//==================
	CRecList m_FinalRecList;

// default constructor & destructor
public:
	CIndexInfo();
	~CIndexInfo();

// attributes
public:
	BOOL IsExistIndex(const WCHAR *pwzIndex);
	BOOL SetRomajiInfo(WCHAR *pwzRomaji, int cchRomaji, int cchPrefix);

	BOOL IsEmpty(void) { return (m_nCurrRec == MIN_RECORD); }

// operators
public:
	// initializer & uninitializer
	//==================
	BOOL Initialize(int cchTextProcessed, int cwcSrcPos, IWordSink *pWordSink, IPhraseSink *pPhraseSink);
	void Uninitialize(void);

	BOOL AddIndex(const WCHAR *pwzIndex, int cchIndex, float fWeight, int nFT, int nLT);

	// single length processing
	//==================
	BOOL FindAndMergeIndexTerm(INDEX_REC *pIndexSrc, int nFT, int nLT);
	BOOL MakeSingleLengthMergedIndex(void);

	// index time final index list
	//==================
	BOOL InsertFinalIndex(int nFT);
	BOOL PutFinalIndexList(LPCWSTR lpcwzSrc);

	// query time final index list
	//==================
	BOOL MakeSeqIndexList(int nFT =0, CRecList *plistFinal = NULL);
	BOOL PutQueryIndexList(void);
};

#endif // #ifdef _INDEX_REC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\korwbrk.cpp ===
// KorWbrk.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f KorWbrkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "KorWbrk.h"
#include "KorWbrk_i.c"
#include "IWBreak.h"
#include "IStemmer.h"
#include "Lex.h"

CComModule _Module;
CRITICAL_SECTION g_CritSect;
MAPFILE g_LexMap;
BOOL g_fLoaded;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WordBreaker, CWordBreaker)
OBJECT_ENTRY(CLSID_Stemmer, CStemmer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_KORWBRKLib);
        DisableThreadLibraryCalls(hInstance);

		WB_LOG_INIT();

		g_fLoaded = FALSE;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();

		if (g_fLoaded)
		{
			ATLTRACE("Unload lexicon...\n");

			UnloadLexicon(&g_LexMap);
		}

		WB_LOG_UNINIT();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\lex.h ===
// Lex.h
// lex management routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

BOOL InitLexicon(MAPFILE *pLexMap);
BOOL LoadLexicon(const char *pszLexPath, MAPFILE *pLexMap);
void UnloadLexicon(MAPFILE *pLexMap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\lexinfo.h ===
// lex_info.h
// declaration of lexicon header structure
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  03 JUL 2000   bhshin    reorder sub-lexicon
//  10 MAY 2000   bhshin    added Korean name trie
//  12 APR 2000   bhshin    added rgnCopulaEnd
//  13 MAR 2000	  bhshin	created

// current lexicon version
#define LEX_VERSION 0x0010

// lexicon filename 
#define LEXICON_FILENAME	"korwbrkr.lex"

// lexicon magin signature
#define LEXICON_MAGIC_SIG	"WBRK"

typedef struct {
	unsigned short nVersion;
	char szMagic[4];
	unsigned short nPadding;
	unsigned long rgnLastName;		// offset to last name trie
	unsigned long rgnNameUnigram;   // offset to name unigram trie
	unsigned long rgnNameBigram;    // offset to name bigram trie
	unsigned long rgnNameTrigram;   // offset to name trigram trie
    unsigned long rgnIRTrie;		// offset to main trie
	unsigned long rgnMultiTag;		// offset to multi tag table
	unsigned long rgnEndIndex;		// offset to ending rule index
	unsigned long rgnEndRule;		// offset to ending rule	
	unsigned long rgnPartIndex;		// offset to particle rule index
	unsigned long rgnPartRule;		// offset to particle rule
	unsigned long rgnCopulaEnd;		// offset to copula ending table
	unsigned long rngTrigramTag;	// offset to name trigram tag data
} LEXICON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\lex.cpp ===
// Lex.cpp
// lex management routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "LexInfo.h"
#include "Lex.h"
#include <stdio.h>

// InitLexicon
// 
// finx lexicon & map the lexicon file into memory
//
// Parameters:
//  pLexMap     -> (MAPFILE*) output MAPFILE structure
//
// Result:
//  (TRUE if success, FALSE if failure)
//
// 16MAR00  bhshin  began
BOOL InitLexicon(MAPFILE *pLexMap)
{
    char szLexFile[_MAX_PATH];
	char szDllPath[_MAX_PATH];
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	char szFName[_MAX_FNAME];
	char szExt[_MAX_EXT];

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;

	// get the path of word breaker DLL
	if (GetModuleFileNameA(_Module.m_hInst, szDllPath, _MAX_PATH) == 0)
		return FALSE;

	// make lexicon full path
	_splitpath(szDllPath, szDrive, szDir, szFName, szExt);

	strcpy(szLexFile, szDrive);
    strcat(szLexFile, szDir);
    strcat(szLexFile, LEXICON_FILENAME);

	return LoadLexicon(szLexFile, pLexMap);
}

// LoadLexicon
// 
// map the lexicon file into memory
//
// Parameters:
//  pszLexPath  -> (const char*) lexicon file path
//  pLexMap     -> (MAPFILE*) output MAPFILE structure
//
// Result:
//  (TRUE if success, FALSE if failure)
//
// 16MAR00  bhshin  began
BOOL LoadLexicon(const char *pszLexPath, MAPFILE *pLexMap)
{
    char *pData;
	unsigned short nVersion;
	
	if (pszLexPath == NULL)
		return FALSE;

	if (pLexMap == NULL)
		return FALSE;

	// open the file for reading
    pLexMap->hFile = CreateFile(pszLexPath, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (pLexMap->hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // create a file mapping
    pLexMap->hFileMapping = CreateFileMappingA(pLexMap->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (pLexMap->hFileMapping == NULL)
        return FALSE;

    // map the entire file for reading
    pLexMap->pvData = MapViewOfFileEx(pLexMap->hFileMapping, FILE_MAP_READ, 0, 0, 0, 0);
    if (pLexMap->pvData == NULL)
        return FALSE;

    // check the version # in the first 2 bytes (swap bytes)
    pData = (char*)pLexMap->pvData;
    nVersion = pData[0];
    nVersion |= (pData[1] << 8);
    if (nVersion < LEX_VERSION)
    {
        ATLTRACE("Outdated lexicon file\n");
        ATLTRACE("Expected v.%d, found v.%d\n", LEX_VERSION, nVersion);
        return FALSE;
    }

	// check the magic signature
	if (strcmp(pData+2, LEXICON_MAGIC_SIG) != 0)
		return FALSE;

	return TRUE;
}

// UnloadLexicon
// 
// unmap the lexicon file into memory
//
// Parameters:
//  pLexMap  -> (MAPFILE*) input MAPFILE structure
//
// Result:
//  (void)
//
// 16MAR00  bhshin  began
void UnloadLexicon(MAPFILE *pLexMap)
{
    if (pLexMap->pvData != NULL)
        UnmapViewOfFile(pLexMap->pvData);
    
	if (pLexMap->hFileMapping != NULL)
        CloseHandle(pLexMap->hFileMapping);

    if (pLexMap->hFile != NULL)
        CloseHandle(pLexMap->hFile);

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\lookup.h ===
// Lookup.h
//
// dictionary lookup routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#ifndef _LOOKUP_H
#define _LOOKUP_H

#include "trie.h"

BOOL DictionaryLookup(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput, BOOL fQuery);

BOOL LookupNameFrequency(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, ULONG *pulFreq);

BOOL LookupNameIndex(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, int *pnIndex);

BOOL LookupTrigramTag(unsigned char *pTrigramTag, int nIndex, ULONG *pulTri, ULONG *pulBi, ULONG *pulUni);

#endif // #ifndef _LOOKUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\lookup.cpp ===
// Lookup.cpp
//
// dictionary lookup routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Lookup.h"
#include "LexInfo.h"
#include "trie.h"
#include "unikor.h"
#include "Morpho.h"
#include "WbData.h"

#define		MASK_MULTI_TAG		0x00008000
#define		MASK_TAG_INDEX		0x00007FFF

#define		SIZE_OF_TRIGRAM_TAG		7

//////////////////////////////////////////////////////////////////////////////
// function declaration

BOOL LookupIRDict(PARSE_INFO *pPI, TRIECTRL *pTrieCtrl, unsigned char *pMultiTag, 
				  const WCHAR *pwzSource, int nIndex, BOOL fQuery);

//////////////////////////////////////////////////////////////////////////////
// function implementation

// DictionaryLookup
//
// dictionary lookup and create a record for every valid word
// Before call this, InitRecord should be called
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pwzInput		-> (const WCHAR*) input string to analyze (NOT decomposed)
//  cchInput		-> (int) length of input string to analyze
//  fQuery          -> (BOOL) flag if it's query time
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 09AUG00  bhshin  added fQuery parameter
// 30MAR00  bhshin  began
BOOL DictionaryLookup(PARSE_INFO *pPI, const WCHAR *pwzInput, int cchInput, BOOL fQuery)
{	
	LEXICON_HEADER *pLex;
	unsigned char *pIRDict;
	unsigned char *pMultiTag;
	TRIECTRL *pTrieCtrl;
	int i;

	if (pPI == NULL)
		return FALSE;

	// allocate record storage
	if (ClearRecords(pPI) == FALSE)
		return FALSE;

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return FALSE;
	
	pIRDict = (unsigned char*)pLex;
	pIRDict += pLex->rgnIRTrie;

	pMultiTag = (unsigned char*)pLex;
	pMultiTag += pLex->rgnMultiTag;

	pTrieCtrl = TrieInit((LPBYTE)pIRDict);
	if (pTrieCtrl == NULL)
		return FALSE;

	// start to lookup all the substring
	for (i = 0; i < pPI->nLen; i++)
	{
		LookupIRDict(pPI, pTrieCtrl, pMultiTag, pPI->pwzSourceString, i, fQuery);
	}

	TrieFree(pTrieCtrl);

	return TRUE;
}


// LookupIRDict
//
// lookup IR main dictionary and if entry found, then add record
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  pTrieCtrl		-> (TRIECTRL *) ptr to trie control returned by TrieInit
//  pMultiTag		-> (unsigned char*) multiple tag table
//  pwzSource		-> (const WCHAR*) input normalized(decomposed) string (NULL terminated)
//  nIndex			-> index to start search
//  fQuery          -> (BOOL) flag if it's query time
//
// Result:
//  (BOOL) TRUE if successfully entry found, FALSE otherwise
//
// 09AUG00  bhshin  added fQuery parameter
// 30MAR00  bhshin  began
BOOL LookupIRDict(PARSE_INFO *pPI, TRIECTRL *pTrieCtrl, unsigned char *pMultiTag, 
				  const WCHAR *pwzSource, int nIndex, BOOL fQuery)
{
	BOOL fResult = FALSE;
	TRIESCAN TrieScan;
	unsigned long ulFinal;
	int idxInput, idxTag;
	unsigned char cTags;
	RECORD_INFO rec;
	WCHAR wzIndex[MAX_ENTRY_LENGTH+1];
	BYTE bPOS, bInfl;
	WORD wCat;

	if (pTrieCtrl == NULL || pMultiTag == NULL)
		return FALSE;

	if (pwzSource == NULL)
		return FALSE;

    memset(&TrieScan, 0, sizeof(TRIESCAN));

	idxInput = nIndex;
	
	while (pwzSource[idxInput] != L'\0')
    {
        if (!TrieGetNextState(pTrieCtrl, &TrieScan))
            goto Exit;

        while (TrieScan.wch != pwzSource[idxInput])
        {
            if (!TrieSkipNextNode(pTrieCtrl, &TrieScan, pwzSource[idxInput]))
                goto Exit;
        }

		if (TrieScan.wFlags & TRIE_NODE_VALID)
		{
			ulFinal = TrieScan.aTags[0].dwData;

			if (ulFinal & MASK_MULTI_TAG)
			{
				// process multiple tag
				idxTag = ulFinal & MASK_TAG_INDEX;

				cTags = pMultiTag[idxTag++];

				int nTag = 0;
				while (nTag < cTags)
				{
					bPOS = pMultiTag[idxTag++];
					bInfl = pMultiTag[idxTag++];

					// on query time, we just look up NOUN rec.
					if (fQuery && !IsNounPOS(bPOS))
					{
						nTag++;
						continue; // while (nTag < cTags)
					}

					wCat = MAKEWORD(bInfl, bPOS);
					
					rec.nFT = (unsigned short)nIndex;
					rec.nLT = (unsigned short)idxInput;
					rec.nDict = DICT_FOUND;
					
					// newly added record has its cat as Left/Right cat
					rec.nLeftCat = wCat;
					rec.nRightCat = wCat;

					// newly added record has no child
					rec.nLeftChild = 0;
					rec.nRightChild = 0;

					rec.fWeight = (float)GetWeightFromPOS(bPOS);

					ATLASSERT(rec.nLT-rec.nFT+1 < MAX_ENTRY_LENGTH);

					wcsncpy(wzIndex, &pPI->pwzSourceString[rec.nFT], rec.nLT-rec.nFT+1);
					wzIndex[rec.nLT-rec.nFT+1] = L'\0';
					
					rec.pwzIndex = wzIndex;

					if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NN)
						rec.cNounRec = 1;
					else
						rec.cNounRec = 0;

					rec.cNoRec = 0;

					if (bPOS == POS_NO)
						rec.cNoRec = 1;

					AddRecord(pPI, &rec);

					nTag++;
				}
			}
			else
			{
				// single tag case
				wCat = (WORD)ulFinal;

				// on query time, we just look up NOUN rec.
				if (fQuery && !IsNounPOS(HIBYTE(wCat)))
				{
					idxInput++;
					continue; // while (pwzSource[idxInput] != L'\0')
				}

				rec.nFT = (unsigned short)nIndex;
				rec.nLT = (unsigned short)idxInput;
				rec.nDict = DICT_FOUND;

				// newly added record has its cat as Left/Right cat
				rec.nLeftCat = wCat;
				rec.nRightCat = wCat;

				// newly added record has no child
				rec.nLeftChild = 0;
				rec.nRightChild = 0;

				rec.fWeight = (float)GetWeightFromPOS(HIBYTE(wCat));

				ATLASSERT(rec.nLT-rec.nFT+1 < MAX_ENTRY_LENGTH);

				wcsncpy(wzIndex, &pPI->pwzSourceString[rec.nFT], rec.nLT-rec.nFT+1);
				wzIndex[rec.nLT-rec.nFT+1] = L'\0';
				
				rec.pwzIndex = wzIndex;

				bPOS = HIBYTE(wCat);

				if (bPOS == POS_NF || bPOS == POS_NC || bPOS == POS_NN)
					rec.cNounRec = 1;
				else
					rec.cNounRec = 0;

				rec.cNoRec = 0;

				if (bPOS == POS_NO)
					rec.cNoRec = 1;

				AddRecord(pPI, &rec);
			}

			fResult = TRUE;
		}

		idxInput++;
    }

Exit:
	return fResult;
}

// LookupNameFrequency
//
// look up Korean name frequency
//
// Parameters:
//  pTrieCtrl		-> (TRIECTRL *) ptr to trie
//  pwzName		    -> (const WCHAR*) input name (NULL terminated)
//  pulFreq			-> (ULONG*) output frequency value
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 02MAY00  bhshin  began
BOOL LookupNameFrequency(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, ULONG *pulFreq)
{
	TRIESCAN TrieScan;
	WCHAR wzDecomp[15];
	CHAR_INFO_REC rgCharInfo[15];

	if (pTrieCtrl == NULL || pwzName == NULL)
		return FALSE;

	decompose_jamo(wzDecomp, pwzName, rgCharInfo, 15);

	if (TrieCheckWord(pTrieCtrl, &TrieScan, (WCHAR*)wzDecomp))
	{
		if (TrieScan.wFlags & TRIE_NODE_VALID)
		{
			// found. get the frequency value
			*pulFreq = TrieScan.aTags[0].dwData;
		}
		else
		{
			// not found
			*pulFreq = 0L; 
		}
	}
	else
	{
		// not found
		*pulFreq = 0L; 
	}

	return TRUE;
}

// LookupNameIndex
//
// look up Korean name index (for trigram lookup)
//
// Parameters:
//  pTrieCtrl		-> (TRIECTRL *) ptr to trie
//  pwzName		    -> (const WCHAR*) input name (NULL terminated)
//  pnIndex		    -> (int*) output index of trie (-1 means not found)
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10MAY00  bhshin  began
BOOL LookupNameIndex(TRIECTRL *pTrieCtrl, const WCHAR *pwzName, int *pnIndex)
{
	TRIESCAN TrieScan;
	WCHAR wzDecomp[15];
	CHAR_INFO_REC rgCharInfo[15];

	if (pTrieCtrl == NULL || pwzName == NULL)
		return FALSE;

	// the key of trie is decomposed string
	decompose_jamo(wzDecomp, pwzName, rgCharInfo, 15);

	if (TrieCheckWord(pTrieCtrl, &TrieScan, (WCHAR*)wzDecomp))
	{
		if (TrieScan.wFlags & TRIE_NODE_VALID)
		{
			// found. get the frequency value
			*pnIndex = TrieScan.aTags[0].dwData;
		}
		else
		{
			// not found
			*pnIndex = -1; 
		}
	}
	else
	{
		// not found
		*pnIndex = -1; 
	}

	return TRUE;
}

// LookupNameIndex
//
// look up Korean name index (for trigram lookup)
//
// Parameters:
//  pTrigramTag	-> (unsigned char *) ptr to trie
//  nIndex		-> (int) index of data
//  pulTri		-> (ULONG*) output index of trie
//  pulBi		-> (ULONG*) output index of trie
//  pulUni		-> (ULONG*) output frequency of
//
// Result:
//  (BOOL) TRUE if succeed, otherwise return FALSE
//
// 10MAY00  bhshin  began
BOOL LookupTrigramTag(unsigned char *pTrigramTag, int nIndex, ULONG *pulTri, ULONG *pulBi, ULONG *pulUni)
{
	int idxData;
	
	if (pTrigramTag == NULL)
		return FALSE;

	if (pulTri == NULL || pulBi == NULL || pulUni == NULL)
		return FALSE;

	idxData = nIndex * SIZE_OF_TRIGRAM_TAG;

	// trigram
	*pulTri = (*(pTrigramTag + idxData++)) << 8;
	*pulTri += (*(pTrigramTag + idxData++));

	// bigram
	*pulBi = (*(pTrigramTag + idxData++)) << 8;
	*pulBi += (*(pTrigramTag + idxData++));

	// unigram
	*pulUni = (*(pTrigramTag + idxData++)) << 16;
	*pulUni += (*(pTrigramTag + idxData++)) << 8;
	*pulUni += (*(pTrigramTag + idxData++));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\memmgr.h ===
// memmgr.h
//
// This file contains declarations and macros for memory management.  
// Implementation details may change so beware of relying on internal details.


#ifndef __INCLUDE_MEMMGR
#define __INCLUDE_MEMMGR

#ifdef __cplusplus
extern "C" 
{
#endif

void *ExternAlloc(DWORD cb);
void *ExternRealloc(void *pv, DWORD cb);
void  ExternFree(void *pv);

char *Externstrdup( const char *strSource );

#ifdef DEBUG
extern int cAllocMem;     // Amount of memory alloced
extern int cAlloc;        // Count of allocs outstanding
extern int cAllocMaxMem;  // Max amount of memory ever alloced.
#endif

#ifdef __cplusplus
};
#endif

#endif //__INCLUDE_MEMMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\morpho.h ===
// Morpho.h
//
// morphotactics and weight handling routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#ifndef _MORPHO_H
#define _MORPHO_H

// pre-defined morphotactics weight
const float WEIGHT_NOT_MATCH  =   -1;
const float WEIGHT_SOFT_MATCH	=	 0;
const float WEIGHT_VA_MATCH   =    8;
const float WEIGHT_HARD_MATCH	=	10;

float CheckMorphotactics(PARSE_INFO *pPI, int nLeftRec, int nRightRec, BOOL fQuery);
int GetWeightFromPOS(BYTE bPOS);
BOOL IsCopulaEnding(PARSE_INFO *pPI, WORD wCat);
BOOL CheckValidFinal(PARSE_INFO *pPI, WORD_REC *pWordRec);
BOOL IsLeafRecord(WORD_REC *pWordRec);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\memmgr.c ===
// memmgr.c
//
// This file contains definitions for the memory management.
// Implementation details may change so beware of relying on internal details.
//
// 21-FEB-2000	bhshin	changed malloc into GlobalAlloc

#include <windows.h>
#include "memmgr.h"

#ifdef DEBUG
int cAllocMem = 0;     // Amount of memory alloced
int cAlloc = 0;        // Count of allocs outstanding
int cAllocMaxMem = 0;  // Max amount of memory ever alloced.
#endif

#ifdef  DEBUG
int	gFailure = 0;
#endif

/******************************Public*Routine******************************\
* ExternAlloc
*
* This guy keeps the size in the first long so we can fake a realloc.  Lot's
* of debug checking for heap overwrites.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternAlloc(DWORD cb)
{
    long   *pl;
	DWORD	cbAlloc;

#ifdef  DEBUG
#ifndef WINCE
    //
    // If gFailure is 0 nothing happens, if it's non-zero we
    // fail 1 in gFailure allocations.
    //

    if (gFailure)
    {
        if (((rand() * gFailure) / (RAND_MAX + 1)) == 0)
        {
            return (void *) NULL;
        }
    }
#endif
#endif

// Since we can't use realloc on WINCE, we need to save the original size for memcpy
// in our own realloc function.

	cbAlloc = cb + 4;

#ifdef DEBUG
    cbAlloc +=  3;	// round it up to DWORD boundary
    cbAlloc &= ~3;
    cbAlloc +=  8;	// write size at begining and overwrite detector at begining and end
#endif

	pl = (long *)GlobalAlloc(GPTR, cbAlloc);
	if (pl == (long *) NULL)
		return pl;

// Stamp this baby full of invalid bytes so code that relies on 0's in it are sniffed out.

#ifdef DEBUG
	memset(pl,0xff,cbAlloc);
#endif

// OK, tuck the object size away at the begining

	*(pl++) = cb;

#ifdef DEBUG
    *(pl++) = 0xDEADBEEF;
    pl[(cbAlloc / 4) - 3] = 0xDEADBEEF;
    cAlloc++;
    cAllocMem += cb;

    if (cAllocMem > cAllocMaxMem)
    {
        TCHAR szDebug[128];
        cAllocMaxMem = cAllocMem;
        wsprintf(szDebug, TEXT("cAllocMaxMem = %d \r\n"), cAllocMaxMem);
        OutputDebugString(szDebug);
    }
#endif

    return pl;
}

/******************************Public*Routine******************************\
* ExternRealloc
*
* We want the same exact code on NT and WINCE and we can't find a way to 
* use the flags and have Realloc work the same on both.  Realloc is a very 
* infrequent event so this work for us.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternRealloc(void *pv, DWORD cbNew)
{
    void   *pvNew = ExternAlloc(cbNew);

    if (pv && pvNew)
    {
        long   *pl;
        DWORD	cb;

        pl = (long *) pv;

#ifdef	DEBUG
		pl--;
#endif

        cb = (DWORD) *(--pl);
		memcpy(pvNew, pv, min(cbNew, cb));
        ExternFree(pv);
    }

	return pvNew;
}

/******************************Public*Routine******************************\
* ExternFree
*
* Free up the memory, in debug mode check for heap corruption !
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void ExternFree(void *pv)
{
    long   *pl;

// We now allow freeing of null pointers

	if (pv == (void *) NULL)
		return;

    pl = (long *) pv;
    pl--;

#ifdef DEBUG
{
    int		cbAlloc;

// Check nothing has been stepped on.

    Assert(*pl == 0xDEADBEEF);
    pl--;
    cbAlloc = *pl;
    cAllocMem -= cbAlloc;
    assert(cAllocMem >= 0);
    cbAlloc = (cbAlloc + 11) & ~3;
    Assert(pl[(cbAlloc / 4)] == 0xDEADBEEF);
    cAlloc--;
}
#endif

	GlobalFree(pl);
}

char *Externstrdup( const char *strSource )
{
	int		nLen = 0;
	char*	pszOut = NULL;

	// fail immediately on a null pointer
	if (NULL == strSource)
		return NULL;

	// get the length of the ansi string 
	nLen = strlen(strSource) * sizeof(char);

	// fail on a 0 length string 
	//  @todo(petewil) - is this right, or return 0 length string instead?
	if (0 == nLen)
		return NULL;

	// allow room for a trailing null
	nLen += sizeof(char);

	// allocate space for the string
	pszOut = ExternAlloc(nLen);

	if (NULL == pszOut)
		return NULL;

	// copy the string into the buffer provided
	strcpy(pszOut, strSource);

    return pszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\morpho.cpp ===
// Morpho.cpp
//
// morphotactics and weight handling routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  14 AUG 2000   bhshin    remove CheckVaFollowNoun
//  12 APR 2000   bhshin    added IsCopulaEnding
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "LexInfo.h"
#include "Morpho.h"
#include "Record.h"
#include "unikor.h"
#include "WbData.h"

// POS weight value
const int WEIGHT_POS_NF		=	10;
const int WEIGHT_POS_NO		=	10;
const int WEIGHT_POS_OTHER  =	10;

//////////////////////////////////////////////////////////////////////////////
// Function Declarations

float PredefinedMorphotactics(PARSE_INFO *pPI, WORD wLeftCat, WORD wRightCat);
BOOL IsClassXXCat(WORD wCat);
BOOL CheckVaFollowNoun(WORD_REC *pWordRec);
BOOL CheckFollwingNo(WORD_REC *pRightRec);
WORD_REC* GetRightEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec);
WORD_REC* GetLeftEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec);

//////////////////////////////////////////////////////////////////////////////
// Data For CheckMorphotactics

static const WCHAR *LEFT_STR1[]   = {L"\xACE0",        // 
                                     L"\xC774\xACE0"}; // 
static const WCHAR *RIGHT_STR1[]  = {L"\xC2F6",        // 
                                     L"\xC2F6\xC5B4\xD558",		   // 
									 L"\xC2F6\xC5B4\xD574",        // 
									 L"\xC2F6\xC5B4\xD558\xC5EC",  // 
                                     L"\xC788",        // 
									 L"\xACC4\xC2DC",  // 
									 L"\xACC4\xC154",  // 
									 L"\xD504",        // 
									 L"\xD30C"};       // 

static const WCHAR *LEFT_STR2[]   = {L"\x3139",        // 
                                     L"\xC77C",        //  
									 L"\xC744"};	   // 
static const WCHAR *RIGHT_STR2[]  = {L"\xBED4\xD558",		// 
                                     L"\xBED4\xD574",		// 
									 L"\xBED4\xD558\xC5EC", // 
									 L"\xB4EF\xC2F6",		// 
									 L"\xC131\xC2F6",		// 
									 L"\xB4EF\xD558",		// 
                                     L"\xB4EF\xD558\xC5EC", // 
									 L"\xB4EF\xD574",		// 
									 L"\xBC95\xD558",		// 
									 L"\xBC95\xD574",		// 
									 L"\xBC95\xD558\xC5EC", // 
									 L"\xB9CC\xD558",		// 
									 L"\xB9CC\xD574",		// 
									 L"\xB9CC\xD558\xC5EC"};// 

static const WCHAR *LEFT_STR3[]   = {L"\x3134",  // 
                                     L"\xC740",  // 
									 L"\xC778",  // 
									 L"\xB294"}; // 
static const WCHAR *RIGHT_STR3[]  = {L"\xCCB4\xD558",			// 
                                     L"\xCCB4\xD574",			// 
									 L"\xCCB4\xD558\xC5EC",		//  
									 L"\xCC99\xD558",			// 
									 L"\xCC99\xD558\xC5EC",		// 
                                     L"\xCC99\xD574",			// 
									 L"\xC591\xD558",			// 
									 L"\xC591\xD574",			// 
									 L"\xC591\xD558\xC5EC",		// 
									 L"\xB4EF\xC2F6",			// 
									 L"\xB4EF\xD558",			// 
									 L"\xB4EF\xD574",			// 
									 L"\xB4EF\xD558\xC5EC",		// 
									 L"\xC131\xC2F6",			// 
									 L"\xC148\xCE58"};			// 

static const WCHAR *LEFT_STR4[]   = {L"\xC9C0"};	// 
static const WCHAR *RIGHT_STR4[]  = {L"\xC54A"};	// 

    
static const WCHAR *LEFT_STR5[]   = {L"\xC57C",					// 
                                     L"\xC5B4\xC57C",			// 
									 L"\xC544\xC57C",			// 
									 L"\xC5EC\xC57C",			// 
									 L"\xC774\xC5B4\xC57C"};	// 
static const WCHAR *RIGHT_STR5[]  = {L"\xD558",					// 
                                     L"\xD558\xC5EC",			// 
									 L"\xD574"};				// 

static const WCHAR *LEFT_STR6[]   = {L"\xAC8C"};				// 
static const WCHAR *RIGHT_STR6[]  = {L"\xD558",					// 
                                     L"\xD558\xC5EC",			// 
									 L"\xD574",					// 
									 L"\xB418",					// 
									 L"\xB3FC"};				// 

// CompareIndexTerm
//
// compare decompose index term string with string list
//
// Parameters:
//  pwzLeft			-> (const WCHAR *) decomposed left index string
//  pwzRight		-> (const WCHAR *) decomposed right index string
//  ppwzLeftList 	-> (const WCHAR **) composed string list to compare with left
//  nLeftList		-> (int) left string list size
//  ppwzRightList 	-> (const WCHAR **) composed string list to compare with right
//  nRightList		-> (int) right string list size
//
// Result:
//  (BOOL) return TRUE if Copular Ending, otherwise return FALSE
//
// 30MAR00  bhshin  began
inline BOOL CompareIndexTerm(const WCHAR *pwzLeft, const WCHAR *pwzRight,
							 const WCHAR **ppwzLeftList, int nLeftList,
							 const WCHAR **ppwzRightList, int nRightList)
{
	int i;
	WCHAR wzLeft[MAX_INDEX_STRING+1];
	WCHAR wzRight[MAX_INDEX_STRING+1];

	compose_jamo(wzLeft, pwzLeft, MAX_INDEX_STRING);

	for (i = 0; i < nLeftList; i++)
	{
		if (wcscmp(wzLeft, ppwzLeftList[i]) == 0)
			break;
	}

	if (i == nLeftList)
		return FALSE;

	compose_jamo(wzRight, pwzRight, MAX_INDEX_STRING);

	for (i = 0; i < nRightList; i++)
	{
		if (wcscmp(wzRight, ppwzRightList[i]) == 0)
			return TRUE;
	}

	return FALSE;
}

static const WCHAR *VA_LEMMA[] = {L"\xAC00",				// 
                                  L"\xAC00\xC9C0",			// 
							      L"\xAC00\xC838",			// 
								  L"\xACC4\xC2DC",			// 
								  L"\xACC4\xC154",          // 
								  L"\xB098",				// 
								  L"\xB098\xAC00",          // 
								  L"\xB0B4",                // 
								  L"\xB193",                // 
								  L"\xB300",				// 
								  L"\xB450",                // 
								  L"\xB46C",                // 
								  L"\xB4DC\xB9AC",          // 
								  L"\xB4DC\xB824",          // 
								  L"\xB2E4\xC624",          // 
								  L"\xBA39",                // 
								  L"\xBC14\xCE58",			// 
								  L"\xBC14\xCCD0",			// 
								  L"\xBC84\xB987\xD558",	// 
								  L"\xBC84\xB987\xD574",	// 
								  L"\xBC84\xB987\xD558\xC5EC",  // 
								  L"\xBC84\xB9AC",			//  
								  L"\xBC84\xB824",			//  
								  L"\xBCF4",				//   
								  L"\xBD10",				//   
								  L"\xBE60\xC9C0",			//  
								  L"\xBE60\xC838",			// 
								  L"\xC624",				// 
								  L"\xC640",				// 
								  L"\xC788",                // 
								  L"\xC8FC",				// 
								  L"\xC918",                // 
								  L"\xC9C0",                // 
								  L"\xC838",                // 
								  L"\xD130\xC9C0",			// 
								  L"\xD130\xC838",          // 
							      L"\xD558",				// 
								  L"\xD574",				// 
								  L"\xD558\xC5EC"};			// 

inline BOOL CompareVaLemma(const WCHAR *pwzIndex)
{
	WCHAR wzLemma[MAX_ENTRY_LENGTH+1];
	
	// we should compare list with composed lemma.
	compose_jamo(wzLemma, pwzIndex, MAX_ENTRY_LENGTH);
	
	int cLemmaList = sizeof(VA_LEMMA)/sizeof(VA_LEMMA[0]);

	for (int i = 0; i < cLemmaList; i++)
	{
		if (wcscmp(wzLemma, VA_LEMMA[i]) == 0)
			return TRUE;
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Function Implementation

// CheckMorphotactics
//
// check morphotactics & return corresponding weight value
//
// Parameters:
// pPI	     -> (PARSE_INFO*) ptr to parse-info struct
// nLeftRec  -> (int) left side record
// nRightRec -> (int) right side record
// fQuery    -> (BOOL) query time flag
//
// Result:
//  (float) weight value, if not matched then return -1
//
// 17APR00  bhshin  changed return type
// 31MAR00  bhshin  began
float CheckMorphotactics(PARSE_INFO *pPI, int nLeftRec, int nRightRec, BOOL fQuery)
{
	WORD_REC *pLeftRec = NULL;
	WORD_REC *pRightRec = NULL;
	WORD_REC *pLeftEdgeRec = NULL;
	WORD_REC *pRightEdgeRec = NULL;
	BYTE bLeftPOS, bRightPOS;
	int cchLeft, cchRight, cNoRec;
	float fWeight;
	WCHAR wzRight[MAX_ENTRY_LENGTH+1];
	WCHAR wzLeft[MAX_ENTRY_LENGTH+1];
	
	if (pPI == NULL)
		return WEIGHT_NOT_MATCH;
	
	if (nLeftRec < MIN_RECORD || nLeftRec >= pPI->nCurrRec)
		return WEIGHT_NOT_MATCH;

	if (nRightRec < MIN_RECORD || nRightRec >= pPI->nCurrRec)
		return WEIGHT_NOT_MATCH;

	pLeftRec = &pPI->rgWordRec[nLeftRec];
	pRightRec = &pPI->rgWordRec[nRightRec];

	if (pLeftRec == NULL || pRightRec == NULL)
		return WEIGHT_NOT_MATCH;

	bLeftPOS = HIBYTE(pLeftRec->nRightCat);
	bRightPOS = HIBYTE(pRightRec->nLeftCat);

	if (bRightPOS == POS_VA && IsLeafRecord(pRightRec))
	{
		// get the right edge record of LeftRec
		pLeftEdgeRec = GetRightEdgeRec(pPI, pLeftRec);
		if (pLeftEdgeRec == NULL)
			return WEIGHT_NOT_MATCH; // error

		// get the left edge record of RightRec
		pRightEdgeRec = GetLeftEdgeRec(pPI, pRightRec);
		if (pRightEdgeRec == NULL)
			return WEIGHT_NOT_MATCH; // error
	
		if (CompareVaLemma(pRightEdgeRec->wzIndex))
		{
			// CASE I
			if (IsClassXXCat(pLeftRec->nRightCat))
			{
				cchLeft = compose_length(&pPI->pwzSourceString[pLeftEdgeRec->nFT], 
										 pLeftEdgeRec->nLT - pLeftEdgeRec->nFT + 1);

				cchRight = compose_length(&pPI->pwzSourceString[pRightEdgeRec->nFT], 
										  pRightEdgeRec->nLT - pRightEdgeRec->nFT + 1);
				
				if (cchLeft > 1 || cchRight > 1)
				{
					
					return (pLeftRec->fWeight + pRightRec->fWeight) / 3;
				}
			}

			// CASE II
			if (bLeftPOS == POS_FUNCW)
			{
				// (0x110b,0x1165), (0x110b,0x1161)
				if ((wcscmp(pLeftEdgeRec->wzIndex, L"\x110B\x1165") == 0 || 
					 wcscmp(pLeftEdgeRec->wzIndex, L"\x110B\x1161") == 0) &&
					pLeftRec->nFT > 0)
				{
					return (pLeftRec->fWeight + pRightRec->fWeight) / 3;
				}
			}
		}

		// CASE III : hard coded matching list
		if (bLeftPOS == POS_FUNCW)
		{
			if (CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR1, sizeof(LEFT_STR1)/sizeof(LEFT_STR1[0]),
								 RIGHT_STR1, sizeof(RIGHT_STR1)/sizeof(RIGHT_STR1[0])) ||
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR2, sizeof(LEFT_STR2)/sizeof(LEFT_STR2[0]),
								 RIGHT_STR2, sizeof(RIGHT_STR2)/sizeof(RIGHT_STR2[0])) ||
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR3, sizeof(LEFT_STR3)/sizeof(LEFT_STR3[0]),
								 RIGHT_STR3, sizeof(RIGHT_STR3)/sizeof(RIGHT_STR3[0])) ||			
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR4, sizeof(LEFT_STR4)/sizeof(LEFT_STR4[0]),
								 RIGHT_STR4, sizeof(RIGHT_STR4)/sizeof(RIGHT_STR4[0])) ||		
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR5, sizeof(LEFT_STR5)/sizeof(LEFT_STR5[0]),
								 RIGHT_STR5, sizeof(RIGHT_STR5)/sizeof(RIGHT_STR5[0])) ||		
				CompareIndexTerm(pLeftEdgeRec->wzIndex, pRightEdgeRec->wzIndex, 
								 LEFT_STR6, sizeof(LEFT_STR6)/sizeof(LEFT_STR6[0]),
								 RIGHT_STR6, sizeof(RIGHT_STR6)/sizeof(RIGHT_STR6[0])))
			{
				return (pLeftRec->fWeight + pRightRec->fWeight) / 3;
			}
		}
		else if ((bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN || bLeftPOS == POS_NO) && 
		     CheckVaFollowNoun(pRightRec))
		{
			// recordA in {Nf Nc Nn No} & recordB in Va & CheckVaFollowNoun(recordB)
			return (pLeftRec->fWeight + pRightRec->fWeight + WEIGHT_HARD_MATCH) / 3;	
		}			
	} // if (bRightPOS == POS_VA)
	else if (bRightPOS == POS_FUNCW || bRightPOS == POS_POSP)
	{
		// get the right edge record of LeftRec
		pLeftEdgeRec = GetRightEdgeRec(pPI, pLeftRec);
		if (pLeftEdgeRec == NULL)
			return WEIGHT_NOT_MATCH; // error

		cchLeft = compose_length(&pPI->pwzSourceString[pLeftEdgeRec->nFT], 
								 pLeftEdgeRec->nLT - pLeftEdgeRec->nFT + 1);

		if ((bLeftPOS == POS_FUNCW || bLeftPOS == POS_POSP) && cchLeft > 1 &&
			IsCopulaEnding(pPI, pRightRec->nLeftCat))
		{
			return (pLeftRec->fWeight + pRightRec->fWeight + 0) / 3;
		}
		else 
		{
			// get the left edge record of RightRec
			pRightEdgeRec = GetLeftEdgeRec(pPI, pRightRec);
			if (pRightEdgeRec == NULL)
				return WEIGHT_NOT_MATCH; // error

			cchRight = compose_length(&pPI->pwzSourceString[pRightEdgeRec->nFT], 
									  pRightEdgeRec->nLT - pRightEdgeRec->nFT + 1);

			// (recordA in No && recordA is ENDING && Length(Lemma(recordB)) == 1) => block
			if (bLeftPOS != POS_NO || bRightPOS != POS_FUNCW || cchRight > 1)
			{
				fWeight = PredefinedMorphotactics(pPI, pLeftRec->nRightCat, pRightRec->nLeftCat);
				if (fWeight == WEIGHT_NOT_MATCH)
					return fWeight;

				return (pLeftRec->fWeight + pRightRec->fWeight + fWeight) / 3;
			}
		}
	} // if (bRightPOS == POS_FUNCW || bRightPOS == POS_POSP)
	else if (bRightPOS == POS_NO && IsLeafRecord(pRightRec))
	{
		compose_jamo(wzRight, pRightRec->wzIndex, MAX_ENTRY_LENGTH);
		
		if (IsOneJosaContent(*wzRight))
		{
			if ((bLeftPOS == POS_NC || bLeftPOS == POS_NF) && pLeftRec->cNoRec == 0)
			{	
				pRightRec->cNoRec = 0;
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
			}
		}
		else if (bLeftPOS == POS_NC || bLeftPOS == POS_NF || bLeftPOS == POS_NN)
		{
			if (pLeftRec->cNoRec == 0)
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
		else if (bLeftPOS == POS_NO)
		{
			cNoRec = pLeftRec->cNoRec + pRightRec->cNoRec;

			if (cNoRec == 2 && CheckFollwingNo(pRightRec))
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
	} // if (bRightPOS == POS_NO)
	else if (bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN)
	{
		if (bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN)
		{
			return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
		else if (bLeftPOS == POS_NO)
		{
			// only if query time, then don't match No + Noun
			if (fQuery)
				return WEIGHT_NOT_MATCH;
			
			compose_jamo(wzLeft, pLeftRec->wzIndex, MAX_ENTRY_LENGTH);	
			
			if (pRightRec->cNoRec == 0 && pLeftRec->nFT == 0 && 
				IsLeafRecord(pLeftRec) && IsNoPrefix(*wzLeft))
				return (pLeftRec->fWeight + pRightRec->fWeight + 10) / 3;
		}
	} // if (bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN)

	return WEIGHT_NOT_MATCH;
}

// GetWeightFromPOS
//
// get the base weight value from POS
//
// Parameters:
// bPOS -> (BYTE) Part of Speech of record
//
// Result:
//  (int) defined weight value
//
// 30MAR00  bhshin  began
int GetWeightFromPOS(BYTE bPOS)
{
	if (bPOS == POS_NF)
		return WEIGHT_POS_NF;

	if (bPOS == POS_NO)
		return WEIGHT_POS_NO;

	// others (NC, NN, VA, IJ, IX, FUNCW, POSP)
	return WEIGHT_POS_OTHER;
}

// PredefinedMorphotactics
//
// check pre-defined(lexicon) morphotactics
//
// Parameters:
//  pPI				-> (PARSE_INFO*) ptr to parse-info struct
//  wLeftCat		-> (WORD) category(POS+Infl) of left record
//  wRightCat		-> (WORD) category(POS+Infl) of right record
//
// Result:
//  (float) -1 if not matched, otherwise return WEIGHT_PRE_MORPHO(10)
//
// 30MAR00  bhshin  began
float PredefinedMorphotactics(PARSE_INFO *pPI, WORD wLeftCat, WORD wRightCat)
{
	LEXICON_HEADER *pLex;
	unsigned char *pIndex;
	unsigned char *pRules;
	BYTE bRightPOS, bRightInfl, bLeftPOS, bLeftInfl;
	int nStart, nEnd;

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return WEIGHT_NOT_MATCH;

	bLeftPOS = HIBYTE(wLeftCat);
	bLeftInfl = LOBYTE(wLeftCat);

	bRightPOS = HIBYTE(wRightCat);
	bRightInfl = LOBYTE(wRightCat);

	// we just accept NOUN/VA.
	if (bLeftPOS == POS_IJ || bLeftPOS == POS_IX || bLeftPOS == POS_FUNCW || bLeftPOS == POS_POSP)
		return WEIGHT_NOT_MATCH;
	
	if (bRightPOS == POS_FUNCW)
	{
		pIndex = (unsigned char*)pLex;
		pIndex += pLex->rgnEndIndex;

		pRules = (unsigned char*)pLex;
		pRules += pLex->rgnEndRule;
	}
	else
	{
		ATLASSERT(bRightPOS == POS_POSP);

		// it should be NOUN
		if (bLeftPOS != POS_NF && bLeftPOS != POS_NC &&
			bLeftPOS != POS_NO && bLeftPOS != POS_NN)
			return WEIGHT_NOT_MATCH;

		pIndex = (unsigned char*)pLex;
		pIndex += pLex->rgnPartIndex;

		pRules = (unsigned char*)pLex;
		pRules += pLex->rgnPartRule;
	}

	nStart = (*(pIndex + bRightInfl*2) << 8) | *(pIndex + bRightInfl*2 + 1);
	nEnd = (*(pIndex + (bRightInfl+1)*2) << 8) | *(pIndex + (bRightInfl+1)*2 + 1);

	for (int i = nStart; i < nEnd; i++)
	{
		if (*(pRules + i) == 0xFF)
		{
			i++;
			
			// it should be NOUN
			if (bLeftPOS == POS_NF || bLeftPOS == POS_NC ||
				bLeftPOS == POS_NO || bLeftPOS == POS_NN)
			{
				if (*(pRules + i) == bLeftInfl)
					return WEIGHT_HARD_MATCH;
			}
		}
		else
		{
			// if no leading 0xFF and right is Ending, then left should be VA.
			if (bRightPOS == POS_FUNCW && bLeftPOS != POS_VA)
				continue;

			if (*(pRules + i) == bLeftInfl)
				return WEIGHT_HARD_MATCH;
		}
	}

	return WEIGHT_NOT_MATCH;
}

//===============================
// CLASS XX table
//===============================

#define NUM_OF_VAINFL	52

static const BYTE rgClassXX[] = {
	0, // reserved
	1, // INFL_VERB_NULL
	0, // INFL_VERB_REG0
	0, // INFL_VERB_REG1
	0, // INFL_VERB_REG2
	1, // INFL_VERB_REG3
	1, // INFL_VERB_REG4
	0, // INFL_VERB_REG5
	0, // INFL_VERB_P0	
	0, // INFL_VERB_P1	
	1, // INFL_VERB_P2	
	0, // INFL_VERB_T0	
	0, // INFL_VERB_T1	
	0, // INFL_VERB_L0	
	0, // INFL_VERB_L1	
	0, // INFL_VERB_YE0	
	1, // INFL_VERB_YE1	
	1, // INFL_VERB_YE2	
	0, // INFL_VERB_S0	
	0, // INFL_VERB_S1	
	0, // INFL_VERB_LU0	
	1, // INFL_VERB_LU1	
	0, // INFL_VERB_U0	
	1, // INFL_VERB_U1	
	0, // INFL_VERB_LE0	
	1, // INFL_VERB_LE1	
	0, // INFL_VERB_WU0	
	1, // INFL_VERB_WU1	
	
	0, // INFL_ADJ_REG0	
	0, // INFL_ADJ_REG1	
	0, // INFL_ADJ_REG2	
	1, // INFL_ADJ_REG3	
	1, // INFL_ADJ_REG4	
	0, // INFL_ADJ_REG5	
	0, // INFL_ADJ_P0
	0, // INFL_ADJ_P1
	1, // INFL_ADJ_P2
	0, // INFL_ADJ_L0
	0, // INFL_ADJ_L1
	0, // INFL_ADJ_YE0
	1, // INFL_ADJ_YE1
	1, // INFL_ADJ_YE2
	0, // INFL_ADJ_S0
	0, // INFL_ADJ_S1
	0, // INFL_ADJ_LU0
	1, // INFL_ADJ_LU1
	0, // INFL_ADJ_U0
	1, // INFL_ADJ_U1
	0, // INFL_ADJ_LE0
	1, // INFL_ADJ_LE1
	0, // INFL_ADJ_H0
	0, // INFL_ADJ_H1
	1, // INFL_ADJ_H2
	0, // INFL_ADJ_ANI0
};


// IsClassXXCat
//
// check category included in ClassXX
//
// Parameters:
//  wCat		-> (WORD) category(POS+Infl) 
//
// Result:
//  (BOOL) return TRUE if ClassXX, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL IsClassXXCat(WORD wCat)
{
	BYTE bPOS = HIBYTE(wCat);
	BYTE bInfl = LOBYTE(wCat);

	if (bPOS != POS_VA)
		return FALSE;

	if (bInfl >= NUM_OF_VAINFL)
		return FALSE;

	return rgClassXX[bInfl];
}

// IsCopulaEnding
//
// check input category is copula ending
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  wCat		-> (WORD) category(POS+Infl) 
//
// Result:
//  (BOOL) return TRUE if Copular Ending, otherwise return FALSE
//
// 30MAR00  bhshin  began
BOOL IsCopulaEnding(PARSE_INFO *pPI, WORD wCat)
{
	LEXICON_HEADER *pLex;
	unsigned char *pCopulaEnd;
	BYTE bPOS, bInfl;

	bPOS = HIBYTE(wCat);
	bInfl = LOBYTE(wCat);

	// check ENDING
	if (bPOS != POS_FUNCW)
		return FALSE;

	// lookup copula table

	pLex = (LEXICON_HEADER*)pPI->lexicon.pvData;
	if (pLex == NULL)
		return FALSE;

	pCopulaEnd = (unsigned char*)pLex;
	pCopulaEnd += pLex->rgnCopulaEnd;

	return *(pCopulaEnd + bInfl);
}

// CheckVaFollowNoun
//
// check this VA record can follow Noun
//
// Parameters:
//  pWordRec -> (WORD_REC*) input VA record
//
// Result:
//  (BOOL) return TRUE if it can follow Noun, otherwise return FALSE
//
// 17APR00  bhshin  began
BOOL CheckVaFollowNoun(WORD_REC *pWordRec)
{
	WCHAR *pwzIndex;
	WCHAR wzIndex[MAX_INDEX_STRING];
	BOOL fStop, fResult;
	WCHAR wchPrev, wchCurr;
	
	if (pWordRec == NULL)
		return FALSE;

	// make string to compare
	compose_jamo(wzIndex, pWordRec->wzIndex, MAX_INDEX_STRING);

	// automata
	pwzIndex = wzIndex;

	fResult = FALSE;
	fStop = FALSE;
	wchPrev = L'\0';
	
	//====================================
	// //   //
	// /
	// /    /
	// /
	//          
	// /
	// /////
	// //
	//====================================
	while (*pwzIndex != L'\0')
	{
		wchCurr = *pwzIndex;

		switch (wchPrev)
		{
		case L'\0':
			// 
			if (wcsrchr(L"\xD558\xD574\xB418\xB3FC\xBC1B\xC5C6\xAC19\xC788\xC9D3\xC9C0\xB2F5 ", wchCurr))	
				fResult = TRUE;
			// 
			else if (wcsrchr(L"\xB2F9\xC2DC\xB4DC\xB9CC\xC2A4\xB2E4 ", wchCurr) == NULL)
				fStop = TRUE;
			break;
		case 0xD558: // 
			if (wchCurr != 0xC5EC)	// 
				fStop = TRUE;
			break;
		case 0xB2F9: // 
			if (wchCurr == 0xD558 || wchCurr == 0xD574) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xC2DC: // 
			if (wchCurr == 0xD0A4 || wchCurr == 0xCF1C) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xB4DC: // 
			if (wchCurr == 0xB9AC || wchCurr == 0xB824) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xB9CC: // 
			if (wchCurr == 0xB4E4  || wchCurr == 0xB4DC) // , 
			{
				fResult = TRUE;
				wchCurr = 0xB4E4; // '' make automata ambiguous, so change it to 
			}
			else
				fStop = TRUE;
			break;
		case 0xC2A4: // 
			if (wchCurr == 0xB7FD || wchCurr == 0xB7F0 || wchCurr == 0xB808) // , , 
				fResult = TRUE;
			else if (wchCurr != 0xB7EC) // 
				fStop = TRUE;
			break;
		case 0xB7EC: // 
			if (wchCurr == 0xC6B0 || wchCurr == 0xC6CC || wchCurr == 0xC774) // , , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		case 0xB2E4: // 
			if (wchCurr == 0xC6B0 || wchCurr == 0xC6CC) // , 
				fResult = TRUE;
			else
				fStop = TRUE;
			break;
		default:
			fStop = TRUE;
			break;
		}
		
		if (fStop)
			return FALSE;

		wchPrev = wchCurr;

		pwzIndex++;
	}
	
	return fResult;
}

// CheckFollwingNo
//
// check No [ ] to combine
//
// Parameters:
//  pRightRec -> (WORD_REC*) right record
//
// Result:
//  (BOOL) return TRUE if it's [ ], otherwise return FALSE
//
// 02JUN00  bhshin  began
BOOL CheckFollwingNo(WORD_REC *pRightRec)
{
	int cchIndex;
	WCHAR *pwzIndex;

	if (pRightRec == NULL)
		return FALSE;

	// check right record
	pwzIndex = pRightRec->wzIndex;
	if (pwzIndex == NULL)
		return FALSE;

	cchIndex = wcslen(pwzIndex);
	if (cchIndex < 3)
		return FALSE;

	// recordB = [] (0x1102 + 0x1175 + 0x11B7)
	// recordB = [] (0x1103 + 0x1173 + 0x11AF)
	if ((pwzIndex[0] == 0x1102 &&
		 pwzIndex[1] == 0x1175 &&
		 pwzIndex[2] == 0x11B7) ||
		
		(pwzIndex[0] == 0x1103 && 
		 pwzIndex[1] == 0x1173 && 
		 pwzIndex[2] == 0x11AF))
	{
		return TRUE;
	}

	return FALSE;
}

// CheckValidFinal
//
// check input record is valid as final
//
// Parameters:
//  pPI			-> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (BOOL) return TRUE if it's valid final, otherwise return FALSE
//
// 17APR00  bhshin  began
BOOL CheckValidFinal(PARSE_INFO *pPI, WORD_REC *pWordRec)
{
	int nLT;
	WORD wRightCat;

	if (pWordRec == NULL)
		return FALSE;

	nLT = pWordRec->nLT;
	wRightCat = pWordRec->nRightCat;

	if (nLT == pPI->nMaxLT && HIBYTE(wRightCat) == POS_VA && !IsClassXXCat(wRightCat))
		return FALSE;
		
	return TRUE;
}

// GetRightEdgeRec
//
// find the right most record and copy the index string of found record
//
// Parameters:
//  pPI		 -> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (WORD_REC*) return NULL if error occurs
//
// 01JUN00  bhshin  began
WORD_REC* GetRightEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec)
{
	int nRightChild;
	WORD_REC *pRightRec;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	pRightRec = pWordRec;
	nRightChild = pWordRec->nRightChild;

	while (nRightChild != 0)
	{
		pRightRec = &pPI->rgWordRec[nRightChild];
		if (pRightRec == NULL)
			return FALSE;
		
		nRightChild = pRightRec->nRightChild;
	}

	return pRightRec;	
}

// GetLeftEdgeRec
//
// find the left edge record and copy the index string of found record
//
// Parameters:
//  pPI		 -> (PARSE_INFO*) ptr to parse-info struct
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (WORD_REC*) return NULL if error occurs
//
// 01JUN00  bhshin  began
WORD_REC* GetLeftEdgeRec(PARSE_INFO *pPI, WORD_REC *pWordRec)
{
	int nLeftChild;
	WORD_REC *pLeftRec;
	
	if (pPI == NULL || pWordRec == NULL)
		return FALSE;

	pLeftRec = pWordRec;
	nLeftChild = pWordRec->nLeftChild;

	while (nLeftChild != 0)
	{
		pLeftRec = &pPI->rgWordRec[nLeftChild];
		if (pLeftRec == NULL)
			return FALSE;
		
		nLeftChild = pLeftRec->nLeftChild;
	}

	return pLeftRec;	
}

// IsLeafRecord
//
// check input record has no child record
//
// Parameters:
//  pWordRec -> (WORD_REC*) input record to check
//
// Result:
//  (WORD_REC*) return TRUE if it has no child
//
// 05JUN00  bhshin  began
BOOL IsLeafRecord(WORD_REC *pWordRec)
{
	if (pWordRec == NULL)
		return FALSE; // error

	if (pWordRec->nLeftChild != 0 || pWordRec->nRightChild != 0)
		return FALSE; // child exist

	// it can have functional child record
	if (pWordRec->nLeftCat != pWordRec->nRightCat)
		return FALSE; // child exit

	return TRUE; // it has no child
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\record.cpp ===
// Record.cpp
// record maintenance routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  30 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Record.h"
#include "Unikor.h"

// =======================
// internal helper function
// =======================

int comp_index_str(const WCHAR *src, const WCHAR *dst)
{
	int ret = 0;

	while (*dst)
	{
		if (*src == L'.')
			src++;

		if (*dst == L'.')
			dst++;

		if (ret = (int)(*src - *dst))
			break;

		src++;
		dst++;
	}

	if (ret == 0)
		ret = *src;

    if (ret < 0)
		ret = -1 ;
    else if (ret > 0)
        ret = 1 ;

    return ret;
}

// =======================
// Initialization Routines
// =======================

// InitRecords
//
// initialize the record-related members in the PARSE_INFO struct to
// a reasonable default value.
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void InitRecords(PARSE_INFO *pPI)
{
    pPI->nMaxRec = 0;
	pPI->rgWordRec = NULL;
}

// UninitRecords
//
// cleanup any record-related members in the PARSE_INFO struct
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (void)
//
// 20MAR00  bhshin  began
void UninitRecords(PARSE_INFO *pPI)
{
	pPI->nMaxRec = 0;

	if (pPI->rgWordRec != NULL)
		free(pPI->rgWordRec);
	pPI->rgWordRec = NULL;
}

// ClearRecords
//
// init/re-init the record structures.
//
// this should be called once before each sentence is processed
//
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//
// Result:
//  (BOOL) TRUE if succeed, FALSE otherwise
//
// 20MAR00  bhshin  began
BOOL ClearRecords(PARSE_INFO *pPI)
{
    // allocate new WordRec (or re-use an existing one)
    if (pPI->rgWordRec == NULL)
    {
        pPI->nMaxRec = RECORD_INITIAL_SIZE;
        pPI->rgWordRec = (WORD_REC*)malloc(pPI->nMaxRec * sizeof(WORD_REC));
        if (pPI->rgWordRec == NULL)
        {
            pPI->nMaxRec = 0;
            return FALSE;
        }
    }

	pPI->nCurrRec = MIN_RECORD;

	return TRUE;
}

// =========================
// Adding / Removing Records
// =========================

// AddRecord
//
// add a new record
// 
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//  pRec    -> (RECORD_INFO*) ptr to record info struct for new record
//
// Result:
//  (int) 0 if error occurs, otherwise return record index
//
// 30MAR00  bhshin  changed return type (BOOL -> index)
// 20MAR00  bhshin  began
int AddRecord(PARSE_INFO *pPI, RECORD_INFO *pRec)
{
    int nNewRecord;
    unsigned short nFT, nLT;
	unsigned char nDict;
	unsigned short nLeftCat, nRightCat;
	unsigned short nLeftChild, nRightChild;
    const WCHAR *pwzIndex;
	float fWeight;
	int cNounRec;
	int cNoRec;
	int curr;
	BYTE bLeftPOS, bRightPOS;

    nFT = pRec->nFT;
    nLT = pRec->nLT;
    fWeight = pRec->fWeight;
	nDict = pRec->nDict;
	nLeftCat = pRec->nLeftCat;
	nRightCat = pRec->nRightCat;
	nLeftChild = pRec->nLeftChild;
	nRightChild = pRec->nRightChild;
	cNoRec = pRec->cNoRec;
	cNounRec = pRec->cNounRec;
	pwzIndex = pRec->pwzIndex;

	bLeftPOS = HIBYTE(nLeftCat);
	bRightPOS = HIBYTE(nRightCat);

    if (pPI->rgWordRec == NULL)
	{
		ATLTRACE("rgWordRec == NULL\n");
		return 0;
	}

	// make sure this isn't a duplicate of another record
	for (curr = MIN_RECORD; curr < pPI->nCurrRec; curr++)
	{
		if (pPI->rgWordRec[curr].nFT == nFT && 
			pPI->rgWordRec[curr].nLT == nLT)
		{
            // exact index string match
			/*
			if (pPI->rgWordRec[curr].nRightCat == nRightCat &&
				pPI->rgWordRec[curr].nLeftCat == nLeftCat && 
				wcscmp(pPI->rgWordRec[curr].wzIndex, pwzIndex) == 0)
			{
				// duplicate record found
				return curr; 
			}
			*/

			// Nf, just one Noun and compare index string 
			if (pPI->rgWordRec[curr].cNounRec == 1 &&
				comp_index_str(pPI->rgWordRec[curr].wzIndex, pwzIndex) == 0)
			{
				if (HIBYTE(pPI->rgWordRec[curr].nLeftCat) == POS_NF &&
					HIBYTE(pPI->rgWordRec[curr].nRightCat) == POS_NF &&
					(bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN) &&
					(bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN))
				{
					return curr;
				}
				else if (HIBYTE(pPI->rgWordRec[curr].nLeftCat) == POS_NF &&
						 (bLeftPOS == POS_NF || bLeftPOS == POS_NC || bLeftPOS == POS_NN) &&
						 pPI->rgWordRec[curr].nRightCat == nRightCat)
				{
					return curr;
				}
				else if (HIBYTE(pPI->rgWordRec[curr].nRightCat) == POS_NF &&
						 (bRightPOS == POS_NF || bRightPOS == POS_NC || bRightPOS == POS_NN) &&
						 pPI->rgWordRec[curr].nLeftCat == nLeftCat)
				{
					return curr;
				}
			}
		}
	}

    // make sure there's enough room for the new record
	if (pPI->nCurrRec >= pPI->nMaxRec)
	{
        // alloc some more space in the array
        int nNewSize = pPI->nMaxRec + RECORD_CLUMP_SIZE;
        void *pNew;
        pNew = realloc(pPI->rgWordRec, nNewSize * sizeof(WORD_REC));
        if (pNew == NULL)
        {
    		ATLTRACE("unable to malloc more records\n");
	    	return 0;
        }

        pPI->rgWordRec = (WORD_REC*)pNew;
        pPI->nMaxRec = nNewSize;
	}

    nNewRecord = pPI->nCurrRec;
    pPI->nCurrRec++;

	pPI->rgWordRec[nNewRecord].nFT = nFT;
	pPI->rgWordRec[nNewRecord].nLT = nLT;
	pPI->rgWordRec[nNewRecord].fWeight = fWeight;
	pPI->rgWordRec[nNewRecord].nDict = nDict;
	pPI->rgWordRec[nNewRecord].nLeftCat = nLeftCat;
	pPI->rgWordRec[nNewRecord].nRightCat = nRightCat;
	pPI->rgWordRec[nNewRecord].nLeftChild = nLeftChild;
	pPI->rgWordRec[nNewRecord].nRightChild = nRightChild;
	pPI->rgWordRec[nNewRecord].cNoRec = cNoRec;
	pPI->rgWordRec[nNewRecord].cNounRec = cNounRec;

	// copy index string
	if (wcslen(pwzIndex) >= MAX_INDEX_STRING)
	{
		ATLTRACE("index string is too long\n");
		pwzIndex = L"";	// empty index string
	}

	wcscpy(pPI->rgWordRec[nNewRecord].wzIndex, pwzIndex);

	return nNewRecord;
}

// DeleteRecord
//
// delete the given record
// 
// Parameters:
//  pPI     -> (PARSE_INFO*) ptr to parse-info struct
//  nRecord -> (int) index of the record to remove
//
// Result:
//  (void) 
//
// 20MAR00  bhshin  began
void DeleteRecord(PARSE_INFO *pPI, int nRecord)
{
	// don't attempt to delete records twice
    if (pPI->rgWordRec[nRecord].nDict == DICT_DELETED)
        return;

	// just mark delete record
	pPI->rgWordRec[nRecord].nDict = DICT_DELETED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A6BE11CB_1933_40BA_B930_0B3CDA65DC1B__INCLUDED_)
#define AFX_STDAFX_H__A6BE11CB_1933_40BA_B930_0B3CDA65DC1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "globals.h"
#include "cierror.h"
#include "wblog.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A6BE11CB_1933_40BA_B930_0B3CDA65DC1B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\record.h ===
// Record.h
// record maintenance routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  02 JUN 2000   bhshin    add cNounRec, cNoRec entry in RECORD_INFO
//  17 MAR 2000	  bhshin	created

#ifndef _RECORD_H
#define _RERORD_H

// the number of records (in pWordRec) that we should allocate in a clump.
// this is used whenever we need to re-alloc the array
#define RECORD_INITIAL_SIZE 100
#define RECORD_CLUMP_SIZE   100

// the index of the first "real" record (0 is reserved)
#define MIN_RECORD  1

// nDict types
#define DICT_DELETED    0       // deleted record
#define DICT_FOUND      1       // found in dictionary
#define DICT_ADDED		2		// added while morphotactics processing 

// info about new record to create
typedef struct tagRECORD_INFO
{
	unsigned short nFT, nLT;
	unsigned char nDict;
	unsigned short nLeftCat, nRightCat;
	unsigned short nLeftChild, nRightChild;
	const WCHAR *pwzIndex;
	float fWeight;
	int cNounRec, cNoRec;
} RECORD_INFO;

// utility functions
// =====================
inline 
int IsNounPOS(int nPOS)
{ 
	return (nPOS == POS_NF || nPOS == POS_NC || nPOS == POS_NO || nPOS == POS_NN); 
}

// =======================
// Initialization Routines
// =======================

void InitRecords(PARSE_INFO *pPI);
void UninitRecords(PARSE_INFO *pPI);
BOOL ClearRecords(PARSE_INFO *pPI);

// =========================
// Adding / Removing Records
// =========================

int AddRecord(PARSE_INFO *pPI, RECORD_INFO *pRec);
void DeleteRecord(PARSE_INFO *pPI, int nRecord);

#endif // #ifndef _RECORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by KorWbrk.rc
//
#define IDS_PROJNAME                    100
#define IDR_WORDBREAKER                 101
#define IDR_STEMMER                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\token.h ===
// Token.h
// Tokenizing routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

#ifndef _TOEKN_H
#define _TOKEN_H

extern "C"
{
#include "ctplus.h"
}

void Tokenize(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur, 
			  WT *pType, int *pcchTextProcessed, int *pcchHanguel);

int CheckURLPrefix(const WCHAR *pwzIndex, int cchIndex);
int GetWordPhrase(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur);

// fIsWhiteSpace
inline int
fIsWhiteSpace(WCHAR wch)
{
	// TAB, SPACE, Ideography Space
	return  (wch == 0x0009 || wch == 0x0020 || wch == 0x3000);
}

// fIsParamark
inline int
fIsParamark(WCHAR wch)
{
	return  (wch == 0x000d || wch == 0x000a);
}

// fIsWS
inline int
fIsWS(WCHAR wch)
{
	return (fIsWhiteSpace(wch) || fIsParamark(wch) || wch == 0x0000);
}

// fIsCH
inline int
fIsCH(WCHAR wch)
{
	BYTE  ct;
	
	ct = GetCharType(wch);

	return (ct == CH || ct == VC);
}

// fIsDelimeter
inline int
fIsDelimeter(WCHAR wch)
{
	// : ; & + ^ ~ @ " " *
	switch (wch)
	{
	case 0x003A: // :
	case 0xFF1A: // full width :
	case 0x003B: // ;
	case 0xFF1B: // full width ;
	case 0x0026: // &
	case 0xFF06: // full width &
	case 0x002B: // +
	case 0xFF0B: // full width +
	case 0x005E: // ^
	case 0xFF3E: // full width ^
	case 0x007E: // ~
	case 0xFF5E: // full width ~
	case 0x0040: // @
	case 0xFF20: // full width @
	case 0x0022: // "
	case 0x201C: // left double quotation mark
	case 0x201D: // right double quotation mark
	case 0xFF02: // full width "
	case 0x002A: // *
	case 0xFF0A: // full width *
		return TRUE;
	default:
		break;
	}

	return FALSE;
}

// fIsPunc
inline int
fIsPunc(WCHAR wch)
{
	return (wch == 0x0021 || wch == 0x002C || wch == 0x002E || wch == 0x003F ||
		    wch == 0x201A || wch == 0x2026 || wch == 0x3002 ||
			wch == 0xFF01 || wch == 0xFF0C || wch == 0xFF0E || wch == 0xFF1F);
}

// fIsGroupStart
inline int
fIsGroupStart(WCHAR wchChar)
{
	BOOL fGroupStart = FALSE;
	
	switch (wchChar)
	{
	case 0x0022: // "
	case 0x0027: // '
	case L'(':
	case L'{':
	case L'[':
	case L'<':
	case 0x2018: // left single quotation mark
	case 0x201C: // left double quotation mark
	case 0xFF08: // fullwidth '('
	case 0xFF5B: // fullwidth '{'
	case 0xFF3B: // fullwidth '['
	case 0xFF1C: // fullwidth '<'
	case 0x3008: // CJK punctuation '<'
	case 0x300A: // CJK punctuation double '<'
	case 0x300C: // CJK corner bracket
	case 0x300E: // White cornder bracket
	case 0x3010: // Lenticular bracket
	case 0x3014: // Shell bracket
		fGroupStart = TRUE;
		break;
	default:
		break;
	}

	return fGroupStart;
}

// fIsGroupEnd
inline int
fIsGroupEnd(WCHAR wchChar)
{
	BOOL fGroupEnd = FALSE;
	
	switch (wchChar)
	{
	case 0x0022: // "
	case 0x0027: // '
	case L')':
	case L'}':
	case L']':
	case L'>':
	case 0x2019: // right single quotation mark
	case 0x201D: // right double quotation mark
	case 0xFF09: // fullwidth ')'
	case 0xFF5D: // fullwidth '}'
	case 0xFF3D: // fullwidth ']'
	case 0xFF1E: // fullwidth '>'
	case 0x3009: // CJK punctuation '>'
	case 0x300B: // CJK punctuation double '>'
	case 0x300D: // CJK corner bracket
	case 0x300F: // White cornder bracket
	case 0x3011: // Lenticular bracket
	case 0x3015: // Shell bracket
		fGroupEnd = TRUE;
		break;
	default:
		break;
	}

	return fGroupEnd;
}

//fIsGroup
inline int
fIsGroup(WCHAR wchChar)
{
	return (fIsGroupStart(wchChar) || fIsGroupEnd(wchChar));
}

//fIsAlpha
inline int
fIsAlpha(WCHAR wchChar)
{
	return ((wchChar >= L'A' && wchChar <= L'Z') || 
		    (wchChar >= L'a' && wchChar <= L'z') ||
			(wchChar >= 0x00C0 && wchChar <= 0x0217));
}

//fIsColon
inline int
fIsColon(WCHAR wchChar)
{
	return (wchChar == L':');
}

//fIsSlash
inline int
fIsSlash(WCHAR wchChar)
{
	return (wchChar == L'/');
}



#endif // #ifndef _TOEKN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\token.cpp ===
// Token.cpp
// Tokenizing routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "Token.h"

// Tokenize
//
// tokenize input TEXT_SOURCE buffer and return token type 
// and processed string length
//
// Parameters:
//  bMoreText			-> (BOOL) flag whether dependent on callback of TEXT_SOURCE or not
//  pTextSource			-> (TEXT_SOURCE*) source text information structure
//  iCur				-> (int) current buffer pos
//  pType				-> (WT*) output token type
//  pcchTextProcessed	-> (int*) output processed text length
//  pcchHanguel         -> (int*) output processed hanguel token length
//
// Result:
//  (void)
//
// 16MAR00  bhshin  porting from CWordBreaker::Tokenize
void Tokenize(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur, 
			  WT *pType, int *pcchTextProcessed, int *pcchHanguel)
{
    ULONG cwc, i;
    BYTE  ct;
    BOOL  fRomanWord = FALSE;
    BOOL  fHanguelWord = FALSE;
	BOOL  fHanjaWord = FALSE;
    const WCHAR *pwcInput, *pwcStem;

    *pcchTextProcessed = 0;
	*pcchHanguel = 0;
    *pType =  WT_START;

	cwc = pTextSource->iEnd - iCur;
    pwcStem = pwcInput = pTextSource->awcBuffer + iCur;

    for (i = 0; i < cwc; i++, pwcInput++) 
	{
		ct = GetCharType(*pwcInput);

		// we take VC(full width char) for CH.
		if (ct == VC)
			ct = CH;

		switch (ct) 
		{
		case CH: // alpha+num
			// check to see if there is a Hanguel word before this char
			if (fHanguelWord) 
			{
				// {Hanguel}{Romanji} -> make it one token
				fHanguelWord = FALSE;
				fRomanWord = TRUE;
				*pcchHanguel = (DWORD)(pwcInput - pwcStem);
				*pType = WT_ROMAJI;
			}

			// check to see if there is an Hanja word before this char
			if (fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			if (!fRomanWord) 
			{
				pwcStem = pwcInput;
				fRomanWord = TRUE;
				*pType = WT_ROMAJI;
			}
			break;
		case IC: // hanja case
			// check to see if there is an English word before this char
			if (fRomanWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			// check to see if there is a Hanguel word before this char
			if (fHanguelWord) 
			{
				// {Hanguel}{Romanji} -> make it one token
				fHanguelWord = FALSE;
				fHanjaWord = TRUE;
				*pcchHanguel = (DWORD)(pwcInput - pwcStem);
				*pType = WT_ROMAJI;
			}

			if (!fHanjaWord) 
			{
				pwcStem = pwcInput;
				fHanjaWord = TRUE;
				*pType = WT_ROMAJI;
			}
			break;

		case HG:
			// check to see if there is an English word before this char
			if (fRomanWord || fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			if (!fHanguelWord) 
			{
				pwcStem = pwcInput;
				fHanguelWord = TRUE;
				*pType = WT_HANGUEL;
			}
			break;
		case WS:
			if (fRomanWord && i < cwc-1 &&
				!fIsWS(*pwcInput) && fIsCH(*(pwcInput+1)) &&
				!fIsGroup(*pwcInput) && !fIsDelimeter(*pwcInput))
			{
				// add symbol
				break;
			}

			// handle "http://"
			if ((fIsColon(*pwcInput) || fIsSlash(*pwcInput)) && 
				fRomanWord && i < cwc-3 &&
				CheckURLPrefix(pwcStem, (int)(pwcInput-pwcStem)+3))
			{
				// add symbol
				break;
			}
						
			if (fRomanWord || fHanguelWord || fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			*pType = WT_WORD_SEP;
			*pcchTextProcessed = 1;
			return;
		case PS:
			if (fRomanWord && i < cwc-1 &&
				!fIsWS(*pwcInput) && fIsCH(*(pwcInput+1)) &&
				!fIsGroup(*pwcInput) && !fIsDelimeter(*pwcInput))
			{
				// add symbol
				break;
			}

			if (fRomanWord || fHanguelWord || fHanjaWord) 
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			*pType = WT_PHRASE_SEP;
			*pcchTextProcessed = 1;
			return;
		default:
			if (fRomanWord || fHanguelWord || fHanjaWord)
			{
				*pcchTextProcessed = (DWORD)(pwcInput - pwcStem);
				return;
			}

			*pType = WT_WORD_SEP;
			*pcchTextProcessed = 1;
			return;
		}	
	}

	if (bMoreText) 
	{
		*pcchTextProcessed = 0;
		*pType = WT_REACHEND;
	}
	else
		*pcchTextProcessed = cwc;
}

// CheckURLPrefix
//
// check URL prefix 
//
// Parameters:
//  pwzInput	-> (const WCHAR*) input string to check
//  cchInput	-> (int) length of input string to check
//
// Result:
//  (int)	length of URL prefix string
//
// 25JUL00  bhshin  created
int CheckURLPrefix(const WCHAR *pwzInput, int cchInput)
{
	// [alpha+][:][/][/] eg) http://, ftp:// 
		
	int cchPrefix = 0;

	if (cchInput <= 0)
		return 0;

    if (!fIsAlpha(pwzInput[cchPrefix]))
    {
        return 0;
    }

    while (cchPrefix < cchInput && fIsAlpha(pwzInput[cchPrefix])) 
    {
        cchPrefix++;
    }

    if (cchPrefix >= cchInput || !fIsColon(pwzInput[cchPrefix]))
    {
        return 0;
    }

	cchPrefix++;

    if (cchPrefix >= cchInput || !fIsSlash(pwzInput[cchPrefix]))
    {
        return 0;
    }
    
	cchPrefix++;

    if (cchPrefix >= cchInput || !fIsSlash(pwzInput[cchPrefix]))
    {
        return 0;
    }

	cchPrefix++;

	return cchPrefix;
}

// GetWordPhrase
//
// check URL prefix 
//
// Parameters:
//  bMoreText			-> (BOOL) flag whether dependent on callback of TEXT_SOURCE or not
//  pTextSource			-> (TEXT_SOURCE*) source text information structure
//  iCur				-> (int) current buffer pos
//
// Result:
//  (int)	length of word phrase
//
// 01AUG00  bhshin  created
int GetWordPhrase(BOOL bMoreText, TEXT_SOURCE *pTextSource, int iCur)
{
	WT Type;
	int iPos, cchToken, cchHg;
	int cchProcessed;
	
	cchProcessed = 0;
	iPos = iCur;

	while (TRUE)
	{
		Tokenize(FALSE, pTextSource, iPos, &Type, &cchToken, &cchHg);

		if (Type != WT_HANGUEL && Type != WT_ROMAJI)
			break;

		cchProcessed += cchToken;
		iPos += cchToken;
	}

	return cchProcessed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 8
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc                 // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord,           // Word for which we're looking
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc,                // Max characters in buffer (including NULL)
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                // Returned values
        BYTE       *pbValid             // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                // Trie in which to find prefix range
        wchar_t    *pwszWord,           // Prefix for which we're looking
        int        *piStart				// Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                    // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,              // buffer to hold words being enumerated
        void *pvParam,                  // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\trie.c ===
#include "trie.h"
#include "memmgr.h"

#ifndef UNDER_CE
#   include "assert.h"
#else
#   define assert(x)
#endif

#define fNLGNewMemory(pp,cb) ((*pp) = GlobalAlloc(GPTR, cb))       
#define NLGFreeMemory		 GlobalFree

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
    LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	if (lpTrieStats == NULL)
		return(NULL);

	// Check the version number.  This code currently only supports version 1 tries  

	if (lpTrieStats->version > 1)
		return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //

    if (!fNLGNewMemory(&lpTrieCtrl, sizeof(TRIECTRL)))
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //

    lpByte += lpTrieStats->cbHeader;
    lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

    lpwTables = (LPWORD)(lpTrieStats+1);

    lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

    if (lpTrieStats->cCharFlagsCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

    if (lpTrieStats->cTagsCodesMax & 1)                     // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

    if (lpTrieStats->cMRPointersCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
    lpwTables += lpTrieStats->cSROffsetsCodesMax;

    if (lpTrieStats->cSROffsetsCodesMax & 1)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
    lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

    lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueTags);

    lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

    lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    if ((LPBYTE)lpwTables - (LPBYTE)lpTrieStats != (int)lpTrieStats->cbHeader)
	{	
		NLGFreeMemory(lpTrieCtrl);		
		return NULL;
	}

    //
    // Init trie pointers
    //

    lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

    return (void *)lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //

    NLGFreeMemory(lpTrieCtrl);
}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, WORD *pcCodes, unsigned char *pbData)
{
    int cBytes = 0;
    WORD wCode = 0, wiSymbol = 0;

    /* At each stage in this loop, we're trying to see if we've got a length-n code.
    dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
    we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
    the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
        wCode += *pbData++;
        ++cBytes;

        if (wCode < *pcCodes)
        {
			break;
        }
        wiSymbol += *pcCodes;
        wCode -= *pcCodes++;
        wCode <<= 8;
    }

    /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
    dwiSymbol, because we've already added the counts of the shorter codes to it. */

    wiSymbol += wCode;

    *piSymbol = wiSymbol;

    return cBytes;
}

DWORD Get3ByteAddress(BYTE *pb)
{
    return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the trie */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
    }

    /* Decompress the char/flags */

    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
    lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
    lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

    // Decompress skip enumeration

    if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cSkipWords = dwCode;
    }

    /* Code to decompress enumeration goes here */

    if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cWords = dwCode;

		// Decompress the tagged enumeration counts

        wMask = 1;
        for (iTag = 0; iTag < MAXTAGS; iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
            {
            // Values greater than 127 are really 15 or 21 bit values.

                dwCode = (DWORD) *lpTrieScan->lpbNode++;

                if (dwCode >= 0x00c0)
                {
                    dwCode  = ((dwCode & 0x003f) << 15);
                    dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                    dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                }
                else if (dwCode >= 0x0080)
                    dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                lpTrieScan->aTags[iTag].cTag = dwCode;
            }
            else
                lpTrieScan->aTags[iTag].cTag = 0;

            wMask <<= 1;
        }
    }
    else
		lpTrieScan->cWords = 0;

    // Any tagged data for this node follows the counts

    lpTrieScan->wMask = 0;

    if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
    {
		// If there is only one tagged field, the mask byte won't be stored

        if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
            bMask = lpTrieCtrl->lpTrieStats->wDataMask;
        else
            bMask = *lpTrieScan->lpbNode++;

		// Now that we know which elements are stored here, pull them in their proper place

        wMask = 1;
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
            {
                lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                lpTrieScan->wMask |= wMask;
            }

            bMask  &= ~wMask;
            wMask <<= 1;
        }
    }

    // There are two flavors of right pointers: Multiref and Skip.

    if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
    {
        if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
        {
            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
            wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
        }
        else
        {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
            lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
    }
    else
        lpTrieScan->lpbRight = NULL;

    // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
    // Each requires different decompression

    if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
    {
        // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

        lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
        lpTrieScan->lpbNode += 3;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
    {
        /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

        lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
    {
        /* Multiref: The down pointer is encoded directly */

        lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                lpTrieScan->lpbNode);

        lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
    }
    else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
    {
        /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
        into this singleref segment.  So we have to keep the old one around so we can add to it */

        lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                lpTrieScan->lpbNode);

        if (lpTrieScan->lpbSRDown == 0)
        {
                lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
        }

        wOffset = lpTrieCtrl->lpwSROffsets[wCode];
        lpTrieScan->lpbSRDown += wOffset;
        lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
    }
    else
        lpTrieScan->lpbDown = NULL;

	// We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

    if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
        lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
	// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
		// Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
			// If we can follow a right pointer, do so, else fail
        
            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

		// Either we're at a soft EOS or we've followed a right pointer.
		// Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

	// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
	// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

	// If there isn't a right pointer or if the target letter is alphabetically less then
	// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
		return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
		return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Now, follow the skip pointer if exist and the alphabetic character is greater then
			// the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
			// use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

				// This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
		// If we're at the end of the buffer, fail
        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.
        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
		// If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;
                
                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, wchar_t *pwszWord, int *piStart)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         cnt;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));
	*piStart = 0;

    if (!TrieGetNextState(ptc, &ts))
        return 0;

    // Deal with special case of empty string

    if (pwszWord || !*pwszWord)
        return ptc->lpTrieStats->cWords;

    do
    {
		// Get the count of words below this prefix
        cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

		// If the node we just arrived at is valid, increment the count
        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of prefix, return the count remaining below

            if (pwszWord[ich] == L'\0')
            {
                if (bValid)
                    cnt++;

                return cnt;
            }

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return 0;
        }
        else
        {
			// Add the sub tree count.

			*piStart += cnt;

			// Try the next letter in this state

            if (!TrieGetNextNode(ptc, &ts))
                return 0;
        }

        if (bValid)
            (*piStart)++;

    } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
    TRIESCAN        ts    = *pts;
    DWORD           cTags = 0;

    if (!TrieGetNextState(ptc, &ts))
        return cTags;

    do
    {
        if (ts.wFlags & wMask)
            cTags++;

        cTags += CountTags(ptc, &ts, wMask, iTag);
    } while (TrieGetNextNode(ptc, &ts));

    return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, wchar_t *pwszWord, int iTag)
{
    TRIESCAN        ts;
    int             ich = 0;
    int             index = 0;
    BOOL            bValid;
    DWORD           wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
        bValid = ts.wFlags & wMask;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

            index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

            if (!TrieGetNextNode(ptc, &ts))
                return -1;
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
            index++;
    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cTags;
    DWORD           wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
		// If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & wMask)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.

        cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

        if (nIndex < cTags)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                                  // Advance the character position
        }
        else
        {
            nIndex -= cTags;

            if (!TrieGetNextNode(ptc, &ts))
                return FALSE;
        }
    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & wMask;                       // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
)
{
	TRIESCAN        ts;
    int             iTag;
    WORD            wMask = 1;
    BYTE            bMask = ptc->lpTrieStats->wTagsMask;

    if (!TrieCheckWord(ptc, &ts, pwszWord))
        return FALSE;

    if (ts.wFlags & TRIE_NODE_TAGGED)
    {
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
            if (ts.wMask & wMask)
            {
                    pdw[iTag] = ts.aTags[iTag].dwData;
                    bMask |= wMask;
            }

            wMask <<= 1;
        }
    }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\uni.cpp ===
// uni.cpp
// Unicode tables
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 00  bhshin   porting for WordBreaker from uni.c

#include "stdafx.h"
#include "uni.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\unikor.h ===
// unikor.h
// unicode tables and compose/decompose routines
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  21 MAR 00  bhshin   added compose_length function
//  16 MAR 00  bhshin   porting for WordBreaker from uni_kor.h

#ifndef _UNIKOR_H_
#define _UNIKOR_H_

// Conjoining Jamo range
#define HANGUL_JAMO_BASE    0x1100
#define HANGUL_JAMO_MAX     0x11F9

#define HANGUL_CHOSEONG         0x1100
#define HANGUL_CHOSEONG_MAX     0x1159
#define HANGUL_JUNGSEONG        0x1161
#define HANGUL_JUNGSEONG_MAX    0x11A2
#define HANGUL_JONGSEONG        0x11A8
#define HANGUL_JONGSEONG_MAX    0x11F9

#define HANGUL_FILL_CHO     0x115F
#define HANGUL_FILL_JUNG    0x1160

#define NUM_CHOSEONG        19  // (L) Leading Consonants
#define NUM_JUNGSEONG       21  // (V) Vowels
#define NUM_JONGSEONG       28  // (T) Trailing Consonants

// Compatibility Jamo range
#define HANGUL_xJAMO_PAGE   0x3100
#define HANGUL_xJAMO_BASE   0x3131
#define HANGUL_xJAMO_MAX    0x318E

// Pre-composed forms
#define HANGUL_PRECOMP_BASE 0xAC00
#define HANGUL_PRECOMP_MAX  0xD7A3

// Halfwidth compatibility range
#define HANGUL_HALF_JAMO_BASE   0xFFA1
#define HANGUL_HALF_JAMO_MAX    0xFFDC

// function prototypes
void decompose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, CHAR_INFO_REC *rgCharInfo, int nMaxDst);
int compose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, int nMaxDst);
int compose_length(const WCHAR *wszInput);
int compose_length(const WCHAR *wszInput, int cchInput);

// fIsHangulJamo
//
// return TRUE if the given char is a hangul jamo char
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsHangulJamo(WCHAR wch)
{
    return (wch >= HANGUL_JAMO_BASE && wch <= HANGUL_JAMO_MAX) ? TRUE : FALSE;
}


// fIsHangulSyllable
//
// return TRUE if the given char is a precomposed hangul syllable
//
// 23NOV98  GaryKac  began
__inline int
fIsHangulSyllable(WCHAR wch)
{
    return (wch >= HANGUL_PRECOMP_BASE && wch <= HANGUL_PRECOMP_MAX) ? TRUE : FALSE;
}


// fIsOldHangulJamo
//
// return TRUE if the given char is a old (compatibility) Jamo with
// no conjoining semantics
//
// 23NOV98  GaryKac  began
__inline int
fIsOldHangulJamo(WCHAR wch)
{
    return (wch >= HANGUL_xJAMO_BASE && wch <= HANGUL_xJAMO_MAX) ? TRUE : FALSE;
}


// fIsHalfwidthJamo
//
// return TRUE if the given char is a halfwidth Jamo
//
// 23NOV98  GaryKac  began
__inline int
fIsHalfwidthJamo(WCHAR wch)
{
    return (wch >= HANGUL_HALF_JAMO_BASE && wch <= HANGUL_HALF_JAMO_MAX) ? TRUE : FALSE;
}


// fIsChoSeong
//
// return TRUE if the given char is a ChoSeong (Leading Consonant)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsChoSeong(WCHAR wch)
{
    return (wch >= HANGUL_CHOSEONG && wch <= HANGUL_CHOSEONG_MAX) ? TRUE : FALSE;
}


// fIsJungSeong
//
// return TRUE if the given char is a JungSeong (Vowel)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsJungSeong(WCHAR wch)
{
    return (wch >= HANGUL_JUNGSEONG && wch <= HANGUL_JUNGSEONG_MAX) ? TRUE : FALSE;
}


// fIsJongSeong
//
// return TRUE if the given char is a JongSeong (Trailing Consonant)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 23NOV98  GaryKac  began
__inline int
fIsJongSeong(WCHAR wch)
{
    return (wch >= HANGUL_JONGSEONG && wch <= HANGUL_JONGSEONG_MAX) ? TRUE : FALSE;
}


#endif  // _UNIKOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\uni.h ===
// uni.h
// Unicode api
// Copyright 1998 Microsoft Corp.
//
// Modification History:
//  16 MAR 00  bhshin   porting for WordBreaker from uni.c

#ifndef _UNI_H_
#define _UNI_H_

#define HANGUL_CHOSEONG         0x1100
#define HANGUL_CHOSEONG_MAX     0x1159
#define HANGUL_JUNGSEONG        0x1161
#define HANGUL_JUNGSEONG_MAX    0x11A2
#define HANGUL_JONGSEONG        0x11A8
#define HANGUL_JONGSEONG_MAX    0x11F9


// fIsC
//
// return fTrue if the given char is a consonant (ChoSeong or JungSeong)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 24NOV98  GaryKac  began
__inline int
fIsC(WCHAR wch)
{
    return ((wch >= HANGUL_CHOSEONG && wch <= HANGUL_CHOSEONG_MAX) || 
		    (wch >= HANGUL_JONGSEONG && wch <= HANGUL_JONGSEONG_MAX)) ? TRUE : FALSE;
}


// fIsV
//
// return fTrue if the given char is a vowel (JongSeong)
//
// this assumes that the text has already been decomposed and
// normalized
//
// 24NOV98  GaryKac  began
__inline int
fIsV(WCHAR wch)
{
    return (wch >= HANGUL_JUNGSEONG && wch <= HANGUL_JUNGSEONG_MAX) ? TRUE : FALSE;
}


#endif  // _UNI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\wbdata.cpp ===
// WbData.cpp
//
// static data & search routines for Korean Word Breaker
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  02 JUN 2000   bhshin    added IsOneJosaContentRec helper
//  20 APR 2000	  bhshin	created

#include "StdAfx.h"
#include "KorWbrk.h"
#include "WbData.h"
#include "unikor.h"

////////////////////////////////////////////////////////////////////////////////
// Function for binary search

int BinarySearchForWCHAR(const WCHAR *pwchrgTable, int crgTable, WCHAR wchSearch)
{
	int iLeft, iRight, iMiddle;
	int nComp;
	
	iLeft = 0;
	iRight = crgTable;

	while (iLeft <= iRight) 
	{
		iMiddle = (iLeft + iRight) >> 1;
		
		nComp = pwchrgTable[iMiddle] - wchSearch;

		if (nComp < 0) 
		{
			iLeft = iMiddle + 1;
		}
		else
		{
			if (nComp == 0) 
				return iMiddle; // found
			else if (nComp > 0) 
				iRight = iMiddle - 1;
		}
	}	

	return -1; // not found
}

////////////////////////////////////////////////////////////////////////////////
// One Josa Content Word (sorted list)

static const WCHAR wchrgOneJosaContent[] = {
	0xAC00, // 
	0xAC01, // 
	0xAC04, // 
	0xAC10, // 
	0xAC1C, // 
	0xAC1D, // 
	0xAC74, // 
	0xAC8C, // 
	0xACBD, // 
	0xACC4, // 
	0xACE0, // 
	0xACF5, // 
	0xACF6, // 
	0xACFC, // 
	0xAD00, // 
	0xAD11, // 
	0xAD6C, // 
	0xAD6D, // 
	0xAD70, // 
	0xAD8C, // 
	0xAE30, // 
	0xAE38, // 
	0xAE54, // 
	0xAECF, // 
	0xAED8, // 
	0xAF34, // 
	0xAFBC, // 
	0xB098, // 
	0xB0B4, // 
	0xB124, // 
	0xB140, // 
	0xB144, // 
	0xB2E8, // 
	0xB2F4, // 
	0xB2F9, // 
	0xB300, // 
	0xB301, // 
	0xB370, // 
	0xB3C4, // 
	0xB3D9, // 
	0xB780, // 
	0xB791, // 
	0xB825, // 
	0xB839, // 
	0xB85C, // 
	0xB85D, // 
	0xB860, // 
	0xB8CC, // 
	0xB8E8, // 
	0xB958, // 
	0xB960, // 
	0xB9AC, // 
	0xB9BC, // 
	0xB9C9, // 
	0xB9CC, // 
	0xB9DD, // 
	0xB9E1, // 
	0xB9E4, // 
	0xBA74, // 
	0xBA85, // 
	0xBAA8, // 
	0xBB38, // 
	0xBB3C, // 
	0xBBFC, // 
	0xBC18, // 
	0xBC1C, // 
	0xBC29, // 
	0xBC30, // 
	0xBC31, // 
	0xBC94, // 
	0xBC95, // 
	0xBCC4, // 
	0xBCF4, // 
	0xBCF5, // 
	0xBD80, // 
	0xBD84, // 
	0xBE44, // 
	0xBED8, // 
	0xC0AC, // 
	0xC0B0, // 
	0xC0C1, // 
	0xC0C8, // 
	0xC0DD, // 
	0xC11D, // 
	0xC120, // 
	0xC124, // 
	0xC131, // 
	0xC18C, // 
	0xC190, // 
	0xC218, // 
	0xC21C, // 
	0xC220, // 
	0xC2DC, // 
	0xC2DD, // 
	0xC2E4, // 
	0xC2EC, // 
	0xC528, // 
	0xC529, // 
	0xC544, // 
	0xC548, // 
	0xC554, // 
	0xC560, // 
	0xC561, // 
	0xC591, // 
	0xC5B4, // 
	0xC5C5, // 
	0xC5EC, // 
	0xC624, // 
	0xC625, // 
	0xC639, // 
	0xC655, // 
	0xC694, // 
	0xC695, // 
	0xC6A9, // 
	0xC6D0, // 
	0xC728, // 
	0xC774, // 
	0xC778, // 
	0xC77C, // 
	0xC784, // 
	0xC790, // 
	0xC791, // 
	0xC7A5, // 
	0xC7AC, // 
	0xC801, // 
	0xC804, // 
	0xC810, // 
	0xC815, // 
	0xC81C, // 
	0xC870, // 
	0xC871, // 
	0xC885, // 
	0xC88C, // 
	0xC8FC, // 
	0xC99D, // 
	0xC9C0, // 
	0xC9C4, // 
	0xC9C8, // 
	0xC9D1, // 
	0xC9DD, // 
	0xC9F8, // 
	0xCB5D, // 
	0xCBE4, // 
	0xCC3D, // 
	0xCC44, // 
	0xCC45, // 
	0xCC98, // 
	0xCC9C, // 
	0xCCA0, // 
	0xCCA9, // 
	0xCCAD, // 
	0xCCB4, // 
	0xCD0C, // 
	0xCE21, // 
	0xCE35, // 
	0xCE58, // 
	0xD0D5, // 
	0xD1B5, // 
	0xD30C, // 
	0xD310, // 
	0xD488, // 
	0xD48D, // 
	0xD544, // 
	0xD559, // 
	0xD560, // 
	0xD56D, // 
	0xD574, // 
	0xD589, // 
	0xD615, // 
	0xD638, // 
	0xD654, // 
	0xD68C, // 
};

BOOL IsOneJosaContent(WCHAR wchInput)
{
	int cOneJosaContent = sizeof(wchrgOneJosaContent)/sizeof(wchrgOneJosaContent[0]);
	
	if (BinarySearchForWCHAR(wchrgOneJosaContent, cOneJosaContent, wchInput) == -1)
		return FALSE;
	else
		return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
// One Josa Content Word (sorted list)

static const WCHAR wchrgNoPrefix[] = {
	0xAC00, // 
	0xACE0, // 
	0xACFC, // 
	0xAD6C, // 
	0xAE09, // 
	0xB0A8, // 
	0xB2E4, // 
	0xB300, // 
	0xBB34, // 
	0xBBF8, // 
	0xBC18, // 
	0xBC31, // 
	0xBC94, // 
	0xBCF8, // 
	0xBD80, // 
	0xBD88, // 
	0xBE44, // 
	0xC0DD, // 
	0xC120, // 
	0xC131, // 
	0xC18C, // 
	0xC18D, // 
	0xC591, // 
	0xC5EC, // 
	0xC5ED, // 
	0xC5F0, // 
	0xC655, // 
	0xC694, // 
	0xC6D0, // 
	0xC7AC, // 
	0xC800, // 
	0xC8FC, // 
	0xC900, // 
	0xC904, // 
	0xC911, // 
	0xC9DD, // 
	0xCD08, // 
	0xCD1D, // 
	0xCD5C, // 
	0xCE5C, // 
	0xD070, // 
	0xD0C8, // 
	0xD1B5, // 
	0xD53C, // 
	0xD55C, // 
	0xD587, // 
	0xD5DB, // 
	0xD638, // 
};

BOOL IsNoPrefix(WCHAR wchInput)
{
	int cNoPrefix = sizeof(wchrgNoPrefix)/sizeof(wchrgNoPrefix[0]);
	
	if (BinarySearchForWCHAR(wchrgNoPrefix, cNoPrefix, wchInput) == -1)
		return FALSE;
	else
		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\wbdata.h ===
// WbData.h
//
// static data & search routines for Korean Word Breaker
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  20 APR 2000	  bhshin	created

#ifndef _WBDATA_H
#define _WBDATA_H

BOOL IsOneJosaContent(WCHAR wchInput);
BOOL IsNoPrefix(WCHAR wchInput);

#endif // #ifndef _WBDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\wblog.h ===
// WbLog.cpp
//
// wordbreaker log routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  05 JUL 2000	  bhshin	created

#ifndef _WB_LOG_H
#define _WB_LOG_H

#ifdef _WB_LOG

#define WB_LOG_INIT					WbLogInit
#define WB_LOG_UNINIT				WbLogUninit
#define WB_LOG_PRINT				WbLogPrint
#define WB_LOG_PRINT_HEADER(a)		WbLogPrintHeader(a)
#define WB_LOG_PRINT_BREAK(a)		WbLogPrintBreak(a)

#define WB_LOG_START(a,b)			g_WbLog.Init(a,b)
#define WB_LOG_END					g_WbLog.Reset
#define WB_LOG_ROOT_INDEX(a,b)		g_WbLog.SetRootIndex(a,b)
#define WB_LOG_ADD_INDEX(a,b,c)		g_WbLog.AddIndex(a,b,c)
#define WB_LOG_REMOVE_INDEX(a)      g_WbLog.RemoveIndex(a)
#define WB_LOG_PRINT_ALL			g_WbLog.PrintWbLog

void WbLogInit();
void WbLogUninit();
void WbLogPrint(LPCWSTR lpwzFormat, ...);
void WbLogPrintHeader(BOOL fQuery);
void WbLogPrintBreak(int nLen);

typedef enum _tagIndexType
{
	INDEX_QUERY = 0, // query term
	INDEX_BREAK,	 // word break, sentence break
	INDEX_PREFILTER,
	INDEX_PARSE,
	INDEX_GUESS_NOUN,
	INDEX_GUESS_NF,
	INDEX_GUESS_NAME,
	INDEX_GUESS_NAME_SSI,
	INDEX_INSIDE_GROUP,
	INDEX_SYMBOL,
} INDEX_TYPE;

typedef struct _tagLogInfo
{
	WCHAR		wzIndex[MAX_INDEX_STRING+1]; // index string
	WCHAR	    wzRoot[MAX_INDEX_STRING+1];
	INDEX_TYPE  IndexType;
	BOOL		fRootChanged;
	BOOL		fPrint;

} LOG_INFO, *pLOG_INFO;

#define MAX_LOG_NUMBER	512

class CWbLog
{
// member data
private:
	LOG_INFO   m_LogInfo[MAX_LOG_NUMBER];
	WCHAR	   m_wzSource[MAX_INDEX_STRING+1]; 
	int		   m_iCurLog;
	BOOL	   m_fInit;

	WCHAR	   m_wzRootIndex[MAX_INDEX_STRING+1]; 

// method
public:
	CWbLog(){ Reset(); }

	void Reset()
	{
		m_wzRootIndex[0] = L'\0';
		m_wzSource[0] = L'\0';
		m_iCurLog = 0;
		m_fInit = FALSE;
	}

	void Init(LPCWSTR lpwzSource, int cchTextProcessed)
	{
		int cchSrc;

		cchSrc = (cchTextProcessed > MAX_INDEX_STRING) ? MAX_INDEX_STRING : cchTextProcessed;
		
		wcsncpy(m_wzSource, lpwzSource, cchSrc);
		m_wzSource[cchTextProcessed] = L'\0';

		m_iCurLog = 0;
		
		m_wzRootIndex[0] = L'\0';

		m_fInit = TRUE;
	}

	void SetRootIndex(LPCWSTR lpwzIndex, BOOL fIsRoot);
	void AddIndex(const WCHAR *pwzIndex, int cchIndex, INDEX_TYPE typeIndex);
	void RemoveIndex(const WCHAR *pwzIndex);
	void PrintWbLog(void);
};

extern CWbLog g_WbLog;

#else

#define WB_LOG_INIT					/##/
#define WB_LOG_UNINIT				/##/
#define WB_LOG_PRINT				/##/
#define WB_LOG_PRINT_HEADER			/##/
#define WB_LOG_PRINT_BREAK			/##/

#define WB_LOG_START(a,b)			/##/
#define WB_LOG_END					/##/
#define WB_LOG_ROOT_INDEX(a,b)		/##/
#define WB_LOG_ADD_INDEX(a,b,c)		/##/
#define WB_LOG_REMOVE_INDEX(a)      /##/
#define WB_LOG_PRINT_ALL			/##/

#endif // #ifdef _WB_LOG

#endif // #ifndef _WB_LOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\unikor.cpp ===
// unikor.cpp
// Korean Unicode routines
// Copyright 1998-2000 Microsoft Corp.
//
// Modification History:
//  16 MAR 00  bhshin   porting for WordBreaker from uni_kor.c

#include "stdafx.h"
#include "unikor.h"

#pragma setlocale(".949")

// Hangul Jamo Map
// this table maps from the "conjoining jamo" area (u1100 - u11F9)
// to the compatibility Jamo area (u3131 - u318E)
//
// subtract HANGUL_JAMO_BASE (u1100) before indexing into this table
// make sure the the char is not > HANGUL_JAMO_MAX (u11F9) before indexing
//
// to build the complete Unicode character, add the value from this
// table to HANGUL_xJAMO_PAGE (u3100).
//
// 30JUN99  GaryKac  created
unsigned char g_rgchXJamoMap[] = {
    0x31,       // 1100 - 
    0x32,       // 1101 - 
    0x34,       // 1102 - 
    0x37,       // 1103 - 
    0x38,       // 1104 - 
    0x39,       // 1105 - 
    0x41,       // 1106 - 
    0x42,       // 1107 - 
    0x43,       // 1108 - 
    0x45,       // 1109 - 
    0x46,       // 110A - 
    0x47,       // 110B - 
    0x48,       // 110C - 
    0x49,       // 110D - 
    0x4A,       // 110E - 
    0x4B,       // 110F - 

    0x4C,       // 1110 - 
    0x4D,       // 1111 - 
    0x4E,       // 1112 - 
    0x64,       // 1113 -  - no match, use fill
    0x65,       // 1114 - 
    0x66,       // 1115 - 
    0x64,       // 1116 -  - no match
    0x64,       // 1117 -  - no match
    0x64,       // 1118 -  - no match
    0x64,       // 1119 -  - no match
    0x40,       // 111A - 
    0x64,       // 111B -  - no match
    0x6E,       // 111C - 
    0x71,       // 111D - 
    0x72,       // 111E - 
    0x64,       // 111F -  - no match

    0x73,       // 1120 - 
    0x44,       // 1121 - 
    0x74,       // 1122 - 
    0x75,       // 1123 - 
    0x64,       // 1124 -  - no match
    0x64,       // 1125 -  - no match
    0x64,       // 1126 -  - no match
    0x76,       // 1127 - 
    0x64,       // 1128 -  - no match
    0x77,       // 1129 - 
    0x64,       // 112A -  - no match
    0x78,       // 112B - 
    0x79,       // 112C - 
    0x7A,       // 112D - 
    0x7B,       // 112E - 
    0x7C,       // 112F - 

    0x64,       // 1130 -  - no match
    0x64,       // 1131 -  - no match
    0x7D,       // 1132 - 
    0x64,       // 1133 -  - no match
    0x64,       // 1134 -  - no match
    0x64,       // 1135 -  - no match
    0x7E,       // 1136 - 
    0x64,       // 1137 -  - no match
    0x64,       // 1138 -  - no match
    0x64,       // 1139 -  - no match
    0x64,       // 113A -  - no match
    0x64,       // 113B -  - no match
    0x64,       // 113C - no match
    0x64,       // 113D - no match
    0x64,       // 113E - no match
    0x64,       // 113F - no match

    0x7F,       // 1140 - ^
    0x64,       // 1141 -  - no match
    0x64,       // 1142 -  - no match
    0x64,       // 1143 -  - no match
    0x64,       // 1144 -  - no match
    0x82,       // 1145 - 
    0x83,       // 1146 - ^
    0x84,       // 1147 - 
    0x64,       // 1148 -  - no match
    0x64,       // 1149 -  - no match
    0x64,       // 114A -  - no match
    0x64,       // 114B -  - no match
    0x64,       // 114C -  - no match
    0x64,       // 114D -  - no match
    0x64,       // 114E - no match
    0x64,       // 114F - no match

    0x64,       // 1150 - no match
    0x64,       // 1151 - no match
    0x64,       // 1152 -  - no match
    0x64,       // 1153 -  - no match
    0x64,       // 1154 - no match
    0x64,       // 1155 - no match
    0x64,       // 1156 -  - no match
    0x84,       // 1157 - 
    0x85,       // 1158 - 
    0x86,       // 1159 - 
    0x64,       // 115A - unused
    0x64,       // 115B - unused
    0x64,       // 115C - unused
    0x64,       // 115D - unused
    0x64,       // 115E - unused
    0x64,       // 115F - fill

    0x64,       // 1160 - fill
    0x4F,       // 1161 - 
    0x50,       // 1162 - 
    0x51,       // 1163 - 
    0x52,       // 1164 - 
    0x53,       // 1165 - 
    0x54,       // 1166 - 
    0x55,       // 1167 - 
    0x56,       // 1168 - 
    0x57,       // 1169 - 
    0x58,       // 116A - 
    0x59,       // 116B - 
    0x5A,       // 116C - 
    0x5B,       // 116D - 
    0x5C,       // 116E - 
    0x5D,       // 116F - 

    0x5E,       // 1170 - 
    0x5F,       // 1171 - 
    0x60,       // 1172 - 
    0x61,       // 1173 - 
    0x62,       // 1174 - 
    0x63,       // 1175 - 
    0x64,       // 1176 -  - no match
    0x64,       // 1177 -  - no match
    0x64,       // 1178 -  - no match
    0x64,       // 1179 -  - no match
    0x64,       // 117A -  - no match
    0x64,       // 117B -  - no match
    0x64,       // 117C -  - no match
    0x64,       // 117D -  - no match
    0x64,       // 117E -  - no match
    0x64,       // 117F -  - no match

    0x64,       // 1180 -  - no match
    0x64,       // 1181 -  - no match
    0x64,       // 1182 -  - no match
    0x64,       // 1183 -  - no match
    0x87,       // 1184 - 
    0x88,       // 1185 - 
    0x64,       // 1186 -  - no match
    0x64,       // 1187 -  - no match
    0x89,       // 1188 - 
    0x64,       // 1189 -  - no match
    0x64,       // 118A -  - no match
    0x64,       // 118B -  - no match
    0x64,       // 118C -  - no match
    0x64,       // 118D -  - no match
    0x64,       // 118E -  - no match
    0x64,       // 118F -  - no match

    0x64,       // 1190 -  - no match
    0x8A,       // 1191 - 
    0x8B,       // 1192 - 
    0x64,       // 1193 -  - no match
    0x8C,       // 1194 - 
    0x64,       // 1195 -  - no match
    0x64,       // 1196 -  - no match
    0x64,       // 1197 -  - no match
    0x64,       // 1198 -  - no match
    0x64,       // 1199 -  - no match
    0x64,       // 119A -  - no match
    0x64,       // 119B -  - no match
    0x64,       // 119C -  - no match
    0x64,       // 119D -  - no match
    0x8D,       // 119E - .
    0x64,       // 119F -  - no match

    0x64,       // 11A0 - . - no match
    0x8E,       // 11A1 - .
    0x64,       // 11A2 - .. - no match
    0x64,       // 11A3 - unused
    0x64,       // 11A4 - unused
    0x64,       // 11A5 - unused
    0x64,       // 11A6 - unused
    0x64,       // 11A7 - unused
    0x31,       // 11A8 - 
    0x32,       // 11A9 - 
    0x33,       // 11AA - 
    0x34,       // 11AB - 
    0x35,       // 11AC - 
    0x36,       // 11AD - 
    0x37,       // 11AE - 
    0x39,       // 11AF - 

    0x3A,       // 11B0 - 
    0x3B,       // 11B1 - 
    0x3C,       // 11B2 - 
    0x3D,       // 11B3 - 
    0x3E,       // 11B4 - 
    0x3F,       // 11B5 - 
    0x40,       // 11B6 - 
    0x41,       // 11B7 - 
    0x42,       // 11B8 - 
    0x44,       // 11B9 - 
    0x45,       // 11BA - 
    0x46,       // 11BB - 
    0x47,       // 11BC - 
    0x48,       // 11BD - 
    0x4A,       // 11BE - 
    0x4B,       // 11BF - 

    0x4C,       // 11C0 - 
    0x4D,       // 11C1 - 
    0x4E,       // 11C2 - 
    0x64,       // 11C3 -  - no match
    0x64,       // 11C4 -  - no match
    0x64,       // 11C5 -  - no match
    0x66,       // 11C6 - 
    0x67,       // 11C7 - 
    0x68,       // 11C8 - ^
    0x64,       // 11C9 -  - no match
    0x64,       // 11CA -  - no match
    0x64,       // 11CB -  - no match
    0x69,       // 11CC - 
    0x64,       // 11CD -  - no match
    0x6A,       // 11CE - 
    0x64,       // 11CF -  - no match

    0x64,       // 11D0 -  - no match
    0x64,       // 11D1 -  - no match
    0x64,       // 11D2 -  - no match
    0x6B,       // 11D3 - 
    0x64,       // 11D4 -  - no match
    0x64,       // 11D5 -  - no match
    0x64,       // 11D6 -  - no match
    0x6C,       // 11D7 - ^
    0x64,       // 11D8 -  - no match
    0x6D,       // 11D9 - 
    0x64,       // 11DA -  - no match
    0x64,       // 11DB -  - no match
    0x6E,       // 11DC - 
    0x6F,       // 11DD - 
    0x64,       // 11DE -  - no match
    0x70,       // 11DF - ^

    0x64,       // 11E0 -  - no match
    0x64,       // 11E1 -  - no match
    0x71,       // 11E2 - 
    0x64,       // 11E3 -  - no match
    0x64,       // 11E4 -  - no match
    0x64,       // 11E5 -  - no match
    0x78,       // 11E6 - 
    0x7A,       // 11E7 - 
    0x7C,       // 11E8 - 
    0x64,       // 11E9 -  - no match
    0x7D,       // 11EA - 
    0x7F,       // 11EB - ^
    0x64,       // 11EC -  - no match
    0x64,       // 11ED -  - no match
    0x80,       // 11EE - 
    0x64,       // 11EF -  - no match

    0x81,       // 11F0 - 
    0x82,       // 11F1 - 
    0x83,       // 11F2 - ^
    0x64,       // 11F3 -  - no match
    0x84,       // 11F4 - 
    0x64,       // 11F5 -  - no match
    0x64,       // 11F6 -  - no match
    0x64,       // 11F7 -  - no match
    0x64,       // 11F8 -  - no match
    0x86,       // 11F9 - 
    0x64,       // 11FA - unused
    0x64,       // 11FB - unused
    0x64,       // 11FC - unused
    0x64,       // 11FD - unused
    0x64,       // 11FE - unused
    0x64,       // 11FF - unused
};


// decompose_jamo
//
// break the precomposed hangul syllables into the composite jamo
//
// Parameters:
//  wzDst        -> (WCHAR*) ptr to output buffer
//               <- (WCHAR*) expanded (decomposed) string
//  wzSrc        -> (WCHAR*) input string to expand
//  rgCharInfo   -> (CHAR_INFO*) ptr to CharInfo buffer
//               <- (char*) CharStart info for string
//  wzMaxDst     -> (int) size of output buffer
//
// Note: this code assumes that wzDst is large enough to hold the
// decomposed string.  it should be 3x the size of wzSrc.
//
// Result:
//  (void)
//
// 16MAR00  bhshin   porting for WordBreaker
void
decompose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, CHAR_INFO_REC *rgCharInfo, int nMaxDst)
{
    const WCHAR *pwzS;
    WCHAR *pwzD, wch;
    CHAR_INFO_REC *pCharInfo = rgCharInfo;
    unsigned short nToken = 0;
    
    pwzS = wzSrc;
    pwzD = wzDst;
    for (; *pwzS != L'\0'; pwzS++, nToken++)
    {
        ATLASSERT(nMaxDst > 0);
        
		wch = *pwzS;

        if (fIsHangulSyllable(wch))
        {
            int nIndex = (wch - HANGUL_PRECOMP_BASE);
            int nL, nV, nT;
            WCHAR wchL, wchV, wchT;

            nL = nIndex / (NUM_JUNGSEONG * NUM_JONGSEONG);
            nV = (nIndex % (NUM_JUNGSEONG * NUM_JONGSEONG)) / NUM_JONGSEONG;
            nT = nIndex % NUM_JONGSEONG;

            // output L
            wchL = HANGUL_CHOSEONG + nL;
            *pwzD++ = wchL;
            pCharInfo->nToken = nToken;
            pCharInfo->fValidStart = 1;
            pCharInfo->fValidEnd = 0;
            pCharInfo++;

            // output V
            wchV = HANGUL_JUNGSEONG + nV;
            *pwzD++ = wchV;
            pCharInfo->nToken = nToken;
            pCharInfo->fValidStart = 0;
			if (nT != 0)
	            pCharInfo->fValidEnd = 0;	// 3-char syllable - not a valid end
			else
	            pCharInfo->fValidEnd = 1;	// 2-char syllable - mark end as valid
            pCharInfo++;

            // output T (if present)
            if (nT != 0)
            {
                wchT = HANGUL_JONGSEONG + (nT-1);
                *pwzD++ = wchT;
	            pCharInfo->nToken = nToken;
                pCharInfo->fValidStart = 0;
                pCharInfo->fValidEnd = 1;
                pCharInfo++;
            }
        }
        else
        {
            // just copy over the char
            *pwzD++ = *pwzS;
            pCharInfo->nToken = nToken;
            pCharInfo->fValidStart = 1;
            pCharInfo->fValidEnd = 1;
            pCharInfo++;
        }
    }
    *pwzD = L'\0';
    pCharInfo->nToken = nToken;
    pCharInfo++;
}


// compose_jamo
//
// take the jamo chars and combine them into precomposed forms
//
// Parameters:
//  pwzDst  <- (WCHAR*) human-readable bit string
//  pwzSrc  -> (WCHAR*) string buffer to write output string
//  wzMaxDst -> (int) size of output buffer
//
// Result:
//  (int)  number of chars in output string
//
// 11APR00  bhshin   check output buffer overflow
// 16MAR00  bhshin   porting for WordBreaker
int
compose_jamo(WCHAR *wzDst, const WCHAR *wzSrc, int nMaxDst)
{
    const WCHAR *pwzS;
    WCHAR *pwzD, wchL, wchV, wchT, wchS;
    int nChars=0;

    pwzS = wzSrc;
    pwzD = wzDst;
    for (; *pwzS != L'\0';)
    {
        ATLASSERT(nChars < nMaxDst);

		// output buffer overflow
		if (nChars >= nMaxDst)
		{
			// make output string empty
			*wzDst = L'0';
			return 0;
		}
        
		wchL = *pwzS;
        wchV = *(pwzS+1);

        // if the L or V aren't valid, consume 1 char and continue
        if (!fIsChoSeong(wchL) || !fIsJungSeong(wchV))
        {
            if (fIsHangulJamo(wchL))
            {
                // convert from conjoining-jamo to compatibility-jamo
                wchS = g_rgchXJamoMap[wchL-HANGUL_JAMO_BASE];
                wchS += HANGUL_xJAMO_PAGE;
                *pwzD++ = wchS;
                pwzS++;
            }
            else
            {
                // just copy over the unknown char
                *pwzD++ = *pwzS++;
            }
            nChars++;
            continue;
        }

        wchL -= HANGUL_CHOSEONG;
        wchV -= HANGUL_JUNGSEONG;
        pwzS += 2;

        // calc (optional) T
        wchT = *pwzS;
        if (!fIsJongSeong(wchT))
            wchT = 0;
        else
        {
            wchT -= (HANGUL_JONGSEONG-1);
            pwzS++;
        }

        wchS = ((wchL * NUM_JUNGSEONG + wchV) * NUM_JONGSEONG) + wchT + HANGUL_PRECOMP_BASE;
        ATLASSERT(fIsHangulSyllable(wchS));
        
        *pwzD++ = wchS;
        nChars++;
    }
    *pwzD = L'\0';

    return nChars;
}

// compose_length
//
// get the composed string length of input decomposed jamo
//
// Parameters:
//  wszInput  <- (const WCHAR*) input decomposed string (NULL terminated)
//
// Result:
//  (int)  number of chars in composed string
//
// 21MAR00  bhshin   created
int 
compose_length(const WCHAR *wszInput)
{
	const WCHAR *pwzInput;
	
	pwzInput = wszInput;
	
	int cch = 0;
	while (*pwzInput != L'\0')
	{
		if (!fIsChoSeong(*pwzInput) && !fIsJongSeong(*pwzInput))
			cch++;

		pwzInput++;
	}

	return cch;
}

// compose_length
//
// get the composed string length of input decomposed jamo
//
// Parameters:
//  wszInput  <- (const WCHAR*) input decomposed string (NULL terminated)
//  cchInput  <- (int) length of input string
//
// Result:
//  (int)  number of chars in composed string
//
// 15MAY00  bhshin   created
int 
compose_length(const WCHAR *wszInput, int cchInput)
{
	const WCHAR *pwzInput;
	
	pwzInput = wszInput;
	
	int cch = 0;
	int idxInput = 0;
	while (*pwzInput != L'\0' && idxInput < cchInput)
	{
		if (!fIsChoSeong(*pwzInput) && !fIsJongSeong(*pwzInput))
			cch++;

		pwzInput++;
		idxInput++;
	}

	return cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\wblog.cpp ===
// WbLog.cpp
//
// wordbreaker log routines
//
// Copyright 2000 Microsoft Corp.
//
// Modification History:
//  05 JUL 2000	  bhshin	created

#include "stdafx.h"
#include "KorWbrk.h"
#include "WbLog.h"
#include "unikor.h"
#include <stdio.h>

#ifdef _WB_LOG

#define MAX_LOG_LENGTH	1024

// global variables
static HANDLE g_hWbLog = INVALID_HANDLE_VALUE;
static const char g_szWbLogFile[] = "_wb_log.txt";

CWbLog g_WbLog;

// WbLogInit
//
// create & initialize log file
//
// Parameters:
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void WbLogInit()
{
	DWORD dwWritten;
	static const BYTE szBOM[] = {0xFF, 0xFE};

	// initialize log level
	g_hWbLog = CreateFile(g_szWbLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
		                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (g_hWbLog == INVALID_HANDLE_VALUE) 
		return;

	// write BOM
	if (!WriteFile(g_hWbLog, &szBOM, 2, &dwWritten, 0))
	{
		CloseHandle(g_hWbLog);
		g_hWbLog = INVALID_HANDLE_VALUE;
		return;
	}

	return;
}

// WbLogUninit
//
// uninitialize log file
//
// Parameters:
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void WbLogUninit()
{
	if (g_hWbLog != INVALID_HANDLE_VALUE)
		CloseHandle(g_hWbLog);
}

// WbLogPrint
//
// print log string
//
// Parameters:
//  lpwzFormat -> (LPCWSTR) input log format
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void WbLogPrint(LPCWSTR lpwzFormat, ...)
{
	va_list args;
	int nBuf, cchBuffer;
	WCHAR wzBuffer[MAX_LOG_LENGTH];
	DWORD dwWritten;

	va_start(args, lpwzFormat);

	nBuf = _vsnwprintf(wzBuffer, MAX_LOG_LENGTH, lpwzFormat, args);

	// was there an error? was the expanded string too long?
	if (nBuf < 0)
	{
		va_end(args);
		return;
	}

	if (g_hWbLog == INVALID_HANDLE_VALUE)
	{
		va_end(args);
		return;
	}

	cchBuffer = wcslen(wzBuffer);

	if (cchBuffer > 0)
	{
		WriteFile(g_hWbLog, wzBuffer, cchBuffer*2, &dwWritten, 0);
	}

	va_end(args);
}

// WbLogPrintHeader
//
// print log header
//
// Parameters:
//  fQuery -> (BOOL) Query flag of IWordBreak::Init
//
// Result:
//  (void)
//
// 06JUL00  bhshin  created
void WbLogPrintHeader(BOOL fQuery)
{
	WbLogPrint(L"\r\n");
	WbLogPrintBreak(100);
	WbLogPrint(L"fQuery = %s\r\n\r\n", fQuery ? L"TRUE" : L"FALSE");
	WbLogPrint(L"\r\n");
	WbLogPrint(L"%-15s %-15s %-20s [%s]", L"Input Token", L"Index Term", L"Root Index String", L"Index Type");
	WbLogPrint(L"\r\n");
	WbLogPrintBreak(100);
}

// WbLogPrintBreak
//
// print log header
//
// Parameters:
//	nLen -> (int) length of break string
//
// Result:
//  (void)
//
// 07JUL00  bhshin  created
void WbLogPrintBreak(int nLen)
{
	WCHAR wzBuffer[MAX_LOG_LENGTH];	
	
	memset(wzBuffer, '?', sizeof(WCHAR)*nLen);

	_wcsnset(wzBuffer, L'-', nLen);
	wzBuffer[nLen] = L'\0';

	WbLogPrint(L"%s\r\n", wzBuffer);
}

// CWbLog::SetRootIndex
//
// set top record's index string when TraverseIndexString
//
// Parameters:
//	 lpwzIndex	-> (const WCHAR*) decomposed index string
//   fIsRoot    -> (BOOL) top index flag
//
// Result:
//  (void)
//
// 07JUL00  bhshin  created
void CWbLog::SetRootIndex(LPCWSTR lpwzIndex, BOOL fIsRoot)
{ 
	WCHAR wzRoot[MAX_INDEX_STRING]; 

	if (fIsRoot && /*wcslen(m_wzRootIndex) > 0 &&*/ m_iCurLog > 0)
	{
		// root changed
		m_LogInfo[m_iCurLog-1].fRootChanged = TRUE;
	}

	compose_jamo(wzRoot, lpwzIndex, MAX_INDEX_STRING);
	wcscpy(m_wzRootIndex, wzRoot);
}

// CWbLog::AddIndex
//
// add index term
//
// Parameters:
//	 pwzIndex	-> (const WCHAR*) index term string
//   cchIndex   -> (int) length of index term
//	 typeIndex  -> (INDEX_TYPE) index type
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void CWbLog::AddIndex(const WCHAR *pwzIndex, int cchIndex, INDEX_TYPE typeIndex)
{
	if (m_iCurLog >= MAX_LOG_NUMBER)
		return;

	if (cchIndex >= MAX_INDEX_STRING)
		return;

	wcsncpy(m_LogInfo[m_iCurLog].wzIndex, pwzIndex, cchIndex);
	m_LogInfo[m_iCurLog].wzIndex[cchIndex] = L'\0';

	wcscpy(m_LogInfo[m_iCurLog].wzRoot, m_wzRootIndex);
	m_LogInfo[m_iCurLog].IndexType = typeIndex;

	m_LogInfo[m_iCurLog].fRootChanged = FALSE;

	m_iCurLog++;
}

// CWbLog::RemoveIndex
//
// add index term
//
// Parameters:
//	 pwzIndex	-> (const WCHAR*) index term string
//
// Result:
//  (void)
//
// 30AUG00  bhshin  created
void CWbLog::RemoveIndex(const WCHAR *pwzIndex)
{
	for (int i = 0; i < m_iCurLog; i++)
	{
		if (wcscmp(m_LogInfo[i].wzIndex, pwzIndex) == 0)
		{
			m_LogInfo[i].fPrint = FALSE; // delete it
		}
	}
}

// CWbLog::PrintWbLog
//
// add index term
//
// Parameters:
//
// Result:
//  (void)
//
// 05JUL00  bhshin  created
void CWbLog::PrintWbLog()
{
	DWORD dwWritten;
	static WCHAR *rgwzIndexType[] = 
	{
		L"Query",			// INDEX_QUERY
		L"Break",			// INDEX_BREAK
		L"PreFilter",       // INDEX_PREFILTER
		L"Parse",			// INDEX_PARSE
		L"GuessNoun",		// INDEX_GUESS_NOUN
		L"GuessNF",			// INDEX_GUESS_NF
		L"GuessName",		// INDEX_GUESS_NAME
		L"GuessNameSSI",	// INDEX_GUESS_NAME_SSI
		L"GuessGroup",		// INDEX_INSIDE_GROUP
		L"Symbol",			// INDEX_SYMBOL
	};

	if (g_hWbLog == INVALID_HANDLE_VALUE)
		return; // not initialized

	if (m_iCurLog == 0)
	{
		WCHAR wzBuffer[MAX_LOG_LENGTH];

		swprintf(wzBuffer, 
				 L"%-15s %-15s %-5s\r\n", 
				 m_wzSource, 
				 L"NoIndex", 
				 m_wzRootIndex);

		WriteFile(g_hWbLog, wzBuffer, wcslen(wzBuffer)*2, &dwWritten, NULL);

		WbLogPrintBreak(100);
		
		return;
	}

	for (int i = 0; i < m_iCurLog; i++)
	{
		WCHAR wzBuffer[MAX_LOG_LENGTH];

		swprintf(wzBuffer, 
				 L"%-15s %-15s %-20s [%s]\r\n", 
				 m_wzSource, 
				 m_LogInfo[i].wzIndex, 
				 m_LogInfo[i].wzRoot,
				 rgwzIndexType[m_LogInfo[i].IndexType]);

		WriteFile(g_hWbLog, wzBuffer, wcslen(wzBuffer)*2, &dwWritten, NULL);

		if (i == m_iCurLog-1)
			break;

		if (m_LogInfo[i].fRootChanged ||
			m_LogInfo[i].IndexType != m_LogInfo[i+1].IndexType)
		{
			WbLogPrint(L"%20s", L" ");
			WbLogPrintBreak(80);
		}
	}

	WbLogPrintBreak(100);
}

#endif // #ifdef _WB_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\ctplus0.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//              11-Nov-97   weibz       Add Thai char support
//
//---------------------------------------------------------------------------


//#include <windows.h>
//#include "ctplus0.h"

#include "pch.cxx"


//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,CH,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,CH,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          //  FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,VC,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,VC,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2000-2007
        WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,CH,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          //  3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    10-Sep-97   Weibz
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(VC);  // including Hangul
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeExW( MAKELANGID( LANG_THAI, SUBLANG_DEFAULT ),
                                  CT_CTYPE1,
                                  &wc2,
                                  1,
                                  &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole CJK Range as Kanji
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

            //
            // Treat All Gaiji as Kanji Char, too
            //
            if ((wc >= 0xE000) && (wc < 0xE758)) {
                return(IC);
            }

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // If it's not interesting return CH as default;
            return(CH);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\ctplus0.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//              11-Nov-97   Weibz       Add Thai char
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC       0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC       0x03                             // Katakana char
#define WS       0x04                             // Word seperator
#define VC       0x05                             // Hankaku (variant) char
#define PS       0x06                             // Phrase seperator
#define CH       0x07                             // Code page 0 - ASCII Char.

BYTE
GetCharType(WCHAR wc);

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START       = 0x00,
   CT_HIRAGANA    = 0x01,
   CT_KANJI       = 0x02,
   CT_KATAKANA    = 0x03,
   CT_WORD_SEP    = 0x04,
   CT_HANKAKU     = 0x05,
   CT_PHRASE_SEP  = 0x06,
   CT_ROMAJI      = 0x07,
} CT;


// Declare node types transitions
// Intuitively frequency ordered
//
typedef enum _WT {
   WT_START       = 0x00,
   WT_WORD_SEP    = 0x01,
   WT_PHRASE_SEP  = 0x02,
   WT_ROMAJI      = 0x03,
   WT_REACHEND    = 0x04,
} WT;


#define CT_MAX    0x08

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>


#include <cierror.h>
#include <query.h>
#include <except.hxx>

#include <assert.h>

#include <usp10.h>

#include  "ctplus0.h"

#undef Assert
#define Assert(a)

// Base services
//

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\kor2\src\_kor_name.h ===
// kor\_kor_name.h
// Korean Name definitions
// Copyright 2000 Microsoft Corp.
//
// *** do not edit this file ***
//
// this file is automatically generated from kor_name.bat script
//
// generated on Mon 3 Jul 2000 at 18:15:57
//

const ULONG TOTAL_KORNAME_UNIGRAM = 3050628;
const ULONG TOTAL_KORNAME_BIGRAM = 4568990;
const ULONG TOTAL_KORNAME_TRIGRAM = 3987666;

const ULONG TOTAL_KORNAME_LASTNAME = 1536850;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\iwbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   Thai  Word Breaker glue code
//
//  History:   weibz,   10-Nov-1997   created
//
//----------------------------------------------------------------------------

#include <pch.cxx>

#include "iwbreak.hxx"

extern  long            gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{

    InterlockedIncrement( &gulcInstances );

}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );


}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IWordBreaker = D53552C8-77E3-101A-B552-08002B33B0E6
    //                    --------
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1     & 0x000000FF) == 0x00 );
    Assert( (IID_IWordBreaker.Data1 & 0x000000FF) == 0xC8 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 )
    {
    case 0x00000000:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0xD53552C8:
        if ( memcmp( &IID_IWordBreaker, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IWordBreaker *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp ) 
        delete this;


    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if ( NULL == pfLicense ) {
       return E_INVALIDARG;
    }


    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;


    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{

    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";


    if ( NULL == ppwcsLicense )  {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  History:    10-Nov-1997, WeibZ,       Created.
//
//  Notes:      Since the input buffer may be greater than MAX_II_BUFFER_LEN
//              we process the buffer in chunks of length MAX_II_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreaker::BreakText( TEXT_SOURCE *pTextSource,
                                                 IWordSink *pWordSink,
                                                 IPhraseSink *pPhraseSink )
{
    SCODE             sc = S_OK;
    ULONG             cwc;
    SCRIPT_ITEM       *pItems, *pItem_Next, *pItem_org;
    SCRIPT_ANALYSIS   *psa;
    PCWSTR            pwcInChars;
    INT               iItems;
    BOOL              bItemProc;
    PCWSTR            pwcChars;
    INT               cChars;
    HRESULT           retUSP;


    if ( NULL == pTextSource ) {
       return E_INVALIDARG;
    }

    if ( NULL == pWordSink )
    {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }


    if ( 0 != pPhraseSink )
    {
        // ignore the phrase sink for now
        // return sc;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
       return S_OK;
    }

    Assert( pTextSource->iCur < pTextSource->iEnd );


    __try 
    {
        do  {

            if ( pTextSource->iCur >= pTextSource->iEnd )
               continue;

            cwc = pTextSource->iEnd - pTextSource->iCur;
            pwcInChars = pTextSource->awcBuffer + pTextSource->iCur;
            
            
            pItems = (SCRIPT_ITEM *)LocalAlloc(LPTR,sizeof(SCRIPT_ITEM)*(cwc+1));

            if ( !pItems) {

                return E_UNEXPECTED;
            }

            pItem_org = pItems; 

           
            iItems = 0; 
            retUSP = ScriptItemize(pwcInChars,cwc,cwc+1, NULL, NULL, 
                                   pItems, &iItems);

            if (retUSP != S_OK) {
                LocalFree(pItem_org);
                return  E_UNEXPECTED;
            }

            while  ( iItems > 1 ) {

               pItem_Next = pItems + 1;
               pwcChars =  pwcInChars + pItems->iCharPos;
               cChars   =  pItem_Next->iCharPos - pItems->iCharPos;

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       FALSE,   // no need to keep chars
                                       pTextSource,
                                       pWordSink, 
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }

               pItems++;
               iItems--;

            }

            //  special handle for the last item
            if ( iItems == 1 ) {

               pwcChars = pwcInChars + pItems->iCharPos;
               cChars = pTextSource->iEnd - pTextSource->iCur; 

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       TRUE,  // need to keep chars
                                       pTextSource,
                                       pWordSink,
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }
            }

            if (pItem_org)
               LocalFree(pItem_org);

        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );


        if ( pTextSource->iCur < pTextSource->iEnd ) {

            cwc = pTextSource->iEnd - pTextSource->iCur;
            pwcInChars = pTextSource->awcBuffer + pTextSource->iCur;
            
            pItems = (SCRIPT_ITEM *)LocalAlloc(LPTR,sizeof(SCRIPT_ITEM)*(cwc+1));

            if ( !pItems ) {

                return E_UNEXPECTED;
            }

            pItem_org = pItems;


            iItems = 0; 
            retUSP = ScriptItemize(pwcInChars,cwc,cwc+1, NULL, NULL,
                                   pItems, &iItems);

            if (retUSP != S_OK) {
                LocalFree(pItem_org);
                return  E_UNEXPECTED;
            }

            while  ( iItems > 1 ) {

               pItem_Next = pItems + 1;
               pwcChars =  pwcInChars + pItems->iCharPos;
               cChars   =  pItem_Next->iCharPos - pItems->iCharPos;

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       FALSE,  // no need to keep chars
                                       pTextSource,
                                       pWordSink, 
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }

               pItems++;
               iItems--;

            }

            if ( iItems == 1 ) {

               pwcChars = pwcInChars + pItems->iCharPos;
               cChars = pTextSource->iEnd - pTextSource->iCur; 

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       FALSE,    // no need to keep chars
                                       pTextSource,
                                       pWordSink,
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }
            }

            if ( pItem_org ) 
               LocalFree(pItem_org);
        }

    } __except(1) {

       sc = E_UNEXPECTED;
   }

    return sc;
}

BOOL CWordBreaker::ProcessItem( 
                     PCWSTR        pwcChars,
                     INT           cChars,
                     SCRIPT_ITEM   *pItems,
                     BOOL          fKeep,
                     TEXT_SOURCE  *pTextSource,     
                     IWordSink    *pWordSink,
                     IPhraseSink  *pPhraseSink )
{

    SCRIPT_LOGATTR    *psla, *psla_org, *pslatmp;
    INT               iChar,i;
    INT               iWord, iWordStart, iWordLen;
    PTHAIWORD         pThaiWord, pThaiWordTmp;
    BOOL              fLastIsWhiteSpace=FALSE;

    const SCRIPT_PROPERTIES **pScript_Properties;
    DWORD             LangID;
    WORD              iScript;

    HRESULT           retUSP;

    ScriptGetProperties(&pScript_Properties, NULL);

    iScript = pItems->a.eScript;

    LangID = (pScript_Properties[iScript])->langid;

    switch (LangID) {

       case LANG_THAI: //Thai script, there are SCRIPT_THAI & SCRIPT_THAI_NUM

//           if (pScript_Properties[iScript].fNeedsWordBreaking == FALSE) {
//           //   this is SCRIPT_THAI_NUM,
//
//              for ( iChar=0; iChar < cChars; iChar++ ) {
//                   pWordSink->PutWord(1,
//                                      pwcChars+iChar,
//                                      1,
//                                      pTextSource->iCur);
//                   pTextSource->iCur ++;
//              }
//
//              break;
//
//           }
//
//           // Following code is for SCRIPT_THAI 

           psla = (SCRIPT_LOGATTR *)LocalAlloc(LPTR,
                              (sizeof(SCRIPT_LOGATTR)+sizeof(THAIWORD))*cChars);
           psla_org = psla;

           pThaiWord = (PTHAIWORD)&psla[cChars];

           if ( psla == NULL ) 
              return  FALSE;
                          
           retUSP = ScriptBreak(pwcChars, cChars, &(pItems->a), psla);

           if (retUSP != S_OK) {
               LocalFree(psla_org);
               return FALSE;
           }

           pThaiWordTmp = pThaiWord;


           // check if the last char is a white space.
           if ( psla[cChars-1].fWhiteSpace )
               fLastIsWhiteSpace=TRUE;


           iWordStart = -1;
           iWord=0;
           for (iChar=0; iChar < cChars; iChar++) {
               if (psla->fWordStop) {
                  if ( iWordStart != -1 ) {

                     iWordLen = iChar - iWordStart;
                     if (iWordLen > 0) {
                        pThaiWordTmp->offset = iWordStart;
                        pThaiWordTmp->len = iWordLen;
                        pThaiWordTmp++;
                        iWord++;
                     }

                  }
                  iWordStart = iChar;
               }


               if ( psla->fWhiteSpace ) {
                     
                     if ( iWordStart != -1 ) {

                        iWordLen = iChar - iWordStart;
                        if (iWordLen > 0 ) {
                           pThaiWordTmp->offset = iWordStart;
                           pThaiWordTmp->len = iWordLen;
                           pThaiWordTmp++;
                           iWord++;
                        }

                     }
                     iWordStart = iChar;
                 
                     // skip all the consequent white spaces.
                     while ( (psla->fWhiteSpace) && (iChar < cChars) ) {
                          iWordStart = iChar;
                          iChar ++;
                          psla++;
                     } 

                     if ( iChar < cChars)
                        iWordStart = iChar;

               }

               psla++;
           }

           if  ( !fLastIsWhiteSpace ) {
               iWordLen = cChars - iWordStart;
               if ( iWordLen > 0 ) {
                  pThaiWordTmp->offset = iWordStart;
                  pThaiWordTmp->len = iWordLen;
                  iWord++; 
               }
           }

         
           // if this is the last item, and the last char is a Thai char,
           // we will discard the last 4 words and integrate into the next
           // filled buffer and do again!!!

           if (fKeep && !fLastIsWhiteSpace) 
              iWord = iWord - 4;

           pThaiWordTmp = pThaiWord;
           for (i=0; i<iWord; i++) {
           
              iWordLen = pThaiWordTmp->len; 
              iWordStart = pThaiWordTmp->offset;
              pWordSink->PutWord(iWordLen,
                                 pwcChars+iWordStart,
                                 iWordLen,
                                 pTextSource->iCur+iWordStart);

              pThaiWordTmp++;
           }

           
           if ( fKeep && !fLastIsWhiteSpace) 
              pTextSource->iCur += iWordStart + iWordLen;
           else
              pTextSource->iCur += cChars;

           LocalFree(psla_org);
                                   
           break;
       
       case LANG_ENGLISH :   // handle English chars 

            { 

                BYTE        ct;
                BOOL        fRomanWord = FALSE;
                CONST WCHAR *pwcInput;
                WT          Type;

                Type =  WT_START;

                pwcInput = pwcChars;
                iWordStart = 0;

                for (iChar=0; iChar< cChars; iChar++, pwcInput++) {

                    ct = GetCharType(*pwcInput);

                    if ( (ct != WS) && (ct != PS) )
                       ct = CH;


                    switch (ct) {
                      case CH :
                           if (!fRomanWord) {
                               iWordStart = iChar; 
                               fRomanWord = TRUE;
                               Type = WT_ROMAJI;
                           }
                           break;
                      case WS :
                           if (fRomanWord) {
                              iWordLen = iChar - iWordStart; 
                              pWordSink->PutWord(iWordLen,
                                                 pwcChars+iWordStart,
                                                 iWordLen,
                                                 pTextSource->iCur);

                              pTextSource->iCur += iWordLen;
                              fRomanWord = FALSE;
                           }
                           
                           Type = WT_WORD_SEP;
                           pTextSource->iCur++;
                           break;

                      case PS :
                           if (fRomanWord) {
                              iWordLen = iChar - iWordStart;
                              pWordSink->PutWord(iWordLen,
                                                 pwcChars+iWordStart,
                                                 iWordLen,
                                                 pTextSource->iCur);

                              pTextSource->iCur += iWordLen;
                              fRomanWord = FALSE;
                           }
                           
                           Type = WT_PHRASE_SEP;
                           pWordSink->PutBreak(WORDREP_BREAK_EOS);
                           pTextSource->iCur++;
                           break;

                    }
                }

                if ((Type == WT_WORD_SEP) || (Type == WT_PHRASE_SEP))
                   break;
                
                if ( fKeep )
                   break;
                
                iWordLen =cChars - iWordStart;
                pWordSink->PutWord(iWordLen,
                                  pwcChars+iWordStart,
                                  iWordLen,
                                  pTextSource->iCur);

                pTextSource->iCur += iWordLen;
            }

            break;


       default           :

               pTextSource->iCur += cChars;
               break;
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\stemcf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       stemcf.cxx
//
//  Contents:   Stemmer class factory
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "stemcf.hxx"
#include "stemmer.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CStemmerCF
//
//  Synopsis:   Stemmer class factory constructor
//
//--------------------------------------------------------------------------

CStemmerCF::CStemmerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::~CStemmerCF
//
//  Synopsis:   Stemmer class factory destructor
//
//--------------------------------------------------------------------------

CStemmerCF::~CStemmerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( riid == IID_IClassFactory )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CreateInstance
//
//  Synopsis:   Creates new CStemmer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::CreateInstance( IUnknown * pUnkOuter,
                                                    REFIID riid,
                                                    void  * * ppvObject )
{
    CStemmer *pIUnk = 0;
    SCODE sc = S_OK;

    __try
    {
        pIUnk = new CStemmer( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998 - 1999, Microsoft Corporation.
//
// File:        Register.cxx
//
// Contents:    Self-registration for Word Breaker /Stemmer.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     12-Jan-98       Weibz       Created
//              08-Jan-99       AlanW       Modified to use langreg.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "langreg.hxx"

//
// Registry constants
//


WCHAR const wszCILang[] = L"System\\CurrentControlSet\\Control\\ContentIndex\\Language";

SLangRegistry const LangResource = {
    L"Thai_Default",
    1054,
    {   L"{cca22cf4-59fe-11d1-bbff-00c04fb97fda}",
        L"Thai_Default Word Breaker",
        L"thawbrkr.dll",
        L"Both" },

    {   L"{cedc01c7-59fe-11d1-bbff-00c04fb97fda}",
        L"Thai_Default Stemmer",
        L"thawbrkr.dll",
        L"Both" }
};


//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created 
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    long dwErr = UnRegisterALanguageResource( LangResource );
    if ( ERROR_SUCCESS != dwErr )
        return S_FALSE;

    return S_OK;
} //DllUnregisterServer

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    //
    // Register classes
    //

    long dwErr = RegisterALanguageResource( LangResource );

    if ( ERROR_SUCCESS != dwErr )
        return SELFREG_E_CLASS;

    return S_OK;
} //DllRegisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\init.cxx ===
//  ----------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  Routine:    DllMain
//
//  Description:
//
//  Returns:    True if successful, else False.
//  History:    Weibz, 10-Nov-1997,  created it.
//
//---------------------------------------------------------------------------

#include <pch.cxx>

CRITICAL_SECTION ThCritSect;

SCRIPTITEMIZE   ScriptItemize;
SCRIPTBREAK     ScriptBreak;
HMODULE         hUsp;

BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{

    CHAR      szUSPPath[MAX_PATH];

    switch(dwReason) 
    {
       case DLL_PROCESS_ATTACH : 

          DisableThreadLibraryCalls(hDLL);
          InitializeCriticalSection (&ThCritSect);


          GetSystemDirectory ( szUSPPath, MAX_PATH );

          strcat ( szUSPPath, "\\USP.DLL" );
          hUsp = LoadLibrary (szUSPPath);

          if ( hUsp == NULL ) 
             return FALSE;

          ScriptItemize = (SCRIPTITEMIZE)GetProcAddress(hUsp,"ScriptItemize");
          ScriptBreak = (SCRIPTBREAK) GetProcAddress(hUsp,"ScriptBreak");

          if ( (ScriptItemize==NULL) || (ScriptBreak==NULL) )
             return FALSE;

          break ;

       case DLL_THREAD_ATTACH:
            break;
       case DLL_THREAD_DETACH:
            break;
       case DLL_PROCESS_DETACH  :
            
            if (hUsp != NULL )
               FreeLibrary(hUsp);
              
            hUsp = NULL;

            DeleteCriticalSection (&ThCritSect);
            break ;
      }   //switch
 
      return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       exports.cxx
//
//  Contents:   Code to export word breaker class factories
//
//  History:     weibz,   11-10-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include <classid.hxx>
#include <wbclassf.hxx>
#include <stemcf.hxx>

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE
DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

//    __try {

        switch ( cid.Data1 ) {

        // Thai language wordbreaker
        //
        case 0xcca22cf4:
           if ( cid == CLSID_Thai_Default_WBreaker ) {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Thai language stemmer
        //
        case 0xcedc01c7:
           if ( cid == CLSID_Thai_Default_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
             sc = pResult->QueryInterface( iid, ppvObj );

             pResult->Release(); // Release extra refcount from QueryInterface
           }
           else
              sc = E_NOINTERFACE;
           break;

        default:
             sc = E_NOINTERFACE;
        }
 /*   } __except(1) {

        if ( pResult )
            pResult->Release();

        sc = E_UNEXPECTED;
    }  */

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:     weibz,   11-10-1997   created 
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cbreaktree.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CBreakTree - class CBreakTree 
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CBREAKTREE_HPP_
#define _CBREAKTREE_HPP_

class CBreakTree
{
public:
	virtual void Init(CTrie* pTrie, CTrie* pTrigramTrie) = 0;
    virtual unsigned int TrigramBreak(WCHAR* pwchBegin, WCHAR* pwchEnd) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\wbclassf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       wbclassf.cxx
//
//  Contents:   Word Breaker class factory
//
//  History:     weibz,   10-Nov-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "wbclassf.hxx"
#include "iwbreak.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory constructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::CWordBreakerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::~CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory destructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::~CWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreakerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    Assert( (IID_IUnknown.Data1& 0x000000FF) == 0x00 );
    Assert( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF ) {
    case 0x00:
        if ( memcmp( &IID_IUnknown, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x01:
        if ( memcmp( &IID_IClassFactory, &riid, sizeof(riid) ) == 0 )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject )
{
    CWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    if (NULL != pUnkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return E_NOINTERFACE;
    }

    __try 
    {
        pIUnk = new CWordBreaker( _lcid );
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cmn_debug.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Debug.h
//
//  History:    22-May-95   PatHal      Created.
//
//---------------------------------------------------------------------------

#ifndef _DEBUG_
#define _DEBUG_

#ifdef _DEBUG

#ifdef __cplusplus
extern "C" {
#endif
// in NLGlib.h
// extern void DebugAssert(LPCTSTR, LPCTSTR, UINT);
// extern void SetAssertOptions(DWORD);
//

// Optional assert behavior
#define AssertOptionWriteToFile     0x01
#define AssertOptionShowAlert       0x02
// Continue and exit are mutually exclusive
#define AssertOptionContinue        0x00
#define AssertOptionExit            0x04
#define AssertOptionCallDebugger    0x08
#define AssertOptionUseVCAssert     0x10

#define AssertDefaultBehavior       (AssertOptionUseVCAssert)

#define bAssertWriteToFile()    ((fAssertFlags & AssertOptionWriteToFile) != 0)
#define bAssertShowAlert()      ((fAssertFlags & AssertOptionShowAlert) != 0)
#define bAssertExit()           ((fAssertFlags & AssertOptionExit) != 0)
#define bAssertCallDebugger()   ((fAssertFlags & AssertOptionCallDebugger) != 0)
#define bAssertUseVCAssert()    ((fAssertFlags & AssertOptionUseVCAssert) != 0)


#define Assert(a) { if (!(a)) DebugAssert((LPCTSTR)L#a, TEXT(__FILE__), __LINE__); }
#define AssertSz(a,t) { if (!(a)) DebugAssert((LPCTSTR)t, TEXT(__FILE__), __LINE__); }

#ifdef __cplusplus
}
#endif

#else // _DEBUG

#define Assert(a)
#define AssertSz(a,t)

#endif // _DEBUG

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai\stemmer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       stemmer.cxx
//
//  Contents:   Thai Stemmer
//
//  History:    weibz,   10-Nov-1997   created 
//
//----------------------------------------------------------------------------

#include <pch.cxx>

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    IUnknown *pUnkTemp;
    SCODE sc = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( riid == IID_IUnknown )
            pUnkTemp = (IUnknown *)this;
        else
            sc = E_NOINTERFACE;
        break;

    case 0x40:
        if ( riid == IID_IStemmer )
            pUnkTemp = (IUnknown *)(IStemmer *)this;
        else
            sc = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        sc = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    else
       *ppvObject = 0;
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";
    
    if ( NULL == ppwcsLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return ( E_INVALIDARG );
    }

    *ppwcsLicense = wcsCopyright;

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwcInBuf,
    ULONG cwc,
    IStemSink *pStemSink )
{
    INT nReturn;
    SCODE sc = S_OK;

#ifdef THAIDBG
    ULONG  i;
    OutputDebugString("\n Stemword\n");
    for (i=0; i<cwc; i++)
    {
          WORD  wtmp;
          char  ctmp[80];

          wtmp = pwcInBuf[i];
          sprintf(ctmp, "%4x ", wtmp);
          OutputDebugString(ctmp);
    }
#endif

    if ( NULL == pStemSink  || NULL == pwcInBuf) {
        return E_FAIL;
    }

    // Currently, Thai stemmer doesn't make inflection form for tripolli.
    pStemSink->PutWord (pwcInBuf, cwc);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaibreaktree.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiBreakTree - class CThaiBreakTree 
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiBreakTree.hpp"

//+---------------------------------------------------------------------------
//
//  Function:   ExtractPOS
//
//  Synopsis:   The functions takes a tag and return Part Of Speech Tags.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline WCHAR ExtractPOS(DWORD dwTag)
{
    return (WCHAR) ( (dwTag & iPosMask) >> iPosShift);
}

//+---------------------------------------------------------------------------
//
//  Function:   ExtractFrq
//
//  Synopsis:   The functions takes a tag and return Frquency of words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BYTE ExtractFrq(DWORD dwTag)
{
    return (BYTE) ( (dwTag & 0x300) >> iFrqShift);
}

//+---------------------------------------------------------------------------
//
//  Function:   DetermineFrequencyWeight
//
//  Synopsis:   The functions returns the frequency weight of a words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void DetermineFrequencyWeight(BYTE frq, unsigned int* uiWeight)
{
    switch (frq)
    {
    case frqpenInfrequent:
        (*uiWeight) -= 2;
        break;
    case frqpenSomewhat:
        (*uiWeight)--;
        break;
    case frqpenVery:
        (*uiWeight) += 2;
        break;
    case frqpenNormal:
    default:
        (*uiWeight)++;
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DetermineFrequencyWeight
//
//  Synopsis:   The functions returns the frequency weight of a words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void DetermineFrequencyWeight(BYTE frq, DWORD* uiWeight)
{
    switch (frq)
    {
    case frqpenInfrequent:
        (*uiWeight) -= 2;
        break;
    case frqpenSomewhat:
        (*uiWeight)--;
        break;
    case frqpenVery:
        (*uiWeight) += 2;
        break;
    case frqpenNormal:
    default:
        (*uiWeight)++;
        break;
    }
}
//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrieIter
//
//  Synopsis:	Constructor - initialize local variables
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiBreakTree::CThaiBreakTree() :  iNodeIndex(0), iNumNode(0),
                                    pszBegin(NULL), pszEnd(NULL),
                                    breakTree(NULL), breakArray(NULL),
                                    tagArray(NULL), maximalMatchingBreakArray(NULL),
                                    maximalMatchingTAGArray(NULL),
                                    POSArray(NULL), maximalMatchingPOSArray(NULL)
{
    // Allocate memory need for CThaiBreakTree.
#if defined (NGRAM_ENABLE)
	breakTree = new ThaiBreakNode[MAXTHAIBREAKNODE];
#endif
    breakArray = new BYTE[MAXBREAK];
    tagArray = new DWORD[MAXBREAK];
    POSArray = new WCHAR[MAXBREAK];
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrieIter
//
//  Synopsis:	Destructor - clean up code
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiBreakTree::~CThaiBreakTree()
{
    // Clean up all memory used.
#if defined (NGRAM_ENABLE)
	if (breakTree)
        delete breakTree;
    if (maximalMatchingBreakArray)
        delete maximalMatchingBreakArray;
    if (maximalMatchingTAGArray)
        delete maximalMatchingTAGArray;
    if (maximalMatchingPOSArray)
        delete maximalMatchingPOSArray;
#endif
    if (breakArray)
        delete breakArray;
    if (tagArray)
        delete tagArray;
    if (POSArray)
        delete POSArray;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:	Associate the class to the string.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
void CThaiBreakTree::Init(CTrie* pTrie, CTrie* pSentTrie, CTrie* pTrigramTrie)
#else
void CThaiBreakTree::Init(CTrie* pTrie, CTrie* pTrigramTrie)
#endif
{
    assert(pTrie != NULL);
    thaiTrieIter.Init(pTrie);
    thaiTrieIter1.Init(pTrie);

#if defined (NGRAM_ENABLE)
    assert(pSentTrie != NULL);
    thaiSentIter.Init(pSentTrie);
#endif
	assert(pTrigramTrie != NULL);
	thaiTrigramIter.Init(pTrigramTrie);
}

#if defined (NGRAM_ENABLE)
//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:	reset iterator to top of the tree
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiBreakTree::Reset()
{
	iNodeIndex = 0;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:	Move to the next break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::MoveNext()
{
	iNodeIndex = breakTree[iNodeIndex].NextBreak;
	return (iNodeIndex != 0);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Move down to next level.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::MoveDown()
{
	iNodeIndex = breakTree[iNodeIndex].Down;
	return (iNodeIndex != 0);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   create new node to position, and return index to the node.
//
//              * return Unable to Create Node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline unsigned int CThaiBreakTree::CreateNode(int iPos, BYTE iBreakLen, DWORD dwTAG)
{
    assert(iNumNode < MAXTHAIBREAKNODE);

    breakTree[iNumNode].iPos = iPos;
    breakTree[iNumNode].iBreakLen = iBreakLen;
    breakTree[iNumNode].dwTAG = dwTAG;
    breakTree[iNumNode].NextBreak = 0;
    breakTree[iNumNode].Down = 0;
    if  (iNumNode >= MAXTHAIBREAKNODE)
    {
        return UNABLETOCREATENODE;
    }

    iNumNode++;
    return (iNumNode - 1);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Generate a Tree of possible break from the given string.
//
//              * Note - false if there aren't enough memory to create node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
enum thai_parse_state {
                        END_SENTENCE,    // Reached the end of sentence.
                        LONGEST_MATCH,   // Longest possible matched.
                        NOMATCH_FOUND,   // Unable to find word.
                        ERROR_OUTMEMORY, // Out of Memory.
                      };

bool CThaiBreakTree::GenerateTree(WCHAR* pszBegin, WCHAR* pszEnd1)
{
    // Declare and initialize local variables.
    unsigned int iIndexBreakTree = 0;
    unsigned int iPrevIndexBreakTree = 0;
    unsigned int iParentNode = 0;
    WCHAR* pszBeginWord = pszBegin;
    WCHAR* pszIndex = pszBegin;
    unsigned int iNumCluster = 1;
    unsigned int iNumLastCluster;
    unsigned int iWordLen = 0;
	unsigned int iNodeAnalyze = 0;
    thai_parse_state parseState = END_SENTENCE;
    bool fFoundMatch = false;
    bool fAddToNodeAnalyze = false;
    bool fDoneGenerateTree = false;
    pszEnd = pszEnd1;

#if defined (_DEBUG)
    memset(breakTree,0,sizeof(ThaiBreakNode)*MAXTHAIBREAKNODE);
#endif
    iNodeIndex = 0;
    iNumNode = 0;

    while (true)
    {
        // Reset Iterator for generating break for new word.
        fFoundMatch = false;
        thaiTrieIter.Reset();
		
		if (iIndexBreakTree != 0)
        {
            while (true)
            {
			    // If this is not the first node than set pszBeginWord after the last break.
			    pszBeginWord = pszBegin + breakTree[iNodeAnalyze].iPos + breakTree[iNodeAnalyze].iBreakLen;
                fAddToNodeAnalyze = true;

                // Are we at the end of the sentence.
                if ( (pszBeginWord == pszEnd) ||
                     (breakTree[iNodeAnalyze].dwTAG == TAGPOS_PURGE) )
                {
                    iNodeAnalyze++;             // Move to next node.
                    if (iNodeAnalyze >= iNumNode)
                    {
                        fDoneGenerateTree = true;
                        break;
                    }
                }   
                else
                    break;
            }
        }
        pszIndex = pszBeginWord;
        iParentNode = iNodeAnalyze;

        if (fDoneGenerateTree)
            break;

		// Get next level of tree.
        while (TRUE)
        {
            iNumLastCluster = iNumCluster;
            iNumCluster = GetCluster(pszIndex);
            if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster))
            {
                pszIndex += iNumCluster;
                if (thaiTrieIter.fWordEnd)
                {
                    fFoundMatch = true;
                    // if first node add first node
                    if (iIndexBreakTree == 0)
                    {
                        CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, thaiTrieIter.dwTag);
                        iIndexBreakTree++;
                    }
                    else
                    {
						if (fAddToNodeAnalyze)
						{
                            fAddToNodeAnalyze = false;
							breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, thaiTrieIter.dwTag);

                            // Determine if an error has occur.
                            if (breakTree[iNodeAnalyze].NextBreak == UNABLETOCREATENODE)
                            {
                                breakTree[iNodeAnalyze].NextBreak = 0;
                                parseState = ERROR_OUTMEMORY;
                                break;
                            }

                            iPrevIndexBreakTree = breakTree[iNodeAnalyze].NextBreak;
							iNodeAnalyze++;
						}
						else
						{
                            breakTree[iPrevIndexBreakTree].Down = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, thaiTrieIter.dwTag);

                            // Determine if an error has occur.
                            if (breakTree[iPrevIndexBreakTree].Down == UNABLETOCREATENODE)
                            {
                                breakTree[iPrevIndexBreakTree].Down = 0;
                                parseState = ERROR_OUTMEMORY;
                                break;
                            }

                            iPrevIndexBreakTree = iIndexBreakTree;
						}
       	                iIndexBreakTree++;
                    }
                }

				if (pszIndex >= pszEnd)
				{
					assert(pszIndex <= pszEnd);			// assert should never come up - if it appear likely bug in GetCluster funciton.
                    parseState = END_SENTENCE;
					break;
				}
            }
            else
            {
                if (fFoundMatch)
                    parseState = LONGEST_MATCH;
                else
                    parseState = NOMATCH_FOUND;
                break;

            }
        }

	    if (parseState == LONGEST_MATCH)
        {
            // We found a matched.
            assert(breakTree[iPrevIndexBreakTree].Down == 0);  // at this point breakTree[iPreveIndexBreakTree].Down should equal null.(optimization note)
            if (breakTree[iParentNode].NextBreak != iPrevIndexBreakTree) 
            {
                assert(breakTree[iPrevIndexBreakTree].dwTAG != TAGPOS_UNKNOWN);  // shouldn't assert because the end node should ever be unknown.
                DeterminePurgeEndingSentence(pszBeginWord, breakTree[iParentNode].NextBreak);
            }
        }
        else if (parseState == NOMATCH_FOUND)
        {
            // Should mark node as unknown.
            if (fAddToNodeAnalyze)
            {
                fAddToNodeAnalyze = false;
                iWordLen = pszIndex - pszBeginWord;
                
                // Make sure we don't only have a cluster of text before making a node.
                if (iWordLen == 0)
                {
                    // If we have an UNKNOWN word of one character only current node mark it as unknown.
                    assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                    breakTree[iNodeAnalyze].iBreakLen += iNumCluster;
                    breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                }
                else
                {
                    if (breakTree[iNodeAnalyze].iBreakLen + iWordLen < 8)
                                            // The reason we are using 8 is because from corpora analysis
                                            // the average Thai word is about 7.732 characters.
                                            // TODO: We should add orthographic analysis here to get a better on boundary
                                            // of unknown word.
                    {
                        assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                        breakTree[iNodeAnalyze].iBreakLen += iWordLen;
                        breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                    }
                    else
                    {
                        if (GetWeight(pszIndex - iNumLastCluster))
                            breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen - iNumLastCluster, TAGPOS_UNKNOWN);
                        else
                            breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen, TAGPOS_UNKNOWN);

                        // Determine if an error has occur.
                        if (breakTree[iNodeAnalyze].NextBreak == UNABLETOCREATENODE)
                        {
                            breakTree[iNodeAnalyze].NextBreak = 0;
                            parseState = ERROR_OUTMEMORY;
                            break;
                        }
                        iNodeAnalyze++;
                        iIndexBreakTree++;
                    }
                }
            }
            else
            {
                breakTree[iPrevIndexBreakTree].Down = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, TAGPOS_UNKNOWN);

                // Determine if an error has occur.
                if (breakTree[iPrevIndexBreakTree].Down == UNABLETOCREATENODE)
                {
                    breakTree[iPrevIndexBreakTree].Down = 0;
                    parseState = ERROR_OUTMEMORY;
                    break;
                }
                iIndexBreakTree++;
            }
        }
        else if (parseState == END_SENTENCE)
        {
            // If we find ourself at the end of a sentence and no match.
            if (!fFoundMatch)
            {
                if (fAddToNodeAnalyze)
                {
                    fAddToNodeAnalyze = false;
                    iWordLen = pszIndex - pszBeginWord;
                
                    // Make sure we don't only have a cluster of text before making a node.
                    if (iWordLen == 0)
                    {
                        // If we have an UNKNOWN word of one character only current node mark it as unknown.
                        assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                        breakTree[iNodeAnalyze].iBreakLen += iNumCluster;
                        breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                    }
                    else
                    {
                        if (breakTree[iNodeAnalyze].iBreakLen + iWordLen < 8)
                                                // The reason we are using 8 is because from corpora analysis
                                                // the average Thai word is about 7.732 characters.
                                                // TODO: We should add orthographic analysis here to get a better on boundary
                                                // of unknown word.
                        {
                            assert(iNodeAnalyze == iParentNode);                // Since we have a no match iNodeAnalyze better equal iParentNode
                            breakTree[iNodeAnalyze].iBreakLen += iWordLen;
                            breakTree[iNodeAnalyze].dwTAG = DeterminePurgeOrUnknown(iNodeAnalyze,breakTree[iNodeAnalyze].iBreakLen);
                        }
                        else
                        {
                            if (GetWeight(pszIndex - iNumLastCluster))
                                breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen - iNumLastCluster, TAGPOS_UNKNOWN);
                            else
                                breakTree[iNodeAnalyze].NextBreak = CreateNode(pszBeginWord - pszBegin, iWordLen, TAGPOS_UNKNOWN);

                            // Determine if an error has occur.
                            if (breakTree[iNodeAnalyze].NextBreak == UNABLETOCREATENODE)
                            {
                                breakTree[iNodeAnalyze].NextBreak = 0;
                                parseState = ERROR_OUTMEMORY;
                                break;
                            }
                            iNodeAnalyze++;
                            iIndexBreakTree++;
                        }
                    }
                }
                else
                {
                    breakTree[iPrevIndexBreakTree].Down = CreateNode(pszBeginWord - pszBegin, pszIndex - pszBeginWord, TAGPOS_UNKNOWN);

                    // Determine if an error has occur.
                    if (breakTree[iPrevIndexBreakTree].Down == UNABLETOCREATENODE)
                    {
                        breakTree[iPrevIndexBreakTree].Down = 0;
                        parseState = ERROR_OUTMEMORY;
                        break;
                    }
                }
                iIndexBreakTree++;
            }
            // If the beginning of node the branch isn't equal to leaf node perphase it is possible to
            // do some ending optimization.
            else if (breakTree[iParentNode].NextBreak != iPrevIndexBreakTree) 
            {
                assert(breakTree[iPrevIndexBreakTree].dwTAG != TAGPOS_UNKNOWN);  // shouldn't assert because the end node should ever be unknown.
                DeterminePurgeEndingSentence(pszBeginWord, breakTree[iParentNode].NextBreak);
            }
        }
        else if ( (breakTree[iNodeAnalyze].iBreakLen == 0) || (parseState == ERROR_OUTMEMORY) )
            break;
    }

    return (parseState != ERROR_OUTMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Traverse all the tree and look for the least number of token.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiBreakTree::MaximalMatching()
{
    // If maximal matching break array has not been allocate, than allocate it.
    if (!maximalMatchingBreakArray)
        maximalMatchingBreakArray = new BYTE[MAXBREAK];
    if (!maximalMatchingTAGArray)
        maximalMatchingTAGArray = new DWORD[MAXBREAK];
    if (!maximalMatchingPOSArray)
        maximalMatchingPOSArray = new WCHAR[MAXBREAK];

    maxLevel = MAXUNSIGNEDINT;
    maxToken = 0;
    iNumUnknownMaximalPOSArray = MAXBREAK;
    Traverse(0,0,0);

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   The function determine if the node if the node should,
//              be tag as unknown or purge.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline DWORD CThaiBreakTree::DeterminePurgeOrUnknown(unsigned int iCurrentNode, unsigned int iBreakLen)
{
    // Declare and initialize local variables.
    unsigned int iNode = breakTree[iCurrentNode].Down;

    while (iNode != 0)
    {
        if ( (breakTree[iNode].iBreakLen == iBreakLen)     ||
             (breakTree[iNode].iBreakLen < iBreakLen)      &&
             ( (breakTree[iNode].dwTAG != TAGPOS_UNKNOWN)  ||
               (breakTree[iNode].dwTAG != TAGPOS_PURGE)    ))
        {
            // Since we are purging this break just make sure the NextBreak is Null.
            assert(breakTree[iCurrentNode].NextBreak == 0);
            return TAGPOS_PURGE;
        }

        iNode = breakTree[iNode].Down;
    }
    return TAGPOS_UNKNOWN;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Ending optimization - if we have found the end of a sentence,
//              and possible break.  Purge the branch for unnecessary break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiBreakTree::DeterminePurgeEndingSentence(WCHAR* pszBeginWord, unsigned int iNode)
{
    while (breakTree[iNode].Down != 0)
    {
        // Determine if the next string has a possiblity to become a word.
        // TODO: We may need to change this once the GetWeight add soundex
        //       functionality.
        if (GetWeight(pszBeginWord + breakTree[iNode].iBreakLen) == 0)
        {
            // Since we are purging this break just make sure the NextBreak is Null.
            assert(breakTree[iNode].NextBreak == 0);
            breakTree[iNode].dwTAG = TAGPOS_PURGE;
        }
        iNode = breakTree[iNode].Down;
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetWeight(WCHAR* pszBegin)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
    unsigned int Weight = 0;
    bool fBeginNewWord;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ((pszEnd - pszBegin) == 1)
        return Weight;
    else if (pszEnd == pszBegin)
        return 1000;

    // Reset Iterator for generating break for new word.
    fBeginNewWord = true;

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster, fBeginNewWord))
        {
            fBeginNewWord = false;
            pszIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
                Weight = (unsigned int) (pszIndex - pszBegin);
        }
        else
            break;
    }
    return Weight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetWeight(WCHAR* pszBegin, DWORD* pdwTag)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
    unsigned int Weight = 0;
    bool fBeginNewWord;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ((pszEnd - pszBegin) == 1)
        return Weight;
    else if (pszEnd == pszBegin)
        return 1000;

    // Reset Iterator for generating break for new word.
    fBeginNewWord = true;

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        if (thaiTrieIter.MoveCluster(pszIndex, iNumCluster, fBeginNewWord))
        {
            fBeginNewWord = false;
            pszIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
			{
                Weight = (unsigned int) (pszIndex - pszBegin);
				*pdwTag = thaiTrieIter.dwTag;
			}
        }
        else
            break;
    }
    return Weight;
}


//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   Traverse the tree.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiBreakTree::Traverse(unsigned int iLevel, unsigned int iCurrentNode, unsigned int iNumUnknown)
{
    assert (iLevel < MAXBREAK);
    // Process node.
    breakArray[iLevel] = breakTree[iCurrentNode].iBreakLen;
    tagArray[iLevel] = breakTree[iCurrentNode].dwTAG;
    if (tagArray[iLevel] ==  TAGPOS_UNKNOWN)
        iNumUnknown++;

    // Have we found the end of the sentence.
    if (breakTree[iCurrentNode].NextBreak == 0)
    {
        if (breakTree[iCurrentNode].dwTAG != TAGPOS_PURGE)
            AddBreakToList(iLevel + 1, iNumUnknown);
        if (breakTree[iCurrentNode].Down != 0)
        {
            if (tagArray[iLevel] == TAGPOS_UNKNOWN)
                iNumUnknown--;
            return Traverse(iLevel,breakTree[iCurrentNode].Down, iNumUnknown);
        }
        else
            return true;
    }
    else
        Traverse(iLevel + 1, breakTree[iCurrentNode].NextBreak, iNumUnknown);

    if (breakTree[iCurrentNode].Down != 0)
    {
       if (tagArray[iLevel] == TAGPOS_UNKNOWN)
           iNumUnknown--;

        Traverse(iLevel,breakTree[iCurrentNode].Down, iNumUnknown);
    }

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::SoundexSearch(WCHAR* pszBegin)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
    unsigned int iNumNextCluster = 1;
    unsigned int iLongestWord = 0;
    unsigned int iPenalty = 0;
    WCHAR* pszIndex = pszBegin;
    
    // Short circuit the length is less of string is less than 1.
    if ( (pszBegin+1) >= pszEnd )
        return iLongestWord;

    // Reset Iterator for generating break for new word.
    thaiTrieIter1.Reset();

    // Get next level of tree.
    while (true)
    {
        iNumCluster = GetCluster(pszIndex);
        
        // Determine iNumNextCluster let iNumNextCluster = 0, if we reached the end of string.
        if (pszIndex + iNumCluster >= pszEnd)
            iNumNextCluster = 0;
        else
            iNumNextCluster = GetCluster(pszIndex+iNumCluster);

        // Determine penalty
        switch (thaiTrieIter1.MoveSoundexByCluster(pszIndex, iNumCluster, iNumNextCluster))
        {
        case SUBSTITUTE_SOUNDLIKECHAR:
            iPenalty += 2;
            break;
        case SUBSTITUTE_DIACRITIC:
            iPenalty++;
            break;
        case UNABLE_TO_MOVE:
            iPenalty += 2;
            break;
        default:
        case NOSUBSTITUTE:
            break;
        }

        // Update Index.
        if (iPenalty <= 2)
        {
            pszIndex += iNumCluster;
            if (thaiTrieIter1.fWordEnd)
                iLongestWord = (unsigned int) (pszIndex - pszBegin);
        }
        else
            break;
    }
    return iLongestWord;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   The information used here is a reference to the orthographic
//              analysis work done on the Thai languages.  (see paper: Natural
//              Language Processing in Thailand 1993 Chulalongkorn. p 361).
//
//  Arguments:  pszBoundaryChar - Contain pointer to at least two thai character
//                                character next to each other which we will
//                                use to calculate wheather we should or
//                                should not merge the two word.
//
//              iPrevWordLen - 
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::ShouldMerge(WCHAR* pwszPrevWord, unsigned int iPrevWordLen, unsigned int iMergeWordLen, DWORD dwPrevTag)
{
    WCHAR* pwszBoundary = pwszPrevWord + iPrevWordLen - 1;

    assert(iMergeWordLen != 0);
    assert(iPrevWordLen != 0);

    // There are very few words in Thai that are 4 character or less, therefore we should
    // found a pair that less than 4 character we should merge.
    // Or if merge word length is one than also merge.
    // Of if last cluster of the word is a Thanthakhat(Karan) we should always merge.
    if (iPrevWordLen + iMergeWordLen <= 4 || iMergeWordLen == 1 ||
        (iMergeWordLen == 2 && *(pwszBoundary + iMergeWordLen) == THAI_Thanthakhat))
        return true;

    if (iPrevWordLen >=2)
    {
        WCHAR* pwszPrevCharBoundary = pwszBoundary - 1;

        // TO IMPROVE: It better to check the last character of Previous word, it can give us a
        // much better guess 
        if ((*pwszPrevCharBoundary == THAI_Vowel_Sign_Mai_HanAkat || *pwszBoundary == THAI_Vowel_Sign_Mai_HanAkat) ||
            (*pwszPrevCharBoundary == THAI_Tone_Mai_Tri           || *pwszBoundary == THAI_Tone_Mai_Tri)           ||
            (*pwszPrevCharBoundary == THAI_Sara_Ue                || *pwszBoundary == THAI_Sara_Ue)                )
            return true;
    }

    // If the first character of the next word is mostly likly the beginning
    // character and last character of the previous word is not sara-A than
    // we have a high probability that we found a begin of word boundary,
    // therefore we shouldn't merge.
    if ( (IsThaiMostlyBeginCharacter(pwszBoundary[1]) && *pwszBoundary != THAI_Vowel_Sara_A) )
        return false;

    // If the last character of the previous word is mostly likely an ending
    // character than, than there is a high probability that the found a boundary.
    // There are very few words in Thai that are 4 character or less, therefore we should
    // found a pair that less than 4 character we should merge.
    if (IsThaiMostlyLastCharacter(*pwszBoundary))
        return false;

    // The reason we are using 8 is because from corpora analysis
    // the average Thai word is about 7.732 characters. Or, if previous word is already
    // an unknown, to keep the amount of unknown low the unknown to previous words.
    if ( (iPrevWordLen + iMergeWordLen < 8) || (dwPrevTag == TAGPOS_UNKNOWN) )
        return true;

    return false;
}


//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//              8/17/99 optimize some code.
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiBreakTree::AddBreakToList(unsigned int iNumBreak, unsigned int iNumUnknown)
{
#if defined (_DEBUG)
    breakArray[iNumBreak] = 0;
#endif
    if (CompareSentenceStructure(iNumBreak, iNumUnknown))
    {
        maxToken = maxLevel = iNumBreak;                          // This is ugly but it save 5 clock cycle.
        memcpy(maximalMatchingBreakArray,breakArray,maxToken);
        memcpy(maximalMatchingTAGArray,tagArray,sizeof(unsigned int)*maxToken);
        maximalMatchingBreakArray[maxToken] = 0;
        maximalMatchingTAGArray[maxToken] = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:   The function compares sentence structure of
//              maximalMatchingPOSArray with posArray.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline bool CThaiBreakTree::CompareSentenceStructure(unsigned int iNumBreak, unsigned int iNumUnknownPOSArray)
{
    if ( (iNumBreak < maxLevel) && (iNumUnknownMaximalPOSArray >= iNumUnknownPOSArray) )
    {
        iNumUnknownMaximalPOSArray = iNumUnknownPOSArray;
        return true;
    }
    else if (iNumBreak == maxLevel)
    {
        // true - maximal matching has a larger unknown.
        if (iNumUnknownMaximalPOSArray > iNumUnknownPOSArray)
        {
            iNumUnknownMaximalPOSArray = iNumUnknownPOSArray;
            return true;
        }

        for(unsigned int i = 0; i <= iNumBreak; i++)
        {
            maximalMatchingPOSArray[i] = ExtractPOS(maximalMatchingTAGArray[i]);
            POSArray[i] = ExtractPOS(tagArray[i]);
        }

        // Determine if the sentence structure is like any one of the sentence
        // sentence structure in our corpora.
        if ( (IsSentenceStruct(POSArray, iNumBreak)) &&
             (!IsSentenceStruct(maximalMatchingPOSArray, iNumBreak)) )
        {
            iNumUnknownMaximalPOSArray = iNumUnknownPOSArray;
            return true;
        }
        else if (iNumUnknownMaximalPOSArray == iNumUnknownPOSArray)
        {
            // Determine the frequency of word used in the sentence.
            unsigned int iFrequencyArray = 500;
            unsigned int iFrequencyMaximalArray = 500;
            
            for(unsigned int i = 0; i <= iNumBreak; i++)
            {
                DetermineFrequencyWeight(ExtractFrq(maximalMatchingTAGArray[i]),&iFrequencyMaximalArray);
                DetermineFrequencyWeight(ExtractFrq(tagArray[i]),&iFrequencyArray);
            }
            return (iFrequencyArray > iFrequencyMaximalArray);
        }
    }
    return false;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiBreakTree::IsSentenceStruct(WCHAR* pos, unsigned int iPosLen)
{
	// Declare and initialize all local variables.
	unsigned int i = 0;

	thaiSentIter.Reset();

	if (!thaiSentIter.Down())
		return FALSE;

    while (TRUE)
	{
		thaiSentIter.GetNode();
		if (thaiSentIter.pos == pos[i])
		{
			i++;
			if (thaiSentIter.fWordEnd && i == iPosLen)
            {
				return TRUE;
            }
			else if (i == iPosLen) break;
			// Move down the Trie Branch.
			else if (!thaiSentIter.Down()) break;
		}
		// Move right of the Trie Branch
		else if (!thaiSentIter.Right()) break;
	}
	return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
float CThaiBreakTree::BigramProbablity(DWORD dwTag1,DWORD dwTag2)
{
	unsigned int iWeight = 4;

	// TODO : Use the distribution of word category to determine optimial search - exmaple
	//        NOUN VERB ADVERB CLASSIFIER CONJETURE PREP et....
	// TODO : Once we got trigram use it to create bigram probability as well.
    if ( (dwTag1 != TAGPOS_UNKNOWN) &&
         (dwTag2 != TAGPOS_UNKNOWN) )
	{
        WCHAR pos1 = ExtractPOS(dwTag1);
        WCHAR pos2 = ExtractPOS(dwTag2);

		// case NCMN VATT
		///     a common noun is often followed by attributive verb(adjective)
		//      Example: (In Thai) book good, people nice
		if (pos1 == 5 && pos2 == 13)
			iWeight += 10;
		// case NTTL NPRP
		//      a title noun is often followed by proper noun
		//      Example: Dr. Athapan, Mr. Sam
		else if (pos1 == 6 && pos2 == 1)
			iWeight += 5;
		// case JSBR (XVAM || VSTA)
		//      a subordinating conjunction is often followed by preverb auxillary or Active verb
		//      Example: (In Thai) Because of , Because see
		else if (pos1 == 39 && (pos2 == 15 || pos2 == 12))
			iWeight += 10;
		// case ADVN NCMN
		//      a Adverb normal form is often followed by Common noun (Bug 55057).
		//      Example: (In Thai) under table.
		else if (pos1 == 28 && pos2 == 5)
			iWeight += 5;
		// case VACT XVAE
		else if (pos1 == 11 && pos2 == 18)
			iWeight += 5;
		// case VACT DDBQ
		//      Active verb follow by Definite determiner.
		//      Example: (In Thai) working for, singing again.
		else if (pos1 == 11 && pos2 == 21)
			iWeight += 10;
		// case XVAE VACT
		//      a post verb auxilliary are often followed by an active verb.
		//      Example: (In Thai) come singing, go work.
		else if (pos1 == 18 && pos2 == 11)
			iWeight += 10;
		// case CLTV NCMN
		//      a Collective classfier are often followed by Common Noun
		//      Example: (In Thai) group people, flock bird
		else if (pos1 == 33 && pos2 == 5)
			iWeight += 5;
		// case NEG (VACT || VSTA || VATT || XVAM || XVAE)
		//      a negator (ie. not) is often followed by some kind of VERB.
		//      Example: He is not going.
		else if (pos1 == 46 && (pos2 == 11 || pos2 == 12 || pos2 == 13 || pos2 == 15 || pos2 == 16))
			iWeight += 8;
		// case EAFF or EITT
		//      Ending for affirmative, and interrogative are more often ending of the pair
		//      Example: (In Thai) Krub, Ka, 
		else if (pos2 == 44 || pos2 == 45)
			iWeight += 3;
		// case VATT and VATT
		//      Attributive Verb and Attributive Verb occur when often in spoken laguages.
		//      Example: she is reall really cute.  
		else if (pos1 == 13 && pos2 == 13)
			iWeight += 2;
		// case NCMN and DDAC
		//      Common Noun and Definitive determiner classifier.
		//      Example: Food here (Thai)
		else if (pos1 == 5 && pos2 == 20)
			iWeight += 3;
		// case CMTR and JCMP
		//      Measurement classifier and Comparative conjunction, are likly to appear in Thai.
		//      Example: year about (Thai) -> English about a year.
		else if (pos1 == 34 && pos2 == 38)
			iWeight += 5;
	}

	DetermineFrequencyWeight(ExtractFrq(dwTag1), &iWeight);
	DetermineFrequencyWeight(ExtractFrq(dwTag2), &iWeight);
	return (float) iWeight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CThaiBreakTree::TrigramProbablity(DWORD dwTag1,DWORD dwTag2,DWORD dwTag3)
{
	DWORD iWeight = 6;

    if ( (dwTag1 != TAGPOS_UNKNOWN) &&
         (dwTag2 != TAGPOS_UNKNOWN) &&
         (dwTag3 != TAGPOS_UNKNOWN) )
    {
        WCHAR pos1 = ExtractPOS(dwTag1);
        WCHAR pos2 = ExtractPOS(dwTag2);
        WCHAR pos3 = ExtractPOS(dwTag3);
		WCHAR posArray[4];
		posArray[0] = pos1;
		posArray[1] = pos2;
		posArray[2] = pos3;
		posArray[3] = 0;
        iWeight += thaiTrigramIter.GetProb(posArray);

/*
        // TODO: We are hard coding this part until we get finish Trigram probablity analysis
        //       than we simply return stright look up.
        if ( (pos1 == 18)   &&          // Post verb auxiliary - XVAE
             (pos2 == 5 )   &&          // Common Noun - NCMN
             (pos3 == 18)   )           // Post verb auxiliary - XVAE
        {
            return 70;              // Return 70% probablity
        }
        else if ( (pos1 == 18)   &&          // Post verb auxiliary - XVAE
                  (pos2 == 5 )   &&          // Common Noun - NCMN
                  (pos3 == 5 )   )           // Common Noun - NCMN
        {
            return 30;             // Return 30%.
        }
*/
//        iWeight = thaiTrigramIter.GetProb(pos1,pos2,pos3);

    }
	DetermineFrequencyWeight(ExtractFrq(dwTag1), &iWeight);
	DetermineFrequencyWeight(ExtractFrq(dwTag2), &iWeight);
	DetermineFrequencyWeight(ExtractFrq(dwTag3), &iWeight);
	
    // We reached zero probablity.
    return (DWORD)iWeight;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::TrigramBreak(WCHAR* pwchBegin, WCHAR* pwchEnd1)
{
    // Declare and initialize local variables.
    WCHAR* pwchBeginWord = pwchBegin;
    WCHAR* pwchIndex = pwchBegin;
    unsigned int iWordLen;
    unsigned int iNumCluster = 1;
    unsigned int iNumLastCluster;
    unsigned int iBreakIndex = 0;
    BYTE nextBreakArray[MAXBREAK];
    DWORD nextTagArray[MAXBREAK];
    unsigned int iNextBreakIndex;           // index for array nextBreakArray and nextTagArray.
    bool fFoundMatch;
    unsigned int iWeight;
    unsigned int iSumWeight;
    unsigned int iPrevWeight;
    BYTE iSoundexWordLen;
    DWORD iPrevProbability;
    DWORD iCurrentProbability;
	DWORD dwTagTemp;
	DWORD dwLastTag;
    int i;                                  // temporary int for use as need.
    bool fBeginNewWord;
	bool fEndWord = false;

    pszEnd = pwchEnd1;
    breakArray[0] = 0;
    POSArray[0] = 0;
    tagArray[0] = 0;
    nextBreakArray[0] = 0;
    nextTagArray[0] = 0;

    while (true)
    {
        // Reset Iterator for generating break for new word.
        fFoundMatch = false;
        fBeginNewWord = true;


        // Get begin word string for next round of word break.
        pwchIndex = pwchBeginWord;        
        iNextBreakIndex = 0;

        if (pwchIndex == pszEnd)
            break;

        while(true)
        {
            iNumLastCluster = iNumCluster;
            iNumCluster = GetCluster(pwchIndex);
            if (!thaiTrieIter.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
			{
				if ((iNumCluster == 0) && (pwchIndex == pszEnd))
					fEndWord = true;
				else
					break;
			}

            fBeginNewWord = false;
            pwchIndex += iNumCluster;
            if (thaiTrieIter.fWordEnd)
            {
				if (thaiTrieIter.m_fThaiNumber)
				{
					// If we have Thai number accumulate it as one break.
					assert(iNumCluster == 1);
					fFoundMatch = true;
					nextBreakArray[0]= (BYTE)(pwchIndex - pwchBeginWord);
					nextTagArray[0] = TAGPOS_NCNM;
					iNextBreakIndex = 1;
				}
				else
				{
					fFoundMatch = true;
					nextBreakArray[iNextBreakIndex] =  (BYTE)(pwchIndex - pwchBeginWord);
					nextTagArray[iNextBreakIndex] = thaiTrieIter.dwTag;
					iNextBreakIndex++;              
				}
				if (pwchIndex >= pszEnd)
				{
					assert(pwchIndex <= pszEnd);			// assert should never come up - if it appear likely bug in GetCluster funciton.
					assert(iNextBreakIndex != 0);
					breakArray[iBreakIndex] = nextBreakArray[iNextBreakIndex - 1];
					tagArray[iBreakIndex] = nextTagArray[iNextBreakIndex - 1];
					return (++iBreakIndex);
				}
            }
            else if ((pwchIndex >= pszEnd && iNextBreakIndex == 0) || fEndWord)
            {
                assert(pwchIndex <= pszEnd);			// assert should never come up - if it appear likely bug in GetCluster funciton.
                iWordLen = (unsigned int) (pwchIndex - pwchBeginWord);
                switch (iWordLen)
                {
                case 0:
                    if (iBreakIndex > 0)
                    {
                        // if We have a length of one character add it to previous node.
                        breakArray[iBreakIndex - 1] +=  (BYTE) iNumCluster;
                        tagArray[iBreakIndex - 1] = TAGPOS_UNKNOWN;
                    }
                    else
                    {
                        // if this is the first break create a new break.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        iBreakIndex++;
                    }
                    break;
                case 1:
                    if (iBreakIndex > 0)
                    {
                        // if We have a length of one character add it to previous node.
                        breakArray[iBreakIndex - 1] +=  (BYTE) iWordLen;
                        tagArray[iBreakIndex - 1] = TAGPOS_UNKNOWN;
                    }
                    else
                    {
                        // if this is the first break create a new break.
                        breakArray[iBreakIndex] =  (BYTE) iWordLen;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        iBreakIndex++;
                    }
                    break;
                default:
					if ( iBreakIndex > 0 &&
						 ShouldMerge(pwchBeginWord - breakArray[iBreakIndex - 1], breakArray[iBreakIndex - 1],
						             iWordLen , tagArray[iBreakIndex - 1]) )
					{
						breakArray[iBreakIndex - 1] += (BYTE) iWordLen;
						tagArray[iBreakIndex - 1] = TAGPOS_UNKNOWN;
					}
					else
					{
						breakArray[iBreakIndex] = (BYTE) iWordLen;
						tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
						iBreakIndex++;
					}
                }
                return iBreakIndex;
            }
        }

		if (fFoundMatch)        // Longest Matching.
		{
            // If we only found one break, than say it the maximum.
            if (1 == iNextBreakIndex)
			{
                breakArray[iBreakIndex] = nextBreakArray[0];
                tagArray[iBreakIndex] = nextTagArray[0];
			}
			else
            {
                iSumWeight = 0;
                iPrevWeight = 0;
                iPrevProbability = 0;
                iCurrentProbability = 0;
				dwLastTag = TAGPOS_UNKNOWN;
				tagArray[iBreakIndex] = TAGPOS_UNKNOWN;

                for (i = (iNextBreakIndex - 1); i >= 0 ; i--)
			    {
					if ( iBreakIndex == 0)
					{
						iWeight = GetWeight(pwchBeginWord + nextBreakArray[i], &dwTagTemp);

						if (iWeight != 0)
							// Bigram Probability
							iCurrentProbability = (DWORD)BigramProbablity(nextTagArray[i], dwTagTemp);
					}
					else
					{
						iWeight = GetWeight(pwchBeginWord + nextBreakArray[i], &dwTagTemp);

						if (iBreakIndex == 1)
							// Get Trigram Probability.
							iCurrentProbability = TrigramProbablity(tagArray[iBreakIndex - 1], nextTagArray[i], dwTagTemp);	
						else if (iBreakIndex >= 2)
						{
							// Get Trigram Probability.
							iCurrentProbability = TrigramProbablity(tagArray[iBreakIndex - 2], tagArray[iBreakIndex - 1], nextTagArray[i]);
							if (iWeight != 0)
								iCurrentProbability += (DWORD)BigramProbablity(nextTagArray[i],dwTagTemp);
						}
					}

                    // Store the string the best maximum weight, if the pair is equal
                    // store the string with maxim
				    if ( (iWeight + nextBreakArray[i] > iSumWeight)             ||
    					 ( (iWeight + nextBreakArray[i] == iSumWeight)          &&
                           ( (Maximum(iWeight,nextBreakArray[i]) <= iPrevWeight) || (iCurrentProbability > iPrevProbability) ) ))
	    			{
                        if (iCurrentProbability >= iPrevProbability || iSumWeight < iWeight + nextBreakArray[i])
                        {
					        iSumWeight = Maximum(iWeight,1) + nextBreakArray[i];
					        iPrevWeight = Maximum(iWeight,nextBreakArray[i]);
                            breakArray[iBreakIndex] = nextBreakArray[i];
                            tagArray[iBreakIndex] = nextTagArray[i];
                            iPrevProbability = iCurrentProbability;
							dwLastTag = dwTagTemp;
                        }
				    }
			    }
            }
            pwchBeginWord += breakArray[iBreakIndex];          // update begin word for next round.
            iBreakIndex++;
		}
        else
        {
            // NOMATCH_FOUND
            iWordLen = (unsigned int)(pwchIndex - pwchBeginWord);
            if (iBreakIndex > 0)
            {
                i = iBreakIndex - 1;        // set i to previous break
                if (iWordLen == 0)
                {
					if (iNumCluster == 1 && *pwchBeginWord == L',' &&
						IsThaiChar(*(pwchBeginWord-breakArray[i])) )
					{
						// We should not merge comma into the word, only merge comma to
						// Number.
						// TODO: Should add TAGPOS_PUNCT.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        pwchBeginWord += (BYTE) iNumCluster;   // update begin word for next round.
                        iBreakIndex++;
					}
                    else if (ShouldMerge(pwchBeginWord - breakArray[i], breakArray[i], iNumCluster, tagArray[i]))
                    {
                        // If word length is null use the cluster add to previous node.
                        breakArray[i] += (BYTE) iNumCluster;
                        tagArray[i] = TAGPOS_UNKNOWN;
                        pwchBeginWord += iNumCluster;          // update begin word for next round.
                    }
                    else
                    {
                        // Add the unknown word to list.
                        breakArray[iBreakIndex] = (BYTE) iNumCluster;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        pwchBeginWord += (BYTE) iNumCluster;   // update begin word for next round.
                        iBreakIndex++;
                    }
                }
                else
                {
                    // Perphase Misspelled word try use sounding to spell the words.
                    
					if (iWordLen == 1 && iNumCluster == 2 && pwchIndex[1] == L'.')
					{
						// The word is an abbrivated words.
						// TODO: #1. Add TAGPOS_ABBRV.
						// TODO: #2. May need to add rules code abbrivated word with 3 letters.
						breakArray[iBreakIndex] = iWordLen + iNumCluster;
						tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
	                    pwchBeginWord += breakArray[iBreakIndex];
                        iBreakIndex++;
					}
                    // Try soundex two word back.
                    else if ( (iBreakIndex >= 2)																																&&
                         ( (iSoundexWordLen = (BYTE) SoundexSearch(pwchBeginWord - breakArray[i] - breakArray[i - 1])) > (BYTE) (breakArray[i] + breakArray[i - 1]) )	&&
                            GetWeight(pwchBeginWord - breakArray[i] - breakArray[i - 1] + iSoundexWordLen) )
                    {
                        // Resize the word.
                        pwchBeginWord = (pwchBeginWord - breakArray[i] - breakArray[i - 1]) + iSoundexWordLen;          // update begin word for next round.
                        breakArray[i - 1] = iSoundexWordLen;
                        tagArray[i - 1] = thaiTrieIter.dwTag;
                        iBreakIndex--;                         // Decrement iBreakIndex.
                    }
                    // Try soundex one words back.
                    else if (((iSoundexWordLen = (BYTE) SoundexSearch(pwchBeginWord - breakArray[i])) > (BYTE) breakArray[i]) &&
                            GetWeight(pwchBeginWord - breakArray[i] + iSoundexWordLen) )
                    {
                        // Resize the word
                        pwchBeginWord = (pwchBeginWord - breakArray[i]) + iSoundexWordLen;          // update begin word for next round.
                        breakArray[i] = iSoundexWordLen;
                        tagArray[i] = thaiTrieIter.dwTag;
                    }
                    // Try soundex on this word.
                    else if (((iSoundexWordLen = (BYTE) SoundexSearch(pwchBeginWord)) > (BYTE) iWordLen) &&
                            GetWeight(pwchBeginWord + iSoundexWordLen) )
                    {
                        // Resize the word.
                        breakArray[iBreakIndex] = iSoundexWordLen;
                        tagArray[iBreakIndex] = thaiTrieIter.dwTag;
                        pwchBeginWord += iSoundexWordLen;          // update begin word for next round.
                        iBreakIndex++;
                    }
                    else if ( ShouldMerge(pwchBeginWord - breakArray[i], breakArray[i], iWordLen , tagArray[i]) )
                    {
                        // Merge the words.
                        breakArray[i] += (BYTE) iWordLen;
                        tagArray[i] = TAGPOS_UNKNOWN;
                        pwchBeginWord += iWordLen;          // update begin word for next round.
                    }
                    else
                    {
                        // Add the unknown word to list.
                        breakArray[iBreakIndex] = (BYTE) iWordLen;
                        tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                        pwchBeginWord += iWordLen;          // update begin word for next round.
                        iBreakIndex++;
                    }
                }
            }
            else
            {
                // Add unknown word to list and mark it.
                if (iWordLen == 0)
                {
                    // If word length is null use the cluster add to previous node.
                    breakArray[iBreakIndex] = (BYTE) iNumCluster;
                    tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                    pwchBeginWord += iNumCluster;          // update begin word for next round.
                }
                else
                {
					// We we are here there are 2 case that can happen:
					// 1. We take too little into our unknown.
					// 2. We take too much into our unknown word.

					// Have we taken too little check if this unknown word is an abbrivated words.
					if (iWordLen == 1 && iNumCluster == 2 && pwchIndex[1] == L'.')
						breakArray[iBreakIndex] = iWordLen + iNumCluster;
					// Try to see if we are taking to much, see if we can get a Weight from last cluster.
                    else if ( (iWordLen - iNumLastCluster > 0) && GetWeight(pwchIndex - iNumLastCluster) )
                        breakArray[iBreakIndex] = iWordLen - iNumLastCluster;
                    else
                        breakArray[iBreakIndex] = (BYTE) iWordLen;
                    tagArray[iBreakIndex] = TAGPOS_UNKNOWN;
                    pwchBeginWord += breakArray[iBreakIndex];    // update begin word for next round.
                }
                iBreakIndex++;
            }
        }
    }
    return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiBreakTree::Soundex(WCHAR* word)
{
    return thaiTrieIter.Soundex(word);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCluster
//
//  Synopsis:   The function return the next number of character which represent
//              a cluster of Thai text.
//
//              ie. Kor Kai, Kor Kai -> 1
//                  Kor Kai, Sara Um -> 2
//
//              * Note this function will not return no more than 3 character,
//                for cluster as this would represent invalid sequence of character.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiBreakTree::GetCluster(WCHAR* pszIndex)
{
    bool fHasSaraE;
    int iRetValue = 0;
    bool fNeedEndingCluster = false;

	if (pszIndex == pszEnd)
		return 0;

    while (true)
    {
        fHasSaraE= false;

        // Take all begin cluster character.
        while (IsThaiBeginClusterCharacter(*pszIndex))
        {
            if (*pszIndex == THAI_Vowel_Sara_E)
                fHasSaraE = true;
            pszIndex++;
            iRetValue++;

        }

        if (IsThaiConsonant(*pszIndex))
        {
            pszIndex++;
            iRetValue++;

            while (IsThaiUpperAndLowerClusterCharacter(*pszIndex))
            {
                // Mai Han Akat is a special type of cluster that will need at lease
                // one ending cluster.
                if (*pszIndex == THAI_Vowel_Sign_Mai_HanAkat)
                    fNeedEndingCluster = true;

                // In Thai it isn't possible to make a sound if we have the SaraE
                // following by vowel below vowel.
                else if ( fHasSaraE                             &&
                        ( (*pszIndex == THAI_Vowel_Sara_II)     || 
                          (*pszIndex == THAI_Tone_MaiTaiKhu)    ||
                          (*pszIndex == THAI_Vowel_Sara_I)      ||
                          (*pszIndex == THAI_Sara_Uee)          ))
                    fNeedEndingCluster = true;
                pszIndex++;
                iRetValue++;
            }

            while (IsThaiEndingClusterCharacter(*pszIndex))
            {
                pszIndex++;
                iRetValue++;
                fNeedEndingCluster = false;
            }

			// Include period as part of a cluster.  Bug#57106
			if (*pszIndex == 0x002e)
			{
				pszIndex++;
				iRetValue++;
				fNeedEndingCluster = false;
			}
        }

        if (fNeedEndingCluster)
            fNeedEndingCluster = false;
        else
            break;
    }

    if (iRetValue == 0)
        iRetValue++;   // The character is probably a punctuation.

	if (pszIndex > pszEnd)
	{
		// We need to do this as we have gone over end buff boundary.
		iRetValue -= (int) (pszIndex - pszEnd);
		pszIndex = pszEnd;
	}
    return iRetValue;
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiBreakTree
//
//  Synopsis:
//				
//  Arguments:
//
//			wzWord			- input string.								(in)
//			iWordLen		- input string length.						(in)	
//			Alt				- find close alternate word					(in)
//			pBreakPos		- array of break position allways 5 byte.	(out)
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiBreakTree::FindAltWord(WCHAR* pwchBegin,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos)
{
    // Declare and initialize local variables.
    unsigned int iNumCluster = 1;
	WCHAR* pwchBeginWord = pwchBegin;
    WCHAR* pwchIndex = pwchBegin;
	bool fBeginNewWord = true;
	unsigned int iBreakIndex = 0;
	unsigned int iBreakTemp  = 0;
	unsigned int iBreakTemp1 = 0;
	unsigned int iBreakTemp2 = 0;

	pszEnd = pwchBegin + iWordLen;
    
	// TODO: Need to clean this code up.
	switch(Alt)
	{
	case 3:
		while (true)
		{
			iNumCluster = GetCluster(pwchIndex);

			if (!thaiTrieIter1.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
				return iBreakIndex;

			fBeginNewWord = false;
			pwchIndex += iNumCluster;
			if (thaiTrieIter1.fWordEnd)
			{
				iBreakTemp  = (unsigned int)(pwchIndex - pwchBeginWord);
				iBreakTemp1 = GetWeight(pwchIndex);
				iBreakTemp2 = GetWeight(pwchIndex+iBreakTemp1);
				if (iBreakTemp + iBreakTemp1 + iBreakTemp2 == iWordLen)
				{
					pBreakPos[0] = (BYTE)iBreakTemp;
					pBreakPos[1] = (BYTE)iBreakTemp1;
					pBreakPos[2] = (BYTE)iBreakTemp2;
					return 3;
				}
			}
			if (pwchIndex >= pszEnd)
				return iBreakIndex;
		}
		break;
	case 2:
		while (true)
		{
			iNumCluster = GetCluster(pwchIndex);

			if (!thaiTrieIter1.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
				return iBreakIndex;

			fBeginNewWord = false;
			pwchIndex += iNumCluster;
			if (thaiTrieIter1.fWordEnd)
			{
				iBreakTemp  = (unsigned int)(pwchIndex - pwchBeginWord);
				iBreakTemp1 = GetWeight(pwchIndex);
				if (iBreakTemp + iBreakTemp1  == iWordLen)
				{
					pBreakPos[0] = (BYTE)iBreakTemp;
					pBreakPos[1] = (BYTE)iBreakTemp1;
					return 2;
				}
			}
			if (pwchIndex >= pszEnd)
				return iBreakIndex;
		}
		break;
	default:
	case 1:
		while (iBreakIndex < Alt)
		{
			iNumCluster = GetCluster(pwchIndex);

			if (!thaiTrieIter1.MoveCluster(pwchIndex, iNumCluster, fBeginNewWord))
				return iBreakIndex;

			fBeginNewWord = false;
			pwchIndex += iNumCluster;
			if (thaiTrieIter1.fWordEnd)
			{
				fBeginNewWord = true;
				pBreakPos[iBreakIndex] =  (BYTE)(pwchIndex - pwchBeginWord);
				iBreakIndex++;
				pwchBeginWord = pwchIndex;
			}
			if (pwchIndex >= pszEnd)
				return iBreakIndex;
		}
		break;
    }

	return iBreakIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cmn_createfilew.c ===
/*****************************************************************************

  Natural Language Group Common Library

  CMN_CreateFileW.c - windows 95 safe version of CreateFileW

  History:
		DougP	11/20/97	Created

	1997 Microsoft Corporation
*****************************************************************************/

#include "precomp.h"
#undef CMN_CreateFileW
#undef CreateFileW

HANDLE WINAPI
CMN_CreateFileW (
    PCWSTR pwzFileName,  // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES pSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile)    // handle to file with attributes to copy  
{
	HINSTANCE hFile;
	Assert(pwzFileName);
	hFile = CreateFileW (
		pwzFileName,  // pointer to name of the file 
		dwDesiredAccess,  // access (read-write) mode 
		dwShareMode,  // share mode 
		pSecurityAttributes, // pointer to security descriptor 
		dwCreationDistribution,   // how to create 
		dwFlagsAndAttributes, // file attributes 
		hTemplateFile);
#if defined(_M_IX86)
	if (!hFile && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
	{		// must be in win95 - arghhh!
		char szFileName[MAX_PATH];
		  // Lenox convinced me this is a safe limit for w95
		  //(if it's NT we're not here)

		BOOL fcharerr;
		char chdef = ' ';
		int res = WideCharToMultiByte (CP_ACP, 0, pwzFileName,
				-1,
				szFileName, sizeof(szFileName), &chdef, &fcharerr);
		if (res && !fcharerr)
			hFile = CreateFileA (
				szFileName,  // pointer to name of the file 
				dwDesiredAccess,  // access (read-write) mode 
				dwShareMode,  // share mode 
				pSecurityAttributes, // pointer to security descriptor 
				dwCreationDistribution,   // how to create 
				dwFlagsAndAttributes, // file attributes 
				hTemplateFile);
		else if (fcharerr)
			SetLastError(ERROR_NO_UNICODE_TRANSLATION);
	}
#endif
#if defined(_DEBUG)
	if (!hFile || hFile == INVALID_HANDLE_VALUE)
		CMN_OutputSystemErrW(L"Can't CreateFile", pwzFileName);
#endif
	return hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\common.h ===
/****************************** Module Header ******************************\
* Module Name: common.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* History:
\***************************************************************************/

#ifndef _COMMON_
#define _COMMON_

extern HANDLE ghHeap;

#ifdef _DEBUG_PRINT
    #define _DBGERROR     0x00000001
    #define _DBGWARNING 0x00000002
    #define _DBGVERBOSE 0x00000004
    #define _DBGALL           0xFFFFFFFF
    extern ULONG gThDebugFlag;

    #define DBGERROR(_params_)   {if (gThDebugFlag & _DBGERROR)DbgPrint _params_ ; }
    #define DBGWARNING(_params_) {if (gThDebugFlag & _DBGWARNING)DbgPrint _params_ ; }
    #define DBGVERBOSE(_params_) {if (gThDebugFlag & _DBGVERBOSE)DbgPrint _params_ ; }
    #define DBGPRINT(_params_)   DbgPrint _params_
#else
    #define DBGERROR(_params_)
    #define DBGWARNING(_params_)
    #define DBGVERBOSE(_params_)
    #define DBGPRINT(_params_)
#endif

// misc defines
//
#define SUCCESS(s)      ((s) == ERROR_SUCCESS)
#define NO_SUCCESS(s)   ((s) != ERROR_SUCCESS)

#define ThAlloc( cbSize ) HeapAlloc( ghHeap, HEAP_ZERO_MEMORY, (cbSize));
#define ThFree( pv )                       HeapFree(  ghHeap, 0, (pv));
#define ThReAlloc( pv, cbSize)      HeapReAlloc( ghHeap, 0, (pv), (cbSize));

#ifdef _DEBUG
#define MAX_PROCINFO 16

typedef struct _tagBLOCKINFO {
    struct _tagBLOCKINFO *pbiNext;
    BYTE *pb;           // Start of block
    ULONG ulSize;       // Length of block
    BOOL fReferenced;   // Ever referenced
    PROCESS_INFORMATION ProcInfo[MAX_PROCINFO];
} BLOCKINFO, *PBLOCKINFO;

BOOL fCreateBlockInfo(BYTE *pbNew, ULONG cbSizeNew);
VOID FreeBlockInfo(BYTE *pbToFree);
VOID UpdateBlockInfo(BYTE *pbOld, BYTE *pbNew, ULONG cbSizeNew);
ULONG sizeofBlock(BYTE *pb);

VOID ClearMemoryRefs(VOID);
VOID NoteMemoryRef(VOID *pv);
VOID CheckMemoryRefs(VOID);
BOOL fValidPointer(VOID *pv, ULONG cbSize);

#define bThNewGarbage    0xA3
#define bThOldGarbage    0xA4
#define bThFreeGarbage   0xA5
#define bThDebugByte     0xE1

#define sizeofDebugByte 1

#else
#define sizeofDebugByte 0
#endif

#endif // _COMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cmn_outputsystemerr.c ===
/*****************************************************************************

  Natural Language Group Common Library

  CMN_OutputDebugStringW.c -
    DEBUG ONLY
    local helper functions that puts specific error message to debug output
    for errors on library functions

  History:
        DougP   9/9/97  Created

The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1997-1998 Microsoft Corporation.  All rights reserved.
******************************************************************************/

#include "precomp.h"

#if defined(_DEBUG)
#undef CMN_OutputDebugStringW

VOID
WINAPI
CMN_OutputDebugStringW(const WCHAR * pwzOutputString)
{
#if defined(_M_IX86)
    char szOutputString[MAX_PATH];
    BOOL fcharerr;
    char chdef = '?';
    int res = WideCharToMultiByte (CP_ACP, 0, pwzOutputString,
            -1,
            szOutputString, sizeof(szOutputString), &chdef, &fcharerr);
    OutputDebugStringA(szOutputString);
#else
    OutputDebugStringW(pwzOutputString);
#endif
}

void WINAPI CMN_OutputSystemErrA(const char *pszMsg, const char *pszComponent)
{
    CMN_OutputErrA(GetLastError(), pszMsg, pszComponent);
}

void WINAPI CMN_OutputErrA(DWORD dwErr, const char *pszMsg, const char *pszComponent)
{
    char szMsgBuf[256];
    OutputDebugStringA(pszMsg);
    OutputDebugStringA(" \"");
    if (pszComponent)
        OutputDebugStringA(pszComponent);
    OutputDebugStringA("\": ");
    if (!FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, // source and processing options
            NULL, // pointer to message source
            dwErr, // requested message identifier
            0, // language identifier for requested message
            szMsgBuf, // pointer to message buffer
            sizeof(szMsgBuf)/sizeof(szMsgBuf[0]), // maximum size of message buffer
            0 // address of array of message inserts
        ))
        OutputDebugStringA("Couldn't decode err msg");
    else
        OutputDebugStringA(szMsgBuf);
    OutputDebugStringA("\r\n");
}

void WINAPI CMN_OutputSystemErrW(const WCHAR *pwzMsg, const WCHAR *pwzComponent)
{
    CMN_OutputErrW(GetLastError(), pwzMsg, pwzComponent);
}

void WINAPI CMN_OutputErrW(DWORD dwErr, const WCHAR *pwzMsg, const WCHAR *pwzComponent)
{
    char wcMsgBuf[256];
    CMN_OutputDebugStringW(pwzMsg);
    OutputDebugStringA(" \"");
    if (pwzComponent)
        CMN_OutputDebugStringW(pwzComponent);
    OutputDebugStringA("\": ");
    if (!FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM, // source and processing options
            NULL, // pointer to message source
            dwErr, // requested message identifier
            0, // language identifier for requested message
            wcMsgBuf, // pointer to message buffer
            sizeof(wcMsgBuf)/sizeof(wcMsgBuf[0]), // maximum size of message buffer
            0 // address of array of message inserts
        ))
        OutputDebugStringA("Couldn't decode err msg");
    else
        OutputDebugStringA(wcMsgBuf);
    OutputDebugStringA("\r\n");
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaisenttrieiter.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiSentTrieIter - contain the header for class CThaiSentTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAISENTTRIEITER_HPP_
#define _CTHAISENTTRIEITER_HPP_

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
#include "NLGlib.h"
#include "ProofBase.h"
#include "thwbdef.hpp"
#include "CTrie.hpp"

class CThaiSentTrieIter : public CTrieIter {
public:
	void GetNode();
    WCHAR pos;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaisenttrieiter.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiSentTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiSentTrieIter.hpp"

//+---------------------------------------------------------------------------
//
//  Class:   CThaiSentTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiSentTrieIter::GetNode()
{
	pos = (WCHAR) trieScan.wch - 0x0100;
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID) &&
				(!(trieScan.wFlags & TRIE_NODE_TAGGED) ||
				(trieScan.aTags[0].dwData & iDialectMask));

	if (fWordEnd)
	{
        dwTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
                            trieScan.aTags[0].dwData :
                            0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaibreaktree.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiBreakTree - class CThaiBreakTree 
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAIBREAKTREE_H_
#define _CTHAIBREAKTREE_H_

#include <windows.h>
#include <assert.h>
#include "CThaiTrieIter.hpp"
#include "CThaiSentTrieIter.hpp"
#include "CThaiTrigramTrieIter.hpp"
#include "CBreakTree.hpp"
#include "lextable.hpp"

#define MAXTHAIBREAKNODE    255000
#define MAXUNSIGNEDINT      4294967295
#define UNABLETOCREATENODE  MAXUNSIGNEDINT

class CThaiWordBreak;

class ThaiBreakNode
{
public:
    ThaiBreakNode() {};

	int iPos;
	BYTE iBreakLen;
    DWORD dwTAG;
	unsigned int NextBreak;
	unsigned int Down;
};

class CThaiBreakTree : public CBreakTree
{
    friend class CThaiWordBreak;
public:
	CThaiBreakTree();
	~CThaiBreakTree();

#if defined (NGRAM_ENABLE)
	void Init(CTrie* pTrie, CTrie* pSentTrie, CTrie* pTrigramTrie);
#else
	void Init(CTrie* pTrie, CTrie* pTrigramTrie);
#endif

#if defined (NGRAM_ENABLE)
	inline void Reset();
	inline bool MoveNext();
	inline bool MoveDown();
    inline unsigned int CreateNode(int iPos, BYTE iBreakLen, DWORD dwPOS);
    bool GenerateTree(WCHAR* pszBegin, WCHAR* pszEnd);
    bool MaximalMatching();
#endif
    int Soundex(WCHAR* word);

    unsigned int TrigramBreak(WCHAR* pwchBegin, WCHAR* pwchEnd);
	int FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);

protected:
#if defined (NGRAM_ENABLE)
    inline DWORD DeterminePurgeOrUnknown(unsigned int iCurrentNode, unsigned int iBreakLen);
    inline void DeterminePurgeEndingSentence(WCHAR* pszBeginWord, unsigned int iNode);
#endif
    inline unsigned int Maximum(unsigned int x, unsigned y) { if (x > y) return x; else return y;}

    unsigned int GetWeight(WCHAR* pszBegin);
	unsigned int GetWeight(WCHAR* pszBegin, DWORD* pdwTag);
	float BigramProbablity(DWORD dwTag1,DWORD dwTag2);
    DWORD TrigramProbablity(DWORD dwTag1,DWORD dwTag2,DWORD dwTag3);
    unsigned int SoundexSearch(WCHAR* pszBegin);
    inline bool ShouldMerge(WCHAR* pwszPrevWord, unsigned int iPrevWordLen, unsigned int iMergeWordLen, DWORD dwPrevTag);
    bool Traverse(unsigned int iLevel, unsigned int iCurrentNode, unsigned int iNumUnknown);
    unsigned int GetCluster(WCHAR* pszIndex);


    void MaximalMatchingAddBreakToList(unsigned int iNumBreak);
    inline void AddBreakToList(unsigned int iNumBreak, unsigned int iNumUnknown);
    inline bool CompareSentenceStructure(unsigned int iNumBreak, unsigned int iNumUnknown);
    bool IsSentenceStruct(WCHAR* pos, unsigned int iPosLen);

	ThaiBreakNode* breakTree;

    CThaiTrieIter thaiTrieIter;
    CThaiTrieIter thaiTrieIter1;
    CThaiSentTrieIter thaiSentIter;
	CThaiTrigramTrieIter thaiTrigramIter;
    
	WCHAR* pszBegin;
	WCHAR* pszEnd;

	unsigned int iNodeIndex;
	unsigned int iNumNode;

    // Array of break and part-of-speech use for Traverse the Tree.
    BYTE* breakArray;
    DWORD* tagArray;
    WCHAR* POSArray;
    unsigned int iNumUnknownMaximalPOSArray;

    // Array of break for use with maximal matching array;
    unsigned int maxToken;
    unsigned int maxLevel;
    BYTE* maximalMatchingBreakArray;
    DWORD* maximalMatchingTAGArray;
    WCHAR* maximalMatchingPOSArray;

    // Array of break for use with trigram array.
    BYTE* trigramBreakArray;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaitrigrambreak.h ===
//+---------------------------------------------------------------------------
//
//
//  CThaiBreakTree - class CThaiBreakTree 
//
//  History:
//      created 11/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAITRIGRAMBREAK_H_
#define _CTHAITRIGRAMBREAK_H_

#include <windows.h>
#include <assert.h>
#include "CThaiTrieIter.hpp"
#include "CThaiSentTrieIter.hpp"
#include "CThaiTrigramTrieIter.hpp"

class CThaiTrigramBreak
{

public:
	CThaiTrigramBreak();
	~CThaiTrigramBreak();
	void Init(CTrie* pTrie, CTrie* pTrigramTrie);

protected:
    inline unsigned int Maximum(unsigned int x, unsigned y) { if (x > y) return x; else return y;}

    CThaiTrieIter thaiTrieIter;
	CThaiTrigramTrieIter thaiTrigramIter;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaitrigrambreak.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrigramBreak - class CThaiTrigramBreak 
//
//  History:
//      created 11/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiTrigramBreak.h"

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrigramBreak
//
//  Synopsis:	Constructor - initialize local variables
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 11/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramBreak::CThaiTrigramBreak()
{
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrigramBreak
//
//  Synopsis:	Destructor - clean up code
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 11/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramBreak::~CThaiTrigramBreak()
{
}

//+---------------------------------------------------------------------------
//
//  Class:		CThaiTrigramBreak
//
//  Synopsis:	Associate the class to the string.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrigramBreak::Init(CTrie* pTrie, CTrie* pTrigramTrie)
{
	assert(pTrigramTrie != NULL);
	thaiTrigramIter.Init(pTrigramTrie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaitrieiter.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrieIter - class CThaiTrieIter use for traversing trie.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiTrieIter.hpp"

static unsigned int iStackSize = 0;

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiBeginClusterCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiBeginClusterCharacter(WCHAR wc)
{
    return ( ( wc >= THAI_Vowel_Sara_E ) && (wc <= THAI_Vowel_Sara_AI_MaiMaLai) );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiUpperAndLowerClusterCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiUpperAndLowerClusterCharacter(WCHAR wc)
{
	return (	( (wc == THAI_Vowel_Sign_Mai_HanAkat) )									||
				( (wc >= THAI_Vowel_Sign_Sara_Am) && (wc <= THAI_Vowel_Sign_Phinthu) )	||
				( (wc >= THAI_Tone_MaiTaiKhu) && (wc <= THAI_Nikhahit) )   );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiEndingClusterCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiEndingClusterCharacter(WCHAR wc)
{
    return ( (wc == THAI_Sign_PaiYanNoi)    ||
             (wc == THAI_Vowel_Sara_A)      ||
             (wc == THAI_Vowel_Sara_AA)     ||
             (wc == THAI_Vowel_LakKhangYao) ||
             (wc == THAI_Vowel_MaiYaMok)    );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiMostlyBeginCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiMostlyBeginCharacter(WCHAR wc)
{
    return ( (wc >= THAI_Vowel_Sara_E && wc <= THAI_Vowel_Sara_AI_MaiMaLai) || // Character always in front of a word.
             (wc == THAI_Cho_Ching)                                         || // Character always in front of a word.
             (wc == THAI_Pho_Phung)                                         || // Character always in front of a word.
             (wc == THAI_Fo_Fa)                                             || // Character always in front of a word.
             (wc == THAI_Ho_Nok_Huk)                                        || // Character always in front of a word.
             (wc == THAI_Ho_Hip)                                            || // Character most like in front of a word.
             (wc == THAI_Pho_Samphao)                                       || // Character most like in front of a word.
             (wc == THAI_Kho_Rakhang)                                       || // Character most like in front of a word.
             (wc == THAI_Fo_Fan)                                            || // Character most like in front of a word.
             (wc == THAI_So_So)                                             || // Character most like in front of a word.
             (wc == THAI_Tho_NangmonTho)                                    ); // Character most like in front of a word.
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiMostlyLastCharacter
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiMostlyLastCharacter(WCHAR wc)
{
    return ( (wc == THAI_Vowel_Sign_Sara_Am) || // Always the end of word.
             (wc == THAI_Sign_PaiYanNoi)     || // Always the end of word.
             (wc == THAI_Vowel_MaiYaMok)     || // Always the end of word.
             (wc == THAI_Vowel_LakKhangYao)  || // Most likely the end of word.
             (wc == THAI_Thanthakhat)        ); // Most likely the end of word.

}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiToneMark
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool IsThaiToneMark(WCHAR wc)
{
    return ( (wc >= 0x0e48) && (wc <= 0x0e4b) ||
             (wc == 0x0e31));

}

//+---------------------------------------------------------------------------
//
//  Function:   GetCluster
//
//  Synopsis:   The function return the next number of character which represent
//              a cluster of Thai text.
//
//              ie. Kor Kai, Kor Kai -> 1
//                  Kor Kai, Sara Um -> 2
//
//              * Note this function will not return no more than 3 character,
//                for cluster as this would represent invalid sequence of character.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
/*
unsigned int GetCluster(WCHAR* pszIndex)
{
    int iRetValue = 0;

    // Take all begin cluster character.
    while (IsThaiBeginClusterCharacter(*pszIndex))
    {
        pszIndex++;
        iRetValue++;
    }

    if (IsThaiConsonant(*pszIndex))
    {
        pszIndex++;
        iRetValue++;

        while (IsThaiUpperAndLowerClusterCharacter(*pszIndex))
        {
            pszIndex++;
            iRetValue++;
        }

        while (IsThaiEndingClusterCharacter(*pszIndex))
        {
            pszIndex++;
            iRetValue++;
        }
    }

    if (iRetValue == 0)
        // The character is probably a punctuation.
        iRetValue++;

    return iRetValue;
}

*/
//+---------------------------------------------------------------------------
//
//  Function:   IsThaiConsonant
//
//  Synopsis:   
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsThaiConsonant(WCHAR wc)
{
	return ( (wc >= THAI_Ko_Kai) && (wc <= THAI_Ho_Nok_Huk) );
}

//+---------------------------------------------------------------------------
//
// Define the different part of speech for Thai.
//
//----------------------------------------------------------------------------
WCHAR wzPOSLookup[POSTYPE][46] =
							{	L"NONE",				// 0 . No tags.
								L"NPRP",				// 1 . Proper noun
								L"NCNM",				// 2 . Cardinal number
								L"NONM",				// 3 . Ordinal number
								L"NLBL",				// 4 . Label noun
								L"NCMN",				// 5 . Common noun
								L"NTTL",				// 6 . Title noun
								L"PPRS",				// 7 . Personal pronoun
								L"PDMN",				// 8 . Demonstrative pronoun
								L"PNTR",				// 9 . Interrogative pronoun
								L"PREL",				// 10. Relative pronoun
								L"VACT",				// 11. Active verb
								L"VSTA",				// 12. Stative verb
								L"VATT",				// 13. Attributive verb
								L"XVBM",				// 14. Pre-verb auxiliary, before negator
								L"XVAM",				// 15. Pre-verb auxiliary, after negator
								L"XVMM",				// 16. Pre-verb, before or after negator
								L"XVBB",				// 17. Pre-verb auxiliary, in imperative mood
								L"XVAE",				// 18. Post-verb auxiliary
								L"DDAN",				// 19. Definite determiner, after noun without classifier in between
								L"DDAC",				// 20. Definite determiner, allowing classifier in between
								L"DDBQ",				// 21. Definite determiner, between noun and classifier or preceding quantitative expression
								L"DDAQ",				// 22. Definite determiner, following quantitative expression
								L"DIAC",				// 23. Indefinite determiner, following noun; allowing classifier in between
								L"DIBQ",				// 24. Indefinite determiner, between noun and classifier or preceding quantitative expression
								L"DIAQ",				// 25. Indefinite determiner, following quantitative expression
								L"DCNM",				// 26. Determiner, cardinal number expression
								L"DONM",				// 27. Determiner, ordinal number expression
								L"ADVN",				// 28. Adverb with normal form
								L"ADVI",				// 29. Adverb with iterative form
								L"ADVP",				// 30. Adverb with prefixed form
								L"ADVS",				// 31. Sentential adverb
								L"CNIT",				// 32. Unit classifier
								L"CLTV",				// 33. Collective classifier
								L"CMTR",				// 34. Measurement classifier
								L"CFQC",				// 35. Frequency classifier
								L"CVBL",				// 36. Verbal classifier
								L"JCRG",				// 37. Coordinating conjunction
								L"JCMP",				// 38. Comparative conjunction
								L"JSBR",				// 39. Subordinating conjunction
								L"RPRE",				// 40. Preposition
								L"INT",                 // 41. Interjection
								L"FIXN",				// 42. Nominal prefix
								L"FIXV",				// 43. Adverbial prefix
								L"EAFF",				// 44. Ending for affirmative sentencev
								L"EITT",				// 45. Ending for interrogative sentence
								L"NEG",                 // 46. Negator
								L"PUNC",				// 47. Punctuation
								L"ADVI ADVN",
								  // 48.
								L"ADVI ADVN NCMN",
								  // 49.
								L"ADVI ADVN VSTA",
								  // 50.
								L"ADVI VATT",
								  // 51.
								L"ADVN ADVP",
								  // 52.
								L"ADVN ADVP ADVS",
								  // 53.
								L"ADVN ADVP DIAQ DIBQ JCMP JSBR RPRE",
								  // 54.
								L"ADVN ADVP NCMN VATT",
								  // 55.
								L"ADVN ADVP VSTA",
								  // 56.
								L"ADVN ADVS DDAC DDAN DIAC VATT XVAE",
								  // 57.
								L"ADVN ADVS DDAN NCMN VATT VSTA",
								  // 58.
								L"ADVN ADVS NCMN",
								  // 59.
								L"ADVN ADVS NCMN VATT",
								  // 60.
								L"ADVN ADVS VACT",
								  // 61.
								L"ADVN ADVS VATT",
								  // 62.
								L"ADVN CFQC NCMN RPRE VSTA",
								  // 63.
								L"ADVN CLTV CNIT NCMN RPRE",
								  // 64.
								L"ADVN DCNM",
								  // 65.
								L"ADVN DDAC DDAN",
								  // 66.
								L"ADVN DDAC DDAN NCMN PDMN",
								  // 67.
								L"ADVN DDAC DDAN PDMN",
								  // 68.
								L"ADVN DDAN DDBQ",
								  // 69.
								L"ADVN DDAN DIAC PDMN VSTA",
								  // 70.
								L"ADVN DDAN FIXN PDMN",
								  // 71.
								L"ADVN DDAN NCMN",
								  // 72.
								L"ADVN DDAQ",
								  // 73.
								L"ADVN DDBQ",
								  // 74.
								L"ADVN DDBQ RPRE VATT",
								  // 75.
								L"ADVN DDBQ VATT VSTA XVAE",
								  // 76.
								L"ADVN DIAC",
								  // 77.
								L"ADVN DIAC PDMN",
								  // 78.
								L"ADVN DIBQ",
								  // 79.
								L"ADVN DIBQ NCMN",
								  // 80.
								L"ADVN DIBQ VACT VSTA",
								  // 81.
								L"ADVN DIBQ VATT",
								  // 82.
								L"ADVN DONM JCMP",
								  // 83.
								L"ADVN DONM JSBR NCMN RPRE VATT XVAE",
								  // 84.
								L"ADVN EITT PNTR",
								  // 85.
								L"ADVN FIXN",
								  // 86.
								L"ADVN JCMP",
								  // 87.
								L"ADVN JCRG",
								  // 88.
								L"ADVN JCRG JSBR",
								  // 89.
								L"ADVN JCRG JSBR XVBM XVMM",
								  // 90.
								L"ADVN JCRG RPRE VACT VSTA XVAE",
								  // 91.
								L"ADVN JSBR",
								  // 92.
								L"ADVN JSBR NCMN",
								  // 93.
								L"ADVN JSBR RPRE VATT",
								  // 94.
								L"ADVN JSBR RPRE XVAE",
								  // 95.
								L"ADVN JSBR VSTA",
								  // 96.
								L"ADVN JSBR XVAE XVBM",
								  // 97.
								L"ADVN NCMN",
								  // 98.
								L"ADVN NCMN RPRE VACT VATT VSTA",
								  // 99.
								L"ADVN NCMN RPRE VACT XVAE",
								  // 100.
								L"ADVN NCMN RPRE VATT",
								  // 101.
								L"ADVN NCMN VACT VATT VSTA",
								  // 102.
								L"ADVN NCMN VACT VSTA",
								  // 103.
								L"ADVN NCMN VATT",
								  // 104.
								L"ADVN NCMN VATT VSTA",
								  // 105.
								L"ADVN NEG",
								  // 106.
								L"ADVN NPRP VATT",
								  // 107.
								L"ADVN PDMN VACT",
								  // 108.
								L"ADVN PNTR",
								  // 109.
								L"ADVN RPRE",
								  // 110.
								L"ADVN RPRE VACT VATT XVAE",
								  // 111.
								L"ADVN RPRE VACT XVAM XVBM",
								  // 112.
								L"ADVN RPRE VATT VSTA",
								  // 113.
								L"ADVN RPRE VSTA",
								  // 114.
								L"ADVN VACT",
								  // 115.
								L"ADVN VACT VATT",
								  // 116.
								L"ADVN VACT VATT VSTA",
								  // 117.
								L"ADVN VACT VATT VSTA XVAM XVBM",
								  // 118.
								L"ADVN VACT VSTA",
								  // 119.
								L"ADVN VACT VSTA XVAE",
								  // 120.
								L"ADVN VACT XVAE",
								  // 121.
								L"ADVN VATT",
								  // 122.
								L"ADVN VATT VSTA",
								  // 123.
								L"ADVN VATT VSTA XVAM XVBM XVMM",
								  // 124.
								L"ADVN VATT XVBM",
								  // 125.
								L"ADVN VSTA",
								  // 126.
								L"ADVN VSTA XVAE",
								  // 127.
								L"ADVN VSTA XVBM",
								  // 128.
								L"ADVN XVAE",
								  // 129.
								L"ADVN XVAM",
								  // 130.
								L"ADVN XVBM XVMM",
								  // 131.
								L"ADVP JSBR RPRE VATT",
								  // 132.
								L"ADVP VATT",
								  // 133.
								L"ADVS DDAC JCRG",
								  // 134.
								L"ADVS DDAC JSBR",
								  // 135.
								L"ADVS DDAN VSTA",
								  // 136.
								L"ADVS DIAC",
								  // 137.
								L"ADVS DONM",
								  // 138.
								L"ADVS JCRG JSBR",
								  // 139.
								L"ADVS JCRG JSBR RPRE",
								  // 140.
								L"ADVS JSBR",
								  // 141.
								L"ADVS JSBR RPRE",
								  // 142.
								L"ADVS NCMN",
								  // 143.
								L"ADVS VATT",
								  // 144.
								L"CFQC CLTV CNIT DCNM JCRG JSBR NCMN RPRE XVBM",
								  // 145.
								L"CFQC CNIT PREL",
								  // 146.
								L"CFQC NCMN",
								  // 147.
								L"CLTV CNIT NCMN",
								  // 148.
								L"CLTV CNIT NCMN RPRE",
								  // 149.
								L"CLTV CNIT NCMN VSTA",
								  // 150.
								L"CLTV NCMN",
								  // 151.
								L"CLTV NCMN VACT VATT",
								  // 152.
								L"CLTV NCMN VATT",
								  // 153.
								L"CMTR CNIT NCMN",
								  // 154.
								L"CMTR NCMN",
								  // 155.
								L"CMTR NCMN VATT VSTA",
								  // 156.
								L"CNIT DDAC NCMN VATT",
								  // 157.
								L"CNIT DONM NCMN RPRE VATT",
								  // 158.
								L"CNIT FIXN FIXV JSBR NCMN",
								  // 159.
								L"CNIT JCRG JSBR NCMN PREL RPRE VATT",
								  // 160.
								L"CNIT JSBR RPRE",
								  // 161.
								L"CNIT NCMN",
								  // 162.
								L"CNIT NCMN RPRE",
								  // 163.
								L"CNIT NCMN RPRE VATT",
								  // 164.
								L"CNIT NCMN VACT",
								  // 165.
								L"CNIT NCMN VSTA",
								  // 166.
								L"CNIT NCNM",
								  // 167.
								L"CNIT PPRS",
								  // 168.
								L"DCNM DDAC DIAC DONM VATT VSTA",
								  // 169.
								L"DCNM DDAN DIAC",
								  // 170.
								L"DCNM DIAC NCMN NCNM",
								  // 171.
								L"DCNM DIBQ NCMN",
								  // 172.
								L"DCNM DONM",
								  // 173.
								L"DCNM NCMN",
								  // 174.
								L"DCNM NCNM",
								  // 175.
								L"DCNM NCNM VACT",
								  // 176.
								L"DCNM VATT",
								  // 177.
								L"DDAC DDAN",
								  // 178.
								L"DDAC DDAN DIAC NCMN",
								  // 179.
								L"DDAC DDAN DIAC VATT",
								  // 180.
								L"DDAC DDAN EAFF PDMN",
								  // 181.
								L"DDAC DDAN PDMN",
								  // 182.
								L"DDAC DIAC VSTA",
								  // 183.
								L"DDAC NCMN",
								  // 184.
								L"DDAN DDBQ",
								  // 185.
								L"DDAN DIAC PNTR",
								  // 186.
								L"DDAN NCMN",
								  // 187.
								L"DDAN NCMN RPRE VATT",
								  // 188.
								L"DDAN PDMN",
								  // 189.
								L"DDAN RPRE",
								  // 190.
								L"DDAN VATT",
								  // 191.
								L"DDAQ VATT",
								  // 192.
								L"DDBQ DIBQ",
								  // 193.
								L"DDBQ JCRG JSBR",
								  // 194.
								L"DDBQ JCRG NCMN",
								  // 195.
								L"DIAC PDMN",
								  // 196.
								L"DIBQ JSBR RPRE VSTA",
								  // 197.
								L"DIBQ NCMN",
								  // 198.
								L"DIBQ VATT",
								  // 199.
								L"DIBQ VATT VSTA",
								  // 200.
								L"DIBQ XVBM",
								  // 201.
								L"DONM NCMN RPRE",
								  // 202.
								L"DONM VACT VATT VSTA",
								  // 203.
								L"DONM VATT",
								  // 204.
								L"EAFF XVAE XVAM XVBM",
								  // 205.
								L"EITT JCRG",
								  // 206.
								L"FIXN FIXV NCMN",
								  // 207.
								L"FIXN FIXV RPRE VSTA",
								  // 208.
								L"FIXN JSBR NCMN PREL RPRE VSTA XVBM",
								  // 209.
								L"FIXN NCMN",
								  // 210.
								L"FIXN VACT",
								  // 211.
								L"FIXN VACT VSTA",
								  // 212.
								L"FIXV JSBR RPRE",
								  // 213.
								L"JCMP JSBR",
								  // 214.
								L"JCMP RPRE VSTA",
								  // 215.
								L"JCMP VATT VSTA",
								  // 216.
								L"JCMP VSTA",
								  // 217.
								L"JCRG JSBR",
								  // 218.
								L"JCRG JSBR NCMN RPRE",
								  // 219.
								L"JCRG JSBR RPRE",
								  // 220.
								L"JCRG RPRE",
								  // 221.
								L"JCRG RPRE VATT VSTA",
								  // 222.
								L"JCRG VSTA",
								  // 223.
								L"JSBR NCMN",
								  // 224.
								L"JSBR NCMN XVAE",
								  // 225.
								L"JSBR NCMN XVAM XVBM XVMM",
								  // 226.
								L"JSBR PREL",
								  // 227.
								L"JSBR PREL RPRE",
								  // 228.
								L"JSBR PREL XVBM",
								  // 229.
								L"JSBR RPRE",
								  // 230.
								L"JSBR RPRE VACT",
								  // 231.
								L"JSBR RPRE VACT VSTA",
								  // 232.
								L"JSBR RPRE VACT XVAE XVAM",
								  // 233.
								L"JSBR RPRE VATT",
								  // 234.
								L"JSBR RPRE VSTA",
								  // 235.
								L"JSBR RPRE XVAM",
								  // 236.
								L"JSBR VACT",
								  // 237.
								L"JSBR VACT VSTA",
								  // 238.
								L"JSBR VATT XVBM XVMM",
								  // 239.
								L"JSBR VSTA",
								  // 240.
								L"JSBR XVBM",
								  // 241.
								L"NCMN NCNM",
								  // 242.
								L"NCMN NCNM NPRP",
								  // 243.
								L"NCMN NLBL NPRP",
								  // 244.
								L"NCMN NPRP",
								  // 245.
								L"NCMN NPRP RPRE",
								  // 246.
								L"NCMN NTTL",
								  // 247.
								L"NCMN PDMN PPRS",
								  // 248.
								L"NCMN PDMN VATT",
								  // 249.
								L"NCMN PNTR",
								  // 250.
								L"NCMN PPRS PREL VACT",
								  // 251.
								L"NCMN RPRE",
								  // 252.
								L"NCMN RPRE VACT VATT",
								  // 253.
								L"NCMN RPRE VATT",
								  // 254.
								L"NCMN VACT",
								  // 255.
								L"NCMN VACT VATT",
								  // 256.
								L"NCMN VACT VATT VSTA XVAE",
								  // 257.
								L"NCMN VACT VSTA",
								  // 258.
								L"NCMN VACT VSTA XVAM",
								  // 259.
								L"NCMN VACT VSTA XVBB",
								  // 260.
								L"NCMN VATT",
								  // 261.
								L"NCMN VATT VSTA",
								  // 262.
								L"NCMN VATT XVAM",
								  // 263.
								L"NCMN VSTA",
								  // 264.
								L"NCMN XVBM",
								  // 265.
								L"NPRP RPRE",
								  // 266.
								L"NPRP VATT",
								  // 267.
								L"NTTL PPRS",
								  // 268.
								L"PDMN PPRS",
								  // 269.
								L"PDMN VATT",
								  // 270.
								L"PDMN VATT VSTA",
								  // 271.
								L"PPRS PREL",
								  // 272.
								L"PPRS VATT",
								  // 273.
								L"RPRE VACT",
								  // 274.
								L"RPRE VACT VATT",
								  // 275.
								L"RPRE VACT VSTA",
								  // 276.
								L"RPRE VACT VSTA XVAE",
								  // 277.
								L"RPRE VACT XVAE",
								  // 278.
								L"RPRE VATT",
								  // 279.
								L"RPRE VATT VSTA",
								  // 280.
								L"RPRE VSTA",
								  // 281.
								L"VACT VATT",
								  // 282.
								L"VACT VATT VSTA",
								  // 283.
								L"VACT VATT XVAE XVAM XVBM",
								  // 284.
								L"VACT VSTA",
								  // 285.
								L"VACT VSTA XVAE",
								  // 286.
								L"VACT VSTA XVAE XVAM",
								  // 287.
								L"VACT VSTA XVAE XVAM XVMM",
								  // 288.
								L"VACT VSTA XVAM",
								  // 289.
								L"VACT VSTA XVAM XVMM",
								  // 290.
								L"VACT XVAE",
								  // 291.
								L"VACT XVAM",
								  // 292.
								L"VACT XVAM XVMM",
								  // 293.
								L"VACT XVMM",
								  // 294.
								L"VATT VSTA",
								  // 295.
								L"VSTA XVAE",
								  // 296.
								L"VSTA XVAM",
								  // 297.
								L"VSTA XVAM XVMM",
								  // 298.
								L"VSTA XVBM",
								  // 299.
								L"XVAM XVBM",
								  // 300.
								L"XVAM XVBM XVMM",
								  // 301.
								L"XVAM XVMM",
								  // 302.
                                L"UNKN",                // 303. Unknown
                            };

//+---------------------------------------------------------------------------
//
//  Function:   POSCompress
//
//  Synopsis:   Part Of Speech Compress - translating string to unique id.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD POSCompress(WCHAR* szTag)
{
	int i;

	for (i = 0; i < POSTYPE; i++)
	{
		if (wcscmp(szTag, &wzPOSLookup[i][0]) == 0)
		{
			return (DWORD)i;
		}
	}
	return POSTYPE;
}

//+---------------------------------------------------------------------------
//
//  Function:   POSDecompress
//
//  Synopsis:   Part Of Speech Decompress - Decompress tag get 
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline WCHAR* POSDecompress(DWORD dwTag)
{
    return (&wzPOSLookup[dwTag][0]);
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  Constructor:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrieIter::CThaiTrieIter() : resultWord(NULL), soundexWord(NULL), tempWord(NULL),
                                 pTrieScanArray(NULL), m_fThaiNumber(false)
{
    resultWord = new WCHAR[64];
    tempWord = new WCHAR[64];
    pTrieScanArray = new TRIESCAN[53];
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  Destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrieIter::~CThaiTrieIter()
{
    if (resultWord)
        delete resultWord;
    if (tempWord)
        delete tempWord;
    if (pTrieScanArray)
        delete pTrieScanArray;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrieIter::Init(CTrie* ctrie)
{
    // Declare varialbes.
    WCHAR wc;

    // Initialize parent.
    CTrieIter::Init(ctrie);

    // Initialize Hash table.
    for (wc = THAI_Ko_Kai; wc <= THAI_Ho_Nok_Huk; wc++)
        GetScanFirstChar(wc,&pTrieScanArray[wc - THAI_Ko_Kai]);
    for (wc = THAI_Vowel_Sara_E; wc <= THAI_Vowel_Sara_AI_MaiMaLai; wc++)
        GetScanFirstChar(wc,&pTrieScanArray[wc - THAI_Ko_Kai - 17]);
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan)
{
    // Reset the trie scan.
	memset(&trieScan1, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return false;

    while (wc != trieScan1.wch)
    {
        // Keep moving the the right of the trie.
        if (!TrieGetNextNode(pTrieCtrl, &trieScan1))
        {
        	memset(pTrieScan, 0, sizeof(TRIESCAN));
            return false;
        }
    }
    memcpy(pTrieScan, &trieScan1, sizeof(TRIESCAN));

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   The function move trieScan to the relevant node matching with
//              with the cluster of Thai character.
//
//  Arguments:  szCluster - contain the thai character cluster.
//              iNumCluster  - contain the size of character.
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CThaiTrieIter::MoveCluster(WCHAR* szCluster, unsigned int iNumCluster)
{
    // Declare and initailze local variables.
    unsigned int i = 0;

    Assert(iNumCluster <= 6, "Invalid cluster");

    CopyScan();

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return FALSE;

    while (TRUE)
    {
        if (szCluster[i] == trieScan1.wch)
        {
            i++;
            if (i == iNumCluster)
            {
            	memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return TRUE;
            }
        	// Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;
        }
    	// Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:   The function move trieScan to the relevant node matching with
//              with the cluster of Thai character.
//
//  Arguments:  szCluster - contain the thai character cluster.
//              iNumCluster  - contain the size of character.
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::MoveCluster(WCHAR* szCluster, unsigned int iNumCluster, bool fBeginNewWord)
{
    // Declare and initailze local variables.
    unsigned int i = 0;

    Assert(iNumCluster <= 6, "Invalid cluster");

	// No need to move.
	if (iNumCluster == 0)
		return false;

    // Use a look indexes for where the first character is at.
    if (fBeginNewWord)
    {
		m_fThaiNumber = false;
        // Quick look up for proper characters.
        if (szCluster[i] >= THAI_Ko_Kai && szCluster[i] <= THAI_Ho_Nok_Huk)
            memcpy(&trieScan,&pTrieScanArray[(szCluster[i] - THAI_Ko_Kai)], sizeof(TRIESCAN));
        else if (szCluster[i] >= THAI_Vowel_Sara_E && szCluster[i] <= THAI_Vowel_Sara_AI_MaiMaLai)
            memcpy(&trieScan,&pTrieScanArray[(szCluster[i] - THAI_Ko_Kai - 17)], sizeof(TRIESCAN));
        else
			{
            Reset();
			m_fThaiNumber = IsThaiNumeric(szCluster[i]);
			}

        if (trieScan.wch == szCluster[i])
            i++;

        if (i == iNumCluster)
        {
            GetNode();
            return true;
        }
    }
    CopyScan();

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return false;

	if (m_fThaiNumber)
		{
		fWordEnd = true;
		if (IsThaiNumeric(szCluster[i]) || szCluster[i] == L',' || szCluster[i] == L'.')
			return true;
		else
			return false;
		}

    while (true)
    {
        if (szCluster[i] == trieScan1.wch)
        {
            i++;
            if ((i == iNumCluster) ||
				( (szCluster[i] == THAI_Vowel_MaiYaMok || szCluster[i] == THAI_Sign_PaiYanNoi)/* && (i+1 == iNumCluster )*/) )
            {
                memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return true;
            }
            // Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;
        }
        // Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
    }

    if (fBeginNewWord)
        Reset();

    return false;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
SOUNDEXSTATE CThaiTrieIter::MoveSoundexByCluster(WCHAR* szCluster, unsigned int iNumCluster, unsigned int iNumNextCluster)
{
    // Declare and initailze local variables.
    unsigned int i = 0 , x = 0;
    bool fStoreScan = false;
	TRIESCAN trieScanPush;

    Assert(iNumCluster <= 6, "Invalid cluster");
    Assert(iNumNextCluster <= 6, "Invalid cluster");

    CopyScan();

    if (!TrieGetNextState(pTrieCtrl, &trieScan1))
        return UNABLE_TO_MOVE;

    // Match as much as possible
    while (true)
    {
        if (szCluster[i] == trieScan1.wch)
        {
            i++;
            if (i == iNumCluster)
            {
            	memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                GetNode();
                return NOSUBSTITUTE;
            }
            // Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan1)) break;

            // Save our current scan position.
            memcpy(&trieScanPush, &trieScan1, sizeof(TRIESCAN));
            fStoreScan = true;
        }
    	// Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
    }

    // Try doing some tonemark substitution.
    if (fStoreScan && IsThaiToneMark(szCluster[i]) )
    {
        // Restore trieScan1 to last matched.
        memcpy(&trieScan1, &trieScanPush, sizeof(TRIESCAN));

        while (true)
        {
            if (IsThaiToneMark(trieScan1.wch))
            {           
                if ( (i + 1) == iNumCluster)
                {
                    if (CheckNextCluster(szCluster+iNumCluster,iNumNextCluster))
                    {
                        memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                        GetNode();
                        return SUBSTITUTE_DIACRITIC;
                    }
                } 
            }
            // Move the Trie right one node.
            // Goes through all the none Tonemark.
            if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
        }
    }

    // Try doing droping the current tonemark.  
    // Example is case can be best found "Click" is spelt in Thai from the
    //  different group at Microsoft.
    if (fStoreScan && !IsThaiToneMark(szCluster[i]) )
    {
        // Restore trieScan1 to last matched.
        memcpy(&trieScan1, &trieScanPush, sizeof(TRIESCAN));

        while (true)
        {
            if (IsThaiToneMark(trieScan1.wch))
            {
                if ( (i + 1) == iNumCluster)
                {
                    if (CheckNextCluster(szCluster+iNumCluster,iNumNextCluster))
                    {
                        memcpy(&trieScan, &trieScan1, sizeof(TRIESCAN));
                        GetNode();
                        return SUBSTITUTE_DIACRITIC;
                    }
                } 
            }
            // Move the Trie right one node.
            // Drop all the Tonemark.
            if (!TrieGetNextNode(pTrieCtrl, &trieScan1)) break;
        }
    }

    return UNABLE_TO_MOVE;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrieIter
//
//  Synopsis: set trieScan1 = trieScan.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline void CThaiTrieIter::CopyScan()
{
	// Let trieScan1 = trieScan
	memcpy(&trieScan1,&trieScan, sizeof(TRIESCAN));
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  the function traverse through the whole dictionary
//              to find the best possible match words.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiTrieIter::Soundex(WCHAR* word)
{
	// Reset Trie.
    Reset();

    // Move Down.
    Down();

    // Clean soundexWord.
    memset(resultWord, 0, sizeof(WCHAR) * 64);
    memset(tempWord, 0, sizeof(WCHAR) * 64);

    soundexWord = word;

    iResultScore = GetScore(L"\x0e04\x0e25\x0e34\x0e01\x0e01\x0e01",soundexWord);
    iResultScore = 2000;

#if defined (_DEBUG)
    iStackSize = 0;
#endif
    Traverse(0,1000);

    return iResultScore;
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
unsigned int CThaiTrieIter::GetScore(WCHAR* idealWord, WCHAR* inputWord)
{
    unsigned int iScore = 1000;
    unsigned int idealWordLen = wcslen(idealWord);
    unsigned int iInputWordLen = wcslen(inputWord);
    unsigned int iIndexBegin = 0;
    unsigned int i,x;
    unsigned int iMaxCompare;
    bool fShouldExit;

    for (i=0; i < iInputWordLen; i++)
    {
        iMaxCompare = ( (iIndexBegin + 2) < idealWordLen ) ? (iIndexBegin + 2) : idealWordLen;
        if (i <= idealWordLen)
        {
            x = iIndexBegin;
            fShouldExit = false;
            while (true)
            {
                if ((x >= iMaxCompare) || (fShouldExit) )
                    break;

                if (idealWord[x] == inputWord[i])
                {
                    x++;
                    iIndexBegin = x;
                    break;
                }
                if (IsThaiUpperAndLowerClusterCharacter(inputWord[i]))
                    iScore += 5;
                else
                    iScore += 10;
                x++;
                fShouldExit = true;
            }
        }
        else
        {
            if (IsThaiUpperAndLowerClusterCharacter(inputWord[i]))
                iScore += 20;
            else
                iScore += 30;
        }
    }

    while (x <= idealWordLen)
    {
        if (IsThaiUpperAndLowerClusterCharacter(idealWord[x]))
            iScore += 5;
        else
            iScore += 10;
        x++;
    }

    return iScore;
}


//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::Traverse(unsigned int iCharPos, unsigned int score)
{
    TRIESCAN trieScanLevel;

#if defined(_DEBUG)   
    iStackSize++;
#endif

    // push current trieScan into local stack trieScanLevel.
    memcpy(&trieScanLevel,&trieScan, sizeof(TRIESCAN));

    // Get Node information
    GetNode();

    // Store the current character to result word.
    tempWord[iCharPos] = wc;
    tempWord[iCharPos + 1] = 0;

    // Determine the distance between two string.
    score = GetScore(tempWord, soundexWord);
 
    // See if we have reached the end of a word.
    if (fWordEnd)
    {
        tempWord[iCharPos + 1] = 0;
    
        // Is Soundex score lower than we have.
        if (score <  iResultScore)
        {
            wcscpy(resultWord,tempWord);
            iResultScore = score;
        }
    }

    // See if we can prune the result of the words.
    if (score > (iResultScore + APPROXIMATEWEIGHT))
    {
#if defined(_DEBUG)
        iStackSize--;
#endif
        return true;
    }

    // Move down Trie branch.
    if (Down())
    {
        Traverse(iCharPos + 1, score);

        if (Right())
            Traverse(iCharPos + 1, score);

        // restore trieScan
        memcpy(&trieScan,&trieScanLevel, sizeof(TRIESCAN));

        if (Right())
            Traverse(iCharPos, score);
    }

#if defined(_DEBUG)
    iStackSize--;
#endif

    return true;
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrieIter
//
//  Synoposis:  This function will trieScan1 to the next cluster if
//              the move is possible.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrieIter::CheckNextCluster(WCHAR* szCluster, unsigned int iNumCluster)
{
    // Declare and initailze local variables.
    unsigned int i = 0;
    TRIESCAN trieScan2;

    Assert(iNumCluster <= 6, "Invalid cluster");

    // If there are no cluster to check consider cluster found.
    if (0 == iNumCluster)
        return true;

    memcpy(&trieScan2, &trieScan1, sizeof(TRIESCAN));

    // Move down the Trie Branch.
    if (!TrieGetNextState(pTrieCtrl, &trieScan2)) 
        return false;

    while (true)
    {
        if (szCluster[i] == trieScan2.wch)
        {
            i++;
            if (i == iNumCluster)
            {
                return true;
            }
        	// Move down the Trie Branch.
            else if (!TrieGetNextState(pTrieCtrl, &trieScan2)) break;
        }
    	// Move the Trie right one node.
        else if (!TrieGetNextNode(pTrieCtrl, &trieScan2)) break;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaitrieiter.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrieIter - class CThaiTrieIter use for traversing trie.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAITRIEITER_H_
#define _CTHAITRIEITER_H_

#include "ctrie.hpp"
#include "thwbdef.hpp"
#include "WB_Asserts.h"
#include "lextable.hpp"
BOOL IsThaiUpperAndLowerClusterCharacter(WCHAR wc);
BOOL IsThaiBeginClusterCharacter(WCHAR wc);
BOOL IsThaiEndingClusterCharacter(WCHAR wc);
BOOL IsThaiConsonant(WCHAR wc);
bool IsThaiMostlyBeginCharacter(WCHAR wc);
bool IsThaiMostlyLastCharacter(WCHAR wc);
//unsigned int GetCluster(WCHAR* pszIndex);
DWORD POSCompress(WCHAR* szTag);
WCHAR* POSDecompress(DWORD dwTag);



enum SOUNDEXSTATE {
                        UNABLE_TO_MOVE,
                        NOSUBSTITUTE,
                        SUBSTITUTE_DIACRITIC,
                        SUBSTITUTE_SOUNDLIKECHAR
                   };

class CThaiTrieIter : public CTrieIter {
public:
    CThaiTrieIter();
    ~CThaiTrieIter();
    void Init(CTrie* ctrie);
	BOOL MoveCluster(WCHAR* szCluster, unsigned int iNumCluster);
    bool MoveCluster(WCHAR* szCluster, unsigned int iNumCluster, bool fBeginNewWord);
    SOUNDEXSTATE MoveSoundexByCluster(WCHAR* szCluster, unsigned int iNumCluster, unsigned int iNumNextCluster);
    int Soundex(WCHAR* word);
	bool m_fThaiNumber;
protected:
    unsigned int GetScore(WCHAR* idealWord, WCHAR* soundLikeWord);
    bool Traverse(unsigned int iCharPos, unsigned int scoring);
	inline void CopyScan();

	// Trie Iterator - extra iterator for use as 
	TRIESCAN trieScan1;

    WCHAR* soundexWord;
    WCHAR* resultWord;
    WCHAR* tempWord;
    unsigned int iResultScore;

    // For optimization quick look up table.
    TRIESCAN* pTrieScanArray;
private:
    bool CheckNextCluster(WCHAR* szCluster, unsigned int iNumCluster);
    bool GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaitrigramtrieiter.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrigramTrieIter - contain the header for class CThaiTrigramTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAITRIGRAMTRIEITER_HPP_
#define _CTHAITRIGRAMTRIEITER_HPP_

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
#include "NLGlib.h"
#include "ProofBase.h"
#include "thwbdef.hpp"
#include "CTrie.hpp"

class CThaiTrigramTrieIter : public CTrieIter {
public:
    CThaiTrigramTrieIter();
    ~CThaiTrigramTrieIter();
    DWORD GetProb(WCHAR pos1, WCHAR pos2, WCHAR pos3);
	DWORD GetProb(WCHAR* posArray);
    void Init(CTrie* ctrie);
	void GetNode();
    WCHAR pos;
private:
    // For optimization quick look up table.
    WCHAR pos1Cache;
    WCHAR pos2Cache;
    TRIESCAN trieScanCache;

    TRIESCAN* pTrieScanArray;
    bool GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthaitrigramtrieiter.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiTrigramTrieIter
//
//  History:
//      created 8/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "CThaiTrigramTrieIter.hpp"


bool IsTagEqual(WCHAR pos1, WCHAR pos2)
{
    // if unambigious tags.
    if (pos1 < 48)
        return (pos1 == pos2);
    else
    {
        switch (pos1)
        {
        case 48:                // 48. ADVI ADVN
            return ((pos2 == 29) || (pos2 == 28));
        case 49:                // 49. ADVI ADVN NCMN
            return ((pos2 == 29) || (pos2 == 28) || (pos2 == 5));
        case 50:                // 50. ADVI ADVN VSTA
            return ((pos2 == 29) || (pos2 == 28) || (pos2 == 12));
        case 51:                // 51. ADVI VATT
            return ((pos2 == 29) || (pos2 == 13));
        case 52:                // 52. ADVN ADVP
            return ((pos2 == 28) || (pos2 == 30));
        case 53:                // 53. ADVN ADVP ADVS
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 31));
        case 54:                // 54. ADVN ADVP DIAQ DIBQ JCMP JSBR RPRE *
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 25));
        case 55:                // 55. ADVN ADVP NCMN VATT
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 5) || (pos2 == 13));
        case 56:                // 56. ADVN ADVP VSTA
            return ((pos2 == 28) || (pos2 == 30) || (pos2 == 12));
        case 57:                // 57. ADVN ADVS DDAC DDAN DIAC VATT XVAE *
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 20));
        case 58:                // 58. ADVN ADVS DDAN NCMN VATT VSTA *
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 19));
        case 59:                // 59. ADVN ADVS NCMN
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 5));
        case 60:                // 60. ADVN ADVS NCMN VATT
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 5) || (pos2 == 13));
        case 61:                // 61. ADVN ADVS VACT
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 11));
        case 62:                // 62. ADVN ADVS VATT
            return ((pos2 == 28) || (pos2 == 31) || (pos2 == 13));
        case 63:                // 63. ADVN CFQC NCMN RPRE VSTA *
            return ((pos2 == 28) || (pos2 == 35) || (pos2 == 5));
        case 64:                // 64. ADVN CLTV CNIT NCMN RPRE
            return ((pos2 == 28) || (pos2 == 33) || (pos2 == 32) || (pos2 == 5) || (pos2 == 40));
        case 65:                // 65. ADVN DCNM
            return ((pos2 == 28) || (pos2 == 26));
        case 66:                // 66. ADVN DDAC DDAN
            return ((pos2 == 28) || (pos2 == 20) || (pos2 == 19));
        case 67:                // 67. ADVN DDAC DDAN NCMN PDMN
            return ((pos2 == 28) || (pos2 == 20) || (pos2 == 19) || (pos2 == 5) || (pos2 == 8));
        case 68:                // 68. ADVN DDAC DDAN PDMN
            return ((pos2 == 28) || (pos2 == 20) || (pos2 == 19) || (pos2 == 8));
        case 69:                // 69. ADVN DDAN DDBQ
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 21));
        case 70:                // 70. ADVN DDAN DIAC PDMN VSTA
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 23) || (pos2 == 8) || (pos2 == 12));
        case 71:                // 71. ADVN DDAN FIXN PDMN
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 42) || (pos2 == 8));
        case 72:                // 72. ADVN DDAN NCMN
            return ((pos2 == 28) || (pos2 == 19) || (pos2 == 5));
        case 73:                // 73. ADVN DDAQ
            return ((pos2 == 28) || (pos2 == 22));
        case 74:                // 74. ADVN DDBQ
            return ((pos2 == 28) || (pos2 == 21));
        case 75:                // 75. ADVN DDBQ RPRE VATT
            return ((pos2 == 28) || (pos2 == 21) || (pos2 == 40) || (pos2 == 13));
        case 76:                // 76. ADVN DDBQ VATT VSTA XVAE *
            return ((pos2 == 28) || (pos2 == 21) || (pos2 == 13) || (pos2 == 12));
        case 77:                // 77. ADVN DIAC
            return ((pos2 == 28) || (pos2 == 21));
        case 78:                // 78. ADVN DIAC PDMN
            return ((pos2 == 28) || (pos2 == 21) || (pos2 == 8));
        case 79:                // 79. ADVN DIBQ
            return ((pos2 == 28) || (pos2 == 24));
        case 80:                // 80. ADVN DIBQ NCMN
            return ((pos2 == 28) || (pos2 == 24) || (pos2 == 5));
        case 81:                // 81. ADVN DIBQ VACT VSTA
            return ((pos2 == 28) || (pos2 == 24) || (pos2 == 11) || (pos2 == 12));
        case 82:                // 82. ADVN DIBQ VATT
            return ((pos2 == 28) || (pos2 == 24) || (pos2 == 13));
        case 83:                // 83. ADVN DONM JCMP
            return ((pos2 == 28) || (pos2 == 27) || (pos2 == 38));
        case 84:                // 84. ADVN DONM JSBR NCMN RPRE VATT XVAE *
            return ((pos2 == 28) || (pos2 == 27) || (pos2 == 39) || (pos2 == 5));
        case 85:                // 85. ADVN EITT PNTR
            return ((pos2 == 28) || (pos2 == 45) || (pos2 == 9));
        case 86:                // 86. ADVN FIXN
            return ((pos2 == 28) || (pos2 == 42));
        case 87:                // 87. ADVN JCMP
            return ((pos2 == 28) || (pos2 == 38));
        case 88:                // 88. ADVN JCRG
            return ((pos2 == 28) || (pos2 == 37));
        case 89:                // 89. ADVN JCRG JSBR
            return ((pos2 == 28) || (pos2 == 37) || (pos2 == 39));
        case 90:                // 90. ADVN JCRG JSBR XVBM XVMM
            return ((pos2 == 28) || (pos2 == 37) || (pos2 == 39) || (pos2 == 14) || (pos2 == 16));
        case 91:                // 91. ADVN JCRG RPRE VACT VSTA XVAE *
            return ((pos2 == 28) || (pos2 == 37) || (pos2 == 40) || (pos2 == 11));
        case 92:                // 92. ADVN JSBR
            return ((pos2 == 28) || (pos2 == 39));
        case 93:                // 93. ADVN JSBR NCMN
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 5));
        case 94:                // 94. ADVN JSBR RPRE VATT
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 40) || (pos2 == 13));
        case 95:                // 95. ADVN JSBR RPRE XVAE
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 40) || (pos2 == 18));
        case 96:                // 96. ADVN JSBR VSTA
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 12));
        case 97:                // 97. ADVN JSBR XVAE XVBM
            return ((pos2 == 28) || (pos2 == 39) || (pos2 == 18) || (pos2 == 14));
        case 98:                // 98. ADVN NCMN
            return ((pos2 == 28) || (pos2 == 5));
        case 99:                // 99. ADVN NCMN RPRE VACT VATT VSTA
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 40) || (pos2 == 11) || (pos2 == 12));
        case 100:               // 100. ADVN NCMN RPRE VACT XVAE
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 40) || (pos2 == 18));
        case 101:               // 101. ADVN NCMN RPRE VATT
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 102:               // 102. ADVN NCMN VACT VATT VSTA
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12));
        case 103:               // 103. ADVN NCMN VACT VSTA",
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 11) || (pos2 == 12));
        case 104:               // 104. ADVN NCMN VATT
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 13));
        case 105:               // 105. ADVN NCMN VATT VSTA
            return ((pos2 == 28) || (pos2 == 5) || (pos2 == 13) || (pos2 == 12));
        case 106:               // 106. ADVN NEG
            return ((pos2 == 28) || (pos2 == 46));
        case 107:               // 107. ADVN NPRP VATT
            return ((pos2 == 28) || (pos2 == 1) || (pos2 == 13));
        case 108:               // 108. ADVN PDMN VACT
            return ((pos2 == 28) || (pos2 == 8) || (pos2 == 11));
        case 109:               // 109. ADVN PNTR",
            return ((pos2 == 28) || (pos2 == 9));
        case 110:               // 110. ADVN RPRE",
            return ((pos2 == 28) || (pos2 == 40)); 
        case 111:               // 111. ADVN RPRE VACT VATT XVAE",
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 11) || (pos2 == 13));  
        case 112:               // 112. ADVN RPRE VACT XVAM XVBM
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 11) || (pos2 == 15) || (pos2 == 14)); 
        case 113:               // 113. ADVN RPRE VATT VSTA
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 13) || (pos2 == 12)); 
        case 114:               // 114. ADVN RPRE VSTA
            return ((pos2 == 28) || (pos2 == 40) || (pos2 == 12)); 
        case 115:               // 115. ADVN VACT
            return ((pos2 == 28) || (pos2 == 11)); 
        case 116:               // 116. ADVN VACT VATT
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 13)); 
        case 117:               // 117. ADVN VACT VATT VSTA
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12));
        case 118:               // 118. ADVN VACT VATT VSTA XVAM XVBM
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12) || (pos2 == 15) || (pos2 == 14));
        case 119:               // 119. ADVN VACT VSTA
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 12));
        case 120:               // 120. ADVN VACT VSTA XVAE
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 12) || (pos2 == 18));
        case 121:               // 121. ADVN VACT XVAE
            return ((pos2 == 28) || (pos2 == 11) || (pos2 == 18));
        case 122:               // 122. ADVN VATT
            return ((pos2 == 28) || (pos2 == 13));
        case 123:               // 123. ADVN VATT VSTA
            return ((pos2 == 28) || (pos2 == 13) || (pos2 == 12));
        case 124:               // 124. ADVN VATT VSTA XVAM XVBM XVMM
            return ((pos2 == 28) || (pos2 == 13) || (pos2 == 12) || (pos2 == 15) || (pos2 == 14));
        case 125:               // 125. ADVN VATT XVBM
            return ((pos2 == 28) || (pos2 == 13) || (pos2 == 14));
        case 126:               // 126. ADVN VSTA
            return ((pos2 == 28) || (pos2 == 12));
        case 127:               // 127. ADVN VSTA XVAE
            return ((pos2 == 28) || (pos2 == 12) || (pos2 == 18));
        case 128:               // 128. ADVN VSTA XVBM",
            return ((pos2 == 28) || (pos2 == 12) || (pos2 == 14));
        case 129:               // 129. ADVN XVAE
            return ((pos2 == 28) || (pos2 == 18));
        case 130:               // 130. ADVN XVAM
            return ((pos2 == 28) || (pos2 == 15));
        case 131:               // 131. ADVN XVBM XVMM
            return ((pos2 == 28) || (pos2 == 14) || (pos2 == 16));
        case 132:               // 132. ADVP JSBR RPRE VATT
            return ((pos2 == 30) || (pos2 == 39) || (pos2 == 40) || (pos2 == 13));
        case 133:               // 133. ADVP VATT
            return ((pos2 == 30) || (pos2 == 13));
        case 134:               // 134. ADVS DDAC JCRG
            return ((pos2 == 31) || (pos2 == 20) || (pos2 == 37));
        case 135:               // 135. ADVS DDAC JSBR
            return ((pos2 == 31) || (pos2 == 20) || (pos2 == 39));
        case 136:               // 136. ADVS DDAN VSTA
            return ((pos2 == 31) || (pos2 == 19) || (pos2 == 12));
        case 137:               // 137. ADVS DIAC
            return ((pos2 == 31) || (pos2 == 23));
        case 138:               // 138. ADVS DONM
            return ((pos2 == 31) || (pos2 == 27));
        case 139:               // 139. ADVS JCRG JSBR
            return ((pos2 == 31) || (pos2 == 37) || (pos2 == 39));
        case 140:               // 140. ADVS JCRG JSBR RPRE
            return ((pos2 == 31) || (pos2 == 37) || (pos2 == 39) || (pos2 == 40));
        case 141:               // 141. ADVS JSBR
            return ((pos2 == 31) || (pos2 == 39));
        case 142:               // 142. ADVS JSBR RPRE
            return ((pos2 == 31) || (pos2 == 39) || (pos2 == 40));
        case 143:               // 143. ADVS NCMN
            return ((pos2 == 31) || (pos2 == 5));
        case 144:               // 144. ADVS VATT
            return ((pos2 == 31) || (pos2 == 13));
        case 145:               // 145. CFQC CLTV CNIT DCNM JCRG JSBR NCMN RPRE XVBM
            return ((pos2 == 35) || (pos2 == 33) || (pos2 == 32));
        case 146:               // 146. CFQC CNIT PREL
            return ((pos2 == 35) || (pos2 == 32) || (pos2 == 10));
        case 147:               // 147. CFQC NCMN
            return ((pos2 == 35) || (pos2 == 5));
        case 148:               // 148. CLTV CNIT NCMN
            return ((pos2 == 33) || (pos2 == 32) || (pos2 == 5));
        case 149:               // 149. CLTV CNIT NCMN RPRE
            return ((pos2 == 33) || (pos2 == 32) || (pos2 == 5) || (pos2 == 40));
        case 150:               // 150. CLTV CNIT NCMN VSTA
            return ((pos2 == 33) || (pos2 == 32) || (pos2 == 5) || (pos2 == 12));
        case 151:               // 151. CLTV NCMN
            return ((pos2 == 33) || (pos2 == 5));
        case 152:               // 152. CLTV NCMN VACT VATT
            return ((pos2 == 33) || (pos2 == 5) || (pos2 == 11) || (pos2 == 13));
        case 153:               // 153. CLTV NCMN VATT
            return ((pos2 == 33) || (pos2 == 5) || (pos2 == 13));
        case 154:               // 154. CMTR CNIT NCMN
            return ((pos2 == 34) || (pos2 == 32) || (pos2 == 5));
        case 155:               // 155. CMTR NCMN
            return ((pos2 == 34) || (pos2 == 5));
        case 156:               // 156. CMTR NCMN VATT VSTA
            return ((pos2 == 34) || (pos2 == 5) || (pos2 == 13) || (pos2 == 12));
        case 157:               // 157. CNIT DDAC NCMN VATT
            return ((pos2 == 32) || (pos2 == 20) || (pos2 == 5) || (pos2 == 13));
        case 158:               // 158. CNIT DONM NCMN RPRE VATT
            return ((pos2 == 32) || (pos2 == 27) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 159:               // 159. CNIT FIXN FIXV JSBR NCMN
            return ((pos2 == 32) || (pos2 == 42) || (pos2 == 43) || (pos2 == 39) || (pos2 == 5));
        case 160:               // 160. CNIT JCRG JSBR NCMN PREL RPRE VATT
            return ((pos2 == 32) || (pos2 == 37) || (pos2 == 39) || (pos2 == 5) || (pos2 == 40));
        case 161:               // 161. CNIT JSBR RPRE
            return ((pos2 == 32) || (pos2 == 39) || (pos2 == 40));
        case 162:               // 162. CNIT NCMN
            return ((pos2 == 32) || (pos2 == 5));
        case 163:               // 163. CNIT NCMN RPRE
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 40));
        case 164:               // 164. CNIT NCMN RPRE VATT
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 165:               // 165. CNIT NCMN VACT
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 11));
        case 166:               // 166. CNIT NCMN VSTA
            return ((pos2 == 32) || (pos2 == 5) || (pos2 == 12));
        case 167:               // 167. CNIT NCNM
            return ((pos2 == 32) || (pos2 == 5));
        case 168:               // 168. CNIT PPRS
            return ((pos2 == 32) || (pos2 == 7));
        case 169:               // 169. DCNM DDAC DIAC DONM VATT VSTA *
            return ((pos2 == 26) || (pos2 == 20) || (pos2 == 23));
        case 170:               // 170. DCNM DDAN DIAC  
            return ((pos2 == 26) || (pos2 == 19) || (pos2 == 23));
        case 171:               // 171. DCNM DIAC NCMN NCNM
            return ((pos2 == 26) || (pos2 == 23) || (pos2 == 5) || (pos2 == 2));
        case 172:               // 172. DCNM DIBQ NCMN
            return ((pos2 == 26) || (pos2 == 24) || (pos2 == 5));
        case 173:               // 173. DCNM DONM
            return ((pos2 == 26) || (pos2 == 27));
        case 174:               // 174. DCNM NCMN
            return ((pos2 == 26) || (pos2 == 2));
        case 175:               // 175. DCNM NCNM
            return ((pos2 == 26) || (pos2 == 5));
        case 176:               // 176. DCNM NCNM VACT
            return ((pos2 == 26) || (pos2 == 5) || (pos2 == 11));
        case 177:               // 177. DCNM VATT
            return ((pos2 == 26) || (pos2 == 13));
        case 178:               // 178. DDAC DDAN
            return ((pos2 == 20) || (pos2 == 19));
        case 179:               // 179. DDAC DDAN DIAC NCMN
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==23) || (pos2 ==5));
        case 180:               // 180. DDAC DDAN DIAC VATT
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==23) || (pos2 ==13));
        case 181:               // 181. DDAC DDAN EAFF PDMN
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==44) || (pos2 ==8));
        case 182:               // 182. DDAC DDAN PDMN
            return ((pos2 == 20) || (pos2 == 19) || (pos2 ==8));
        case 183:               // 183. DDAC DIAC VSTA
            return ((pos2 == 20) || (pos2 == 23) || (pos2 ==12));
        case 184:               // 184. DDAC NCMN
            return ((pos2 == 20) || (pos2 == 5));
        case 185:               // 185. DDAN DDBQ
            return ((pos2 == 20) || (pos2 == 21));
        case 186:               // 186. DDAN DIAC PNTR
            return ((pos2 == 20) || (pos2 == 23) || (pos2 == 9));
        case 187:               // 187. DDAN NCMN
            return ((pos2 == 20) || (pos2 == 5));
        case 188:               // 188. DDAN NCMN RPRE VATT
            return ((pos2 == 20) || (pos2 == 5) || (pos2 == 40) || (pos2 == 13));
        case 189:               // 189. DDAN PDMN
            return ((pos2 == 20) || (pos2 == 8));
        case 190:				// 190. DDAN RPRE
            return ((pos2 == 20) || (pos2 == 40));
        case 191:               // 191. VATT
            return (pos2 == 13);
		case 192:				// 192. DDAQ VATT
            return ((pos2 == 22) || (pos2 == 13));
		case 193:				// 193. DDBQ DIBQ
            return ((pos2 == 21) || (pos2 == 24));
		case 194:				// 194. DDBQ JCRG JSBR
            return ((pos2 == 21) || (pos2 == 37) || (pos2 == 39));
		case 195:				// 195. DDBQ JCRG NCMN
            return ((pos2 == 21) || (pos2 == 37) || (pos2 == 5));
		case 196:				// 196. DIAC PDMN
            return ((pos2 == 23) || (pos2 == 8));
		case 197:				// 197. DIBQ JSBR RPRE VSTA
            return ((pos2 == 24) || (pos2 == 39) || (pos2 == 40) || (pos2 == 12));
		case 198:				// 198. DIBQ NCMN
            return ((pos2 == 24) || (pos2 == 5));
		case 199:				// 199. DIBQ VATT
            return ((pos2 == 24) || (pos2 == 13));
		case 200:				// 200. DIBQ VATT VSTA
            return ((pos2 == 24) || (pos2 == 13) || (pos2 == 12));
		case 201:				// 201. DIBQ XVBM
            return ((pos2 == 24) || (pos2 == 14));
		case 202:				// 202. DONM NCMN RPRE
            return ((pos2 == 27) || (pos2 == 5) || (pos2 == 40));
		case 203:				// 203. DONM VACT VATT VSTA
            return ((pos2 == 27) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12));
		case 204:				// 204. DONM VATT
            return ((pos2 == 27) || (pos2 == 13));
		case 205:				// 205. EAFF XVAE XVAM XVBM
            return ((pos2 == 44) || (pos2 == 18) || (pos2 == 15) || (pos2 == 14));
		case 206:				// 206. EITT JCRG
            return ((pos2 == 45) || (pos2 == 37));
		case 207:				// 207. FIXN FIXV NCMN
            return ((pos2 == 42) || (pos2 == 43) || (pos2 == 5));
		case 208:				// 208. FIXN FIXV RPRE VSTA
            return ((pos2 == 42) || (pos2 == 43) || (pos2 == 40) || (pos2 == 12));
		case 209:				// 209. FIXN JSBR NCMN PREL RPRE VSTA XVBM *
            return ((pos2 == 42) || (pos2 == 39) || (pos2 == 5) || (pos2 == 10));
		case 210:				// 210. FIXN NCMN
			return ((pos2 == 42) || (pos2 == 5));
		case 211:				// 211. FIXN VACT",
			return ((pos2 == 42) || (pos2 == 11));
		case 212:				// 212. FIXN VACT VSTA",
			return ((pos2 == 42) || (pos2 == 11) || (pos2 == 12));
		case 213:				// 213. FIXV JSBR RPRE",
			return ((pos2 == 42) || (pos2 == 39) || (pos2 == 40));
		case 214:				// 214. JCMP JSBR",
			return ((pos2 == 38) || (pos2 == 39));
		case 215:				// 215. JCMP RPRE VSTA",
			return ((pos2 == 38) || (pos2 == 40) || (pos2 == 12));
		case 216:				// 216. JCMP VATT VSTA",
			return ((pos2 == 38) || (pos2 == 13) || (pos2 == 12));
		case 217:				// 217. JCMP VSTA",
			return ((pos2 == 38) || (pos2 == 12));
		case 218:				// 218. JCRG JSBR",
			return ((pos2 == 37) || (pos2 == 39));
		case 219:				// 219. JCRG JSBR NCMN RPRE
			return ((pos2 == 37) || (pos2 == 39) || (pos2 == 5) || (pos2 == 40));
		case 220:				// 220. JCRG JSBR RPRE",
			return ((pos2 == 37) || (pos2 == 39) || (pos2 == 40));
		case 221:				// 221. JCRG RPRE
			return ((pos2 == 37) || (pos2 == 40));
		case 222:				// 222. JCRG RPRE VATT VSTA
			return ((pos2 == 37) || (pos2 == 40)|| (pos2 == 13)|| (pos2 == 12));
		case 223:				// 223. JCRG VSTA
			return ((pos2 == 37) || (pos2 == 12));
		case 224:				// 224. JSBR NCMN
			return ((pos2 == 39) || (pos2 == 5));
		case 225:				// 225. JSBR NCMN XVAE
			return ((pos2 == 39) || (pos2 == 5) || (pos2 == 18));
		case 226:				// 226. JSBR NCMN XVAM XVBM XVMM
			return ((pos2 == 39) || (pos2 == 5) || (pos2 == 15) || (pos2 == 14) || (pos2 ==16));
		case 227:				// 227. JSBR PREL
			return ((pos2 == 39) || (pos2 == 10));
		case 228:				// 228. JSBR PREL RPRE
			return ((pos2 == 39) || (pos2 == 10) || (pos2 == 40));
		case 229:				// 229. JSBR PREL XVBM
			return ((pos2 == 39) || (pos2 == 10) || (pos2 == 14));
		case 230:				// 230. JSBR RPRE
			return ((pos2 == 39) || (pos2 == 40));
		case 231:				// 231. JSBR RPRE VACT
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 11));
		case 232:				// 232. JSBR RPRE VACT VSTA
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 11)|| (pos2 == 12));
		case 233:				// 233. JSBR RPRE VACT XVAE XVAM
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 11)|| (pos2 == 18)|| (pos2 == 15));
		case 234:				// 234. JSBR RPRE VATT
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 13));
		case 235:				// 235. JSBR RPRE VSTA
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 12));
		case 236:				// 236. JSBR RPRE XVAM
			return ((pos2 == 39) || (pos2 == 40)|| (pos2 == 15));
		case 237:				// 237. JSBR VACT
			return ((pos2 == 39) || (pos2 == 11));
		case 238:				// 238. JSBR VACT VSTA
			return ((pos2 == 39) || (pos2 == 11) || (pos2 == 12));
		case 239:				// 239. JSBR VATT XVBM XVMM
			return ((pos2 == 39) || (pos2 == 13) || (pos2 == 14) || (pos2 == 16));
		case 240:				// 240. JSBR VSTA
			return ((pos2 == 39) || (pos2 == 12));
		case 241:				// 241. JSBR XVBM
			return ((pos2 == 39) || (pos2 == 14)); 
		case 242:				// 242. NCMN NCNM
			return ((pos2 == 5) || (pos2 == 2)); 
		case 243:				// 243. NCMN NCNM NPRP
			return ((pos2 == 5) || (pos2 == 2) || (pos2 == 1)); 
		case 244:				// 244. NCMN NLBL NPRP
			return ((pos2 == 5) || (pos2 == 4) || (pos2 == 1)); 
		case 245:				// 245. NCMN NPRP
			return ((pos2 == 5) || (pos2 == 1)); 
		case 246:				// 246. NCMN NPRP RPRE
			return ((pos2 == 5) || (pos2 == 1) || (pos2 == 40)); 
		case 247:				// 247. NCMN NTTL
			return ((pos2 == 5) || (pos2 == 6)); 
		case 248:				// 248. NCMN PDMN PPRS
			return ((pos2 == 5) || (pos2 == 8) || (pos2 == 7)); 
		case 249:				// 249. NCMN PDMN VATT
			return ((pos2 == 5) || (pos2 == 8) || (pos2 == 13)); 
		case 250:				// 250. NCMN PNTR
			return ((pos2 == 5) || (pos2 == 9)); 
		case 251:				// 251. NCMN PPRS PREL VACT
			return ((pos2 == 5) || (pos2 == 7) || (pos2 == 10) || (pos2 == 11)); 
		case 252:				// 252. NCMN RPRE
			return ((pos2 == 5) || (pos2 == 40)); 
		case 253:				// 253. NCMN RPRE VACT VATT
			return ((pos2 == 5) || (pos2 == 40) || (pos2 == 11) || (pos2 == 13)); 
		case 254:				// 254. NCMN RPRE VATT
			return ((pos2 == 5) || (pos2 == 40) || (pos2 == 13)); 
		case 255:				// 255. NCMN VACT
			return ((pos2 == 5) || (pos2 == 11)); 
		case 256:				// 256. NCMN VACT VATT
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 13)); 
		case 257:				// 257. NCMN VACT VATT VSTA XVAE
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 13) || (pos2 == 12) || (pos2 == 18)); 
		case 258:				// 258. NCMN VACT VSTA
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 12)); 
		case 259:				// 259. NCMN VACT VSTA XVAM
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 12) || (pos2 == 15)); 
		case 260:				// 260. NCMN VACT VSTA XVBB
			return ((pos2 == 5) || (pos2 == 11) || (pos2 == 12) || (pos2 == 17)); 
		case 261:				// 261. NCMN VATT
			return ((pos2 == 5) || (pos2 == 13)); 
		case 262:				// 262. NCMN VATT VSTA
			return ((pos2 == 5) || (pos2 == 13) || (pos2 == 12)); 
		case 263:				// 263. NCMN VATT XVAM
			return ((pos2 == 5) || (pos2 == 13) || (pos2 == 15)); 
		case 264:				// 264. NCMN VSTA
			return ((pos2 == 5) || (pos2 == 12)); 
		case 265:				// 265. NCMN XVBM
			return ((pos2 == 5) || (pos2 == 14)); 
		case 266:				// 266. NPRP RPRE
			return ((pos2 == 1) || (pos2 == 40)); 
		case 267:				// 267. NPRP VATT
			return ((pos2 == 1) || (pos2 == 13)); 
		case 268:				// 268. NTTL PPRS
			return ((pos2 == 6) || (pos2 == 7)); 
		case 269:				// 269. PDMN PPRS
			return ((pos2 == 8) || (pos2 == 7)); 
		case 270:				// 270. PDMN VATT
			return ((pos2 == 8) || (pos2 == 13)); 
		case 271:				// 271. PDMN VATT VSTA
			return ((pos2 == 8) || (pos2 == 13) || (pos2 == 12)); 
		case 272:				// 272. PPRS PREL
			return ((pos2 == 7) || (pos2 == 10)); 
		case 273:				// 273. PPRS VATT
			return ((pos2 == 7) || (pos2 == 13)); 
		case 274:				// 274. RPRE VACT
			return ((pos2 == 40) || (pos2 == 11)); 
		case 275:				// 275. RPRE VACT VATT
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 13)); 
		case 276:				// 276. RPRE VACT VSTA
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 12)); 
		case 277:				// 277. RPRE VACT VSTA XVAE
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 12) || (pos2 == 18)); 
		case 278:				// 278. RPRE VACT XVAE
			return ((pos2 == 40) || (pos2 == 11) || (pos2 == 18)); 
		case 279:				// 279. RPRE VATT
			return ((pos2 == 40) || (pos2 == 13)); 
		case 280:				// 280. RPRE VATT VSTA
			return ((pos2 == 40) || (pos2 == 13) || (pos2 == 12)); 
		case 281:				// 281. RPRE VSTA
			return ((pos2 == 40) || (pos2 == 12)); 
		case 282:				// 282. VACT VATT
			return ((pos2 == 11) || (pos2 == 13)); 
		case 283:				// 283. VACT VATT VSTA
			return ((pos2 == 11) || (pos2 == 13) || (pos2 == 12)); 
		case 284:				// 284. VACT VATT XVAE XVAM XVBM
			return ((pos2 == 11) || (pos2 == 13) || (pos2 == 18) || (pos2 == 15) || (pos2 == 14)); 
		case 285:				// 285. VACT VSTA
			return ((pos2 == 11) || (pos2 == 12)); 
		case 286:				// 286. VACT VSTA XVAE
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 18)); 
		case 287:				// 287. VACT VSTA XVAE XVAM
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 18) || (pos2 == 15)); 
		case 288:				// 288. VACT VSTA XVAE XVAM XVMM",
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 18) || (pos2 == 15) || (pos2 == 16)); 
		case 289:				// 289. VACT VSTA XVAM",
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 15)); 
		case 290:				// 290. VACT VSTA XVAM XVMM",
			return ((pos2 == 11) || (pos2 == 12) || (pos2 == 15) || (pos2 == 16)); 
		case 291:				// 291. VACT XVAE",
			return ((pos2 == 11) || (pos2 == 18)); 
		case 292:				// 292. VACT XVAM",
			return ((pos2 == 11) || (pos2 == 15)); 
		case 293:				// 293. VACT XVAM XVMM",
			return ((pos2 == 11) || (pos2 == 15) || (pos2 == 16)); 
		case 294:				// 294. VACT XVMM",
			return ((pos2 == 11) || (pos2 == 16)); 
		case 295:				// 295. VATT VSTA",
			return ((pos2 == 13) || (pos2 == 12)); 
		case 296:				// 296. VSTA XVAE",
			return ((pos2 == 12) || (pos2 == 18)); 
		case 297:				// 297. VSTA XVAM",
			return ((pos2 == 12) || (pos2 == 15)); 
		case 298:				// 298. VSTA XVAM XVMM",
			return ((pos2 == 12) || (pos2 == 15) || (pos2 == 16)); 
		case 299:				// 299. VSTA XVBM",
			return ((pos2 == 12) || (pos2 ==14)); 
		case 300:				// 300. XVAM XVBM",
			return ((pos2 == 15) || (pos2 == 14)); 
		case 301:				// 301. XVAM XVBM XVMM",
			return ((pos2 == 15) || (pos2 == 14) || (pos2 == 16)); 
		case 302:				// 302. XVAM XVMM",
			return ((pos2 == 15) || (pos2 == 16)); 
		default:
			return false;
        }
    }
}
//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrigramTrieIter
//
//  Synoposis:  Constructor:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramTrieIter::CThaiTrigramTrieIter() : pTrieScanArray(NULL)
{
    pTrieScanArray = new TRIESCAN[50];
}

//+---------------------------------------------------------------------------
//
//  Class:      CThaiTrigramTrieIter
//
//  Synoposis:  Destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CThaiTrigramTrieIter::~CThaiTrigramTrieIter()
{
    if (pTrieScanArray)
        delete pTrieScanArray;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrigramTrieIter::Init(CTrie* ctrie)
{
    // Declare varialbes.
    WCHAR pos;

    // Initialize parent.
    CTrieIter::Init(ctrie);

    pos1Cache = 0;
    pos2Cache = 0;

    // Initialize Hash table.
    for (pos = 1; pos <= 47; pos++)
        GetScanFirstChar(pos,&pTrieScanArray[pos]);
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiTrigramTrieIter::GetScanFirstChar(WCHAR wc, TRIESCAN* pTrieScan)
{
    // Reset the trie scan.
	memset(&trieScan, 0, sizeof(TRIESCAN));

    // Encrypt
    wc += 0x0100;

    if (!TrieGetNextState(pTrieCtrl, &trieScan))
        return false;

    while (wc != trieScan.wch)
    {
        // Keep moving the the right of the trie.
        if (!TrieGetNextNode(pTrieCtrl, &trieScan))
        {
        	memset(pTrieScan, 0, sizeof(TRIESCAN));
            return false;
        }
    }
    memcpy(pTrieScan, &trieScan, sizeof(TRIESCAN));

    return true;
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiTrigramTrieIter::GetNode()
{
	pos = (WCHAR) trieScan.wch - 0x0100;
/*
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID) &&
				(!(trieScan.wFlags & TRIE_NODE_TAGGED) ||
				(trieScan.aTags[0].dwData & iDialectMask));
*/
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID);

	if (fWordEnd)
	{
        dwTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
                            trieScan.aTags[0].dwData :
                            0);
	}
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiTrigramTrieIter
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CThaiTrigramTrieIter::GetProb(WCHAR pos1, WCHAR pos2, WCHAR pos3)
{
   	// Declare and initialize all local variables.
	int i = 0;

    if (pos1 == pos1Cache && pos2 == pos2Cache)
    {
        memcpy(&trieScan,&trieScanCache, sizeof(TRIESCAN));

        if (!Down()) return 0;
        while (true)
        {
            GetNode();
            if (IsTagEqual(pos3,pos) && fWordEnd)
            {
                return dwTag;
            }
            else if (!Right()) break;               
        }
        return 0;
    }
    if (pos1 >= 1 && pos1 <= 47)
        memcpy(&trieScan,&pTrieScanArray[pos1], sizeof(TRIESCAN));
	Reset();

	if (!Down())
		return false;

	while (true)
	{
		GetNode();
		if (IsTagEqual(pos1,pos))
		{
            if (!Down()) break;
            while (true)
            {
        		GetNode();
                if (IsTagEqual(pos2,pos))
	        	{
                    pos1Cache = pos1;
                    pos2Cache = pos2;
                    memcpy(&trieScanCache,&trieScan, sizeof(TRIESCAN));

                    if (!Down()) break;
                    while (true)
                    {
                		GetNode();
                        if (IsTagEqual(pos3,pos) && fWordEnd)
	                	{
                            return dwTag;
                        }
                		else if (!Right()) break;               
                    }
                    return 0;
                }
        		else if (!Right()) break;               
            }
            return 0;
		}
		// Move right of the Trie Branch
		else if (!Right()) break;
	}
	return 0;
}

DWORD CThaiTrigramTrieIter::GetProb(WCHAR* posArray)
{
	// Declare and initialize all local variables.
	int i = 0;

	Reset();

	if (!Down())
		return 0;

	while (TRUE)
	{
		GetNode();
		if (pos == posArray[i])
		{
			i++;
			if (fWordEnd && posArray[i] == '\0')
            {
				return dwTag;
            }
			// Move down the Trie Branch.
			else if (!Down()) break;
		}
		// Move right of the Trie Branch
		else if (!Right()) break;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthwb.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiWordBreak
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTHAIWORDBREAK_H_
#define _CTHAIWORDBREAK_H_
#include "thwbdef.hpp"
#include "ctrie.hpp"
#include "CThaiTrieIter.hpp"
#include "lextable.hpp"
#include "CThaiBreakTree.hpp"
#include "CThaiTrigramTrieIter.hpp"

class CThaiBreakTree;

class CThaiWordBreak {
public:
#if defined (NGRAM_ENABLE)
	PTEC Init(WCHAR* wzFileName, WCHAR* wzFileNameSentStruct, WCHAR* wzFileNameTrigram);
#else
	PTEC Init(WCHAR* wzFileName, WCHAR* wzFileNameTrigram);
#endif
	PTEC InitRc(LPBYTE , LPBYTE);
	void UnInit();

	int IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax);
	int FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);

	int FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak = true);

	DWORD_PTR CreateWordBreaker();
	bool DeleteWordBreaker(DWORD_PTR dwBreaker);
	int FindWordBreak(DWORD_PTR dwBreaker, WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak = true, THWB_STRUCT* pThwb_Struct = NULL);

    BOOL Find(WCHAR* wzString, DWORD* pdwPOS);
    int Soundex(WCHAR* word) {return 0;} //breakTree.Soundex(word);} -- re-entrant bug fix
protected:
#if defined (NGRAM_ENABLE)
	BOOL WordBreak(WCHAR* pszBegin, WCHAR* pszEnd);
#endif

	CTrie m_trie;
#if defined (NGRAM_ENABLE)
    CTrie trie_sentence_struct;
#endif
	CTrie m_trie_trigram;
    CThaiTrieIter m_thaiTrieIter;
//    CThaiBreakTree breakTree;  fix re-entrant bug.

	int wordCount[MAXBREAK];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\dbgmemp.h ===
#ifndef _DBGMEMP_H
#define _DBGMEMP_H

#include <windows.h>
#include <string.h>
#include "cmn_debug.h"              // For our local version of Assert()

// Define ENABLE_DBG_HANDLES if you want to be enable the moveable block
// portion of the memory allocator
#undef ENABLE_DBG_HANDLES

// The base allocator type
typedef struct head             /* Private memory block header */
{
    DWORD dwTag;                /* Block validation ID */
    struct head* pheadNext;     /* Next in list of allocated blocks */
    int idBlock;                /* Block "name" */

    DWORD cbBlock;              /* Size of caller's memory block */
    int cLock;                  /* Lock count of object */

    LPBYTE pbBase;              /* The VirtualAlloc'd block */
} HEAD;

#define HEAD_TAG  ( MAKELONG( MAKEWORD('H','E'),MAKEWORD('A','D') ))
#define PAD(a,n)  ( ((a)+(n)-1) / (n) * (n) )


// byte patterns for filling memory
#define bNewGarbage    0xA3
#define bOldGarbage    0xA4
#define bFreeGarbage   0xA5
#define bDebugByte     0xE1

// Flags for enabling particular types of optional behavior
// if fMove is true, blah blah
// if fExtraReadPage is true, blah blah
// if fPadBlocks is true, all memory allocations will be padded to 4-byte boundaries
#define fMove           FALSE
#define fExtraReadPage  FALSE
#ifdef _M_ALPHA
// Enable dword alignment (padding to 4 byte boundaries) for the Alpha
#define fPadBlocks      TRUE
#else // not _M_ALPHA
#define fPadBlocks      FALSE
#endif // _M_ALPHA


// Protos that must be shared between our source files
HEAD    *GetBlockHeader(void*);
LPVOID  PvAllocateCore(UINT, DWORD);

#ifdef ENABLE_DBG_HANDLES
#define minGHandle      0xA0000000L
#define cGHandles       0x4000L
#define limGHandle      (minGHandle+cGHandles)

HGLOBAL WINAPI  HgAllocateMoveable(UINT uFlags, DWORD cb);
HGLOBAL WINAPI  HgModifyMoveable(HGLOBAL hMem, DWORD cb, UINT uFlags);
void            **PpvFromHandle(HGLOBAL);

#else // NOT ENABLE_DBG_HANDLES

#define HgAllocateMoveable(a, b)    (NULL)
#define HgModifyMoveable(a, b, c)   (NULL)
#define PpvFromHandle(a)            (NULL)

#endif // ENABLE_DBG_HANDLES


/* F A C T U A L  H A N D L E */
/*----------------------------------------------------------------------------
    %%Macro: FActualHandle

    Returns TRUE if the handle came from actual Global memory manager.
----------------------------------------------------------------------------*/
#define FActualHandle(hMem)     FALSE

#endif // _DBGMEMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\cthwb.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CThaiWordBreak
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "cthwb.hpp"

//+---------------------------------------------------------------------------
//
//  Function:   ExtractALT
//
//  Synopsis:   The functions takes a tag and return Alternate Tags.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BYTE ExtractALT(DWORD dwTag)
{
    return (BYTE) ( (dwTag & iAltMask) >> iAltShift);
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   Initialize ThaiWordBreak.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
PTEC CThaiWordBreak::Init(WCHAR* wzFileName, WCHAR* wzFileNameSentStruct, WCHAR* wzFileNameTrigram)
#else
PTEC CThaiWordBreak::Init(WCHAR* wzFileName, WCHAR* wzFileNameTrigram)
#endif
{
    // Declare and Initialize local variables.
    PTEC retValue = m_trie.Init(wzFileName);
#if defined (NGRAM_ENABLE)
    if (retValue == ptecNoErrors)
    {
        // Initialize m_thaiTrieIter.
        m_thaiTrieIter.Init(&trie);
        retValue = m_trie_sentence_struct.Init(wzFileNameSentStruct);
        if (retValue == ptecNoErrors)
		{
			retValue = m_trie_trigram.Init(wzFileNameTrigram);
/* fix re-entrant bug
			if (retValue == ptecNoErrors)
	            breakTree.Init(&trie, &trie_sentence_struct, &trie_trigram);
*/
		}
		
    }
#else
    if (retValue == ptecNoErrors)
    {
		retValue = m_trie_trigram.Init(wzFileNameTrigram);
/* fix re-entrant bug
		if (retValue == ptecNoErrors)
			breakTree.Init(&trie, &trie_trigram);
*/
	}
#endif

	return retValue;
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   Initialize ThaiWordBreak.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC CThaiWordBreak::InitRc(LPBYTE pThaiDic, LPBYTE pThaiTrigram)
{
    // Declare and Initialize local variables.
    PTEC retValue = m_trie.InitRc(pThaiDic);
    if (retValue == ptecNoErrors)
		retValue = m_trie_trigram.InitRc(pThaiTrigram);

	return retValue;
}



//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:   UnInitialize ThaiWordBreak.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CThaiWordBreak::UnInit()
{
	m_trie.UnInit();
#if defined (NGRAM_ENABLE)
    m_trie_sentence_struct.UnInit();
#endif
	m_trie_trigram.UnInit();
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
enum merge_direction	{
							NO_MERGE,
							MERGE_RIGHT,
							MERGE_LEFT,
							MERGE_BOTH_DIRECTIONS,
							NOT_SURE_WHICH_DIRECTION
						};
merge_direction DetermineMergeDirection(WCHAR wc)
{
	if (wc == 0x0020) // space
		return NO_MERGE;
	else if (   wc == 0x0022 || // quotation mark
		        wc == 0x0027 )  // apostrophe
		return NOT_SURE_WHICH_DIRECTION;
	else if (	wc == 0x0028 || // left parenthesis
				wc == 0x003C || // less than sign
				wc == 0x005B || // left square bracket
				wc == 0x007B || // left curly bracket
				wc == 0x201C || // left double quotation mark
				wc == 0x201F )  // left double quotation mark reverse
		return MERGE_RIGHT;

	// TODO: need to add MERGE_BOTH_DIRECTIONS for character joiner characters.

	// all other character merge left.
	return MERGE_LEFT;
}
//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD_PTR CThaiWordBreak::CreateWordBreaker()
{
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();
#if defined (NGRAM_ENABLE)
	breakTree->Init(&m_trie, &m_trie_sentence_struct, &m_trie_trigram);
#else
	breakTree->Init(&m_trie, &m_trie_trigram);
#endif
	return (DWORD_PTR)breakTree;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
bool CThaiWordBreak::DeleteWordBreaker(DWORD_PTR dwBreaker)
{
	CThaiBreakTree* breakTree	= (CThaiBreakTree*) dwBreaker;

	if (breakTree)
	{
		delete breakTree;
		return true;
	}

	return false;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:	This funciton segment Thai word use for Indexing.
//				
//  Arguments:
//			wzString		- input string.				(in)
//			iStringLen		- input string length.		(in)	
//			pBreakPos		- array of break position.	(out)
//			pThwb_Struct	- array structure of THWB.	(out)
//			iBreakMax		- length of pBreakPos and
//							  pThwb_Struct.				(out)
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax)
{
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();

	if (breakTree)
	{
		breakTree->Init(&m_trie, &m_trie_trigram);

		iBreakIndex = FindWordBreak((DWORD_PTR)breakTree,wzString,iStringLen,pBreakPos,iBreakMax,WB_INDEX,true,pThwb_Struct);

		delete breakTree;
	}

	return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//				
//  Arguments:
//
//			wzWord			- input string.								(in)
//			iWordLen		- input string length.						(in)	
//			Alt				- find close alternate word					(in)
//			pBreakPos		- array of break position allways 5 byte.	(out)
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos)
{
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();

	if (breakTree)
	{
		breakTree->Init(&m_trie, &m_trie_trigram);

		iBreakIndex = breakTree->FindAltWord(wzWord,iWordLen,Alt,pBreakPos);

		delete breakTree;
	}

	return iBreakIndex;
}


//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:	This funciton segment Thai text segment them depending on the modes specifies.
//
//				WB_LINEBREAK - is used when the application needs to break for line wrapping,
//                             this mode takes into the consideration of punctuations.
//
//				WB_NORMAL - is used when application wants determine word for searching,
//                          autocorrect, etc.
//
//				WB_SPELLER - not yet implemented, but same as normal with additional soundex
//                           rules.
//				
//  Arguments:
//
//			wzString		- input string.				(in)
//			iStringLen		- input string length.		(in)	
//			pBreakPos		- array of break position.	(out)
//			iBreakMax		- length of pBreakPos		(out)
//			mode			- either WB_LINEBREAK, etct (in)
//			fFastWordBreak	- true for fast algorithm	(in)
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak)
{
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
// fix re-entrant bug
	CThaiBreakTree* breakTree	= NULL;
	breakTree = new CThaiBreakTree();

	if (breakTree)
	{
#if defined (NGRAM_ENABLE)
		breakTree->Init(&m_trie, &trie_sentence_struct, &m_trie_trigram);
#else
		breakTree->Init(&m_trie, &m_trie_trigram);
#endif

		assert(mode != WB_INDEX);	// If this assert come up, use function IndexWordBreak

		iBreakIndex = FindWordBreak((DWORD_PTR)breakTree,wzString,iStringLen,pBreakPos,iBreakMax,mode,fFastWordBreak);

		delete breakTree;
	}

	return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:	This funciton segment Thai text segment them depending on the modes specifies.
//
//				WB_LINEBREAK - is used when the application needs to break for line wrapping,
//                             this mode takes into the consideration of punctuations.
//
//				WB_NORMAL - is used when application wants determine word for searching,
//                          autocorrect, etc.
//
//				WB_SPELLER - not yet implemented, but same as normal with additional soundex
//                           rules.
//
//				WB_INDEX - is used when application wanted to do Thai indexing.
//
//
//  Arguments:
//
//			wzString		- input string.				(in)
//			iStringLen		- input string length.		(in)	
//			pBreakPos		- array of break position.	(out)
//			iBreakMax		- length of pBreakPos		(out)
//							  must be greater than 1.
//			mode			- either WB_LINEBREAK, etct (in)
//			fFastWordBreak	- true for fast algorithm	(in)
//			pThwb_Struct	- array structure of THWB.	(out)
//
//  Modifies:
//
//  History:    created 11/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int CThaiWordBreak::FindWordBreak(DWORD_PTR dwBreaker, WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakMax, BYTE mode, bool fFastWordBreak, THWB_STRUCT* pThwb_Struct)
{
    // Declare and Initialize all local variables.
    WCHAR* pwszRunStart            = wzString;
    WCHAR* pwszMax                 = wzString + iStringLen;
    WCHAR* pwch					   = wzString;
	bool fThaiRun		           = true;
	bool fSpaceMergeRight          = false;
	int iRunCount                  = 0;
    unsigned int i                 = 0;
    unsigned int iBreakIndex       = 0;            // Contain number of Breaks.
	merge_direction dirPrevious = NO_MERGE;
	merge_direction dirCurrent  = NO_MERGE;

	CThaiBreakTree* breakTree = (CThaiBreakTree*) dwBreaker;

	// check for possible invalid arguments.
	assert(wzString != NULL);
	assert(iBreakMax > 0);
	assert(pBreakPos != NULL);
	if ((wzString == NULL) || (iBreakMax == 0) || (pBreakPos == NULL))
		return 0;

    switch (mode)
    {
    case WB_LINEBREAK:
	case 2:					// to be compatible with old api.
    	do
        {
		    while ((TWB_IsCharPunctW(*pwch) || TWB_IsCharWordDelimW(*pwch))  && iBreakIndex < iBreakMax && pwch < pwszMax)
			{
				dirCurrent = DetermineMergeDirection(*pwch);
				switch (dirCurrent)
				{
				case NO_MERGE:
					if ( pwch + 1 < pwszMax && *(pwch + 1) == THAI_Vowel_MaiYaMok && iBreakIndex > 0)
					{
						// Mai Ya Mok case only.
						pBreakPos[iBreakIndex - 1] += 2;	
						dirCurrent = MERGE_LEFT;
						pwch++;
					}
					else
						pBreakPos[iBreakIndex++] = 1;
					break;

				case MERGE_RIGHT:
					if (dirPrevious == MERGE_RIGHT)
						pBreakPos[iBreakIndex - 1]++;
					else if (!TWB_IsCharPunctW(*(pwch + 1)))
						pBreakPos[iBreakIndex++] = 1;
					else
						pBreakPos[iBreakIndex++] = 1;
					break;

				case NOT_SURE_WHICH_DIRECTION:
					if (pwch == wzString					||	// if pwch is first character.
						TWB_IsCharWordDelimW(*(pwch - 1))   )  // if previous character is delimiter.
					{
						pBreakPos[iBreakIndex++] = 1;
						dirCurrent = MERGE_RIGHT;
					}
					else
					{
						pBreakPos[iBreakIndex - 1]++;
						dirCurrent = MERGE_LEFT;
					}
					break;
				case MERGE_LEFT:
				default:
					if (iBreakIndex == 0)
						if (pwch == wzString)
							pBreakPos[iBreakIndex++] = 1;
						else
							pBreakPos[iBreakIndex]++;
					else
						pBreakPos[iBreakIndex - 1]++;
					break;
				}
				dirPrevious = dirCurrent; 
				pwch++;
                pwszRunStart = pwch;
			}

			assert(pwszRunStart == pwch);

		    if( iBreakIndex >= iBreakMax || pwch >= pwszMax)
			    break;

            // Detect if this is a Thai Run.
		    fThaiRun = IsThaiChar(*pwch);
		    do
            {
                pwch++;
			    iRunCount++;
            } while ((IsThaiChar(*pwch)==fThaiRun    &&
                     iRunCount < (MAXBREAK - 2)      &&
                     *pwch                           &&
                     !TWB_IsCharWordDelimW(*pwch)    &&
                     (pwch < pwszMax)                )  ||
					 ( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));

            if (fThaiRun)
            {
				unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
				for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
				{
					// First Thai character of the run.
					if (dirPrevious == MERGE_RIGHT)
					{
						assert(iBreakIndex != 0);
						pBreakPos[iBreakIndex - 1] += breakTree->breakArray[i];
					}
					else
						pBreakPos[iBreakIndex++] = breakTree->breakArray[i];

					dirPrevious = NO_MERGE;

				}
            }
		    else
            {
                // Not a Thai Run simply put the whole thing in the break array.
                assert(pwch > pwszRunStart);        // pwch must be greater than pwszRunStart, since we just walk.
				if (dirPrevious == MERGE_RIGHT)
				{
					assert(iBreakIndex != 0);
					pBreakPos[iBreakIndex - 1] += (BYTE) (pwch - pwszRunStart);
				}
				else
					pBreakPos[iBreakIndex++] = (BYTE) (pwch - pwszRunStart);
            }
            iRunCount = 0;
            pwszRunStart = pwch;

        // Make sure we haven't pass iBreakMax define by user else return whatever we got.
        } while(iBreakIndex < iBreakMax && pwch < pwszMax);
        break;
    case WB_INDEX:
		// Make sure argument is the same.
		assert(pThwb_Struct != NULL);
		if (pThwb_Struct == NULL)
			return 0;
    	do
        {
		    while (TWB_IsCharWordDelimW(*pwch) && pwszMax > pwch)
		        pwch++;

		    if( pwszRunStart < pwch)
            {
                pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
                pwszRunStart = pwch;
            }

		    if( iBreakIndex >= iBreakMax || pwch >= pwszMax)
			    break;

            // Detect if this is a Thai Run.
		    fThaiRun = IsThaiChar(*pwch); //TODO: Add comma and period to Thai range.
		    do
            {
                pwch++;
			    iRunCount++;
            } while ((IsThaiChar(*pwch)==fThaiRun    &&
                     iRunCount < (MAXBREAK - 2)      &&
                     *pwch                           &&
                     !TWB_IsCharWordDelimW(*pwch)    &&
                     (pwch < pwszMax)                )  ||

					 ( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));

            if (fThaiRun)
            {
				unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
				for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
				{
					pThwb_Struct[iBreakIndex].fThai = true;
					pThwb_Struct[iBreakIndex].alt = ExtractALT(breakTree->tagArray[i]);
					pBreakPos[iBreakIndex++] = breakTree->breakArray[i];
				}
            }
		    else
            {
                // Not a Thai Run simply put the whole thing in the break array.
                assert(pwch > pwszRunStart);        // pwch must be greater than pwszRunStart, since we just walk.
				pThwb_Struct[iBreakIndex].fThai = false;
				pThwb_Struct[iBreakIndex].alt = 0;
                pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
            }
            iRunCount = 0;
            pwszRunStart = pwch;

        // Make sure we haven't pass iBreakMax define by user else return whatever we got.
        } while(iBreakIndex < iBreakMax && pwch < pwszMax);
		break;
    case WB_CARETBREAK:
		fSpaceMergeRight = true;
    case WB_NORMAL:
    default: 
    	do
        {
		    while (TWB_IsCharWordDelimW(*pwch) && pwszMax > pwch)
		        pwch++;

		    if( pwszRunStart < pwch)
            {
				if (fSpaceMergeRight && *pwszRunStart == L' ' && iBreakIndex > 0)
					// This is a caret movement features, should merge space to
					// the right words.
					pBreakPos[iBreakIndex - 1] += (BYTE)(pwch - pwszRunStart);
				else
					pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
                pwszRunStart = pwch;
            }

		    if( iBreakIndex >= iBreakMax || pwch >= pwszMax)
			    break;

            // Detect if this is a Thai Run.
		    fThaiRun = IsThaiChar(*pwch); //TODO: Add comma and period to Thai range.
		    do
            {
                pwch++;
			    iRunCount++;
            } while ((IsThaiChar(*pwch)==fThaiRun    &&
                     iRunCount < (MAXBREAK - 2)      &&
                     *pwch                           &&
                     !TWB_IsCharWordDelimW(*pwch)    &&
                     (pwch < pwszMax)                )  ||
					 ( ( *pwch == 0x2c || *pwch == 0x2e) && (iRunCount < (MAXBREAK - 2)) && (pwch < pwszMax) ));

            if (fThaiRun)
            {
#if defined (NGRAM_ENABLE)
                if (!fFastWordBreak)
                {
                    if (WordBreak(pwszRunStart,pwch))
                        for (i=0; i < breakTree.maxToken && iBreakIndex <iBreakMax; i++)
                            pBreakPos[iBreakIndex++] = breakTree->maximalMatchingBreakArray[i];
                }
                else
                {
                    unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
                    for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
                        pBreakPos[iBreakIndex++] = breakTree->breakArray[i];
                }
#else
				unsigned int iBreak = breakTree->TrigramBreak(pwszRunStart,pwch);
				for (i=0; i < iBreak && iBreakIndex <iBreakMax; i++)
					pBreakPos[iBreakIndex++] = breakTree->breakArray[i];
#endif
            }
		    else
            {
                // Not a Thai Run simply put the whole thing in the break array.
                assert(pwch > pwszRunStart);        // pwch must be greater than pwszRunStart, since we just walk.
                pBreakPos[iBreakIndex++] = (BYTE)(pwch - pwszRunStart);
            }
            iRunCount = 0;
            pwszRunStart = pwch;

        // Make sure we haven't pass iBreakMax define by user else return whatever we got.
        } while(iBreakIndex < iBreakMax && pwch < pwszMax);
        break;
    }

#if defined (_DEBUG)
	unsigned int iTotalChar = 0;
	for (i = 0; i < iBreakIndex; i++)
	{
		iTotalChar += pBreakPos[i];
	}
	if (iBreakIndex < iBreakMax)
		assert(iStringLen == iTotalChar);
#endif

	return iBreakIndex;
}

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
BOOL CThaiWordBreak::WordBreak(WCHAR* pszBegin, WCHAR* pszEnd)
{
    // Declare and Initialize all local variables.
    bool fWordEnd = false;
	bool fCorrectPath = false;
    WCHAR* pszIndex = pszBegin;
    int iNumCluster = 1;

    assert(pszBegin < pszEnd);          // Make sure pszEnd is at least greater pszBegin.

    breakTree.GenerateTree(pszBegin, pszEnd);
    breakTree.MaximalMatching();

   	return (breakTree.maxToken > 0);

}
#endif

//+---------------------------------------------------------------------------
//
//  Class:   CThaiWordBreak
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CThaiWordBreak::Find(WCHAR* wzString, DWORD* pdwPOS)
{
    return m_trie.Find(wzString, pdwPOS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\ctrie.hpp ===
//+---------------------------------------------------------------------------
//
//
//  CTrie - class CTrie encapsulation for Trie data structure.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _CTRIE_H_
#define _CTRIE_H_

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
#include "NLGlib.h"
#include "ProofBase.h"
#include "thwbdef.hpp"

#define lidThai 0x41e
#define lidViet 0x42a

// 1111 0000 0000 0000 0000 0000 0000 0000   -- Alt Mask
// 0000 1111 1111 1111 1111 0000 0000 0000   -- Pos Mas

const int iDialectMask = 1;
const int iRestrictedMask = 16;
const int iPosMask = 268431360;   // 0x0FFFF000
const int iAltMask = 4026531840;  // 0xF0000000
const int iFrqShift = 8;
const int iPosShift = 12;
const int iAltShift = 28;

class CTrie;

class CTrieIter {
public:
	// Initialization functions.
	CTrieIter();
    CTrieIter(const CTrieIter& trieIter);
	virtual void Init(CTrie*);
	virtual void Init(TRIECTRL*);

	// Interation functions.
	virtual void Reset();
	virtual BOOL Down();
	virtual BOOL Right();
	virtual void GetNode();

	// Local variables.
	WCHAR wc;
	BOOL fWordEnd;
	BOOL fRestricted;
	BYTE frq;
	DWORD posTag;
    DWORD dwTag;        // Uncompress word tags.
protected:
	//Trie
	TRIECTRL* pTrieCtrl;

	// Trie Iterator.
	TRIESCAN trieScan;
};

class CTrie {
	friend class CTrieIter;
public:
	CTrie();
	~CTrie();

	static PTEC retcode(int mjr, int mnr) { return MAKELONG(mjr, mnr); }


	PTEC Init(WCHAR* szFileName);
	PTEC InitRc(LPBYTE);
	void UnInit();
	BOOL Find(WCHAR* szWord, DWORD* pdwPOS);

protected:
	PMFILE pMapFile;
	TRIECTRL *pTrieCtrl;
//	CTrieIter trieScan;
	CTrieIter* pTrieScan;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\ctrie.cpp ===
//+---------------------------------------------------------------------------
//
//
//  CTrie - class CTrie encapsulation for Trie data structure.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "ctrie.hpp"

#define VERSIONMAJOR 1
#define VERSIONMINOR 0

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrieIter::CTrieIter()
{
	// Initialize local variables.
	Reset();
	wc = 0;
	fWordEnd = FALSE;
	fRestricted = FALSE;
	frq = 0;
    dwTag = 0;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   copy constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrieIter::CTrieIter(const CTrieIter& trieIter)
{
	// Copy all variables from Initial trie.
   	memcpy(&trieScan, &trieIter.trieScan, sizeof(TRIESCAN));
	pTrieCtrl = trieIter.pTrieCtrl;
    wc = trieIter.wc;
	fWordEnd = trieIter.fWordEnd;
	fRestricted = trieIter.fRestricted;
	frq = trieIter.frq;
    dwTag = trieIter.dwTag;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::Init(CTrie* ctrie)
{
	// Initialize TrieCtrl
	pTrieCtrl = ctrie->pTrieCtrl;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Initialize variables.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::Init(TRIECTRL* pTrieCtrl1)
{
	// Initialize TrieCtrl
	pTrieCtrl = pTrieCtrl1;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::Reset()
{
	// Reset Trie.
	memset(&trieScan, 0, sizeof(TRIESCAN));
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Move Iteration index down one node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTrieIter::Down()
{
	// Move the Trie down one node.
	return TrieGetNextState(pTrieCtrl, &trieScan);
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Move Iteration index right one node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTrieIter::Right()
{
	// Move the Trie right one node.
	return TrieGetNextNode(pTrieCtrl, &trieScan);
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrieIter
//
//  Synopsis:   Bring interation index to the first node.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrieIter::GetNode()
{
	wc = trieScan.wch;
	fWordEnd = (trieScan.wFlags & TRIE_NODE_VALID) &&
				(!(trieScan.wFlags & TRIE_NODE_TAGGED) ||
				(trieScan.aTags[0].dwData & iDialectMask));

	if (fWordEnd)
	{
		fRestricted = (trieScan.wFlags & TRIE_NODE_TAGGED) &&
						(trieScan.aTags[0].dwData & iRestrictedMask);
		frq = (BYTE) (trieScan.wFlags & TRIE_NODE_TAGGED ?
						(trieScan.aTags[0].dwData & 0x300) >> iFrqShift :
						frqpenNormal);

		posTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
							(trieScan.aTags[0].dwData & iPosMask) >> iPosShift :
							0);

        dwTag = (DWORD) (trieScan.wFlags & TRIE_NODE_TAGGED ?
                            trieScan.aTags[0].dwData :
                            0);
	}
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrie::CTrie()
{
	pMapFile = NULL;
	pTrieCtrl = NULL;
	pTrieScan = NULL;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
CTrie::~CTrie()
{
	UnInit();
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Initialize Trie.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC CTrie::Init(WCHAR* szFileName)
{
	// Declare and Initialize all local variables.
    PTEC ptec = ptecModuleError;

	// The function assume that pMapFile and pTrieCtrl is NULL, else there are possible memory leak.
	// possibility of this could be call Initilization without Terminating.
	assert(pMapFile == NULL);
	assert(pTrieCtrl == NULL);

	// Initialize pMapFile and pTrieCtrl to NULL.		
    pMapFile = NULL;
	pTrieCtrl = NULL;

	pMapFile = OpenMapFileW(szFileName);

    if (pMapFile == NULL)
	{
		// Unable to load map files, return invalid read error.
        ptec = retcode(ptecIOErrorMainLex, ptecFileRead);
	}
	else if (pMapFile->pvMap == NULL)
	{
		// Return Invalid format and close the files.
        ptec = retcode(ptecIOErrorMainLex, ptecInvalidFormat);
        CloseMapFile(pMapFile);
	}
	else
	{
        BYTE *pmap = (BYTE *) pMapFile->pvMap;

        // find the header
        LEXHEADER *plxhead = (LEXHEADER *) pmap;
        pmap += sizeof(LEXHEADER);

          // verify that it's a valid lex file
        if (!(plxhead->lxid == lxidSpeller && plxhead->vendorid == vendoridMicrosoft &&
              PROOFMAJORVERSION(plxhead->version) == VERSIONMAJOR ))
        {
			// If we reached here than the lexicon is no in a valid Thai wordbreak format.
            ptec = retcode(ptecIOErrorMainLex, ptecInvalidFormat);
        }
		else
		{
            // Make sure the language matches check the first dialect of the lexicon.
			// CTrie also support both Thai and Vietnamese language.
			if ( (plxhead->lidArray[0] != lidThai) && (plxhead->lidArray[0] != lidViet) )
			{
				// If we reached here than we are not using Thai lexicon.
                ptec = retcode(ptecIOErrorMainLex, ptecInvalidLanguage);
            }
            else
            {
				// The size of the copyright notice
                int cCopyright = 0;
				WCHAR* pwzCopyright = NULL;
				int cLexSup = 0;

				cCopyright = * (int *) pmap;
                pmap += sizeof(int);

				// The copyright notice itself
                pwzCopyright = (WCHAR *) pmap;
                pmap += cCopyright * sizeof(WCHAR);

                // Skip Supplemental data for Thai word break.
				cLexSup = * (int *) pmap;
                pmap += sizeof(int);
                pmap += cLexSup;

                pTrieCtrl = TrieInit(pmap);
                if (pTrieCtrl)
				{
					// We were able to load and point to the Trie okay.
					//MessageBoxW(0,L"Was able to initialize Trie",pwsz,MB_OK);
					pTrieScan = new CTrieIter();
					pTrieScan->Init(this);
					ptec = ptecNoErrors;
				}
				else
				{
					// We were not able to initailize main lexicon.
	                ptec = retcode(ptecIOErrorMainLex, ptecInvalidMainLex);
				}
			}
		}
	}

	return ptec;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   Initialize Trie.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 2/2000 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC CTrie::InitRc(LPBYTE pmap)
{
	// Declare and Initialize all local variables.
    PTEC ptec = ptecModuleError;

	// The function assume that pMapFile and pTrieCtrl is NULL, else there are possible memory leak.
	// possibility of this could be call Initilization without Terminating.
	assert(pMapFile == NULL);
	assert(pTrieCtrl == NULL);
	assert(pTrieScan == NULL);

	// Initialize pMapFile and pTrieCtrl to NULL.		
    pMapFile = NULL;
	pTrieCtrl = NULL;
	pTrieScan = NULL;

    LEXHEADER *plxhead = (LEXHEADER *) pmap;
    pmap += sizeof(LEXHEADER);

	// The size of the copyright notice
    int cCopyright = 0;
	WCHAR* pwzCopyright = NULL;
	int cLexSup = 0;

	cCopyright = * (int *) pmap;
    pmap += sizeof(int);

	// The copyright notice itself
    pwzCopyright = (WCHAR *) pmap;
    pmap += cCopyright * sizeof(WCHAR);

    // Skip Supplemental data for Thai word break.
	cLexSup = * (int *) pmap;
    pmap += sizeof(int);
    pmap += cLexSup;

    pTrieCtrl = TrieInit(pmap);
    if (pTrieCtrl)
	{
		// We were able to load and point to the Trie okay.
		//MessageBoxW(0,L"Was able to initialize Trie",L"ThWB",MB_OK);
		pTrieScan = new CTrieIter();
		pTrieScan->Init(this);
		ptec = ptecNoErrors;
	}
	else
	{
		// We were not able to initailize main lexicon.
	    ptec = retcode(ptecIOErrorMainLex, ptecInvalidMainLex);
	}

	return ptec;
}

//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   UnInitialize Trie.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTrie::UnInit()
{
	// Free up memory allocated by Trie.
	if (pTrieCtrl)
	{
		TrieFree(pTrieCtrl);
		pTrieCtrl = NULL;
	}

	// Close the map files.
	if (pMapFile)
	{
        CloseMapFile(pMapFile);
		pMapFile = NULL;
	}

	if (pTrieScan)
	{
		delete pTrieScan;
		pTrieScan = NULL;
	}

}


//+---------------------------------------------------------------------------
//
//  Class:   CTrie
//
//  Synopsis:   searches for the given string in the trie
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTrie::Find(WCHAR* szWord, DWORD* pdwPOS)
{
	// Declare and initialize all local variables.
	int i = 0;

	if (pTrieScan == NULL)
		return FALSE;

	pTrieScan->Reset();

	if (!pTrieScan->Down())
		return FALSE;

	while (TRUE)
	{
		pTrieScan->GetNode();
		if (pTrieScan->wc == szWord[i])
		{
			i++;
			if (pTrieScan->fWordEnd && szWord[i] == '\0')
            {
                *pdwPOS = pTrieScan->posTag;
				return TRUE;
            }
			else if (szWord[i] == '\0') break;
			// Move down the Trie Branch.
			else if (!pTrieScan->Down()) break;
		}
		// Move right of the Trie Branch
		else if (!pTrieScan->Right()) break;
	}
    *pdwPOS = POS_UNKNOWN;
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\debug.c ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       Debug.cpp
//
//  Contents:   Debug code.
//
//  History:    05-Apr-94   v-kentc     Created.
//
//---------------------------------------------------------------------------

#include "precomp.h"
#include <assert.h>

int __cdecl _purecall()
{
    AssertSz(FALSE, TEXT("'__purecall called'"));
    return 0;
}

#ifdef _DEBUG

static DWORD fAssertFlags = AssertDefaultBehavior;
static FILE *pAssertFile;

void WINAPI SetAssertOptions(DWORD dwNewOptions)
{
    fAssertFlags = dwNewOptions;
}

static void
OpenAssertFile()
{
    // REVIEW - do we want a unicode file name? If so
    // pAssertFile = _wfopen(L"asserts.txt", L"a");
    pAssertFile = fopen("asserts.txt", "a");
    if (NULL != pAssertFile)
        fflush(pAssertFile);
}

void WINAPI DebugAssert(LPCTSTR pText, LPCTSTR pFile, UINT uLineNo)
{
    TCHAR buf[256];

    if (bAssertWriteToFile() || bAssertShowAlert())
    {
        if (pText)
            wsprintf(buf, TEXT("Assert %ws in file %ws - line %d"), pText, pFile, uLineNo);
        else
            wsprintf(buf, TEXT("Assert in file %ws - line %d"), pFile, uLineNo);
    }

    if (bAssertWriteToFile())
    {
        if (NULL == pAssertFile)
            OpenAssertFile();

        if (NULL != pAssertFile)
        {
            fwprintf(pAssertFile, buf);
            fflush(pAssertFile);
        }
    }

    if (bAssertShowAlert())
    {
         MessageBox(NULL, buf, TEXT("THammer"), MB_SETFOREGROUND | MB_OK);
    }

    if (bAssertUseVCAssert())
    {
       _assert((PVOID)pText, (PVOID)pFile, uLineNo);
    }

    if (bAssertCallDebugger())
    {
        DebugBreak();
    }

    if (bAssertExit())
    {
        if (pAssertFile)
            fclose(pAssertFile);
        exit(EXIT_FAILURE);
    }
}

#endif // !_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\lexheader.h ===
/****************************************************
*** lexheader.h

structure to head proofing tool lex files

DougP
-------------
The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1998 Microsoft Corporation.  All rights reserved.
******************************************************************************/
#ifndef _LEXHEADER_H_
#define _LEXHEADER_H_

#include "vendor.h"

typedef DWORD LEXVERSION; // version

typedef enum
{
    lxidSpeller=0x779ff320,
    lxidThesaurus,
    lxidHyphenator,
    lxidGrammar,
    lxidMorphology,
    lxidLanguageId,
} LEXTYPEID;    // lxid

#define maxlidLexHeader 8
typedef struct
{
    LEXTYPEID   lxid;   // should be one of Lex...
    LEXVERSION  version;    // minimum version number of corresponding engine w/
                        // build number of THIS lex file
    VENDORID    vendorid;   // vendor id (must match engine - from vendor.h)
    LANGID      lidArray[maxlidLexHeader];  // LID's for this lex
                                        // terminate w/ 0
} LEXHEADER;    // lxhead

// The following enumeration was copied from lexdata.h -- aarayas
typedef short FREQPENALTY;    //frqpen
enum {
    frqpenNormal,
    frqpenVery,
    frqpenSomewhat,
    frqpenInfrequent,
    frqpenMax,  // needs to be last
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\misc.h ===
/* Simple but direct hash function that hashes across several bits by
multiplying by the greatest prime less than bits**2 and masking off the excess. */


extern WCHAR g_szLogLine[];
extern BOOL g_bEnvStrings;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\lexicon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 5/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "lexheader.h"
#include "trie.h"
#include "NLGlib.h"
#include "ProofBase.h"

class Lexicon
{
public:
	Lexicon(WCHAR* szFileName);
	~Lexicon();
protected:
	PMFILE pMapFile;
	TRIECTRL *pTrieCtrl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\lextable.hpp ===
//+---------------------------------------------------------------------------
//
//
//  Lextable.hpp
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _LEXTABLE_HPP_
#define _LEXTABLE_HPP_
#include <windows.h>

/*************************************************
    Lexical Table definition
*************************************************/
#define Lex_UpperFlag             0x01         /* upper case */
#define Lex_LowerFlag             0x02         /* lower case */
#define Lex_DigitFlag             0x04         /* decimal digits */
#define Lex_SpaceFlag             0x08         /* spacing characters */
#define Lex_PunctFlag             0x10         /* punctuation characters */
#define Lex_ControlFlag             0x20         /* control characters */
#define Lex_LexiconFlag 0x40
#define Lex_VowelFlag 0x80
#define NTRANSTAB 256

#define INUPPERPAGES(ch) (ch & 0xff00)  // this is the same as ch > 0x00ff

/*************************************************
    Lexical Table
*************************************************/
const BYTE rgFlags[NTRANSTAB] =
{
	0x00, // 00        
	0x20, // 01        
	0x20, // 02        
	0x20, // 03        
	0x20, // 04        
	0x20, // 05        
	0x20, // 06        
	0x20, // 07        
	0x20, // 08        
	0x28, // 09    X   
	0x28, // 0a    X   
	0x28, // 0b    X   
	0x28, // 0c    X   
	0x28, // 0d    X   
	0x20, // 0e        
	0x20, // 0f        
	0x20, // 10        
	0x20, // 11        
	0x20, // 12        
	0x20, // 13        
	0x20, // 14        
	0x20, // 15        
	0x20, // 16        
	0x20, // 17        
	0x20, // 18        
	0x20, // 19        
	0x20, // 1a        
	0x20, // 1b        
	0x20, // 1c        
	0x20, // 1d        
	0x20, // 1e        
	0x20, // 1f        
	0x08, // 20    X   
	0x10, // 21     P   (!)
	0x10, // 22     P   (")
	0x10, // 23     P   (#)
	0x10, // 24     P   ($)
	0x10, // 25     P   (%)
	0x10, // 26     P   (&)
	0x50, // 27     PE  (')
	0x10, // 28     P   (()
	0x10, // 29     P   ())
	0x10, // 2a     P   (*)
	0x10, // 2b     P   (+)
	0x10, // 2c     P   (,)
	0x50, // 2d     PE  (-)
	0x50, // 2e     PE  (.)
	0x50, // 2f     PE  (/)
	0x44, // 30   D  E  (0)
	0x44, // 31   D  E  (1)
	0x44, // 32   D  E  (2)
	0x44, // 33   D  E  (3)
	0x44, // 34   D  E  (4)
	0x44, // 35   D  E  (5)
	0x44, // 36   D  E  (6)
	0x44, // 37   D  E  (7)
	0x44, // 38   D  E  (8)
	0x44, // 39   D  E  (9)
	0x10, // 3a     P   (:)
	0x10, // 3b     P   (;)
	0x10, // 3c     P   (<)
	0x10, // 3d     P   (=)
	0x10, // 3e     P   (>)
	0x10, // 3f     P   (?)
	0x10, // 40     P   (@)
	0xc1, // 41 U    EV (A)
	0x41, // 42 U    E  (B)
	0x41, // 43 U    E  (C)
	0x41, // 44 U    E  (D)
	0xc1, // 45 U    EV (E)
	0x41, // 46 U    E  (F)
	0x41, // 47 U    E  (G)
	0x41, // 48 U    E  (H)
	0xc1, // 49 U    EV (I)
	0x41, // 4a U    E  (J)
	0x41, // 4b U    E  (K)
	0x41, // 4c U    E  (L)
	0x41, // 4d U    E  (M)
	0x41, // 4e U    E  (N)
	0xc1, // 4f U    EV (O)
	0x41, // 50 U    E  (P)
	0x41, // 51 U    E  (Q)
	0x41, // 52 U    E  (R)
	0x41, // 53 U    E  (S)
	0x41, // 54 U    E  (T)
	0xc1, // 55 U    EV (U)
	0x41, // 56 U    E  (V)
	0x41, // 57 U    E  (W)
	0x41, // 58 U    E  (X)
	0x41, // 59 U    E  (Y)
	0x41, // 5a U    E  (Z)
	0x10, // 5b     P   ([)
	0x10, // 5c     P   (\)
	0x10, // 5d     P   (])
	0x10, // 5e     P   (^)
	0x10, // 5f     P   (_)
	0x10, // 60     P   (`)
	0xc2, // 61  L   EV (a)
	0x42, // 62  L   E  (b)
	0x42, // 63  L   E  (c)
	0x42, // 64  L   E  (d)
	0xc2, // 65  L   EV (e)
	0x42, // 66  L   E  (f)
	0x42, // 67  L   E  (g)
	0x42, // 68  L   E  (h)
	0xc2, // 69  L   EV (i)
	0x42, // 6a  L   E  (j)
	0x42, // 6b  L   E  (k)
	0x42, // 6c  L   E  (l)
	0x42, // 6d  L   E  (m)
	0x42, // 6e  L   E  (n)
	0xc2, // 6f  L   EV (o)
	0x42, // 70  L   E  (p)
	0x42, // 71  L   E  (q)
	0x42, // 72  L   E  (r)
	0x42, // 73  L   E  (s)
	0x42, // 74  L   E  (t)
	0xc2, // 75  L   EV (u)
	0x42, // 76  L   E  (v)
	0x42, // 77  L   E  (w)
	0x42, // 78  L   E  (x)
	0x42, // 79  L   E  (y)
	0x42, // 7a  L   E  (z)
	0x10, // 7b     P   ({)
	0x10, // 7c     P   (|)
	0x10, // 7d     P   (})
	0x10, // 7e     P   (~)
	0x20, // 7f         ()
	0x10, // 80     P   ()
	0x20, // 81         ()
	0x20, // 82         ()
	0x20, // 83         ()
	0x20, // 84         ()
	0x20, // 85         ()
	0x20, // 86         ()
	0x20, // 87         ()
	0x20, // 88         ()
	0x20, // 89         ()
	0x20, // 8a         ()
	0x20, // 8b         ()
	0x20, // 8c         ()
	0x20, // 8d         ()
	0x20, // 8e         ()
	0x20, // 8f         ()
	0x20, // 90         ()
	0x20, // 91         ()
	0x20, // 92         ()
	0x20, // 93         ()
	0x20, // 94         ()
	0x20, // 95         ()
	0x20, // 96         ()
	0x20, // 97         ()
	0x20, // 98         ()
	0x20, // 99         ()
	0x20, // 9a         ()
	0x20, // 9b         ()
	0x20, // 9c         ()
	0x20, // 9d         ()
	0x20, // 9e         ()
	0x20, // 9f         ()
	0x08, // a0    X    ()
	0x10, // a1     P   ()
	0x10, // a2     P   ()
	0x10, // a3     P   ()
	0x10, // a4     P   ()
	0x10, // a5     P   ()
	0x10, // a6     P   ()
	0x10, // a7     P   ()
	0x10, // a8     P   ()
	0x10, // a9     P   ()
	0x10, // aa     P   ()
	0x10, // ab     P   ()
	0x10, // ac     P   ()
	0x10, // ad     P   ()
	0x10, // ae     P   ()
	0x10, // af     P   ()
	0x10, // b0     P   ()
	0x10, // b1     P   ()
	0x54, // b2   D PE  ()
	0x54, // b3   D PE  ()
	0x10, // b4     P   ()
	0x10, // b5     P   ()
	0x10, // b6     P   ()
	0x10, // b7     P   ()
	0x10, // b8     P   ()
	0x54, // b9   D PE  ()
	0x10, // ba     P   ()
	0x10, // bb     P   ()
	0x54, // bc   D PE  ()
	0x54, // bd   D PE  ()
	0x54, // be   D PE  ()
	0x10, // bf     P   ()
	0xc1, // c0 U    EV ()
	0xc1, // c1 U    EV ()
	0xc1, // c2 U    EV ()
	0xc1, // c3 U    EV ()
	0xc1, // c4 U    EV ()
	0xc1, // c5 U    EV ()
	0x41, // c6 U    E  ()
	0x41, // c7 U    E  ()
	0xc1, // c8 U    EV ()
	0xc1, // c9 U    EV ()
	0xc1, // ca U    EV ()
	0xc1, // cb U    EV ()
	0xc1, // cc U    EV ()
	0xc1, // cd U    EV ()
	0xc1, // ce U    EV ()
	0xc1, // cf U    EV ()
	0x41, // d0 U    E  ()
	0x41, // d1 U    E  ()
	0xc1, // d2 U    EV ()
	0xc1, // d3 U    EV ()
	0xc1, // d4 U    EV ()
	0xc1, // d5 U    EV ()
	0xc1, // d6 U    EV ()
	0x10, // d7     P   ()
	0xc1, // d8 U    EV ()
	0xc1, // d9 U    EV ()
	0xc1, // da U    EV ()
	0xc1, // db U    EV ()
	0xc1, // dc U    EV ()
	0x41, // dd U    E  ()
	0x41, // de U    E  ()
	0x42, // df  L   E  ()
	0xc2, // e0  L   EV ()
	0xc2, // e1  L   EV ()
	0xc2, // e2  L   EV ()
	0xc2, // e3  L   EV ()
	0xc2, // e4  L   EV ()
	0xc2, // e5  L   EV ()
	0x42, // e6  L   E  ()
	0x42, // e7  L   E  ()
	0xc2, // e8  L   EV ()
	0xc2, // e9  L   EV ()
	0xc2, // ea  L   EV ()
	0xc2, // eb  L   EV ()
	0xc2, // ec  L   EV ()
	0xc2, // ed  L   EV ()
	0xc2, // ee  L   EV ()
	0xc2, // ef  L   EV ()
	0x42, // f0  L   E  ()
	0x42, // f1  L   E  ()
	0xc2, // f2  L   EV ()
	0xc2, // f3  L   EV ()
	0xc2, // f4  L   EV ()
	0xc2, // f5  L   EV ()
	0xc2, // f6  L   EV ()
	0x10, // f7     P   ()
	0xc2, // f8  L   EV ()
	0xc2, // f9  L   EV ()
	0xc2, // fa  L   EV ()
	0xc2, // fb  L   EV ()
	0xc2, // fc  L   EV ()
	0x42, // fd  L   E  ()
	0x42, // fe  L   E  ()
	0x42, // ff  L   E  ()
};

const BYTE rgPunctFlags[NTRANSTAB] =
{
	0x00, // 00     
	0x00, // 01     
	0x00, // 02     
	0x00, // 03     
	0x00, // 04     
	0x00, // 05     
	0x00, // 06     
	0x00, // 07     
	0x00, // 08     
	0x08, // 09    W
	0x08, // 0a    W
	0x08, // 0b    W
	0x08, // 0c    W
	0x08, // 0d    W
	0x00, // 0e     
	0x00, // 0f     
	0x00, // 10     
	0x00, // 11     
	0x00, // 12     
	0x00, // 13     
	0x00, // 14     
	0x00, // 15     
	0x00, // 16     
	0x00, // 17     
	0x00, // 18     
	0x00, // 19     
	0x00, // 1a     
	0x00, // 1b     
	0x00, // 1c     
	0x00, // 1d     
	0x00, // 1e     
	0x00, // 1f     
	0x08, // 20    W
	0x04, // 21   T  (!)
	0x05, // 22 L T  (")
	0x01, // 23 L    (#)
	0x01, // 24 L    ($)
	0x04, // 25   T  (%)
	0x00, // 26      (&)
	0x05, // 27 L T  (')
	0x01, // 28 L    (()
	0x04, // 29   T  ())
	0x08, // 2a    W (*)
	0x00, // 2b      (+)
	0x04, // 2c   T  (,)
	0x02, // 2d  J   (-)
	0x04, // 2e   T  (.)
	0x02, // 2f  J   (/)
	0x00, // 30      (0)
	0x00, // 31      (1)
	0x00, // 32      (2)
	0x00, // 33      (3)
	0x00, // 34      (4)
	0x00, // 35      (5)
	0x00, // 36      (6)
	0x00, // 37      (7)
	0x00, // 38      (8)
	0x00, // 39      (9)
	0x04, // 3a   T  (:)
	0x04, // 3b   T  (;)
	0x09, // 3c L  W (<)
	0x08, // 3d    W (=)
	0x0c, // 3e   TW (>)
	0x04, // 3f   T  (?)
	0x02, // 40  J   (@)
	0x00, // 41      (A)
	0x00, // 42      (B)
	0x00, // 43      (C)
	0x00, // 44      (D)
	0x00, // 45      (E)
	0x00, // 46      (F)
	0x00, // 47      (G)
	0x00, // 48      (H)
	0x00, // 49      (I)
	0x00, // 4a      (J)
	0x00, // 4b      (K)
	0x00, // 4c      (L)
	0x00, // 4d      (M)
	0x00, // 4e      (N)
	0x00, // 4f      (O)
	0x00, // 50      (P)
	0x00, // 51      (Q)
	0x00, // 52      (R)
	0x00, // 53      (S)
	0x00, // 54      (T)
	0x00, // 55      (U)
	0x00, // 56      (V)
	0x00, // 57      (W)
	0x00, // 58      (X)
	0x00, // 59      (Y)
	0x00, // 5a      (Z)
	0x01, // 5b L    ([)
	0x02, // 5c  J   (\)
	0x04, // 5d   T  (])
	0x00, // 5e      (^)
	0x00, // 5f      (_)
	0x00, // 60      (`)
	0x00, // 61      (a)
	0x00, // 62      (b)
	0x00, // 63      (c)
	0x00, // 64      (d)
	0x00, // 65      (e)
	0x00, // 66      (f)
	0x00, // 67      (g)
	0x00, // 68      (h)
	0x00, // 69      (i)
	0x00, // 6a      (j)
	0x00, // 6b      (k)
	0x00, // 6c      (l)
	0x00, // 6d      (m)
	0x00, // 6e      (n)
	0x00, // 6f      (o)
	0x00, // 70      (p)
	0x00, // 71      (q)
	0x00, // 72      (r)
	0x00, // 73      (s)
	0x00, // 74      (t)
	0x00, // 75      (u)
	0x00, // 76      (v)
	0x00, // 77      (w)
	0x00, // 78      (x)
	0x00, // 79      (y)
	0x00, // 7a      (z)
	0x01, // 7b L    ({)
	0x00, // 7c      (|)
	0x04, // 7d   T  (})
	0x00, // 7e      (~)
	0x00, // 7f      ()
	0x01, // 80 L    ()
	0x00, // 81      ()
	0x00, // 82      ()
	0x00, // 83      ()
	0x00, // 84      ()
	0x00, // 85      ()
	0x00, // 86      ()
	0x00, // 87      ()
	0x00, // 88      ()
	0x00, // 89      ()
	0x00, // 8a      ()
	0x00, // 8b      ()
	0x00, // 8c      ()
	0x00, // 8d      ()
	0x00, // 8e      ()
	0x00, // 8f      ()
	0x00, // 90      ()
	0x00, // 91      ()
	0x00, // 92      ()
	0x00, // 93      ()
	0x00, // 94      ()
	0x00, // 95      ()
	0x00, // 96      ()
	0x00, // 97      ()
	0x00, // 98      ()
	0x00, // 99      ()
	0x00, // 9a      ()
	0x00, // 9b      ()
	0x00, // 9c      ()
	0x00, // 9d      ()
	0x00, // 9e      ()
	0x00, // 9f      ()
	0x08, // a0    W ()
	0x00, // a1      ()
	0x00, // a2      ()
	0x00, // a3      ()
	0x00, // a4      ()
	0x00, // a5      ()
	0x00, // a6      ()
	0x00, // a7      ()
	0x00, // a8      ()
	0x00, // a9      ()
	0x00, // aa      ()
	0x00, // ab      ()
	0x00, // ac      ()
	0x00, // ad      ()
	0x00, // ae      ()
	0x00, // af      ()
	0x00, // b0      ()
	0x00, // b1      ()
	0x00, // b2      ()
	0x00, // b3      ()
	0x00, // b4      ()
	0x00, // b5      ()
	0x00, // b6      ()
	0x00, // b7      ()
	0x00, // b8      ()
	0x00, // b9      ()
	0x00, // ba      ()
	0x00, // bb      ()
	0x00, // bc      ()
	0x00, // bd      ()
	0x00, // be      ()
	0x00, // bf      ()
	0x00, // c0      ()
	0x00, // c1      ()
	0x00, // c2      ()
	0x00, // c3      ()
	0x00, // c4      ()
	0x00, // c5      ()
	0x00, // c6      ()
	0x00, // c7      ()
	0x00, // c8      ()
	0x00, // c9      ()
	0x00, // ca      ()
	0x00, // cb      ()
	0x00, // cc      ()
	0x00, // cd      ()
	0x00, // ce      ()
	0x00, // cf      ()
	0x00, // d0      ()
	0x00, // d1      ()
	0x00, // d2      ()
	0x00, // d3      ()
	0x00, // d4      ()
	0x00, // d5      ()
	0x00, // d6      ()
	0x00, // d7      ()
	0x00, // d8      ()
	0x00, // d9      ()
	0x00, // da      ()
	0x00, // db      ()
	0x00, // dc      ()
	0x00, // dd      ()
	0x00, // de      ()
	0x00, // df      ()
	0x00, // e0      ()
	0x00, // e1      ()
	0x00, // e2      ()
	0x00, // e3      ()
	0x00, // e4      ()
	0x00, // e5      ()
	0x00, // e6      ()
	0x00, // e7      ()
	0x00, // e8      ()
	0x00, // e9      ()
	0x00, // ea      ()
	0x00, // eb      ()
	0x00, // ec      ()
	0x00, // ed      ()
	0x00, // ee      ()
	0x00, // ef      ()
	0x00, // f0      ()
	0x00, // f1      ()
	0x00, // f2      ()
	0x00, // f3      ()
	0x00, // f4      ()
	0x00, // f5      ()
	0x00, // f6      ()
	0x00, // f7      ()
	0x00, // f8      ()
	0x00, // f9      ()
	0x00, // fa      ()
	0x00, // fb      ()
	0x00, // fc      ()
	0x00, // fd      ()
	0x00, // fe      ()
	0x00, // ff      ()
};

/*************************************************
    Functions definition - define lextable.cpp
*************************************************/
BOOL IsUpperPunctW(const WCHAR ch);
BOOL IsUpperWordDelimW(WCHAR wc);
BOOL TWB_IsCharPunctW(WCHAR ch);
BOOL TWB_IsCharWordDelimW(WCHAR ch);
bool IsThaiChar(const WCHAR ch);
bool IsThaiNumeric(const WCHAR ch);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\lextable.cpp ===
//+---------------------------------------------------------------------------
//
//
//  Lextable.hpp
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "lextable.hpp"

//+---------------------------------------------------------------------------
//
//  Function:   IsUpperPunctW
//
//  Synopsis:   Returns true if wc is a punctuation character in the upper
//              unicode range
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsUpperPunctW(const WCHAR wc)
{
    BOOL fRet = FALSE;

    if ((wc & 0xff00) == 0x2000)  // is Unicode punctuation
    {
        fRet = TRUE;
    }
    else
    {
        switch(wc)
        {
        case 0x01C3:     // Yet another latin exclamation mark
        case 0x037E:     // Greek question mark
        case 0x03D7:     // greek question mark
        case 0x055C:     // Armenian exclamation mark
        case 0x055E:     // Armenian question mark
        case 0x0589:     // armenian period
        case 0x061F:     // Arabic question mark
        case 0x06d4:     // arabic period
        case 0x2026:     // horizontal ellipsis
        case 0x2029:     // paragraph separator
        case 0x203C:     // Double eclamation mark
        case 0x2762:     // Heavy exclamation mark
        case 0x3002:     // ideographic period
        case 0xFE52:     // small period
        case 0xFE56:     // Small question mark
        case 0xFE57:     // Small exclamation mark
        case 0xFF01:     // Fullwidth exclamation mark
        case 0xFF0E:     // fullwidth period
        case 0xFF1F:     // Fullwidth question mark
        case 0xFF61:     // halfwidth ideographic period
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsUpperWordDelimW
//
//  Synopsis:   figures out whether an upper unicode char is a word delimiter
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsUpperWordDelimW(WCHAR wc)
{
    return (wc & 0xfff0) == 0x2000 ||
        wc == 0x2026 || // ellipsis
        wc == 0x2013 || // en dash
        wc == 0x2014;   // em dash
}

//+---------------------------------------------------------------------------
//
//  Function:   TWB_IsCharPunctW
//
//  Synopsis:   figures out whether charater is a punctuation
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL TWB_IsCharPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? IsUpperPunctW(ch) : rgFlags[(UCHAR) ch] & Lex_PunctFlag;
}

//+---------------------------------------------------------------------------
//
//  Function:   TWB_IsCharPunctW
//
//  Synopsis:   figures out whether charater is a word delimiter
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL TWB_IsCharWordDelimW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? IsUpperWordDelimW(ch) : rgPunctFlags[(UCHAR) ch] & Lex_SpaceFlag;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiChar
//
//  Synopsis:   determine if the character is a Thai character
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:      13/12/99 - take out Thai numbers as Thai Characters since
//                         we want to consider them like english numbers.
//
//----------------------------------------------------------------------------
bool IsThaiChar(const WCHAR wch)
{
	return ( wch >= 0x0e01 && wch <= 0x0e59);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsThaiNumeric
//
//  Synopsis:   determine if the character is a Thai character
//
//  Parameters:
//
//  Modifies:
//
//  History:    created 5/00 aarayas
//
//----------------------------------------------------------------------------
bool IsThaiNumeric(const WCHAR wch)
{
	return ( wch >= 0x0e50 && wch <= 0x0e59);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\mapio.c ===
/*+---------------------------------------------------------------------------
//
//  mapio.c - mapped file i/o routines
//
//  History:
//      9/4/97 DougP    Create this header
                        allow and deal with input map files of zero length
	11/20/97	DougP	Move these routines from misc.c to here
						Add option to spec codepage
//
//  1997 Microsoft Corporation
//----------------------------------------------------------------------------*/
#include <windows.h>
#include <assert.h>
#include "NLGlib.h"

//#ifdef WINCE
void Assert(x)
{
	if (x)
		MessageBox(0,"assert","assert",MB_OK);
}
//#endif

BOOL WINAPI CloseMapFile(PMFILE pmf)
{
    if (pmf==NULL) {
        return FALSE;
    }

      // only unmap what existed - DougP
    if (pmf->pvMap && !UnmapViewOfFile(pmf->pvMap)) {
       return FALSE;
    }

      // ditto
    if (pmf->hFileMap && !CloseHandle(pmf->hFileMap)) {
        return FALSE;
    }

    if (!CloseHandle(pmf->hFile)) {
        return FALSE;
    }

    NLGFreeMemory(pmf);

    return TRUE;
}

PMFILE WINAPI OpenMapFileWorker(const WCHAR * pwszFileName,BOOL fDstUnicode)
{
    PMFILE pmf;
    const WCHAR * pwszExt;

    if (!fNLGNewMemory(&pmf, sizeof(MFILE)))
    {
        goto Error;
    }

    pmf->fDstUnicode = fDstUnicode;

#ifdef WINCE
    pmf->hFile = CreateFileForMapping(
#else
    pmf->hFile = CMN_CreateFileW(
#endif
	 pwszFileName, GENERIC_READ, FILE_SHARE_READ,
	 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (pmf->hFile == INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    pmf->cbSize1 = GetFileSize(pmf->hFile, &pmf->cbSize2);
    if (pmf->cbSize1 == 0xFFFFFFFF)
    {
        CMN_OutputSystemErrW(L"Can't get size for", pwszFileName);
        CloseHandle(pmf->hFile);
        goto Error;
    }
    else if (pmf->cbSize1 == 0)
    {
          // can't map a zero length file so mark this appropriately
        pmf->hFileMap = 0;
        pmf->pvMap = 0;
        pmf->fSrcUnicode    = TRUE;
    }
    else
    {
#ifdef	WINCE
	pmf->hFileMap = CreateFileMapping(pmf->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
#else
	pmf->hFileMap = CreateFileMappingA(pmf->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
#endif
        if (pmf->hFileMap == NULL)
        {
            CMN_OutputSystemErrW(L"Can't Map", pwszFileName);
            CloseHandle(pmf->hFile);
            goto Error;
        }

        // Map the entire file starting at the first byte
        //
        pmf->pvMap = MapViewOfFile(pmf->hFileMap, FILE_MAP_READ, 0, 0, 0);
        if (pmf->pvMap == NULL)
        {
            CloseHandle(pmf->hFileMap);
            CloseHandle(pmf->hFile);
            goto Error;
        }

        // HACK:  Since IsTextUnicode returns false for sorted stem files, preset
        // unicode status here based on utf file extension
        pwszExt = pwszFileName;
        while (*pwszExt && *pwszExt != L'.' ) pwszExt++;

        if (*pwszExt && !wcscmp(pwszExt, L".utf"))
        {
            pmf->fSrcUnicode = TRUE;
        }
        else if (pmf->cbSize1 >= 2 && *(WORD *)pmf->pvMap == 0xFEFF)
        {
            // Safe to assume that anything starting with a BOM is Unicode
            pmf->fSrcUnicode = TRUE;
        }
        else
	{
#ifdef	WINCE
	    pmf->fSrcUnicode = TRUE;
#else
	    pmf->fSrcUnicode = IsTextUnicode(pmf->pvMap, pmf->cbSize1, NULL);
#endif
        }

        if (pmf->fSrcUnicode)
        {
            pmf->pwsz = (WCHAR *)pmf->pvMap;
        }
        else
        {
            pmf->psz = (PSTR)pmf->pvMap;
        }
    }

	pmf->uCodePage = CP_ACP;	// DWP - use default unless client specifies otherwise
    return pmf;

Error:
    if (pmf)
    {
        NLGFreeMemory(pmf);
    }
    return NULL;
}

#ifndef WINCE
PMFILE WINAPI OpenMapFileA(const char * pszFileName)
{
    WCHAR * pwszFileName;
    DWORD cchFileNameLen;
    int iRet;

    cchFileNameLen = lstrlenA(pszFileName) + 1;
    if (!fNLGNewMemory(&pwszFileName, cchFileNameLen * sizeof(WCHAR)))
    {
        return NULL;
    }

    iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFileName, -1,
        pwszFileName, cchFileNameLen);
    if (iRet ==0)
    {
        NLGFreeMemory(pwszFileName);
        return NULL;
    }

    return (OpenMapFileWorker(pwszFileName, FALSE));
}

#endif

BOOL WINAPI ResetMap(PMFILE pmf)
{
    if (pmf == NULL) {
        return FALSE;
    }

    if (pmf->fSrcUnicode) {
        pmf->pwsz = (WCHAR*)pmf->pvMap;
        if (*pmf->pwsz == 0xFEFF) {
            pmf->pwsz++;
        }
    } else {
        pmf->psz = (CHAR*)pmf->pvMap;
    }

    return TRUE;
}

// Same side effect as GetMapLine (incrememnt map pointer) but without returning contents
// in buffer.  This is useful in situations where the line may be longer than the max  cch and
// when the buffer isn't actually needed (counting lines, etc.)
//
BOOL WINAPI NextMapLine(PMFILE pmf)
{
    DWORD cbOffset;

    if (!pmf || !pmf->hFileMap) // check for zero length file
        return FALSE;

    if (pmf->fSrcUnicode)
    {
        WCHAR wch;
        cbOffset = (DWORD) ((PBYTE)pmf->pwsz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            return FALSE;

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(WCHAR);
            wch = *pmf->pwsz++;

            // Break out if this is the newline or the control-Z
            if (wch == 0x001A || wch == L'\n')
                break;
        }
    }
    else
    {
        CHAR ch;
        cbOffset = (DWORD) ((PBYTE)pmf->psz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            return FALSE;

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(CHAR);
            ch = *pmf->psz++;

            // Break out if this is the newline or the control-Z
            if (ch == 0x1A || ch == '\n')
                break;
        }
    }

    return TRUE;
}


PVOID WINAPI GetMapLine(PVOID pv0, DWORD cbMac, PMFILE pmf)
{
    PVOID pv1;
    DWORD cbOffset, cbBuff;

    Assert(pv0);
    // Make sure that the buffer is at least as big as the caller says it is.
    // (If the buffer was allocated with the debug memory allocator, this access
    // should cause an exception if pv0 isn't at least cbMac bytes long.
    Assert(((char *)pv0)[cbMac-1] == ((char *)pv0)[cbMac-1]);

    if (!pmf || !pmf->hFileMap) // check for zero length file
        return NULL;

    if (pmf->fSrcUnicode != pmf->fDstUnicode)
    {
        if (!fNLGNewMemory(&pv1, cbMac))
            return NULL;

        cbBuff = cbMac;
    }
    else
    {
        pv1 = pv0;
    }

    if (pmf->fSrcUnicode)
    {
        WCHAR wch, *pwsz = pv1;
        cbOffset = (DWORD) ((PBYTE)pmf->pwsz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            goto Error;

        // don't want deal with odd-sized buffers
        if (cbMac % sizeof(WCHAR) != 0)
            cbMac -= (cbMac % sizeof(WCHAR));

        // reserve space for terminating 0
        //
        Assert (cbMac > 0);
        cbMac -= sizeof(WCHAR);

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(WCHAR);
            wch = *pmf->pwsz++;

            switch (wch)
            {
            case L'\r':
            case L'\n':      // end of line
            case 0xFEFF:     // Unicode BOM
                break;
            case 0x001A:     // ctrl-Z
                wch = L'\n'; // Replace it so that the last line can be read
                break;
            default:
                *pwsz++ = wch;
                cbMac -= sizeof(WCHAR);
            }

            // Break out if this is the newline or buffer is full
            if (wch == L'\n' || cbMac <= 0)
                break;
        }
        *pwsz = L'\0';
    }
    else
    {
        CHAR ch, *psz = pv1;
        cbOffset = (DWORD) ((PBYTE)pmf->psz - (PBYTE)pmf->pvMap);

        // test for EOF
        Assert (cbOffset <= pmf->cbSize1);
        if (cbOffset == pmf->cbSize1)
            goto Error;

        // reserve space for terminating 0
        //
        Assert (cbMac > 0);
        cbMac -= sizeof(CHAR);

        while (cbOffset < pmf->cbSize1)
        {
            cbOffset += sizeof(CHAR);
            ch = *pmf->psz++;

            switch (ch)
            {
            case '\r':
            case '\n':      // end of line
                break;
            case 0x1A:      // ctrl-Z
                ch = '\n';  // Replace it so that the last line can be read
                break;
            default:
                cbMac -= sizeof(CHAR);
                *psz++ = ch;
            }

            // Break out if this is the newline or buffer is full
            if (ch == '\n' || cbMac <= 0)
                break;
        }
        *psz = '\0';
    }

    if (pmf->fSrcUnicode != pmf->fDstUnicode)
    {
        DWORD cch = cbBuff;     // our argument is a count of bytes

        if (pmf->fDstUnicode)
        {
            // MultiByteToWideChar wants the size of the destination in wide characters
            cch /= sizeof(WCHAR);
            cch = MultiByteToWideChar(pmf->uCodePage, MB_PRECOMPOSED,(PSTR)pv1,-1, (WCHAR *)pv0,cch);
        }
        else
        {
            cch = WideCharToMultiByte(pmf->uCodePage, 0, (WCHAR *)pv1, -1, (PSTR)pv0, cch, NULL, NULL);
        }
        if (cch == 0)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // Ignore truncation (for consistency with no-conversion cases)
                //
                if (pmf->fDstUnicode)
                {
                    ((WCHAR *)pv0)[(cbBuff / sizeof(WCHAR)) - 1] = 0;
                }
                else
                {
                    ((CHAR *)pv0)[cbBuff - 1] = 0;
                }
            }
            else
            {
                // not a truncation error
                NLGFreeMemory(pv1);
                return NULL;
            }
        }
        NLGFreeMemory(pv1);
    }

    return(pv0);

Error:
    if (pmf->fSrcUnicode != pmf->fDstUnicode)
    {
        NLGFreeMemory(pv1);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\precomp.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1994, Microsoft Corporation.  All Rights Reserved.
//
//  File:       precomop.h
//
//  Contents:   Internal include file for Token Hammer.
//
//  History:    22-May-95       PatHal          Created
//
//---------------------------------------------------------------------------

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define _UNICODE 1
#define UNICODE 1

#include <windows.h>
#include <memory.h>
#include <malloc.h>
#ifndef WINCE
#include <stdio.h>
#include <wchar.h>
#endif
#include <string.h>

#ifndef WINCE
#include "cmn_debug.h"
#endif
#include "common.h"
#include "misc.h"
#include "NLGlib.h"

#define unreference(x)  (x)

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\nlglib.h ===
/****************************** Module Header ******************************\
* Module Name: NLGLib.h
*
* Copyright (c) 1997, Microsoft Corporation
*
* History:
1/26/98 DougP   prefix dbgMalloc, dbgFree, and dbgRealloc with CMN_
                whack defs of malloc, free, and realloc
\***************************************************************************/

#ifndef _NLGLIB_H_
#define _NLGLIB_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>      // For the definition of FILE


// Mapped file stuff
//
typedef struct _TAG_MFILE {
    HANDLE hFile;
    HANDLE hFileMap;
    DWORD cbSize1;
    DWORD cbSize2;
    PVOID pvMap;
    BOOL fSrcUnicode;
    BOOL fDstUnicode;
    union {
        WCHAR * pwsz;
        CHAR * psz;
    };
        UINT uCodePage; // codepage for conversions
} MFILE, *PMFILE;

// ----------------------------------------------------------------------
// misc.c
// ----------------------------------------------------------------------
#ifdef _UNICODE
#define OpenMapFile OpenMapFileW
#define OpenDataFile OpenDataFileW
#define OpenOutFile OpenOutFileW
#else
#define OpenMapFile OpenMapFileA
#endif

BOOL WINAPI ResetMap(PMFILE pmf);
BOOL WINAPI CloseMapFile(PMFILE pmf);
PMFILE WINAPI OpenMapFileA(const char *pszFileName);
PVOID WINAPI GetMapLine(PVOID pv0, DWORD cbMac, PMFILE pmf);
BOOL WINAPI NextMapLine(PMFILE pmf);

PMFILE WINAPI OpenMapFileWorker(const WCHAR * pwszFileName, BOOL fDstUnicode);
#define OpenMapFileW(pwszFileName) OpenMapFileWorker(pwszFileName, TRUE)
#define OpenDataFileW(pwszFileName) OpenMapFileWorker(pwszFileName, TRUE)
#define OpenOutFileW(pwszFileName) OpenMapFileWorker(pwszFileName, TRUE)


// Inverse Probability Log (IPL) stuff
//
typedef BYTE IPL;
#define IPL_UNKNOWN     0xFF

// All ipl values must be strictly less than this.
// This corresponds to a probability of 1 in 4 billion, so
// it supports a corpus of 4 billion items (chars, words, sentences, etc.)
//
#define IPL_LIMIT     32

// Multiplier is used to boost precision of low ipls
//
#define IPL_MULTIPLIER      8    // 256 divided by 32 = 8

#define Ipl2Freq( ipl, cTotalFreq)     ((cTotalFreq) >> (ipl))

IPL WINAPI Freq2Ipl( double );

DWORD WINAPI GetCRC32( IN BYTE *pb, IN DWORD cb);
WORD WINAPI GetCRC16( IN BYTE *pb, IN DWORD cb);


// ----------------------------------------------------------------------
// mapsort.c
// ----------------------------------------------------------------------
// Sort and Unique stuff
//
#ifdef _UNICODE
#define MapSort MapSortW
#define MapUnique MapUniqueW
#define Member MemberW
#define RecordString RecordStringW
#else // _UNICODE not defined
#define MapSort MapSortA
#define MapUnique MapUniqueA
#endif // _UNICODE

BOOL WINAPI MapSortW( CONST WCHAR * pszFileName);
BOOL WINAPI MapSortA( CHAR * pszFileName);
BOOL WINAPI MapUniqueW( CONST WCHAR * pwszFileName);
BOOL WINAPI MapUniqueA( CHAR * pszFileName);

// ----------------------------------------------------------------------
// mcodes.c
// ----------------------------------------------------------------------

// WARNING WARNING WARNING
// cpheme creation mode - should be consistent with T-Hammer
#define CPHEME_MODE_STRICT    0x0001
#define CPHEME_MODE_DUPLICATE 0x0002
#define STEM_ATTR_COMPV       0x0010

typedef struct _tagMETABASES {
    WCHAR wcOphemeBase;
    WCHAR wcMinTrieChar;
    WCHAR wcStemBase;
    WCHAR wcFcnBase;
    WCHAR wcSelBase;
} METABASE, *PMETABASE;

// Stem/Morph Code file stuff
//
void WINAPI ReadBases( METABASE *pMetaBases );
void WINAPI WriteBases( METABASE *pMetaBases );

void WINAPI
WriteFcnCodes(
    WCHAR **ppwzMorphs,
    DWORD cMorphs,
    PWORD pwSelections);

void WINAPI
WriteCodesBin(
    CONST WCHAR *pwzFileName,
    WCHAR **ppwzMorphs,
    DWORD cMorphs,
    WCHAR **ppwzAttr1,
    WCHAR **ppwzAttr2,
    PWORD pwAttributes);

BOOL WINAPI
GetCodes(
    WCHAR *wszCodesFile,
    WCHAR **ppwszBuffer,
    WCHAR **ppwszCodes,
    DWORD *pcCodes,
    DWORD cCodesMac);

BOOL WINAPI
GetCodesUnsorted(
    WCHAR *wszCodesFile,
    WCHAR **ppwszBuffer,
    WCHAR **ppwszCodes,
    DWORD *pcCodes,
    DWORD cCodesMac);

BOOL WINAPI
GetCodeAttributes(
    WCHAR *wszCodesFile,
    WCHAR **ppwszCodes,
    DWORD  cCodes,
    WCHAR **ppwszBuffer,
    WCHAR **ppwszAttr1,
    WCHAR **ppwszAttr2,
    WORD *pwAttrFlags);

BOOL WINAPI
LoadMCatMappingTable(
    WCHAR *wszCodesFile,
    WCHAR **ppwszCodes,
    DWORD  cCodes,
    WCHAR **ppwszTBits,
    DWORD  cTBits,
    WORD *pwTBitToMCat,
    WORD *pwSubMToMCat);

BOOL WINAPI
MCatFromTBit(
    DWORD iTBit,
    DWORD *piMCat,
    WORD *pwTBitToMCat,
    DWORD cTBits);

BOOL WINAPI
MCatFromSubM(
    DWORD iSubM,
    DWORD *piMCat,
    WORD *pwSubMToMCat,
    DWORD cCodes);

BOOL WINAPI
EnumSubMFromMCat(
    DWORD iMCat,
    DWORD *piSubM,
    WORD *pwSubMToMCat,
    DWORD cCodes);

// ----------------------------------------------------------------------
// ctplus0.c
// ----------------------------------------------------------------------
// Character type routines
BYTE WINAPI
GetCharType(WCHAR wc );


// ----------------------------------------------------------------------
// fileio.c
// ----------------------------------------------------------------------

// File I/O Wrappers
//
HANDLE WINAPI ThCreate( CONST WCHAR * );
HANDLE WINAPI ThOpen( CONST WCHAR * );
UINT WINAPI ThRead( HANDLE , LPVOID , UINT );
UINT WINAPI ThWrite( HANDLE, LPCVOID , UINT );

// CRT Unicode routines
//
int WINAPI UStrCmp(const WCHAR *pwsz1, const WCHAR *pwsz2);
DWORD WINAPI MemberW(WCHAR * ,WCHAR **, DWORD);
DWORD WINAPI RecordString(WCHAR *, WCHAR **, WCHAR *, DWORD *, DWORD *);
void WINAPI PutLine(const WCHAR *, FILE *);
WCHAR * WINAPI GetLine(WCHAR *, int , FILE *);

#define PrimeHash(wOld, wNew, cBitsMax) (((wOld) + (wNew))*hashPrime[cBitsMax]&hashMask[cBitsMax])


extern const unsigned int hashPrime[];
extern const unsigned int hashMask[];

// #include "ctplus0.h"

//-----------------------------------------------------------+
// memory allocation:
// In the debug version, we compile in the debugging memory
// allocator and aim our allocation macros at it.
// In retail, the macros just use LocalAlloc
//-----------------------------------------------------------+
#if defined(_DEBUG)
    void    * WINAPI dbgMalloc(size_t cb);
    void    * WINAPI dbgCalloc(size_t c, size_t cb);
    void    * WINAPI dbgFree(void* pv);
    void    * WINAPI dbgRealloc(void* pv, size_t cb);
    void    * WINAPI dbgMallocCore(size_t cb, BOOL fTrackUsage);
    void    * WINAPI dbgFreeCore(void* pv, BOOL fTrackUsage);
    void    * WINAPI dbgReallocCore(void* pv, size_t cb, BOOL fTrackUsage);

    #if 0
        #define malloc  dbgMalloc
        #define free    dbgFree
        #define realloc dbgRealloc
        #define calloc  dbgCalloc
    #endif

    //DWORD WINAPI     dbGlobalSize(HANDLE);
    //HANDLE WINAPI   dbGlobalAlloc(UINT, DWORD);
    //HANDLE WINAPI   dbGlobalFree(HANDLE);
    //HANDLE WINAPI   dbGlobalReAlloc(HANDLE, DWORD, UINT);
    #if defined(ENABLE_DBG_HANDLES)
        HANDLE WINAPI   dbGlobalHandle(LPCVOID);
        BOOL WINAPI      dbGlobalUnlock(HANDLE);
        LPVOID WINAPI    dbGlobalLock(HANDLE);
    #endif // ENABLE_DBG_HANDLES

    #define dbHeapInit InitDebugMem
      // it is a good idea (essential if you're MT) to call these before any mem allocs
    void WINAPI InitDebugMem(void);
      // and this after all mem allocs
    BOOL WINAPI FiniDebugMem(void);  // returns true if not all memory released

    // these are alternative entrypoints
    BOOL    WINAPI fNLGNewMemory( PVOID *ppv, ULONG cbSize);
    DWORD   WINAPI NLGMemorySize(PVOID pvMem);
    BOOL    WINAPI fNLGResizeMemory(PVOID *ppv, ULONG cbNew);
    VOID    WINAPI NLGFreeMemory(PVOID pv);
    BOOL    WINAPI fNLGHeapDestroy( VOID );
#else // NOT (DEBUG)
    #define InitDebugMem()  ((void)0)
    #define FiniDebugMem() (FALSE)

    #define dbgMalloc(cb)   LocalAlloc( LMEM_FIXED, cb )
    void    * WINAPI dbgCalloc(size_t c, size_t cb);
    #define dbgFree(pv)     LocalFree( pv )
    #define dbgRealloc(pv, cb)  LocalReAlloc(pv, cb, LMEM_MOVEABLE)

    #define fNLGHeapDestroy( )          TRUE
    // When fNLGNewMemory fails the passed in ptr will be side-effected to NULL
    #define fNLGNewMemory( ppv, cbSize) ((*(ppv) = LocalAlloc( LMEM_FIXED, cbSize )) != NULL)
    #define NLGFreeMemory( pv)          LocalFree( pv )

#endif //  (DEBUG)


/*************************************************
    Lexical Table functions
        implementation in lextable.c
*************************************************/
#define Lex_UpperFlag             0x01         /* upper case */
#define Lex_LowerFlag             0x02         /* lower case */
#define Lex_DigitFlag             0x04         /* decimal digits */
#define Lex_SpaceFlag             0x08         /* spacing characters */
#define Lex_PunctFlag             0x10         /* punctuation characters */
#define Lex_ControlFlag             0x20         /* control characters */
#define Lex_LexiconFlag 0x40
#define Lex_VowelFlag 0x80
#define NTRANSTAB 256

extern const BYTE Lex_rgchKey[NTRANSTAB];
extern const BYTE Lex_rgFlags[NTRANSTAB];
#define INUPPERPAGES(ch) (ch & 0xff00)  // this is the same as ch > 0x00ff

// don't count on any of the above constants - use these functions below

// The speller uses this to make equivalent classes
WCHAR WINAPI fwcUpperKey(const WCHAR wc);
BOOL WINAPI IsUpperPunct(const WCHAR ch);
__inline WCHAR WINAPI CMN_Key(const WCHAR ch)
{
#if defined(_VIET_)
	// When we are ready for merge we should add these data to core Lex_rgFlgas.
	if (INUPPERPAGES(ch))
	{
		if ( (ch == 0x0102) ||
		     (ch == 0x0110) ||
			 (ch == 0x01A0) ||
			 (ch == 0x01AF) )
		{
			return (ch + 1);
		}
		return fwcUpperKey(ch);
	}
	else if ( (ch == 0x00D0) )				// This seem very weird that we map it like this in NT.
	{
		return 0x0111;
	}
	else if ( (ch == 0x00C3) )
	{
		return 0x0103;
	}
	else if ( (ch == 0x00D5) )
	{
		return 0x01A1;
	}
	else if ( (ch == 0x00DD) )
	{
		return 0x01B0;
	}
	else if ( (ch == 0x00D4) ||
			  (ch == 0x00CA) ||
			  (ch == 0x00C2) )
	{
		return (ch + 0x0020);
	}
	else if ( (ch == 0x00f4) ||				// These are special case there are no key that should map to these characters.
			  (ch == 0x00ea) ||
			  (ch == 0x00e2) )
	{
		return ch;
	}
	else
	{
		return ((WCHAR) Lex_rgchKey[(UCHAR) ch]);
	}

#else
    return (WCHAR) (INUPPERPAGES(ch) ?
                    fwcUpperKey(ch) :
                    (WCHAR) Lex_rgchKey[(UCHAR) ch]);
#endif
}
__inline BOOL WINAPI CMN_IsCharUpperW(WCHAR ch)
{
#if defined(_VIET_)
	// When we are ready for merge we should add these data to core Lex_rgFlgas.
	if ( (ch == 0x0111) ||
	     (ch == 0x0103) ||
		 (ch == 0x01A1) ||
		 (ch == 0x01B0) )
	{
		return FALSE;
	}
	else if ( (ch == 0x0102) ||
			  (ch == 0x0110) ||
			  (ch == 0x01A0) ||
			  (ch == 0x01AF) ||
			  (ch == 0x00D4) ||
			  (ch == 0x00CA) ||
			  (ch == 0x00D0) ||
			  (ch == 0x00C3) ||
			  (ch == 0x00D5) ||
			  (ch == 0x00DD) ||
			  (ch == 0x00C2) )
	{
		return TRUE;
	}
	else if (INUPPERPAGES(ch))
	{
		return FALSE;
	}
	else
	{
		return Lex_rgFlags[(UCHAR) ch] & Lex_UpperFlag;
	}

#else
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_UpperFlag;
#endif
}
__inline BOOL WINAPI CMN_IsCharLowerW(WCHAR ch)
{
#if defined(_VIET_)
	// When we are ready for merge we should add these data to core Lex_rgFlgas.
	if ( (ch == 0x0111) ||
	     (ch == 0x0103) ||
		 (ch == 0x01A1) ||
		 (ch == 0x01B0) )
	{
		return TRUE;
	}
	else if ( (ch == 0x0102) ||
			  (ch == 0x0110) ||
			  (ch == 0x01A0) ||
			  (ch == 0x01AF) ||
			  (ch == 0x00D4) ||
			  (ch == 0x00CA) ||
			  (ch == 0x00D0) ||
			  (ch == 0x00C3) ||
			  (ch == 0x00D5) ||
			  (ch == 0x00DD) ||
			  (ch == 0x00C2) )
	{
		return FALSE;
	}
	else if (INUPPERPAGES(ch))
	{
		return FALSE;
	}
	else
	{
		return Lex_rgFlags[(UCHAR) ch] & Lex_LowerFlag;
	}
#else
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_LowerFlag;
#endif
}
__inline BOOL WINAPI CMN_IsCharAlphaW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? !IsUpperPunct(ch) : Lex_rgFlags[(UCHAR) ch] & (Lex_LowerFlag | Lex_UpperFlag);
}
__inline BOOL WINAPI CMN_IsCharAlphaNumericW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? !IsUpperPunct(ch) : Lex_rgFlags[(UCHAR) ch] & (Lex_LowerFlag | Lex_UpperFlag | Lex_DigitFlag);
}
__inline BOOL WINAPI CMN_IsCharDigitW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_DigitFlag;
}
__inline BOOL WINAPI CMN_IsCharStrictDigitW(WCHAR ch)
{     // only allows digits 0-9 - no superscripts, no fractions
    return (
        INUPPERPAGES(ch) ?
            FALSE :
            (Lex_rgFlags[(UCHAR) ch] & (Lex_DigitFlag | Lex_PunctFlag)) ==
                    Lex_DigitFlag
    );
}
BOOL WINAPI IsUpperSpace(WCHAR ch);
__inline BOOL WINAPI CMN_IsCharSpaceW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        IsUpperSpace(ch) :
        Lex_rgFlags[(UCHAR) ch] & Lex_SpaceFlag;
}
__inline BOOL WINAPI CMN_IsCharPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? IsUpperPunct(ch) : Lex_rgFlags[(UCHAR) ch] & Lex_PunctFlag;
}
__inline BOOL WINAPI CMN_IsCharPrintW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        !CMN_IsCharSpaceW(ch) :
        Lex_rgFlags[(UCHAR) ch] &
            (Lex_PunctFlag | Lex_UpperFlag | Lex_LowerFlag | Lex_DigitFlag);
}
__inline BOOL WINAPI CMN_IsCharInLexiconW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        (!IsUpperPunct(ch) || ch == 0x2019 || ch == 0x2018) :
        Lex_rgFlags[(UCHAR) ch] & Lex_LexiconFlag;
}
__inline BOOL WINAPI CMN_IsCharVowelW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? FALSE : Lex_rgFlags[(UCHAR) ch] & Lex_VowelFlag;
}
__inline BOOL WINAPI CMN_IsCharGraphW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        TRUE :
        Lex_rgFlags[(UCHAR) ch] &
            (Lex_LowerFlag |
                Lex_UpperFlag |
                Lex_DigitFlag |
                Lex_PunctFlag);
}

  // Some punctuation flags
#define Lex_PunctLead             0x01         /* leading punctuation */
#define Lex_PunctJoin             0x02         /* joining punctuation */
#define Lex_PunctTrail            0x04         /* trailing punctuation */
    // reuse Lex_SpaceFlag here
extern const BYTE Lex_rgPunctFlags[NTRANSTAB];
__inline BOOL WINAPI CMN_IsLeadPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        (ch == 0x201c || ch == 0x2018) :
        (Lex_rgPunctFlags[(UCHAR) ch] & Lex_PunctLead);
}
__inline BOOL WINAPI CMN_IsJoinPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ? FALSE : Lex_rgPunctFlags[(UCHAR) ch] & Lex_PunctJoin;
}
__inline BOOL WINAPI CMN_IsTrailPunctW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        (ch == 0x201d || ch == 0x2019) :
        (Lex_rgPunctFlags[(UCHAR) ch] & Lex_PunctTrail);
}
BOOL WINAPI IsUpperWordDelim(WCHAR ch);
__inline BOOL WINAPI CMN_IsCharWordDelimW(WCHAR ch)
{
    return INUPPERPAGES(ch) ?
        IsUpperWordDelim(ch) :
        Lex_rgPunctFlags[(UCHAR) ch] & Lex_SpaceFlag;
}

  // implementation in lexfuncs.c
WCHAR WINAPI CMN_CharUpperW(const WCHAR ch);
WCHAR WINAPI CMN_CharLowerW(const WCHAR ch);
BOOL WINAPI CMN_IsStringEqualNoCaseW(const WCHAR *pwz1, const WCHAR *pwz2);
BOOL WINAPI CMN_IsStringEqualNoCaseNumW(const WCHAR *pwz1, const WCHAR *pwz2, int cch);
DWORD WINAPI CMN_CharUpperBuffW(WCHAR *pwz, DWORD cchLength);
DWORD WINAPI CMN_CharLowerBuffW(WCHAR *pwz, DWORD cchLength);
int WINAPI CMN_CompareStringNoCaseW(const WCHAR *pwz1, const WCHAR *pwz2);
int WINAPI CMN_CompareStringNoCaseNumW(const WCHAR *pwz1, const WCHAR *pwz2, int cch);
  // note that this version does not set errno on errors
long WINAPI CMN_wcstol( const wchar_t *nptr, const wchar_t * *endptr, int base );

__inline int WINAPI CMN_wtoi( const wchar_t *string )
{
    return CMN_wcstol(string, NULL, 10);
}

__inline wchar_t * WINAPI CMN_wcsupr( wchar_t *string )
{
    CMN_CharUpperBuffW(string, wcslen(string));
    return string;
}

__inline wchar_t * WINAPI CMN_wcslwr( wchar_t *string )
{
    CMN_CharLowerBuffW(string, wcslen(string));
    return string;
}


////////////////////
// debug.c
/////////////////////
#if defined(_DEBUG)

extern void WINAPI DebugAssert(LPCTSTR, LPCTSTR, UINT);
extern void WINAPI SetAssertOptions(DWORD);

#else // _DEBUG

#define DebugAssert(a, b, c)
#define SetAssertOptions(a)

#endif // _DEBUG defined

/****************************************************************

  These are versions of some WINAPI functions that normally don't work
  on win95 with Unicode (not supported).  They have the same arguments
  as the API functions

    If UNICODE is not defined, they become the A versions
    If UNICODE is defined and x86, they become our W version
    If UNICODE is defined and not x86, they become API W version

****************************************************************/

#include <sys/stat.h>   // this needs to be before the redefs we do below
#include <stdlib.h>     // as does this

  // want to do these substitutions regardless
#define IsCharLowerW        CMN_IsCharLowerW
#define IsCharUpperW        CMN_IsCharUpperW
#define IsCharAlphaW        CMN_IsCharAlphaW
#define IsCharAlphaNumericW CMN_IsCharAlphaNumericW
#define CharUpperBuffW      CMN_CharUpperBuffW
#define CharLowerBuffW      CMN_CharLowerBuffW
#define _wcsicmp            CMN_CompareStringNoCaseW
#define _wcsnicmp           CMN_CompareStringNoCaseNumW
#define towupper            CMN_CharUpperW
#define towlower            CMN_CharLowerW
#define wcstol              CMN_wcstol
#define _wtoi               CMN_wtoi
#define _wcsupr             CMN_wcsupr
#define _wcslwr             CMN_wcslwr

#undef iswdigit
#define iswdigit            CMN_IsCharDigitW
#undef iswspace
#define iswspace            CMN_IsCharSpaceW
#undef iswpunct
#define iswpunct            CMN_IsCharPunctW
#undef iswprint
#define iswprint            CMN_IsCharPrintW
#undef iswalpha
#define iswalpha            CMN_IsCharAlphaW
#undef iswalnum
#define iswalnum            CMN_IsCharAlphaNumericW
#undef iswgraph
#define iswgraph            CMN_IsCharGraphW
#undef iswupper
#define iswupper            CMN_IsCharUpperW
#undef iswlower
#define iswlower            CMN_IsCharLowerW

  // function defs for our versions
int WINAPI CMN_LoadStringW(HINSTANCE hModule, UINT uiId, WCHAR * wszString, int cchStringMax);
int WINAPI CMN_LoadStringWEx(HINSTANCE hModule, UINT uiId, WCHAR * wszString, int cchStringMax, LANGID lid);

  // these two functions replace the associated RTL functions - however
  // they can't be just replaced - as they use a third argument to maintain state
  // instead of static variables within the function.
  // Use these the same as the RTL functions, but declare TCHAR *pnexttoken before use
  // and pass its address as the third parameter
wchar_t * WINAPI CMN_wcstok (wchar_t * string, const wchar_t * control, wchar_t **pnextoken);
char * WINAPI CMN_strtok (char * string, const char * control, char **pnextoken);
#if defined(UNICODE)
#define CMN_tcstok CMN_wcstok
#else
#define CMN_tcstok CMN_strtok
#endif

#if defined(_M_IX86) && !defined(WINCE) && !defined(NTONLY)
#define CreateFileW         CMN_CreateFileW
#define LoadLibraryW        CMN_LoadLibraryW
#define GetModuleFileNameW  CMN_GetModuleFileNameW
#define GetFileAttributesW  CMN_GetFileAttributesW
  // FindResourceW works in win95
  // as does FindResourceExW

//#define PostMessageW        ERR_Does_not_work_in_w95    // no easy replacement for this one
#define FindWindowW         ERR_No_w95_equiv_yet

#define lstrcpynW           CMN_lstrcpynW
#define lstrcatW            CMN_lstrcatW
#define lstrcmpiW           CMN_lstrcmpiW
#define lstrcpyW            CMN_lstrcpyW
#define lstrlenW            CMN_lstrlenW
#define lstrcmpW            CMN_lstrcmpW
#define wsprintfW           swprintf
#define _wstat              CMN_wstat

#define CharNextW           CMN_CharNextW

#define LoadStringW         CMN_LoadStringW
#define _wfopen             CMN_wfopen

HANDLE WINAPI
CMN_CreateFileW (
    PCWSTR pwzFileName,  // pointer to name of the file
    DWORD dwDesiredAccess,  // access (read-write) mode
    DWORD dwShareMode,  // share mode
    LPSECURITY_ATTRIBUTES pSecurityAttributes, // pointer to security descriptor
    DWORD dwCreationDistribution,   // how to create
    DWORD dwFlagsAndAttributes, // file attributes
    HANDLE hTemplateFile);    // handle to file with attributes to copy

HINSTANCE WINAPI CMN_LoadLibraryW(const WCHAR *pwszLibraryFileName);

DWORD WINAPI CMN_GetModuleFileNameW( HINSTANCE hModule,  // handle to module to find filename for
    WCHAR *lpFilename,  // pointer to buffer to receive module path
    DWORD nSize);  // size of buffer, in characters

DWORD WINAPI CMN_GetFileAttributesW(const WCHAR *lpFileName); // address of the name of a file or directory

// note: Even though WINAPI returns WCHAR *, I define this as returning void
void WINAPI CMN_lstrcpynW( WCHAR *lpString1, // address of target buffer
                const WCHAR *lpString2, // address of source string
                int iMaxLength);  // number of bytes or characters to copy

#define CMN_lstrcmpiW _wcsicmp    // just use c-runtime for now
#define CMN_lstrcpyW wcscpy
#define CMN_lstrcatW    wcscat
#define CMN_lstrlenW(pwz)    ((int) wcslen(pwz))
#define CMN_lstrcmpW        wcscmp

#define CMN_CharNextW(pwz)  (pwz + 1)

FILE *WINAPI CMN_wfopen(const WCHAR *pwzFileName, const WCHAR *pwzUnimode);
int WINAPI CMN_wstat(const WCHAR *pwzPath, struct _stat *pStatBuffer);


#else   // there is no win95 - and it must be NT
#define CMN_CreateFileW         CreateFileW
#define CMN_LoadLibraryW        LoadLibraryW
#define CMN_GetModuleFileNameW  GetModuleFileNameW
#define CMN_GetFileAttributesW  GetFileAttributesW
#define CMN_lstrcpynW           lstrcpynW
#define CMN_lstrcmpiW           lstrcmpiW
#define CMN_lstrcpyW            lstrcpyW
#define CMN_lstrcatW            lstrcatW
#define CMN_lstrcmpW            lstrcmpW
#define CMN_wfopen              _wfopen
#define CMN_wstat               _wstat
#define CMN_CharNextW           CharNextW
#endif

  // Outputs Readable Error String to the Debug Output
#if defined (_DEBUG)
        void WINAPI CMN_OutputSystemErrA(const char *pszMsg, const char *pszComponent);
        void WINAPI CMN_OutputSystemErrW(const WCHAR *pwzMsg, const WCHAR *pwzComponent);
        void WINAPI CMN_OutputErrA(DWORD dwErr, const char *pszMsg, const char *pszComponent);
        void WINAPI CMN_OutputErrW(DWORD dwErr, const WCHAR *pwzMsg, const WCHAR *pwzComponent);
#       if defined (UNICODE)
#               define CMN_OutputSystemErr CMN_OutputSystemErrW
#               define CMN_OutputErr CMN_OutputErrW
#       else
#               define CMN_OutputSystemErr CMN_OutputSystemErrA
#               define CMN_OutputErr CMN_OutputErrA
#       endif
#else   //!_DEBUG
#       define CMN_OutputSystemErr(x, y)
#       define CMN_OutputSystemErrA(x, y)
#       define CMN_OutputSystemErrW(x, y)
#       define CMN_OutputErr(n, x, y)
#       define CMN_OutputErrA(n, x, y)
#       define CMN_OutputErrW(n, x, y)
#endif

///////////////////////
// LexWin95.c
///////////////////////

#define LoadLibraryW2A CMN_LoadLibraryW
#define CreateFileW2A CMN_CreateFileW

// Add anything new here, within the extern "C" clause

#ifdef __cplusplus
}       // ends the extern "C" clause

  // here's some C++ specific stuff
inline BOOL IsMapFileUnicode(PMFILE pmf, BOOL fDefault=TRUE)
{
    if (pmf->hFileMap)
            return pmf->fSrcUnicode;
      // must be zero length, set and return default
    return pmf->fSrcUnicode = fDefault;
}
inline void MapFileCodePage(PMFILE pmf, UINT uCP)
{
        pmf->uCodePage = uCP;
}

#if defined(CPPMEMORY)
inline void * _cdecl operator new (size_t size)
{
#if defined(DEBUG)
    return dbgMalloc(size);
#else
    return LocalAlloc( LMEM_FIXED, size );
#endif
}

inline void _cdecl operator delete(void *pMem)
{
    if (!pMem)
        return;
#if defined(DEBUG)
    dbgFree(pMem);
#else
    LocalFree(pMem);
#endif
}
#endif // CPPMEMORY


#endif // __cplusplus


#endif // _NLGLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\memcore.c ===
////////////////////////////////////////////////////////////////////////////////
// File: memCore.c
//
// This module which replaces the Win32 Global heap functions used by Word
// with functions which place objects at the end of a physical page.  In
// this way, we hope to catch out-of-bounds memory references exactly where
// they happen, helping to isolate heap corruption problems.
//
//
// This module is not enabled for ship builds.
//
// lenoxb:  4/05/94
//
////////////////////////////////////////////////////////////////////////////////


#include "precomp.h"

#if defined(_DEBUG) && (defined(_M_IX86) || defined (_M_ALPHA))

#include "dbgmemp.h"

static DWORD s_cbMemPage = 0;     // Initialize to 0 so init can check

static void *          FreePvCore(void*);
static LPVOID           PvReallocCore(PVOID, DWORD, UINT);

static LPVOID           DoAlloc(UINT, DWORD);
static void AddToList(struct head*);
static void RemoveFromList(struct head*);
static void TrackHeapUsage(long dcb);

static DWORD idBlockNext;

static struct head* phead;
static CRITICAL_SECTION csMine;

    #undef GlobalAlloc
    #undef GlobalReAlloc
    #undef GlobalFree
    #undef GlobalLock
    #undef GlobalUnlock
    #undef GlobalSize
    #undef GlobalHandle

BOOL g_fTrackHeapUsage;
DWORD g_cbAllocMax;
DWORD g_cbAlloc;

/*
 *Function Name:InitDebugMem
 *
 *Parameters:
 *
 *Description:  Initialize Memory Manager
 *
 *Returns:
 *
 */

void WINAPI InitDebugMem(void)
{
    SYSTEM_INFO SysInfo;

    Assert(!s_cbMemPage);
    InitializeCriticalSection(&csMine);

    GetSystemInfo( &SysInfo );  // get the system memory page size
    s_cbMemPage = SysInfo.dwPageSize;
}

BOOL WINAPI FiniDebugMem(void)
{
    Assert(s_cbMemPage);
    s_cbMemPage = 0;
    DeleteCriticalSection(&csMine);

    if (!phead) // no outstanding mem blocks
        return FALSE;
    else
    {
        struct head* pheadThis = phead;
        char buf[256];

        OutputDebugStringA("Unfreed Memory Blocks\n");
        for ( ; pheadThis; pheadThis = pheadThis->pheadNext)
        {
            sprintf(buf, "ID %d size %d\n",
                    pheadThis->idBlock,
                    pheadThis->cbBlock
                    );
            OutputDebugStringA(buf);
        }
    }
    return TRUE;
}



/* D B  G L O B A L  A L L O C */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalAlloc
    %%Contact: lenoxb

    Replacement for GlobalAlloc
    Now an Internal Routine
----------------------------------------------------------------------------*/
static void * WINAPI dbGlobalAlloc(UINT uFlags, DWORD cb)
{
    /* Send "tough" requests to actual memory manager */
    if ((uFlags & GMEM_DDESHARE) || ((uFlags & GMEM_MOVEABLE) && !fMove))
        return GlobalAlloc(uFlags,cb);

    if (uFlags & GMEM_MOVEABLE)
    {
        return HgAllocateMoveable(uFlags, cb);
    }

    return (void *) PvAllocateCore(uFlags, cb);
}



/* D B  G L O B A L  F R E E */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalFree
    %%Contact: lenoxb

    Replacement for GlobalFree()
    Now an internal routine
----------------------------------------------------------------------------*/
static void * WINAPI dbGlobalFree(void * hMem)
{
    void** ppv;

    if (!fMove && FActualHandle(hMem))
        return GlobalFree(hMem);

    ppv = PpvFromHandle(hMem);
    if (ppv)
    {
        if (FreePvCore(*ppv) != NULL)
            return hMem;

        *ppv = NULL;
        return NULL;
    }

    return FreePvCore (hMem);
}


/* D B  G L O B A L  S I Z E */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalSize
    %%Contact: lenoxb

    Replacement for GlobalSize()
    Now an internal routine
----------------------------------------------------------------------------*/
static DWORD WINAPI dbGlobalSize(void * hMem)
{
    void** ppv;
    HEAD * phead;

    if (!fMove && FActualHandle(hMem))
        return GlobalSize(hMem);

    if (hMem == 0)
        return 0;

    ppv = PpvFromHandle(hMem);
    phead = GetBlockHeader(ppv ? *ppv : hMem);
    return phead ? phead->cbBlock : 0;
}



/* D B  G L O B A L  R E  A L L O C */
/*----------------------------------------------------------------------------
    %%Function: dbGlobalReAlloc
    %%Contact: lenoxb

    Replacement for GlobalReAlloc()
    Now an internal routine
----------------------------------------------------------------------------*/
static void * WINAPI dbGlobalReAlloc(void * hMem, DWORD cb, UINT uFlags)
{
    LPVOID pvNew;
    void** ppv;

    if (!fMove && FActualHandle(hMem))
        return GlobalReAlloc(hMem,cb,uFlags);

    /* REVIEW: what's supposed to happen when hMem==NULL */

    ppv = PpvFromHandle(hMem);
    if (uFlags & GMEM_MODIFY)       /* Modify block attributes */
    {
        if (uFlags & GMEM_MOVEABLE)
        {
            return HgModifyMoveable(hMem, cb, uFlags);
        }
        else
        {
            HEAD * phead;

            if (ppv == NULL)        /* Already fixed */
                return hMem;

            phead = GetBlockHeader(*ppv);
            if (phead->cLock != 0)      /* Don't realloc a locked block */
                return NULL;

            *ppv = NULL;
            return phead+1;
        }
    }

    if (ppv)
    {
        pvNew = PvReallocCore (*ppv, cb, uFlags);
        if (pvNew == NULL)
            return NULL;

        *ppv = pvNew;
        return hMem;
    }

    if (!(uFlags & GMEM_MOVEABLE))
        return NULL;

    return PvReallocCore (hMem, cb, uFlags);
}

/***********************************************
  External interface for routines that can track usage
***********************************************/
void* WINAPI dbgMallocCore(size_t cb, BOOL fTrackUsage)
{
    void* pv;

    // make sure we're initialized
    if (s_cbMemPage == 0)
        InitDebugMem();

    EnterCriticalSection(&csMine);
    pv = dbGlobalAlloc(GMEM_FIXED, cb);
    if (fTrackUsage)
        TrackHeapUsage((long)dbGlobalSize(pv));
    LeaveCriticalSection(&csMine);
    return pv;
}

void * WINAPI dbgFreeCore(void* pv, BOOL fTrackUsage)
{
    void * hRes;
    // make sure we're initialized
    if (s_cbMemPage == 0)
        InitDebugMem();
    EnterCriticalSection(&csMine);
    if (fTrackUsage)
        TrackHeapUsage(-(long)dbGlobalSize(pv));
    hRes = dbGlobalFree(pv);
    LeaveCriticalSection(&csMine);
    return hRes;
}

void* WINAPI dbgReallocCore(void* pv, size_t cb, BOOL fTrackUsage)
{
    long cbOld, cbNew;

    // make sure we're initialized
    if (s_cbMemPage == 0)
        InitDebugMem();
    EnterCriticalSection(&csMine);
    cbOld = dbGlobalSize(pv);
    pv = dbGlobalReAlloc(pv,cb,GMEM_MOVEABLE);
    if (pv && fTrackUsage)
    {
        cbNew = dbGlobalSize(pv);
        TrackHeapUsage(cbNew - cbOld);
    }
    LeaveCriticalSection(&csMine);
    return pv;
}

/**************************************************************
  Normal Public Interface
**************************************************************/

void* WINAPI dbgMalloc(size_t cb)
{
    return dbgMallocCore(cb, FALSE);
}

void* WINAPI dbgCalloc(size_t c, size_t cb)
{
    void *pMem = dbgMallocCore(cb * c, FALSE);
    if (pMem)
    {
        memset(pMem, 0, cb * c);
    }
    return pMem;
}

HLOCAL WINAPI dbgFree(void* pv)
{
    return dbgFreeCore(pv, FALSE);
}

void* WINAPI dbgRealloc(void* pv, size_t cb)
{
    return dbgReallocCore(pv, cb, FALSE);
}

static void TrackHeapUsage(long dcb)
{
    long cbAlloc=0, cbAllocMax=0;

    if (!g_fTrackHeapUsage)
        return;

    g_cbAlloc += dcb;
    g_cbAllocMax = (g_cbAllocMax > g_cbAlloc ? g_cbAllocMax : g_cbAlloc);
    cbAlloc = g_cbAlloc;
    cbAllocMax = g_cbAllocMax;
    LeaveCriticalSection(&csMine);

    Assert(cbAlloc >= 0);
    Assert(cbAllocMax >= 0);
}

//////////////////////////////////////
/// NLG (ex T-Hammer) interfaces   ///
//////////////////////////////////////

BOOL WINAPI
fNLGNewMemory(
             OUT PVOID *ppv,
             IN  ULONG cb)
{
    Assert(ppv != NULL && cb != 0);

    *ppv = dbgMalloc(cb);
    return *ppv != NULL;
}


DWORD WINAPI
NLGMemorySize(
             VOID *pvMem)
{
    Assert (pvMem != NULL);

    return dbGlobalSize(pvMem);
}

BOOL WINAPI
fNLGResizeMemory(
                IN OUT PVOID *ppv,
                IN ULONG cbNew)
{
    PVOID pv;
    Assert( ppv != NULL && *ppv != NULL && cbNew != 0 );

    // Note that the semantics of GMEM_MOVEABLE are different
    // between Alloc and ReAlloc; with ReAlloc, it only means that
    // it's OK for the realloc'ed block to start at a different location
    // than the original...
    pv = dbgRealloc(*ppv, cbNew);
    if (pv != NULL)
    {
        *ppv = pv;
    }
    return (pv != NULL);
}

VOID WINAPI
NLGFreeMemory(
             IN PVOID pvMem)
{
    Assert(pvMem != NULL);

    dbgFree(pvMem);
}

// These two are the same in retail and debug;
// find a home for the retail versions...

BOOL WINAPI
fNLGHeapDestroy(
               VOID)
{
    return TRUE;
}



/* G E T  B L O C K  H E A D E R */
/*----------------------------------------------------------------------------
    %%Function: GetBlockHeader
    %%Contact: lenoxb
tmp
    Returns memory block header associated with indicated handle.
    Generates access violation if passed an invalid handle.
------------------------------------------tmp----------------------------------*/
static HEAD * GetBlockHeader(void* pvMem)
{
    HEAD * phead = ((HEAD *) pvMem) - 1;

    Assert (!IsBadWritePtr(phead, sizeof *phead));
    return phead;
}


/* P V  A L L O C A T E  C O R E */
/*----------------------------------------------------------------------------
    %%Function: PvAllocateCore
    %%Contact: lenoxb

    Workhorse routine to allocate memory blocks
----------------------------------------------------------------------------*/
static LPVOID PvAllocateCore (UINT uFlags, DWORD cb)
{
    HEAD headNew;
    HEAD *pAllocHead;
    DWORD cbTotal, cbPadded, cbPages;


    if (fPadBlocks)
        cbPadded = PAD(cb,4);       /* For RISC platforms, makes sure the block is aligned */
    else
        cbPadded = cb;

    cbTotal = PAD(cbPadded + sizeof headNew, s_cbMemPage);

    if (fExtraReadPage)
        cbPages = cbTotal+1;
    else
        cbPages = cbTotal;
    cbPages += s_cbMemPage;

    headNew.dwTag = HEAD_TAG;
    headNew.cbBlock = cb;
    headNew.cLock = 0;
    headNew.idBlock = idBlockNext++;
    headNew.pheadNext = NULL;
    headNew.pbBase = VirtualAlloc(NULL,
                                  cbPages, MEM_RESERVE, PAGE_READWRITE
                                 );
    if (headNew.pbBase == NULL)
        return NULL;
    pAllocHead = VirtualAlloc(headNew.pbBase,
                              cbTotal, MEM_COMMIT, PAGE_READWRITE
                             );
    if (pAllocHead == NULL)
    {
        VirtualFree(headNew.pbBase, 0, MEM_RELEASE);
        return NULL;
    }
    headNew.pbBase = (LPBYTE)pAllocHead;


    if (fExtraReadPage)
    {
        if (!VirtualAlloc(headNew.pbBase+cbTotal,1, MEM_COMMIT, PAGE_READONLY))
        {
            VirtualFree(headNew.pbBase, 0, MEM_RELEASE);
            return NULL;
        }
    }

    // FUTURE: do something with PAGE_GUARD?
    if (!VirtualAlloc(headNew.pbBase + cbPages - s_cbMemPage,
                      1, MEM_COMMIT, PAGE_NOACCESS))
    {
        // the entire reserved range must be either committed or decommitted
        VirtualFree(headNew.pbBase, cbTotal, MEM_DECOMMIT);
        VirtualFree(headNew.pbBase, 0, MEM_RELEASE);
        return FALSE;
    }

    if ((uFlags & GMEM_ZEROINIT) == 0)
        memset(headNew.pbBase, bNewGarbage, cbTotal);

    pAllocHead = ((HEAD *)(headNew.pbBase + cbTotal - cbPadded));
    pAllocHead[-1] = headNew;
    AddToList(pAllocHead-1);
    return pAllocHead;
}


/* P V  R E A L L O C  C O R E */
/*----------------------------------------------------------------------------
    %%Function: PvReallocCore
    %%Contact: lenoxb

    Workhorse routine to move memory blocks
----------------------------------------------------------------------------*/
static LPVOID PvReallocCore (PVOID pvMem, DWORD cb, UINT uFlags)
{
    LPVOID pvNew;
    DWORD cbOld;

    pvNew = (LPVOID) PvAllocateCore(uFlags, cb);
    if (!pvNew)
        return NULL;

    cbOld = dbGlobalSize(pvMem);
    if (cbOld>0 && cb>0)
        memcpy(pvNew, pvMem, cbOld<cb ? cbOld : cb);

    FreePvCore (pvMem);
    return pvNew;
}


/* F R E E  P V  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FreePvCore
    %%Contact: lenoxb

    Workhourse routine to free memory blocks.
----------------------------------------------------------------------------*/
static void * FreePvCore (void* pvMem)
{
    HEAD * phead;

    if (pvMem)
    {
        phead = GetBlockHeader(pvMem);
        if (phead->cLock != 0)
            return pvMem;

        RemoveFromList(phead);
        VirtualFree(phead->pbBase, 0, MEM_RELEASE);
    }

    return NULL;
}


struct head* dbgHead(void)
{
    struct head* pheadThis = phead;

    if (pheadThis == NULL)
        return NULL;

    for (pheadThis=phead; pheadThis->pheadNext; pheadThis = pheadThis->pheadNext)
        continue;
    return pheadThis;
}

static void AddToList(struct head* pheadAdd)
{
    EnterCriticalSection(&csMine);
    pheadAdd->pheadNext = phead;
    phead = pheadAdd;
    LeaveCriticalSection(&csMine);
}

static void RemoveFromList(struct head* pheadRemove)
{
    struct head* pheadThis;
    struct head* pheadPrev;
    BOOL fFoundNode = FALSE;

    Assert(pheadRemove != NULL);

    EnterCriticalSection(&csMine);
    pheadPrev = NULL;
    for (pheadThis = phead; pheadThis; pheadThis = pheadThis->pheadNext)
    {
        if (pheadThis == pheadRemove)
        {
            if (pheadPrev == NULL)
            {
                Assert(pheadThis == phead);
                phead = pheadThis->pheadNext;
            }
            else
            {
                pheadPrev->pheadNext = pheadThis->pheadNext;
            }

            fFoundNode = TRUE;
            goto LExit;
        }

        pheadPrev = pheadThis;
    }

    LExit:
    LeaveCriticalSection(&csMine);
    Assert(fFoundNode);  // Not on the list? Never happens.
}


#else // !defined(DEBUG) && defined(NTX86) || defined (M_ALPHA)
void    * WINAPI dbgCalloc(size_t c, size_t cb)
{
    void *pMem = dbgMalloc(cb * c);
    if (pMem)
    {
        memset(pMem, 0, cb * c);
    }
    return pMem;
}

#endif //defined(DEBUG) && defined(NTX86) || defined (M_ALPHA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\thwbdef.hpp ===
//+---------------------------------------------------------------------------
//
//
//  THWBDEF.HPP - contain different definition use in Thai Word Break.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBDEF_HPP_
#define _THWBDEF_HPP_
#include <windows.h>
#include "thwbplat.h"

#define THAI_Ko_Kai					0x0e01
#define THAI_Kho_Rakhang            0x0e06
#define THAI_Cho_Ching              0x0e09
#define THAI_So_So                  0x0e0b
#define THAI_Tho_NangmonTho         0x0e11
#define THAI_Pho_Phung              0x0e1c
#define THAI_Fo_Fa                  0x0e1d
#define THAI_Fo_Fan                 0x0e1f
#define THAI_Pho_Samphao            0x0e20
#define THAI_Ho_Hip                 0x0e2b
#define THAI_Ho_Nok_Huk				0x0e2e
#define THAI_Sign_PaiYanNoi         0x0e2f
#define THAI_Vowel_Sara_A           0x0e30
#define THAI_Vowel_Sign_Mai_HanAkat 0x0e31
#define THAI_Vowel_Sara_AA          0x0e32
#define THAI_Vowel_Sign_Sara_Am		0x0e33
#define THAI_Vowel_Sara_I           0x0e34
#define THAI_Vowel_Sara_II          0x0e35
#define THAI_Sara_Ue                0x0e36
#define THAI_Sara_Uee               0x0e37
#define THAI_Vowel_Sign_Phinthu		0x0e3a
#define THAI_Vowel_Sara_E           0x0e40
#define THAI_Vowel_Sara_AI_MaiMaLai 0x0e44
#define THAI_Vowel_LakKhangYao      0x0e45
#define THAI_Vowel_MaiYaMok         0x0e46
#define THAI_Tone_MaiTaiKhu         0x0e47
#define THAI_Tone_Mai_Ek			0x0e48
#define THAI_Tone_Mai_Tri           0x0e4a
#define THAI_Thanthakhat            0x0e4c
#define THAI_Nikhahit               0x0e4d

#define POSTYPE		                304
#define POS_UNKNOWN                 (POSTYPE - 1)
#define TAGPOS_NCNM                 0x0002301
#define TAGPOS_UNKNOWN              0x012F301
#define TAGPOS_PURGE                0x0130301

#define MAXBREAK                    256

// Soundex definition.
#define APPROXIMATEWEIGHT           60

#define WB_LINEBREAK	0
#define WB_NORMAL		1
//#define WB_LINEBREAK	2	// Number 2 is also linebreak.
#define WB_SPELLER		3
#define WB_INDEX		4
#define WB_CARETBREAK   5

typedef struct THWB_STRUCT
{
	bool fThai;
	BYTE alt;
} THWB_STRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\thwbplat.h ===
//+---------------------------------------------------------------------------
//
//
//  THWBPLAT.H - contain different definition use in Thai Word Break.
//
//  History:
//      created 3/00 aarayas
//
//  2000 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBPLAT_H_
#define _THWBPLAT_H_

#ifdef _OFFICE_
#define DWORD_PTR DWORD
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\thwbint.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 5/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#include "thwbint.h"
#include "lexheader.h"
#include "trie.h"
#include "NLGlib.h"
#include "ProofBase.h"
#include "ctrie.hpp"
#include "cthwb.hpp"
#include "thwbdef.hpp"

HINSTANCE g_hInst;

static PTEC retcode(int mjr, int mnr) { return MAKELONG(mjr, mnr); }
#define lidThai 0x41e

// class trie.
//CTrie trie;

// class CThaiWordBreak
CThaiWordBreak* thaiWordBreak = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakInit
//
//  Synopsis:   Initialize Thai Word Break - initialize variables of Thai Word Break.
//
//  Arguments:  szFileName - contain the path of the word list lexicon.
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
#if defined (NGRAM_ENABLE)
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameSentStruct, WCHAR* szFileNameTrigram)
#else
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameTrigram)
#endif
{
	if (thaiWordBreak == NULL)
		{
		thaiWordBreak = new CThaiWordBreak;
		if (thaiWordBreak == NULL)
			return retcode(ptecIOErrorMainLex, ptecFileRead);
		}

#if defined (NGRAM_ENABLE)
    return thaiWordBreak->Init(szFileName, szFileNameSentStruct, szFileNameTrigram);
#else
    return thaiWordBreak->Init(szFileName, szFileNameTrigram);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakInitResource
//
//  Synopsis:   Initialize Thai Word Break - initialize variables of Thai Word Break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/2000 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
PTEC WINAPI ThaiWordBreakInitResource(LPBYTE pThaiDic, LPBYTE pThaiTrigram)
{
	if (thaiWordBreak == NULL)
	{
		thaiWordBreak = new CThaiWordBreak;
		if (thaiWordBreak == NULL)
			return retcode(ptecIOErrorMainLex, ptecFileRead);
	}

    return thaiWordBreak->InitRc(pThaiDic, pThaiTrigram);
}

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakTerminate
//
//  Synopsis:   Terminate Thai Word Break - does the cleanup for Thai Word Break.
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void WINAPI ThaiWordBreakTerminate()
{
	if (thaiWordBreak)
	{
	    thaiWordBreak->UnInit();
		delete thaiWordBreak;
		thaiWordBreak = NULL;
	}
}

//+---------------------------------------------------------------------------
//
//  Function:   ThaiWordBreakSearch
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 6/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI ThaiWordBreakSearch(WCHAR* szWord, DWORD* pdwPOS)
{
	if (thaiWordBreak == NULL)
		return FALSE;

    return thaiWordBreak->Find(szWord, pdwPOS);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_FindWordBreak
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 7/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->FindWordBreak(wzString,iStringLen, pBreakPos, iBreakLen, (BYTE) mode, true);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_IndexWordBreak
//
//  Synopsis:   Search to see if the word is in.
//
//  Arguments:  szWord - the word to search for
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakLen)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->IndexWordBreak(wzString,iStringLen, pBreakPos, pThwb_Struct, iBreakLen);
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_FindAltWord
//
//  Synopsis:
//
//  Arguments:
//		pBreakPos - array of 5 byte.
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI THWB_FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos)
{
	if (thaiWordBreak == NULL)
		return 0;

    return thaiWordBreak->FindAltWord(wzWord,iWordLen,Alt,pBreakPos);

}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_CreateThwbStruct
//
//  Synopsis:   
//
//  Arguments:  
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
THWB_STRUCT* WINAPI THWB_CreateThwbStruct(unsigned int iNumStruct)
{
	unsigned int i = 0;
	THWB_STRUCT* pThwb_Struct = NULL;
	pThwb_Struct = new THWB_STRUCT[iNumStruct];

	if (pThwb_Struct)
	{
		for(i=0;i < iNumStruct; i++)
		{
			pThwb_Struct[i].fThai = false;
			pThwb_Struct[i].alt = 0;
		}
	}
	return pThwb_Struct;
}

//+---------------------------------------------------------------------------
//
//  Function:   THWB_DeleteThwbStruct
//
//  Synopsis:   
//
//  Arguments:  
//
//  Modifies:
//
//  History:    created 3/00 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
void WINAPI THWB_DeleteThwbStruct(THWB_STRUCT* pThwb_Struct)
{
	if (pThwb_Struct)
		delete pThwb_Struct;
	pThwb_Struct = NULL;
}



//+---------------------------------------------------------------------------
//
//  Function:   ThaiSoundEx
//
//  Synopsis:
//
//  Arguments:
//
//  Modifies:
//
//  History:    created 8/99 aarayas
//
//  Notes:
//
//----------------------------------------------------------------------------
int WINAPI ThaiSoundEx(WCHAR* word)
{
//        ::MessageBoxW(0,L"Soundex called",L"THWB",MB_OK);
//        return 0;
	if (thaiWordBreak == NULL)
		return 0;
    return thaiWordBreak->Soundex(word);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\thwbint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBINT_H_
#define _THWBINT_H_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "ProofBase.h"						// Include for definition of PTEC.
#include "thwbdef.hpp"

#define VERSIONMAJOR 1
#define VERSIONMINOR 0

#if defined(__cplusplus)
extern "C" {
#endif

#if defined (NGRAM_ENABLE)
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameSentStruct, WCHAR* szFileNameTrigram);
#else
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameTrigram);
#endif
PTEC WINAPI ThaiWordBreakInitResource(LPBYTE pThaiDic, LPBYTE pThaiTrigram);
void WINAPI ThaiWordBreakTerminate();
BOOL WINAPI ThaiWordBreakSearch(WCHAR* szWord, DWORD* pdwPOS);
int WINAPI THWB_FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode);
int WINAPI ThaiSoundEx(WCHAR* word);

int WINAPI THWB_IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax);
int WINAPI THWB_FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);
THWB_STRUCT* WINAPI THWB_CreateThwbStruct(unsigned int iNumStruct);
void WINAPI THWB_DeleteThwbStruct(THWB_STRUCT* pThwb_Struct);

#if defined(__cplusplus)
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\ctplus0.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.  All Rights Reserved.
//
//  File:       ctplus.h
//
//  Contents:   Local definitions for ctplus.c
//
//  History:    23-May-96   pathal      Created.
//              11-Nov-97   Weibz       Add Thai char
//
//---------------------------------------------------------------------------

#ifndef _CTPLUS_0_H_
#define _CTPLUS_0_H_

#define HC       0x01                             // Hiragana char
#define IC       0x02                             // Ideograph char
#define KC       0x03                             // Katakana char
#define WS       0x04                             // Word seperator
#define VC       0x05                             // Hankaku (variant) char
#define PS       0x06                             // Phrase seperator
#define CH       0x07                             // Code page 0 - ASCII Char.

BYTE
GetCharType(WCHAR wc);

// Declare character types transitions
// Intuitively frequency ordered
//
typedef enum _CT {
   CT_START       = 0x00,
   CT_HIRAGANA    = 0x01,
   CT_KANJI       = 0x02,
   CT_KATAKANA    = 0x03,
   CT_WORD_SEP    = 0x04,
   CT_HANKAKU     = 0x05,
   CT_PHRASE_SEP  = 0x06,
   CT_ROMAJI      = 0x07,
} CT;


// Declare node types transitions
// Intuitively frequency ordered
//
typedef enum _WT {
   WT_START       = 0x00,
   WT_WORD_SEP    = 0x01,
   WT_PHRASE_SEP  = 0x02,
   WT_ROMAJI      = 0x03,
   WT_REACHEND    = 0x04,
} WT;


#define CT_MAX    0x08

#endif // _CTPLUS_0_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\proofbase.h ===
/********************************************************************
  ProofBase.h - Base API definitions for CSAPI, CTAPI, & CHAPI
    Speller, Thesaurus, and Hyphenator

  Version 3.0 - all api's

    History:
    5/97    DougP   Created
    12/97   DougP   Copied from ProofAPI.h and Separated into tool section files
	5/99	aarayas	Copied Vendor.h into proofbase to elminate many files to copied for Thai wordbreak.

    The Natural Language Group maintains this file.

The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1997-1998 Microsoft Corporation.  All rights reserved.
********************************************************************/

#if !defined(PROOFBASE_H)
#define PROOFBASE_H

#pragma pack(push, proofapi_h, 8)   // default alignment

// The Following code was taken from NLG group vendor.h
#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll

#define vendoridPriberam             75     /* Priberam Informtica - Portuguese - 7/13/98 */
#define vendoridTranquility     76  /* Tranquility Software - Vietnamese - 7/22/98 */

#define vendoridColtec          77  /* Coltec - Arabic - added 8/17/98 */

/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */


  // you may wish to include lid.h for some convenient langid defs
#if !defined(lidUnknown)
#   define lidUnknown   0xffff
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------- */

/* hardcoded ordinals are the exported dll entry points */
// individual def files have these as well so be sure to change them
// if you change these
#define idllProofVersion        20
#define idllProofInit           21
#define idllProofTerminate      22
#define idllProofOpenLex        23
#define idllProofCloseLex       24
#define idllProofSetOptions     25
#define idllProofGetOptions     26

typedef unsigned long PTEC;     // ptec

/******************* Proofing Tool Error Codes ************************/
    /* Major Error Codes in low two bytes (WORD) of PTEC */
enum {
    ptecNoErrors,
    ptecOOM,            /* memory error */
    ptecModuleError,    /* Something wrong with parameters, or state of spell module. */
    ptecIOErrorMainLex,  /* Read,write,or share error with Main Dictionary. */
    ptecIOErrorUserLex,  /* Read,write,or share error with User Dictionary. */
    ptecNotSupported,   /* No support for requested operation */
    ptecBufferTooSmall, /* Insufficient room for return info */
    ptecNotFound,       /* Hyphenator and Thesaurus only */
    ptecModuleNotLoaded,    /* underlying module not loaded (Glue Dll's) */
};

/* Minor Error Codes in high two bytes of PTEC */
/* (Not set unless major code also set) */
enum {
    ptecModuleAlreadyBusy=128,  /* For non-reentrant code */
    ptecInvalidID,              /* Not yet inited or already terminated.*/
    ptecInvalidWsc,             /* Illegal values in WSC struct (speller only) */
    ptecInvalidMainLex,     /* Mdr not registered with session */
    ptecInvalidUserLex,     /* Udr not registered with session */
    ptecInvalidCmd,             /* Command unknown */
    ptecInvalidFormat,          /* Specified dictionary not correct format */
    ptecOperNotMatchedUserLex,  /* Illegal operation for user dictionary type. */
    ptecFileRead,               /* Generic read error */
    ptecFileWrite,              /* Generic write error */
    ptecFileCreate,             /* Generic create error */
    ptecFileShare,              /* Generic share error */
    ptecModuleNotTerminated,    /* Module not able to be terminated completely.*/
    ptecUserLexFull,            /* Could not update Udr without exceeding limit.*/
    ptecInvalidEntry,           /* invalid chars in string(s) */
    ptecEntryTooLong,           /* Entry too long, or invalid chars in string(s) */
    ptecMainLexCountExceeded,   /* Too many Mdr references */
    ptecUserLexCountExceeded,   /* Too many udr references */
    ptecFileOpenError,          /* Generic Open error */
    ptecFileTooLargeError,      /* Generic file too large error */
    ptecUserLexReadOnly,        /* Attempt to add to or write RO udr */
    ptecProtectModeOnly,        /* (obsolete) */
    ptecInvalidLanguage,        /* requested language not available */
};


#define ProofMajorErr(x) LOWORD(x)
#define ProofMinorErr(x) HIWORD(x)

/************* Structure def macros *************
Smoke and mirrors to allow initialization of some members when
using C++
***********************************/
#if !defined(__cplusplus)
#   define STRUCTUREBEGIN(x) typedef struct {
#   define STRUCTUREEND0(x) } x;
#   define STRUCTUREEND1(x, y) } x;
#   define STRUCTUREEND2(x, y, z) } x;
#   define STRUCTUREEND3(x, y, z, w) } x;
#else
#   define STRUCTUREBEGIN(x) struct x {
#   define STRUCTUREEND0(x) };
#   define STRUCTUREEND1(x, y) public: x() : y {} };
#   define STRUCTUREEND2(x, y, z) public: x() : y, z {} };
#   define STRUCTUREEND3(x, y, z, w) public: x() : y, z, w {} };
#endif

typedef DWORD PROOFVERNO;   // version

  /* Proof Information Structure - return info from ToolVersion */
STRUCTUREBEGIN(PROOFINFO)   // info
    WCHAR           *pwszCopyright; /* pointer to copyright buffer -
                                            can be NULL if size is zero */
    PROOFVERNO  versionAPI;   /* API */
    PROOFVERNO  versionVendor;  /* includes buildnumber */
    VENDORID        vendorid;   /* from vendor.h */
      /* size of copyright buffer in chars - client sets */
    DWORD           cchCopyright;   /* no error if too small or zero */
    DWORD           xcap;   /* tool dependent */
STRUCTUREEND2(PROOFINFO, pwszCopyright(0), cchCopyright(0))

/* xcap is the bitwise-or of */
enum {
    xcapNULL                    =   0x00000000,
    xcapWildCardSupport         =   0x00000001, // Speller only
    xcapMultiLexSupport         =   0x00000002,
    xcapUserLexSupport          =   0x00000008, // a must for spellers
    xcapLongDefSupport          =   0x00000010, // Thesaurus only
    xcapExampleSentenceSupport  =   0x00000020, // Thesaurus only
    xcapLemmaSupport            =   0x00000040, // Thesaurus only
    xcapAnagramSupport          =   0x00000100, // Speller only
};  // xcap

typedef void * PROOFLEX;    // lex

typedef enum {
    lxtChangeOnce=0,
    lxtChangeAlways,
    lxtUser,
    lxtExclude,
    lxtMain,
    lxtMax,
    lxtIgnoreAlways=lxtUser,
} PROOFLEXTYPE; // lxt


  // note this API does not support external user dictionaries with
  // Change (lxtChangeAlways or lxtChangeOnce) properties
  // It does support either UserLex (the norm) or Exclude types
  // Opening a udr with type Exclude automatically makes it apply to
  // the entire session
STRUCTUREBEGIN(PROOFLEXIN)  /* Dictionary Input Info - lxin - all parameters in only */
    const WCHAR     *pwszLex;   // full path of dictionary to open
    BOOL            fCreate;    /* create if not already exist? (UDR's only) */
    PROOFLEXTYPE    lxt;    /* lxtMain, lxtUser, or lxtExclude (Speller UDR's only) */
    LANGID          lidExpected;    // expected LANGID of dictionary
STRUCTUREEND3(PROOFLEXIN, lidExpected(lidUnknown), fCreate(TRUE), lxt(lxtMain))


STRUCTUREBEGIN(PROOFLEXOUT)    /* Dictionary Output Info - lxout */
    WCHAR       *pwszCopyright; /* pointer to copyright buffer (MDR only)
                                        -- can be NULL if size (below) is zero -
								pointer is in, contents out */
    PROOFLEX    lex;            /* [out] id for use in subsequent calls */
    DWORD       cchCopyright;   /* [in] client sets - no error if too small or zero */
    PROOFVERNO  version;        /* [out] version of lexfile - includes buildnumber */
    BOOL        fReadonly;      /* [out] set if can't be written on */
    LANGID      lid;            /* [out] LANGID actually used */
STRUCTUREEND2(PROOFLEXOUT, pwszCopyright(0), cchCopyright(0))

typedef void *PROOFID;  // id (or sid, hid, or tid)

#define PROOFMAJORVERSION(x)            (HIBYTE(HIWORD(x)))
#define PROOFMINORVERSION(x)            (LOBYTE(HIWORD(x)))
#define PROOFMAJORMINORVERSION(x)       (HIWORD(x))
#define PROOFBUILDNO(x)                 (LOWORD(x))
#define PROOFMAKEVERSION1(major, minor, buildno)    (MAKELONG(buildno, MAKEWORD(minor, major)))
#define PROOFMAKEVERSION(major, minor)  PROOFMAKEVERSION1(major, minor, 0)

#define PROOFTHISAPIVERSION             PROOFMAKEVERSION(3, 0)

STRUCTUREBEGIN(PROOFPARAMS) // xpar [in]
    DWORD   versionAPI; // API version requested
STRUCTUREEND1(PROOFPARAMS, versionAPI(PROOFTHISAPIVERSION))



/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------------

the functions in this section are for documentation only -
separate versions exist for each tool.

  ---------------------------------------------- */
/****************************************************************
*** PROOFVERSION
This is the only routine that can be called outside of a session.
ToolInit begins a session.

The version numbers are in hex format with
the high byte representing the major version number,
the next byte the minor revision number, and the
low order bytes represent an optional build number.
For example, version 1.00 is 0x01000000.  Version 2.13
is 0x020d0000.  Engines that support
this API should return 0x03000000 for iAPIVersion.

The engine ID identifies the core engine creator.  The list
in vendor.h identifies the possible values.  For example,
the Inso derived speller returns VendorIdInso.   iVendorVersion
is up to the vendor to manage and determine.

This routine may return in xcap the functionality
supported by the module.  Since modules are usually
dynamically linked, the application should read the
information and verify that required functionality is
present.
Errors:
    ptecModuleError - bad memory (can't write on pinfo)
**********************************/
// PTEC WINAPI ToolVersion(ToolInfo *pInfo);
typedef PTEC (WINAPI *PROOFVERSION) (PROOFINFO *pinfo);

/***********************************************************
*** ToolInit
This is the entry point for a session.  With the exception
of ToolVersion, this routine must return successfully before
use of any other routines.  ToolInit initializes internal
structures and resources needed for subsequent calls into the
module.  For example, SpellerInit initializes the UserLex,
ChangeOnce, and ChangeAlways built-in UDR's.  In general,
modules allocate and free resources as needed, transparent to
the application.  pToolId is the handle to those variables.
Modules store any data from the PROOFPARAMS structure internally
and do not rely on the data in the structure remaining intact.

Errors:
    ptecModuleError - bad memory (can't write on pxpar)
    ptecNotSupported - incompatible version
    ptecOOM - insufficient memory
*****************************************/
// PTEC WINAPI ToolInit(PROOFID *pToolid, const PROOFPARAMS *pxpar);
typedef PTEC (WINAPI *PROOFINIT) (PROOFID *pid, const PROOFPARAMS *pxpar);


/************************************************************
*** ToolTerminate
This function marks the end of the session.  It attempts to
close all dictionaries and free up any and all other resources
allocated by the module since ToolInit.

Do not call ToolTerminate if  ToolInit was not successful.

If fForce is TRUE, ToolTerminate is guaranteed to succeed.  If
fForce is false, it may fail.  For example, there may be errors
writing the user dictionaries out to disk.  After ToolTerminate
(whether it succeeds or fails), all other module routines with
the exception of ToolTerminate and ToolVersion are unusable
until the module is successfully reinitialized using ToolInit.

If this call fails, successful re-initialization of the module
is not guaranteed on all platforms.  In addition, failure to
successfully terminate each session may lock memory and file
resources in an unrecoverable way until terminate is successful.
If the terminate call fails, the main application should either
fix the problem (e.g., insert floppy in drive) and try to
terminate again, or should terminate using the fForce flag
switch.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
***********************************************/
// PTEC WINAPI ToolTerminate(PROOFID id, BOOL fForce);
typedef PTEC (WINAPI *PROOFTERMINATE) (PROOFID id, BOOL fForce);


/*****************************************************************
*** ToolSetOptions
Set the value of an option for a tool.  The value to set is in iOptVal.

Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolSetOptions(PROOFID id, int iOptionSelect, int iOptVal);
typedef PTEC (WINAPI *PROOFSETOPTIONS) (PROOFID id, DWORD iOptionSelect, const DWORD iOptVal);


/*****************************************************************
*** ToolGetOptions
Get the current value of an option from a tool.  Returns in *piOptVal;
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - can't write at piOptVal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolGetOptions(PROOFID id, int iOptionSelect, int *piOptVal);
typedef PTEC (WINAPI *PROOFGETOPTIONS) (PROOFID id, DWORD iOptionSelect, DWORD *piOptVal);


/*****************************************************************
*** ToolOpenLex
The dictionary file (main or user) is opened and verified, but not
necessarily loaded.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - memory error
    ptecIOErrorMainLex - Can't open or read Main Lex
    ptecIOErrorMainLex, ptecInvalidFormat
    ptecIOErrorMainLex, ptecInvalidLanguage - requested LANGID not in this lex
    ptecOOM
    ptecIOErrorUserLex, ptecUserLexCountExceeded - second exclusion dictionary
                                                 - too many Udrs
    ptecIOErrorUserLex, ptecFileOpenError
    ptecIOErrorUserLex, ptecFileCreate - couldn't create a UDR
    ptecIOErrorUserLex, ptecFileRead
    ptecIOErrorUserLex, ptecInvalidFormat
********************************************/
// PTEC WINAPI ToolOpenLex(PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
typedef PTEC (WINAPI *PROOFOPENLEX) (PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);


/*****************************************************************
*** ToolCloseLex
Closes the specified dictionary and disassociates that dictionary
from any subsequent checks.  In the case of user dictionaries,
updates the disk file (if any).  If the dictionary file cannot
be updated, the call fails unless the fForce parameter is also set.

If fForce is true, ToolCloseLex is guaranteed to successfully
remove the dictionary from the dictionary list and effectively
close the file.  In this case, it the file could not be updated,
the changes are lost, but the function is considered successful,
and therefore returns ptecNOERRORS.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError, ptecInvalidMainLex - lex is illegal
    ptecIOErrorUserLex, ptecFileWrite
    ptecIOErrorUserLex, ptecOperNotMatchedUserLex - can't close a built-in UDR
// PTEC WINAPI ToolCloseLex(PROOFID id, PROOFLEX dict, BOOL fforce);
*****************************/
typedef PTEC (WINAPI *PROOFCLOSELEX) (PROOFID id, PROOFLEX lex, BOOL fforce);
// fForce forces closing the specified user dictionary, even if the
// dictionary cannot be updated.  Has no meaning for main
// dictionaries.


/******************************** Special Glue DLL API ******************
For the glue dll's (converts the API for clients to tools that use API v1 for
speller, hyphenator, v2 for thesaurus), we need to set the name of the previous version
DLL to use - and the code page (that it can't figure out from the LANGID)
to use for any data conversion.
The glue dll's use the lid to set the code page for data conversion.

BOOL WINAPI ToolSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
*************************************************************************/
#define idllProofSetDllName     19
typedef BOOL (WINAPI *PROOFSETDLLNAME)(const WCHAR *pwszDllName, const UINT uCodePage);


#if defined(__cplusplus)
}
#endif
#pragma pack(pop, proofapi_h)   // restore to whatever was before

#endif // PROOFBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\vendor.h ===
/*------------------------------------------------------------
    vendor.h - Unified vendor include file

        2/5/97  dougp   created

    Note:  The Natural Language Group maintains this file.
        Please contact us with change requests.
------------------------------------------------------------*/

#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll

#define vendoridPriberam             75     /* Priberam Informtica - Portuguese - 7/13/98 */
#define vendoridTranquility     76  /* Tranquility Software - Vietnamese - 7/22/98 */

#define vendoridColtec          77  /* Coltec - Arabic - added 8/17/98 */

/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\trie.c ===
#if !defined(LANGUAGE_IDENTIFICATION)
#   include "precomp.h"
#endif
#include "trie.h"
#ifdef LANGUAGE_IDENTIFICATION
#   include "mymalloc.h"
#endif

#ifndef WINCE
#   include "assert.h"
#else
#   define assert(x)
#endif

#include "thwbplat.h"

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
    LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	//MessageBoxW(0,L"Step#1",L"Trie.C",MB_OK);
    if (lpTrieStats == NULL)
        return(NULL);

    // Check the version number.  This code currently only supports version 1 tries
	//MessageBoxW(0,L"Step#2",L"Trie.C",MB_OK);
    if (lpTrieStats->version > 1)
        return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //
	//MessageBoxW(0,L"Step#3",L"Trie.C",MB_OK);
    if (!fNLGNewMemory(&lpTrieCtrl, sizeof(TRIECTRL)))
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //
	//MessageBoxW(0,L"Step#4",L"Trie.C",MB_OK);
    lpByte += lpTrieStats->cbHeader;
    lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

    lpwTables = (LPWORD)(lpTrieStats+1);

    lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
    lpwTables += lpTrieStats->cSROffsetsCodesMax;

    if ((DWORD_PTR) lpwTables & 0x02)                           // Deal with possible data mis-alignment
        lpwTables++;

	lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
	lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

	lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
	lpwTables += (2 * lpTrieStats->cUniqueTags);

	lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

    lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    assert((LPBYTE)lpwTables == (LPBYTE)lpTrieStats + lpTrieStats->cbHeader);

    //
    // Init trie pointers
    //

    lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

    return (void *)lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //

    NLGFreeMemory(lpTrieCtrl);

}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, WORD *pcCodes, unsigned char *pbData)
{
        int cBytes = 0;
        WORD wCode = 0, wiSymbol = 0;

        /* At each stage in this loop, we're trying to see if we've got a length-n code.
        dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
        we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
        the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
                wCode += *pbData++;
                ++cBytes;
        if (wCode < *pcCodes)
        {
                        break;
                }
                wiSymbol += *pcCodes;
                wCode -= *pcCodes++;
                wCode <<= 8;
        }

        /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
        dwiSymbol, because we've already added the counts of the shorter codes to it. */

        wiSymbol += wCode;

        *piSymbol = wiSymbol;

        return cBytes;
}

DWORD Get3ByteAddress(BYTE *pb)
{
        return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the first SR segment */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
        }

        /* Decompress the char/flags */

        lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
        lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
        lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

        // Decompress skip enumeration

        if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
        {
        // Values greater than 127 are really 15 or 21 bit values.

            dwCode = (DWORD) *lpTrieScan->lpbNode++;

            if (dwCode >= 0x00c0)
            {
                dwCode  = ((dwCode & 0x003f) << 15);
                dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
            }
            else if (dwCode >= 0x0080)
                dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

            lpTrieScan->cSkipWords = dwCode;
        }

        /* Code to decompress enumeration goes here */

        if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
        {
        // Values greater than 127 are really 15 or 21 bit values.

            dwCode = (DWORD) *lpTrieScan->lpbNode++;

            if (dwCode >= 0x00c0)
            {
                dwCode  = ((dwCode & 0x003f) << 15);
                dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
            }
            else if (dwCode >= 0x0080)
                dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

            lpTrieScan->cWords = dwCode;

        // Decompress the tagged enumeration counts

            wMask = 1;
            for (iTag = 0; iTag < MAXTAGS; iTag++)
            {
                if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
                {
                // Values greater than 127 are really 15 or 21 bit values.

                    dwCode = (DWORD) *lpTrieScan->lpbNode++;

                    if (dwCode >= 0x00c0)
                    {
                        dwCode  = ((dwCode & 0x003f) << 15);
                        dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                        dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                    }
                    else if (dwCode >= 0x0080)
                        dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                    lpTrieScan->aTags[iTag].cTag = dwCode;
                }
                else
                    lpTrieScan->aTags[iTag].cTag = 0;

                wMask <<= 1;
            }
        }
        else
                lpTrieScan->cWords = 0;

        // Any tagged data for this node follows the counts

        lpTrieScan->wMask = 0;

        if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
        {
        // If there is only one tagged field, the mask byte won't be stored

                if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
                        bMask = lpTrieCtrl->lpTrieStats->wDataMask;
                else
                        bMask = *lpTrieScan->lpbNode++;

        // Now that we know which elements are stored here, pull them in their proper place

                wMask = 1;
                for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
                {
                        if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
                        {
                                lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                                lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                                lpTrieScan->wMask |= wMask;
                        }

                        bMask  &= ~wMask;
                        wMask <<= 1;
                }
        }

        // There are two flavors of right pointers: Multiref and Skip.

        if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
        {
            if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
            {
                lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
                wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
            }
            else
            {
                /* Multiref: The down pointer is encoded directly */

                lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
                lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
            }
        }
        else
                lpTrieScan->lpbRight = NULL;

        // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
        // Each requires different decompression

        if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
        {
                // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

                lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
                lpTrieScan->lpbNode += 3;
        }
        else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
        {
                /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

                assert(lpTrieScan->wFlags&TRIE_NODE_END);

                lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
        }
        else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
        {
                /* Multiref: The down pointer is encoded directly */

                lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                        lpTrieScan->lpbNode);

                lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
        else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
        {
                /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
                into this singleref segment.  So we have to keep the old one around so we can add to it */

                lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                        lpTrieScan->lpbNode);

                if (lpTrieScan->lpbSRDown == 0)
                {
                        lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
                }

                wOffset = lpTrieCtrl->lpwSROffsets[wCode];
                lpTrieScan->lpbSRDown += wOffset;
                lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
        }
        else
                lpTrieScan->lpbDown = NULL;

    // We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

        if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
            lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
    // Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
        // If we can follow a right pointer, do so, else fail

            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

    // Either we're at a soft EOS or we've followed a right pointer.
    // Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

// If there isn't a right pointer or if the target letter is alphabetically less then
// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
        /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
            return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
            return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

    // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
    // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

        // If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

        // Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
        // Now, follow the skip pointer if exist and the alphabetic character is greater then
        // the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
        // use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

            // This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

    // If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
    // If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

    // Remember this node's character

        pwszWord[ich] = ts.wch;

    // If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

    // Get the count of words in this subtree.

        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

    // Scan to the right until the word count of the subtree would be greater than or equal to the index
    // we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
    // If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;

                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, wchar_t *pwszWord, int *piStart)
{
        TRIESCAN        ts;
        int                     ich = 0;
        int                     cnt;
        BOOL            bValid;

        memset(&ts, 0, sizeof(TRIESCAN));
   *piStart = 0;

        if (!TrieGetNextState(ptc, &ts))
                return 0;

        // Deal with special case of empty string

        if (pwszWord && !*pwszWord)
                return ptc->lpTrieStats->cWords;

        do
        {
        // Get the count of words below this prefix

                cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

        // If the node we just arrived at is valid, increment the count

                bValid = ts.wFlags & TRIE_NODE_VALID;

        // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
        // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

                if (ts.wch == pwszWord[ich])
                {
                        ich++;

                // If we reached the end of prefix, return the count remaining below

                        if (pwszWord[ich] == L'\0')
                        {
                                if (bValid)
                                        cnt++;

                                return cnt;
                        }

                // Try going down a level

                        if (!TrieGetNextState(ptc, &ts))
                                return 0;
                }
                else
                {
                // Add the sub tree count.

                   *piStart += cnt;

                // Try the next letter in this state

                        if (!TrieGetNextNode(ptc, &ts))
                                return 0;
                }

                if (bValid)
                        (*piStart)++;

        } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
        TRIESCAN        ts    = *pts;
        DWORD           cTags = 0;

        if (!TrieGetNextState(ptc, &ts))
                return cTags;

        do
        {
                if (ts.wFlags & wMask)
                        cTags++;

                cTags += CountTags(ptc, &ts, wMask, iTag);
        } while (TrieGetNextNode(ptc, &ts));

        return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, wchar_t *pwszWord, int iTag)
{
        TRIESCAN        ts;
        int                     ich = 0;
        int                     index = 0;
        BOOL            bValid;
        DWORD           wMask = 1 << iTag;

        memset(&ts, 0, sizeof(TRIESCAN));

        if (!TrieGetNextState(ptc, &ts))
                return FALSE;

        do
        {
                bValid = ts.wFlags & wMask;

        // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
        // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

                if (ts.wch == pwszWord[ich])
                {
                        ich++;

                // If we reached the end of word at a valid state, return the index

                        if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                                return index;

                // Try going down a level

                        if (!TrieGetNextState(ptc, &ts))
                                return -1;
                }
                else
                {
                // Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

                        index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

                        if (!TrieGetNextNode(ptc, &ts))
                                return -1;
                }

        // If the node we just visited was valid, increment the index

                if (bValid)
                        index++;
        } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
        TRIESCAN        ts;
        int                     ich = 0;
        DWORD           cTags;
        DWORD           wMask = 1 << iTag;

        memset(&ts, 0, sizeof(TRIESCAN));

        if (!TrieGetNextState(ptc, &ts))
                return FALSE;

        do
        {
        // If we're at the end of the buffer, fail

                if (ich + 1 >= cwc)
                        return FALSE;

        // Remember this node's character

                pwszWord[ich] = ts.wch;

        // If we're on a valid word AND we've reached the index we're looking for, exit the loop

                if (ts.wFlags & wMask)
                {
                        if (!nIndex)
                                break;

                        nIndex--;
                }

        // Get the count of words in this subtree.

                cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

        // Scan to the right until the word count of the subtree would be greater than or equal to the index
        // we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

                if (nIndex < cTags)
                {
                        if (!TrieGetNextState(ptc, &ts))
                                return FALSE;

                        ich++;                                                  // Advance the character position
                }
                else
                {
                        nIndex -= cTags;

                        if (!TrieGetNextNode(ptc, &ts))
                                return FALSE;
                }
        } while (TRUE);

        pwszWord[++ich] = L'\0';                        // Null terminate the string
        return ts.wFlags & wMask;                       // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
)
{
        TRIESCAN        ts;
        int             iTag;
        WORD            wMask;
        BYTE            bMask = ptc->lpTrieStats->wTagsMask;

        if (!TrieCheckWord(ptc, &ts, pwszWord))
                return FALSE;

        if (ts.wFlags & TRIE_NODE_TAGGED)
        {
                wMask = 1;
                for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
                {
                        if (ts.wMask & wMask)
                        {
                                pdw[iTag] = ts.aTags[iTag].dwData;
                                bMask |= wMask;
                        }

                        wMask <<= 1;
                }
        }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 1
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  lpwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, set *pTrieScan to all zeros.  Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
TrieEnumerate(
        LPTRIECTRL lpTrieCtrl,          // Trie to enumerate
        LPTRIESCAN lpTrieScan,  // structure holding starting point, all-zero for whole trie
        wchar_t *pwszWord,                      // buffer to hold words being enumerated
        void *pvParam,                          // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                        // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                        // Trie in which to find indexed word
        DWORD           nIndex,                 // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int                     cwc                             // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                        // Trie in which to find word index
        wchar_t    *pwszWord,           // Word for which we're looking
        int                     tag                             // Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                        // Trie in which to find indexed word
        DWORD           nIndex,                 // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int                     cwc,                    // Max characters in buffer (including NULL)
        int                     tag                             // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                        // Trie in which to find prefix range
        wchar_t    *pwszWord,           // Prefix for which we're looking
        int                *piStart                     // Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                            // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,                      // buffer to hold words being enumerated
        void *pvParam,                          // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>


#include <cierror.h>
#include <query.h>
#include <except.hxx>

#include <assert.h>

#include <usp10.h>

#include  "ctplus0.h"

#undef Assert
#define Assert(a)

// Base services
//

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\wb_asserts.c ===
#include "WB_Asserts.h"

//||||||||||||||||||||||||||||||| D E B U G  S T U F F |||||||||||||||||||||||||||||||||||||

#if defined(_DEBUG)


#include <stdio.h>


BOOL FAlertContinue(char *pchAlert)
{
    int iMsgBoxRetVal = MessageBoxA(NULL, "Continue", pchAlert, MB_YESNO|MB_ICONEXCLAMATION);
    
    return (IDYES == iMsgBoxRetVal);
}

BOOL g_fDebugAssertsOff = FALSE;

void AssertCore(BOOL f, char *pChErrorT, char *pchFile, int nLine)
{
if ((!g_fDebugAssertsOff) && (!f))
	{
	int iMsgBoxRetVal;
	char pChError[256];

	sprintf(pChError,"%s ! %s : %d",pChErrorT, pchFile, nLine);

	iMsgBoxRetVal = MessageBoxA(NULL, " Assertion Failure: thwb.dll. YES=Go On, NO=DEBUG, CANCEL=Asserts OFF", pChError, MB_YESNOCANCEL|MB_ICONEXCLAMATION);

	if (IDNO == iMsgBoxRetVal)
		{
		__asm int 3
		}
	else if (IDCANCEL == iMsgBoxRetVal)
		{
		g_fDebugAssertsOff = TRUE;
		}
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\sth\wb_asserts.h ===
#ifndef _WORDBREAKASSERT_H_
#define _WORDBREAKASSERT_H_

#include <windows.h>

#if defined(__cplusplus)
extern "C" {
#endif

// Debugging stuff goes here
#if defined(_DEBUG)

#include <stdio.h>
void __cdecl AssertCore(BOOL f, char *pChErrorT, char *pchFile, int nLine);
#define Assert(_f_, _pChErrorT_) AssertCore(_f_, _pChErrorT_, __FILE__ , __LINE__)
BOOL FAlertContinue(char *pchAlert);

#else

#define Assert(_f_, _pChErrorT_)
#define FAlertContinue(_pchAlert_) TRUE
#endif


#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\ctplus0.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999.
//
//  File:       ctplus.c
//
//  Contents:   Contains character type (orthography) data and routine
//                    to get at it.
//
//  History:    23-May-96   pathal      Created.
//              11-Nov-97   weibz       Add Thai char support
//
//---------------------------------------------------------------------------


//#include <windows.h>
//#include "ctplus0.h"

#include "pch.cxx"


//----------------------------------------------------------------------------
//  s_abBreakList
//
//  This array starts at -1, so that EOF can be found in the array.  It
//  depends on (EOF == -1) being true.  Also, all references to it must be
//  of the form (s_abCharTypeList+1)[x]
//
//  000
//  EOF
//
//  001-080
//  The lower 7F entries from the ASCII Code Page (0000-00ff) are mapped in place
//  (ex. UNICODE 0009 (HT) == 009)
//      The word characters are: $,0-9,A-Z,_,a-z
//      The word separators are: bs,tab,lf,vtab,cr,spc,
//                               ",#,%,&,',(,),*,+,comma,-,/,
//                               :,;,<,=,>,@,[,],`
//      The phrase seperators are: !,.,?,\,^,{,|,},~
//
//  NOTE: Symbols are treated as WS or PS.
//
//  081-0FF
//  The lower 7E entries from the Half Width Variant Code Page (FF00-FF7F) are
//  mapped to 081-0FF.
//
//  100-1FF
//  The lower FF entries from the General Punctuation Code Page (2000-2044) are
//  mapped to 100-1ff.
//
//  200-2FF
//  The lower FF entries from the CJK Auxiliary Code Page (3000-30FF) are mapped
//  to 200-2ff.
//
// pathal - 5/20/96
// Special default character processing for selection
// The following is a list of white space characters that T-Hammer will not right select on:
//          0x0009 (tab), 0x0020 (ansi space), 0x2005 (narrow space, 0x3000 (wide space)
// (Note: see AnalyzeHPBs for special end SPB processing of adjacent white space)
// The following is a list of nls characters to be treated as text by T-Hammer:
//      (in other words T-Hammer will neither right nor left-select on them):
//          0x001F (non-required hyphen), 0x0027 (single quote), 0x2019 (right quote),
//          0x200C (non-width optional break), 0x200D (non-width no break)
//----------------------------------------------------------------------------

const BYTE
s_abCharTypeList[0x301] =
    {
        (BYTE) -1,                                       // EOF (-1)
        PS,PS,PS,PS,PS,PS,PS,PS, WS,WS,WS,WS,PS,WS,PS,PS, // 000 - 015
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,CH,PS, // 016 - 031
        WS,PS,WS,WS,CH,CH,WS,PS,                          // sp ! " # $ % & '
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  0 1 2 3 4 5 6 7
        CH,CH,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  @ A B C D E F G
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  H I J K M L N O
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  P Q R S T U V Y
        CH,CH,CH,WS,PS,WS,PS,CH,                          //  X Y Z [ \ ] ^ _
        WS,CH,CH,CH,CH,CH,CH,CH,                          //  ` a b c d e f g
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  h i j k m l n o
        CH,CH,CH,CH,CH,CH,CH,CH,                          //  p q r s t u v y
        CH,CH,CH,PS,PS,PS,CH,PS,                          //  x y z { | } ~ del
        WS,PS,WS,WS,CH,CH,WS,WS,                          //  FF00-FF07 (sp ! " # $ % & ')
        WS,WS,WS,WS,WS,WS,PS,WS,                          //  ( ) * + , - . /
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  0 1 2 3 4 5 6 7
        VC,VC,WS,WS,WS,WS,WS,PS,                          //  8 9 : ; < = > ?
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  @ A B C D E F G
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  H I J K M L N O
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  P Q R S T U V Y
        VC,VC,VC,WS,VC,WS,PS,VC,                          //  X Y Z [ \ ] ^ _
        WS,VC,VC,VC,VC,VC,VC,VC,                          //  ` a b c d e f g
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  h i j k m l n o
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  p q r s t u v y
        VC,VC,VC,PS,PS,PS,VC,PS,                          //  x y z { | } ~ del
        VC,PS,WS,WS,WS,WS,VC,VC,                          //  FF60-FF67
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF68-FF6F
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF77
        VC,VC,VC,VC,VC,VC,VC,VC,                          //  FF70-FF7E
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2000-2007
        WS,WS,WS,WS,CH,CH,WS,WS,                          //  2008-200F
        WS,CH,WS,WS,WS,KC,PS,WS,                          //  2010-2017
        WS,CH,WS,WS,WS,WS,WS,WS,                          //  2018-201F
        WS,WS,PS,PS,PS,PS,PS,CH,                          //  2020-2027
        PS,PS,CH,CH,CH,CH,CH,PS,                          //  2028-202F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2030-2037
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  2038-203F
        WS,WS,WS,PS,WS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2040-204F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2050-205F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2060-206F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2070-207F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2080-208F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  2090-209F
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20A0-20AF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20B0-20BF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20C0-20CF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20D0-20DF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20E0-20EF
        PS,PS,PS,PS,PS,PS,PS,PS, PS,PS,PS,PS,PS,PS,PS,PS, //  20F0-20FF
        WS,WS,PS,HC,HC,IC,IC,HC,                          //  3000-3007
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3008-300F
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3010-3017
        WS,WS,WS,WS,WS,WS,WS,WS,                          //  3018-301F
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3020-3027
        HC,HC,HC,HC,HC,HC,HC,HC,                          //  3028-302F
        WS,HC,IC,HC,IC,HC,HC,HC,                          //  3030-3037
        PS,PS,PS,PS,PS,PS,PS,WS,                          //  3038-303F
        WS,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3040-304F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3050-305F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3060-306F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3070-307F
        HC,HC,HC,HC,HC,HC,HC,HC, HC,HC,HC,HC,HC,HC,HC,HC, //  3080-308F
        HC,HC,HC,HC,HC,PS,PS,PS,                          //  3090-3097
        PS,HC,HC,WS,WS,HC,HC,PS,                          //  3098-309F
        WS,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30A0-30AF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30B0-30BF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30C0-30CF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30D0-30DF
        KC,KC,KC,KC,KC,KC,KC,KC, KC,KC,KC,KC,KC,KC,KC,KC, //  30E0-30EF
        KC,KC,KC,KC,KC,KC,IC,PS,                          //  30F0-30F7
        PS,PS,PS,WS,KC,KC,KC,PS,                          //  30F8-30FF
    };

//
// Type C1 bits are:
//
//   C1_UPPER                  0x0001      // upper case
//   C1_LOWER                  0x0002      // lower case
//   C1_DIGIT                  0x0004      // decimal digits             1
//   C1_SPACE                  0x0008      // spacing characters         2
//   C1_PUNCT                  0x0010      // punctuation characters     4
//   C1_CNTRL                  0x0020      // control characters         8
//   C1_BLANK                  0x0040      // blank characters          10
//   C1_XDIGIT                 0x0080      // other digits              20
//   C1_ALPHA                  0x0100      // any linguistic character  40
//
// But since I don't care about C1_UPPER and C1_LOWER I can right-shift
// the output of GetStringTypeEx and keep a 128 Byte lookup table.
//
// The precedence rules are: (Alpha, XDigit, Digit) --> CH
//                           (Punct) --> PS
//                           (Space, Blank, Control) --> WS
//

const BYTE
s_abCTypeList[128] =
    {
      WS, CH, WS, CH, PS, CH, WS, CH,   // 00 - 07
      WS, CH, WS, CH, PS, CH, WS, CH,   // 08 - 0F
      WS, CH, WS, CH, PS, CH, WS, CH,   // 10 - 17
      WS, CH, WS, CH, PS, CH, WS, CH,   // 18 - 1F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 20 - 27
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 30 - 37
      CH, CH, CH, CH, CH, CH, CH, CH,   // 40 - 47
      CH, CH, CH, CH, CH, CH, CH, CH,   // 48 - 4F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 50 - 57
      CH, CH, CH, CH, CH, CH, CH, CH,   // 58 - 5F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 60 - 67
      CH, CH, CH, CH, CH, CH, CH, CH,   // 68 - 6F
      CH, CH, CH, CH, CH, CH, CH, CH,   // 70 - 77
      CH, CH, CH, CH, CH, CH, CH, CH,   // 78 - 7F
    };

//+---------------------------------------------------------------------------
//
//  Synopsis:   Returns the type of a character
//
//  Arguments:  [c]   -- Unicode Character
//
//  Returns:    type, one of CH, WS, PS, EOF
//
//  History:    10-Sep-97   Weibz
//
//  Notes:      This returns the type of a character, using the static
//              array s_abCharTypeList.  It adds 1 so that EOF (-1) can be in
//              the array, and accessed normally.
//
//              This is not done by overloading the [] opeator, because in
//              future versions it will not necessarly be a table lookup.
//
//  See above (typeof comments) for an explanation of the mapping
//
//----------------------------------------------------------------------------
BYTE
GetCharType(WCHAR wc )
{
    WCHAR wc2;

    // Map interesting stuff (0000, 2000, 3000, FF00) to the table range,
    // 0x0000 - 0x0300.
    //
    wc2 = (wc & 0x00FF);

    switch (wc & 0xFF00) {

        case 0xFF00:  // Half-Width Variants
            if (wc2 & 0x80) {
                return(VC);  // including Hangul
            }
            wc2 |=  0x0080;
            break;

        case 0xFE00:  // Small Variants
            if ((wc2 <= 0x006B) && (wc2 != 0x0069)) {
                return(WS);
            }
            // Treat Small $ and arabic symbols as CH
            return(CH);
            // break;

        case 0x3000:  // CJK Auxiliary
            wc2 |=  0x0200;
            break;

        case 0x2000:  // General Punctuation
            wc2 |=  0x0100;
            break;

        case 0x0000:  // Code page 0
            // Use System NLS map for code page 0
            if (wc2 & 0x80)
            {
                WORD wCharType = 0;

                GetStringTypeExW( MAKELANGID( LANG_THAI, SUBLANG_DEFAULT ),
                                  CT_CTYPE1,
                                  &wc2,
                                  1,
                                  &wCharType );
                return s_abCTypeList[wCharType >> 2];
            }
            break;

        default:
            //
            // Treat the whole CJK Range as Kanji
            //
            if ((wc >= 0x4E00) && (wc <= 0x9FFF)) {
                return(IC);
            }

            //
            // Treat All Gaiji as Kanji Char, too
            //
            if ((wc >= 0xE000) && (wc < 0xE758)) {
                return(IC);
            }

            //
            // Treat all CJK symbols as word separators
            // NOTE: This means that the stemmer must be smart about searching
            // for zipcodes when given one with a preceding zipcode char.
            //
            if ((wc >= 0x3200) && (wc <= 0x33DD)) {
                return(WS);
            }

            // If it's not interesting return CH as default;
            return(CH);
            // break;
    }

    return( (s_abCharTypeList+1)[wc2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\init.cxx ===
//  ----------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  Routine:    DllMain
//
//  Description:
//
//  Returns:    True if successful, else False.
//  History:    Weibz, 10-Nov-1997,  created it.
//
//---------------------------------------------------------------------------

#include <pch.cxx>
#include "thwbint.h"
#include "resource.h"
CRITICAL_SECTION ThCritSect;

//SCRIPTITEMIZE   ScriptItemize;
//SCRIPTBREAK     ScriptBreak;
HMODULE         hUsp;

BOOL InitWordBreakEngine(HINSTANCE hInstance);

BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{

    CHAR      szUSPPath[MAX_PATH];

    switch(dwReason) 
    {
       case DLL_PROCESS_ATTACH : 
          DisableThreadLibraryCalls(hDLL);
          InitializeCriticalSection (&ThCritSect);

/*
          GetSystemDirectory ( szUSPPath, MAX_PATH );

          strcat ( szUSPPath, "\\USP.DLL" );
          hUsp = LoadLibrary (szUSPPath);

          if ( hUsp == NULL ) 
             return FALSE;

          ScriptItemize = (SCRIPTITEMIZE)GetProcAddress(hUsp,"ScriptItemize");
          ScriptBreak = (SCRIPTBREAK) GetProcAddress(hUsp,"ScriptBreak");

          if ( (ScriptItemize==NULL) || (ScriptBreak==NULL) )
             return FALSE;
*/
		  return InitWordBreakEngine(hDLL);
          break ;

       case DLL_THREAD_ATTACH:
            break;
       case DLL_THREAD_DETACH:
            break;
       case DLL_PROCESS_DETACH  :
/*            
            if (hUsp != NULL )
               FreeLibrary(hUsp);
              
            hUsp = NULL;
*/
			ThaiWordBreakTerminate();
            DeleteCriticalSection (&ThCritSect);
            break ;
      }   //switch
 
      return TRUE ;
}    

BOOL InitWordBreakEngine(HINSTANCE hInstance)
{
	LPBYTE lpLexicon = NULL;
	LPBYTE lpTrigram = NULL;
	HGLOBAL hLexicon = NULL;
	HGLOBAL hTrigram = NULL;
	HRSRC hrsrcLexicon = FindResource(hInstance,(LPSTR) MAKEINTRESOURCE(IDR_LEXICON1),"LEXICON");
	HRSRC hrsrcTrigram = FindResource(hInstance,(LPSTR) MAKEINTRESOURCE(IDR_LEXICON2),"LEXICON");

	// Check if we were able to find resource.
	if (NULL == hrsrcLexicon || NULL == hrsrcTrigram)
	{
		assert(false);
		return FALSE;
	}

	hLexicon = LoadResource(hInstance, hrsrcLexicon);
	hTrigram = LoadResource(hInstance, hrsrcTrigram);

	// Check if we were able to load resource.
	if (NULL == hLexicon || NULL == hTrigram)
	{
		assert(false);
		return FALSE;
	}

	lpLexicon = (LPBYTE) LockResource(hLexicon);
	lpTrigram = (LPBYTE) LockResource(hTrigram);

	if (ThaiWordBreakInitResource(lpLexicon,lpTrigram) != ptecNoErrors)
	{
		assert(false);
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by thawbrkr.rc
//
#define IDR_LEXICON1                    105
#define IDR_LEXICON2                    106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\proofbase.h ===
/********************************************************************
  ProofBase.h - Base API definitions for CSAPI, CTAPI, & CHAPI
    Speller, Thesaurus, and Hyphenator

  Version 3.0 - all api's

    History:
    5/97    DougP   Created
    12/97   DougP   Copied from ProofAPI.h and Separated into tool section files
	5/99	aarayas	Copied Vendor.h into proofbase to elminate many files to copied for Thai wordbreak.

    The Natural Language Group maintains this file.

The end user license agreement (EULA) for CSAPI, CHAPI, or CTAPI covers this source file.  Do not disclose it to third parties.

You are not entitled to any support or assistance from Microsoft Corporation regarding your use of this program.

 1997-1998 Microsoft Corporation.  All rights reserved.
********************************************************************/

#if !defined(PROOFBASE_H)
#define PROOFBASE_H

#pragma pack(push, proofapi_h, 8)   // default alignment

// The Following code was taken from NLG group vendor.h
#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll

#define vendoridPriberam             75     /* Priberam Informtica - Portuguese - 7/13/98 */
#define vendoridTranquility     76  /* Tranquility Software - Vietnamese - 7/22/98 */

#define vendoridColtec          77  /* Coltec - Arabic - added 8/17/98 */

/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */


  // you may wish to include lid.h for some convenient langid defs
#if !defined(lidUnknown)
#   define lidUnknown   0xffff
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------- */

/* hardcoded ordinals are the exported dll entry points */
// individual def files have these as well so be sure to change them
// if you change these
#define idllProofVersion        20
#define idllProofInit           21
#define idllProofTerminate      22
#define idllProofOpenLex        23
#define idllProofCloseLex       24
#define idllProofSetOptions     25
#define idllProofGetOptions     26

typedef unsigned long PTEC;     // ptec

/******************* Proofing Tool Error Codes ************************/
    /* Major Error Codes in low two bytes (WORD) of PTEC */
enum {
    ptecNoErrors,
    ptecOOM,            /* memory error */
    ptecModuleError,    /* Something wrong with parameters, or state of spell module. */
    ptecIOErrorMainLex,  /* Read,write,or share error with Main Dictionary. */
    ptecIOErrorUserLex,  /* Read,write,or share error with User Dictionary. */
    ptecNotSupported,   /* No support for requested operation */
    ptecBufferTooSmall, /* Insufficient room for return info */
    ptecNotFound,       /* Hyphenator and Thesaurus only */
    ptecModuleNotLoaded,    /* underlying module not loaded (Glue Dll's) */
};

/* Minor Error Codes in high two bytes of PTEC */
/* (Not set unless major code also set) */
enum {
    ptecModuleAlreadyBusy=128,  /* For non-reentrant code */
    ptecInvalidID,              /* Not yet inited or already terminated.*/
    ptecInvalidWsc,             /* Illegal values in WSC struct (speller only) */
    ptecInvalidMainLex,     /* Mdr not registered with session */
    ptecInvalidUserLex,     /* Udr not registered with session */
    ptecInvalidCmd,             /* Command unknown */
    ptecInvalidFormat,          /* Specified dictionary not correct format */
    ptecOperNotMatchedUserLex,  /* Illegal operation for user dictionary type. */
    ptecFileRead,               /* Generic read error */
    ptecFileWrite,              /* Generic write error */
    ptecFileCreate,             /* Generic create error */
    ptecFileShare,              /* Generic share error */
    ptecModuleNotTerminated,    /* Module not able to be terminated completely.*/
    ptecUserLexFull,            /* Could not update Udr without exceeding limit.*/
    ptecInvalidEntry,           /* invalid chars in string(s) */
    ptecEntryTooLong,           /* Entry too long, or invalid chars in string(s) */
    ptecMainLexCountExceeded,   /* Too many Mdr references */
    ptecUserLexCountExceeded,   /* Too many udr references */
    ptecFileOpenError,          /* Generic Open error */
    ptecFileTooLargeError,      /* Generic file too large error */
    ptecUserLexReadOnly,        /* Attempt to add to or write RO udr */
    ptecProtectModeOnly,        /* (obsolete) */
    ptecInvalidLanguage,        /* requested language not available */
};


#define ProofMajorErr(x) LOWORD(x)
#define ProofMinorErr(x) HIWORD(x)

/************* Structure def macros *************
Smoke and mirrors to allow initialization of some members when
using C++
***********************************/
#if !defined(__cplusplus)
#   define STRUCTUREBEGIN(x) typedef struct {
#   define STRUCTUREEND0(x) } x;
#   define STRUCTUREEND1(x, y) } x;
#   define STRUCTUREEND2(x, y, z) } x;
#   define STRUCTUREEND3(x, y, z, w) } x;
#else
#   define STRUCTUREBEGIN(x) struct x {
#   define STRUCTUREEND0(x) };
#   define STRUCTUREEND1(x, y) public: x() : y {} };
#   define STRUCTUREEND2(x, y, z) public: x() : y, z {} };
#   define STRUCTUREEND3(x, y, z, w) public: x() : y, z, w {} };
#endif

typedef DWORD PROOFVERNO;   // version

  /* Proof Information Structure - return info from ToolVersion */
STRUCTUREBEGIN(PROOFINFO)   // info
    WCHAR           *pwszCopyright; /* pointer to copyright buffer -
                                            can be NULL if size is zero */
    PROOFVERNO  versionAPI;   /* API */
    PROOFVERNO  versionVendor;  /* includes buildnumber */
    VENDORID        vendorid;   /* from vendor.h */
      /* size of copyright buffer in chars - client sets */
    DWORD           cchCopyright;   /* no error if too small or zero */
    DWORD           xcap;   /* tool dependent */
STRUCTUREEND2(PROOFINFO, pwszCopyright(0), cchCopyright(0))

/* xcap is the bitwise-or of */
enum {
    xcapNULL                    =   0x00000000,
    xcapWildCardSupport         =   0x00000001, // Speller only
    xcapMultiLexSupport         =   0x00000002,
    xcapUserLexSupport          =   0x00000008, // a must for spellers
    xcapLongDefSupport          =   0x00000010, // Thesaurus only
    xcapExampleSentenceSupport  =   0x00000020, // Thesaurus only
    xcapLemmaSupport            =   0x00000040, // Thesaurus only
    xcapAnagramSupport          =   0x00000100, // Speller only
};  // xcap

typedef void * PROOFLEX;    // lex

typedef enum {
    lxtChangeOnce=0,
    lxtChangeAlways,
    lxtUser,
    lxtExclude,
    lxtMain,
    lxtMax,
    lxtIgnoreAlways=lxtUser,
} PROOFLEXTYPE; // lxt


  // note this API does not support external user dictionaries with
  // Change (lxtChangeAlways or lxtChangeOnce) properties
  // It does support either UserLex (the norm) or Exclude types
  // Opening a udr with type Exclude automatically makes it apply to
  // the entire session
STRUCTUREBEGIN(PROOFLEXIN)  /* Dictionary Input Info - lxin - all parameters in only */
    const WCHAR     *pwszLex;   // full path of dictionary to open
    BOOL            fCreate;    /* create if not already exist? (UDR's only) */
    PROOFLEXTYPE    lxt;    /* lxtMain, lxtUser, or lxtExclude (Speller UDR's only) */
    LANGID          lidExpected;    // expected LANGID of dictionary
STRUCTUREEND3(PROOFLEXIN, lidExpected(lidUnknown), fCreate(TRUE), lxt(lxtMain))


STRUCTUREBEGIN(PROOFLEXOUT)    /* Dictionary Output Info - lxout */
    WCHAR       *pwszCopyright; /* pointer to copyright buffer (MDR only)
                                        -- can be NULL if size (below) is zero -
								pointer is in, contents out */
    PROOFLEX    lex;            /* [out] id for use in subsequent calls */
    DWORD       cchCopyright;   /* [in] client sets - no error if too small or zero */
    PROOFVERNO  version;        /* [out] version of lexfile - includes buildnumber */
    BOOL        fReadonly;      /* [out] set if can't be written on */
    LANGID      lid;            /* [out] LANGID actually used */
STRUCTUREEND2(PROOFLEXOUT, pwszCopyright(0), cchCopyright(0))

typedef void *PROOFID;  // id (or sid, hid, or tid)

#define PROOFMAJORVERSION(x)            (HIBYTE(HIWORD(x)))
#define PROOFMINORVERSION(x)            (LOBYTE(HIWORD(x)))
#define PROOFMAJORMINORVERSION(x)       (HIWORD(x))
#define PROOFBUILDNO(x)                 (LOWORD(x))
#define PROOFMAKEVERSION1(major, minor, buildno)    (MAKELONG(buildno, MAKEWORD(minor, major)))
#define PROOFMAKEVERSION(major, minor)  PROOFMAKEVERSION1(major, minor, 0)

#define PROOFTHISAPIVERSION             PROOFMAKEVERSION(3, 0)

STRUCTUREBEGIN(PROOFPARAMS) // xpar [in]
    DWORD   versionAPI; // API version requested
STRUCTUREEND1(PROOFPARAMS, versionAPI(PROOFTHISAPIVERSION))



/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------------

the functions in this section are for documentation only -
separate versions exist for each tool.

  ---------------------------------------------- */
/****************************************************************
*** PROOFVERSION
This is the only routine that can be called outside of a session.
ToolInit begins a session.

The version numbers are in hex format with
the high byte representing the major version number,
the next byte the minor revision number, and the
low order bytes represent an optional build number.
For example, version 1.00 is 0x01000000.  Version 2.13
is 0x020d0000.  Engines that support
this API should return 0x03000000 for iAPIVersion.

The engine ID identifies the core engine creator.  The list
in vendor.h identifies the possible values.  For example,
the Inso derived speller returns VendorIdInso.   iVendorVersion
is up to the vendor to manage and determine.

This routine may return in xcap the functionality
supported by the module.  Since modules are usually
dynamically linked, the application should read the
information and verify that required functionality is
present.
Errors:
    ptecModuleError - bad memory (can't write on pinfo)
**********************************/
// PTEC WINAPI ToolVersion(ToolInfo *pInfo);
typedef PTEC (WINAPI *PROOFVERSION) (PROOFINFO *pinfo);

/***********************************************************
*** ToolInit
This is the entry point for a session.  With the exception
of ToolVersion, this routine must return successfully before
use of any other routines.  ToolInit initializes internal
structures and resources needed for subsequent calls into the
module.  For example, SpellerInit initializes the UserLex,
ChangeOnce, and ChangeAlways built-in UDR's.  In general,
modules allocate and free resources as needed, transparent to
the application.  pToolId is the handle to those variables.
Modules store any data from the PROOFPARAMS structure internally
and do not rely on the data in the structure remaining intact.

Errors:
    ptecModuleError - bad memory (can't write on pxpar)
    ptecNotSupported - incompatible version
    ptecOOM - insufficient memory
*****************************************/
// PTEC WINAPI ToolInit(PROOFID *pToolid, const PROOFPARAMS *pxpar);
typedef PTEC (WINAPI *PROOFINIT) (PROOFID *pid, const PROOFPARAMS *pxpar);


/************************************************************
*** ToolTerminate
This function marks the end of the session.  It attempts to
close all dictionaries and free up any and all other resources
allocated by the module since ToolInit.

Do not call ToolTerminate if  ToolInit was not successful.

If fForce is TRUE, ToolTerminate is guaranteed to succeed.  If
fForce is false, it may fail.  For example, there may be errors
writing the user dictionaries out to disk.  After ToolTerminate
(whether it succeeds or fails), all other module routines with
the exception of ToolTerminate and ToolVersion are unusable
until the module is successfully reinitialized using ToolInit.

If this call fails, successful re-initialization of the module
is not guaranteed on all platforms.  In addition, failure to
successfully terminate each session may lock memory and file
resources in an unrecoverable way until terminate is successful.
If the terminate call fails, the main application should either
fix the problem (e.g., insert floppy in drive) and try to
terminate again, or should terminate using the fForce flag
switch.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
***********************************************/
// PTEC WINAPI ToolTerminate(PROOFID id, BOOL fForce);
typedef PTEC (WINAPI *PROOFTERMINATE) (PROOFID id, BOOL fForce);


/*****************************************************************
*** ToolSetOptions
Set the value of an option for a tool.  The value to set is in iOptVal.

Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolSetOptions(PROOFID id, int iOptionSelect, int iOptVal);
typedef PTEC (WINAPI *PROOFSETOPTIONS) (PROOFID id, DWORD iOptionSelect, const DWORD iOptVal);


/*****************************************************************
*** ToolGetOptions
Get the current value of an option from a tool.  Returns in *piOptVal;
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - can't write at piOptVal
    ptecNotSupported    - iOptionSelect unknown
********************************************/
// PTEC WINAPI ToolGetOptions(PROOFID id, int iOptionSelect, int *piOptVal);
typedef PTEC (WINAPI *PROOFGETOPTIONS) (PROOFID id, DWORD iOptionSelect, DWORD *piOptVal);


/*****************************************************************
*** ToolOpenLex
The dictionary file (main or user) is opened and verified, but not
necessarily loaded.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError - memory error
    ptecIOErrorMainLex - Can't open or read Main Lex
    ptecIOErrorMainLex, ptecInvalidFormat
    ptecIOErrorMainLex, ptecInvalidLanguage - requested LANGID not in this lex
    ptecOOM
    ptecIOErrorUserLex, ptecUserLexCountExceeded - second exclusion dictionary
                                                 - too many Udrs
    ptecIOErrorUserLex, ptecFileOpenError
    ptecIOErrorUserLex, ptecFileCreate - couldn't create a UDR
    ptecIOErrorUserLex, ptecFileRead
    ptecIOErrorUserLex, ptecInvalidFormat
********************************************/
// PTEC WINAPI ToolOpenLex(PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
typedef PTEC (WINAPI *PROOFOPENLEX) (PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);


/*****************************************************************
*** ToolCloseLex
Closes the specified dictionary and disassociates that dictionary
from any subsequent checks.  In the case of user dictionaries,
updates the disk file (if any).  If the dictionary file cannot
be updated, the call fails unless the fForce parameter is also set.

If fForce is true, ToolCloseLex is guaranteed to successfully
remove the dictionary from the dictionary list and effectively
close the file.  In this case, it the file could not be updated,
the changes are lost, but the function is considered successful,
and therefore returns ptecNOERRORS.
Errors:
    ptecModuleError, ptecInvalidID - id is illegal
    ptecModuleError, ptecInvalidMainLex - lex is illegal
    ptecIOErrorUserLex, ptecFileWrite
    ptecIOErrorUserLex, ptecOperNotMatchedUserLex - can't close a built-in UDR
// PTEC WINAPI ToolCloseLex(PROOFID id, PROOFLEX dict, BOOL fforce);
*****************************/
typedef PTEC (WINAPI *PROOFCLOSELEX) (PROOFID id, PROOFLEX lex, BOOL fforce);
// fForce forces closing the specified user dictionary, even if the
// dictionary cannot be updated.  Has no meaning for main
// dictionaries.


/******************************** Special Glue DLL API ******************
For the glue dll's (converts the API for clients to tools that use API v1 for
speller, hyphenator, v2 for thesaurus), we need to set the name of the previous version
DLL to use - and the code page (that it can't figure out from the LANGID)
to use for any data conversion.
The glue dll's use the lid to set the code page for data conversion.

BOOL WINAPI ToolSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
*************************************************************************/
#define idllProofSetDllName     19
typedef BOOL (WINAPI *PROOFSETDLLNAME)(const WCHAR *pwszDllName, const UINT uCodePage);


#if defined(__cplusplus)
}
#endif
#pragma pack(pop, proofapi_h)   // restore to whatever was before

#endif // PROOFBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\thwbint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Thai WordBreak
//
//  Thai WordBreak Interface Header File.
//
//  History:
//      created 6/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBINT_H_
#define _THWBINT_H_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <assert.h>
#include <memory.h>
#include "ProofBase.h"						// Include for definition of PTEC.
#include "thwbdef.hpp"

#define VERSIONMAJOR 1
#define VERSIONMINOR 0

#if defined(__cplusplus)
extern "C" {
#endif

#if defined (NGRAM_ENABLE)
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameSentStruct, WCHAR* szFileNameTrigram);
#else
PTEC WINAPI ThaiWordBreakInit(WCHAR* szFileName, WCHAR* szFileNameTrigram);
#endif
PTEC WINAPI ThaiWordBreakInitResource(LPBYTE pThaiDic, LPBYTE pThaiTrigram);
void WINAPI ThaiWordBreakTerminate();
BOOL WINAPI ThaiWordBreakSearch(WCHAR* szWord, DWORD* pdwPOS);
int WINAPI THWB_FindWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,unsigned int iBreakLen, unsigned int mode);
int WINAPI ThaiSoundEx(WCHAR* word);

int WINAPI THWB_IndexWordBreak(WCHAR* wzString,unsigned int iStringLen, BYTE* pBreakPos,THWB_STRUCT* pThwb_Struct,unsigned int iBreakMax);
int WINAPI THWB_FindAltWord(WCHAR* wzWord,unsigned int iWordLen, BYTE Alt, BYTE* pBreakPos);
THWB_STRUCT* WINAPI THWB_CreateThwbStruct(unsigned int iNumStruct);
void WINAPI THWB_DeleteThwbStruct(THWB_STRUCT* pThwb_Struct);

#if defined(__cplusplus)
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\register.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) 1998 - 1999, Microsoft Corporation.
//
// File:        Register.cxx
//
// Contents:    Self-registration for Word Breaker /Stemmer.
//
// Functions:   DllRegisterServer, DllUnregisterServer
//
// History:     12-Jan-98       Weibz       Created
//              08-Jan-99       AlanW       Modified to use langreg.hxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "thwbint.h"
#include "langreg.hxx"

//
// Registry constants
//


WCHAR const wszCILang[] = L"System\\CurrentControlSet\\Control\\ContentIndex\\Language";

#if defined (THAIINDEX)
SLangRegistry const LangResource = {
    L"Thai_IndexDefault",
    1054,
    {   L"{B66F590A-62A5-47db-AFBC-EFDD4FFBDBEB}", // L"{cca22cf4-59fe-11d1-aaff-00c04fb97fda}",
        L"Thai_IndexDefault Word Breaker",
        L"thawbrkr.dll",
        L"Both" },

    {   L"{52CC7D83-1378-4537-A40F-DD4372498E18}", // L"{cedc01c7-59fe-11d1-aaff-00c04fb97fda}",
        L"Thai_IndexDefault Stemmer",
        L"thawbrkr.dll",
        L"Both" }
};
#else
SLangRegistry const LangResource = {
    L"Thai_Default",
    1054,
    {   L"{cca22cf4-59fe-11d1-bbff-00c04fb97fda}",
        L"Thai_Default Word Breaker",
        L"thawbrkr.dll",
        L"Both" },

    {   L"{cedc01c7-59fe-11d1-bbff-00c04fb97fda}",
        L"Thai_Default Stemmer",
        L"thawbrkr.dll",
        L"Both" }
};
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created 
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer()
{
    long dwErr = UnRegisterALanguageResource( LangResource );
    if ( ERROR_SUCCESS != dwErr )
        return S_FALSE;

    return S_OK;
} //DllUnregisterServer

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Self-registration
//
//  History:    12-Jan-98       Weibz       Created
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
    //
    // Register classes
    //

    long dwErr = RegisterALanguageResource( LangResource );

    if ( ERROR_SUCCESS != dwErr )
        return SELFREG_E_CLASS;

    return S_OK;
} //DllRegisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       exports.cxx
//
//  Contents:   Code to export word breaker class factories
//
//  History:     weibz,   11-10-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include <classid.hxx>
#include <wbclassf.hxx>
#include <stemcf.hxx>

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE
DllGetClassObject(
    REFCLSID   cid,
    REFIID     iid,
    void **    ppvObj )
{
    IUnknown *  pResult = 0;
    SCODE       sc      = S_OK;

//    __try {

        switch ( cid.Data1 ) {

        // Thai language wordbreaker
        //
		case 0xB66F590A:
        case 0xcca22cf4:
           if ( cid == CLSID_Thai_Default_WBreaker ) {
             pResult = (IUnknown *) new CWordBreakerCF(
                MAKELCID( MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
			 if (pResult) {
				sc = pResult->QueryInterface( iid, ppvObj );
				pResult->Release(); // Release extra refcount from QueryInterface
			 }
			 else
				 sc = E_NOINTERFACE;
           }
           else
              sc = E_NOINTERFACE;
           break;

        // Thai language stemmer
        //
		case 0x52CC7D83:
        case 0xcedc01c7:
           if ( cid == CLSID_Thai_Default_Stemmer )
           {
             pResult = (IUnknown *) new CStemmerCF(
                MAKELCID( MAKELANGID(LANG_THAI, SUBLANG_DEFAULT),
                SORT_DEFAULT ));
			 if (pResult) {
				sc = pResult->QueryInterface( iid, ppvObj );

				pResult->Release(); // Release extra refcount from QueryInterface
			 }
			 else
				 sc = E_NOINTERFACE;
           }
           else
              sc = E_NOINTERFACE;
           break;

        default:
             sc = E_NOINTERFACE;
        }
 /*   } __except(1) {

        if ( pResult )
            pResult->Release();

        sc = E_UNEXPECTED;
    }  */

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:     weibz,   11-10-1997   created 
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\iwbreak.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       IWBreak.cxx
//
//  Contents:   Thai  Word Breaker glue code
//
//  History:   weibz,   10-Nov-1997   created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#include "iwbreak.hxx"
#include "thwbint.h"
#define MAX_BREAKS 255
#define WB_NORMAL 1
extern  long            gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::CWordBreaker
//
//  Synopsis:   Constructor for the CWordBreaker class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CWordBreaker::CWordBreaker( LCID lcid )
        : _cRefs(1),
          _lcid(lcid)
{

    InterlockedIncrement( &gulcInstances );

}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::~CWordBreaker
//
//  Synopsis:   Destructor for the CWordBreaker class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CWordBreaker::~CWordBreaker()
{
   InterlockedDecrement( &gulcInstances );


}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::QueryInterface( REFIID riid, void  ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IWordBreaker == riid )
        *ppvObject = (IUnknown *)(IWordBreaker *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject =  (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CWordBreaker::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp ) 
        delete this;


    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreaker::Init
//
//  Synopsis:   Initialize word-breaker
//
//  Arguments:  [fQuery]         -- TRUE if query-time
//              [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreaker::Init(
    BOOL fQuery,
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{
    if ( NULL == pfLicense ) {
       return E_INVALIDARG;
    }


    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _fQuery = fQuery;
    _ulMaxTokenSize = ulMaxTokenSize;


    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::ComposePhrase
//
//  Synopsis:   Convert a noun and a modifier into a phrase.
//
//  Arguments:  [pwcNoun] -- pointer to noun.
//              [cwcNoun] -- count of chars in pwcNoun
//              [pwcModifier] -- pointer to word modifying pwcNoun
//              [cwcModifier] -- count of chars in pwcModifier
//              [ulAttachmentType] -- relationship between pwcNoun &pwcModifier
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::ComposePhrase(
    WCHAR const *pwcNoun,
    ULONG cwcNoun,
    WCHAR const *pwcModifier,
    ULONG cwcModifier,
    ULONG ulAttachmentType,
    WCHAR *pwcPhrase,
    ULONG *pcwcPhrase )
{
    //
    // Need to code in later
    //
    if ( _fQuery )
        return( E_NOTIMPL );
    else
        return ( WBREAK_E_QUERY_ONLY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CWordBreaker::GetLicenseToUse(
    const WCHAR **ppwcsLicense )
{

    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";


    if ( NULL == ppwcsLicense )  {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *ppwcsLicense = wcsCopyright;
    return( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWordBreaker::BreakText
//
//  Synopsis:   Break input stream into words.
//
//  Arguments:  [pTextSource] -- source of Unicode text
//              [pWordSink] -- sink for collecting words
//              [pPhraseSink] -- sink for collecting phrases
//
//  History:    10-Nov-1997, WeibZ,       Created.
//
//  Notes:      Since the input buffer may be greater than MAX_II_BUFFER_LEN
//              we process the buffer in chunks of length MAX_II_BUFFER_LEN.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreaker::BreakText( TEXT_SOURCE *pTextSource,
                                                 IWordSink *pWordSink,
                                                 IPhraseSink *pPhraseSink )
{
    SCODE             sc = S_OK;
    ULONG             cwc;
    SCRIPT_ITEM       *pItems, *pItem_Next, *pItem_org;
    SCRIPT_ANALYSIS   *psa;
    PCWSTR            pwcInChars;
    INT               iItems;
    BOOL              bItemProc;
    PCWSTR            pwcChars;
    INT               cChars;
    HRESULT           retUSP;


    if ( NULL == pTextSource ) {
       return E_INVALIDARG;
    }

    if ( NULL == pWordSink )
    {
        // BUGBUG, propagate the null word sink error code
        return sc;
    }


    if ( 0 != pPhraseSink )
    {
        // ignore the phrase sink for now
        // return sc;
    }

    if (pTextSource->iEnd == pTextSource->iCur) {
       return S_OK;
    }

    Assert( pTextSource->iCur < pTextSource->iEnd );


    __try 
    {
        do  {

            if ( pTextSource->iCur >= pTextSource->iEnd )
               continue;

            cwc = pTextSource->iEnd - pTextSource->iCur;
            pwcInChars = pTextSource->awcBuffer + pTextSource->iCur;
            
            
            pItems = (SCRIPT_ITEM *)LocalAlloc(LPTR,sizeof(SCRIPT_ITEM)*(cwc+1));

            if ( !pItems) {

                return E_UNEXPECTED;
            }

            pItem_org = pItems; 

           
            iItems = 0; 
            retUSP = ScriptItemize(pwcInChars,cwc,cwc+1, NULL, NULL, 
                                   pItems, &iItems);

            if (retUSP != S_OK) {
                LocalFree(pItem_org);
                return  E_UNEXPECTED;
            }

            while  ( iItems > 1 ) {

               pItem_Next = pItems + 1;
               pwcChars =  pwcInChars + pItems->iCharPos;
               cChars   =  pItem_Next->iCharPos - pItems->iCharPos;

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       FALSE,   // no need to keep chars
                                       pTextSource,
                                       pWordSink, 
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }

               pItems++;
               iItems--;

            }

            //  special handle for the last item
            if ( iItems == 1 ) {

               pwcChars = pwcInChars + pItems->iCharPos;
               cChars = pTextSource->iEnd - pTextSource->iCur; 

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       TRUE,  // need to keep chars
                                       pTextSource,
                                       pWordSink,
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }
            }

            if (pItem_org)
               LocalFree(pItem_org);

        } while ( SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)) );


        if ( pTextSource->iCur < pTextSource->iEnd ) {

            cwc = pTextSource->iEnd - pTextSource->iCur;
            pwcInChars = pTextSource->awcBuffer + pTextSource->iCur;
            
            pItems = (SCRIPT_ITEM *)LocalAlloc(LPTR,sizeof(SCRIPT_ITEM)*(cwc+1));

            if ( !pItems ) {

                return E_UNEXPECTED;
            }

            pItem_org = pItems;


            iItems = 0; 
            retUSP = ScriptItemize(pwcInChars,cwc,cwc+1, NULL, NULL,
                                   pItems, &iItems);

            if (retUSP != S_OK) {
                LocalFree(pItem_org);
                return  E_UNEXPECTED;
            }

            while  ( iItems > 1 ) {

               pItem_Next = pItems + 1;
               pwcChars =  pwcInChars + pItems->iCharPos;
               cChars   =  pItem_Next->iCharPos - pItems->iCharPos;

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       FALSE,  // no need to keep chars
                                       pTextSource,
                                       pWordSink, 
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }

               pItems++;
               iItems--;

            }

            if ( iItems == 1 ) {

               pwcChars = pwcInChars + pItems->iCharPos;
               cChars = pTextSource->iEnd - pTextSource->iCur; 

               bItemProc = ProcessItem(pwcChars,
                                       cChars,
                                       pItems,
                                       FALSE,    // no need to keep chars
                                       pTextSource,
                                       pWordSink,
                                       pPhraseSink);

               if ( bItemProc == FALSE ) {
                  LocalFree(pItem_org);
                  return  E_UNEXPECTED;
               }
            }

            if ( pItem_org ) 
               LocalFree(pItem_org);
        }

    } __except(1) {

       sc = E_UNEXPECTED;
   }

    return sc;
}

BOOL CWordBreaker::ProcessItem( 
                     PCWSTR        pwcChars,
                     INT           cChars,
                     SCRIPT_ITEM   *pItems,
                     BOOL          fKeep,
                     TEXT_SOURCE  *pTextSource,     
                     IWordSink    *pWordSink,
                     IPhraseSink  *pPhraseSink )
{

//    SCRIPT_LOGATTR    *psla, *psla_org, *pslatmp;
    INT             iChar,i;
    INT             iWord, iWordStart, iWordLen;
//    PTHAIWORD         pThaiWord, pThaiWordTmp;
//    BOOL              fLastIsWhiteSpace=FALSE;
    const SCRIPT_PROPERTIES **pScript_Properties;
    DWORD             LangID;
    WORD              iScript;

    HRESULT           retUSP;

    ScriptGetProperties(&pScript_Properties, NULL);

    iScript = pItems->a.eScript;

    LangID = (pScript_Properties[iScript])->langid;

    switch (LangID) {
       case LANG_THAI:
                        {
                        BYTE*   pBreakPos;
                        int             iNumberOfBreak = 0;
                        int             i;
                        WCHAR*  pwch = (WCHAR*) pwcChars;
                        THWB_STRUCT* pThwbStruct = NULL;

                        pBreakPos = new BYTE[cChars];

                        if ( pBreakPos == NULL ) 
                                return  FALSE;

                        pThwbStruct = THWB_CreateThwbStruct(cChars);
                        
                        pBreakPos[0] = 0;
//                      iNumberOfBreak = THWB_FindWordBreak(pwch, cChars, pBreakPos, cChars, WB_NORMAL);
                        iNumberOfBreak = THWB_IndexWordBreak(pwch,cChars, pBreakPos, pThwbStruct,cChars);

                        for (i=0;i < iNumberOfBreak; i++)
                                {

                                // Search index alternate words.
                                // If not query create Alternate word.
                                if (pThwbStruct[i].alt != 0 && !_fQuery)
                                        {
                                        int             iNumAltWord = 0, k;
                                        BYTE    pAltBreakPos[5];
                                        WCHAR*  word1 = pwch;
                                        int             indexWord1 = 0;

                                        
                                        // Find Alternate words
                                        iNumAltWord = THWB_FindAltWord(word1,pBreakPos[i], pThwbStruct[i].alt, pAltBreakPos);
                                        
                                        // Put alternate words.
                                        for(k=0; k<iNumAltWord;k++)
                                                {
                                                pWordSink->PutAltWord(pAltBreakPos[k],&word1[indexWord1],pBreakPos[i],pTextSource->iCur);
                                                indexWord1 += pAltBreakPos[k];
                                                }                       
                                        }

                                if (*pwch >= THAI_Ko_Kai && *pwch <= THAI_Vowel_MaiYaMok)
                                        pWordSink->PutWord(     pBreakPos[i], pwch,     pBreakPos[i], pTextSource->iCur);
                                pTextSource->iCur += pBreakPos[i];

                                pwch += pBreakPos[i];
                                }

                        if (pBreakPos)
                                delete pBreakPos;

                        // Prefix bug 1055941 - clear allocated memory.
                        THWB_DeleteThwbStruct(pThwbStruct);

                        break;
                        }

       case LANG_ENGLISH :   // handle English chars 

            { 

                BYTE        ct;
                BOOL        fRomanWord = FALSE;
                CONST WCHAR *pwcInput;
                WT          Type;

                Type =  WT_START;

                pwcInput = pwcChars;
                iWordStart = 0;

                for (iChar=0; iChar< cChars; iChar++, pwcInput++) {

                    ct = GetCharType(*pwcInput);

                    if ( (ct != WS) && (ct != PS) )
                       ct = CH;


                    switch (ct) {
                      case CH :
                           if (!fRomanWord) {
                               iWordStart = iChar; 
                               fRomanWord = TRUE;
                               Type = WT_ROMAJI;
                           }
                           break;
                      case WS :
                           if (fRomanWord) {
                              iWordLen = iChar - iWordStart; 
                              pWordSink->PutWord(iWordLen,
                                                 pwcChars+iWordStart,
                                                 iWordLen,
                                                 pTextSource->iCur);

                              pTextSource->iCur += iWordLen;
                              fRomanWord = FALSE;
                           }
                           
                           Type = WT_WORD_SEP;
                           pTextSource->iCur++;
                           break;

                      case PS :
                           if (fRomanWord) {
                              iWordLen = iChar - iWordStart;
                              pWordSink->PutWord(iWordLen,
                                                 pwcChars+iWordStart,
                                                 iWordLen,
                                                 pTextSource->iCur);

                              pTextSource->iCur += iWordLen;
                              fRomanWord = FALSE;
                           }
                           
                           Type = WT_PHRASE_SEP;
                           pWordSink->PutBreak(WORDREP_BREAK_EOS);
                           pTextSource->iCur++;
                           break;

                    }
                }

                if ((Type == WT_WORD_SEP) || (Type == WT_PHRASE_SEP))
                   break;
                
                if ( fKeep )
                   break;
                
                iWordLen =cChars - iWordStart;
                pWordSink->PutWord(iWordLen,
                                  pwcChars+iWordStart,
                                  iWordLen,
                                  pTextSource->iCur);

                pTextSource->iCur += iWordLen;
            }

            break;


       default           :

               pTextSource->iCur += cChars;
               break;
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\thwbplat.h ===
//+---------------------------------------------------------------------------
//
//
//  THWBPLAT.H - contain different definition use in Thai Word Break.
//
//  History:
//      created 3/00 aarayas
//
//  2000 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBPLAT_H_
#define _THWBPLAT_H_

#ifdef _OFFICE_
#define DWORD_PTR DWORD
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\stemcf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       stemcf.cxx
//
//  Contents:   Stemmer class factory
//
//  History:     weibz,   10-Sep-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "stemcf.hxx"
#include "stemmer.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CStemmerCF
//
//  Synopsis:   Stemmer class factory constructor
//
//--------------------------------------------------------------------------

CStemmerCF::CStemmerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::~CStemmerCF
//
//  Synopsis:   Stemmer class factory destructor
//
//--------------------------------------------------------------------------

CStemmerCF::~CStemmerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::QueryInterface( REFIID riid,
                                                    void  ** ppvObject )
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CStemmerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::CreateInstance
//
//  Synopsis:   Creates new CStemmer object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::CreateInstance( IUnknown * pUnkOuter,
                                                    REFIID riid,
                                                    void  * * ppvObject )
{
    CStemmer *pIUnk = 0;
    SCODE sc = S_OK;

    __try
    {
        pIUnk = new CStemmer( _lcid );
        if (pIUnk)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );

            pIUnk->Release();  // Release extra refcount from QueryInterface
        }
        else
        {
            sc = E_UNEXPECTED;
        }
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CStemmerCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\stemmer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       stemmer.cxx
//
//  Contents:   Thai Stemmer
//
//  History:    weibz,   10-Nov-1997   created 
//
//----------------------------------------------------------------------------

#include <pch.cxx>

#include "stemmer.hxx"

extern long gulcInstances;

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::CStemmer
//
//  Synopsis:   Constructor for the CStemmer class.
//
//  Arguments:  [lcid] -- locale id
//
//----------------------------------------------------------------------------

CStemmer::CStemmer( LCID lcid )
        : _cRefs(1)
{
   InterlockedIncrement( &gulcInstances );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::~CStemmer
//
//  Synopsis:   Destructor for the CStemmer class.
//
//  Notes:      All termination/deallocation is done by embedded smart pointers
//
//----------------------------------------------------------------------------

CStemmer::~CStemmer()
{
   InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::QueryInterface( REFIID riid, void  ** ppvObject)
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IStemmer == riid )
        *ppvObject = (IUnknown *)(IStemmer *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CStemmer::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CStemmer::Init
//
//  Synopsis:   Initialize stemmer
//
//  Arguments:  [ulMaxTokenSize] -- Maximum size token stored by caller
//              [pfLicense]      -- Set to true if use restricted
//
//  Returns:    Status code
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::Init(
    ULONG ulMaxTokenSize,
    BOOL *pfLicense )
{

    if ( NULL == pfLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(pfLicense, sizeof(DWORD))) {
        return E_INVALIDARG;
    }

    *pfLicense = TRUE;
    _ulMaxTokenSize = ulMaxTokenSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::GetLicenseToUse
//
//  Synopsis:   Returns a pointer to vendors license information
//
//  Arguments:  [ppwcsLicense] -- ptr to ptr to which license info is returned
//
//----------------------------------------------------------------------------
SCODE STDMETHODCALLTYPE
CStemmer::GetLicenseToUse( const WCHAR **ppwcsLicense )
{
    static WCHAR const * wcsCopyright = L"Copyright Microsoft, 1991-1998";
    
    if ( NULL == ppwcsLicense ) {
       return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppwcsLicense, sizeof(DWORD))) {
        return ( E_INVALIDARG );
    }

    *ppwcsLicense = wcsCopyright;

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CStemmer::StemWord
//
//  Synopsis:   Stem a word into its inflected forms, eg swim to swims and swimming
//
//  Arguments:  [pwcInBuf] -- input Unicode word
//              [cwc] -- count of characters in word
//              [pStemSink] -- sink to collect inflected forms
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CStemmer::StemWord(
    WCHAR const *pwcInBuf,
    ULONG cwc,
    IStemSink *pStemSink )
{
    INT nReturn;
    SCODE sc = S_OK;

#ifdef THAIDBG
    ULONG  i;
    OutputDebugString("\n Stemword\n");
    for (i=0; i<cwc; i++)
    {
          WORD  wtmp;
          char  ctmp[80];

          wtmp = pwcInBuf[i];
          sprintf(ctmp, "%4x ", wtmp);
          OutputDebugString(ctmp);
    }
#endif

    if ( NULL == pStemSink  || NULL == pwcInBuf) {
        return E_FAIL;
    }

    // Currently, Thai stemmer doesn't make inflection form for tripolli.
    pStemSink->PutWord (pwcInBuf, cwc);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\thwbdef.hpp ===
//+---------------------------------------------------------------------------
//
//
//  THWBDEF.HPP - contain different definition use in Thai Word Break.
//
//  History:
//      created 7/99 aarayas
//
//  1999 Microsoft Corporation
//----------------------------------------------------------------------------
#ifndef _THWBDEF_HPP_
#define _THWBDEF_HPP_
#include <windows.h>
#include "thwbplat.h"

#define THAI_Ko_Kai					0x0e01
#define THAI_Kho_Rakhang            0x0e06
#define THAI_Cho_Ching              0x0e09
#define THAI_So_So                  0x0e0b
#define THAI_Tho_NangmonTho         0x0e11
#define THAI_Pho_Phung              0x0e1c
#define THAI_Fo_Fa                  0x0e1d
#define THAI_Fo_Fan                 0x0e1f
#define THAI_Pho_Samphao            0x0e20
#define THAI_Ho_Hip                 0x0e2b
#define THAI_Ho_Nok_Huk				0x0e2e
#define THAI_Sign_PaiYanNoi         0x0e2f
#define THAI_Vowel_Sara_A           0x0e30
#define THAI_Vowel_Sign_Mai_HanAkat 0x0e31
#define THAI_Vowel_Sara_AA          0x0e32
#define THAI_Vowel_Sign_Sara_Am		0x0e33
#define THAI_Vowel_Sara_I           0x0e34
#define THAI_Vowel_Sara_II          0x0e35
#define THAI_Sara_Ue                0x0e36
#define THAI_Sara_Uee               0x0e37
#define THAI_Vowel_Sign_Phinthu		0x0e3a
#define THAI_Vowel_Sara_E           0x0e40
#define THAI_Vowel_Sara_AI_MaiMaLai 0x0e44
#define THAI_Vowel_LakKhangYao      0x0e45
#define THAI_Vowel_MaiYaMok         0x0e46
#define THAI_Tone_MaiTaiKhu         0x0e47
#define THAI_Tone_Mai_Ek			0x0e48
#define THAI_Tone_Mai_Tri           0x0e4a
#define THAI_Thanthakhat            0x0e4c
#define THAI_Nikhahit               0x0e4d

#define POSTYPE		                304
#define POS_UNKNOWN                 (POSTYPE - 1)
#define TAGPOS_UNKNOWN              0x012F301
#define TAGPOS_PURGE                0x0130301

#define MAXBREAK                    256

// Soundex definition.
#define APPROXIMATEWEIGHT           60

#define WB_LINEBREAK	0
#define WB_NORMAL		1
//#define WB_LINEBREAK	2	// Number 2 is also linebreak.
#define WB_SPELLER		3
#define WB_INDEX		4

typedef struct THWB_STRUCT
{
	bool fThai;
	BYTE alt;
} THWB_STRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\disdraw.h ===
// disdraw.h : main header file for the DISDRAW application
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDisdrawApp:
// See disdraw.cpp for the implementation of this class
//

class CDisdrawApp : public CWinApp
{
public:
	CDisdrawApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDisdrawApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDisdrawApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\disdraw.cpp ===
// disdraw.cpp : Defines the class behaviors for the application.
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "disdraw.h"
#include "drawdlg.h"
#include "logindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_USERNAME_LEN 32

/////////////////////////////////////////////////////////////////////////////
// CDisdrawApp

BEGIN_MESSAGE_MAP(CDisdrawApp, CWinApp)
	//{{AFX_MSG_MAP(CDisdrawApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDisdrawApp construction

CDisdrawApp::CDisdrawApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDisdrawApp object

CDisdrawApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDisdrawApp initialization

BOOL CDisdrawApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	//
	// Prompt for the user's name
	//
	char mbsUserName[MAX_USERNAME_LEN];
	DWORD dwNumBytes = MAX_USERNAME_LEN;
	GetUserName(mbsUserName, &dwNumBytes);
	CLoginDlg dlgLogin;
	dlgLogin.m_strLogin = mbsUserName;
	if (dlgLogin.DoModal() == IDCANCEL || dlgLogin.m_strLogin == "" )
	{
		return FALSE;
	}

	dlgLogin.m_strLogin.MakeUpper();

	CDisdrawDlg dlg;
	m_pMainWnd = &dlg;
	dlg.m_strLogin = dlgLogin.m_strLogin;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\drawarea.cpp ===
// drawarea.cpp : implementation file
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "disdraw.h"
#include "drawdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDrawArea

CDrawArea::CDrawArea()
{
}

CDrawArea::~CDrawArea()
{
}


BEGIN_MESSAGE_MAP(CDrawArea, CEdit)
	//{{AFX_MSG_MAP(CDrawArea)
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_PAINT()
	ON_WM_RBUTTONUP()
	ON_WM_CTLCOLOR_REFLECT()
	ON_WM_KEYDOWN()
	ON_WM_CHAR()
	ON_WM_SETFOCUS()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDrawArea message handlers

void CDrawArea::AddKeystroke(char *mbsKey)
{
	//
	// The backspace keystroke should erase the last character
	//
	if (mbsKey[0] == VK_BACK)
	{
		int nStart, nEnd;
		GetSel(nStart, nEnd);
		SetSel(nEnd-1, nEnd);
		mbsKey[0] = '\0';

        //
        // Erasing a line feed should erase the preceding carriage return
        //
        CString strText;
        GetWindowText(strText);
        int iLength = strText.GetLength();
        if (iLength > 0 && strText.GetAt(strText.GetLength() - 1) == '\n')
            SetSel(nEnd-2, nEnd);
	}

	//
	// Append a line feed to a carriage return
	//
	else if (mbsKey[0] == VK_RETURN)
		strcat(mbsKey, "\xa");

	//
	// Store the new keystroke
	//
	ReplaceSel(mbsKey);
}


void CDrawArea::AddLine(LINE line)
{
	//
	// Set the clipping region for the drawing
	//
	CClientDC dc(this);
	RECT rect;
	GetClientRect(&rect);
	CRgn rgn;
	rgn.CreateRectRgnIndirect(&rect); 
	dc.SelectClipRgn(&rgn);

	//
	// Draw the line and save it for redrawing
	//
	dc.MoveTo(line.ptStart);
	dc.LineTo(line.ptEnd);
    m_listLines.AddTail(line);
}


void CDrawArea::OnLButtonDown(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	m_ptLast = point;
	SetFocus();
}


void CDrawArea::OnMouseMove(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	if (nFlags & MK_LBUTTON)
	{
		//
		// Add the drawn line to the drawing
		//
		LINE line;
		line.ptStart = m_ptLast;
		line.ptEnd = point;
        AddLine(line);

		//
		// Send the line to the friend
		//
		((CDisdrawDlg *)GetParent())->SendMouseMovement(line);

		//
		// Remember the end point of the line 
		//
		m_ptLast = point;
	}
}


void CDrawArea::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here

	//
	// Set the clipping region for the drawing
	//
	RECT rect;
	GetClientRect(&rect);
	CRgn rgn;
	rgn.CreateRectRgnIndirect(&rect); 
	dc.SelectClipRgn(&rgn);

	//
	// Erase the drawing area
	//
	dc.FillSolidRect(&rect, GetSysColor(COLOR_MENU));

	//
	// Redisplay the text
	//
    CString strText;
    GetWindowText(strText);
    dc.SelectStockObject(ANSI_VAR_FONT);
    rect.top++;
    rect.left++;
    dc.DrawText(strText, &rect, DT_TOP | DT_WORDBREAK);

	//
	// Redraw each line
	//
	LINE line;
	POSITION posLine = m_listLines.GetHeadPosition();
	while (posLine != NULL)
	{
		line = m_listLines.GetNext(posLine);
		dc.MoveTo(line.ptStart);
		dc.LineTo(line.ptEnd);
	}

	// Do not call CEdit::OnPaint() for painting messages
}


void CDrawArea::OnRButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	//
	// Clear the drawing area
	//
	SetSel(0, -1);
	Clear();
	m_listLines.RemoveAll();
	RedrawWindow();
}


BOOL CDrawArea::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	// TODO: Add your message handler code here and/or call default
	
	return 0;
}


void CDrawArea::OnSetFocus(CWnd* pOldWnd) 
{
	CEdit::OnSetFocus(pOldWnd);
	
	// TODO: Add your message handler code here

	HideCaret();
}


HBRUSH CDrawArea::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	// TODO: Change any attributes of the DC here
	pDC->SetBkColor(GetSysColor(COLOR_MENU));
	
	// TODO: Return a non-NULL brush if the parent's handler should not be called
	return HBRUSH((CBrush *)pDC->SelectStockObject(LTGRAY_BRUSH));
}


void CDrawArea::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default

	switch (nChar)
	{
	case VK_LEFT:
	case VK_RIGHT:
	case VK_UP:
	case VK_DOWN:	
	case VK_HOME:	break;
	default:		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}


void CDrawArea::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	((CDisdrawDlg *)GetParent())->SendKeystroke(nChar);
	
	CEdit::OnChar(nChar, nRepCnt, nFlags);

	RedrawWindow();
}


void CDrawArea::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\intlwb\thai2\wb\wbclassf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       wbclassf.cxx
//
//  Contents:   Word Breaker class factory
//
//  History:     weibz,   10-Nov-1997   created 
//
//--------------------------------------------------------------------------

#include <pch.cxx>

#include "wbclassf.hxx"
#include "iwbreak.hxx"

extern long gulcInstances;

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory constructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::CWordBreakerCF( LCID lcid )
        : _cRefs( 1 ), _lcid( lcid )
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::~CWordBreakerCF
//
//  Synopsis:   Word Breaker class factory destructor
//
//--------------------------------------------------------------------------

CWordBreakerCF::~CWordBreakerCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CWordBreakerCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CWordBreakerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::CreateInstance
//
//  Synopsis:   Creates new CWordBreaker object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void  * * ppvObject )
{
    CWordBreaker *pIUnk = 0;
    SCODE sc = S_OK;

    if (NULL != pUnkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return E_NOINTERFACE;
    }

    __try 
    {
        pIUnk = new CWordBreaker( _lcid );
        if (pIUnk)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );

            pIUnk->Release();  // Release extra refcount from QueryInterface
        }
        else
        {
            sc = E_UNEXPECTED;
        }
    }
    __except(1)
    {
        Assert( 0 == pIUnk );

        sc = E_UNEXPECTED;
    }


    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWordBreakerCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE
CWordBreakerCF::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\published\inc\mq.h ===
/*++

Copyright (c) 1996-2001, Microsoft Corporation

Module Name:

    mq.h

Abstract:

    Master include file for Message Queuing applications

--*/

#ifndef __MQ_H__
#define __MQ_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif


#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif  // __ITransaction_FWD_DEFINED__


#ifdef __midl
// This is the PROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT tagMQPROPVARIANT;

#else
// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT tagMQPROPVARIANT;
#endif
typedef tagMQPROPVARIANT MQPROPVARIANT;


#define	PRLT	( 0 )

#define	PRLE	( 1 )

#define	PRGT	( 2 )

#define	PRGE	( 3 )

#define	PREQ	( 4 )

#define	PRNE	( 5 )

typedef struct tagMQPROPERTYRESTRICTION
    {
    ULONG rel;
    PROPID prop;
    MQPROPVARIANT prval;
    } 	MQPROPERTYRESTRICTION;

typedef struct tagMQRESTRICTION
    {
    ULONG cRes;
    /* [size_is] */ MQPROPERTYRESTRICTION *paPropRes;
    } 	MQRESTRICTION;

typedef struct tagMQCOLUMNSET
    {
    ULONG cCol;
    /* [size_is] */ PROPID *aCol;
    } 	MQCOLUMNSET;

#define	QUERY_SORTASCEND	( 0 )

#define	QUERY_SORTDESCEND	( 1 )

typedef struct tagMQSORTKEY
    {
    PROPID propColumn;
    ULONG dwOrder;
    } 	MQSORTKEY;

typedef struct tagMQSORTSET
    {
    ULONG cCol;
    /* [size_is] */ MQSORTKEY *aCol;
    } 	MQSORTSET;


#define MQ_MAX_Q_NAME_LEN      124   // Maximal WCHAR length of a queue name.
#define MQ_MAX_Q_LABEL_LEN     124
#define MQ_MAX_MSG_LABEL_LEN   250

typedef HANDLE QUEUEHANDLE;

typedef PROPID MSGPROPID;
typedef struct tagMQMSGPROPS
{
    DWORD           cProp;
    MSGPROPID*      aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQMSGPROPS;


typedef PROPID QUEUEPROPID;
typedef struct tagMQQUEUEPROPS
{
    DWORD           cProp;
    QUEUEPROPID*    aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQQUEUEPROPS;


typedef PROPID QMPROPID;
typedef struct tagMQQMPROPS
{
    DWORD           cProp;
    QMPROPID*       aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQQMPROPS;


typedef struct tagMQPRIVATEPROPS
{
    DWORD           cProp;
    QMPROPID*       aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQPRIVATEPROPS;


typedef PROPID MGMTPROPID;
typedef struct tagMQMGMTPROPS
{
    DWORD cProp;
    MGMTPROPID* aPropID;
    MQPROPVARIANT* aPropVar;
    HRESULT* aStatus;
} MQMGMTPROPS;

typedef struct tagSEQUENCE_INFO
{
    LONGLONG SeqID;
    ULONG SeqNo; 
    ULONG PrevNo;
} SEQUENCE_INFO;

    



//********************************************************************
//  API FLAGS
//********************************************************************

//
//  MQOpenQueue - Access values
//
#define MQ_RECEIVE_ACCESS       0x00000001
#define MQ_SEND_ACCESS          0x00000002
#define MQ_PEEK_ACCESS          0x00000020
#define MQ_ADMIN_ACCESS         0x00000080

//
//  MQOpenQueue - Share values
//
#define MQ_DENY_NONE            0x00000000
#define MQ_DENY_RECEIVE_SHARE   0x00000001

//
//  MQReceiveMessage - Action values
//
#define MQ_ACTION_RECEIVE       0x00000000
#define MQ_ACTION_PEEK_CURRENT  0x80000000
#define MQ_ACTION_PEEK_NEXT     0x80000001

//
//  MQReceiveMessageByLookupId - Action values
//
#define MQ_LOOKUP_PEEK_CURRENT    0x40000010
#define MQ_LOOKUP_PEEK_NEXT       0x40000011
#define MQ_LOOKUP_PEEK_PREV       0x40000012
#define MQ_LOOKUP_PEEK_FIRST      0x40000014
#define MQ_LOOKUP_PEEK_LAST       0x40000018

#define MQ_LOOKUP_RECEIVE_CURRENT 0x40000020
#define MQ_LOOKUP_RECEIVE_NEXT    0x40000021
#define MQ_LOOKUP_RECEIVE_PREV    0x40000022
#define MQ_LOOKUP_RECEIVE_FIRST   0x40000024
#define MQ_LOOKUP_RECEIVE_LAST    0x40000028

//
// MQSendMessage,  MQReceiveMessage:  special cases for the transaction parameter
//
#define MQ_NO_TRANSACTION             NULL
#define MQ_MTS_TRANSACTION            (ITransaction *)1
#define MQ_XA_TRANSACTION             (ITransaction *)2
#define MQ_SINGLE_MESSAGE             (ITransaction *)3

//********************************************************************
//  PRIORITY LIMITS
//********************************************************************

//
//  Message priorities
//
#define MQ_MIN_PRIORITY          0    // Minimal message priority
#define MQ_MAX_PRIORITY          7    // Maximal message priority


//********************************************************************
//  MESSAGE PROPERTIES
//********************************************************************
#define PROPID_M_BASE					 0
#define PROPID_M_CLASS                   (PROPID_M_BASE + 1)     /* VT_UI2           */
#define PROPID_M_MSGID                   (PROPID_M_BASE + 2)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_CORRELATIONID           (PROPID_M_BASE + 3)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_PRIORITY                (PROPID_M_BASE + 4)     /* VT_UI1           */
#define PROPID_M_DELIVERY                (PROPID_M_BASE + 5)     /* VT_UI1           */
#define PROPID_M_ACKNOWLEDGE             (PROPID_M_BASE + 6)     /* VT_UI1           */
#define PROPID_M_JOURNAL                 (PROPID_M_BASE + 7)     /* VT_UI1           */
#define PROPID_M_APPSPECIFIC             (PROPID_M_BASE + 8)     /* VT_UI4           */
#define PROPID_M_BODY                    (PROPID_M_BASE + 9)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_BODY_SIZE               (PROPID_M_BASE + 10)    /* VT_UI4           */
#define PROPID_M_LABEL                   (PROPID_M_BASE + 11)    /* VT_LPWSTR        */
#define PROPID_M_LABEL_LEN               (PROPID_M_BASE + 12)    /* VT_UI4           */
#define PROPID_M_TIME_TO_REACH_QUEUE     (PROPID_M_BASE + 13)    /* VT_UI4           */
#define PROPID_M_TIME_TO_BE_RECEIVED     (PROPID_M_BASE + 14)    /* VT_UI4           */
#define PROPID_M_RESP_QUEUE              (PROPID_M_BASE + 15)    /* VT_LPWSTR        */
#define PROPID_M_RESP_QUEUE_LEN          (PROPID_M_BASE + 16)    /* VT_UI4           */
#define PROPID_M_ADMIN_QUEUE             (PROPID_M_BASE + 17)    /* VT_LPWSTR        */
#define PROPID_M_ADMIN_QUEUE_LEN         (PROPID_M_BASE + 18)    /* VT_UI4           */
#define PROPID_M_VERSION                 (PROPID_M_BASE + 19)    /* VT_UI4           */
#define PROPID_M_SENDERID                (PROPID_M_BASE + 20)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SENDERID_LEN            (PROPID_M_BASE + 21)    /* VT_UI4           */
#define PROPID_M_SENDERID_TYPE           (PROPID_M_BASE + 22)    /* VT_UI4           */
#define PROPID_M_PRIV_LEVEL              (PROPID_M_BASE + 23)    /* VT_UI4           */
#define PROPID_M_AUTH_LEVEL              (PROPID_M_BASE + 24)    /* VT_UI4           */
#define PROPID_M_AUTHENTICATED           (PROPID_M_BASE + 25)    /* VT_UI1           */
#define PROPID_M_HASH_ALG                (PROPID_M_BASE + 26)    /* VT_UI4           */
#define PROPID_M_ENCRYPTION_ALG          (PROPID_M_BASE + 27)    /* VT_UI4           */
#define PROPID_M_SENDER_CERT             (PROPID_M_BASE + 28)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SENDER_CERT_LEN         (PROPID_M_BASE + 29)    /* VT_UI4           */
#define PROPID_M_SRC_MACHINE_ID          (PROPID_M_BASE + 30)    /* VT_CLSID         */
#define PROPID_M_SENTTIME                (PROPID_M_BASE + 31)    /* VT_UI4           */
#define PROPID_M_ARRIVEDTIME             (PROPID_M_BASE + 32)    /* VT_UI4           */
#define PROPID_M_DEST_QUEUE              (PROPID_M_BASE + 33)    /* VT_LPWSTR        */
#define PROPID_M_DEST_QUEUE_LEN          (PROPID_M_BASE + 34)    /* VT_UI4           */
#define PROPID_M_EXTENSION               (PROPID_M_BASE + 35)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_EXTENSION_LEN           (PROPID_M_BASE + 36)    /* VT_UI4           */
#define PROPID_M_SECURITY_CONTEXT        (PROPID_M_BASE + 37)    /* VT_UI4           */
#define PROPID_M_CONNECTOR_TYPE          (PROPID_M_BASE + 38)    /* VT_CLSID         */
#define PROPID_M_XACT_STATUS_QUEUE       (PROPID_M_BASE + 39)    /* VT_LPWSTR        */
#define PROPID_M_XACT_STATUS_QUEUE_LEN   (PROPID_M_BASE + 40)    /* VT_UI4           */
#define PROPID_M_TRACE                   (PROPID_M_BASE + 41)    /* VT_UI1           */
#define PROPID_M_BODY_TYPE               (PROPID_M_BASE + 42)    /* VT_UI4           */
#define PROPID_M_DEST_SYMM_KEY           (PROPID_M_BASE + 43)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_DEST_SYMM_KEY_LEN       (PROPID_M_BASE + 44)    /* VT_UI4           */
#define PROPID_M_SIGNATURE               (PROPID_M_BASE + 45)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SIGNATURE_LEN           (PROPID_M_BASE + 46)    /* VT_UI4           */
#define PROPID_M_PROV_TYPE               (PROPID_M_BASE + 47)    /* VT_UI4           */
#define PROPID_M_PROV_NAME               (PROPID_M_BASE + 48)    /* VT_LPWSTR        */
#define PROPID_M_PROV_NAME_LEN           (PROPID_M_BASE + 49)    /* VT_UI4           */
#define PROPID_M_FIRST_IN_XACT           (PROPID_M_BASE + 50)    /* VT_UI1           */
#define PROPID_M_LAST_IN_XACT            (PROPID_M_BASE + 51)    /* VT_UI1           */
#define PROPID_M_XACTID                  (PROPID_M_BASE + 52)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_AUTHENTICATED_EX        (PROPID_M_BASE + 53)    /* VT_UI1           */
#define PROPID_M_RESP_FORMAT_NAME        (PROPID_M_BASE + 54)    /* VT_LPWSTR        */
#define PROPID_M_RESP_FORMAT_NAME_LEN    (PROPID_M_BASE + 55)    /* VT_UI4           */
#define PROPID_M_DEST_FORMAT_NAME        (PROPID_M_BASE + 58)    /* VT_LPWSTR        */
#define PROPID_M_DEST_FORMAT_NAME_LEN    (PROPID_M_BASE + 59)    /* VT_UI4           */
#define PROPID_M_LOOKUPID                (PROPID_M_BASE + 60)    /* VT_UI8           */
#define PROPID_M_SOAP_ENVELOPE			 (PROPID_M_BASE + 61)    /* VT_LPWSTR        */
#define PROPID_M_SOAP_ENVELOPE_LEN		 (PROPID_M_BASE + 62)    /* VT_UI4           */
#define PROPID_M_COMPOUND_MESSAGE		 (PROPID_M_BASE + 63)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_COMPOUND_MESSAGE_SIZE	 (PROPID_M_BASE + 64)    /* VT_UI4           */
#define PROPID_M_SOAP_HEADER             (PROPID_M_BASE + 65)    /* VT_LPWSTR        */
#define PROPID_M_SOAP_BODY               (PROPID_M_BASE + 66)    /* VT_LPWSTR        */

//
// Message Property Size
//
#define PROPID_M_MSGID_SIZE         20
#define PROPID_M_CORRELATIONID_SIZE 20
#define PROPID_M_XACTID_SIZE        20


//********************************************************************
//  MESSAGE CLASS VALUES
//********************************************************************
//
//  Message class values are 16 bits laid out as follows:
//
//   1 1 1 1 1 1
//   5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-------+-----------------+
//  |S|R|H|Reserve|   Class code    |
//  +-+-+-+-------+-----------------+
//
//  where
//
//      S - is the severity flag
//          0 - Normal Message/Positive Acknowledgment (ACK)
//          1 - Negative Acknowledgment (NACK)
//
//      R - is the receive flag
//          0 - Arrival ACK/NACK
//          1 - Receive ACK/NACK
//
//      H - is http flag
//          0 - no http
//          1 - http 

#define MQCLASS_CODE(s, r, code) ((USHORT)(((s) << 15) | ((r) << 14) | (code)))
#define MQCLASS_NACK(c)     ((c) & 0x8000)
#define MQCLASS_RECEIVE(c)  ((c) & 0x4000)

#define MQCLASS_NACK_HTTP(c) (((c) & 0xA000) == 0xA000)



//
//  Normal message
//
#define MQMSG_CLASS_NORMAL                      MQCLASS_CODE(0, 0, 0x00)

//
//  Report message
//
#define MQMSG_CLASS_REPORT                      MQCLASS_CODE(0, 0, 0x01)

//
//  Arrival acknowledgment. The message has reached its destination queue
//
#define MQMSG_CLASS_ACK_REACH_QUEUE             MQCLASS_CODE(0, 0, 0x02)

//
//  Receive acknowledgment. The message has been received by an application
//
#define MQMSG_CLASS_ACK_RECEIVE                 MQCLASS_CODE(0, 1, 0x00)


//-----------------------------------------------
//
//  Negative arrival acknowledgments
//

//
//  Destination queue cannot be reached, the queue may have been deleted
//
#define MQMSG_CLASS_NACK_BAD_DST_Q              MQCLASS_CODE(1, 0, 0x00)

//
//  The message was purged before reaching its destination queue
//
#define MQMSG_CLASS_NACK_PURGED                 MQCLASS_CODE(1, 0, 0x01)

//
//  Time to reach queue has expired
//
#define MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT    MQCLASS_CODE(1, 0, 0x02)

//
//  The message has exceeded the queue quota
//
#define MQMSG_CLASS_NACK_Q_EXCEED_QUOTA         MQCLASS_CODE(1, 0, 0x03)

//
//  The sender does not have send access rights to the queue.
//
#define MQMSG_CLASS_NACK_ACCESS_DENIED          MQCLASS_CODE(1, 0, 0x04)

//
//  The message hop count was exceeded
//
#define MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED     MQCLASS_CODE(1, 0, 0x05)

//
//  The message signature is bad. The message could not be authenticated.
//
#define MQMSG_CLASS_NACK_BAD_SIGNATURE          MQCLASS_CODE(1, 0, 0x06)

//
//  The message could not be decrypted.
//
#define MQMSG_CLASS_NACK_BAD_ENCRYPTION         MQCLASS_CODE(1, 0, 0x07)

//
//  The message could not be encrypted for the destination.
//
#define MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT      MQCLASS_CODE(1, 0, 0x08)

//
//  The message was sent to a non-transactional queue within a transaction.
//
#define MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q    MQCLASS_CODE(1, 0, 0x09)

//
//  The message was sent to a transactional queue not within a transaction.
//
#define MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG  MQCLASS_CODE(1, 0, 0x0A)

//
//  The requested crypto provider for encryption is not supported by the destination.
//
#define MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER  MQCLASS_CODE(1, 0, 0x0B)


//-----------------------------------------------
//
//  Negative receive acknowledgments
//

//
//  The queue was deleted, after the message arrived
//
#define MQMSG_CLASS_NACK_Q_DELETED              MQCLASS_CODE(1, 1, 0x00)

//
//  The message was purged at the destination queue
//
#define MQMSG_CLASS_NACK_Q_PURGED               MQCLASS_CODE(1, 1, 0x01)

//
//  Time to receive has expired while the message was still in its destination queue
//  (generated by destination)
//
#define MQMSG_CLASS_NACK_RECEIVE_TIMEOUT        MQCLASS_CODE(1, 1, 0x02)

//
//  Time to receive has expired while the message was still in its local outgoing queue
//  (generated locally by sender)
//
#define MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER  MQCLASS_CODE(1, 1, 0x03)


//------ PROPID_M_ACKNOWLEDGE ---------------
#define MQMSG_ACKNOWLEDGMENT_NONE           0x00

#define MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL    0x01
#define MQMSG_ACKNOWLEDGMENT_POS_RECEIVE    0x02
#define MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL    0x04
#define MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE    0x08

#define MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL ))

#define MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL ))

#define MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE ))

#define MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE |  \
            MQMSG_ACKNOWLEDGMENT_POS_RECEIVE ))

//------ PROPID_M_DELIVERY ------------------
#define MQMSG_DELIVERY_EXPRESS              0
#define MQMSG_DELIVERY_RECOVERABLE          1

//----- PROPID_M_JOURNAL --------------------
#define MQMSG_JOURNAL_NONE                  0
#define MQMSG_DEADLETTER                    1
#define MQMSG_JOURNAL                       2

//----- PROPID_M_TRACE ----------------------
#define MQMSG_TRACE_NONE                    0
#define MQMSG_SEND_ROUTE_TO_REPORT_QUEUE    1

//----- PROPID_M_SENDERID_TYPE --------------
#define MQMSG_SENDERID_TYPE_NONE            0
#define MQMSG_SENDERID_TYPE_SID             1

//----- PROPID_M_PRIV_LEVEL -----------------
#define MQMSG_PRIV_LEVEL_NONE               0
#define MQMSG_PRIV_LEVEL_BODY               0x01
#define MQMSG_PRIV_LEVEL_BODY_BASE          0x01
#define MQMSG_PRIV_LEVEL_BODY_ENHANCED      0x03

//----- PROPID_M_AUTH_LEVEL -----------------
#define MQMSG_AUTH_LEVEL_NONE				0
#define MQMSG_AUTH_LEVEL_ALWAYS				1

//
// MQMSG_AUTH_LEVEL_MSMQxx are obsolete 
// you should use MQMSG_AUTH_LEVEL_SIGxx
//
#define MQMSG_AUTH_LEVEL_MSMQ10				2
#define MQMSG_AUTH_LEVEL_MSMQ20				4

#define MQMSG_AUTH_LEVEL_SIG10 				2
#define MQMSG_AUTH_LEVEL_SIG20 				4
#define MQMSG_AUTH_LEVEL_SIG30 				8


//----- PROPID_M_AUTHENTICATED -----------------
//----- PROPID_M_AUTHENTICATED_EX --------------
#define MQMSG_AUTHENTICATION_NOT_REQUESTED  0
#define MQMSG_AUTHENTICATION_REQUESTED      1

//
// MQMSG_AUTHENTICATION_REQUESTED_EX is obsolete 
// use the values MQMSG_AUTHENTICATED_SIGxx
// for PROPID_M_AUTHENTICATED_EX
//
#define MQMSG_AUTHENTICATION_REQUESTED_EX   3

#define MQMSG_AUTHENTICATED_SIG10			1
#define MQMSG_AUTHENTICATED_SIG20			3
#define MQMSG_AUTHENTICATED_SIG30			5
#define MQMSG_AUTHENTICATED_SIGXML			9


//----- PROPID_M_FIRST_IN_XACT --------------
#define MQMSG_NOT_FIRST_IN_XACT             0
#define MQMSG_FIRST_IN_XACT                 1

//----- PROPID_M_LAST_IN_XACT  --------------
#define MQMSG_NOT_LAST_IN_XACT              0
#define MQMSG_LAST_IN_XACT                  1



//********************************************************************
//  QUEUE PROPERTIES
//********************************************************************
#define PROPID_Q_BASE           100
#define PROPID_Q_INSTANCE       (PROPID_Q_BASE +  1)  /* VT_CLSID     */
#define PROPID_Q_TYPE           (PROPID_Q_BASE +  2)  /* VT_CLSID     */
#define PROPID_Q_PATHNAME       (PROPID_Q_BASE +  3)  /* VT_LPWSTR    */
#define PROPID_Q_JOURNAL        (PROPID_Q_BASE +  4)  /* VT_UI1       */
#define PROPID_Q_QUOTA          (PROPID_Q_BASE +  5)  /* VT_UI4       */
#define PROPID_Q_BASEPRIORITY   (PROPID_Q_BASE +  6)  /* VT_I2        */
#define PROPID_Q_JOURNAL_QUOTA  (PROPID_Q_BASE +  7)  /* VT_UI4       */
#define PROPID_Q_LABEL          (PROPID_Q_BASE +  8)  /* VT_LPWSTR    */
#define PROPID_Q_CREATE_TIME    (PROPID_Q_BASE +  9)  /* VT_I4        */
#define PROPID_Q_MODIFY_TIME    (PROPID_Q_BASE + 10)  /* VT_I4        */
#define PROPID_Q_AUTHENTICATE   (PROPID_Q_BASE + 11)  /* VT_UI1       */
#define PROPID_Q_PRIV_LEVEL     (PROPID_Q_BASE + 12)  /* VT_UI4       */
#define PROPID_Q_TRANSACTION    (PROPID_Q_BASE + 13)  /* VT_UI1       */
#define PROPID_Q_PATHNAME_DNS  (PROPID_Q_BASE + 24)  /* VT_LPWSTR    */
#define PROPID_Q_MULTICAST_ADDRESS (PROPID_Q_BASE + 25)  /* VT_LPWSTR */
#define PROPID_Q_ADS_PATH      (PROPID_Q_BASE + 26)  /* VT_LPWSTR    */


//----- PROPID_Q_JOURNAL ------------------
#define MQ_JOURNAL_NONE     (unsigned char)0
#define MQ_JOURNAL          (unsigned char)1

//----- PROPID_Q_TYPE ------------------
//  {55EE8F32-CCE9-11cf-B108-0020AFD61CE9}
#define MQ_QTYPE_REPORT {0x55ee8f32, 0xcce9, 0x11cf, \
                        {0xb1, 0x8, 0x0, 0x20, 0xaf, 0xd6, 0x1c, 0xe9}}

//  {55EE8F33-CCE9-11cf-B108-0020AFD61CE9}
#define MQ_QTYPE_TEST   {0x55ee8f33, 0xcce9, 0x11cf, \
                        {0xb1, 0x8, 0x0, 0x20, 0xaf, 0xd6, 0x1c, 0xe9}}

//----- PROPID_Q_TRANSACTION ------------------
#define MQ_TRANSACTIONAL_NONE     (unsigned char)0
#define MQ_TRANSACTIONAL          (unsigned char)1

//----- PROPID_Q_AUTHENTICATE ------------------
#define MQ_AUTHENTICATE_NONE      (unsigned char)0
#define MQ_AUTHENTICATE           (unsigned char)1

//----- PROPID_Q_PRIV_LEVEL ------------------
#define MQ_PRIV_LEVEL_NONE        (unsigned long)0
#define MQ_PRIV_LEVEL_OPTIONAL    (unsigned long)1
#define MQ_PRIV_LEVEL_BODY        (unsigned long)2


//********************************************************************
//  MACHINE PROPERTIES
//********************************************************************
#define PROPID_QM_BASE 200

#define PROPID_QM_SITE_ID                   (PROPID_QM_BASE +  1) /* VT_CLSID            */
#define PROPID_QM_MACHINE_ID                (PROPID_QM_BASE +  2) /* VT_CLSID            */
#define PROPID_QM_PATHNAME                  (PROPID_QM_BASE +  3) /* VT_LPWSTR           */
#define PROPID_QM_CONNECTION                (PROPID_QM_BASE +  4) /* VT_LPWSTR|VT_VECTOR */
#define PROPID_QM_ENCRYPTION_PK             (PROPID_QM_BASE +  5) /* VT_UI1|VT_VECTOR	 */
#define PROPID_QM_ENCRYPTION_PK_BASE        (PROPID_QM_BASE + 31)  /* VT_UI1|VT_VECTOR  */
#define PROPID_QM_ENCRYPTION_PK_ENHANCED    (PROPID_QM_BASE + 32)  /* VT_UI1|VT_VECTOR  */
#define PROPID_QM_PATHNAME_DNS              (PROPID_QM_BASE + 33)  /* VT_LPWSTR         */

//********************************************************************
//  PRIVATE COMPUTER PROPERTIES
//********************************************************************
#define PROPID_PC_BASE 5800

#define PROPID_PC_VERSION             (PROPID_PC_BASE + 1) /* VT_UI4            */
#define PROPID_PC_DS_ENABLED          (PROPID_PC_BASE + 2) /* VT_BOOL           */

//********************************************************************
//  LOCAL ADMIN MSMQ MACHINE PROPERTIES
//********************************************************************
#define PROPID_MGMT_MSMQ_BASE           0
#define PROPID_MGMT_MSMQ_ACTIVEQUEUES   (PROPID_MGMT_MSMQ_BASE + 1) /* VT_LPWSTR | VT_VECTOR  */
#define PROPID_MGMT_MSMQ_PRIVATEQ       (PROPID_MGMT_MSMQ_BASE + 2) /* VT_LPWSTR | VT_VECTOR  */
#define PROPID_MGMT_MSMQ_DSSERVER       (PROPID_MGMT_MSMQ_BASE + 3) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_CONNECTED      (PROPID_MGMT_MSMQ_BASE + 4) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_TYPE           (PROPID_MGMT_MSMQ_BASE + 5) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_BYTES_IN_ALL_QUEUES (PROPID_MGMT_QUEUE_BASE + 6)    /* VT_UI8    */


//
// Returned Value for PROPID_MGMT_MSMQ_CONNECTED property
//
#define MSMQ_CONNECTED      L"CONNECTED"
#define MSMQ_DISCONNECTED   L"DISCONNECTED"


//********************************************************************
//  LOCAL ADMIN MSMQ QUEUE PROPERTIES
//********************************************************************
#define PROPID_MGMT_QUEUE_BASE                  0
#define PROPID_MGMT_QUEUE_PATHNAME              (PROPID_MGMT_QUEUE_BASE + 1)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_FORMATNAME            (PROPID_MGMT_QUEUE_BASE + 2)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_TYPE                  (PROPID_MGMT_QUEUE_BASE + 3)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_LOCATION              (PROPID_MGMT_QUEUE_BASE + 4)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_XACT                  (PROPID_MGMT_QUEUE_BASE + 5)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_FOREIGN               (PROPID_MGMT_QUEUE_BASE + 6)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_MESSAGE_COUNT         (PROPID_MGMT_QUEUE_BASE + 7)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_BYTES_IN_QUEUE        (PROPID_MGMT_QUEUE_BASE + 8)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT (PROPID_MGMT_QUEUE_BASE + 9)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL      (PROPID_MGMT_QUEUE_BASE + 10)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_STATE                 (PROPID_MGMT_QUEUE_BASE + 11)   /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_NEXTHOPS              (PROPID_MGMT_QUEUE_BASE + 12)   /* VT_LPWSTR|VT_VECTOR  */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK          (PROPID_MGMT_QUEUE_BASE + 13)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME     (PROPID_MGMT_QUEUE_BASE + 14)   /* VT_I4     */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK_COUNT    (PROPID_MGMT_QUEUE_BASE + 15)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK     (PROPID_MGMT_QUEUE_BASE + 16)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK      (PROPID_MGMT_QUEUE_BASE + 17)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_NEXT_SEQ          (PROPID_MGMT_QUEUE_BASE + 18)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT     (PROPID_MGMT_QUEUE_BASE + 19)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT      (PROPID_MGMT_QUEUE_BASE + 20)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_RESEND_TIME       (PROPID_MGMT_QUEUE_BASE + 21)   /* VT_I4     */
#define PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL   (PROPID_MGMT_QUEUE_BASE + 22)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_RESEND_COUNT      (PROPID_MGMT_QUEUE_BASE + 23)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_SOURCE_INFO       (PROPID_MGMT_QUEUE_BASE + 24)   /* VT_VARIANT|VT_VECTOR */


//
// Olbselete alternative names for "Bytes in ..."
//
#define PROPID_MGMT_QUEUE_USED_QUOTA            PROPID_MGMT_QUEUE_BYTES_IN_QUEUE          
#define PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA    PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL        

//
// Returned value for PROPID_MGMT_QUEUE_TYPE
//
#define MGMT_QUEUE_TYPE_PUBLIC      L"PUBLIC"
#define MGMT_QUEUE_TYPE_PRIVATE     L"PRIVATE"
#define MGMT_QUEUE_TYPE_MACHINE     L"MACHINE"
#define MGMT_QUEUE_TYPE_CONNECTOR   L"CONNECTOR"
#define MGMT_QUEUE_TYPE_MULTICAST   L"MULTICAST"

//
// Returned value for PROPID_MGMT_QUEUE_STATE
//
#define MGMT_QUEUE_STATE_LOCAL          L"LOCAL CONNECTION"
#define MGMT_QUEUE_STATE_NONACTIVE      L"INACTIVE"
#define MGMT_QUEUE_STATE_WAITING        L"WAITING"
#define MGMT_QUEUE_STATE_NEED_VALIDATE  L"NEED VALIDATION"
#define MGMT_QUEUE_STATE_ONHOLD         L"ONHOLD"
#define MGMT_QUEUE_STATE_CONNECTED      L"CONNECTED"
#define MGMT_QUEUE_STATE_DISCONNECTING  L"DISCONNECTING"
#define MGMT_QUEUE_STATE_DISCONNECTED   L"DISCONNECTED"

//
// Returned value for PROPID_MGMT_QUEUE_LOCATION
//
#define MGMT_QUEUE_LOCAL_LOCATION   L"LOCAL"
#define MGMT_QUEUE_REMOTE_LOCATION  L"REMOTE"

// 
// Returned Value for PROPID_MGMT_QUEUE_XACT and PROPID_MGMT_QUEUE_FOREIGN
//

#define MGMT_QUEUE_UNKNOWN_TYPE     L"UNKNOWN"

//
// Obselete names left for backword compatibility.
//

#define MGMT_QUEUE_CORRECT_TYPE     L"YES"
#define MGMT_QUEUE_INCORRECT_TYPE   L"NO"

//
// Names for Returned Value for PROPID_MGMT_QUEUE_XACT 
//

//#define MGMT_QUEUE_UNKNOWN_TYPE     	L"UNKNOWN"
#define MGMT_QUEUE_TRANSACTIONAL_TYPE  	L"YES"
#define MGMT_QUEUE_NOT_TRANSACTIONAL_TYPE   L"NO"

//
// Names for Returned Value for PROPID_MGMT_QUEUE_FOREIGN
//

//#define MGMT_QUEUE_UNKNOWN_TYPE     	L"UNKNOWN"
#define MGMT_QUEUE_FOREIGN_TYPE         L"YES"
#define MGMT_QUEUE_NOT_FOREIGN_TYPE     L"NO"

//
// Object parameter values for MQMgmtAction API
//
#define MO_MACHINE_TOKEN    L"MACHINE"
#define MO_QUEUE_TOKEN      L"QUEUE"

//
// Action parameter values for MQMgmtAction API
//
#define MACHINE_ACTION_CONNECT      L"CONNECT"
#define MACHINE_ACTION_DISCONNECT   L"DISCONNECT"
#define MACHINE_ACTION_TIDY         L"TIDY"

#define QUEUE_ACTION_PAUSE      L"PAUSE"
#define QUEUE_ACTION_RESUME     L"RESUME"
#define QUEUE_ACTION_EOD_RESEND L"EOD_RESEND"

//
// LONG_LIVED is the default for PROPID_M_TIME_TO_REACH_QUEUE. If calls
// to MQSendMessage() specify this value, or not specify this property at
// all, then the actual timeout is obtained from Active Directory.
//
#define LONG_LIVED    0xfffffffe

//
// Success
//
#define MQ_OK                       0L


#ifndef FACILITY_MSMQ
#define FACILITY_MSMQ               0x0E
#endif


//
//  Error
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MQ_ERROR
//
// MessageText:
//
//  Generic error code.
//
#define MQ_ERROR                         0xC00E0001L

//
// MessageId: MQ_ERROR_PROPERTY
//
// MessageText:
//
//  One or more of the properties passed are invalid.
//
#define MQ_ERROR_PROPERTY                0xC00E0002L

//
// MessageId: MQ_ERROR_QUEUE_NOT_FOUND
//
// MessageText:
//
//  The queue does not exist, or you do not have sufficient permissions to perform the operation.
//
#define MQ_ERROR_QUEUE_NOT_FOUND         0xC00E0003L

//
// MessageId: MQ_ERROR_QUEUE_EXISTS
//
// MessageText:
//
//  A queue with the same path name already exists.
//
#define MQ_ERROR_QUEUE_EXISTS            0xC00E0005L

//
// MessageId: MQ_ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  An invalid parameter was passed to a function.
//
#define MQ_ERROR_INVALID_PARAMETER       0xC00E0006L

//
// MessageId: MQ_ERROR_INVALID_HANDLE
//
// MessageText:
//
//  An invalid handle was passed to a function.
//
#define MQ_ERROR_INVALID_HANDLE          0xC00E0007L

//
// MessageId: MQ_ERROR_OPERATION_CANCELLED
//
// MessageText:
//
//  The operation was canceled before it could be completed.
//
#define MQ_ERROR_OPERATION_CANCELLED     0xC00E0008L

//
// MessageId: MQ_ERROR_SHARING_VIOLATION
//
// MessageText:
//
//  There is a sharing violation. The queue is already open for exclusive retrieval.
//
#define MQ_ERROR_SHARING_VIOLATION       0xC00E0009L

//
// MessageId: MQ_ERROR_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
//  The Message Queuing service is not available
//
#define MQ_ERROR_SERVICE_NOT_AVAILABLE   0xC00E000BL

//
// MessageId: MQ_ERROR_MACHINE_NOT_FOUND
//
// MessageText:
//
//  The computer specified cannot be found.
//
#define MQ_ERROR_MACHINE_NOT_FOUND       0xC00E000DL

//
// MessageId: MQ_ERROR_ILLEGAL_SORT
//
// MessageText:
//
//  The sort operation specified in MQLocateBegin is invalid (for example, there are duplicate columns).
//
#define MQ_ERROR_ILLEGAL_SORT            0xC00E0010L

//
// MessageId: MQ_ERROR_ILLEGAL_USER
//
// MessageText:
//
//  The user specified is not a valid user.
//
#define MQ_ERROR_ILLEGAL_USER            0xC00E0011L

//
// MessageId: MQ_ERROR_NO_DS
//
// MessageText:
//
//  A connection with Active Directory cannot be established. Verify that there are sufficient permissions to perform this operation.
//
#define MQ_ERROR_NO_DS                   0xC00E0013L

//
// MessageId: MQ_ERROR_ILLEGAL_QUEUE_PATHNAME
//
// MessageText:
//
//  The queue path name specified is invalid.
//
#define MQ_ERROR_ILLEGAL_QUEUE_PATHNAME  0xC00E0014L

//
// MessageId: MQ_ERROR_ILLEGAL_PROPERTY_VALUE
//
// MessageText:
//
//  The property value specified is invalid.
//
#define MQ_ERROR_ILLEGAL_PROPERTY_VALUE  0xC00E0018L

//
// MessageId: MQ_ERROR_ILLEGAL_PROPERTY_VT
//
// MessageText:
//
//  The VARTYPE value specified is invalid.
//
#define MQ_ERROR_ILLEGAL_PROPERTY_VT     0xC00E0019L

//
// MessageId: MQ_ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
//  The buffer supplied to MQReceiveMessage for message property retrieval
//  is too small. The message was not removed from the queue, but the part
//  of the message property that was in the buffer was copied.
//
#define MQ_ERROR_BUFFER_OVERFLOW         0xC00E001AL

//
// MessageId: MQ_ERROR_IO_TIMEOUT
//
// MessageText:
//
//  The time specified for MQReceiveMessage to wait for the message elapsed.
//
#define MQ_ERROR_IO_TIMEOUT              0xC00E001BL

//
// MessageId: MQ_ERROR_ILLEGAL_CURSOR_ACTION
//
// MessageText:
//
//  The MQ_ACTION_PEEK_NEXT value specified for MQReceiveMessage cannot be used with
//  the current cursor position.
//
#define MQ_ERROR_ILLEGAL_CURSOR_ACTION   0xC00E001CL

//
// MessageId: MQ_ERROR_MESSAGE_ALREADY_RECEIVED
//
// MessageText:
//
//  The message at which the cursor is currently pointing was removed from
//  the queue by another process or by another call to MQReceiveMessage
//  without the use of this cursor.
//
#define MQ_ERROR_MESSAGE_ALREADY_RECEIVED 0xC00E001DL

//
// MessageId: MQ_ERROR_ILLEGAL_FORMATNAME
//
// MessageText:
//
//  The format name specified is invalid.
//
#define MQ_ERROR_ILLEGAL_FORMATNAME      0xC00E001EL

//
// MessageId: MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The format name buffer supplied to the API was too small
//  to hold the format name.
//
#define MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL 0xC00E001FL

//
// MessageId: MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION
//
// MessageText:
//
//  Operations of the type requested (for example, deleting a queue using a direct format name)
//  are not supported for the format name specified.
//
#define MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION 0xC00E0020L

//
// MessageId: MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR
//
// MessageText:
//
//  The specified security descriptor is invalid.
//
#define MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR 0xC00E0021L

//
// MessageId: MQ_ERROR_SENDERID_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The size of the buffer for the user ID property is too small.
//
#define MQ_ERROR_SENDERID_BUFFER_TOO_SMALL 0xC00E0022L

//
// MessageId: MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL
//
// MessageText:
//
//  The size of the buffer passed to MQGetQueueSecurity is too small.
//
#define MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL 0xC00E0023L

//
// MessageId: MQ_ERROR_CANNOT_IMPERSONATE_CLIENT
//
// MessageText:
//
//  The security credentials cannot be verified because the RPC server
//  cannot impersonate the client application.
//
#define MQ_ERROR_CANNOT_IMPERSONATE_CLIENT 0xC00E0024L

//
// MessageId: MQ_ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define MQ_ERROR_ACCESS_DENIED           0xC00E0025L

//
// MessageId: MQ_ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//  The client does not have sufficient security privileges to perform the operation.
//
#define MQ_ERROR_PRIVILEGE_NOT_HELD      0xC00E0026L

//
// MessageId: MQ_ERROR_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  There are insufficient resources to perform this operation.
//
#define MQ_ERROR_INSUFFICIENT_RESOURCES  0xC00E0027L

//
// MessageId: MQ_ERROR_USER_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The request failed because the user buffer is too small to hold the information returned.
//
#define MQ_ERROR_USER_BUFFER_TOO_SMALL   0xC00E0028L

//
// MessageId: MQ_ERROR_MESSAGE_STORAGE_FAILED
//
// MessageText:
//
//  A recoverable or journal message could not be stored. The message was not sent.
//
#define MQ_ERROR_MESSAGE_STORAGE_FAILED  0xC00E002AL

//
// MessageId: MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer for the user certificate property is too small.
//
#define MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL 0xC00E002BL

//
// MessageId: MQ_ERROR_INVALID_CERTIFICATE
//
// MessageText:
//
//  The user certificate is invalid.
//
#define MQ_ERROR_INVALID_CERTIFICATE     0xC00E002CL

//
// MessageId: MQ_ERROR_CORRUPTED_INTERNAL_CERTIFICATE
//
// MessageText:
//
//  The internal Message Queuing certificate is corrupted.
//
#define MQ_ERROR_CORRUPTED_INTERNAL_CERTIFICATE 0xC00E002DL


//
// MessageId: MQ_ERROR_NO_INTERNAL_USER_CERT
//
// MessageText:
//
//  No internal Message Queuing certificate exists for the user.
//
#define MQ_ERROR_NO_INTERNAL_USER_CERT   0xC00E002FL

//
// MessageId: MQ_ERROR_CORRUPTED_SECURITY_DATA
//
// MessageText:
//
//  A cryptographic function failed.
//
#define MQ_ERROR_CORRUPTED_SECURITY_DATA 0xC00E0030L

//
// MessageId: MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE
//
// MessageText:
//
//  The personal certificate store is corrupted.
//
#define MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE 0xC00E0031L

//
// MessageId: MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION
//
// MessageText:
//
//  The computer does not support encryption operations.
//
#define MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION 0xC00E0033L

//
// MessageId: MQ_ERROR_BAD_SECURITY_CONTEXT
//
// MessageText:
//
//  The security context is invalid.
//
#define MQ_ERROR_BAD_SECURITY_CONTEXT    0xC00E0035L

//
// MessageId: MQ_ERROR_COULD_NOT_GET_USER_SID
//
// MessageText:
//
//  The SID cannot be obtained from the thread token.
//
#define MQ_ERROR_COULD_NOT_GET_USER_SID  0xC00E0036L

//
// MessageId: MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO
//
// MessageText:
//
//  The account information for the user cannot be obtained.
//
#define MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO 0xC00E0037L

//
// MessageId: MQ_ERROR_ILLEGAL_MQCOLUMNS
//
// MessageText:
//
//  The MQCOLUMNS parameter is invalid.
//
#define MQ_ERROR_ILLEGAL_MQCOLUMNS       0xC00E0038L

//
// MessageId: MQ_ERROR_ILLEGAL_PROPID
//
// MessageText:
//
//  A property identifier is invalid.
//
#define MQ_ERROR_ILLEGAL_PROPID          0xC00E0039L

//
// MessageId: MQ_ERROR_ILLEGAL_RELATION
//
// MessageText:
//
//  A relationship parameter is invalid.
//
#define MQ_ERROR_ILLEGAL_RELATION        0xC00E003AL

//
// MessageId: MQ_ERROR_ILLEGAL_PROPERTY_SIZE
//
// MessageText:
//
//  The size of the buffer for the message identifier or correlation identifier is invalid.
//
#define MQ_ERROR_ILLEGAL_PROPERTY_SIZE   0xC00E003BL

//
// MessageId: MQ_ERROR_ILLEGAL_RESTRICTION_PROPID
//
// MessageText:
//
//  A property identifier specified in MQRESTRICTION is invalid.
//
#define MQ_ERROR_ILLEGAL_RESTRICTION_PROPID 0xC00E003CL

//
// MessageId: MQ_ERROR_ILLEGAL_MQQUEUEPROPS
//
// MessageText:
//
//  Either the pointer to the MQQUEUEPROPS structure has a null value, or no properties are specified in it.
//
#define MQ_ERROR_ILLEGAL_MQQUEUEPROPS    0xC00E003DL

//
// MessageId: MQ_ERROR_PROPERTY_NOTALLOWED
//
// MessageText:
//
//  The property identifier specified (for example, PROPID_Q_INSTANCE in MQSetQueueProperties)
//  is invalid for the operation requested.
//
#define MQ_ERROR_PROPERTY_NOTALLOWED     0xC00E003EL

//
// MessageId: MQ_ERROR_INSUFFICIENT_PROPERTIES
//
// MessageText:
//
//  Not all the properties required for the operation were specified
//  for the input parameters.
//
#define MQ_ERROR_INSUFFICIENT_PROPERTIES 0xC00E003FL

//
// MessageId: MQ_ERROR_MACHINE_EXISTS
//
// MessageText:
//
//  A computer with the same name already exists in the site. Either the computer object already exists
//  (for a Windows NT enterprise), or the MSMQ Configuration (msmq) object already exists for the applicable computer
//  object in Active directory (for a Windows 2000 or Windows Whistler forest).
//
#define MQ_ERROR_MACHINE_EXISTS          0xC00E0040L

//
// MessageId: MQ_ERROR_ILLEGAL_MQQMPROPS
//
// MessageText:
//
//  Either the pointer to the MQQMROPS structure has a null value, or no properties are specified in it.
//
#define MQ_ERROR_ILLEGAL_MQQMPROPS       0xC00E0041L

//
// MessageId: MQ_ERROR_DS_IS_FULL
//
// MessageText:
//
//  Obsolete, kept for backward compatibility
//
#define MQ_ERROR_DS_IS_FULL              0xC00E0042L

//
// MessageId: MQ_ERROR_DS_ERROR
//
// MessageText:
//
//  There is an internal Active Directory error.
//
#define MQ_ERROR_DS_ERROR                0xC00E0043L

//
// MessageId: MQ_ERROR_INVALID_OWNER
//
// MessageText:
//
//  The object owner is invalid (for example, MQCreateQueue failed because the QM
//  object is invalid).
//
#define MQ_ERROR_INVALID_OWNER           0xC00E0044L

//
// MessageId: MQ_ERROR_UNSUPPORTED_ACCESS_MODE
//
// MessageText:
//
//  The access mode specified is unsupported.
//
#define MQ_ERROR_UNSUPPORTED_ACCESS_MODE 0xC00E0045L

//
// MessageId: MQ_ERROR_RESULT_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The result buffer specified is too small.
//
#define MQ_ERROR_RESULT_BUFFER_TOO_SMALL 0xC00E0046L

//
// MessageId: MQ_ERROR_DELETE_CN_IN_USE
//
// MessageText:
//
//  Obsolete, kept for backward compatibility
//
#define MQ_ERROR_DELETE_CN_IN_USE        0xC00E0048L

//
// MessageId: MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER
//
// MessageText:
//
//  There was no response from the object owner.
//
#define MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER 0xC00E0049L

//
// MessageId: MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE
//
// MessageText:
//
//  The object owner is not available.
//
#define MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE 0xC00E004AL

//
// MessageId: MQ_ERROR_QUEUE_NOT_AVAILABLE
//
// MessageText:
//
//  An error occurred while reading from a queue located on a remote computer.
//
#define MQ_ERROR_QUEUE_NOT_AVAILABLE     0xC00E004BL

//
// MessageId: MQ_ERROR_DTC_CONNECT
//
// MessageText:
//
//  A connection cannot be established with the Distributed Transaction Coordinator.
//
#define MQ_ERROR_DTC_CONNECT             0xC00E004CL

//
// MessageId: MQ_ERROR_TRANSACTION_IMPORT
//
// MessageText:
//
//  The transaction specified cannot be imported.
//
#define MQ_ERROR_TRANSACTION_IMPORT      0xC00E004EL

//
// MessageId: MQ_ERROR_TRANSACTION_USAGE
//
// MessageText:
//
//  An attempted action cannot be performed within a transaction.
//
#define MQ_ERROR_TRANSACTION_USAGE       0xC00E0050L

//
// MessageId: MQ_ERROR_TRANSACTION_SEQUENCE
//
// MessageText:
//
//  The transaction's operation sequence is incorrect.
//
#define MQ_ERROR_TRANSACTION_SEQUENCE    0xC00E0051L

//
// MessageId: MQ_ERROR_MISSING_CONNECTOR_TYPE
//
// MessageText:
//
//  The connector type message property is not specified. This property is required for sending an acknowledgment message or a secure message.
//
#define MQ_ERROR_MISSING_CONNECTOR_TYPE  0xC00E0055L

//
// MessageId: MQ_ERROR_STALE_HANDLE
//
// MessageText:
//
//  The Message Queuing service was restarted. Any open queue handles should be closed.
//
#define MQ_ERROR_STALE_HANDLE            0xC00E0056L

//
// MessageId: MQ_ERROR_TRANSACTION_ENLIST
//
// MessageText:
//
//  The transaction specified cannot be enlisted.
//
#define MQ_ERROR_TRANSACTION_ENLIST      0xC00E0058L

//
// MessageId: MQ_ERROR_QUEUE_DELETED
//
// MessageText:
//
//  The queue was deleted. Messages cannot be received anymore using this
//  queue handle. The handle should be closed.
//
#define MQ_ERROR_QUEUE_DELETED           0xC00E005AL

//
// MessageId: MQ_ERROR_ILLEGAL_CONTEXT
//
// MessageText:
//
//  The context parameter for MQLocateBegin is invalid.
//
#define MQ_ERROR_ILLEGAL_CONTEXT         0xC00E005BL

//
// MessageId: MQ_ERROR_ILLEGAL_SORT_PROPID
//
// MessageText:
//
//  An invalid property identifier is specified in MQSORTSET.
//
#define MQ_ERROR_ILLEGAL_SORT_PROPID     0xC00E005CL

//
// MessageId: MQ_ERROR_LABEL_TOO_LONG
//
// MessageText:
//
//  The message label is too long. Its length should be less than or equal to MQ_MAX_MSG_LABEL_LEN.
//
#define MQ_ERROR_LABEL_TOO_LONG          0xC00E005DL

//
// MessageId: MQ_ERROR_LABEL_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The label buffer supplied to the API is too small.
//
#define MQ_ERROR_LABEL_BUFFER_TOO_SMALL  0xC00E005EL

//
// MessageId: MQ_ERROR_MQIS_SERVER_EMPTY
//
// MessageText:
//
//  Obsolete, kept for backward compatibility
//
#define MQ_ERROR_MQIS_SERVER_EMPTY       0xC00E005FL

//
// MessageId: MQ_ERROR_MQIS_READONLY_MODE
//
// MessageText:
//
//  Obsolete, kept for backward compatibility
//
#define MQ_ERROR_MQIS_READONLY_MODE      0xC00E0060L

//
// MessageId: MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer passed for the symmetric key is too small.
//
#define MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL 0xC00E0061L

//
// MessageId: MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer passed for the signature property is too small.
//
#define MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL 0xC00E0062L

//
// MessageId: MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer passed for the provider name property is too small.
//
#define MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL 0xC00E0063L

//
// MessageId: MQ_ERROR_ILLEGAL_OPERATION
//
// MessageText:
//
//  The operation is invalid for a foreign message queuing system.
//
#define MQ_ERROR_ILLEGAL_OPERATION       0xC00E0064L

//
// MessageId: MQ_ERROR_WRITE_NOT_ALLOWED
//
// MessageText:
//
//  Obsolete; another MQIS server is being installed. Write operations to the database are not allowed at this stage.
//
#define MQ_ERROR_WRITE_NOT_ALLOWED       0xC00E0065L

//
// MessageId: MQ_ERROR_WKS_CANT_SERVE_CLIENT
//
// MessageText:
//
//  Independent clients cannot support dependent clients.
//
#define MQ_ERROR_WKS_CANT_SERVE_CLIENT   0xC00E0066L

//
// MessageId: MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW
//
// MessageText:
//
//  The number of dependent clients served by the Message Queuing server reached its upper limit.
//
#define MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW 0xC00E0067L

//
// MessageId: MQ_CORRUPTED_QUEUE_WAS_DELETED
//
// MessageText:
//
//  The file %1 for the queue %2 in the Lqs folder was deleted because it was corrupted.
//
#define MQ_CORRUPTED_QUEUE_WAS_DELETED   0xC00E0068L

//
// MessageId: MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE
//
// MessageText:
//
//  The remote computer is not available.
//
#define MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE 0xC00E0069L

//
// MessageId: MQ_ERROR_UNSUPPORTED_OPERATION
//
// MessageText:
//
//  This operation is not supported for Message Queuing installed in workgroup mode.
//
#define MQ_ERROR_UNSUPPORTED_OPERATION   0xC00E006AL

//
// MessageId: MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED
//
// MessageText:
//
//  The cryptographic service provider %1 is not supported by Message Queuing.
//
#define MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED 0xC00E006BL

//
// MessageId: MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR
//
// MessageText:
//
//  The security descriptors for the cryptographic keys cannot be set.
//
#define MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR 0xC00E006CL

//
// MessageId: MQ_ERROR_CERTIFICATE_NOT_PROVIDED
//
// MessageText:
//
//  A user attempted to send an authenticated message without a certificate.
//
#define MQ_ERROR_CERTIFICATE_NOT_PROVIDED 0xC00E006DL

//
// MessageId: MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED
//
// MessageText:
//
//  The column PROPID_Q_PATHNAME_DNS is not supported for the MQLocateBegin API.
//
#define MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED 0xC00E006EL

//
// MessageId: MQ_ERROR_CANNOT_CREATE_CERT_STORE
//
// MessageText:
//
//  A certificate store cannot be created for the internal certificate.
//
#define MQ_ERROR_CANNOT_CREATE_CERT_STORE 0xC00E006FL

//
// MessageId: MQ_ERROR_CANNOT_OPEN_CERT_STORE
//
// MessageText:
//
//  The certificate store for the internal certificate cannot be opened.
//
#define MQ_ERROR_CANNOT_OPEN_CERT_STORE  0xC00E0070L

//
// MessageId: MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION
//
// MessageText:
//
//  This operation is invalid for an MsmqServices object.
//
#define MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION 0xC00E0071L

//
// MessageId: MQ_ERROR_CANNOT_GRANT_ADD_GUID
//
// MessageText:
//
//  The Add GUID permission cannot be granted to the current user.
//
#define MQ_ERROR_CANNOT_GRANT_ADD_GUID   0xC00E0072L

//
// MessageId: MQ_ERROR_CANNOT_LOAD_MSMQOCM
//
// MessageText:
//
//  Obsolete: The dynamic-link library Msmqocm.dll cannot be loaded.
//
#define MQ_ERROR_CANNOT_LOAD_MSMQOCM     0xC00E0073L

//
// MessageId: MQ_ERROR_NO_ENTRY_POINT_MSMQOCM
//
// MessageText:
//
//  An entry point cannot be located in Msmqocm.dll.
//
#define MQ_ERROR_NO_ENTRY_POINT_MSMQOCM  0xC00E0074L

//
// MessageId: MQ_ERROR_NO_MSMQ_SERVERS_ON_DC
//
// MessageText:
//
//  Message Queuing servers cannot be found on domain controllers.
//
#define MQ_ERROR_NO_MSMQ_SERVERS_ON_DC   0xC00E0075L

//
// MessageId: MQ_ERROR_CANNOT_JOIN_DOMAIN
//
// MessageText:
//
//  The computer joined the domain, but Message Queuing will continue to run in workgroup mode because it failed to register itself in Active Directory.
//
#define MQ_ERROR_CANNOT_JOIN_DOMAIN      0xC00E0076L

//
// MessageId: MQ_ERROR_CANNOT_CREATE_ON_GC
//
// MessageText:
//
//  The object was not created on the Global Catalog server specified.
//
#define MQ_ERROR_CANNOT_CREATE_ON_GC     0xC00E0077L

//
// MessageId: MQ_ERROR_GUID_NOT_MATCHING
//
// MessageText:
//
//  Obsolete, kept for backward compatibility 
//
#define MQ_ERROR_GUID_NOT_MATCHING       0xC00E0078L

//
// MessageId: MQ_ERROR_PUBLIC_KEY_NOT_FOUND
//
// MessageText:
//
//  The public key for the computer %1 cannot be found.
//
#define MQ_ERROR_PUBLIC_KEY_NOT_FOUND    0xC00E0079L

//
// MessageId: MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST
//
// MessageText:
//
//  The public key for the computer %1 does not exist.
//
#define MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST 0xC00E007AL

//
// MessageId: MQ_ERROR_ILLEGAL_MQPRIVATEPROPS
//
// MessageText:
//
//  The parameters in MQPRIVATEPROPS are invalid. Either the pointer to the MQPRIVATEPROPS structure has a null value, or no properties are specified in it.
//
#define MQ_ERROR_ILLEGAL_MQPRIVATEPROPS  0xC00E007BL

//
// MessageId: MQ_ERROR_NO_GC_IN_DOMAIN
//
// MessageText:
//
//  Global Catalog servers cannot be found in the domain specified.
//
#define MQ_ERROR_NO_GC_IN_DOMAIN         0xC00E007CL

//
// MessageId: MQ_ERROR_NO_MSMQ_SERVERS_ON_GC
//
// MessageText:
//
//  No Message Queuing servers were found on Global Catalog servers.
//
#define MQ_ERROR_NO_MSMQ_SERVERS_ON_GC   0xC00E007DL

//
// MessageId: MQ_ERROR_CANNOT_GET_DN
//
// MessageText:
//
//  Obsolete, kept for backward compatibility 
//
#define MQ_ERROR_CANNOT_GET_DN           0xC00E007EL

//
// MessageId: MQ_ERROR_CANNOT_HASH_DATA_EX
//
// MessageText:
//
//  Data for an authenticated message cannot be hashed.
//
#define MQ_ERROR_CANNOT_HASH_DATA_EX     0xC00E007FL

//
// MessageId: MQ_ERROR_CANNOT_SIGN_DATA_EX
//
// MessageText:
//
//  Data cannot be signed before sending an authenticated message.
//
#define MQ_ERROR_CANNOT_SIGN_DATA_EX     0xC00E0080L

//
// MessageId: MQ_ERROR_CANNOT_CREATE_HASH_EX
//
// MessageText:
//
//  A hash object cannot be created for an authenticated message.
//
#define MQ_ERROR_CANNOT_CREATE_HASH_EX   0xC00E0081L

//
// MessageId: MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX
//
// MessageText:
//
//  The signature of the message received is not valid.
//
#define MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX 0xC00E0082L

//
// MessageId: MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS
//
// MessageText:
//
//  The object that will be deleted is owned by a primary site controller. The operation cannot be performed.
//
#define MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS 0xC00E0083L

//
// MessageId: MQ_ERROR_NO_MQUSER_OU
//
// MessageText:
//
//  There is no MSMQ Users organizational unit object in Active Directory for the domain. Please create one manually.
//
#define MQ_ERROR_NO_MQUSER_OU            0xC00E0084L

//
// MessageId: MQ_ERROR_CANNOT_LOAD_MQAD
//
// MessageText:
//
//  The dynamic-link library Mqad.dll cannot be loaded.
//
#define MQ_ERROR_CANNOT_LOAD_MQAD        0xC00E0085L

//
// MessageId: MQ_ERROR_CANNOT_LOAD_MQDSSRV
//
// MessageText:
//
//  Obsolete, kept for backward compatibility 
//
#define MQ_ERROR_CANNOT_LOAD_MQDSSRV     0xC00E0086L

//
// MessageId: MQ_ERROR_PROPERTIES_CONFLICT
//
// MessageText:
//
//  Two or more of the properties passed cannot co-exist.
//  For example, you cannot set both PROPID_M_RESP_QUEUE and PROPID_M_RESP_FORMAT_NAME when sending a message.
//
#define MQ_ERROR_PROPERTIES_CONFLICT     0xC00E0087L

//
// MessageId: MQ_ERROR_MESSAGE_NOT_FOUND
//
// MessageText:
//
//  The message does not exist or was removed from the queue.
//
#define MQ_ERROR_MESSAGE_NOT_FOUND       0xC00E0088L

//
// MessageId: MQ_ERROR_CANT_RESOLVE_SITES
//
// MessageText:
//
//  The sites where the computer resides cannot be resolved. Check that the subnets in your network are configured correctly in Active Directory and that each site is configured with the appropriate subnet.
//
#define MQ_ERROR_CANT_RESOLVE_SITES      0xC00E0089L

//
// MessageId: MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS
//
// MessageText:
//
//  This operation is not supported by dependent clients.
//
#define MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS 0xC00E008AL

//
// MessageId: MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER
//
// MessageText:
//
//  This operation is not supported by the remote Message Queuing service. For example, MQReceiveMessageByLookupId is not supported by MSMQ 1.0/2.0.
//
#define MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER 0xC00E008BL

//
// MessageId: MQ_ERROR_NOT_A_CORRECT_OBJECT_CLASS
//
// MessageText:
//
//  The object whose properties are being retrieved from Active Directory does not belong to the class requested.
//
#define MQ_ERROR_NOT_A_CORRECT_OBJECT_CLASS 0xC00E008CL

//
// MessageId: MQ_ERROR_MULTI_SORT_KEYS
//
// MessageText:
//
//  The value of cCol in MQSORTSET cannot be greater than 1. Active Directory supports only a single sort key.
//
#define MQ_ERROR_MULTI_SORT_KEYS         0xC00E008DL

//
// MessageId: MQ_ERROR_GC_NEEDED
//
// MessageText:
//
//  An MSMQ Configuration (msmq) object with the GUID supplied cannot be created. In order to support the creation of an MSMQ Configuration object with a given GUID, Message Queuing Downlevel Client Support must be installed on a domain controller that is configured as a Global Catalog (GC) server.
//
#define MQ_ERROR_GC_NEEDED               0xC00E008EL

//
// MessageId: MQ_ERROR_DS_BIND_ROOT_FOREST
//
// MessageText:
//
//  Binding to the forest root failed. This error usually indicates a problem in the DNS configuration.
//
#define MQ_ERROR_DS_BIND_ROOT_FOREST     0xC00E008FL

//
// MessageId: MQ_ERROR_DS_LOCAL_USER
//
// MessageText:
//
//  A local user is authenticated as an anonymous user and cannot access Active Directory. You need to log on as a domain user to access Active Directory.
//
#define MQ_ERROR_DS_LOCAL_USER           0xC00E0090L

//
// MessageId: MQ_ERROR_Q_ADS_PROPERTY_NOT_SUPPORTED
//
// MessageText:
//
//  The column PROPID_Q_ADS_PATH is not supported for the MQLocateBegin API.
//
#define MQ_ERROR_Q_ADS_PROPERTY_NOT_SUPPORTED 0xC00E0091L

//
// MessageId: MQ_ERROR_BAD_XML_FORMAT
//
// MessageText:
//
//  The given property is not a valid XML document.
//
#define MQ_ERROR_BAD_XML_FORMAT          0xC00E0092L

//
// MessageId: MQ_ERROR_UNSUPPORTED_CLASS
//
// MessageText:
//
//  The Active Directory object specified is not an instance of a supported class.
//
#define MQ_ERROR_UNSUPPORTED_CLASS       0xC00E0093L

//
// MessageId: MQ_ERROR_UNINITIALIZED_OBJECT
//
// MessageText:
//
//  The MSMQQueueState object must be initialized before it is used. 
//
#define MQ_ERROR_UNINITIALIZED_OBJECT    0xC00E0094L

//
// Informational
//
//
// MessageId: MQ_INFORMATION_PROPERTY
//
// MessageText:
//
//  One or more of the properties passed resulted in a warning, but the function completed.
//
#define MQ_INFORMATION_PROPERTY          0x400E0001L

//
// MessageId: MQ_INFORMATION_ILLEGAL_PROPERTY
//
// MessageText:
//
//  The property ID is invalid.
//
#define MQ_INFORMATION_ILLEGAL_PROPERTY  0x400E0002L

//
// MessageId: MQ_INFORMATION_PROPERTY_IGNORED
//
// MessageText:
//
//  The property specified was ignored for this operation (this occurs,
//  for example, when PROPID_M_SENDERID is passed to SendMessage()).
//
#define MQ_INFORMATION_PROPERTY_IGNORED  0x400E0003L

//
// MessageId: MQ_INFORMATION_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The property specified is not supported and was ignored for this operation.
//
#define MQ_INFORMATION_UNSUPPORTED_PROPERTY 0x400E0004L

//
// MessageId: MQ_INFORMATION_DUPLICATE_PROPERTY
//
// MessageText:
//
//  The property specified is already in the property identifier array.
//  The duplicate was ignored for this operation.
//
#define MQ_INFORMATION_DUPLICATE_PROPERTY 0x400E0005L

//
// MessageId: MQ_INFORMATION_OPERATION_PENDING
//
// MessageText:
//
//  An asynchronous operation is currently pending.
//
#define MQ_INFORMATION_OPERATION_PENDING 0x400E0006L

//
// MessageId: MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The format name buffer supplied to MQCreateQueue was too small
//  to hold the format name, however the queue was created successfully.
//
#define MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL 0x400E0009L

//
// MessageId: MQ_INFORMATION_INTERNAL_USER_CERT_EXIST
//
// MessageText:
//
//  An internal Message Queuing certificate already exists for this user.
//
#define MQ_INFORMATION_INTERNAL_USER_CERT_EXIST 0x400E000AL

//
// MessageId: MQ_INFORMATION_OWNER_IGNORED
//
// MessageText:
//
//  The queue owner was not set during the processing of this call to MQSetQueueSecurity().
//
#define MQ_INFORMATION_OWNER_IGNORED     0x400E000BL


//+-----------------------------------------
//
// Flags for MQRegisterCertificate()
//
//+-----------------------------------------

#define MQCERT_REGISTER_ALWAYS        0x01
#define MQCERT_REGISTER_IF_NOT_EXIST  0x02


//********************************************************************
//  SECURITY Flags (Queue access control)
//********************************************************************

#define MQSEC_DELETE_MESSAGE                0x1
#define MQSEC_PEEK_MESSAGE                  0x2
#define MQSEC_WRITE_MESSAGE                 0x4
#define MQSEC_DELETE_JOURNAL_MESSAGE        0x8
#define MQSEC_SET_QUEUE_PROPERTIES          0x10
#define MQSEC_GET_QUEUE_PROPERTIES          0x20
#define MQSEC_DELETE_QUEUE                  DELETE
#define MQSEC_GET_QUEUE_PERMISSIONS         READ_CONTROL
#define MQSEC_CHANGE_QUEUE_PERMISSIONS      WRITE_DAC
#define MQSEC_TAKE_QUEUE_OWNERSHIP          WRITE_OWNER

#define MQSEC_RECEIVE_MESSAGE               (MQSEC_DELETE_MESSAGE | \
                                             MQSEC_PEEK_MESSAGE)

#define MQSEC_RECEIVE_JOURNAL_MESSAGE       (MQSEC_DELETE_JOURNAL_MESSAGE | \
                                             MQSEC_PEEK_MESSAGE)

#define MQSEC_QUEUE_GENERIC_READ            (MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_RECEIVE_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_MESSAGE)

#define MQSEC_QUEUE_GENERIC_WRITE           (MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_WRITE_MESSAGE)

#define MQSEC_QUEUE_GENERIC_EXECUTE         0

#define MQSEC_QUEUE_GENERIC_ALL             (MQSEC_RECEIVE_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_MESSAGE | \
                                             MQSEC_WRITE_MESSAGE | \
                                             MQSEC_SET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_DELETE_QUEUE | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_CHANGE_QUEUE_PERMISSIONS | \
                                             MQSEC_TAKE_QUEUE_OWNERSHIP)

#ifdef __cplusplus
extern "C"
{
#endif

//********************************************************************
//  RECEIVE CALLBACK
//********************************************************************

typedef
VOID
(APIENTRY *PMQRECEIVECALLBACK)(
    HRESULT hrStatus,
    QUEUEHANDLE hSource,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pMessageProps,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor
    );


//********************************************************************
// MSMQ API
//********************************************************************

HRESULT
APIENTRY
MQCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pQueueProps,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    );

HRESULT
APIENTRY
MQLocateBegin(
    IN LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    );

HRESULT
APIENTRY
MQLocateNext(
    IN HANDLE hEnum,
    IN OUT DWORD* pcProps,
    OUT MQPROPVARIANT aPropVar[]
    );

HRESULT
APIENTRY
MQLocateEnd(
    IN HANDLE hEnum
    );

HRESULT
APIENTRY
MQOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    );

HRESULT
APIENTRY
MQSendMessage(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
MQReceiveMessage(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    );

HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN QUEUEHANDLE hSource,
    IN ULONGLONG ullLookupId,
    IN DWORD dwLookupAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
MQCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    );

HRESULT
APIENTRY
MQCloseCursor(
    IN HANDLE hCursor
    );

HRESULT
APIENTRY
MQCloseQueue(
    IN QUEUEHANDLE hQueue
    );

HRESULT
APIENTRY
MQSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
MQGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    OUT MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
MQGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    );

HRESULT
APIENTRY
MQSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

HRESULT
APIENTRY
MQPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQInstanceToFormatName(
    IN GUID* pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQADsPathToFormatName(
    IN LPCWSTR lpwcsADsPath,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

VOID
APIENTRY
MQFreeMemory(
    IN PVOID pvMemory
    );


HRESULT
APIENTRY
MQGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID* pguidMachineId,
    IN OUT MQQMPROPS* pQMProps
    );

HRESULT
APIENTRY
MQGetSecurityContext(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    );

HRESULT
APIENTRY
MQGetSecurityContextEx(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    );

VOID
APIENTRY
MQFreeSecurityContext(
    IN HANDLE hSecurityContext
    );

HRESULT
APIENTRY
MQRegisterCertificate(
    IN DWORD dwFlags,
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength
    );

HRESULT
APIENTRY
MQBeginTransaction(
    OUT ITransaction **ppTransaction
    );

HRESULT
APIENTRY
MQGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    );

HRESULT
APIENTRY
MQGetPrivateComputerInformation(
    IN LPCWSTR lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
    );

HRESULT
APIENTRY
MQPurgeQueue(
    IN QUEUEHANDLE hQueue
    );

HRESULT
APIENTRY
MQMgmtGetInfo(
    IN LPCWSTR pComputerName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

HRESULT
APIENTRY
MQMgmtAction(
    IN LPCWSTR pComputerName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

#ifdef __cplusplus
}
#endif

#endif // __MQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\drawarea.h ===
// drawarea.h : header file
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#define MAX_MSG_BODY_LEN 32

typedef struct tagLINE
{
	CPoint ptStart;
	CPoint ptEnd;
} LINE;

/////////////////////////////////////////////////////////////////////////////
// CDrawArea window

class CDrawArea : public CEdit
{
// Construction
public:
	CDrawArea();

// Attributes
public:

protected:
	CPoint m_ptLast;
	CList<LINE, LINE &> m_listLines;

// Operations
public:
	void AddLine(LINE line);
	void AddKeystroke(char *mbsKey);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDrawArea)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDrawArea();

	// Generated message map functions
protected:
	//{{AFX_MSG(CDrawArea)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\published\inc\mqoai.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for mqoai.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __mqoai_h__
#define __mqoai_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMSMQQuery_FWD_DEFINED__
#define __IMSMQQuery_FWD_DEFINED__
typedef interface IMSMQQuery IMSMQQuery;
#endif 	/* __IMSMQQuery_FWD_DEFINED__ */


#ifndef __IMSMQQueueInfo_FWD_DEFINED__
#define __IMSMQQueueInfo_FWD_DEFINED__
typedef interface IMSMQQueueInfo IMSMQQueueInfo;
#endif 	/* __IMSMQQueueInfo_FWD_DEFINED__ */


#ifndef __IMSMQQueueInfo2_FWD_DEFINED__
#define __IMSMQQueueInfo2_FWD_DEFINED__
typedef interface IMSMQQueueInfo2 IMSMQQueueInfo2;
#endif 	/* __IMSMQQueueInfo2_FWD_DEFINED__ */


#ifndef __IMSMQQueueInfo3_FWD_DEFINED__
#define __IMSMQQueueInfo3_FWD_DEFINED__
typedef interface IMSMQQueueInfo3 IMSMQQueueInfo3;
#endif 	/* __IMSMQQueueInfo3_FWD_DEFINED__ */


#ifndef __IMSMQQueue_FWD_DEFINED__
#define __IMSMQQueue_FWD_DEFINED__
typedef interface IMSMQQueue IMSMQQueue;
#endif 	/* __IMSMQQueue_FWD_DEFINED__ */


#ifndef __IMSMQQueue2_FWD_DEFINED__
#define __IMSMQQueue2_FWD_DEFINED__
typedef interface IMSMQQueue2 IMSMQQueue2;
#endif 	/* __IMSMQQueue2_FWD_DEFINED__ */


#ifndef __IMSMQMessage_FWD_DEFINED__
#define __IMSMQMessage_FWD_DEFINED__
typedef interface IMSMQMessage IMSMQMessage;
#endif 	/* __IMSMQMessage_FWD_DEFINED__ */


#ifndef __IMSMQQueueInfos_FWD_DEFINED__
#define __IMSMQQueueInfos_FWD_DEFINED__
typedef interface IMSMQQueueInfos IMSMQQueueInfos;
#endif 	/* __IMSMQQueueInfos_FWD_DEFINED__ */


#ifndef __IMSMQQueueInfos2_FWD_DEFINED__
#define __IMSMQQueueInfos2_FWD_DEFINED__
typedef interface IMSMQQueueInfos2 IMSMQQueueInfos2;
#endif 	/* __IMSMQQueueInfos2_FWD_DEFINED__ */


#ifndef __IMSMQQueueInfos3_FWD_DEFINED__
#define __IMSMQQueueInfos3_FWD_DEFINED__
typedef interface IMSMQQueueInfos3 IMSMQQueueInfos3;
#endif 	/* __IMSMQQueueInfos3_FWD_DEFINED__ */


#ifndef __IMSMQEvent_FWD_DEFINED__
#define __IMSMQEvent_FWD_DEFINED__
typedef interface IMSMQEvent IMSMQEvent;
#endif 	/* __IMSMQEvent_FWD_DEFINED__ */


#ifndef __IMSMQEvent2_FWD_DEFINED__
#define __IMSMQEvent2_FWD_DEFINED__
typedef interface IMSMQEvent2 IMSMQEvent2;
#endif 	/* __IMSMQEvent2_FWD_DEFINED__ */


#ifndef __IMSMQEvent3_FWD_DEFINED__
#define __IMSMQEvent3_FWD_DEFINED__
typedef interface IMSMQEvent3 IMSMQEvent3;
#endif 	/* __IMSMQEvent3_FWD_DEFINED__ */


#ifndef __IMSMQTransaction_FWD_DEFINED__
#define __IMSMQTransaction_FWD_DEFINED__
typedef interface IMSMQTransaction IMSMQTransaction;
#endif 	/* __IMSMQTransaction_FWD_DEFINED__ */


#ifndef __IMSMQCoordinatedTransactionDispenser_FWD_DEFINED__
#define __IMSMQCoordinatedTransactionDispenser_FWD_DEFINED__
typedef interface IMSMQCoordinatedTransactionDispenser IMSMQCoordinatedTransactionDispenser;
#endif 	/* __IMSMQCoordinatedTransactionDispenser_FWD_DEFINED__ */


#ifndef __IMSMQTransactionDispenser_FWD_DEFINED__
#define __IMSMQTransactionDispenser_FWD_DEFINED__
typedef interface IMSMQTransactionDispenser IMSMQTransactionDispenser;
#endif 	/* __IMSMQTransactionDispenser_FWD_DEFINED__ */


#ifndef __IMSMQQuery2_FWD_DEFINED__
#define __IMSMQQuery2_FWD_DEFINED__
typedef interface IMSMQQuery2 IMSMQQuery2;
#endif 	/* __IMSMQQuery2_FWD_DEFINED__ */


#ifndef __IMSMQQuery3_FWD_DEFINED__
#define __IMSMQQuery3_FWD_DEFINED__
typedef interface IMSMQQuery3 IMSMQQuery3;
#endif 	/* __IMSMQQuery3_FWD_DEFINED__ */


#ifndef __MSMQQuery_FWD_DEFINED__
#define __MSMQQuery_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQQuery MSMQQuery;
#else
typedef struct MSMQQuery MSMQQuery;
#endif /* __cplusplus */

#endif 	/* __MSMQQuery_FWD_DEFINED__ */


#ifndef __IMSMQMessage2_FWD_DEFINED__
#define __IMSMQMessage2_FWD_DEFINED__
typedef interface IMSMQMessage2 IMSMQMessage2;
#endif 	/* __IMSMQMessage2_FWD_DEFINED__ */


#ifndef __IMSMQMessage3_FWD_DEFINED__
#define __IMSMQMessage3_FWD_DEFINED__
typedef interface IMSMQMessage3 IMSMQMessage3;
#endif 	/* __IMSMQMessage3_FWD_DEFINED__ */


#ifndef __MSMQMessage_FWD_DEFINED__
#define __MSMQMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQMessage MSMQMessage;
#else
typedef struct MSMQMessage MSMQMessage;
#endif /* __cplusplus */

#endif 	/* __MSMQMessage_FWD_DEFINED__ */


#ifndef __IMSMQQueue3_FWD_DEFINED__
#define __IMSMQQueue3_FWD_DEFINED__
typedef interface IMSMQQueue3 IMSMQQueue3;
#endif 	/* __IMSMQQueue3_FWD_DEFINED__ */


#ifndef __MSMQQueue_FWD_DEFINED__
#define __MSMQQueue_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQQueue MSMQQueue;
#else
typedef struct MSMQQueue MSMQQueue;
#endif /* __cplusplus */

#endif 	/* __MSMQQueue_FWD_DEFINED__ */


#ifndef __IMSMQPrivateEvent_FWD_DEFINED__
#define __IMSMQPrivateEvent_FWD_DEFINED__
typedef interface IMSMQPrivateEvent IMSMQPrivateEvent;
#endif 	/* __IMSMQPrivateEvent_FWD_DEFINED__ */


#ifndef ___DMSMQEventEvents_FWD_DEFINED__
#define ___DMSMQEventEvents_FWD_DEFINED__
typedef interface _DMSMQEventEvents _DMSMQEventEvents;
#endif 	/* ___DMSMQEventEvents_FWD_DEFINED__ */


#ifndef __MSMQEvent_FWD_DEFINED__
#define __MSMQEvent_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQEvent MSMQEvent;
#else
typedef struct MSMQEvent MSMQEvent;
#endif /* __cplusplus */

#endif 	/* __MSMQEvent_FWD_DEFINED__ */


#ifndef __MSMQQueueInfo_FWD_DEFINED__
#define __MSMQQueueInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQQueueInfo MSMQQueueInfo;
#else
typedef struct MSMQQueueInfo MSMQQueueInfo;
#endif /* __cplusplus */

#endif 	/* __MSMQQueueInfo_FWD_DEFINED__ */


#ifndef __MSMQQueueInfos_FWD_DEFINED__
#define __MSMQQueueInfos_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQQueueInfos MSMQQueueInfos;
#else
typedef struct MSMQQueueInfos MSMQQueueInfos;
#endif /* __cplusplus */

#endif 	/* __MSMQQueueInfos_FWD_DEFINED__ */


#ifndef __IMSMQTransaction2_FWD_DEFINED__
#define __IMSMQTransaction2_FWD_DEFINED__
typedef interface IMSMQTransaction2 IMSMQTransaction2;
#endif 	/* __IMSMQTransaction2_FWD_DEFINED__ */


#ifndef __IMSMQTransaction3_FWD_DEFINED__
#define __IMSMQTransaction3_FWD_DEFINED__
typedef interface IMSMQTransaction3 IMSMQTransaction3;
#endif 	/* __IMSMQTransaction3_FWD_DEFINED__ */


#ifndef __MSMQTransaction_FWD_DEFINED__
#define __MSMQTransaction_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQTransaction MSMQTransaction;
#else
typedef struct MSMQTransaction MSMQTransaction;
#endif /* __cplusplus */

#endif 	/* __MSMQTransaction_FWD_DEFINED__ */


#ifndef __IMSMQCoordinatedTransactionDispenser2_FWD_DEFINED__
#define __IMSMQCoordinatedTransactionDispenser2_FWD_DEFINED__
typedef interface IMSMQCoordinatedTransactionDispenser2 IMSMQCoordinatedTransactionDispenser2;
#endif 	/* __IMSMQCoordinatedTransactionDispenser2_FWD_DEFINED__ */


#ifndef __IMSMQCoordinatedTransactionDispenser3_FWD_DEFINED__
#define __IMSMQCoordinatedTransactionDispenser3_FWD_DEFINED__
typedef interface IMSMQCoordinatedTransactionDispenser3 IMSMQCoordinatedTransactionDispenser3;
#endif 	/* __IMSMQCoordinatedTransactionDispenser3_FWD_DEFINED__ */


#ifndef __MSMQCoordinatedTransactionDispenser_FWD_DEFINED__
#define __MSMQCoordinatedTransactionDispenser_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQCoordinatedTransactionDispenser MSMQCoordinatedTransactionDispenser;
#else
typedef struct MSMQCoordinatedTransactionDispenser MSMQCoordinatedTransactionDispenser;
#endif /* __cplusplus */

#endif 	/* __MSMQCoordinatedTransactionDispenser_FWD_DEFINED__ */


#ifndef __IMSMQTransactionDispenser2_FWD_DEFINED__
#define __IMSMQTransactionDispenser2_FWD_DEFINED__
typedef interface IMSMQTransactionDispenser2 IMSMQTransactionDispenser2;
#endif 	/* __IMSMQTransactionDispenser2_FWD_DEFINED__ */


#ifndef __IMSMQTransactionDispenser3_FWD_DEFINED__
#define __IMSMQTransactionDispenser3_FWD_DEFINED__
typedef interface IMSMQTransactionDispenser3 IMSMQTransactionDispenser3;
#endif 	/* __IMSMQTransactionDispenser3_FWD_DEFINED__ */


#ifndef __MSMQTransactionDispenser_FWD_DEFINED__
#define __MSMQTransactionDispenser_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQTransactionDispenser MSMQTransactionDispenser;
#else
typedef struct MSMQTransactionDispenser MSMQTransactionDispenser;
#endif /* __cplusplus */

#endif 	/* __MSMQTransactionDispenser_FWD_DEFINED__ */


#ifndef __IMSMQApplication_FWD_DEFINED__
#define __IMSMQApplication_FWD_DEFINED__
typedef interface IMSMQApplication IMSMQApplication;
#endif 	/* __IMSMQApplication_FWD_DEFINED__ */


#ifndef __IMSMQApplication2_FWD_DEFINED__
#define __IMSMQApplication2_FWD_DEFINED__
typedef interface IMSMQApplication2 IMSMQApplication2;
#endif 	/* __IMSMQApplication2_FWD_DEFINED__ */


#ifndef __IMSMQApplication3_FWD_DEFINED__
#define __IMSMQApplication3_FWD_DEFINED__
typedef interface IMSMQApplication3 IMSMQApplication3;
#endif 	/* __IMSMQApplication3_FWD_DEFINED__ */


#ifndef __MSMQApplication_FWD_DEFINED__
#define __MSMQApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQApplication MSMQApplication;
#else
typedef struct MSMQApplication MSMQApplication;
#endif /* __cplusplus */

#endif 	/* __MSMQApplication_FWD_DEFINED__ */


#ifndef __IMSMQDestination_FWD_DEFINED__
#define __IMSMQDestination_FWD_DEFINED__
typedef interface IMSMQDestination IMSMQDestination;
#endif 	/* __IMSMQDestination_FWD_DEFINED__ */


#ifndef __IMSMQPrivateDestination_FWD_DEFINED__
#define __IMSMQPrivateDestination_FWD_DEFINED__
typedef interface IMSMQPrivateDestination IMSMQPrivateDestination;
#endif 	/* __IMSMQPrivateDestination_FWD_DEFINED__ */


#ifndef __MSMQDestination_FWD_DEFINED__
#define __MSMQDestination_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQDestination MSMQDestination;
#else
typedef struct MSMQDestination MSMQDestination;
#endif /* __cplusplus */

#endif 	/* __MSMQDestination_FWD_DEFINED__ */


#ifndef __IMSMQCollection_FWD_DEFINED__
#define __IMSMQCollection_FWD_DEFINED__
typedef interface IMSMQCollection IMSMQCollection;
#endif 	/* __IMSMQCollection_FWD_DEFINED__ */


#ifndef __IMSMQManagement_FWD_DEFINED__
#define __IMSMQManagement_FWD_DEFINED__
typedef interface IMSMQManagement IMSMQManagement;
#endif 	/* __IMSMQManagement_FWD_DEFINED__ */


#ifndef __MSMQManagement_FWD_DEFINED__
#define __MSMQManagement_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQManagement MSMQManagement;
#else
typedef struct MSMQManagement MSMQManagement;
#endif /* __cplusplus */

#endif 	/* __MSMQManagement_FWD_DEFINED__ */


#ifndef __IMSMQOutgoingQueueManagement_FWD_DEFINED__
#define __IMSMQOutgoingQueueManagement_FWD_DEFINED__
typedef interface IMSMQOutgoingQueueManagement IMSMQOutgoingQueueManagement;
#endif 	/* __IMSMQOutgoingQueueManagement_FWD_DEFINED__ */


#ifndef __MSMQOutgoingQueueManagement_FWD_DEFINED__
#define __MSMQOutgoingQueueManagement_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQOutgoingQueueManagement MSMQOutgoingQueueManagement;
#else
typedef struct MSMQOutgoingQueueManagement MSMQOutgoingQueueManagement;
#endif /* __cplusplus */

#endif 	/* __MSMQOutgoingQueueManagement_FWD_DEFINED__ */


#ifndef __IMSMQQueueManagement_FWD_DEFINED__
#define __IMSMQQueueManagement_FWD_DEFINED__
typedef interface IMSMQQueueManagement IMSMQQueueManagement;
#endif 	/* __IMSMQQueueManagement_FWD_DEFINED__ */


#ifndef __MSMQQueueManagement_FWD_DEFINED__
#define __MSMQQueueManagement_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSMQQueueManagement MSMQQueueManagement;
#else
typedef struct MSMQQueueManagement MSMQQueueManagement;
#endif /* __cplusplus */

#endif 	/* __MSMQQueueManagement_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __MSMQ_LIBRARY_DEFINED__
#define __MSMQ_LIBRARY_DEFINED__

/* library MSMQ */
/* [version][lcid][helpstringdll][helpstring][uuid] */ 

#ifndef MIDL_INTERFACE
#if _MSC_VER >= 1100
#define MIDL_INTERFACE(x)   struct __declspec(uuid(x)) __declspec(novtable)
#else
#define MIDL_INTERFACE(x)   struct
#endif //_MSC_VER
#endif //MIDL_INTERFACE

typedef short Boolean;

typedef unsigned char BYTE;

typedef unsigned long ULONG;

typedef unsigned long DWORD;

typedef int BOOL;

















/* [helpstringcontext] */ 
enum MQCALG
    {	MQMSG_CALG_MD2	= 0x8000 + 0 + 1,
	MQMSG_CALG_MD4	= 0x8000 + 0 + 2,
	MQMSG_CALG_MD5	= 0x8000 + 0 + 3,
	MQMSG_CALG_SHA	= 0x8000 + 0 + 4,
	MQMSG_CALG_SHA1	= 0x8000 + 0 + 4,
	MQMSG_CALG_MAC	= 0x8000 + 0 + 5,
	MQMSG_CALG_RSA_SIGN	= 0x2000 + 0x400 + 0,
	MQMSG_CALG_DSS_SIGN	= 0x2000 + 0x200 + 0,
	MQMSG_CALG_RSA_KEYX	= 0xa000 + 0x400 + 0,
	MQMSG_CALG_DES	= 0x6000 + 0x600 + 1,
	MQMSG_CALG_RC2	= 0x6000 + 0x600 + 2,
	MQMSG_CALG_RC4	= 0x6000 + 0x800 + 1,
	MQMSG_CALG_SEAL	= 0x6000 + 0x800 + 2
    } ;
/* [helpstringcontext] */ 
enum MQTRANSACTION
    {	MQ_NO_TRANSACTION	= 0,
	MQ_MTS_TRANSACTION	= 1,
	MQ_XA_TRANSACTION	= 2,
	MQ_SINGLE_MESSAGE	= 3
    } ;
/* [helpstringcontext] */ 
enum RELOPS
    {	REL_NOP	= 0,
	REL_EQ	= REL_NOP + 1,
	REL_NEQ	= REL_EQ + 1,
	REL_LT	= REL_NEQ + 1,
	REL_GT	= REL_LT + 1,
	REL_LE	= REL_GT + 1,
	REL_GE	= REL_LE + 1
    } ;
/* [helpstringcontext] */ 
enum MQCERT_REGISTER
    {	MQCERT_REGISTER_ALWAYS	= 1,
	MQCERT_REGISTER_IF_NOT_EXIST	= 2
    } ;
/* [helpstringcontext] */ 
enum MQMSGCURSOR
    {	MQMSG_FIRST	= 0,
	MQMSG_CURRENT	= 1,
	MQMSG_NEXT	= 2
    } ;
/* [helpstringcontext] */ 
enum MQMSGCLASS
    {	MQMSG_CLASS_NORMAL	= 0 + 0 + 0,
	MQMSG_CLASS_REPORT	= 0 + 0 + 0x1,
	MQMSG_CLASS_ACK_REACH_QUEUE	= 0 + 0 + 0x2,
	MQMSG_CLASS_ACK_RECEIVE	= 0 + 0x4000 + 0,
	MQMSG_CLASS_NACK_BAD_DST_Q	= 0x8000 + 0 + 0,
	MQMSG_CLASS_NACK_PURGED	= 0x8000 + 0 + 0x1,
	MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT	= 0x8000 + 0 + 0x2,
	MQMSG_CLASS_NACK_Q_EXCEED_QUOTA	= 0x8000 + 0 + 0x3,
	MQMSG_CLASS_NACK_ACCESS_DENIED	= 0x8000 + 0 + 0x4,
	MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED	= 0x8000 + 0 + 0x5,
	MQMSG_CLASS_NACK_BAD_SIGNATURE	= 0x8000 + 0 + 0x6,
	MQMSG_CLASS_NACK_BAD_ENCRYPTION	= 0x8000 + 0 + 0x7,
	MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT	= 0x8000 + 0 + 0x8,
	MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q	= 0x8000 + 0 + 0x9,
	MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG	= 0x8000 + 0 + 0xa,
	MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER	= 0x8000 + 0 + 0xb,
	MQMSG_CLASS_NACK_Q_DELETED	= 0x8000 + 0x4000 + 0,
	MQMSG_CLASS_NACK_Q_PURGED	= 0x8000 + 0x4000 + 0x1,
	MQMSG_CLASS_NACK_RECEIVE_TIMEOUT	= 0x8000 + 0x4000 + 0x2,
	MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER	= 0x8000 + 0x4000 + 0x3
    } ;
/* [helpstringcontext] */ 
enum MQMSGDELIVERY
    {	MQMSG_DELIVERY_EXPRESS	= 0,
	MQMSG_DELIVERY_RECOVERABLE	= 1
    } ;
/* [helpstringcontext] */ 
enum MQMSGACKNOWLEDGEMENT
    {	MQMSG_ACKNOWLEDGMENT_NONE	= 0,
	MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL	= 0x1,
	MQMSG_ACKNOWLEDGMENT_POS_RECEIVE	= 0x2,
	MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL	= 0x4,
	MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE	= 0x8,
	MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE	= 0x4,
	MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE	= 0x4 + 0x1,
	MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE	= 0x4 + 0x8,
	MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE	= 0x4 + 0x8 + 0x2
    } ;
/* [helpstringcontext] */ 
enum MQMSGJOURNAL
    {	MQMSG_JOURNAL_NONE	= 0,
	MQMSG_DEADLETTER	= 1,
	MQMSG_JOURNAL	= 2
    } ;
/* [helpstringcontext] */ 
enum MQMSGTRACE
    {	MQMSG_TRACE_NONE	= 0,
	MQMSG_SEND_ROUTE_TO_REPORT_QUEUE	= 1
    } ;
/* [helpstringcontext] */ 
enum MQMSGSENDERIDTYPE
    {	MQMSG_SENDERID_TYPE_NONE	= 0,
	MQMSG_SENDERID_TYPE_SID	= 1
    } ;
/* [helpstringcontext] */ 
enum MQMSGPRIVLEVEL
    {	MQMSG_PRIV_LEVEL_NONE	= 0,
	MQMSG_PRIV_LEVEL_BODY	= 1,
	MQMSG_PRIV_LEVEL_BODY_BASE	= 1,
	MQMSG_PRIV_LEVEL_BODY_ENHANCED	= 3
    } ;
/* [helpstringcontext] */ 
enum MQMSGAUTHLEVEL
    {	MQMSG_AUTH_LEVEL_NONE	= 0,
	MQMSG_AUTH_LEVEL_ALWAYS	= 1,
	MQMSG_AUTH_LEVEL_MSMQ10	= 2,
	MQMSG_AUTH_LEVEL_SIG10	= 2,
	MQMSG_AUTH_LEVEL_MSMQ20	= 4,
	MQMSG_AUTH_LEVEL_SIG20	= 4,
	MQMSG_AUTH_LEVEL_SIG30	= 8
    } ;
/* [helpstringcontext] */ 
enum MQMSGIDSIZE
    {	MQMSG_MSGID_SIZE	= 20,
	MQMSG_CORRELATIONID_SIZE	= 20,
	MQMSG_XACTID_SIZE	= 20
    } ;
/* [helpstringcontext] */ 
enum MQMSGMAX
    {	MQ_MAX_MSG_LABEL_LEN	= 249
    } ;
/* [helpstringcontext] */ 
enum MQMSGAUTHENTICATION
    {	MQMSG_AUTHENTICATION_NOT_REQUESTED	= 0,
	MQMSG_AUTHENTICATION_REQUESTED	= 1,
	MQMSG_AUTHENTICATED_SIG10	= 1,
	MQMSG_AUTHENTICATION_REQUESTED_EX	= 3,
	MQMSG_AUTHENTICATED_SIG20	= 3,
	MQMSG_AUTHENTICATED_SIG30	= 5,
	MQMSG_AUTHENTICATED_SIGXML	= 9
    } ;
/* [helpstringcontext] */ 
enum MQSHARE
    {	MQ_DENY_NONE	= 0,
	MQ_DENY_RECEIVE_SHARE	= 1
    } ;
/* [helpstringcontext] */ 
enum MQACCESS
    {	MQ_RECEIVE_ACCESS	= 1,
	MQ_SEND_ACCESS	= 2,
	MQ_PEEK_ACCESS	= 0x20,
	MQ_ADMIN_ACCESS	= 0x80
    } ;
/* [helpstringcontext] */ 
enum MQJOURNAL
    {	MQ_JOURNAL_NONE	= 0,
	MQ_JOURNAL	= 1
    } ;
/* [helpstringcontext] */ 
enum MQTRANSACTIONAL
    {	MQ_TRANSACTIONAL_NONE	= 0,
	MQ_TRANSACTIONAL	= 1
    } ;
/* [helpstringcontext] */ 
enum MQAUTHENTICATE
    {	MQ_AUTHENTICATE_NONE	= 0,
	MQ_AUTHENTICATE	= 1
    } ;
/* [helpstringcontext] */ 
enum MQPRIVLEVEL
    {	MQ_PRIV_LEVEL_NONE	= 0,
	MQ_PRIV_LEVEL_OPTIONAL	= 1,
	MQ_PRIV_LEVEL_BODY	= 2
    } ;
/* [helpstringcontext] */ 
enum MQPRIORITY
    {	MQ_MIN_PRIORITY	= 0,
	MQ_MAX_PRIORITY	= 7
    } ;
/* [helpstringcontext] */ 
enum MQMAX
    {	MQ_MAX_Q_NAME_LEN	= 124,
	MQ_MAX_Q_LABEL_LEN	= 124
    } ;
/* [helpstringcontext] */ 
enum QUEUE_TYPE
    {	MQ_TYPE_PUBLIC	= 0,
	MQ_TYPE_PRIVATE	= MQ_TYPE_PUBLIC + 1,
	MQ_TYPE_MACHINE	= MQ_TYPE_PRIVATE + 1,
	MQ_TYPE_CONNECTOR	= MQ_TYPE_MACHINE + 1,
	MQ_TYPE_MULTICAST	= MQ_TYPE_CONNECTOR + 1
    } ;
/* [helpstringcontext] */ 
enum FOREIGN_STATUS
    {	MQ_STATUS_FOREIGN	= 0,
	MQ_STATUS_NOT_FOREIGN	= MQ_STATUS_FOREIGN + 1,
	MQ_STATUS_UNKNOWN	= MQ_STATUS_NOT_FOREIGN + 1
    } ;

enum XACT_STATUS
    {	MQ_XACT_STATUS_XACT	= 0,
	MQ_XACT_STATUS_NOT_XACT	= MQ_XACT_STATUS_XACT + 1,
	MQ_XACT_STATUS_UNKNOWN	= MQ_XACT_STATUS_NOT_XACT + 1
    } ;
/* [helpstringcontext] */ 
enum QUEUE_STATE
    {	MQ_QUEUE_STATE_LOCAL_CONNECTION	= 0,
	MQ_QUEUE_STATE_DISCONNECTED	= MQ_QUEUE_STATE_LOCAL_CONNECTION + 1,
	MQ_QUEUE_STATE_WAITING	= MQ_QUEUE_STATE_DISCONNECTED + 1,
	MQ_QUEUE_STATE_NEEDVALIDATE	= MQ_QUEUE_STATE_WAITING + 1,
	MQ_QUEUE_STATE_ONHOLD	= MQ_QUEUE_STATE_NEEDVALIDATE + 1,
	MQ_QUEUE_STATE_NONACTIVE	= MQ_QUEUE_STATE_ONHOLD + 1,
	MQ_QUEUE_STATE_CONNECTED	= MQ_QUEUE_STATE_NONACTIVE + 1,
	MQ_QUEUE_STATE_DISCONNECTING	= MQ_QUEUE_STATE_CONNECTED + 1
    } ;
/* [helpstringcontext] */ 
enum MQDEFAULT
    {	DEFAULT_M_PRIORITY	= 3,
	DEFAULT_M_DELIVERY	= 0,
	DEFAULT_M_ACKNOWLEDGE	= 0,
	DEFAULT_M_JOURNAL	= 0,
	DEFAULT_M_APPSPECIFIC	= 0,
	DEFAULT_M_PRIV_LEVEL	= 0,
	DEFAULT_M_AUTH_LEVEL	= 0,
	DEFAULT_M_SENDERID_TYPE	= 1,
	DEFAULT_Q_JOURNAL	= 0,
	DEFAULT_Q_BASEPRIORITY	= 0,
	DEFAULT_Q_QUOTA	= 0xffffffff,
	DEFAULT_Q_JOURNAL_QUOTA	= 0xffffffff,
	DEFAULT_Q_TRANSACTION	= 0,
	DEFAULT_Q_AUTHENTICATE	= 0,
	DEFAULT_Q_PRIV_LEVEL	= 1,
	DEFAULT_M_LOOKUPID	= 0
    } ;
/* [helpstringcontext] */ 
enum MQERROR
    {	MQ_ERROR	= 0xc00e0001,
	MQ_ERROR_PROPERTY	= 0xc00e0002,
	MQ_ERROR_QUEUE_NOT_FOUND	= 0xc00e0003,
	MQ_ERROR_QUEUE_EXISTS	= 0xc00e0005,
	MQ_ERROR_INVALID_PARAMETER	= 0xc00e0006,
	MQ_ERROR_INVALID_HANDLE	= 0xc00e0007,
	MQ_ERROR_OPERATION_CANCELLED	= 0xc00e0008,
	MQ_ERROR_SHARING_VIOLATION	= 0xc00e0009,
	MQ_ERROR_SERVICE_NOT_AVAILABLE	= 0xc00e000b,
	MQ_ERROR_MACHINE_NOT_FOUND	= 0xc00e000d,
	MQ_ERROR_ILLEGAL_SORT	= 0xc00e0010,
	MQ_ERROR_ILLEGAL_USER	= 0xc00e0011,
	MQ_ERROR_NO_DS	= 0xc00e0013,
	MQ_ERROR_ILLEGAL_QUEUE_PATHNAME	= 0xc00e0014,
	MQ_ERROR_ILLEGAL_PROPERTY_VALUE	= 0xc00e0018,
	MQ_ERROR_ILLEGAL_PROPERTY_VT	= 0xc00e0019,
	MQ_ERROR_BUFFER_OVERFLOW	= 0xc00e001a,
	MQ_ERROR_IO_TIMEOUT	= 0xc00e001b,
	MQ_ERROR_ILLEGAL_CURSOR_ACTION	= 0xc00e001c,
	MQ_ERROR_MESSAGE_ALREADY_RECEIVED	= 0xc00e001d,
	MQ_ERROR_ILLEGAL_FORMATNAME	= 0xc00e001e,
	MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL	= 0xc00e001f,
	MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION	= 0xc00e0020,
	MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR	= 0xc00e0021,
	MQ_ERROR_SENDERID_BUFFER_TOO_SMALL	= 0xc00e0022,
	MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL	= 0xc00e0023,
	MQ_ERROR_CANNOT_IMPERSONATE_CLIENT	= 0xc00e0024,
	MQ_ERROR_ACCESS_DENIED	= 0xc00e0025,
	MQ_ERROR_PRIVILEGE_NOT_HELD	= 0xc00e0026,
	MQ_ERROR_INSUFFICIENT_RESOURCES	= 0xc00e0027,
	MQ_ERROR_USER_BUFFER_TOO_SMALL	= 0xc00e0028,
	MQ_ERROR_MESSAGE_STORAGE_FAILED	= 0xc00e002a,
	MQ_ERROR_SENDER_CERT_BUFFER_TOO_SMALL	= 0xc00e002b,
	MQ_ERROR_INVALID_CERTIFICATE	= 0xc00e002c,
	MQ_ERROR_CORRUPTED_INTERNAL_CERTIFICATE	= 0xc00e002d,
	MQ_ERROR_NO_INTERNAL_USER_CERT	= 0xc00e002f,
	MQ_ERROR_CORRUPTED_SECURITY_DATA	= 0xc00e0030,
	MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE	= 0xc00e0031,
	MQ_ERROR_COMPUTER_DOES_NOT_SUPPORT_ENCRYPTION	= 0xc00e0033,
	MQ_ERROR_BAD_SECURITY_CONTEXT	= 0xc00e0035,
	MQ_ERROR_COULD_NOT_GET_USER_SID	= 0xc00e0036,
	MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO	= 0xc00e0037,
	MQ_ERROR_ILLEGAL_MQCOLUMNS	= 0xc00e0038,
	MQ_ERROR_ILLEGAL_PROPID	= 0xc00e0039,
	MQ_ERROR_ILLEGAL_RELATION	= 0xc00e003a,
	MQ_ERROR_ILLEGAL_PROPERTY_SIZE	= 0xc00e003b,
	MQ_ERROR_ILLEGAL_RESTRICTION_PROPID	= 0xc00e003c,
	MQ_ERROR_ILLEGAL_MQQUEUEPROPS	= 0xc00e003d,
	MQ_ERROR_PROPERTY_NOTALLOWED	= 0xc00e003e,
	MQ_ERROR_INSUFFICIENT_PROPERTIES	= 0xc00e003f,
	MQ_ERROR_MACHINE_EXISTS	= 0xc00e0040,
	MQ_ERROR_ILLEGAL_MQQMPROPS	= 0xc00e0041,
	MQ_ERROR_DS_IS_FULL	= 0xc00e0042L,
	MQ_ERROR_DS_ERROR	= 0xc00e0043,
	MQ_ERROR_INVALID_OWNER	= 0xc00e0044,
	MQ_ERROR_UNSUPPORTED_ACCESS_MODE	= 0xc00e0045,
	MQ_ERROR_RESULT_BUFFER_TOO_SMALL	= 0xc00e0046,
	MQ_ERROR_DELETE_CN_IN_USE	= 0xc00e0048L,
	MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER	= 0xc00e0049,
	MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE	= 0xc00e004a,
	MQ_ERROR_QUEUE_NOT_AVAILABLE	= 0xc00e004b,
	MQ_ERROR_DTC_CONNECT	= 0xc00e004c,
	MQ_ERROR_TRANSACTION_IMPORT	= 0xc00e004e,
	MQ_ERROR_TRANSACTION_USAGE	= 0xc00e0050,
	MQ_ERROR_TRANSACTION_SEQUENCE	= 0xc00e0051,
	MQ_ERROR_MISSING_CONNECTOR_TYPE	= 0xc00e0055,
	MQ_ERROR_STALE_HANDLE	= 0xc00e0056,
	MQ_ERROR_TRANSACTION_ENLIST	= 0xc00e0058,
	MQ_ERROR_QUEUE_DELETED	= 0xc00e005a,
	MQ_ERROR_ILLEGAL_CONTEXT	= 0xc00e005b,
	MQ_ERROR_ILLEGAL_SORT_PROPID	= 0xc00e005c,
	MQ_ERROR_LABEL_TOO_LONG	= 0xc00e005d,
	MQ_ERROR_LABEL_BUFFER_TOO_SMALL	= 0xc00e005e,
	MQ_ERROR_MQIS_SERVER_EMPTY	= 0xc00e005fL,
	MQ_ERROR_MQIS_READONLY_MODE	= 0xc00e0060L,
	MQ_ERROR_SYMM_KEY_BUFFER_TOO_SMALL	= 0xc00e0061,
	MQ_ERROR_SIGNATURE_BUFFER_TOO_SMALL	= 0xc00e0062,
	MQ_ERROR_PROV_NAME_BUFFER_TOO_SMALL	= 0xc00e0063,
	MQ_ERROR_ILLEGAL_OPERATION	= 0xc00e0064,
	MQ_ERROR_WRITE_NOT_ALLOWED	= 0xc00e0065L,
	MQ_ERROR_WKS_CANT_SERVE_CLIENT	= 0xc00e0066L,
	MQ_ERROR_DEPEND_WKS_LICENSE_OVERFLOW	= 0xc00e0067L,
	MQ_CORRUPTED_QUEUE_WAS_DELETED	= 0xc00e0068L,
	MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE	= 0xc00e0069L,
	MQ_ERROR_UNSUPPORTED_OPERATION	= 0xc00e006aL,
	MQ_ERROR_ENCRYPTION_PROVIDER_NOT_SUPPORTED	= 0xc00e006bL,
	MQ_ERROR_CANNOT_SET_CRYPTO_SEC_DESCR	= 0xc00e006cL,
	MQ_ERROR_CERTIFICATE_NOT_PROVIDED	= 0xc00e006dL,
	MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED	= 0xc00e006eL,
	MQ_ERROR_CANT_CREATE_CERT_STORE	= 0xc00e006fL,
	MQ_ERROR_CANNOT_CREATE_CERT_STORE	= 0xc00e006fL,
	MQ_ERROR_CANT_OPEN_CERT_STORE	= 0xc00e0070L,
	MQ_ERROR_CANNOT_OPEN_CERT_STORE	= 0xc00e0070L,
	MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION	= 0xc00e0071L,
	MQ_ERROR_CANNOT_GRANT_ADD_GUID	= 0xc00e0072L,
	MQ_ERROR_CANNOT_LOAD_MSMQOCM	= 0xc00e0073L,
	MQ_ERROR_NO_ENTRY_POINT_MSMQOCM	= 0xc00e0074L,
	MQ_ERROR_NO_MSMQ_SERVERS_ON_DC	= 0xc00e0075L,
	MQ_ERROR_CANNOT_JOIN_DOMAIN	= 0xc00e0076L,
	MQ_ERROR_CANNOT_CREATE_ON_GC	= 0xc00e0077L,
	MQ_ERROR_GUID_NOT_MATCHING	= 0xc00e0078L,
	MQ_ERROR_PUBLIC_KEY_NOT_FOUND	= 0xc00e0079L,
	MQ_ERROR_PUBLIC_KEY_DOES_NOT_EXIST	= 0xc00e007aL,
	MQ_ERROR_ILLEGAL_MQPRIVATEPROPS	= 0xc00e007bL,
	MQ_ERROR_NO_GC_IN_DOMAIN	= 0xc00e007cL,
	MQ_ERROR_NO_MSMQ_SERVERS_ON_GC	= 0xc00e007dL,
	MQ_ERROR_CANNOT_GET_DN	= 0xc00e007eL,
	MQ_ERROR_CANNOT_HASH_DATA_EX	= 0xc00e007fL,
	MQ_ERROR_CANNOT_SIGN_DATA_EX	= 0xc00e0080L,
	MQ_ERROR_CANNOT_CREATE_HASH_EX	= 0xc00e0081L,
	MQ_ERROR_FAIL_VERIFY_SIGNATURE_EX	= 0xc00e0082L,
	MQ_ERROR_CANNOT_DELETE_PSC_OBJECTS	= 0xc00e0083L,
	MQ_ERROR_NO_MQUSER_OU	= 0xc00e0084L,
	MQ_ERROR_CANNOT_LOAD_MQAD	= 0xc00e0085L,
	MQ_ERROR_CANNOT_LOAD_MQDSSRV	= 0xc00e0086L,
	MQ_ERROR_PROPERTIES_CONFLICT	= 0xc00e0087L,
	MQ_ERROR_MESSAGE_NOT_FOUND	= 0xc00e0088L,
	MQ_ERROR_CANT_RESOLVE_SITES	= 0xc00e0089L,
	MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS	= 0xc00e008aL,
	MQ_ERROR_OPERATION_NOT_SUPPORTED_BY_REMOTE_COMPUTER	= 0xc00e008bL,
	MQ_ERROR_NOT_A_CORRECT_OBJECT_CLASS	= 0xc00e008cL,
	MQ_ERROR_MULTI_SORT_KEYS	= 0xc00e008dL,
	MQ_ERROR_GC_NEEDED	= 0xc00e008eL,
	MQ_ERROR_DS_BIND_ROOT_FOREST	= 0xc00e008fL,
	MQ_ERROR_DS_LOCAL_USER	= 0xc00e0090L,
	MQ_ERROR_Q_ADS_PROPERTY_NOT_SUPPORTED	= 0xc00e0091L,
	MQ_ERROR_BAD_XML_FORMAT	= 0xc00e0092L,
	MQ_ERROR_UNSUPPORTED_CLASS	= 0xc00e0093L
    } ;
/* [helpstringcontext] */ 
enum MQWARNING
    {	MQ_INFORMATION_PROPERTY	= 0x400e0001,
	MQ_INFORMATION_ILLEGAL_PROPERTY	= 0x400e0002,
	MQ_INFORMATION_PROPERTY_IGNORED	= 0x400e0003,
	MQ_INFORMATION_UNSUPPORTED_PROPERTY	= 0x400e0004,
	MQ_INFORMATION_DUPLICATE_PROPERTY	= 0x400e0005,
	MQ_INFORMATION_OPERATION_PENDING	= 0x400e0006,
	MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL	= 0x400e0009,
	MQ_INFORMATION_INTERNAL_USER_CERT_EXIST	= 0x400e000aL,
	MQ_INFORMATION_OWNER_IGNORED	= 0x400e000bL
    } ;

EXTERN_C const IID LIBID_MSMQ;

#ifndef __IMSMQQuery_INTERFACE_DEFINED__
#define __IMSMQQuery_INTERFACE_DEFINED__

/* interface IMSMQQuery */
/* [object][nonextensible][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E072-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQQuery : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE LookupQueue( 
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [retval][out] */ IMSMQQueueInfos **ppqinfos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQuery * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQuery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQuery * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQuery * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQuery * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQuery * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *LookupQueue )( 
            IMSMQQuery * This,
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [retval][out] */ IMSMQQueueInfos **ppqinfos);
        
        END_INTERFACE
    } IMSMQQueryVtbl;

    interface IMSMQQuery
    {
        CONST_VTBL struct IMSMQQueryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQuery_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQuery_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQuery_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQuery_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQuery_LookupQueue(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,ppqinfos)	\
    (This)->lpVtbl -> LookupQueue(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,ppqinfos)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQuery_LookupQueue_Proxy( 
    IMSMQQuery * This,
    /* [optional][in] */ VARIANT *QueueGuid,
    /* [optional][in] */ VARIANT *ServiceTypeGuid,
    /* [optional][in] */ VARIANT *Label,
    /* [optional][in] */ VARIANT *CreateTime,
    /* [optional][in] */ VARIANT *ModifyTime,
    /* [optional][in] */ VARIANT *RelServiceType,
    /* [optional][in] */ VARIANT *RelLabel,
    /* [optional][in] */ VARIANT *RelCreateTime,
    /* [optional][in] */ VARIANT *RelModifyTime,
    /* [retval][out] */ IMSMQQueueInfos **ppqinfos);


void __RPC_STUB IMSMQQuery_LookupQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQuery_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueueInfo_INTERFACE_DEFINED__
#define __IMSMQQueueInfo_INTERFACE_DEFINED__

/* interface IMSMQQueueInfo */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E07B-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQQueueInfo : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueGuid( 
            /* [retval][out] */ BSTR *pbstrGuidQueue) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ServiceTypeGuid( 
            /* [retval][out] */ BSTR *pbstrGuidServiceType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_ServiceTypeGuid( 
            /* [in] */ BSTR bstrGuidServiceType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Label( 
            /* [retval][out] */ BSTR *pbstrLabel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Label( 
            /* [in] */ BSTR bstrLabel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PathName( 
            /* [retval][out] */ BSTR *pbstrPathName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PathName( 
            /* [in] */ BSTR bstrPathName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_FormatName( 
            /* [retval][out] */ BSTR *pbstrFormatName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_FormatName( 
            /* [in] */ BSTR bstrFormatName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsTransactional( 
            /* [retval][out] */ Boolean *pisTransactional) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivLevel( 
            /* [retval][out] */ long *plPrivLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PrivLevel( 
            /* [in] */ long lPrivLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ long *plJournal) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Journal( 
            /* [in] */ long lJournal) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Quota( 
            /* [retval][out] */ long *plQuota) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Quota( 
            /* [in] */ long lQuota) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BasePriority( 
            /* [retval][out] */ long *plBasePriority) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_BasePriority( 
            /* [in] */ long lBasePriority) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CreateTime( 
            /* [retval][out] */ VARIANT *pvarCreateTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ModifyTime( 
            /* [retval][out] */ VARIANT *pvarModifyTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Authenticate( 
            /* [retval][out] */ long *plAuthenticate) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Authenticate( 
            /* [in] */ long lAuthenticate) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_JournalQuota( 
            /* [retval][out] */ long *plJournalQuota) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_JournalQuota( 
            /* [in] */ long lJournalQuota) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsWorldReadable( 
            /* [retval][out] */ Boolean *pisWorldReadable) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [optional][in] */ VARIANT *IsTransactional,
            /* [optional][in] */ VARIANT *IsWorldReadable) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ long Access,
            /* [in] */ long ShareMode,
            /* [retval][out] */ IMSMQQueue **ppq) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueGuid )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ BSTR *pbstrGuidQueue);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceTypeGuid )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ BSTR *pbstrGuidServiceType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceTypeGuid )( 
            IMSMQQueueInfo * This,
            /* [in] */ BSTR bstrGuidServiceType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Label )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ BSTR *pbstrLabel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Label )( 
            IMSMQQueueInfo * This,
            /* [in] */ BSTR bstrLabel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PathName )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ BSTR *pbstrPathName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PathName )( 
            IMSMQQueueInfo * This,
            /* [in] */ BSTR bstrPathName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_FormatName )( 
            IMSMQQueueInfo * This,
            /* [in] */ BSTR bstrFormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsTransactional )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ Boolean *pisTransactional);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivLevel )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ long *plPrivLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PrivLevel )( 
            IMSMQQueueInfo * This,
            /* [in] */ long lPrivLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Journal )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ long *plJournal);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Journal )( 
            IMSMQQueueInfo * This,
            /* [in] */ long lJournal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Quota )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ long *plQuota);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Quota )( 
            IMSMQQueueInfo * This,
            /* [in] */ long lQuota);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BasePriority )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ long *plBasePriority);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_BasePriority )( 
            IMSMQQueueInfo * This,
            /* [in] */ long lBasePriority);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CreateTime )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ VARIANT *pvarCreateTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ModifyTime )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ VARIANT *pvarModifyTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticate )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ long *plAuthenticate);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Authenticate )( 
            IMSMQQueueInfo * This,
            /* [in] */ long lAuthenticate);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_JournalQuota )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ long *plJournalQuota);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_JournalQuota )( 
            IMSMQQueueInfo * This,
            /* [in] */ long lJournalQuota);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsWorldReadable )( 
            IMSMQQueueInfo * This,
            /* [retval][out] */ Boolean *pisWorldReadable);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            IMSMQQueueInfo * This,
            /* [optional][in] */ VARIANT *IsTransactional,
            /* [optional][in] */ VARIANT *IsWorldReadable);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IMSMQQueueInfo * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IMSMQQueueInfo * This,
            /* [in] */ long Access,
            /* [in] */ long ShareMode,
            /* [retval][out] */ IMSMQQueue **ppq);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IMSMQQueueInfo * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            IMSMQQueueInfo * This);
        
        END_INTERFACE
    } IMSMQQueueInfoVtbl;

    interface IMSMQQueueInfo
    {
        CONST_VTBL struct IMSMQQueueInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueInfo_get_QueueGuid(This,pbstrGuidQueue)	\
    (This)->lpVtbl -> get_QueueGuid(This,pbstrGuidQueue)

#define IMSMQQueueInfo_get_ServiceTypeGuid(This,pbstrGuidServiceType)	\
    (This)->lpVtbl -> get_ServiceTypeGuid(This,pbstrGuidServiceType)

#define IMSMQQueueInfo_put_ServiceTypeGuid(This,bstrGuidServiceType)	\
    (This)->lpVtbl -> put_ServiceTypeGuid(This,bstrGuidServiceType)

#define IMSMQQueueInfo_get_Label(This,pbstrLabel)	\
    (This)->lpVtbl -> get_Label(This,pbstrLabel)

#define IMSMQQueueInfo_put_Label(This,bstrLabel)	\
    (This)->lpVtbl -> put_Label(This,bstrLabel)

#define IMSMQQueueInfo_get_PathName(This,pbstrPathName)	\
    (This)->lpVtbl -> get_PathName(This,pbstrPathName)

#define IMSMQQueueInfo_put_PathName(This,bstrPathName)	\
    (This)->lpVtbl -> put_PathName(This,bstrPathName)

#define IMSMQQueueInfo_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQQueueInfo_put_FormatName(This,bstrFormatName)	\
    (This)->lpVtbl -> put_FormatName(This,bstrFormatName)

#define IMSMQQueueInfo_get_IsTransactional(This,pisTransactional)	\
    (This)->lpVtbl -> get_IsTransactional(This,pisTransactional)

#define IMSMQQueueInfo_get_PrivLevel(This,plPrivLevel)	\
    (This)->lpVtbl -> get_PrivLevel(This,plPrivLevel)

#define IMSMQQueueInfo_put_PrivLevel(This,lPrivLevel)	\
    (This)->lpVtbl -> put_PrivLevel(This,lPrivLevel)

#define IMSMQQueueInfo_get_Journal(This,plJournal)	\
    (This)->lpVtbl -> get_Journal(This,plJournal)

#define IMSMQQueueInfo_put_Journal(This,lJournal)	\
    (This)->lpVtbl -> put_Journal(This,lJournal)

#define IMSMQQueueInfo_get_Quota(This,plQuota)	\
    (This)->lpVtbl -> get_Quota(This,plQuota)

#define IMSMQQueueInfo_put_Quota(This,lQuota)	\
    (This)->lpVtbl -> put_Quota(This,lQuota)

#define IMSMQQueueInfo_get_BasePriority(This,plBasePriority)	\
    (This)->lpVtbl -> get_BasePriority(This,plBasePriority)

#define IMSMQQueueInfo_put_BasePriority(This,lBasePriority)	\
    (This)->lpVtbl -> put_BasePriority(This,lBasePriority)

#define IMSMQQueueInfo_get_CreateTime(This,pvarCreateTime)	\
    (This)->lpVtbl -> get_CreateTime(This,pvarCreateTime)

#define IMSMQQueueInfo_get_ModifyTime(This,pvarModifyTime)	\
    (This)->lpVtbl -> get_ModifyTime(This,pvarModifyTime)

#define IMSMQQueueInfo_get_Authenticate(This,plAuthenticate)	\
    (This)->lpVtbl -> get_Authenticate(This,plAuthenticate)

#define IMSMQQueueInfo_put_Authenticate(This,lAuthenticate)	\
    (This)->lpVtbl -> put_Authenticate(This,lAuthenticate)

#define IMSMQQueueInfo_get_JournalQuota(This,plJournalQuota)	\
    (This)->lpVtbl -> get_JournalQuota(This,plJournalQuota)

#define IMSMQQueueInfo_put_JournalQuota(This,lJournalQuota)	\
    (This)->lpVtbl -> put_JournalQuota(This,lJournalQuota)

#define IMSMQQueueInfo_get_IsWorldReadable(This,pisWorldReadable)	\
    (This)->lpVtbl -> get_IsWorldReadable(This,pisWorldReadable)

#define IMSMQQueueInfo_Create(This,IsTransactional,IsWorldReadable)	\
    (This)->lpVtbl -> Create(This,IsTransactional,IsWorldReadable)

#define IMSMQQueueInfo_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IMSMQQueueInfo_Open(This,Access,ShareMode,ppq)	\
    (This)->lpVtbl -> Open(This,Access,ShareMode,ppq)

#define IMSMQQueueInfo_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IMSMQQueueInfo_Update(This)	\
    (This)->lpVtbl -> Update(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_QueueGuid_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ BSTR *pbstrGuidQueue);


void __RPC_STUB IMSMQQueueInfo_get_QueueGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_ServiceTypeGuid_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ BSTR *pbstrGuidServiceType);


void __RPC_STUB IMSMQQueueInfo_get_ServiceTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_ServiceTypeGuid_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ BSTR bstrGuidServiceType);


void __RPC_STUB IMSMQQueueInfo_put_ServiceTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_Label_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ BSTR *pbstrLabel);


void __RPC_STUB IMSMQQueueInfo_get_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_Label_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ BSTR bstrLabel);


void __RPC_STUB IMSMQQueueInfo_put_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_PathName_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ BSTR *pbstrPathName);


void __RPC_STUB IMSMQQueueInfo_get_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_PathName_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ BSTR bstrPathName);


void __RPC_STUB IMSMQQueueInfo_put_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_FormatName_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ BSTR *pbstrFormatName);


void __RPC_STUB IMSMQQueueInfo_get_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_FormatName_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ BSTR bstrFormatName);


void __RPC_STUB IMSMQQueueInfo_put_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_IsTransactional_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ Boolean *pisTransactional);


void __RPC_STUB IMSMQQueueInfo_get_IsTransactional_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_PrivLevel_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ long *plPrivLevel);


void __RPC_STUB IMSMQQueueInfo_get_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_PrivLevel_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long lPrivLevel);


void __RPC_STUB IMSMQQueueInfo_put_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_Journal_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ long *plJournal);


void __RPC_STUB IMSMQQueueInfo_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_Journal_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long lJournal);


void __RPC_STUB IMSMQQueueInfo_put_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_Quota_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ long *plQuota);


void __RPC_STUB IMSMQQueueInfo_get_Quota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_Quota_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long lQuota);


void __RPC_STUB IMSMQQueueInfo_put_Quota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_BasePriority_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ long *plBasePriority);


void __RPC_STUB IMSMQQueueInfo_get_BasePriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_BasePriority_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long lBasePriority);


void __RPC_STUB IMSMQQueueInfo_put_BasePriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_CreateTime_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ VARIANT *pvarCreateTime);


void __RPC_STUB IMSMQQueueInfo_get_CreateTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_ModifyTime_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ VARIANT *pvarModifyTime);


void __RPC_STUB IMSMQQueueInfo_get_ModifyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_Authenticate_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ long *plAuthenticate);


void __RPC_STUB IMSMQQueueInfo_get_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_Authenticate_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long lAuthenticate);


void __RPC_STUB IMSMQQueueInfo_put_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_JournalQuota_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ long *plJournalQuota);


void __RPC_STUB IMSMQQueueInfo_get_JournalQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_put_JournalQuota_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long lJournalQuota);


void __RPC_STUB IMSMQQueueInfo_put_JournalQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_get_IsWorldReadable_Proxy( 
    IMSMQQueueInfo * This,
    /* [retval][out] */ Boolean *pisWorldReadable);


void __RPC_STUB IMSMQQueueInfo_get_IsWorldReadable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_Create_Proxy( 
    IMSMQQueueInfo * This,
    /* [optional][in] */ VARIANT *IsTransactional,
    /* [optional][in] */ VARIANT *IsWorldReadable);


void __RPC_STUB IMSMQQueueInfo_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_Delete_Proxy( 
    IMSMQQueueInfo * This);


void __RPC_STUB IMSMQQueueInfo_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_Open_Proxy( 
    IMSMQQueueInfo * This,
    /* [in] */ long Access,
    /* [in] */ long ShareMode,
    /* [retval][out] */ IMSMQQueue **ppq);


void __RPC_STUB IMSMQQueueInfo_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_Refresh_Proxy( 
    IMSMQQueueInfo * This);


void __RPC_STUB IMSMQQueueInfo_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo_Update_Proxy( 
    IMSMQQueueInfo * This);


void __RPC_STUB IMSMQQueueInfo_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueInfo_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueueInfo2_INTERFACE_DEFINED__
#define __IMSMQQueueInfo2_INTERFACE_DEFINED__

/* interface IMSMQQueueInfo2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD174A80-89CF-11D2-B0F2-00E02C074F6B")
    IMSMQQueueInfo2 : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueGuid( 
            /* [retval][out] */ BSTR *pbstrGuidQueue) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ServiceTypeGuid( 
            /* [retval][out] */ BSTR *pbstrGuidServiceType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_ServiceTypeGuid( 
            /* [in] */ BSTR bstrGuidServiceType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Label( 
            /* [retval][out] */ BSTR *pbstrLabel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Label( 
            /* [in] */ BSTR bstrLabel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PathName( 
            /* [retval][out] */ BSTR *pbstrPathName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PathName( 
            /* [in] */ BSTR bstrPathName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_FormatName( 
            /* [retval][out] */ BSTR *pbstrFormatName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_FormatName( 
            /* [in] */ BSTR bstrFormatName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsTransactional( 
            /* [retval][out] */ Boolean *pisTransactional) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivLevel( 
            /* [retval][out] */ long *plPrivLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PrivLevel( 
            /* [in] */ long lPrivLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ long *plJournal) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Journal( 
            /* [in] */ long lJournal) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Quota( 
            /* [retval][out] */ long *plQuota) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Quota( 
            /* [in] */ long lQuota) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BasePriority( 
            /* [retval][out] */ long *plBasePriority) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_BasePriority( 
            /* [in] */ long lBasePriority) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CreateTime( 
            /* [retval][out] */ VARIANT *pvarCreateTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ModifyTime( 
            /* [retval][out] */ VARIANT *pvarModifyTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Authenticate( 
            /* [retval][out] */ long *plAuthenticate) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Authenticate( 
            /* [in] */ long lAuthenticate) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_JournalQuota( 
            /* [retval][out] */ long *plJournalQuota) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_JournalQuota( 
            /* [in] */ long lJournalQuota) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsWorldReadable( 
            /* [retval][out] */ Boolean *pisWorldReadable) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [optional][in] */ VARIANT *IsTransactional,
            /* [optional][in] */ VARIANT *IsWorldReadable) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ long Access,
            /* [in] */ long ShareMode,
            /* [retval][out] */ IMSMQQueue2 **ppq) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PathNameDNS( 
            /* [retval][out] */ BSTR *pbstrPathNameDNS) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Security( 
            /* [retval][out] */ VARIANT *pvarSecurity) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_Security( 
            /* [in] */ VARIANT varSecurity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueInfo2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueGuid )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ BSTR *pbstrGuidQueue);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceTypeGuid )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ BSTR *pbstrGuidServiceType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceTypeGuid )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ BSTR bstrGuidServiceType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Label )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ BSTR *pbstrLabel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Label )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ BSTR bstrLabel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PathName )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ BSTR *pbstrPathName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PathName )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ BSTR bstrPathName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_FormatName )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ BSTR bstrFormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsTransactional )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ Boolean *pisTransactional);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivLevel )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ long *plPrivLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PrivLevel )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long lPrivLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Journal )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ long *plJournal);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Journal )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long lJournal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Quota )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ long *plQuota);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Quota )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long lQuota);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BasePriority )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ long *plBasePriority);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_BasePriority )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long lBasePriority);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CreateTime )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ VARIANT *pvarCreateTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ModifyTime )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ VARIANT *pvarModifyTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticate )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ long *plAuthenticate);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Authenticate )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long lAuthenticate);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_JournalQuota )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ long *plJournalQuota);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_JournalQuota )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long lJournalQuota);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsWorldReadable )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ Boolean *pisWorldReadable);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            IMSMQQueueInfo2 * This,
            /* [optional][in] */ VARIANT *IsTransactional,
            /* [optional][in] */ VARIANT *IsWorldReadable);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IMSMQQueueInfo2 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ long Access,
            /* [in] */ long ShareMode,
            /* [retval][out] */ IMSMQQueue2 **ppq);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IMSMQQueueInfo2 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            IMSMQQueueInfo2 * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PathNameDNS )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ BSTR *pbstrPathNameDNS);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Security )( 
            IMSMQQueueInfo2 * This,
            /* [retval][out] */ VARIANT *pvarSecurity);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Security )( 
            IMSMQQueueInfo2 * This,
            /* [in] */ VARIANT varSecurity);
        
        END_INTERFACE
    } IMSMQQueueInfo2Vtbl;

    interface IMSMQQueueInfo2
    {
        CONST_VTBL struct IMSMQQueueInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueInfo2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueInfo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueInfo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueInfo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueInfo2_get_QueueGuid(This,pbstrGuidQueue)	\
    (This)->lpVtbl -> get_QueueGuid(This,pbstrGuidQueue)

#define IMSMQQueueInfo2_get_ServiceTypeGuid(This,pbstrGuidServiceType)	\
    (This)->lpVtbl -> get_ServiceTypeGuid(This,pbstrGuidServiceType)

#define IMSMQQueueInfo2_put_ServiceTypeGuid(This,bstrGuidServiceType)	\
    (This)->lpVtbl -> put_ServiceTypeGuid(This,bstrGuidServiceType)

#define IMSMQQueueInfo2_get_Label(This,pbstrLabel)	\
    (This)->lpVtbl -> get_Label(This,pbstrLabel)

#define IMSMQQueueInfo2_put_Label(This,bstrLabel)	\
    (This)->lpVtbl -> put_Label(This,bstrLabel)

#define IMSMQQueueInfo2_get_PathName(This,pbstrPathName)	\
    (This)->lpVtbl -> get_PathName(This,pbstrPathName)

#define IMSMQQueueInfo2_put_PathName(This,bstrPathName)	\
    (This)->lpVtbl -> put_PathName(This,bstrPathName)

#define IMSMQQueueInfo2_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQQueueInfo2_put_FormatName(This,bstrFormatName)	\
    (This)->lpVtbl -> put_FormatName(This,bstrFormatName)

#define IMSMQQueueInfo2_get_IsTransactional(This,pisTransactional)	\
    (This)->lpVtbl -> get_IsTransactional(This,pisTransactional)

#define IMSMQQueueInfo2_get_PrivLevel(This,plPrivLevel)	\
    (This)->lpVtbl -> get_PrivLevel(This,plPrivLevel)

#define IMSMQQueueInfo2_put_PrivLevel(This,lPrivLevel)	\
    (This)->lpVtbl -> put_PrivLevel(This,lPrivLevel)

#define IMSMQQueueInfo2_get_Journal(This,plJournal)	\
    (This)->lpVtbl -> get_Journal(This,plJournal)

#define IMSMQQueueInfo2_put_Journal(This,lJournal)	\
    (This)->lpVtbl -> put_Journal(This,lJournal)

#define IMSMQQueueInfo2_get_Quota(This,plQuota)	\
    (This)->lpVtbl -> get_Quota(This,plQuota)

#define IMSMQQueueInfo2_put_Quota(This,lQuota)	\
    (This)->lpVtbl -> put_Quota(This,lQuota)

#define IMSMQQueueInfo2_get_BasePriority(This,plBasePriority)	\
    (This)->lpVtbl -> get_BasePriority(This,plBasePriority)

#define IMSMQQueueInfo2_put_BasePriority(This,lBasePriority)	\
    (This)->lpVtbl -> put_BasePriority(This,lBasePriority)

#define IMSMQQueueInfo2_get_CreateTime(This,pvarCreateTime)	\
    (This)->lpVtbl -> get_CreateTime(This,pvarCreateTime)

#define IMSMQQueueInfo2_get_ModifyTime(This,pvarModifyTime)	\
    (This)->lpVtbl -> get_ModifyTime(This,pvarModifyTime)

#define IMSMQQueueInfo2_get_Authenticate(This,plAuthenticate)	\
    (This)->lpVtbl -> get_Authenticate(This,plAuthenticate)

#define IMSMQQueueInfo2_put_Authenticate(This,lAuthenticate)	\
    (This)->lpVtbl -> put_Authenticate(This,lAuthenticate)

#define IMSMQQueueInfo2_get_JournalQuota(This,plJournalQuota)	\
    (This)->lpVtbl -> get_JournalQuota(This,plJournalQuota)

#define IMSMQQueueInfo2_put_JournalQuota(This,lJournalQuota)	\
    (This)->lpVtbl -> put_JournalQuota(This,lJournalQuota)

#define IMSMQQueueInfo2_get_IsWorldReadable(This,pisWorldReadable)	\
    (This)->lpVtbl -> get_IsWorldReadable(This,pisWorldReadable)

#define IMSMQQueueInfo2_Create(This,IsTransactional,IsWorldReadable)	\
    (This)->lpVtbl -> Create(This,IsTransactional,IsWorldReadable)

#define IMSMQQueueInfo2_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IMSMQQueueInfo2_Open(This,Access,ShareMode,ppq)	\
    (This)->lpVtbl -> Open(This,Access,ShareMode,ppq)

#define IMSMQQueueInfo2_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IMSMQQueueInfo2_Update(This)	\
    (This)->lpVtbl -> Update(This)

#define IMSMQQueueInfo2_get_PathNameDNS(This,pbstrPathNameDNS)	\
    (This)->lpVtbl -> get_PathNameDNS(This,pbstrPathNameDNS)

#define IMSMQQueueInfo2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#define IMSMQQueueInfo2_get_Security(This,pvarSecurity)	\
    (This)->lpVtbl -> get_Security(This,pvarSecurity)

#define IMSMQQueueInfo2_put_Security(This,varSecurity)	\
    (This)->lpVtbl -> put_Security(This,varSecurity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_QueueGuid_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ BSTR *pbstrGuidQueue);


void __RPC_STUB IMSMQQueueInfo2_get_QueueGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_ServiceTypeGuid_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ BSTR *pbstrGuidServiceType);


void __RPC_STUB IMSMQQueueInfo2_get_ServiceTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_ServiceTypeGuid_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ BSTR bstrGuidServiceType);


void __RPC_STUB IMSMQQueueInfo2_put_ServiceTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_Label_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ BSTR *pbstrLabel);


void __RPC_STUB IMSMQQueueInfo2_get_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_Label_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ BSTR bstrLabel);


void __RPC_STUB IMSMQQueueInfo2_put_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_PathName_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ BSTR *pbstrPathName);


void __RPC_STUB IMSMQQueueInfo2_get_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_PathName_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ BSTR bstrPathName);


void __RPC_STUB IMSMQQueueInfo2_put_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_FormatName_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ BSTR *pbstrFormatName);


void __RPC_STUB IMSMQQueueInfo2_get_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_FormatName_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ BSTR bstrFormatName);


void __RPC_STUB IMSMQQueueInfo2_put_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_IsTransactional_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ Boolean *pisTransactional);


void __RPC_STUB IMSMQQueueInfo2_get_IsTransactional_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_PrivLevel_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ long *plPrivLevel);


void __RPC_STUB IMSMQQueueInfo2_get_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_PrivLevel_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long lPrivLevel);


void __RPC_STUB IMSMQQueueInfo2_put_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_Journal_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ long *plJournal);


void __RPC_STUB IMSMQQueueInfo2_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_Journal_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long lJournal);


void __RPC_STUB IMSMQQueueInfo2_put_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_Quota_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ long *plQuota);


void __RPC_STUB IMSMQQueueInfo2_get_Quota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_Quota_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long lQuota);


void __RPC_STUB IMSMQQueueInfo2_put_Quota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_BasePriority_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ long *plBasePriority);


void __RPC_STUB IMSMQQueueInfo2_get_BasePriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_BasePriority_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long lBasePriority);


void __RPC_STUB IMSMQQueueInfo2_put_BasePriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_CreateTime_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ VARIANT *pvarCreateTime);


void __RPC_STUB IMSMQQueueInfo2_get_CreateTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_ModifyTime_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ VARIANT *pvarModifyTime);


void __RPC_STUB IMSMQQueueInfo2_get_ModifyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_Authenticate_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ long *plAuthenticate);


void __RPC_STUB IMSMQQueueInfo2_get_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_Authenticate_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long lAuthenticate);


void __RPC_STUB IMSMQQueueInfo2_put_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_JournalQuota_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ long *plJournalQuota);


void __RPC_STUB IMSMQQueueInfo2_get_JournalQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_JournalQuota_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long lJournalQuota);


void __RPC_STUB IMSMQQueueInfo2_put_JournalQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_IsWorldReadable_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ Boolean *pisWorldReadable);


void __RPC_STUB IMSMQQueueInfo2_get_IsWorldReadable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_Create_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [optional][in] */ VARIANT *IsTransactional,
    /* [optional][in] */ VARIANT *IsWorldReadable);


void __RPC_STUB IMSMQQueueInfo2_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_Delete_Proxy( 
    IMSMQQueueInfo2 * This);


void __RPC_STUB IMSMQQueueInfo2_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_Open_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ long Access,
    /* [in] */ long ShareMode,
    /* [retval][out] */ IMSMQQueue2 **ppq);


void __RPC_STUB IMSMQQueueInfo2_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_Refresh_Proxy( 
    IMSMQQueueInfo2 * This);


void __RPC_STUB IMSMQQueueInfo2_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_Update_Proxy( 
    IMSMQQueueInfo2 * This);


void __RPC_STUB IMSMQQueueInfo2_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_PathNameDNS_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ BSTR *pbstrPathNameDNS);


void __RPC_STUB IMSMQQueueInfo2_get_PathNameDNS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_Properties_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQueueInfo2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_get_Security_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [retval][out] */ VARIANT *pvarSecurity);


void __RPC_STUB IMSMQQueueInfo2_get_Security_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo2_put_Security_Proxy( 
    IMSMQQueueInfo2 * This,
    /* [in] */ VARIANT varSecurity);


void __RPC_STUB IMSMQQueueInfo2_put_Security_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueInfo2_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueueInfo3_INTERFACE_DEFINED__
#define __IMSMQQueueInfo3_INTERFACE_DEFINED__

/* interface IMSMQQueueInfo3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueInfo3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b1d-2168-11d3-898c-00e02c074f6b")
    IMSMQQueueInfo3 : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueGuid( 
            /* [retval][out] */ BSTR *pbstrGuidQueue) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ServiceTypeGuid( 
            /* [retval][out] */ BSTR *pbstrGuidServiceType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_ServiceTypeGuid( 
            /* [in] */ BSTR bstrGuidServiceType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Label( 
            /* [retval][out] */ BSTR *pbstrLabel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Label( 
            /* [in] */ BSTR bstrLabel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PathName( 
            /* [retval][out] */ BSTR *pbstrPathName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PathName( 
            /* [in] */ BSTR bstrPathName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_FormatName( 
            /* [retval][out] */ BSTR *pbstrFormatName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_FormatName( 
            /* [in] */ BSTR bstrFormatName) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_IsTransactional( 
            /* [retval][out] */ Boolean *pisTransactional) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivLevel( 
            /* [retval][out] */ long *plPrivLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PrivLevel( 
            /* [in] */ long lPrivLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ long *plJournal) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Journal( 
            /* [in] */ long lJournal) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Quota( 
            /* [retval][out] */ long *plQuota) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Quota( 
            /* [in] */ long lQuota) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BasePriority( 
            /* [retval][out] */ long *plBasePriority) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_BasePriority( 
            /* [in] */ long lBasePriority) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CreateTime( 
            /* [retval][out] */ VARIANT *pvarCreateTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ModifyTime( 
            /* [retval][out] */ VARIANT *pvarModifyTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Authenticate( 
            /* [retval][out] */ long *plAuthenticate) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Authenticate( 
            /* [in] */ long lAuthenticate) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_JournalQuota( 
            /* [retval][out] */ long *plJournalQuota) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_JournalQuota( 
            /* [in] */ long lJournalQuota) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_IsWorldReadable( 
            /* [retval][out] */ Boolean *pisWorldReadable) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [optional][in] */ VARIANT *IsTransactional,
            /* [optional][in] */ VARIANT *IsWorldReadable) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ long Access,
            /* [in] */ long ShareMode,
            /* [retval][out] */ IMSMQQueue3 **ppq) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PathNameDNS( 
            /* [retval][out] */ BSTR *pbstrPathNameDNS) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Security( 
            /* [retval][out] */ VARIANT *pvarSecurity) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_Security( 
            /* [in] */ VARIANT varSecurity) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsTransactional2( 
            /* [retval][out] */ VARIANT_BOOL *pisTransactional) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsWorldReadable2( 
            /* [retval][out] */ VARIANT_BOOL *pisWorldReadable) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MulticastAddress( 
            /* [retval][out] */ BSTR *pbstrMulticastAddress) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MulticastAddress( 
            /* [in] */ BSTR bstrMulticastAddress) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ADsPath( 
            /* [retval][out] */ BSTR *pbstrADsPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueInfo3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueInfo3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueInfo3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueInfo3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueGuid )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrGuidQueue);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceTypeGuid )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrGuidServiceType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceTypeGuid )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ BSTR bstrGuidServiceType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Label )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrLabel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Label )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ BSTR bstrLabel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PathName )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrPathName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PathName )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ BSTR bstrPathName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_FormatName )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ BSTR bstrFormatName);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IsTransactional )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ Boolean *pisTransactional);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivLevel )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ long *plPrivLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PrivLevel )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long lPrivLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Journal )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ long *plJournal);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Journal )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long lJournal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Quota )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ long *plQuota);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Quota )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long lQuota);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BasePriority )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ long *plBasePriority);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_BasePriority )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long lBasePriority);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CreateTime )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ VARIANT *pvarCreateTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ModifyTime )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ VARIANT *pvarModifyTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Authenticate )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ long *plAuthenticate);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Authenticate )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long lAuthenticate);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_JournalQuota )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ long *plJournalQuota);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_JournalQuota )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long lJournalQuota);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IsWorldReadable )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ Boolean *pisWorldReadable);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            IMSMQQueueInfo3 * This,
            /* [optional][in] */ VARIANT *IsTransactional,
            /* [optional][in] */ VARIANT *IsWorldReadable);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IMSMQQueueInfo3 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ long Access,
            /* [in] */ long ShareMode,
            /* [retval][out] */ IMSMQQueue3 **ppq);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IMSMQQueueInfo3 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            IMSMQQueueInfo3 * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PathNameDNS )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrPathNameDNS);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Security )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ VARIANT *pvarSecurity);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Security )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ VARIANT varSecurity);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsTransactional2 )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ VARIANT_BOOL *pisTransactional);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsWorldReadable2 )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ VARIANT_BOOL *pisWorldReadable);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MulticastAddress )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrMulticastAddress);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MulticastAddress )( 
            IMSMQQueueInfo3 * This,
            /* [in] */ BSTR bstrMulticastAddress);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IMSMQQueueInfo3 * This,
            /* [retval][out] */ BSTR *pbstrADsPath);
        
        END_INTERFACE
    } IMSMQQueueInfo3Vtbl;

    interface IMSMQQueueInfo3
    {
        CONST_VTBL struct IMSMQQueueInfo3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueInfo3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueInfo3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueInfo3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueInfo3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueInfo3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueInfo3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueInfo3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueInfo3_get_QueueGuid(This,pbstrGuidQueue)	\
    (This)->lpVtbl -> get_QueueGuid(This,pbstrGuidQueue)

#define IMSMQQueueInfo3_get_ServiceTypeGuid(This,pbstrGuidServiceType)	\
    (This)->lpVtbl -> get_ServiceTypeGuid(This,pbstrGuidServiceType)

#define IMSMQQueueInfo3_put_ServiceTypeGuid(This,bstrGuidServiceType)	\
    (This)->lpVtbl -> put_ServiceTypeGuid(This,bstrGuidServiceType)

#define IMSMQQueueInfo3_get_Label(This,pbstrLabel)	\
    (This)->lpVtbl -> get_Label(This,pbstrLabel)

#define IMSMQQueueInfo3_put_Label(This,bstrLabel)	\
    (This)->lpVtbl -> put_Label(This,bstrLabel)

#define IMSMQQueueInfo3_get_PathName(This,pbstrPathName)	\
    (This)->lpVtbl -> get_PathName(This,pbstrPathName)

#define IMSMQQueueInfo3_put_PathName(This,bstrPathName)	\
    (This)->lpVtbl -> put_PathName(This,bstrPathName)

#define IMSMQQueueInfo3_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQQueueInfo3_put_FormatName(This,bstrFormatName)	\
    (This)->lpVtbl -> put_FormatName(This,bstrFormatName)

#define IMSMQQueueInfo3_get_IsTransactional(This,pisTransactional)	\
    (This)->lpVtbl -> get_IsTransactional(This,pisTransactional)

#define IMSMQQueueInfo3_get_PrivLevel(This,plPrivLevel)	\
    (This)->lpVtbl -> get_PrivLevel(This,plPrivLevel)

#define IMSMQQueueInfo3_put_PrivLevel(This,lPrivLevel)	\
    (This)->lpVtbl -> put_PrivLevel(This,lPrivLevel)

#define IMSMQQueueInfo3_get_Journal(This,plJournal)	\
    (This)->lpVtbl -> get_Journal(This,plJournal)

#define IMSMQQueueInfo3_put_Journal(This,lJournal)	\
    (This)->lpVtbl -> put_Journal(This,lJournal)

#define IMSMQQueueInfo3_get_Quota(This,plQuota)	\
    (This)->lpVtbl -> get_Quota(This,plQuota)

#define IMSMQQueueInfo3_put_Quota(This,lQuota)	\
    (This)->lpVtbl -> put_Quota(This,lQuota)

#define IMSMQQueueInfo3_get_BasePriority(This,plBasePriority)	\
    (This)->lpVtbl -> get_BasePriority(This,plBasePriority)

#define IMSMQQueueInfo3_put_BasePriority(This,lBasePriority)	\
    (This)->lpVtbl -> put_BasePriority(This,lBasePriority)

#define IMSMQQueueInfo3_get_CreateTime(This,pvarCreateTime)	\
    (This)->lpVtbl -> get_CreateTime(This,pvarCreateTime)

#define IMSMQQueueInfo3_get_ModifyTime(This,pvarModifyTime)	\
    (This)->lpVtbl -> get_ModifyTime(This,pvarModifyTime)

#define IMSMQQueueInfo3_get_Authenticate(This,plAuthenticate)	\
    (This)->lpVtbl -> get_Authenticate(This,plAuthenticate)

#define IMSMQQueueInfo3_put_Authenticate(This,lAuthenticate)	\
    (This)->lpVtbl -> put_Authenticate(This,lAuthenticate)

#define IMSMQQueueInfo3_get_JournalQuota(This,plJournalQuota)	\
    (This)->lpVtbl -> get_JournalQuota(This,plJournalQuota)

#define IMSMQQueueInfo3_put_JournalQuota(This,lJournalQuota)	\
    (This)->lpVtbl -> put_JournalQuota(This,lJournalQuota)

#define IMSMQQueueInfo3_get_IsWorldReadable(This,pisWorldReadable)	\
    (This)->lpVtbl -> get_IsWorldReadable(This,pisWorldReadable)

#define IMSMQQueueInfo3_Create(This,IsTransactional,IsWorldReadable)	\
    (This)->lpVtbl -> Create(This,IsTransactional,IsWorldReadable)

#define IMSMQQueueInfo3_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IMSMQQueueInfo3_Open(This,Access,ShareMode,ppq)	\
    (This)->lpVtbl -> Open(This,Access,ShareMode,ppq)

#define IMSMQQueueInfo3_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IMSMQQueueInfo3_Update(This)	\
    (This)->lpVtbl -> Update(This)

#define IMSMQQueueInfo3_get_PathNameDNS(This,pbstrPathNameDNS)	\
    (This)->lpVtbl -> get_PathNameDNS(This,pbstrPathNameDNS)

#define IMSMQQueueInfo3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#define IMSMQQueueInfo3_get_Security(This,pvarSecurity)	\
    (This)->lpVtbl -> get_Security(This,pvarSecurity)

#define IMSMQQueueInfo3_put_Security(This,varSecurity)	\
    (This)->lpVtbl -> put_Security(This,varSecurity)

#define IMSMQQueueInfo3_get_IsTransactional2(This,pisTransactional)	\
    (This)->lpVtbl -> get_IsTransactional2(This,pisTransactional)

#define IMSMQQueueInfo3_get_IsWorldReadable2(This,pisWorldReadable)	\
    (This)->lpVtbl -> get_IsWorldReadable2(This,pisWorldReadable)

#define IMSMQQueueInfo3_get_MulticastAddress(This,pbstrMulticastAddress)	\
    (This)->lpVtbl -> get_MulticastAddress(This,pbstrMulticastAddress)

#define IMSMQQueueInfo3_put_MulticastAddress(This,bstrMulticastAddress)	\
    (This)->lpVtbl -> put_MulticastAddress(This,bstrMulticastAddress)

#define IMSMQQueueInfo3_get_ADsPath(This,pbstrADsPath)	\
    (This)->lpVtbl -> get_ADsPath(This,pbstrADsPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_QueueGuid_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrGuidQueue);


void __RPC_STUB IMSMQQueueInfo3_get_QueueGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_ServiceTypeGuid_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrGuidServiceType);


void __RPC_STUB IMSMQQueueInfo3_get_ServiceTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_ServiceTypeGuid_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ BSTR bstrGuidServiceType);


void __RPC_STUB IMSMQQueueInfo3_put_ServiceTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_Label_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrLabel);


void __RPC_STUB IMSMQQueueInfo3_get_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_Label_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ BSTR bstrLabel);


void __RPC_STUB IMSMQQueueInfo3_put_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_PathName_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrPathName);


void __RPC_STUB IMSMQQueueInfo3_get_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_PathName_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ BSTR bstrPathName);


void __RPC_STUB IMSMQQueueInfo3_put_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_FormatName_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrFormatName);


void __RPC_STUB IMSMQQueueInfo3_get_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_FormatName_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ BSTR bstrFormatName);


void __RPC_STUB IMSMQQueueInfo3_put_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_IsTransactional_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ Boolean *pisTransactional);


void __RPC_STUB IMSMQQueueInfo3_get_IsTransactional_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_PrivLevel_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ long *plPrivLevel);


void __RPC_STUB IMSMQQueueInfo3_get_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_PrivLevel_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long lPrivLevel);


void __RPC_STUB IMSMQQueueInfo3_put_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_Journal_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ long *plJournal);


void __RPC_STUB IMSMQQueueInfo3_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_Journal_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long lJournal);


void __RPC_STUB IMSMQQueueInfo3_put_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_Quota_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ long *plQuota);


void __RPC_STUB IMSMQQueueInfo3_get_Quota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_Quota_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long lQuota);


void __RPC_STUB IMSMQQueueInfo3_put_Quota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_BasePriority_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ long *plBasePriority);


void __RPC_STUB IMSMQQueueInfo3_get_BasePriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_BasePriority_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long lBasePriority);


void __RPC_STUB IMSMQQueueInfo3_put_BasePriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_CreateTime_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ VARIANT *pvarCreateTime);


void __RPC_STUB IMSMQQueueInfo3_get_CreateTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_ModifyTime_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ VARIANT *pvarModifyTime);


void __RPC_STUB IMSMQQueueInfo3_get_ModifyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_Authenticate_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ long *plAuthenticate);


void __RPC_STUB IMSMQQueueInfo3_get_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_Authenticate_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long lAuthenticate);


void __RPC_STUB IMSMQQueueInfo3_put_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_JournalQuota_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ long *plJournalQuota);


void __RPC_STUB IMSMQQueueInfo3_get_JournalQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_JournalQuota_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long lJournalQuota);


void __RPC_STUB IMSMQQueueInfo3_put_JournalQuota_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_IsWorldReadable_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ Boolean *pisWorldReadable);


void __RPC_STUB IMSMQQueueInfo3_get_IsWorldReadable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_Create_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [optional][in] */ VARIANT *IsTransactional,
    /* [optional][in] */ VARIANT *IsWorldReadable);


void __RPC_STUB IMSMQQueueInfo3_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_Delete_Proxy( 
    IMSMQQueueInfo3 * This);


void __RPC_STUB IMSMQQueueInfo3_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_Open_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ long Access,
    /* [in] */ long ShareMode,
    /* [retval][out] */ IMSMQQueue3 **ppq);


void __RPC_STUB IMSMQQueueInfo3_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_Refresh_Proxy( 
    IMSMQQueueInfo3 * This);


void __RPC_STUB IMSMQQueueInfo3_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_Update_Proxy( 
    IMSMQQueueInfo3 * This);


void __RPC_STUB IMSMQQueueInfo3_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_PathNameDNS_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrPathNameDNS);


void __RPC_STUB IMSMQQueueInfo3_get_PathNameDNS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_Properties_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQueueInfo3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_Security_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ VARIANT *pvarSecurity);


void __RPC_STUB IMSMQQueueInfo3_get_Security_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_Security_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ VARIANT varSecurity);


void __RPC_STUB IMSMQQueueInfo3_put_Security_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_IsTransactional2_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ VARIANT_BOOL *pisTransactional);


void __RPC_STUB IMSMQQueueInfo3_get_IsTransactional2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_IsWorldReadable2_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ VARIANT_BOOL *pisWorldReadable);


void __RPC_STUB IMSMQQueueInfo3_get_IsWorldReadable2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_MulticastAddress_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrMulticastAddress);


void __RPC_STUB IMSMQQueueInfo3_get_MulticastAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_put_MulticastAddress_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [in] */ BSTR bstrMulticastAddress);


void __RPC_STUB IMSMQQueueInfo3_put_MulticastAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfo3_get_ADsPath_Proxy( 
    IMSMQQueueInfo3 * This,
    /* [retval][out] */ BSTR *pbstrADsPath);


void __RPC_STUB IMSMQQueueInfo3_get_ADsPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueInfo3_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueue_INTERFACE_DEFINED__
#define __IMSMQQueue_INTERFACE_DEFINED__

/* interface IMSMQQueue */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E076-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQQueue : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Access( 
            /* [retval][out] */ long *plAccess) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ShareMode( 
            /* [retval][out] */ long *plShareMode) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfo) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ long *plHandle) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsOpen( 
            /* [retval][out] */ Boolean *pisOpen) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Receive( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Peek( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE EnableNotification( 
            /* [in] */ IMSMQEvent *Event,
            /* [optional][in] */ VARIANT *Cursor,
            /* [optional][in] */ VARIANT *ReceiveTimeout) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveCurrent( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekNext( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekCurrent( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueue * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueue * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Access )( 
            IMSMQQueue * This,
            /* [retval][out] */ long *plAccess);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ShareMode )( 
            IMSMQQueue * This,
            /* [retval][out] */ long *plShareMode);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueInfo )( 
            IMSMQQueue * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfo);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Handle )( 
            IMSMQQueue * This,
            /* [retval][out] */ long *plHandle);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen )( 
            IMSMQQueue * This,
            /* [retval][out] */ Boolean *pisOpen);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMSMQQueue * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Receive )( 
            IMSMQQueue * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Peek )( 
            IMSMQQueue * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *EnableNotification )( 
            IMSMQQueue * This,
            /* [in] */ IMSMQEvent *Event,
            /* [optional][in] */ VARIANT *Cursor,
            /* [optional][in] */ VARIANT *ReceiveTimeout);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMSMQQueue * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveCurrent )( 
            IMSMQQueue * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekNext )( 
            IMSMQQueue * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekCurrent )( 
            IMSMQQueue * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        END_INTERFACE
    } IMSMQQueueVtbl;

    interface IMSMQQueue
    {
        CONST_VTBL struct IMSMQQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueue_get_Access(This,plAccess)	\
    (This)->lpVtbl -> get_Access(This,plAccess)

#define IMSMQQueue_get_ShareMode(This,plShareMode)	\
    (This)->lpVtbl -> get_ShareMode(This,plShareMode)

#define IMSMQQueue_get_QueueInfo(This,ppqinfo)	\
    (This)->lpVtbl -> get_QueueInfo(This,ppqinfo)

#define IMSMQQueue_get_Handle(This,plHandle)	\
    (This)->lpVtbl -> get_Handle(This,plHandle)

#define IMSMQQueue_get_IsOpen(This,pisOpen)	\
    (This)->lpVtbl -> get_IsOpen(This,pisOpen)

#define IMSMQQueue_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IMSMQQueue_Receive(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> Receive(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue_Peek(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> Peek(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue_EnableNotification(This,Event,Cursor,ReceiveTimeout)	\
    (This)->lpVtbl -> EnableNotification(This,Event,Cursor,ReceiveTimeout)

#define IMSMQQueue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMSMQQueue_ReceiveCurrent(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> ReceiveCurrent(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue_PeekNext(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> PeekNext(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue_PeekCurrent(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> PeekCurrent(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_get_Access_Proxy( 
    IMSMQQueue * This,
    /* [retval][out] */ long *plAccess);


void __RPC_STUB IMSMQQueue_get_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_get_ShareMode_Proxy( 
    IMSMQQueue * This,
    /* [retval][out] */ long *plShareMode);


void __RPC_STUB IMSMQQueue_get_ShareMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_get_QueueInfo_Proxy( 
    IMSMQQueue * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfo);


void __RPC_STUB IMSMQQueue_get_QueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_get_Handle_Proxy( 
    IMSMQQueue * This,
    /* [retval][out] */ long *plHandle);


void __RPC_STUB IMSMQQueue_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_get_IsOpen_Proxy( 
    IMSMQQueue * This,
    /* [retval][out] */ Boolean *pisOpen);


void __RPC_STUB IMSMQQueue_get_IsOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_Close_Proxy( 
    IMSMQQueue * This);


void __RPC_STUB IMSMQQueue_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_Receive_Proxy( 
    IMSMQQueue * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_Peek_Proxy( 
    IMSMQQueue * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue_Peek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_EnableNotification_Proxy( 
    IMSMQQueue * This,
    /* [in] */ IMSMQEvent *Event,
    /* [optional][in] */ VARIANT *Cursor,
    /* [optional][in] */ VARIANT *ReceiveTimeout);


void __RPC_STUB IMSMQQueue_EnableNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_Reset_Proxy( 
    IMSMQQueue * This);


void __RPC_STUB IMSMQQueue_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_ReceiveCurrent_Proxy( 
    IMSMQQueue * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue_ReceiveCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_PeekNext_Proxy( 
    IMSMQQueue * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue_PeekNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue_PeekCurrent_Proxy( 
    IMSMQQueue * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue_PeekCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueue_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueue2_INTERFACE_DEFINED__
#define __IMSMQQueue2_INTERFACE_DEFINED__

/* interface IMSMQQueue2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF0574E0-06D8-11D3-B100-00E02C074F6B")
    IMSMQQueue2 : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Access( 
            /* [retval][out] */ long *plAccess) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ShareMode( 
            /* [retval][out] */ long *plShareMode) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfo) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ long *plHandle) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsOpen( 
            /* [retval][out] */ Boolean *pisOpen) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE Receive_v1( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE Peek_v1( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE EnableNotification( 
            /* [in] */ IMSMQEvent2 *Event,
            /* [optional][in] */ VARIANT *Cursor,
            /* [optional][in] */ VARIANT *ReceiveTimeout) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveCurrent_v1( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekNext_v1( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekCurrent_v1( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Receive( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Peek( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveCurrent( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekNext( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekCurrent( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueue2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueue2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueue2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueue2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Access )( 
            IMSMQQueue2 * This,
            /* [retval][out] */ long *plAccess);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ShareMode )( 
            IMSMQQueue2 * This,
            /* [retval][out] */ long *plShareMode);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueInfo )( 
            IMSMQQueue2 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfo);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Handle )( 
            IMSMQQueue2 * This,
            /* [retval][out] */ long *plHandle);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen )( 
            IMSMQQueue2 * This,
            /* [retval][out] */ Boolean *pisOpen);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMSMQQueue2 * This);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Receive_v1 )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Peek_v1 )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *EnableNotification )( 
            IMSMQQueue2 * This,
            /* [in] */ IMSMQEvent2 *Event,
            /* [optional][in] */ VARIANT *Cursor,
            /* [optional][in] */ VARIANT *ReceiveTimeout);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMSMQQueue2 * This);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveCurrent_v1 )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekNext_v1 )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekCurrent_v1 )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Receive )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Peek )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveCurrent )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekNext )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekCurrent )( 
            IMSMQQueue2 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage2 **ppmsg);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQueue2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQQueue2Vtbl;

    interface IMSMQQueue2
    {
        CONST_VTBL struct IMSMQQueue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueue2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueue2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueue2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueue2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueue2_get_Access(This,plAccess)	\
    (This)->lpVtbl -> get_Access(This,plAccess)

#define IMSMQQueue2_get_ShareMode(This,plShareMode)	\
    (This)->lpVtbl -> get_ShareMode(This,plShareMode)

#define IMSMQQueue2_get_QueueInfo(This,ppqinfo)	\
    (This)->lpVtbl -> get_QueueInfo(This,ppqinfo)

#define IMSMQQueue2_get_Handle(This,plHandle)	\
    (This)->lpVtbl -> get_Handle(This,plHandle)

#define IMSMQQueue2_get_IsOpen(This,pisOpen)	\
    (This)->lpVtbl -> get_IsOpen(This,pisOpen)

#define IMSMQQueue2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IMSMQQueue2_Receive_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> Receive_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue2_Peek_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> Peek_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue2_EnableNotification(This,Event,Cursor,ReceiveTimeout)	\
    (This)->lpVtbl -> EnableNotification(This,Event,Cursor,ReceiveTimeout)

#define IMSMQQueue2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMSMQQueue2_ReceiveCurrent_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> ReceiveCurrent_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue2_PeekNext_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> PeekNext_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue2_PeekCurrent_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> PeekCurrent_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue2_Receive(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> Receive(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue2_Peek(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> Peek(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue2_ReceiveCurrent(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceiveCurrent(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue2_PeekNext(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekNext(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue2_PeekCurrent(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekCurrent(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_get_Access_Proxy( 
    IMSMQQueue2 * This,
    /* [retval][out] */ long *plAccess);


void __RPC_STUB IMSMQQueue2_get_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_get_ShareMode_Proxy( 
    IMSMQQueue2 * This,
    /* [retval][out] */ long *plShareMode);


void __RPC_STUB IMSMQQueue2_get_ShareMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_get_QueueInfo_Proxy( 
    IMSMQQueue2 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfo);


void __RPC_STUB IMSMQQueue2_get_QueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_get_Handle_Proxy( 
    IMSMQQueue2 * This,
    /* [retval][out] */ long *plHandle);


void __RPC_STUB IMSMQQueue2_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_get_IsOpen_Proxy( 
    IMSMQQueue2 * This,
    /* [retval][out] */ Boolean *pisOpen);


void __RPC_STUB IMSMQQueue2_get_IsOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_Close_Proxy( 
    IMSMQQueue2 * This);


void __RPC_STUB IMSMQQueue2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_Receive_v1_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue2_Receive_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_Peek_v1_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue2_Peek_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_EnableNotification_Proxy( 
    IMSMQQueue2 * This,
    /* [in] */ IMSMQEvent2 *Event,
    /* [optional][in] */ VARIANT *Cursor,
    /* [optional][in] */ VARIANT *ReceiveTimeout);


void __RPC_STUB IMSMQQueue2_EnableNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_Reset_Proxy( 
    IMSMQQueue2 * This);


void __RPC_STUB IMSMQQueue2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_ReceiveCurrent_v1_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue2_ReceiveCurrent_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_PeekNext_v1_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue2_PeekNext_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_PeekCurrent_v1_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue2_PeekCurrent_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_Receive_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage2 **ppmsg);


void __RPC_STUB IMSMQQueue2_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_Peek_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage2 **ppmsg);


void __RPC_STUB IMSMQQueue2_Peek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_ReceiveCurrent_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage2 **ppmsg);


void __RPC_STUB IMSMQQueue2_ReceiveCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_PeekNext_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage2 **ppmsg);


void __RPC_STUB IMSMQQueue2_PeekNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_PeekCurrent_Proxy( 
    IMSMQQueue2 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage2 **ppmsg);


void __RPC_STUB IMSMQQueue2_PeekCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueue2_get_Properties_Proxy( 
    IMSMQQueue2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQueue2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueue2_INTERFACE_DEFINED__ */


#ifndef __IMSMQMessage_INTERFACE_DEFINED__
#define __IMSMQMessage_INTERFACE_DEFINED__

/* interface IMSMQMessage */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E074-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQMessage : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long *plClass) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivLevel( 
            /* [retval][out] */ long *plPrivLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PrivLevel( 
            /* [in] */ long lPrivLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthLevel( 
            /* [retval][out] */ long *plAuthLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthLevel( 
            /* [in] */ long lAuthLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated( 
            /* [retval][out] */ Boolean *pisAuthenticated) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Delivery( 
            /* [retval][out] */ long *plDelivery) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Delivery( 
            /* [in] */ long lDelivery) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Trace( 
            /* [retval][out] */ long *plTrace) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Trace( 
            /* [in] */ long lTrace) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *plPriority) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lPriority) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ long *plJournal) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Journal( 
            /* [in] */ long lJournal) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseQueueInfo( 
            /* [in] */ IMSMQQueueInfo *pqinfoResponse) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AppSpecific( 
            /* [retval][out] */ long *plAppSpecific) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AppSpecific( 
            /* [in] */ long lAppSpecific) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SourceMachineGuid( 
            /* [retval][out] */ BSTR *pbstrGuidSrcMachine) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BodyLength( 
            /* [retval][out] */ long *pcbBody) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Body( 
            /* [in] */ VARIANT varBody) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AdminQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_AdminQueueInfo( 
            /* [in] */ IMSMQQueueInfo *pqinfoAdmin) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ VARIANT *pvarMsgId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CorrelationId( 
            /* [retval][out] */ VARIANT *pvarMsgId) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_CorrelationId( 
            /* [in] */ VARIANT varMsgId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Ack( 
            /* [retval][out] */ long *plAck) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Ack( 
            /* [in] */ long lAck) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Label( 
            /* [retval][out] */ BSTR *pbstrLabel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Label( 
            /* [in] */ BSTR bstrLabel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MaxTimeToReachQueue( 
            /* [retval][out] */ long *plMaxTimeToReachQueue) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MaxTimeToReachQueue( 
            /* [in] */ long lMaxTimeToReachQueue) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MaxTimeToReceive( 
            /* [retval][out] */ long *plMaxTimeToReceive) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MaxTimeToReceive( 
            /* [in] */ long lMaxTimeToReceive) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ long *plHashAlg) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ long lHashAlg) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_EncryptAlgorithm( 
            /* [retval][out] */ long *plEncryptAlg) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_EncryptAlgorithm( 
            /* [in] */ long lEncryptAlg) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SentTime( 
            /* [retval][out] */ VARIANT *pvarSentTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ArrivedTime( 
            /* [retval][out] */ VARIANT *plArrivedTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_DestinationQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoDest) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderCertificate( 
            /* [retval][out] */ VARIANT *pvarSenderCert) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderCertificate( 
            /* [in] */ VARIANT varSenderCert) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderId( 
            /* [retval][out] */ VARIANT *pvarSenderId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderIdType( 
            /* [retval][out] */ long *plSenderIdType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderIdType( 
            /* [in] */ long lSenderIdType) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [in] */ IMSMQQueue *DestinationQueue,
            /* [optional][in] */ VARIANT *Transaction) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE AttachCurrentSecurityContext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plClass);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivLevel )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plPrivLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PrivLevel )( 
            IMSMQMessage * This,
            /* [in] */ long lPrivLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthLevel )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plAuthLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthLevel )( 
            IMSMQMessage * This,
            /* [in] */ long lAuthLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IMSMQMessage * This,
            /* [retval][out] */ Boolean *pisAuthenticated);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Delivery )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plDelivery);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Delivery )( 
            IMSMQMessage * This,
            /* [in] */ long lDelivery);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Trace )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plTrace);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Trace )( 
            IMSMQMessage * This,
            /* [in] */ long lTrace);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plPriority);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IMSMQMessage * This,
            /* [in] */ long lPriority);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Journal )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plJournal);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Journal )( 
            IMSMQMessage * This,
            /* [in] */ long lJournal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseQueueInfo )( 
            IMSMQMessage * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseQueueInfo )( 
            IMSMQMessage * This,
            /* [in] */ IMSMQQueueInfo *pqinfoResponse);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AppSpecific )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plAppSpecific);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AppSpecific )( 
            IMSMQMessage * This,
            /* [in] */ long lAppSpecific);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SourceMachineGuid )( 
            IMSMQMessage * This,
            /* [retval][out] */ BSTR *pbstrGuidSrcMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BodyLength )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *pcbBody);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Body )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Body )( 
            IMSMQMessage * This,
            /* [in] */ VARIANT varBody);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AdminQueueInfo )( 
            IMSMQMessage * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_AdminQueueInfo )( 
            IMSMQMessage * This,
            /* [in] */ IMSMQQueueInfo *pqinfoAdmin);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *pvarMsgId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CorrelationId )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *pvarMsgId);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_CorrelationId )( 
            IMSMQMessage * This,
            /* [in] */ VARIANT varMsgId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Ack )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plAck);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Ack )( 
            IMSMQMessage * This,
            /* [in] */ long lAck);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Label )( 
            IMSMQMessage * This,
            /* [retval][out] */ BSTR *pbstrLabel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Label )( 
            IMSMQMessage * This,
            /* [in] */ BSTR bstrLabel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTimeToReachQueue )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plMaxTimeToReachQueue);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTimeToReachQueue )( 
            IMSMQMessage * This,
            /* [in] */ long lMaxTimeToReachQueue);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTimeToReceive )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plMaxTimeToReceive);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTimeToReceive )( 
            IMSMQMessage * This,
            /* [in] */ long lMaxTimeToReceive);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plHashAlg);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IMSMQMessage * This,
            /* [in] */ long lHashAlg);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptAlgorithm )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plEncryptAlg);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptAlgorithm )( 
            IMSMQMessage * This,
            /* [in] */ long lEncryptAlg);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SentTime )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *pvarSentTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ArrivedTime )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *plArrivedTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationQueueInfo )( 
            IMSMQMessage * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoDest);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCertificate )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *pvarSenderCert);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderCertificate )( 
            IMSMQMessage * This,
            /* [in] */ VARIANT varSenderCert);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderId )( 
            IMSMQMessage * This,
            /* [retval][out] */ VARIANT *pvarSenderId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderIdType )( 
            IMSMQMessage * This,
            /* [retval][out] */ long *plSenderIdType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderIdType )( 
            IMSMQMessage * This,
            /* [in] */ long lSenderIdType);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IMSMQMessage * This,
            /* [in] */ IMSMQQueue *DestinationQueue,
            /* [optional][in] */ VARIANT *Transaction);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *AttachCurrentSecurityContext )( 
            IMSMQMessage * This);
        
        END_INTERFACE
    } IMSMQMessageVtbl;

    interface IMSMQMessage
    {
        CONST_VTBL struct IMSMQMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQMessage_get_Class(This,plClass)	\
    (This)->lpVtbl -> get_Class(This,plClass)

#define IMSMQMessage_get_PrivLevel(This,plPrivLevel)	\
    (This)->lpVtbl -> get_PrivLevel(This,plPrivLevel)

#define IMSMQMessage_put_PrivLevel(This,lPrivLevel)	\
    (This)->lpVtbl -> put_PrivLevel(This,lPrivLevel)

#define IMSMQMessage_get_AuthLevel(This,plAuthLevel)	\
    (This)->lpVtbl -> get_AuthLevel(This,plAuthLevel)

#define IMSMQMessage_put_AuthLevel(This,lAuthLevel)	\
    (This)->lpVtbl -> put_AuthLevel(This,lAuthLevel)

#define IMSMQMessage_get_IsAuthenticated(This,pisAuthenticated)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,pisAuthenticated)

#define IMSMQMessage_get_Delivery(This,plDelivery)	\
    (This)->lpVtbl -> get_Delivery(This,plDelivery)

#define IMSMQMessage_put_Delivery(This,lDelivery)	\
    (This)->lpVtbl -> put_Delivery(This,lDelivery)

#define IMSMQMessage_get_Trace(This,plTrace)	\
    (This)->lpVtbl -> get_Trace(This,plTrace)

#define IMSMQMessage_put_Trace(This,lTrace)	\
    (This)->lpVtbl -> put_Trace(This,lTrace)

#define IMSMQMessage_get_Priority(This,plPriority)	\
    (This)->lpVtbl -> get_Priority(This,plPriority)

#define IMSMQMessage_put_Priority(This,lPriority)	\
    (This)->lpVtbl -> put_Priority(This,lPriority)

#define IMSMQMessage_get_Journal(This,plJournal)	\
    (This)->lpVtbl -> get_Journal(This,plJournal)

#define IMSMQMessage_put_Journal(This,lJournal)	\
    (This)->lpVtbl -> put_Journal(This,lJournal)

#define IMSMQMessage_get_ResponseQueueInfo(This,ppqinfoResponse)	\
    (This)->lpVtbl -> get_ResponseQueueInfo(This,ppqinfoResponse)

#define IMSMQMessage_putref_ResponseQueueInfo(This,pqinfoResponse)	\
    (This)->lpVtbl -> putref_ResponseQueueInfo(This,pqinfoResponse)

#define IMSMQMessage_get_AppSpecific(This,plAppSpecific)	\
    (This)->lpVtbl -> get_AppSpecific(This,plAppSpecific)

#define IMSMQMessage_put_AppSpecific(This,lAppSpecific)	\
    (This)->lpVtbl -> put_AppSpecific(This,lAppSpecific)

#define IMSMQMessage_get_SourceMachineGuid(This,pbstrGuidSrcMachine)	\
    (This)->lpVtbl -> get_SourceMachineGuid(This,pbstrGuidSrcMachine)

#define IMSMQMessage_get_BodyLength(This,pcbBody)	\
    (This)->lpVtbl -> get_BodyLength(This,pcbBody)

#define IMSMQMessage_get_Body(This,pvarBody)	\
    (This)->lpVtbl -> get_Body(This,pvarBody)

#define IMSMQMessage_put_Body(This,varBody)	\
    (This)->lpVtbl -> put_Body(This,varBody)

#define IMSMQMessage_get_AdminQueueInfo(This,ppqinfoAdmin)	\
    (This)->lpVtbl -> get_AdminQueueInfo(This,ppqinfoAdmin)

#define IMSMQMessage_putref_AdminQueueInfo(This,pqinfoAdmin)	\
    (This)->lpVtbl -> putref_AdminQueueInfo(This,pqinfoAdmin)

#define IMSMQMessage_get_Id(This,pvarMsgId)	\
    (This)->lpVtbl -> get_Id(This,pvarMsgId)

#define IMSMQMessage_get_CorrelationId(This,pvarMsgId)	\
    (This)->lpVtbl -> get_CorrelationId(This,pvarMsgId)

#define IMSMQMessage_put_CorrelationId(This,varMsgId)	\
    (This)->lpVtbl -> put_CorrelationId(This,varMsgId)

#define IMSMQMessage_get_Ack(This,plAck)	\
    (This)->lpVtbl -> get_Ack(This,plAck)

#define IMSMQMessage_put_Ack(This,lAck)	\
    (This)->lpVtbl -> put_Ack(This,lAck)

#define IMSMQMessage_get_Label(This,pbstrLabel)	\
    (This)->lpVtbl -> get_Label(This,pbstrLabel)

#define IMSMQMessage_put_Label(This,bstrLabel)	\
    (This)->lpVtbl -> put_Label(This,bstrLabel)

#define IMSMQMessage_get_MaxTimeToReachQueue(This,plMaxTimeToReachQueue)	\
    (This)->lpVtbl -> get_MaxTimeToReachQueue(This,plMaxTimeToReachQueue)

#define IMSMQMessage_put_MaxTimeToReachQueue(This,lMaxTimeToReachQueue)	\
    (This)->lpVtbl -> put_MaxTimeToReachQueue(This,lMaxTimeToReachQueue)

#define IMSMQMessage_get_MaxTimeToReceive(This,plMaxTimeToReceive)	\
    (This)->lpVtbl -> get_MaxTimeToReceive(This,plMaxTimeToReceive)

#define IMSMQMessage_put_MaxTimeToReceive(This,lMaxTimeToReceive)	\
    (This)->lpVtbl -> put_MaxTimeToReceive(This,lMaxTimeToReceive)

#define IMSMQMessage_get_HashAlgorithm(This,plHashAlg)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,plHashAlg)

#define IMSMQMessage_put_HashAlgorithm(This,lHashAlg)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,lHashAlg)

#define IMSMQMessage_get_EncryptAlgorithm(This,plEncryptAlg)	\
    (This)->lpVtbl -> get_EncryptAlgorithm(This,plEncryptAlg)

#define IMSMQMessage_put_EncryptAlgorithm(This,lEncryptAlg)	\
    (This)->lpVtbl -> put_EncryptAlgorithm(This,lEncryptAlg)

#define IMSMQMessage_get_SentTime(This,pvarSentTime)	\
    (This)->lpVtbl -> get_SentTime(This,pvarSentTime)

#define IMSMQMessage_get_ArrivedTime(This,plArrivedTime)	\
    (This)->lpVtbl -> get_ArrivedTime(This,plArrivedTime)

#define IMSMQMessage_get_DestinationQueueInfo(This,ppqinfoDest)	\
    (This)->lpVtbl -> get_DestinationQueueInfo(This,ppqinfoDest)

#define IMSMQMessage_get_SenderCertificate(This,pvarSenderCert)	\
    (This)->lpVtbl -> get_SenderCertificate(This,pvarSenderCert)

#define IMSMQMessage_put_SenderCertificate(This,varSenderCert)	\
    (This)->lpVtbl -> put_SenderCertificate(This,varSenderCert)

#define IMSMQMessage_get_SenderId(This,pvarSenderId)	\
    (This)->lpVtbl -> get_SenderId(This,pvarSenderId)

#define IMSMQMessage_get_SenderIdType(This,plSenderIdType)	\
    (This)->lpVtbl -> get_SenderIdType(This,plSenderIdType)

#define IMSMQMessage_put_SenderIdType(This,lSenderIdType)	\
    (This)->lpVtbl -> put_SenderIdType(This,lSenderIdType)

#define IMSMQMessage_Send(This,DestinationQueue,Transaction)	\
    (This)->lpVtbl -> Send(This,DestinationQueue,Transaction)

#define IMSMQMessage_AttachCurrentSecurityContext(This)	\
    (This)->lpVtbl -> AttachCurrentSecurityContext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Class_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plClass);


void __RPC_STUB IMSMQMessage_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_PrivLevel_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plPrivLevel);


void __RPC_STUB IMSMQMessage_get_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_PrivLevel_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lPrivLevel);


void __RPC_STUB IMSMQMessage_put_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_AuthLevel_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plAuthLevel);


void __RPC_STUB IMSMQMessage_get_AuthLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_AuthLevel_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lAuthLevel);


void __RPC_STUB IMSMQMessage_put_AuthLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_IsAuthenticated_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ Boolean *pisAuthenticated);


void __RPC_STUB IMSMQMessage_get_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Delivery_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plDelivery);


void __RPC_STUB IMSMQMessage_get_Delivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Delivery_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lDelivery);


void __RPC_STUB IMSMQMessage_put_Delivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Trace_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plTrace);


void __RPC_STUB IMSMQMessage_get_Trace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Trace_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lTrace);


void __RPC_STUB IMSMQMessage_put_Trace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Priority_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plPriority);


void __RPC_STUB IMSMQMessage_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Priority_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lPriority);


void __RPC_STUB IMSMQMessage_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Journal_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plJournal);


void __RPC_STUB IMSMQMessage_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Journal_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lJournal);


void __RPC_STUB IMSMQMessage_put_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_ResponseQueueInfo_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse);


void __RPC_STUB IMSMQMessage_get_ResponseQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_putref_ResponseQueueInfo_Proxy( 
    IMSMQMessage * This,
    /* [in] */ IMSMQQueueInfo *pqinfoResponse);


void __RPC_STUB IMSMQMessage_putref_ResponseQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_AppSpecific_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plAppSpecific);


void __RPC_STUB IMSMQMessage_get_AppSpecific_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_AppSpecific_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lAppSpecific);


void __RPC_STUB IMSMQMessage_put_AppSpecific_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_SourceMachineGuid_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ BSTR *pbstrGuidSrcMachine);


void __RPC_STUB IMSMQMessage_get_SourceMachineGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_BodyLength_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *pcbBody);


void __RPC_STUB IMSMQMessage_get_BodyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Body_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IMSMQMessage_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Body_Proxy( 
    IMSMQMessage * This,
    /* [in] */ VARIANT varBody);


void __RPC_STUB IMSMQMessage_put_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_AdminQueueInfo_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin);


void __RPC_STUB IMSMQMessage_get_AdminQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_putref_AdminQueueInfo_Proxy( 
    IMSMQMessage * This,
    /* [in] */ IMSMQQueueInfo *pqinfoAdmin);


void __RPC_STUB IMSMQMessage_putref_AdminQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Id_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *pvarMsgId);


void __RPC_STUB IMSMQMessage_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_CorrelationId_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *pvarMsgId);


void __RPC_STUB IMSMQMessage_get_CorrelationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_CorrelationId_Proxy( 
    IMSMQMessage * This,
    /* [in] */ VARIANT varMsgId);


void __RPC_STUB IMSMQMessage_put_CorrelationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Ack_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plAck);


void __RPC_STUB IMSMQMessage_get_Ack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Ack_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lAck);


void __RPC_STUB IMSMQMessage_put_Ack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_Label_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ BSTR *pbstrLabel);


void __RPC_STUB IMSMQMessage_get_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_Label_Proxy( 
    IMSMQMessage * This,
    /* [in] */ BSTR bstrLabel);


void __RPC_STUB IMSMQMessage_put_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_MaxTimeToReachQueue_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plMaxTimeToReachQueue);


void __RPC_STUB IMSMQMessage_get_MaxTimeToReachQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_MaxTimeToReachQueue_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lMaxTimeToReachQueue);


void __RPC_STUB IMSMQMessage_put_MaxTimeToReachQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_MaxTimeToReceive_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plMaxTimeToReceive);


void __RPC_STUB IMSMQMessage_get_MaxTimeToReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_MaxTimeToReceive_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lMaxTimeToReceive);


void __RPC_STUB IMSMQMessage_put_MaxTimeToReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_HashAlgorithm_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plHashAlg);


void __RPC_STUB IMSMQMessage_get_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_HashAlgorithm_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lHashAlg);


void __RPC_STUB IMSMQMessage_put_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_EncryptAlgorithm_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plEncryptAlg);


void __RPC_STUB IMSMQMessage_get_EncryptAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_EncryptAlgorithm_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lEncryptAlg);


void __RPC_STUB IMSMQMessage_put_EncryptAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_SentTime_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *pvarSentTime);


void __RPC_STUB IMSMQMessage_get_SentTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_ArrivedTime_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *plArrivedTime);


void __RPC_STUB IMSMQMessage_get_ArrivedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_DestinationQueueInfo_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoDest);


void __RPC_STUB IMSMQMessage_get_DestinationQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_SenderCertificate_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *pvarSenderCert);


void __RPC_STUB IMSMQMessage_get_SenderCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_SenderCertificate_Proxy( 
    IMSMQMessage * This,
    /* [in] */ VARIANT varSenderCert);


void __RPC_STUB IMSMQMessage_put_SenderCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_SenderId_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ VARIANT *pvarSenderId);


void __RPC_STUB IMSMQMessage_get_SenderId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_get_SenderIdType_Proxy( 
    IMSMQMessage * This,
    /* [retval][out] */ long *plSenderIdType);


void __RPC_STUB IMSMQMessage_get_SenderIdType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_put_SenderIdType_Proxy( 
    IMSMQMessage * This,
    /* [in] */ long lSenderIdType);


void __RPC_STUB IMSMQMessage_put_SenderIdType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_Send_Proxy( 
    IMSMQMessage * This,
    /* [in] */ IMSMQQueue *DestinationQueue,
    /* [optional][in] */ VARIANT *Transaction);


void __RPC_STUB IMSMQMessage_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage_AttachCurrentSecurityContext_Proxy( 
    IMSMQMessage * This);


void __RPC_STUB IMSMQMessage_AttachCurrentSecurityContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQMessage_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueueInfos_INTERFACE_DEFINED__
#define __IMSMQQueueInfos_INTERFACE_DEFINED__

/* interface IMSMQQueueInfos */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueInfos;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E07D-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQQueueInfos : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoNext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueInfosVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueInfos * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueInfos * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueInfos * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueInfos * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueInfos * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueInfos * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueInfos * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMSMQQueueInfos * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IMSMQQueueInfos * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoNext);
        
        END_INTERFACE
    } IMSMQQueueInfosVtbl;

    interface IMSMQQueueInfos
    {
        CONST_VTBL struct IMSMQQueueInfosVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueInfos_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueInfos_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueInfos_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueInfos_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueInfos_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueInfos_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueInfos_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueInfos_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMSMQQueueInfos_Next(This,ppqinfoNext)	\
    (This)->lpVtbl -> Next(This,ppqinfoNext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos_Reset_Proxy( 
    IMSMQQueueInfos * This);


void __RPC_STUB IMSMQQueueInfos_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos_Next_Proxy( 
    IMSMQQueueInfos * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoNext);


void __RPC_STUB IMSMQQueueInfos_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueInfos_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueueInfos2_INTERFACE_DEFINED__
#define __IMSMQQueueInfos2_INTERFACE_DEFINED__

/* interface IMSMQQueueInfos2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueInfos2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b0f-2168-11d3-898c-00e02c074f6b")
    IMSMQQueueInfos2 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoNext) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueInfos2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueInfos2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueInfos2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueInfos2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueInfos2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueInfos2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueInfos2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueInfos2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMSMQQueueInfos2 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IMSMQQueueInfos2 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoNext);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQueueInfos2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQQueueInfos2Vtbl;

    interface IMSMQQueueInfos2
    {
        CONST_VTBL struct IMSMQQueueInfos2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueInfos2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueInfos2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueInfos2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueInfos2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueInfos2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueInfos2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueInfos2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueInfos2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMSMQQueueInfos2_Next(This,ppqinfoNext)	\
    (This)->lpVtbl -> Next(This,ppqinfoNext)

#define IMSMQQueueInfos2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos2_Reset_Proxy( 
    IMSMQQueueInfos2 * This);


void __RPC_STUB IMSMQQueueInfos2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos2_Next_Proxy( 
    IMSMQQueueInfos2 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoNext);


void __RPC_STUB IMSMQQueueInfos2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos2_get_Properties_Proxy( 
    IMSMQQueueInfos2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQueueInfos2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueInfos2_INTERFACE_DEFINED__ */


#ifndef __IMSMQQueueInfos3_INTERFACE_DEFINED__
#define __IMSMQQueueInfos3_INTERFACE_DEFINED__

/* interface IMSMQQueueInfos3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueInfos3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b1e-2168-11d3-898c-00e02c074f6b")
    IMSMQQueueInfos3 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoNext) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueInfos3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueInfos3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueInfos3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueInfos3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueInfos3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueInfos3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueInfos3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueInfos3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMSMQQueueInfos3 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IMSMQQueueInfos3 * This,
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoNext);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQueueInfos3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQQueueInfos3Vtbl;

    interface IMSMQQueueInfos3
    {
        CONST_VTBL struct IMSMQQueueInfos3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueInfos3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueInfos3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueInfos3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueInfos3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueInfos3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueInfos3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueInfos3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueInfos3_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMSMQQueueInfos3_Next(This,ppqinfoNext)	\
    (This)->lpVtbl -> Next(This,ppqinfoNext)

#define IMSMQQueueInfos3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos3_Reset_Proxy( 
    IMSMQQueueInfos3 * This);


void __RPC_STUB IMSMQQueueInfos3_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos3_Next_Proxy( 
    IMSMQQueueInfos3 * This,
    /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoNext);


void __RPC_STUB IMSMQQueueInfos3_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueInfos3_get_Properties_Proxy( 
    IMSMQQueueInfos3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQueueInfos3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueInfos3_INTERFACE_DEFINED__ */


#ifndef __IMSMQEvent_INTERFACE_DEFINED__
#define __IMSMQEvent_INTERFACE_DEFINED__

/* interface IMSMQEvent */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E077-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQEvent : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSMQEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IMSMQEventVtbl;

    interface IMSMQEvent
    {
        CONST_VTBL struct IMSMQEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSMQEvent_INTERFACE_DEFINED__ */


#ifndef __IMSMQEvent2_INTERFACE_DEFINED__
#define __IMSMQEvent2_INTERFACE_DEFINED__

/* interface IMSMQEvent2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b12-2168-11d3-898c-00e02c074f6b")
    IMSMQEvent2 : public IMSMQEvent
    {
    public:
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQEvent2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQEvent2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQEvent2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQEvent2Vtbl;

    interface IMSMQEvent2
    {
        CONST_VTBL struct IMSMQEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQEvent2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSMQEvent2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQEvent2_get_Properties_Proxy( 
    IMSMQEvent2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQEvent2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQEvent2_INTERFACE_DEFINED__ */


#ifndef __IMSMQEvent3_INTERFACE_DEFINED__
#define __IMSMQEvent3_INTERFACE_DEFINED__

/* interface IMSMQEvent3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQEvent3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b1c-2168-11d3-898c-00e02c074f6b")
    IMSMQEvent3 : public IMSMQEvent2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSMQEvent3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQEvent3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQEvent3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQEvent3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQEvent3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQEvent3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQEvent3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQEvent3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQEvent3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQEvent3Vtbl;

    interface IMSMQEvent3
    {
        CONST_VTBL struct IMSMQEvent3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQEvent3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQEvent3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQEvent3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQEvent3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQEvent3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQEvent3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQEvent3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSMQEvent3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSMQEvent3_INTERFACE_DEFINED__ */


#ifndef __IMSMQTransaction_INTERFACE_DEFINED__
#define __IMSMQTransaction_INTERFACE_DEFINED__

/* interface IMSMQTransaction */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQTransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E07F-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQTransaction : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Transaction( 
            /* [retval][out] */ long *plTransaction) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Commit( 
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *grfTC,
            /* [optional][in] */ VARIANT *grfRM) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Abort( 
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *fAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQTransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQTransaction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQTransaction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQTransaction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQTransaction * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQTransaction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQTransaction * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQTransaction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Transaction )( 
            IMSMQTransaction * This,
            /* [retval][out] */ long *plTransaction);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMSMQTransaction * This,
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *grfTC,
            /* [optional][in] */ VARIANT *grfRM);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IMSMQTransaction * This,
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *fAsync);
        
        END_INTERFACE
    } IMSMQTransactionVtbl;

    interface IMSMQTransaction
    {
        CONST_VTBL struct IMSMQTransactionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQTransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQTransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQTransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQTransaction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQTransaction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQTransaction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQTransaction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQTransaction_get_Transaction(This,plTransaction)	\
    (This)->lpVtbl -> get_Transaction(This,plTransaction)

#define IMSMQTransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define IMSMQTransaction_Abort(This,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,fRetaining,fAsync)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransaction_get_Transaction_Proxy( 
    IMSMQTransaction * This,
    /* [retval][out] */ long *plTransaction);


void __RPC_STUB IMSMQTransaction_get_Transaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransaction_Commit_Proxy( 
    IMSMQTransaction * This,
    /* [optional][in] */ VARIANT *fRetaining,
    /* [optional][in] */ VARIANT *grfTC,
    /* [optional][in] */ VARIANT *grfRM);


void __RPC_STUB IMSMQTransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransaction_Abort_Proxy( 
    IMSMQTransaction * This,
    /* [optional][in] */ VARIANT *fRetaining,
    /* [optional][in] */ VARIANT *fAsync);


void __RPC_STUB IMSMQTransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQTransaction_INTERFACE_DEFINED__ */


#ifndef __IMSMQCoordinatedTransactionDispenser_INTERFACE_DEFINED__
#define __IMSMQCoordinatedTransactionDispenser_INTERFACE_DEFINED__

/* interface IMSMQCoordinatedTransactionDispenser */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQCoordinatedTransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E081-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQCoordinatedTransactionDispenser : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [retval][out] */ IMSMQTransaction **ptransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQCoordinatedTransactionDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQCoordinatedTransactionDispenser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQCoordinatedTransactionDispenser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQCoordinatedTransactionDispenser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQCoordinatedTransactionDispenser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQCoordinatedTransactionDispenser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQCoordinatedTransactionDispenser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQCoordinatedTransactionDispenser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IMSMQCoordinatedTransactionDispenser * This,
            /* [retval][out] */ IMSMQTransaction **ptransaction);
        
        END_INTERFACE
    } IMSMQCoordinatedTransactionDispenserVtbl;

    interface IMSMQCoordinatedTransactionDispenser
    {
        CONST_VTBL struct IMSMQCoordinatedTransactionDispenserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQCoordinatedTransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQCoordinatedTransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQCoordinatedTransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQCoordinatedTransactionDispenser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQCoordinatedTransactionDispenser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQCoordinatedTransactionDispenser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQCoordinatedTransactionDispenser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQCoordinatedTransactionDispenser_BeginTransaction(This,ptransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,ptransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQCoordinatedTransactionDispenser_BeginTransaction_Proxy( 
    IMSMQCoordinatedTransactionDispenser * This,
    /* [retval][out] */ IMSMQTransaction **ptransaction);


void __RPC_STUB IMSMQCoordinatedTransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQCoordinatedTransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __IMSMQTransactionDispenser_INTERFACE_DEFINED__
#define __IMSMQTransactionDispenser_INTERFACE_DEFINED__

/* interface IMSMQTransactionDispenser */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQTransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E083-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQTransactionDispenser : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [retval][out] */ IMSMQTransaction **ptransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQTransactionDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQTransactionDispenser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQTransactionDispenser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQTransactionDispenser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQTransactionDispenser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQTransactionDispenser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQTransactionDispenser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQTransactionDispenser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IMSMQTransactionDispenser * This,
            /* [retval][out] */ IMSMQTransaction **ptransaction);
        
        END_INTERFACE
    } IMSMQTransactionDispenserVtbl;

    interface IMSMQTransactionDispenser
    {
        CONST_VTBL struct IMSMQTransactionDispenserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQTransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQTransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQTransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQTransactionDispenser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQTransactionDispenser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQTransactionDispenser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQTransactionDispenser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQTransactionDispenser_BeginTransaction(This,ptransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,ptransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransactionDispenser_BeginTransaction_Proxy( 
    IMSMQTransactionDispenser * This,
    /* [retval][out] */ IMSMQTransaction **ptransaction);


void __RPC_STUB IMSMQTransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQTransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __IMSMQQuery2_INTERFACE_DEFINED__
#define __IMSMQQuery2_INTERFACE_DEFINED__

/* interface IMSMQQuery2 */
/* [object][nonextensible][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQuery2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b0e-2168-11d3-898c-00e02c074f6b")
    IMSMQQuery2 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE LookupQueue( 
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [retval][out] */ IMSMQQueueInfos2 **ppqinfos) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQuery2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQuery2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQuery2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQuery2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQuery2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQuery2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQuery2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQuery2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *LookupQueue )( 
            IMSMQQuery2 * This,
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [retval][out] */ IMSMQQueueInfos2 **ppqinfos);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQuery2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQQuery2Vtbl;

    interface IMSMQQuery2
    {
        CONST_VTBL struct IMSMQQuery2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQuery2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQuery2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQuery2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQuery2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQuery2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQuery2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQuery2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQuery2_LookupQueue(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,ppqinfos)	\
    (This)->lpVtbl -> LookupQueue(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,ppqinfos)

#define IMSMQQuery2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQuery2_LookupQueue_Proxy( 
    IMSMQQuery2 * This,
    /* [optional][in] */ VARIANT *QueueGuid,
    /* [optional][in] */ VARIANT *ServiceTypeGuid,
    /* [optional][in] */ VARIANT *Label,
    /* [optional][in] */ VARIANT *CreateTime,
    /* [optional][in] */ VARIANT *ModifyTime,
    /* [optional][in] */ VARIANT *RelServiceType,
    /* [optional][in] */ VARIANT *RelLabel,
    /* [optional][in] */ VARIANT *RelCreateTime,
    /* [optional][in] */ VARIANT *RelModifyTime,
    /* [retval][out] */ IMSMQQueueInfos2 **ppqinfos);


void __RPC_STUB IMSMQQuery2_LookupQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQuery2_get_Properties_Proxy( 
    IMSMQQuery2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQuery2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQuery2_INTERFACE_DEFINED__ */


#ifndef __IMSMQQuery3_INTERFACE_DEFINED__
#define __IMSMQQuery3_INTERFACE_DEFINED__

/* interface IMSMQQuery3 */
/* [object][nonextensible][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQuery3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b19-2168-11d3-898c-00e02c074f6b")
    IMSMQQuery3 : public IDispatch
    {
    public:
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE LookupQueue_v2( 
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [retval][out] */ IMSMQQueueInfos3 **ppqinfos) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE LookupQueue( 
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [optional][in] */ VARIANT *MulticastAddress,
            /* [optional][in] */ VARIANT *RelMulticastAddress,
            /* [retval][out] */ IMSMQQueueInfos3 **ppqinfos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQuery3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQuery3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQuery3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQuery3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQuery3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQuery3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQuery3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQuery3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *LookupQueue_v2 )( 
            IMSMQQuery3 * This,
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [retval][out] */ IMSMQQueueInfos3 **ppqinfos);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQuery3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *LookupQueue )( 
            IMSMQQuery3 * This,
            /* [optional][in] */ VARIANT *QueueGuid,
            /* [optional][in] */ VARIANT *ServiceTypeGuid,
            /* [optional][in] */ VARIANT *Label,
            /* [optional][in] */ VARIANT *CreateTime,
            /* [optional][in] */ VARIANT *ModifyTime,
            /* [optional][in] */ VARIANT *RelServiceType,
            /* [optional][in] */ VARIANT *RelLabel,
            /* [optional][in] */ VARIANT *RelCreateTime,
            /* [optional][in] */ VARIANT *RelModifyTime,
            /* [optional][in] */ VARIANT *MulticastAddress,
            /* [optional][in] */ VARIANT *RelMulticastAddress,
            /* [retval][out] */ IMSMQQueueInfos3 **ppqinfos);
        
        END_INTERFACE
    } IMSMQQuery3Vtbl;

    interface IMSMQQuery3
    {
        CONST_VTBL struct IMSMQQuery3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQuery3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQuery3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQuery3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQuery3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQuery3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQuery3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQuery3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQuery3_LookupQueue_v2(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,ppqinfos)	\
    (This)->lpVtbl -> LookupQueue_v2(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,ppqinfos)

#define IMSMQQuery3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#define IMSMQQuery3_LookupQueue(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,MulticastAddress,RelMulticastAddress,ppqinfos)	\
    (This)->lpVtbl -> LookupQueue(This,QueueGuid,ServiceTypeGuid,Label,CreateTime,ModifyTime,RelServiceType,RelLabel,RelCreateTime,RelModifyTime,MulticastAddress,RelMulticastAddress,ppqinfos)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQuery3_LookupQueue_v2_Proxy( 
    IMSMQQuery3 * This,
    /* [optional][in] */ VARIANT *QueueGuid,
    /* [optional][in] */ VARIANT *ServiceTypeGuid,
    /* [optional][in] */ VARIANT *Label,
    /* [optional][in] */ VARIANT *CreateTime,
    /* [optional][in] */ VARIANT *ModifyTime,
    /* [optional][in] */ VARIANT *RelServiceType,
    /* [optional][in] */ VARIANT *RelLabel,
    /* [optional][in] */ VARIANT *RelCreateTime,
    /* [optional][in] */ VARIANT *RelModifyTime,
    /* [retval][out] */ IMSMQQueueInfos3 **ppqinfos);


void __RPC_STUB IMSMQQuery3_LookupQueue_v2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQuery3_get_Properties_Proxy( 
    IMSMQQuery3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQuery3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQuery3_LookupQueue_Proxy( 
    IMSMQQuery3 * This,
    /* [optional][in] */ VARIANT *QueueGuid,
    /* [optional][in] */ VARIANT *ServiceTypeGuid,
    /* [optional][in] */ VARIANT *Label,
    /* [optional][in] */ VARIANT *CreateTime,
    /* [optional][in] */ VARIANT *ModifyTime,
    /* [optional][in] */ VARIANT *RelServiceType,
    /* [optional][in] */ VARIANT *RelLabel,
    /* [optional][in] */ VARIANT *RelCreateTime,
    /* [optional][in] */ VARIANT *RelModifyTime,
    /* [optional][in] */ VARIANT *MulticastAddress,
    /* [optional][in] */ VARIANT *RelMulticastAddress,
    /* [retval][out] */ IMSMQQueueInfos3 **ppqinfos);


void __RPC_STUB IMSMQQuery3_LookupQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQuery3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQQuery;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E073-DCCD-11d0-AA4B-0060970DEBAE")
MSMQQuery;
#endif

#ifndef __IMSMQMessage2_INTERFACE_DEFINED__
#define __IMSMQMessage2_INTERFACE_DEFINED__

/* interface IMSMQMessage2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQMessage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9933BE0-A567-11D2-B0F3-00E02C074F6B")
    IMSMQMessage2 : public IDispatch
    {
    public:
        virtual /* [id][propget][hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long *plClass) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivLevel( 
            /* [retval][out] */ long *plPrivLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PrivLevel( 
            /* [in] */ long lPrivLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthLevel( 
            /* [retval][out] */ long *plAuthLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthLevel( 
            /* [in] */ long lAuthLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated( 
            /* [retval][out] */ Boolean *pisAuthenticated) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Delivery( 
            /* [retval][out] */ long *plDelivery) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Delivery( 
            /* [in] */ long lDelivery) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Trace( 
            /* [retval][out] */ long *plTrace) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Trace( 
            /* [in] */ long lTrace) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *plPriority) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lPriority) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ long *plJournal) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Journal( 
            /* [in] */ long lJournal) = 0;
        
        virtual /* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseQueueInfo_v1( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse) = 0;
        
        virtual /* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseQueueInfo_v1( 
            /* [in] */ IMSMQQueueInfo *pqinfoResponse) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AppSpecific( 
            /* [retval][out] */ long *plAppSpecific) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AppSpecific( 
            /* [in] */ long lAppSpecific) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SourceMachineGuid( 
            /* [retval][out] */ BSTR *pbstrGuidSrcMachine) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BodyLength( 
            /* [retval][out] */ long *pcbBody) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Body( 
            /* [in] */ VARIANT varBody) = 0;
        
        virtual /* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AdminQueueInfo_v1( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin) = 0;
        
        virtual /* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_AdminQueueInfo_v1( 
            /* [in] */ IMSMQQueueInfo *pqinfoAdmin) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ VARIANT *pvarMsgId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CorrelationId( 
            /* [retval][out] */ VARIANT *pvarMsgId) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_CorrelationId( 
            /* [in] */ VARIANT varMsgId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Ack( 
            /* [retval][out] */ long *plAck) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Ack( 
            /* [in] */ long lAck) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Label( 
            /* [retval][out] */ BSTR *pbstrLabel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Label( 
            /* [in] */ BSTR bstrLabel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MaxTimeToReachQueue( 
            /* [retval][out] */ long *plMaxTimeToReachQueue) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MaxTimeToReachQueue( 
            /* [in] */ long lMaxTimeToReachQueue) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MaxTimeToReceive( 
            /* [retval][out] */ long *plMaxTimeToReceive) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MaxTimeToReceive( 
            /* [in] */ long lMaxTimeToReceive) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ long *plHashAlg) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ long lHashAlg) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_EncryptAlgorithm( 
            /* [retval][out] */ long *plEncryptAlg) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_EncryptAlgorithm( 
            /* [in] */ long lEncryptAlg) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SentTime( 
            /* [retval][out] */ VARIANT *pvarSentTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ArrivedTime( 
            /* [retval][out] */ VARIANT *plArrivedTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_DestinationQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoDest) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderCertificate( 
            /* [retval][out] */ VARIANT *pvarSenderCert) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderCertificate( 
            /* [in] */ VARIANT varSenderCert) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderId( 
            /* [retval][out] */ VARIANT *pvarSenderId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderIdType( 
            /* [retval][out] */ long *plSenderIdType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderIdType( 
            /* [in] */ long lSenderIdType) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [in] */ IMSMQQueue2 *DestinationQueue,
            /* [optional][in] */ VARIANT *Transaction) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE AttachCurrentSecurityContext( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderVersion( 
            /* [retval][out] */ long *plSenderVersion) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Extension( 
            /* [retval][out] */ VARIANT *pvarExtension) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Extension( 
            /* [in] */ VARIANT varExtension) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ConnectorTypeGuid( 
            /* [retval][out] */ BSTR *pbstrGuidConnectorType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_ConnectorTypeGuid( 
            /* [in] */ BSTR bstrGuidConnectorType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_TransactionStatusQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoXactStatus) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_DestinationSymmetricKey( 
            /* [retval][out] */ VARIANT *pvarDestSymmKey) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_DestinationSymmetricKey( 
            /* [in] */ VARIANT varDestSymmKey) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Signature( 
            /* [retval][out] */ VARIANT *pvarSignature) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Signature( 
            /* [in] */ VARIANT varSignature) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthenticationProviderType( 
            /* [retval][out] */ long *plAuthProvType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthenticationProviderType( 
            /* [in] */ long lAuthProvType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthenticationProviderName( 
            /* [retval][out] */ BSTR *pbstrAuthProvName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthenticationProviderName( 
            /* [in] */ BSTR bstrAuthProvName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderId( 
            /* [in] */ VARIANT varSenderId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MsgClass( 
            /* [retval][out] */ long *plMsgClass) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MsgClass( 
            /* [in] */ long lMsgClass) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_TransactionId( 
            /* [retval][out] */ VARIANT *pvarXactId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsFirstInTransaction( 
            /* [retval][out] */ Boolean *pisFirstInXact) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsLastInTransaction( 
            /* [retval][out] */ Boolean *pisLastInXact) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoResponse) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseQueueInfo( 
            /* [in] */ IMSMQQueueInfo2 *pqinfoResponse) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AdminQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoAdmin) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_AdminQueueInfo( 
            /* [in] */ IMSMQQueueInfo2 *pqinfoAdmin) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ReceivedAuthenticationLevel( 
            /* [retval][out] */ short *psReceivedAuthenticationLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQMessage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQMessage2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQMessage2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQMessage2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQMessage2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQMessage2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQMessage2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQMessage2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plClass);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivLevel )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plPrivLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PrivLevel )( 
            IMSMQMessage2 * This,
            /* [in] */ long lPrivLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthLevel )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plAuthLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthLevel )( 
            IMSMQMessage2 * This,
            /* [in] */ long lAuthLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ Boolean *pisAuthenticated);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Delivery )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plDelivery);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Delivery )( 
            IMSMQMessage2 * This,
            /* [in] */ long lDelivery);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Trace )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plTrace);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Trace )( 
            IMSMQMessage2 * This,
            /* [in] */ long lTrace);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plPriority);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IMSMQMessage2 * This,
            /* [in] */ long lPriority);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Journal )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plJournal);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Journal )( 
            IMSMQMessage2 * This,
            /* [in] */ long lJournal);
        
        /* [hidden][id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseQueueInfo_v1 )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse);
        
        /* [hidden][id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseQueueInfo_v1 )( 
            IMSMQMessage2 * This,
            /* [in] */ IMSMQQueueInfo *pqinfoResponse);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AppSpecific )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plAppSpecific);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AppSpecific )( 
            IMSMQMessage2 * This,
            /* [in] */ long lAppSpecific);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SourceMachineGuid )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ BSTR *pbstrGuidSrcMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BodyLength )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *pcbBody);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Body )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Body )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varBody);
        
        /* [hidden][id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AdminQueueInfo_v1 )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin);
        
        /* [hidden][id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_AdminQueueInfo_v1 )( 
            IMSMQMessage2 * This,
            /* [in] */ IMSMQQueueInfo *pqinfoAdmin);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarMsgId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CorrelationId )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarMsgId);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_CorrelationId )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varMsgId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Ack )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plAck);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Ack )( 
            IMSMQMessage2 * This,
            /* [in] */ long lAck);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Label )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ BSTR *pbstrLabel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Label )( 
            IMSMQMessage2 * This,
            /* [in] */ BSTR bstrLabel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTimeToReachQueue )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plMaxTimeToReachQueue);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTimeToReachQueue )( 
            IMSMQMessage2 * This,
            /* [in] */ long lMaxTimeToReachQueue);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTimeToReceive )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plMaxTimeToReceive);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTimeToReceive )( 
            IMSMQMessage2 * This,
            /* [in] */ long lMaxTimeToReceive);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plHashAlg);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IMSMQMessage2 * This,
            /* [in] */ long lHashAlg);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptAlgorithm )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plEncryptAlg);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptAlgorithm )( 
            IMSMQMessage2 * This,
            /* [in] */ long lEncryptAlg);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SentTime )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarSentTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ArrivedTime )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *plArrivedTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationQueueInfo )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoDest);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCertificate )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarSenderCert);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderCertificate )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varSenderCert);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderId )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarSenderId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderIdType )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plSenderIdType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderIdType )( 
            IMSMQMessage2 * This,
            /* [in] */ long lSenderIdType);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IMSMQMessage2 * This,
            /* [in] */ IMSMQQueue2 *DestinationQueue,
            /* [optional][in] */ VARIANT *Transaction);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *AttachCurrentSecurityContext )( 
            IMSMQMessage2 * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderVersion )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plSenderVersion);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Extension )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarExtension);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Extension )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varExtension);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectorTypeGuid )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ BSTR *pbstrGuidConnectorType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectorTypeGuid )( 
            IMSMQMessage2 * This,
            /* [in] */ BSTR bstrGuidConnectorType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionStatusQueueInfo )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoXactStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationSymmetricKey )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarDestSymmKey);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationSymmetricKey )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varDestSymmKey);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Signature )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarSignature);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Signature )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varSignature);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationProviderType )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plAuthProvType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationProviderType )( 
            IMSMQMessage2 * This,
            /* [in] */ long lAuthProvType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationProviderName )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ BSTR *pbstrAuthProvName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationProviderName )( 
            IMSMQMessage2 * This,
            /* [in] */ BSTR bstrAuthProvName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderId )( 
            IMSMQMessage2 * This,
            /* [in] */ VARIANT varSenderId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MsgClass )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ long *plMsgClass);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MsgClass )( 
            IMSMQMessage2 * This,
            /* [in] */ long lMsgClass);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionId )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ VARIANT *pvarXactId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsFirstInTransaction )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ Boolean *pisFirstInXact);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsLastInTransaction )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ Boolean *pisLastInXact);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseQueueInfo )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoResponse);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseQueueInfo )( 
            IMSMQMessage2 * This,
            /* [in] */ IMSMQQueueInfo2 *pqinfoResponse);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AdminQueueInfo )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoAdmin);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_AdminQueueInfo )( 
            IMSMQMessage2 * This,
            /* [in] */ IMSMQQueueInfo2 *pqinfoAdmin);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedAuthenticationLevel )( 
            IMSMQMessage2 * This,
            /* [retval][out] */ short *psReceivedAuthenticationLevel);
        
        END_INTERFACE
    } IMSMQMessage2Vtbl;

    interface IMSMQMessage2
    {
        CONST_VTBL struct IMSMQMessage2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQMessage2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQMessage2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQMessage2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQMessage2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQMessage2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQMessage2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQMessage2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQMessage2_get_Class(This,plClass)	\
    (This)->lpVtbl -> get_Class(This,plClass)

#define IMSMQMessage2_get_PrivLevel(This,plPrivLevel)	\
    (This)->lpVtbl -> get_PrivLevel(This,plPrivLevel)

#define IMSMQMessage2_put_PrivLevel(This,lPrivLevel)	\
    (This)->lpVtbl -> put_PrivLevel(This,lPrivLevel)

#define IMSMQMessage2_get_AuthLevel(This,plAuthLevel)	\
    (This)->lpVtbl -> get_AuthLevel(This,plAuthLevel)

#define IMSMQMessage2_put_AuthLevel(This,lAuthLevel)	\
    (This)->lpVtbl -> put_AuthLevel(This,lAuthLevel)

#define IMSMQMessage2_get_IsAuthenticated(This,pisAuthenticated)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,pisAuthenticated)

#define IMSMQMessage2_get_Delivery(This,plDelivery)	\
    (This)->lpVtbl -> get_Delivery(This,plDelivery)

#define IMSMQMessage2_put_Delivery(This,lDelivery)	\
    (This)->lpVtbl -> put_Delivery(This,lDelivery)

#define IMSMQMessage2_get_Trace(This,plTrace)	\
    (This)->lpVtbl -> get_Trace(This,plTrace)

#define IMSMQMessage2_put_Trace(This,lTrace)	\
    (This)->lpVtbl -> put_Trace(This,lTrace)

#define IMSMQMessage2_get_Priority(This,plPriority)	\
    (This)->lpVtbl -> get_Priority(This,plPriority)

#define IMSMQMessage2_put_Priority(This,lPriority)	\
    (This)->lpVtbl -> put_Priority(This,lPriority)

#define IMSMQMessage2_get_Journal(This,plJournal)	\
    (This)->lpVtbl -> get_Journal(This,plJournal)

#define IMSMQMessage2_put_Journal(This,lJournal)	\
    (This)->lpVtbl -> put_Journal(This,lJournal)

#define IMSMQMessage2_get_ResponseQueueInfo_v1(This,ppqinfoResponse)	\
    (This)->lpVtbl -> get_ResponseQueueInfo_v1(This,ppqinfoResponse)

#define IMSMQMessage2_putref_ResponseQueueInfo_v1(This,pqinfoResponse)	\
    (This)->lpVtbl -> putref_ResponseQueueInfo_v1(This,pqinfoResponse)

#define IMSMQMessage2_get_AppSpecific(This,plAppSpecific)	\
    (This)->lpVtbl -> get_AppSpecific(This,plAppSpecific)

#define IMSMQMessage2_put_AppSpecific(This,lAppSpecific)	\
    (This)->lpVtbl -> put_AppSpecific(This,lAppSpecific)

#define IMSMQMessage2_get_SourceMachineGuid(This,pbstrGuidSrcMachine)	\
    (This)->lpVtbl -> get_SourceMachineGuid(This,pbstrGuidSrcMachine)

#define IMSMQMessage2_get_BodyLength(This,pcbBody)	\
    (This)->lpVtbl -> get_BodyLength(This,pcbBody)

#define IMSMQMessage2_get_Body(This,pvarBody)	\
    (This)->lpVtbl -> get_Body(This,pvarBody)

#define IMSMQMessage2_put_Body(This,varBody)	\
    (This)->lpVtbl -> put_Body(This,varBody)

#define IMSMQMessage2_get_AdminQueueInfo_v1(This,ppqinfoAdmin)	\
    (This)->lpVtbl -> get_AdminQueueInfo_v1(This,ppqinfoAdmin)

#define IMSMQMessage2_putref_AdminQueueInfo_v1(This,pqinfoAdmin)	\
    (This)->lpVtbl -> putref_AdminQueueInfo_v1(This,pqinfoAdmin)

#define IMSMQMessage2_get_Id(This,pvarMsgId)	\
    (This)->lpVtbl -> get_Id(This,pvarMsgId)

#define IMSMQMessage2_get_CorrelationId(This,pvarMsgId)	\
    (This)->lpVtbl -> get_CorrelationId(This,pvarMsgId)

#define IMSMQMessage2_put_CorrelationId(This,varMsgId)	\
    (This)->lpVtbl -> put_CorrelationId(This,varMsgId)

#define IMSMQMessage2_get_Ack(This,plAck)	\
    (This)->lpVtbl -> get_Ack(This,plAck)

#define IMSMQMessage2_put_Ack(This,lAck)	\
    (This)->lpVtbl -> put_Ack(This,lAck)

#define IMSMQMessage2_get_Label(This,pbstrLabel)	\
    (This)->lpVtbl -> get_Label(This,pbstrLabel)

#define IMSMQMessage2_put_Label(This,bstrLabel)	\
    (This)->lpVtbl -> put_Label(This,bstrLabel)

#define IMSMQMessage2_get_MaxTimeToReachQueue(This,plMaxTimeToReachQueue)	\
    (This)->lpVtbl -> get_MaxTimeToReachQueue(This,plMaxTimeToReachQueue)

#define IMSMQMessage2_put_MaxTimeToReachQueue(This,lMaxTimeToReachQueue)	\
    (This)->lpVtbl -> put_MaxTimeToReachQueue(This,lMaxTimeToReachQueue)

#define IMSMQMessage2_get_MaxTimeToReceive(This,plMaxTimeToReceive)	\
    (This)->lpVtbl -> get_MaxTimeToReceive(This,plMaxTimeToReceive)

#define IMSMQMessage2_put_MaxTimeToReceive(This,lMaxTimeToReceive)	\
    (This)->lpVtbl -> put_MaxTimeToReceive(This,lMaxTimeToReceive)

#define IMSMQMessage2_get_HashAlgorithm(This,plHashAlg)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,plHashAlg)

#define IMSMQMessage2_put_HashAlgorithm(This,lHashAlg)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,lHashAlg)

#define IMSMQMessage2_get_EncryptAlgorithm(This,plEncryptAlg)	\
    (This)->lpVtbl -> get_EncryptAlgorithm(This,plEncryptAlg)

#define IMSMQMessage2_put_EncryptAlgorithm(This,lEncryptAlg)	\
    (This)->lpVtbl -> put_EncryptAlgorithm(This,lEncryptAlg)

#define IMSMQMessage2_get_SentTime(This,pvarSentTime)	\
    (This)->lpVtbl -> get_SentTime(This,pvarSentTime)

#define IMSMQMessage2_get_ArrivedTime(This,plArrivedTime)	\
    (This)->lpVtbl -> get_ArrivedTime(This,plArrivedTime)

#define IMSMQMessage2_get_DestinationQueueInfo(This,ppqinfoDest)	\
    (This)->lpVtbl -> get_DestinationQueueInfo(This,ppqinfoDest)

#define IMSMQMessage2_get_SenderCertificate(This,pvarSenderCert)	\
    (This)->lpVtbl -> get_SenderCertificate(This,pvarSenderCert)

#define IMSMQMessage2_put_SenderCertificate(This,varSenderCert)	\
    (This)->lpVtbl -> put_SenderCertificate(This,varSenderCert)

#define IMSMQMessage2_get_SenderId(This,pvarSenderId)	\
    (This)->lpVtbl -> get_SenderId(This,pvarSenderId)

#define IMSMQMessage2_get_SenderIdType(This,plSenderIdType)	\
    (This)->lpVtbl -> get_SenderIdType(This,plSenderIdType)

#define IMSMQMessage2_put_SenderIdType(This,lSenderIdType)	\
    (This)->lpVtbl -> put_SenderIdType(This,lSenderIdType)

#define IMSMQMessage2_Send(This,DestinationQueue,Transaction)	\
    (This)->lpVtbl -> Send(This,DestinationQueue,Transaction)

#define IMSMQMessage2_AttachCurrentSecurityContext(This)	\
    (This)->lpVtbl -> AttachCurrentSecurityContext(This)

#define IMSMQMessage2_get_SenderVersion(This,plSenderVersion)	\
    (This)->lpVtbl -> get_SenderVersion(This,plSenderVersion)

#define IMSMQMessage2_get_Extension(This,pvarExtension)	\
    (This)->lpVtbl -> get_Extension(This,pvarExtension)

#define IMSMQMessage2_put_Extension(This,varExtension)	\
    (This)->lpVtbl -> put_Extension(This,varExtension)

#define IMSMQMessage2_get_ConnectorTypeGuid(This,pbstrGuidConnectorType)	\
    (This)->lpVtbl -> get_ConnectorTypeGuid(This,pbstrGuidConnectorType)

#define IMSMQMessage2_put_ConnectorTypeGuid(This,bstrGuidConnectorType)	\
    (This)->lpVtbl -> put_ConnectorTypeGuid(This,bstrGuidConnectorType)

#define IMSMQMessage2_get_TransactionStatusQueueInfo(This,ppqinfoXactStatus)	\
    (This)->lpVtbl -> get_TransactionStatusQueueInfo(This,ppqinfoXactStatus)

#define IMSMQMessage2_get_DestinationSymmetricKey(This,pvarDestSymmKey)	\
    (This)->lpVtbl -> get_DestinationSymmetricKey(This,pvarDestSymmKey)

#define IMSMQMessage2_put_DestinationSymmetricKey(This,varDestSymmKey)	\
    (This)->lpVtbl -> put_DestinationSymmetricKey(This,varDestSymmKey)

#define IMSMQMessage2_get_Signature(This,pvarSignature)	\
    (This)->lpVtbl -> get_Signature(This,pvarSignature)

#define IMSMQMessage2_put_Signature(This,varSignature)	\
    (This)->lpVtbl -> put_Signature(This,varSignature)

#define IMSMQMessage2_get_AuthenticationProviderType(This,plAuthProvType)	\
    (This)->lpVtbl -> get_AuthenticationProviderType(This,plAuthProvType)

#define IMSMQMessage2_put_AuthenticationProviderType(This,lAuthProvType)	\
    (This)->lpVtbl -> put_AuthenticationProviderType(This,lAuthProvType)

#define IMSMQMessage2_get_AuthenticationProviderName(This,pbstrAuthProvName)	\
    (This)->lpVtbl -> get_AuthenticationProviderName(This,pbstrAuthProvName)

#define IMSMQMessage2_put_AuthenticationProviderName(This,bstrAuthProvName)	\
    (This)->lpVtbl -> put_AuthenticationProviderName(This,bstrAuthProvName)

#define IMSMQMessage2_put_SenderId(This,varSenderId)	\
    (This)->lpVtbl -> put_SenderId(This,varSenderId)

#define IMSMQMessage2_get_MsgClass(This,plMsgClass)	\
    (This)->lpVtbl -> get_MsgClass(This,plMsgClass)

#define IMSMQMessage2_put_MsgClass(This,lMsgClass)	\
    (This)->lpVtbl -> put_MsgClass(This,lMsgClass)

#define IMSMQMessage2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#define IMSMQMessage2_get_TransactionId(This,pvarXactId)	\
    (This)->lpVtbl -> get_TransactionId(This,pvarXactId)

#define IMSMQMessage2_get_IsFirstInTransaction(This,pisFirstInXact)	\
    (This)->lpVtbl -> get_IsFirstInTransaction(This,pisFirstInXact)

#define IMSMQMessage2_get_IsLastInTransaction(This,pisLastInXact)	\
    (This)->lpVtbl -> get_IsLastInTransaction(This,pisLastInXact)

#define IMSMQMessage2_get_ResponseQueueInfo(This,ppqinfoResponse)	\
    (This)->lpVtbl -> get_ResponseQueueInfo(This,ppqinfoResponse)

#define IMSMQMessage2_putref_ResponseQueueInfo(This,pqinfoResponse)	\
    (This)->lpVtbl -> putref_ResponseQueueInfo(This,pqinfoResponse)

#define IMSMQMessage2_get_AdminQueueInfo(This,ppqinfoAdmin)	\
    (This)->lpVtbl -> get_AdminQueueInfo(This,ppqinfoAdmin)

#define IMSMQMessage2_putref_AdminQueueInfo(This,pqinfoAdmin)	\
    (This)->lpVtbl -> putref_AdminQueueInfo(This,pqinfoAdmin)

#define IMSMQMessage2_get_ReceivedAuthenticationLevel(This,psReceivedAuthenticationLevel)	\
    (This)->lpVtbl -> get_ReceivedAuthenticationLevel(This,psReceivedAuthenticationLevel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Class_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plClass);


void __RPC_STUB IMSMQMessage2_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_PrivLevel_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plPrivLevel);


void __RPC_STUB IMSMQMessage2_get_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_PrivLevel_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lPrivLevel);


void __RPC_STUB IMSMQMessage2_put_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_AuthLevel_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plAuthLevel);


void __RPC_STUB IMSMQMessage2_get_AuthLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_AuthLevel_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lAuthLevel);


void __RPC_STUB IMSMQMessage2_put_AuthLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_IsAuthenticated_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ Boolean *pisAuthenticated);


void __RPC_STUB IMSMQMessage2_get_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Delivery_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plDelivery);


void __RPC_STUB IMSMQMessage2_get_Delivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Delivery_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lDelivery);


void __RPC_STUB IMSMQMessage2_put_Delivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Trace_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plTrace);


void __RPC_STUB IMSMQMessage2_get_Trace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Trace_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lTrace);


void __RPC_STUB IMSMQMessage2_put_Trace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Priority_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plPriority);


void __RPC_STUB IMSMQMessage2_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Priority_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lPriority);


void __RPC_STUB IMSMQMessage2_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Journal_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plJournal);


void __RPC_STUB IMSMQMessage2_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Journal_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lJournal);


void __RPC_STUB IMSMQMessage2_put_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_ResponseQueueInfo_v1_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse);


void __RPC_STUB IMSMQMessage2_get_ResponseQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_putref_ResponseQueueInfo_v1_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ IMSMQQueueInfo *pqinfoResponse);


void __RPC_STUB IMSMQMessage2_putref_ResponseQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_AppSpecific_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plAppSpecific);


void __RPC_STUB IMSMQMessage2_get_AppSpecific_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_AppSpecific_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lAppSpecific);


void __RPC_STUB IMSMQMessage2_put_AppSpecific_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_SourceMachineGuid_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ BSTR *pbstrGuidSrcMachine);


void __RPC_STUB IMSMQMessage2_get_SourceMachineGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_BodyLength_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *pcbBody);


void __RPC_STUB IMSMQMessage2_get_BodyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Body_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IMSMQMessage2_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Body_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varBody);


void __RPC_STUB IMSMQMessage2_put_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_AdminQueueInfo_v1_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin);


void __RPC_STUB IMSMQMessage2_get_AdminQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_putref_AdminQueueInfo_v1_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ IMSMQQueueInfo *pqinfoAdmin);


void __RPC_STUB IMSMQMessage2_putref_AdminQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Id_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarMsgId);


void __RPC_STUB IMSMQMessage2_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_CorrelationId_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarMsgId);


void __RPC_STUB IMSMQMessage2_get_CorrelationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_CorrelationId_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varMsgId);


void __RPC_STUB IMSMQMessage2_put_CorrelationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Ack_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plAck);


void __RPC_STUB IMSMQMessage2_get_Ack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Ack_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lAck);


void __RPC_STUB IMSMQMessage2_put_Ack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Label_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ BSTR *pbstrLabel);


void __RPC_STUB IMSMQMessage2_get_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Label_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ BSTR bstrLabel);


void __RPC_STUB IMSMQMessage2_put_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_MaxTimeToReachQueue_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plMaxTimeToReachQueue);


void __RPC_STUB IMSMQMessage2_get_MaxTimeToReachQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_MaxTimeToReachQueue_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lMaxTimeToReachQueue);


void __RPC_STUB IMSMQMessage2_put_MaxTimeToReachQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_MaxTimeToReceive_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plMaxTimeToReceive);


void __RPC_STUB IMSMQMessage2_get_MaxTimeToReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_MaxTimeToReceive_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lMaxTimeToReceive);


void __RPC_STUB IMSMQMessage2_put_MaxTimeToReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_HashAlgorithm_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plHashAlg);


void __RPC_STUB IMSMQMessage2_get_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_HashAlgorithm_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lHashAlg);


void __RPC_STUB IMSMQMessage2_put_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_EncryptAlgorithm_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plEncryptAlg);


void __RPC_STUB IMSMQMessage2_get_EncryptAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_EncryptAlgorithm_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lEncryptAlg);


void __RPC_STUB IMSMQMessage2_put_EncryptAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_SentTime_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarSentTime);


void __RPC_STUB IMSMQMessage2_get_SentTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_ArrivedTime_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *plArrivedTime);


void __RPC_STUB IMSMQMessage2_get_ArrivedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_DestinationQueueInfo_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoDest);


void __RPC_STUB IMSMQMessage2_get_DestinationQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_SenderCertificate_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarSenderCert);


void __RPC_STUB IMSMQMessage2_get_SenderCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_SenderCertificate_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varSenderCert);


void __RPC_STUB IMSMQMessage2_put_SenderCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_SenderId_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarSenderId);


void __RPC_STUB IMSMQMessage2_get_SenderId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_SenderIdType_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plSenderIdType);


void __RPC_STUB IMSMQMessage2_get_SenderIdType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_SenderIdType_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lSenderIdType);


void __RPC_STUB IMSMQMessage2_put_SenderIdType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_Send_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ IMSMQQueue2 *DestinationQueue,
    /* [optional][in] */ VARIANT *Transaction);


void __RPC_STUB IMSMQMessage2_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_AttachCurrentSecurityContext_Proxy( 
    IMSMQMessage2 * This);


void __RPC_STUB IMSMQMessage2_AttachCurrentSecurityContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_SenderVersion_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plSenderVersion);


void __RPC_STUB IMSMQMessage2_get_SenderVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Extension_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarExtension);


void __RPC_STUB IMSMQMessage2_get_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Extension_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varExtension);


void __RPC_STUB IMSMQMessage2_put_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_ConnectorTypeGuid_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ BSTR *pbstrGuidConnectorType);


void __RPC_STUB IMSMQMessage2_get_ConnectorTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_ConnectorTypeGuid_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ BSTR bstrGuidConnectorType);


void __RPC_STUB IMSMQMessage2_put_ConnectorTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_TransactionStatusQueueInfo_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoXactStatus);


void __RPC_STUB IMSMQMessage2_get_TransactionStatusQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_DestinationSymmetricKey_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarDestSymmKey);


void __RPC_STUB IMSMQMessage2_get_DestinationSymmetricKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_DestinationSymmetricKey_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varDestSymmKey);


void __RPC_STUB IMSMQMessage2_put_DestinationSymmetricKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Signature_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarSignature);


void __RPC_STUB IMSMQMessage2_get_Signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_Signature_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varSignature);


void __RPC_STUB IMSMQMessage2_put_Signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_AuthenticationProviderType_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plAuthProvType);


void __RPC_STUB IMSMQMessage2_get_AuthenticationProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_AuthenticationProviderType_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lAuthProvType);


void __RPC_STUB IMSMQMessage2_put_AuthenticationProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_AuthenticationProviderName_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ BSTR *pbstrAuthProvName);


void __RPC_STUB IMSMQMessage2_get_AuthenticationProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_AuthenticationProviderName_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ BSTR bstrAuthProvName);


void __RPC_STUB IMSMQMessage2_put_AuthenticationProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_SenderId_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ VARIANT varSenderId);


void __RPC_STUB IMSMQMessage2_put_SenderId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_MsgClass_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ long *plMsgClass);


void __RPC_STUB IMSMQMessage2_get_MsgClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_put_MsgClass_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ long lMsgClass);


void __RPC_STUB IMSMQMessage2_put_MsgClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_Properties_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQMessage2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_TransactionId_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ VARIANT *pvarXactId);


void __RPC_STUB IMSMQMessage2_get_TransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_IsFirstInTransaction_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ Boolean *pisFirstInXact);


void __RPC_STUB IMSMQMessage2_get_IsFirstInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_IsLastInTransaction_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ Boolean *pisLastInXact);


void __RPC_STUB IMSMQMessage2_get_IsLastInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_ResponseQueueInfo_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoResponse);


void __RPC_STUB IMSMQMessage2_get_ResponseQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_putref_ResponseQueueInfo_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ IMSMQQueueInfo2 *pqinfoResponse);


void __RPC_STUB IMSMQMessage2_putref_ResponseQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_AdminQueueInfo_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoAdmin);


void __RPC_STUB IMSMQMessage2_get_AdminQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_putref_AdminQueueInfo_Proxy( 
    IMSMQMessage2 * This,
    /* [in] */ IMSMQQueueInfo2 *pqinfoAdmin);


void __RPC_STUB IMSMQMessage2_putref_AdminQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage2_get_ReceivedAuthenticationLevel_Proxy( 
    IMSMQMessage2 * This,
    /* [retval][out] */ short *psReceivedAuthenticationLevel);


void __RPC_STUB IMSMQMessage2_get_ReceivedAuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQMessage2_INTERFACE_DEFINED__ */


#ifndef __IMSMQMessage3_INTERFACE_DEFINED__
#define __IMSMQMessage3_INTERFACE_DEFINED__

/* interface IMSMQMessage3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQMessage3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b1a-2168-11d3-898c-00e02c074f6b")
    IMSMQMessage3 : public IDispatch
    {
    public:
        virtual /* [id][propget][hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ long *plClass) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivLevel( 
            /* [retval][out] */ long *plPrivLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PrivLevel( 
            /* [in] */ long lPrivLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthLevel( 
            /* [retval][out] */ long *plAuthLevel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthLevel( 
            /* [in] */ long lAuthLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated( 
            /* [retval][out] */ Boolean *pisAuthenticated) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Delivery( 
            /* [retval][out] */ long *plDelivery) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Delivery( 
            /* [in] */ long lDelivery) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Trace( 
            /* [retval][out] */ long *plTrace) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Trace( 
            /* [in] */ long lTrace) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *plPriority) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lPriority) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Journal( 
            /* [retval][out] */ long *plJournal) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Journal( 
            /* [in] */ long lJournal) = 0;
        
        virtual /* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseQueueInfo_v1( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse) = 0;
        
        virtual /* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseQueueInfo_v1( 
            /* [in] */ IMSMQQueueInfo *pqinfoResponse) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AppSpecific( 
            /* [retval][out] */ long *plAppSpecific) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AppSpecific( 
            /* [in] */ long lAppSpecific) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SourceMachineGuid( 
            /* [retval][out] */ BSTR *pbstrGuidSrcMachine) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BodyLength( 
            /* [retval][out] */ long *pcbBody) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Body( 
            /* [in] */ VARIANT varBody) = 0;
        
        virtual /* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AdminQueueInfo_v1( 
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin) = 0;
        
        virtual /* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_AdminQueueInfo_v1( 
            /* [in] */ IMSMQQueueInfo *pqinfoAdmin) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ VARIANT *pvarMsgId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CorrelationId( 
            /* [retval][out] */ VARIANT *pvarMsgId) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_CorrelationId( 
            /* [in] */ VARIANT varMsgId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Ack( 
            /* [retval][out] */ long *plAck) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Ack( 
            /* [in] */ long lAck) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Label( 
            /* [retval][out] */ BSTR *pbstrLabel) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Label( 
            /* [in] */ BSTR bstrLabel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MaxTimeToReachQueue( 
            /* [retval][out] */ long *plMaxTimeToReachQueue) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MaxTimeToReachQueue( 
            /* [in] */ long lMaxTimeToReachQueue) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MaxTimeToReceive( 
            /* [retval][out] */ long *plMaxTimeToReceive) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MaxTimeToReceive( 
            /* [in] */ long lMaxTimeToReceive) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ long *plHashAlg) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ long lHashAlg) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_EncryptAlgorithm( 
            /* [retval][out] */ long *plEncryptAlg) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_EncryptAlgorithm( 
            /* [in] */ long lEncryptAlg) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SentTime( 
            /* [retval][out] */ VARIANT *pvarSentTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ArrivedTime( 
            /* [retval][out] */ VARIANT *plArrivedTime) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_DestinationQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoDest) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderCertificate( 
            /* [retval][out] */ VARIANT *pvarSenderCert) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderCertificate( 
            /* [in] */ VARIANT varSenderCert) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderId( 
            /* [retval][out] */ VARIANT *pvarSenderId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderIdType( 
            /* [retval][out] */ long *plSenderIdType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderIdType( 
            /* [in] */ long lSenderIdType) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [in] */ IDispatch *DestinationQueue,
            /* [optional][in] */ VARIANT *Transaction) = 0;
        
        virtual /* [helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE AttachCurrentSecurityContext( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SenderVersion( 
            /* [retval][out] */ long *plSenderVersion) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Extension( 
            /* [retval][out] */ VARIANT *pvarExtension) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Extension( 
            /* [in] */ VARIANT varExtension) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ConnectorTypeGuid( 
            /* [retval][out] */ BSTR *pbstrGuidConnectorType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_ConnectorTypeGuid( 
            /* [in] */ BSTR bstrGuidConnectorType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_TransactionStatusQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoXactStatus) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_DestinationSymmetricKey( 
            /* [retval][out] */ VARIANT *pvarDestSymmKey) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_DestinationSymmetricKey( 
            /* [in] */ VARIANT varDestSymmKey) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Signature( 
            /* [retval][out] */ VARIANT *pvarSignature) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Signature( 
            /* [in] */ VARIANT varSignature) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthenticationProviderType( 
            /* [retval][out] */ long *plAuthProvType) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthenticationProviderType( 
            /* [in] */ long lAuthProvType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AuthenticationProviderName( 
            /* [retval][out] */ BSTR *pbstrAuthProvName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_AuthenticationProviderName( 
            /* [in] */ BSTR bstrAuthProvName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SenderId( 
            /* [in] */ VARIANT varSenderId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MsgClass( 
            /* [retval][out] */ long *plMsgClass) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_MsgClass( 
            /* [in] */ long lMsgClass) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_TransactionId( 
            /* [retval][out] */ VARIANT *pvarXactId) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_IsFirstInTransaction( 
            /* [retval][out] */ Boolean *pisFirstInXact) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_IsLastInTransaction( 
            /* [retval][out] */ Boolean *pisLastInXact) = 0;
        
        virtual /* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseQueueInfo_v2( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoResponse) = 0;
        
        virtual /* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseQueueInfo_v2( 
            /* [in] */ IMSMQQueueInfo2 *pqinfoResponse) = 0;
        
        virtual /* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AdminQueueInfo_v2( 
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoAdmin) = 0;
        
        virtual /* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_AdminQueueInfo_v2( 
            /* [in] */ IMSMQQueueInfo2 *pqinfoAdmin) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ReceivedAuthenticationLevel( 
            /* [retval][out] */ short *psReceivedAuthenticationLevel) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoResponse) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseQueueInfo( 
            /* [in] */ IMSMQQueueInfo3 *pqinfoResponse) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_AdminQueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoAdmin) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_AdminQueueInfo( 
            /* [in] */ IMSMQQueueInfo3 *pqinfoAdmin) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ResponseDestination( 
            /* [retval][out] */ IDispatch **ppdestResponse) = 0;
        
        virtual /* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE putref_ResponseDestination( 
            /* [in] */ IDispatch *pdestResponse) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Destination( 
            /* [retval][out] */ IDispatch **ppdestDestination) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_LookupId( 
            /* [retval][out] */ VARIANT *pvarLookupId) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated2( 
            /* [retval][out] */ VARIANT_BOOL *pisAuthenticated) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsFirstInTransaction2( 
            /* [retval][out] */ VARIANT_BOOL *pisFirstInXact) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsLastInTransaction2( 
            /* [retval][out] */ VARIANT_BOOL *pisLastInXact) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE AttachCurrentSecurityContext2( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_SoapEnvelope( 
            /* [retval][out] */ BSTR *pbstrSoapEnvelope) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_CompoundMessage( 
            /* [retval][out] */ VARIANT *pvarCompoundMessage) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SoapHeader( 
            /* [in] */ BSTR bstrSoapHeader) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_SoapBody( 
            /* [in] */ BSTR bstrSoapBody) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQMessage3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQMessage3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQMessage3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQMessage3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQMessage3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQMessage3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQMessage3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQMessage3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Class )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plClass);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivLevel )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plPrivLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PrivLevel )( 
            IMSMQMessage3 * This,
            /* [in] */ long lPrivLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthLevel )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plAuthLevel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthLevel )( 
            IMSMQMessage3 * This,
            /* [in] */ long lAuthLevel);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ Boolean *pisAuthenticated);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Delivery )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plDelivery);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Delivery )( 
            IMSMQMessage3 * This,
            /* [in] */ long lDelivery);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Trace )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plTrace);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Trace )( 
            IMSMQMessage3 * This,
            /* [in] */ long lTrace);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plPriority);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IMSMQMessage3 * This,
            /* [in] */ long lPriority);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Journal )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plJournal);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Journal )( 
            IMSMQMessage3 * This,
            /* [in] */ long lJournal);
        
        /* [hidden][id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseQueueInfo_v1 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse);
        
        /* [hidden][id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseQueueInfo_v1 )( 
            IMSMQMessage3 * This,
            /* [in] */ IMSMQQueueInfo *pqinfoResponse);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AppSpecific )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plAppSpecific);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AppSpecific )( 
            IMSMQMessage3 * This,
            /* [in] */ long lAppSpecific);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SourceMachineGuid )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ BSTR *pbstrGuidSrcMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BodyLength )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *pcbBody);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Body )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Body )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varBody);
        
        /* [hidden][id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AdminQueueInfo_v1 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin);
        
        /* [hidden][id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_AdminQueueInfo_v1 )( 
            IMSMQMessage3 * This,
            /* [in] */ IMSMQQueueInfo *pqinfoAdmin);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarMsgId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CorrelationId )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarMsgId);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_CorrelationId )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varMsgId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Ack )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plAck);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Ack )( 
            IMSMQMessage3 * This,
            /* [in] */ long lAck);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Label )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ BSTR *pbstrLabel);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Label )( 
            IMSMQMessage3 * This,
            /* [in] */ BSTR bstrLabel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTimeToReachQueue )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plMaxTimeToReachQueue);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTimeToReachQueue )( 
            IMSMQMessage3 * This,
            /* [in] */ long lMaxTimeToReachQueue);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTimeToReceive )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plMaxTimeToReceive);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTimeToReceive )( 
            IMSMQMessage3 * This,
            /* [in] */ long lMaxTimeToReceive);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plHashAlg);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            IMSMQMessage3 * This,
            /* [in] */ long lHashAlg);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_EncryptAlgorithm )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plEncryptAlg);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptAlgorithm )( 
            IMSMQMessage3 * This,
            /* [in] */ long lEncryptAlg);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SentTime )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarSentTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ArrivedTime )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *plArrivedTime);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationQueueInfo )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoDest);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCertificate )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarSenderCert);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderCertificate )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varSenderCert);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderId )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarSenderId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderIdType )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plSenderIdType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderIdType )( 
            IMSMQMessage3 * This,
            /* [in] */ long lSenderIdType);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IMSMQMessage3 * This,
            /* [in] */ IDispatch *DestinationQueue,
            /* [optional][in] */ VARIANT *Transaction);
        
        /* [helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *AttachCurrentSecurityContext )( 
            IMSMQMessage3 * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SenderVersion )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plSenderVersion);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Extension )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarExtension);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Extension )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varExtension);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectorTypeGuid )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ BSTR *pbstrGuidConnectorType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectorTypeGuid )( 
            IMSMQMessage3 * This,
            /* [in] */ BSTR bstrGuidConnectorType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionStatusQueueInfo )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoXactStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationSymmetricKey )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarDestSymmKey);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_DestinationSymmetricKey )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varDestSymmKey);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Signature )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarSignature);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Signature )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varSignature);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationProviderType )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plAuthProvType);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationProviderType )( 
            IMSMQMessage3 * This,
            /* [in] */ long lAuthProvType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationProviderName )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ BSTR *pbstrAuthProvName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationProviderName )( 
            IMSMQMessage3 * This,
            /* [in] */ BSTR bstrAuthProvName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SenderId )( 
            IMSMQMessage3 * This,
            /* [in] */ VARIANT varSenderId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MsgClass )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ long *plMsgClass);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_MsgClass )( 
            IMSMQMessage3 * This,
            /* [in] */ long lMsgClass);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionId )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarXactId);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IsFirstInTransaction )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ Boolean *pisFirstInXact);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IsLastInTransaction )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ Boolean *pisLastInXact);
        
        /* [hidden][id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseQueueInfo_v2 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoResponse);
        
        /* [hidden][id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseQueueInfo_v2 )( 
            IMSMQMessage3 * This,
            /* [in] */ IMSMQQueueInfo2 *pqinfoResponse);
        
        /* [hidden][id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AdminQueueInfo_v2 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoAdmin);
        
        /* [hidden][id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_AdminQueueInfo_v2 )( 
            IMSMQMessage3 * This,
            /* [in] */ IMSMQQueueInfo2 *pqinfoAdmin);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedAuthenticationLevel )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ short *psReceivedAuthenticationLevel);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseQueueInfo )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoResponse);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseQueueInfo )( 
            IMSMQMessage3 * This,
            /* [in] */ IMSMQQueueInfo3 *pqinfoResponse);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_AdminQueueInfo )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoAdmin);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_AdminQueueInfo )( 
            IMSMQMessage3 * This,
            /* [in] */ IMSMQQueueInfo3 *pqinfoAdmin);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseDestination )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IDispatch **ppdestResponse);
        
        /* [id][propputref][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *putref_ResponseDestination )( 
            IMSMQMessage3 * This,
            /* [in] */ IDispatch *pdestResponse);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Destination )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ IDispatch **ppdestDestination);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_LookupId )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarLookupId);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated2 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT_BOOL *pisAuthenticated);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsFirstInTransaction2 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT_BOOL *pisFirstInXact);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsLastInTransaction2 )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT_BOOL *pisLastInXact);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *AttachCurrentSecurityContext2 )( 
            IMSMQMessage3 * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_SoapEnvelope )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ BSTR *pbstrSoapEnvelope);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_CompoundMessage )( 
            IMSMQMessage3 * This,
            /* [retval][out] */ VARIANT *pvarCompoundMessage);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SoapHeader )( 
            IMSMQMessage3 * This,
            /* [in] */ BSTR bstrSoapHeader);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_SoapBody )( 
            IMSMQMessage3 * This,
            /* [in] */ BSTR bstrSoapBody);
        
        END_INTERFACE
    } IMSMQMessage3Vtbl;

    interface IMSMQMessage3
    {
        CONST_VTBL struct IMSMQMessage3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQMessage3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQMessage3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQMessage3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQMessage3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQMessage3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQMessage3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQMessage3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQMessage3_get_Class(This,plClass)	\
    (This)->lpVtbl -> get_Class(This,plClass)

#define IMSMQMessage3_get_PrivLevel(This,plPrivLevel)	\
    (This)->lpVtbl -> get_PrivLevel(This,plPrivLevel)

#define IMSMQMessage3_put_PrivLevel(This,lPrivLevel)	\
    (This)->lpVtbl -> put_PrivLevel(This,lPrivLevel)

#define IMSMQMessage3_get_AuthLevel(This,plAuthLevel)	\
    (This)->lpVtbl -> get_AuthLevel(This,plAuthLevel)

#define IMSMQMessage3_put_AuthLevel(This,lAuthLevel)	\
    (This)->lpVtbl -> put_AuthLevel(This,lAuthLevel)

#define IMSMQMessage3_get_IsAuthenticated(This,pisAuthenticated)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,pisAuthenticated)

#define IMSMQMessage3_get_Delivery(This,plDelivery)	\
    (This)->lpVtbl -> get_Delivery(This,plDelivery)

#define IMSMQMessage3_put_Delivery(This,lDelivery)	\
    (This)->lpVtbl -> put_Delivery(This,lDelivery)

#define IMSMQMessage3_get_Trace(This,plTrace)	\
    (This)->lpVtbl -> get_Trace(This,plTrace)

#define IMSMQMessage3_put_Trace(This,lTrace)	\
    (This)->lpVtbl -> put_Trace(This,lTrace)

#define IMSMQMessage3_get_Priority(This,plPriority)	\
    (This)->lpVtbl -> get_Priority(This,plPriority)

#define IMSMQMessage3_put_Priority(This,lPriority)	\
    (This)->lpVtbl -> put_Priority(This,lPriority)

#define IMSMQMessage3_get_Journal(This,plJournal)	\
    (This)->lpVtbl -> get_Journal(This,plJournal)

#define IMSMQMessage3_put_Journal(This,lJournal)	\
    (This)->lpVtbl -> put_Journal(This,lJournal)

#define IMSMQMessage3_get_ResponseQueueInfo_v1(This,ppqinfoResponse)	\
    (This)->lpVtbl -> get_ResponseQueueInfo_v1(This,ppqinfoResponse)

#define IMSMQMessage3_putref_ResponseQueueInfo_v1(This,pqinfoResponse)	\
    (This)->lpVtbl -> putref_ResponseQueueInfo_v1(This,pqinfoResponse)

#define IMSMQMessage3_get_AppSpecific(This,plAppSpecific)	\
    (This)->lpVtbl -> get_AppSpecific(This,plAppSpecific)

#define IMSMQMessage3_put_AppSpecific(This,lAppSpecific)	\
    (This)->lpVtbl -> put_AppSpecific(This,lAppSpecific)

#define IMSMQMessage3_get_SourceMachineGuid(This,pbstrGuidSrcMachine)	\
    (This)->lpVtbl -> get_SourceMachineGuid(This,pbstrGuidSrcMachine)

#define IMSMQMessage3_get_BodyLength(This,pcbBody)	\
    (This)->lpVtbl -> get_BodyLength(This,pcbBody)

#define IMSMQMessage3_get_Body(This,pvarBody)	\
    (This)->lpVtbl -> get_Body(This,pvarBody)

#define IMSMQMessage3_put_Body(This,varBody)	\
    (This)->lpVtbl -> put_Body(This,varBody)

#define IMSMQMessage3_get_AdminQueueInfo_v1(This,ppqinfoAdmin)	\
    (This)->lpVtbl -> get_AdminQueueInfo_v1(This,ppqinfoAdmin)

#define IMSMQMessage3_putref_AdminQueueInfo_v1(This,pqinfoAdmin)	\
    (This)->lpVtbl -> putref_AdminQueueInfo_v1(This,pqinfoAdmin)

#define IMSMQMessage3_get_Id(This,pvarMsgId)	\
    (This)->lpVtbl -> get_Id(This,pvarMsgId)

#define IMSMQMessage3_get_CorrelationId(This,pvarMsgId)	\
    (This)->lpVtbl -> get_CorrelationId(This,pvarMsgId)

#define IMSMQMessage3_put_CorrelationId(This,varMsgId)	\
    (This)->lpVtbl -> put_CorrelationId(This,varMsgId)

#define IMSMQMessage3_get_Ack(This,plAck)	\
    (This)->lpVtbl -> get_Ack(This,plAck)

#define IMSMQMessage3_put_Ack(This,lAck)	\
    (This)->lpVtbl -> put_Ack(This,lAck)

#define IMSMQMessage3_get_Label(This,pbstrLabel)	\
    (This)->lpVtbl -> get_Label(This,pbstrLabel)

#define IMSMQMessage3_put_Label(This,bstrLabel)	\
    (This)->lpVtbl -> put_Label(This,bstrLabel)

#define IMSMQMessage3_get_MaxTimeToReachQueue(This,plMaxTimeToReachQueue)	\
    (This)->lpVtbl -> get_MaxTimeToReachQueue(This,plMaxTimeToReachQueue)

#define IMSMQMessage3_put_MaxTimeToReachQueue(This,lMaxTimeToReachQueue)	\
    (This)->lpVtbl -> put_MaxTimeToReachQueue(This,lMaxTimeToReachQueue)

#define IMSMQMessage3_get_MaxTimeToReceive(This,plMaxTimeToReceive)	\
    (This)->lpVtbl -> get_MaxTimeToReceive(This,plMaxTimeToReceive)

#define IMSMQMessage3_put_MaxTimeToReceive(This,lMaxTimeToReceive)	\
    (This)->lpVtbl -> put_MaxTimeToReceive(This,lMaxTimeToReceive)

#define IMSMQMessage3_get_HashAlgorithm(This,plHashAlg)	\
    (This)->lpVtbl -> get_HashAlgorithm(This,plHashAlg)

#define IMSMQMessage3_put_HashAlgorithm(This,lHashAlg)	\
    (This)->lpVtbl -> put_HashAlgorithm(This,lHashAlg)

#define IMSMQMessage3_get_EncryptAlgorithm(This,plEncryptAlg)	\
    (This)->lpVtbl -> get_EncryptAlgorithm(This,plEncryptAlg)

#define IMSMQMessage3_put_EncryptAlgorithm(This,lEncryptAlg)	\
    (This)->lpVtbl -> put_EncryptAlgorithm(This,lEncryptAlg)

#define IMSMQMessage3_get_SentTime(This,pvarSentTime)	\
    (This)->lpVtbl -> get_SentTime(This,pvarSentTime)

#define IMSMQMessage3_get_ArrivedTime(This,plArrivedTime)	\
    (This)->lpVtbl -> get_ArrivedTime(This,plArrivedTime)

#define IMSMQMessage3_get_DestinationQueueInfo(This,ppqinfoDest)	\
    (This)->lpVtbl -> get_DestinationQueueInfo(This,ppqinfoDest)

#define IMSMQMessage3_get_SenderCertificate(This,pvarSenderCert)	\
    (This)->lpVtbl -> get_SenderCertificate(This,pvarSenderCert)

#define IMSMQMessage3_put_SenderCertificate(This,varSenderCert)	\
    (This)->lpVtbl -> put_SenderCertificate(This,varSenderCert)

#define IMSMQMessage3_get_SenderId(This,pvarSenderId)	\
    (This)->lpVtbl -> get_SenderId(This,pvarSenderId)

#define IMSMQMessage3_get_SenderIdType(This,plSenderIdType)	\
    (This)->lpVtbl -> get_SenderIdType(This,plSenderIdType)

#define IMSMQMessage3_put_SenderIdType(This,lSenderIdType)	\
    (This)->lpVtbl -> put_SenderIdType(This,lSenderIdType)

#define IMSMQMessage3_Send(This,DestinationQueue,Transaction)	\
    (This)->lpVtbl -> Send(This,DestinationQueue,Transaction)

#define IMSMQMessage3_AttachCurrentSecurityContext(This)	\
    (This)->lpVtbl -> AttachCurrentSecurityContext(This)

#define IMSMQMessage3_get_SenderVersion(This,plSenderVersion)	\
    (This)->lpVtbl -> get_SenderVersion(This,plSenderVersion)

#define IMSMQMessage3_get_Extension(This,pvarExtension)	\
    (This)->lpVtbl -> get_Extension(This,pvarExtension)

#define IMSMQMessage3_put_Extension(This,varExtension)	\
    (This)->lpVtbl -> put_Extension(This,varExtension)

#define IMSMQMessage3_get_ConnectorTypeGuid(This,pbstrGuidConnectorType)	\
    (This)->lpVtbl -> get_ConnectorTypeGuid(This,pbstrGuidConnectorType)

#define IMSMQMessage3_put_ConnectorTypeGuid(This,bstrGuidConnectorType)	\
    (This)->lpVtbl -> put_ConnectorTypeGuid(This,bstrGuidConnectorType)

#define IMSMQMessage3_get_TransactionStatusQueueInfo(This,ppqinfoXactStatus)	\
    (This)->lpVtbl -> get_TransactionStatusQueueInfo(This,ppqinfoXactStatus)

#define IMSMQMessage3_get_DestinationSymmetricKey(This,pvarDestSymmKey)	\
    (This)->lpVtbl -> get_DestinationSymmetricKey(This,pvarDestSymmKey)

#define IMSMQMessage3_put_DestinationSymmetricKey(This,varDestSymmKey)	\
    (This)->lpVtbl -> put_DestinationSymmetricKey(This,varDestSymmKey)

#define IMSMQMessage3_get_Signature(This,pvarSignature)	\
    (This)->lpVtbl -> get_Signature(This,pvarSignature)

#define IMSMQMessage3_put_Signature(This,varSignature)	\
    (This)->lpVtbl -> put_Signature(This,varSignature)

#define IMSMQMessage3_get_AuthenticationProviderType(This,plAuthProvType)	\
    (This)->lpVtbl -> get_AuthenticationProviderType(This,plAuthProvType)

#define IMSMQMessage3_put_AuthenticationProviderType(This,lAuthProvType)	\
    (This)->lpVtbl -> put_AuthenticationProviderType(This,lAuthProvType)

#define IMSMQMessage3_get_AuthenticationProviderName(This,pbstrAuthProvName)	\
    (This)->lpVtbl -> get_AuthenticationProviderName(This,pbstrAuthProvName)

#define IMSMQMessage3_put_AuthenticationProviderName(This,bstrAuthProvName)	\
    (This)->lpVtbl -> put_AuthenticationProviderName(This,bstrAuthProvName)

#define IMSMQMessage3_put_SenderId(This,varSenderId)	\
    (This)->lpVtbl -> put_SenderId(This,varSenderId)

#define IMSMQMessage3_get_MsgClass(This,plMsgClass)	\
    (This)->lpVtbl -> get_MsgClass(This,plMsgClass)

#define IMSMQMessage3_put_MsgClass(This,lMsgClass)	\
    (This)->lpVtbl -> put_MsgClass(This,lMsgClass)

#define IMSMQMessage3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#define IMSMQMessage3_get_TransactionId(This,pvarXactId)	\
    (This)->lpVtbl -> get_TransactionId(This,pvarXactId)

#define IMSMQMessage3_get_IsFirstInTransaction(This,pisFirstInXact)	\
    (This)->lpVtbl -> get_IsFirstInTransaction(This,pisFirstInXact)

#define IMSMQMessage3_get_IsLastInTransaction(This,pisLastInXact)	\
    (This)->lpVtbl -> get_IsLastInTransaction(This,pisLastInXact)

#define IMSMQMessage3_get_ResponseQueueInfo_v2(This,ppqinfoResponse)	\
    (This)->lpVtbl -> get_ResponseQueueInfo_v2(This,ppqinfoResponse)

#define IMSMQMessage3_putref_ResponseQueueInfo_v2(This,pqinfoResponse)	\
    (This)->lpVtbl -> putref_ResponseQueueInfo_v2(This,pqinfoResponse)

#define IMSMQMessage3_get_AdminQueueInfo_v2(This,ppqinfoAdmin)	\
    (This)->lpVtbl -> get_AdminQueueInfo_v2(This,ppqinfoAdmin)

#define IMSMQMessage3_putref_AdminQueueInfo_v2(This,pqinfoAdmin)	\
    (This)->lpVtbl -> putref_AdminQueueInfo_v2(This,pqinfoAdmin)

#define IMSMQMessage3_get_ReceivedAuthenticationLevel(This,psReceivedAuthenticationLevel)	\
    (This)->lpVtbl -> get_ReceivedAuthenticationLevel(This,psReceivedAuthenticationLevel)

#define IMSMQMessage3_get_ResponseQueueInfo(This,ppqinfoResponse)	\
    (This)->lpVtbl -> get_ResponseQueueInfo(This,ppqinfoResponse)

#define IMSMQMessage3_putref_ResponseQueueInfo(This,pqinfoResponse)	\
    (This)->lpVtbl -> putref_ResponseQueueInfo(This,pqinfoResponse)

#define IMSMQMessage3_get_AdminQueueInfo(This,ppqinfoAdmin)	\
    (This)->lpVtbl -> get_AdminQueueInfo(This,ppqinfoAdmin)

#define IMSMQMessage3_putref_AdminQueueInfo(This,pqinfoAdmin)	\
    (This)->lpVtbl -> putref_AdminQueueInfo(This,pqinfoAdmin)

#define IMSMQMessage3_get_ResponseDestination(This,ppdestResponse)	\
    (This)->lpVtbl -> get_ResponseDestination(This,ppdestResponse)

#define IMSMQMessage3_putref_ResponseDestination(This,pdestResponse)	\
    (This)->lpVtbl -> putref_ResponseDestination(This,pdestResponse)

#define IMSMQMessage3_get_Destination(This,ppdestDestination)	\
    (This)->lpVtbl -> get_Destination(This,ppdestDestination)

#define IMSMQMessage3_get_LookupId(This,pvarLookupId)	\
    (This)->lpVtbl -> get_LookupId(This,pvarLookupId)

#define IMSMQMessage3_get_IsAuthenticated2(This,pisAuthenticated)	\
    (This)->lpVtbl -> get_IsAuthenticated2(This,pisAuthenticated)

#define IMSMQMessage3_get_IsFirstInTransaction2(This,pisFirstInXact)	\
    (This)->lpVtbl -> get_IsFirstInTransaction2(This,pisFirstInXact)

#define IMSMQMessage3_get_IsLastInTransaction2(This,pisLastInXact)	\
    (This)->lpVtbl -> get_IsLastInTransaction2(This,pisLastInXact)

#define IMSMQMessage3_AttachCurrentSecurityContext2(This)	\
    (This)->lpVtbl -> AttachCurrentSecurityContext2(This)

#define IMSMQMessage3_get_SoapEnvelope(This,pbstrSoapEnvelope)	\
    (This)->lpVtbl -> get_SoapEnvelope(This,pbstrSoapEnvelope)

#define IMSMQMessage3_get_CompoundMessage(This,pvarCompoundMessage)	\
    (This)->lpVtbl -> get_CompoundMessage(This,pvarCompoundMessage)

#define IMSMQMessage3_put_SoapHeader(This,bstrSoapHeader)	\
    (This)->lpVtbl -> put_SoapHeader(This,bstrSoapHeader)

#define IMSMQMessage3_put_SoapBody(This,bstrSoapBody)	\
    (This)->lpVtbl -> put_SoapBody(This,bstrSoapBody)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Class_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plClass);


void __RPC_STUB IMSMQMessage3_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_PrivLevel_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plPrivLevel);


void __RPC_STUB IMSMQMessage3_get_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_PrivLevel_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lPrivLevel);


void __RPC_STUB IMSMQMessage3_put_PrivLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AuthLevel_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plAuthLevel);


void __RPC_STUB IMSMQMessage3_get_AuthLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_AuthLevel_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lAuthLevel);


void __RPC_STUB IMSMQMessage3_put_AuthLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_IsAuthenticated_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ Boolean *pisAuthenticated);


void __RPC_STUB IMSMQMessage3_get_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Delivery_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plDelivery);


void __RPC_STUB IMSMQMessage3_get_Delivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Delivery_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lDelivery);


void __RPC_STUB IMSMQMessage3_put_Delivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Trace_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plTrace);


void __RPC_STUB IMSMQMessage3_get_Trace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Trace_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lTrace);


void __RPC_STUB IMSMQMessage3_put_Trace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Priority_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plPriority);


void __RPC_STUB IMSMQMessage3_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Priority_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lPriority);


void __RPC_STUB IMSMQMessage3_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Journal_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plJournal);


void __RPC_STUB IMSMQMessage3_get_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Journal_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lJournal);


void __RPC_STUB IMSMQMessage3_put_Journal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ResponseQueueInfo_v1_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoResponse);


void __RPC_STUB IMSMQMessage3_get_ResponseQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_ResponseQueueInfo_v1_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IMSMQQueueInfo *pqinfoResponse);


void __RPC_STUB IMSMQMessage3_putref_ResponseQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AppSpecific_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plAppSpecific);


void __RPC_STUB IMSMQMessage3_get_AppSpecific_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_AppSpecific_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lAppSpecific);


void __RPC_STUB IMSMQMessage3_put_AppSpecific_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SourceMachineGuid_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ BSTR *pbstrGuidSrcMachine);


void __RPC_STUB IMSMQMessage3_get_SourceMachineGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_BodyLength_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *pcbBody);


void __RPC_STUB IMSMQMessage3_get_BodyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Body_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IMSMQMessage3_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Body_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varBody);


void __RPC_STUB IMSMQMessage3_put_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AdminQueueInfo_v1_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo **ppqinfoAdmin);


void __RPC_STUB IMSMQMessage3_get_AdminQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_AdminQueueInfo_v1_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IMSMQQueueInfo *pqinfoAdmin);


void __RPC_STUB IMSMQMessage3_putref_AdminQueueInfo_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Id_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarMsgId);


void __RPC_STUB IMSMQMessage3_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_CorrelationId_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarMsgId);


void __RPC_STUB IMSMQMessage3_get_CorrelationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_CorrelationId_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varMsgId);


void __RPC_STUB IMSMQMessage3_put_CorrelationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Ack_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plAck);


void __RPC_STUB IMSMQMessage3_get_Ack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Ack_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lAck);


void __RPC_STUB IMSMQMessage3_put_Ack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Label_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ BSTR *pbstrLabel);


void __RPC_STUB IMSMQMessage3_get_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Label_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ BSTR bstrLabel);


void __RPC_STUB IMSMQMessage3_put_Label_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_MaxTimeToReachQueue_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plMaxTimeToReachQueue);


void __RPC_STUB IMSMQMessage3_get_MaxTimeToReachQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_MaxTimeToReachQueue_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lMaxTimeToReachQueue);


void __RPC_STUB IMSMQMessage3_put_MaxTimeToReachQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_MaxTimeToReceive_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plMaxTimeToReceive);


void __RPC_STUB IMSMQMessage3_get_MaxTimeToReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_MaxTimeToReceive_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lMaxTimeToReceive);


void __RPC_STUB IMSMQMessage3_put_MaxTimeToReceive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_HashAlgorithm_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plHashAlg);


void __RPC_STUB IMSMQMessage3_get_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_HashAlgorithm_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lHashAlg);


void __RPC_STUB IMSMQMessage3_put_HashAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_EncryptAlgorithm_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plEncryptAlg);


void __RPC_STUB IMSMQMessage3_get_EncryptAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_EncryptAlgorithm_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lEncryptAlg);


void __RPC_STUB IMSMQMessage3_put_EncryptAlgorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SentTime_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarSentTime);


void __RPC_STUB IMSMQMessage3_get_SentTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ArrivedTime_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *plArrivedTime);


void __RPC_STUB IMSMQMessage3_get_ArrivedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_DestinationQueueInfo_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoDest);


void __RPC_STUB IMSMQMessage3_get_DestinationQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SenderCertificate_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarSenderCert);


void __RPC_STUB IMSMQMessage3_get_SenderCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_SenderCertificate_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varSenderCert);


void __RPC_STUB IMSMQMessage3_put_SenderCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SenderId_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarSenderId);


void __RPC_STUB IMSMQMessage3_get_SenderId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SenderIdType_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plSenderIdType);


void __RPC_STUB IMSMQMessage3_get_SenderIdType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_SenderIdType_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lSenderIdType);


void __RPC_STUB IMSMQMessage3_put_SenderIdType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_Send_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IDispatch *DestinationQueue,
    /* [optional][in] */ VARIANT *Transaction);


void __RPC_STUB IMSMQMessage3_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_AttachCurrentSecurityContext_Proxy( 
    IMSMQMessage3 * This);


void __RPC_STUB IMSMQMessage3_AttachCurrentSecurityContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SenderVersion_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plSenderVersion);


void __RPC_STUB IMSMQMessage3_get_SenderVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Extension_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarExtension);


void __RPC_STUB IMSMQMessage3_get_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Extension_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varExtension);


void __RPC_STUB IMSMQMessage3_put_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ConnectorTypeGuid_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ BSTR *pbstrGuidConnectorType);


void __RPC_STUB IMSMQMessage3_get_ConnectorTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_ConnectorTypeGuid_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ BSTR bstrGuidConnectorType);


void __RPC_STUB IMSMQMessage3_put_ConnectorTypeGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_TransactionStatusQueueInfo_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoXactStatus);


void __RPC_STUB IMSMQMessage3_get_TransactionStatusQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_DestinationSymmetricKey_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarDestSymmKey);


void __RPC_STUB IMSMQMessage3_get_DestinationSymmetricKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_DestinationSymmetricKey_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varDestSymmKey);


void __RPC_STUB IMSMQMessage3_put_DestinationSymmetricKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Signature_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarSignature);


void __RPC_STUB IMSMQMessage3_get_Signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_Signature_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varSignature);


void __RPC_STUB IMSMQMessage3_put_Signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AuthenticationProviderType_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plAuthProvType);


void __RPC_STUB IMSMQMessage3_get_AuthenticationProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_AuthenticationProviderType_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lAuthProvType);


void __RPC_STUB IMSMQMessage3_put_AuthenticationProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AuthenticationProviderName_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ BSTR *pbstrAuthProvName);


void __RPC_STUB IMSMQMessage3_get_AuthenticationProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_AuthenticationProviderName_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ BSTR bstrAuthProvName);


void __RPC_STUB IMSMQMessage3_put_AuthenticationProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_SenderId_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ VARIANT varSenderId);


void __RPC_STUB IMSMQMessage3_put_SenderId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_MsgClass_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ long *plMsgClass);


void __RPC_STUB IMSMQMessage3_get_MsgClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_MsgClass_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ long lMsgClass);


void __RPC_STUB IMSMQMessage3_put_MsgClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Properties_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQMessage3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_TransactionId_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarXactId);


void __RPC_STUB IMSMQMessage3_get_TransactionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_IsFirstInTransaction_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ Boolean *pisFirstInXact);


void __RPC_STUB IMSMQMessage3_get_IsFirstInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_IsLastInTransaction_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ Boolean *pisLastInXact);


void __RPC_STUB IMSMQMessage3_get_IsLastInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ResponseQueueInfo_v2_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoResponse);


void __RPC_STUB IMSMQMessage3_get_ResponseQueueInfo_v2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_ResponseQueueInfo_v2_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IMSMQQueueInfo2 *pqinfoResponse);


void __RPC_STUB IMSMQMessage3_putref_ResponseQueueInfo_v2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AdminQueueInfo_v2_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo2 **ppqinfoAdmin);


void __RPC_STUB IMSMQMessage3_get_AdminQueueInfo_v2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_AdminQueueInfo_v2_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IMSMQQueueInfo2 *pqinfoAdmin);


void __RPC_STUB IMSMQMessage3_putref_AdminQueueInfo_v2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ReceivedAuthenticationLevel_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ short *psReceivedAuthenticationLevel);


void __RPC_STUB IMSMQMessage3_get_ReceivedAuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ResponseQueueInfo_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoResponse);


void __RPC_STUB IMSMQMessage3_get_ResponseQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_ResponseQueueInfo_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IMSMQQueueInfo3 *pqinfoResponse);


void __RPC_STUB IMSMQMessage3_putref_ResponseQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_AdminQueueInfo_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IMSMQQueueInfo3 **ppqinfoAdmin);


void __RPC_STUB IMSMQMessage3_get_AdminQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_AdminQueueInfo_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IMSMQQueueInfo3 *pqinfoAdmin);


void __RPC_STUB IMSMQMessage3_putref_AdminQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_ResponseDestination_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IDispatch **ppdestResponse);


void __RPC_STUB IMSMQMessage3_get_ResponseDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_putref_ResponseDestination_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ IDispatch *pdestResponse);


void __RPC_STUB IMSMQMessage3_putref_ResponseDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_Destination_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ IDispatch **ppdestDestination);


void __RPC_STUB IMSMQMessage3_get_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_LookupId_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarLookupId);


void __RPC_STUB IMSMQMessage3_get_LookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_IsAuthenticated2_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT_BOOL *pisAuthenticated);


void __RPC_STUB IMSMQMessage3_get_IsAuthenticated2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_IsFirstInTransaction2_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT_BOOL *pisFirstInXact);


void __RPC_STUB IMSMQMessage3_get_IsFirstInTransaction2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_IsLastInTransaction2_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT_BOOL *pisLastInXact);


void __RPC_STUB IMSMQMessage3_get_IsLastInTransaction2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_AttachCurrentSecurityContext2_Proxy( 
    IMSMQMessage3 * This);


void __RPC_STUB IMSMQMessage3_AttachCurrentSecurityContext2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_SoapEnvelope_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ BSTR *pbstrSoapEnvelope);


void __RPC_STUB IMSMQMessage3_get_SoapEnvelope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_get_CompoundMessage_Proxy( 
    IMSMQMessage3 * This,
    /* [retval][out] */ VARIANT *pvarCompoundMessage);


void __RPC_STUB IMSMQMessage3_get_CompoundMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_SoapHeader_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ BSTR bstrSoapHeader);


void __RPC_STUB IMSMQMessage3_put_SoapHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQMessage3_put_SoapBody_Proxy( 
    IMSMQMessage3 * This,
    /* [in] */ BSTR bstrSoapBody);


void __RPC_STUB IMSMQMessage3_put_SoapBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQMessage3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E075-DCCD-11d0-AA4B-0060970DEBAE")
MSMQMessage;
#endif

#ifndef __IMSMQQueue3_INTERFACE_DEFINED__
#define __IMSMQQueue3_INTERFACE_DEFINED__

/* interface IMSMQQueue3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueue3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b1b-2168-11d3-898c-00e02c074f6b")
    IMSMQQueue3 : public IDispatch
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Access( 
            /* [retval][out] */ long *plAccess) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ShareMode( 
            /* [retval][out] */ long *plShareMode) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueInfo( 
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfo) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ long *plHandle) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_IsOpen( 
            /* [retval][out] */ Boolean *pisOpen) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE Receive_v1( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE Peek_v1( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE EnableNotification( 
            /* [in] */ IMSMQEvent3 *Event,
            /* [optional][in] */ VARIANT *Cursor,
            /* [optional][in] */ VARIANT *ReceiveTimeout) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveCurrent_v1( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekNext_v1( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekCurrent_v1( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Receive( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Peek( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveCurrent( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekNext( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekCurrent( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
        virtual /* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE get_Handle2( 
            /* [retval][out] */ VARIANT *pvarHandle) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveByLookupId( 
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveNextByLookupId( 
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceivePreviousByLookupId( 
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveFirstByLookupId( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE ReceiveLastByLookupId( 
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekByLookupId( 
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekNextByLookupId( 
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekPreviousByLookupId( 
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekFirstByLookupId( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE PeekLastByLookupId( 
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Purge( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsOpen2( 
            /* [retval][out] */ VARIANT_BOOL *pisOpen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueue3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueue3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueue3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueue3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueue3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueue3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueue3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueue3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Access )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ long *plAccess);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ShareMode )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ long *plShareMode);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueInfo )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ IMSMQQueueInfo3 **ppqinfo);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Handle )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ long *plHandle);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ Boolean *pisOpen);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMSMQQueue3 * This);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Receive_v1 )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Peek_v1 )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *EnableNotification )( 
            IMSMQQueue3 * This,
            /* [in] */ IMSMQEvent3 *Event,
            /* [optional][in] */ VARIANT *Cursor,
            /* [optional][in] */ VARIANT *ReceiveTimeout);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMSMQQueue3 * This);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveCurrent_v1 )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekNext_v1 )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [hidden][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekCurrent_v1 )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [retval][out] */ IMSMQMessage **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Receive )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Peek )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveCurrent )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekNext )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekCurrent )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *ReceiveTimeout,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Handle2 )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ VARIANT *pvarHandle);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveByLookupId )( 
            IMSMQQueue3 * This,
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveNextByLookupId )( 
            IMSMQQueue3 * This,
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceivePreviousByLookupId )( 
            IMSMQQueue3 * This,
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveFirstByLookupId )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *ReceiveLastByLookupId )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *Transaction,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekByLookupId )( 
            IMSMQQueue3 * This,
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekNextByLookupId )( 
            IMSMQQueue3 * This,
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekPreviousByLookupId )( 
            IMSMQQueue3 * This,
            /* [in] */ VARIANT LookupId,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekFirstByLookupId )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *PeekLastByLookupId )( 
            IMSMQQueue3 * This,
            /* [optional][in] */ VARIANT *WantDestinationQueue,
            /* [optional][in] */ VARIANT *WantBody,
            /* [optional][in] */ VARIANT *WantConnectorType,
            /* [retval][out] */ IMSMQMessage3 **ppmsg);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Purge )( 
            IMSMQQueue3 * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen2 )( 
            IMSMQQueue3 * This,
            /* [retval][out] */ VARIANT_BOOL *pisOpen);
        
        END_INTERFACE
    } IMSMQQueue3Vtbl;

    interface IMSMQQueue3
    {
        CONST_VTBL struct IMSMQQueue3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueue3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueue3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueue3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueue3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueue3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueue3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueue3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueue3_get_Access(This,plAccess)	\
    (This)->lpVtbl -> get_Access(This,plAccess)

#define IMSMQQueue3_get_ShareMode(This,plShareMode)	\
    (This)->lpVtbl -> get_ShareMode(This,plShareMode)

#define IMSMQQueue3_get_QueueInfo(This,ppqinfo)	\
    (This)->lpVtbl -> get_QueueInfo(This,ppqinfo)

#define IMSMQQueue3_get_Handle(This,plHandle)	\
    (This)->lpVtbl -> get_Handle(This,plHandle)

#define IMSMQQueue3_get_IsOpen(This,pisOpen)	\
    (This)->lpVtbl -> get_IsOpen(This,pisOpen)

#define IMSMQQueue3_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IMSMQQueue3_Receive_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> Receive_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue3_Peek_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> Peek_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue3_EnableNotification(This,Event,Cursor,ReceiveTimeout)	\
    (This)->lpVtbl -> EnableNotification(This,Event,Cursor,ReceiveTimeout)

#define IMSMQQueue3_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMSMQQueue3_ReceiveCurrent_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> ReceiveCurrent_v1(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue3_PeekNext_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> PeekNext_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue3_PeekCurrent_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)	\
    (This)->lpVtbl -> PeekCurrent_v1(This,WantDestinationQueue,WantBody,ReceiveTimeout,ppmsg)

#define IMSMQQueue3_Receive(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> Receive(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue3_Peek(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> Peek(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue3_ReceiveCurrent(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceiveCurrent(This,Transaction,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekNext(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekNext(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekCurrent(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekCurrent(This,WantDestinationQueue,WantBody,ReceiveTimeout,WantConnectorType,ppmsg)

#define IMSMQQueue3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#define IMSMQQueue3_get_Handle2(This,pvarHandle)	\
    (This)->lpVtbl -> get_Handle2(This,pvarHandle)

#define IMSMQQueue3_ReceiveByLookupId(This,LookupId,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceiveByLookupId(This,LookupId,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_ReceiveNextByLookupId(This,LookupId,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceiveNextByLookupId(This,LookupId,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_ReceivePreviousByLookupId(This,LookupId,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceivePreviousByLookupId(This,LookupId,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_ReceiveFirstByLookupId(This,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceiveFirstByLookupId(This,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_ReceiveLastByLookupId(This,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> ReceiveLastByLookupId(This,Transaction,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekByLookupId(This,LookupId,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekByLookupId(This,LookupId,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekNextByLookupId(This,LookupId,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekNextByLookupId(This,LookupId,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekPreviousByLookupId(This,LookupId,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekPreviousByLookupId(This,LookupId,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekFirstByLookupId(This,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekFirstByLookupId(This,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_PeekLastByLookupId(This,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)	\
    (This)->lpVtbl -> PeekLastByLookupId(This,WantDestinationQueue,WantBody,WantConnectorType,ppmsg)

#define IMSMQQueue3_Purge(This)	\
    (This)->lpVtbl -> Purge(This)

#define IMSMQQueue3_get_IsOpen2(This,pisOpen)	\
    (This)->lpVtbl -> get_IsOpen2(This,pisOpen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_Access_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ long *plAccess);


void __RPC_STUB IMSMQQueue3_get_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_ShareMode_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ long *plShareMode);


void __RPC_STUB IMSMQQueue3_get_ShareMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_QueueInfo_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ IMSMQQueueInfo3 **ppqinfo);


void __RPC_STUB IMSMQQueue3_get_QueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_Handle_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ long *plHandle);


void __RPC_STUB IMSMQQueue3_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_IsOpen_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ Boolean *pisOpen);


void __RPC_STUB IMSMQQueue3_get_IsOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Close_Proxy( 
    IMSMQQueue3 * This);


void __RPC_STUB IMSMQQueue3_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Receive_v1_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue3_Receive_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Peek_v1_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue3_Peek_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_EnableNotification_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ IMSMQEvent3 *Event,
    /* [optional][in] */ VARIANT *Cursor,
    /* [optional][in] */ VARIANT *ReceiveTimeout);


void __RPC_STUB IMSMQQueue3_EnableNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Reset_Proxy( 
    IMSMQQueue3 * This);


void __RPC_STUB IMSMQQueue3_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceiveCurrent_v1_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceiveCurrent_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekNext_v1_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekNext_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekCurrent_v1_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [retval][out] */ IMSMQMessage **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekCurrent_v1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Receive_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Peek_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_Peek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceiveCurrent_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceiveCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekNext_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekCurrent_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *ReceiveTimeout,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_Properties_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQQueue3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_Handle2_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ VARIANT *pvarHandle);


void __RPC_STUB IMSMQQueue3_get_Handle2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceiveByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ VARIANT LookupId,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceiveByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceiveNextByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ VARIANT LookupId,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceiveNextByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceivePreviousByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ VARIANT LookupId,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceivePreviousByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceiveFirstByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceiveFirstByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_ReceiveLastByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *Transaction,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_ReceiveLastByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ VARIANT LookupId,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekNextByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ VARIANT LookupId,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekNextByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekPreviousByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [in] */ VARIANT LookupId,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekPreviousByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekFirstByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekFirstByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_PeekLastByLookupId_Proxy( 
    IMSMQQueue3 * This,
    /* [optional][in] */ VARIANT *WantDestinationQueue,
    /* [optional][in] */ VARIANT *WantBody,
    /* [optional][in] */ VARIANT *WantConnectorType,
    /* [retval][out] */ IMSMQMessage3 **ppmsg);


void __RPC_STUB IMSMQQueue3_PeekLastByLookupId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_Purge_Proxy( 
    IMSMQQueue3 * This);


void __RPC_STUB IMSMQQueue3_Purge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueue3_get_IsOpen2_Proxy( 
    IMSMQQueue3 * This,
    /* [retval][out] */ VARIANT_BOOL *pisOpen);


void __RPC_STUB IMSMQQueue3_get_IsOpen2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueue3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQQueue;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E079-DCCD-11d0-AA4B-0060970DEBAE")
MSMQQueue;
#endif

#ifndef __IMSMQPrivateEvent_INTERFACE_DEFINED__
#define __IMSMQPrivateEvent_INTERFACE_DEFINED__

/* interface IMSMQPrivateEvent */
/* [object][dual][hidden][uuid] */ 


EXTERN_C const IID IID_IMSMQPrivateEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7AB3341-C9D3-11d1-BB47-0080C7C5A2C0")
    IMSMQPrivateEvent : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Hwnd( 
            /* [retval][out] */ long *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireArrivedEvent( 
            /* [in] */ IMSMQQueue *pq,
            /* [in] */ long msgcursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireArrivedErrorEvent( 
            /* [in] */ IMSMQQueue *pq,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ long msgcursor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQPrivateEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQPrivateEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQPrivateEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQPrivateEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQPrivateEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQPrivateEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQPrivateEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQPrivateEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hwnd )( 
            IMSMQPrivateEvent * This,
            /* [retval][out] */ long *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *FireArrivedEvent )( 
            IMSMQPrivateEvent * This,
            /* [in] */ IMSMQQueue *pq,
            /* [in] */ long msgcursor);
        
        HRESULT ( STDMETHODCALLTYPE *FireArrivedErrorEvent )( 
            IMSMQPrivateEvent * This,
            /* [in] */ IMSMQQueue *pq,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ long msgcursor);
        
        END_INTERFACE
    } IMSMQPrivateEventVtbl;

    interface IMSMQPrivateEvent
    {
        CONST_VTBL struct IMSMQPrivateEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQPrivateEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQPrivateEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQPrivateEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQPrivateEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQPrivateEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQPrivateEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQPrivateEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQPrivateEvent_get_Hwnd(This,phwnd)	\
    (This)->lpVtbl -> get_Hwnd(This,phwnd)

#define IMSMQPrivateEvent_FireArrivedEvent(This,pq,msgcursor)	\
    (This)->lpVtbl -> FireArrivedEvent(This,pq,msgcursor)

#define IMSMQPrivateEvent_FireArrivedErrorEvent(This,pq,hrStatus,msgcursor)	\
    (This)->lpVtbl -> FireArrivedErrorEvent(This,pq,hrStatus,msgcursor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IMSMQPrivateEvent_get_Hwnd_Proxy( 
    IMSMQPrivateEvent * This,
    /* [retval][out] */ long *phwnd);


void __RPC_STUB IMSMQPrivateEvent_get_Hwnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSMQPrivateEvent_FireArrivedEvent_Proxy( 
    IMSMQPrivateEvent * This,
    /* [in] */ IMSMQQueue *pq,
    /* [in] */ long msgcursor);


void __RPC_STUB IMSMQPrivateEvent_FireArrivedEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSMQPrivateEvent_FireArrivedErrorEvent_Proxy( 
    IMSMQPrivateEvent * This,
    /* [in] */ IMSMQQueue *pq,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ long msgcursor);


void __RPC_STUB IMSMQPrivateEvent_FireArrivedErrorEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQPrivateEvent_INTERFACE_DEFINED__ */


#ifndef ___DMSMQEventEvents_DISPINTERFACE_DEFINED__
#define ___DMSMQEventEvents_DISPINTERFACE_DEFINED__

/* dispinterface _DMSMQEventEvents */
/* [hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID DIID__DMSMQEventEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("D7D6E078-DCCD-11d0-AA4B-0060970DEBAE")
    _DMSMQEventEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DMSMQEventEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _DMSMQEventEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _DMSMQEventEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _DMSMQEventEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _DMSMQEventEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _DMSMQEventEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _DMSMQEventEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _DMSMQEventEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _DMSMQEventEventsVtbl;

    interface _DMSMQEventEvents
    {
        CONST_VTBL struct _DMSMQEventEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DMSMQEventEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DMSMQEventEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DMSMQEventEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DMSMQEventEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DMSMQEventEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DMSMQEventEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DMSMQEventEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DMSMQEventEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQEvent;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E07A-DCCD-11d0-AA4B-0060970DEBAE")
MSMQEvent;
#endif

EXTERN_C const CLSID CLSID_MSMQQueueInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E07C-DCCD-11d0-AA4B-0060970DEBAE")
MSMQQueueInfo;
#endif

EXTERN_C const CLSID CLSID_MSMQQueueInfos;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E07E-DCCD-11d0-AA4B-0060970DEBAE")
MSMQQueueInfos;
#endif

#ifndef __IMSMQTransaction2_INTERFACE_DEFINED__
#define __IMSMQTransaction2_INTERFACE_DEFINED__

/* interface IMSMQTransaction2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQTransaction2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2CE0C5B0-6E67-11D2-B0E6-00E02C074F6B")
    IMSMQTransaction2 : public IMSMQTransaction
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ VARIANT varTransaction) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQTransaction2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQTransaction2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQTransaction2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQTransaction2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQTransaction2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQTransaction2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQTransaction2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQTransaction2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Transaction )( 
            IMSMQTransaction2 * This,
            /* [retval][out] */ long *plTransaction);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMSMQTransaction2 * This,
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *grfTC,
            /* [optional][in] */ VARIANT *grfRM);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IMSMQTransaction2 * This,
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *fAsync);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IMSMQTransaction2 * This,
            /* [in] */ VARIANT varTransaction);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQTransaction2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQTransaction2Vtbl;

    interface IMSMQTransaction2
    {
        CONST_VTBL struct IMSMQTransaction2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQTransaction2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQTransaction2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQTransaction2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQTransaction2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQTransaction2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQTransaction2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQTransaction2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQTransaction2_get_Transaction(This,plTransaction)	\
    (This)->lpVtbl -> get_Transaction(This,plTransaction)

#define IMSMQTransaction2_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define IMSMQTransaction2_Abort(This,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,fRetaining,fAsync)


#define IMSMQTransaction2_InitNew(This,varTransaction)	\
    (This)->lpVtbl -> InitNew(This,varTransaction)

#define IMSMQTransaction2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransaction2_InitNew_Proxy( 
    IMSMQTransaction2 * This,
    /* [in] */ VARIANT varTransaction);


void __RPC_STUB IMSMQTransaction2_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQTransaction2_get_Properties_Proxy( 
    IMSMQTransaction2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQTransaction2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQTransaction2_INTERFACE_DEFINED__ */


#ifndef __IMSMQTransaction3_INTERFACE_DEFINED__
#define __IMSMQTransaction3_INTERFACE_DEFINED__

/* interface IMSMQTransaction3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQTransaction3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b13-2168-11d3-898c-00e02c074f6b")
    IMSMQTransaction3 : public IMSMQTransaction2
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ITransaction( 
            /* [retval][out] */ VARIANT *pvarITransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQTransaction3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQTransaction3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQTransaction3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQTransaction3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQTransaction3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQTransaction3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQTransaction3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQTransaction3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Transaction )( 
            IMSMQTransaction3 * This,
            /* [retval][out] */ long *plTransaction);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMSMQTransaction3 * This,
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *grfTC,
            /* [optional][in] */ VARIANT *grfRM);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IMSMQTransaction3 * This,
            /* [optional][in] */ VARIANT *fRetaining,
            /* [optional][in] */ VARIANT *fAsync);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IMSMQTransaction3 * This,
            /* [in] */ VARIANT varTransaction);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQTransaction3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ITransaction )( 
            IMSMQTransaction3 * This,
            /* [retval][out] */ VARIANT *pvarITransaction);
        
        END_INTERFACE
    } IMSMQTransaction3Vtbl;

    interface IMSMQTransaction3
    {
        CONST_VTBL struct IMSMQTransaction3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQTransaction3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQTransaction3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQTransaction3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQTransaction3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQTransaction3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQTransaction3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQTransaction3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQTransaction3_get_Transaction(This,plTransaction)	\
    (This)->lpVtbl -> get_Transaction(This,plTransaction)

#define IMSMQTransaction3_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define IMSMQTransaction3_Abort(This,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,fRetaining,fAsync)


#define IMSMQTransaction3_InitNew(This,varTransaction)	\
    (This)->lpVtbl -> InitNew(This,varTransaction)

#define IMSMQTransaction3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)


#define IMSMQTransaction3_get_ITransaction(This,pvarITransaction)	\
    (This)->lpVtbl -> get_ITransaction(This,pvarITransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransaction3_get_ITransaction_Proxy( 
    IMSMQTransaction3 * This,
    /* [retval][out] */ VARIANT *pvarITransaction);


void __RPC_STUB IMSMQTransaction3_get_ITransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQTransaction3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQTransaction;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E080-DCCD-11d0-AA4B-0060970DEBAE")
MSMQTransaction;
#endif

#ifndef __IMSMQCoordinatedTransactionDispenser2_INTERFACE_DEFINED__
#define __IMSMQCoordinatedTransactionDispenser2_INTERFACE_DEFINED__

/* interface IMSMQCoordinatedTransactionDispenser2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQCoordinatedTransactionDispenser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b10-2168-11d3-898c-00e02c074f6b")
    IMSMQCoordinatedTransactionDispenser2 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [retval][out] */ IMSMQTransaction2 **ptransaction) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQCoordinatedTransactionDispenser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQCoordinatedTransactionDispenser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQCoordinatedTransactionDispenser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [retval][out] */ IMSMQTransaction2 **ptransaction);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQCoordinatedTransactionDispenser2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQCoordinatedTransactionDispenser2Vtbl;

    interface IMSMQCoordinatedTransactionDispenser2
    {
        CONST_VTBL struct IMSMQCoordinatedTransactionDispenser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQCoordinatedTransactionDispenser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQCoordinatedTransactionDispenser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQCoordinatedTransactionDispenser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQCoordinatedTransactionDispenser2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQCoordinatedTransactionDispenser2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQCoordinatedTransactionDispenser2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQCoordinatedTransactionDispenser2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQCoordinatedTransactionDispenser2_BeginTransaction(This,ptransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,ptransaction)

#define IMSMQCoordinatedTransactionDispenser2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQCoordinatedTransactionDispenser2_BeginTransaction_Proxy( 
    IMSMQCoordinatedTransactionDispenser2 * This,
    /* [retval][out] */ IMSMQTransaction2 **ptransaction);


void __RPC_STUB IMSMQCoordinatedTransactionDispenser2_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQCoordinatedTransactionDispenser2_get_Properties_Proxy( 
    IMSMQCoordinatedTransactionDispenser2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQCoordinatedTransactionDispenser2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQCoordinatedTransactionDispenser2_INTERFACE_DEFINED__ */


#ifndef __IMSMQCoordinatedTransactionDispenser3_INTERFACE_DEFINED__
#define __IMSMQCoordinatedTransactionDispenser3_INTERFACE_DEFINED__

/* interface IMSMQCoordinatedTransactionDispenser3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQCoordinatedTransactionDispenser3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b14-2168-11d3-898c-00e02c074f6b")
    IMSMQCoordinatedTransactionDispenser3 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [retval][out] */ IMSMQTransaction3 **ptransaction) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQCoordinatedTransactionDispenser3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQCoordinatedTransactionDispenser3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQCoordinatedTransactionDispenser3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [retval][out] */ IMSMQTransaction3 **ptransaction);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQCoordinatedTransactionDispenser3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQCoordinatedTransactionDispenser3Vtbl;

    interface IMSMQCoordinatedTransactionDispenser3
    {
        CONST_VTBL struct IMSMQCoordinatedTransactionDispenser3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQCoordinatedTransactionDispenser3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQCoordinatedTransactionDispenser3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQCoordinatedTransactionDispenser3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQCoordinatedTransactionDispenser3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQCoordinatedTransactionDispenser3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQCoordinatedTransactionDispenser3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQCoordinatedTransactionDispenser3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQCoordinatedTransactionDispenser3_BeginTransaction(This,ptransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,ptransaction)

#define IMSMQCoordinatedTransactionDispenser3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQCoordinatedTransactionDispenser3_BeginTransaction_Proxy( 
    IMSMQCoordinatedTransactionDispenser3 * This,
    /* [retval][out] */ IMSMQTransaction3 **ptransaction);


void __RPC_STUB IMSMQCoordinatedTransactionDispenser3_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQCoordinatedTransactionDispenser3_get_Properties_Proxy( 
    IMSMQCoordinatedTransactionDispenser3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQCoordinatedTransactionDispenser3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQCoordinatedTransactionDispenser3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQCoordinatedTransactionDispenser;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E082-DCCD-11d0-AA4B-0060970DEBAE")
MSMQCoordinatedTransactionDispenser;
#endif

#ifndef __IMSMQTransactionDispenser2_INTERFACE_DEFINED__
#define __IMSMQTransactionDispenser2_INTERFACE_DEFINED__

/* interface IMSMQTransactionDispenser2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQTransactionDispenser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b11-2168-11d3-898c-00e02c074f6b")
    IMSMQTransactionDispenser2 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [retval][out] */ IMSMQTransaction2 **ptransaction) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQTransactionDispenser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQTransactionDispenser2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQTransactionDispenser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQTransactionDispenser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQTransactionDispenser2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQTransactionDispenser2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQTransactionDispenser2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQTransactionDispenser2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IMSMQTransactionDispenser2 * This,
            /* [retval][out] */ IMSMQTransaction2 **ptransaction);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQTransactionDispenser2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQTransactionDispenser2Vtbl;

    interface IMSMQTransactionDispenser2
    {
        CONST_VTBL struct IMSMQTransactionDispenser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQTransactionDispenser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQTransactionDispenser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQTransactionDispenser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQTransactionDispenser2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQTransactionDispenser2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQTransactionDispenser2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQTransactionDispenser2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQTransactionDispenser2_BeginTransaction(This,ptransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,ptransaction)

#define IMSMQTransactionDispenser2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransactionDispenser2_BeginTransaction_Proxy( 
    IMSMQTransactionDispenser2 * This,
    /* [retval][out] */ IMSMQTransaction2 **ptransaction);


void __RPC_STUB IMSMQTransactionDispenser2_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQTransactionDispenser2_get_Properties_Proxy( 
    IMSMQTransactionDispenser2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQTransactionDispenser2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQTransactionDispenser2_INTERFACE_DEFINED__ */


#ifndef __IMSMQTransactionDispenser3_INTERFACE_DEFINED__
#define __IMSMQTransactionDispenser3_INTERFACE_DEFINED__

/* interface IMSMQTransactionDispenser3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQTransactionDispenser3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b15-2168-11d3-898c-00e02c074f6b")
    IMSMQTransactionDispenser3 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [retval][out] */ IMSMQTransaction3 **ptransaction) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQTransactionDispenser3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQTransactionDispenser3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQTransactionDispenser3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQTransactionDispenser3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQTransactionDispenser3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQTransactionDispenser3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQTransactionDispenser3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQTransactionDispenser3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IMSMQTransactionDispenser3 * This,
            /* [retval][out] */ IMSMQTransaction3 **ptransaction);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQTransactionDispenser3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQTransactionDispenser3Vtbl;

    interface IMSMQTransactionDispenser3
    {
        CONST_VTBL struct IMSMQTransactionDispenser3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQTransactionDispenser3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQTransactionDispenser3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQTransactionDispenser3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQTransactionDispenser3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQTransactionDispenser3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQTransactionDispenser3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQTransactionDispenser3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQTransactionDispenser3_BeginTransaction(This,ptransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,ptransaction)

#define IMSMQTransactionDispenser3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQTransactionDispenser3_BeginTransaction_Proxy( 
    IMSMQTransactionDispenser3 * This,
    /* [retval][out] */ IMSMQTransaction3 **ptransaction);


void __RPC_STUB IMSMQTransactionDispenser3_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQTransactionDispenser3_get_Properties_Proxy( 
    IMSMQTransactionDispenser3 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQTransactionDispenser3_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQTransactionDispenser3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQTransactionDispenser;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E084-DCCD-11d0-AA4B-0060970DEBAE")
MSMQTransactionDispenser;
#endif

#ifndef __IMSMQApplication_INTERFACE_DEFINED__
#define __IMSMQApplication_INTERFACE_DEFINED__

/* interface IMSMQApplication */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7D6E085-DCCD-11d0-AA4B-0060970DEBAE")
    IMSMQApplication : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE MachineIdOfMachineName( 
            /* [in] */ BSTR MachineName,
            /* [retval][out] */ BSTR *pbstrGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQApplication * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQApplication * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQApplication * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQApplication * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQApplication * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *MachineIdOfMachineName )( 
            IMSMQApplication * This,
            /* [in] */ BSTR MachineName,
            /* [retval][out] */ BSTR *pbstrGuid);
        
        END_INTERFACE
    } IMSMQApplicationVtbl;

    interface IMSMQApplication
    {
        CONST_VTBL struct IMSMQApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQApplication_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQApplication_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQApplication_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQApplication_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQApplication_MachineIdOfMachineName(This,MachineName,pbstrGuid)	\
    (This)->lpVtbl -> MachineIdOfMachineName(This,MachineName,pbstrGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication_MachineIdOfMachineName_Proxy( 
    IMSMQApplication * This,
    /* [in] */ BSTR MachineName,
    /* [retval][out] */ BSTR *pbstrGuid);


void __RPC_STUB IMSMQApplication_MachineIdOfMachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQApplication_INTERFACE_DEFINED__ */


#ifndef __IMSMQApplication2_INTERFACE_DEFINED__
#define __IMSMQApplication2_INTERFACE_DEFINED__

/* interface IMSMQApplication2 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQApplication2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12A30900-7300-11D2-B0E6-00E02C074F6B")
    IMSMQApplication2 : public IMSMQApplication
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE RegisterCertificate( 
            /* [optional][in] */ VARIANT *Flags,
            /* [optional][in] */ VARIANT *ExternalCertificate) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE MachineNameOfMachineId( 
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ BSTR *pbstrMachineName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MSMQVersionMajor( 
            /* [retval][out] */ short *psMSMQVersionMajor) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MSMQVersionMinor( 
            /* [retval][out] */ short *psMSMQVersionMinor) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MSMQVersionBuild( 
            /* [retval][out] */ short *psMSMQVersionBuild) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsDsEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pfIsDsEnabled) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQApplication2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQApplication2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQApplication2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQApplication2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQApplication2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQApplication2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQApplication2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQApplication2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *MachineIdOfMachineName )( 
            IMSMQApplication2 * This,
            /* [in] */ BSTR MachineName,
            /* [retval][out] */ BSTR *pbstrGuid);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *RegisterCertificate )( 
            IMSMQApplication2 * This,
            /* [optional][in] */ VARIANT *Flags,
            /* [optional][in] */ VARIANT *ExternalCertificate);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *MachineNameOfMachineId )( 
            IMSMQApplication2 * This,
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ BSTR *pbstrMachineName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MSMQVersionMajor )( 
            IMSMQApplication2 * This,
            /* [retval][out] */ short *psMSMQVersionMajor);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MSMQVersionMinor )( 
            IMSMQApplication2 * This,
            /* [retval][out] */ short *psMSMQVersionMinor);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MSMQVersionBuild )( 
            IMSMQApplication2 * This,
            /* [retval][out] */ short *psMSMQVersionBuild);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsDsEnabled )( 
            IMSMQApplication2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsDsEnabled);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQApplication2 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQApplication2Vtbl;

    interface IMSMQApplication2
    {
        CONST_VTBL struct IMSMQApplication2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQApplication2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQApplication2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQApplication2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQApplication2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQApplication2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQApplication2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQApplication2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQApplication2_MachineIdOfMachineName(This,MachineName,pbstrGuid)	\
    (This)->lpVtbl -> MachineIdOfMachineName(This,MachineName,pbstrGuid)


#define IMSMQApplication2_RegisterCertificate(This,Flags,ExternalCertificate)	\
    (This)->lpVtbl -> RegisterCertificate(This,Flags,ExternalCertificate)

#define IMSMQApplication2_MachineNameOfMachineId(This,bstrGuid,pbstrMachineName)	\
    (This)->lpVtbl -> MachineNameOfMachineId(This,bstrGuid,pbstrMachineName)

#define IMSMQApplication2_get_MSMQVersionMajor(This,psMSMQVersionMajor)	\
    (This)->lpVtbl -> get_MSMQVersionMajor(This,psMSMQVersionMajor)

#define IMSMQApplication2_get_MSMQVersionMinor(This,psMSMQVersionMinor)	\
    (This)->lpVtbl -> get_MSMQVersionMinor(This,psMSMQVersionMinor)

#define IMSMQApplication2_get_MSMQVersionBuild(This,psMSMQVersionBuild)	\
    (This)->lpVtbl -> get_MSMQVersionBuild(This,psMSMQVersionBuild)

#define IMSMQApplication2_get_IsDsEnabled(This,pfIsDsEnabled)	\
    (This)->lpVtbl -> get_IsDsEnabled(This,pfIsDsEnabled)

#define IMSMQApplication2_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_RegisterCertificate_Proxy( 
    IMSMQApplication2 * This,
    /* [optional][in] */ VARIANT *Flags,
    /* [optional][in] */ VARIANT *ExternalCertificate);


void __RPC_STUB IMSMQApplication2_RegisterCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_MachineNameOfMachineId_Proxy( 
    IMSMQApplication2 * This,
    /* [in] */ BSTR bstrGuid,
    /* [retval][out] */ BSTR *pbstrMachineName);


void __RPC_STUB IMSMQApplication2_MachineNameOfMachineId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_get_MSMQVersionMajor_Proxy( 
    IMSMQApplication2 * This,
    /* [retval][out] */ short *psMSMQVersionMajor);


void __RPC_STUB IMSMQApplication2_get_MSMQVersionMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_get_MSMQVersionMinor_Proxy( 
    IMSMQApplication2 * This,
    /* [retval][out] */ short *psMSMQVersionMinor);


void __RPC_STUB IMSMQApplication2_get_MSMQVersionMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_get_MSMQVersionBuild_Proxy( 
    IMSMQApplication2 * This,
    /* [retval][out] */ short *psMSMQVersionBuild);


void __RPC_STUB IMSMQApplication2_get_MSMQVersionBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_get_IsDsEnabled_Proxy( 
    IMSMQApplication2 * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsDsEnabled);


void __RPC_STUB IMSMQApplication2_get_IsDsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQApplication2_get_Properties_Proxy( 
    IMSMQApplication2 * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQApplication2_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQApplication2_INTERFACE_DEFINED__ */


#ifndef __IMSMQApplication3_INTERFACE_DEFINED__
#define __IMSMQApplication3_INTERFACE_DEFINED__

/* interface IMSMQApplication3 */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQApplication3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b1f-2168-11d3-898c-00e02c074f6b")
    IMSMQApplication3 : public IMSMQApplication2
    {
    public:
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ActiveQueues( 
            /* [retval][out] */ VARIANT *pvActiveQueues) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PrivateQueues( 
            /* [retval][out] */ VARIANT *pvPrivateQueues) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_DirectoryServiceServer( 
            /* [retval][out] */ BSTR *pbstrDirectoryServiceServer) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsConnected( 
            /* [retval][out] */ VARIANT_BOOL *pfIsConnected) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_BytesInAllQueues( 
            /* [retval][out] */ VARIANT *pvBytesInAllQueues) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_Machine( 
            /* [in] */ BSTR bstrMachine) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Machine( 
            /* [retval][out] */ BSTR *pbstrMachine) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Tidy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQApplication3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQApplication3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQApplication3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQApplication3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQApplication3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQApplication3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQApplication3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQApplication3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *MachineIdOfMachineName )( 
            IMSMQApplication3 * This,
            /* [in] */ BSTR MachineName,
            /* [retval][out] */ BSTR *pbstrGuid);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *RegisterCertificate )( 
            IMSMQApplication3 * This,
            /* [optional][in] */ VARIANT *Flags,
            /* [optional][in] */ VARIANT *ExternalCertificate);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *MachineNameOfMachineId )( 
            IMSMQApplication3 * This,
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ BSTR *pbstrMachineName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MSMQVersionMajor )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ short *psMSMQVersionMajor);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MSMQVersionMinor )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ short *psMSMQVersionMinor);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MSMQVersionBuild )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ short *psMSMQVersionBuild);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsDsEnabled )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsDsEnabled);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveQueues )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ VARIANT *pvActiveQueues);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateQueues )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ VARIANT *pvPrivateQueues);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryServiceServer )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ BSTR *pbstrDirectoryServiceServer);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnected )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsConnected);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_BytesInAllQueues )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ VARIANT *pvBytesInAllQueues);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_Machine )( 
            IMSMQApplication3 * This,
            /* [in] */ BSTR bstrMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Machine )( 
            IMSMQApplication3 * This,
            /* [retval][out] */ BSTR *pbstrMachine);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IMSMQApplication3 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IMSMQApplication3 * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Tidy )( 
            IMSMQApplication3 * This);
        
        END_INTERFACE
    } IMSMQApplication3Vtbl;

    interface IMSMQApplication3
    {
        CONST_VTBL struct IMSMQApplication3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQApplication3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQApplication3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQApplication3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQApplication3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQApplication3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQApplication3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQApplication3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQApplication3_MachineIdOfMachineName(This,MachineName,pbstrGuid)	\
    (This)->lpVtbl -> MachineIdOfMachineName(This,MachineName,pbstrGuid)


#define IMSMQApplication3_RegisterCertificate(This,Flags,ExternalCertificate)	\
    (This)->lpVtbl -> RegisterCertificate(This,Flags,ExternalCertificate)

#define IMSMQApplication3_MachineNameOfMachineId(This,bstrGuid,pbstrMachineName)	\
    (This)->lpVtbl -> MachineNameOfMachineId(This,bstrGuid,pbstrMachineName)

#define IMSMQApplication3_get_MSMQVersionMajor(This,psMSMQVersionMajor)	\
    (This)->lpVtbl -> get_MSMQVersionMajor(This,psMSMQVersionMajor)

#define IMSMQApplication3_get_MSMQVersionMinor(This,psMSMQVersionMinor)	\
    (This)->lpVtbl -> get_MSMQVersionMinor(This,psMSMQVersionMinor)

#define IMSMQApplication3_get_MSMQVersionBuild(This,psMSMQVersionBuild)	\
    (This)->lpVtbl -> get_MSMQVersionBuild(This,psMSMQVersionBuild)

#define IMSMQApplication3_get_IsDsEnabled(This,pfIsDsEnabled)	\
    (This)->lpVtbl -> get_IsDsEnabled(This,pfIsDsEnabled)

#define IMSMQApplication3_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)


#define IMSMQApplication3_get_ActiveQueues(This,pvActiveQueues)	\
    (This)->lpVtbl -> get_ActiveQueues(This,pvActiveQueues)

#define IMSMQApplication3_get_PrivateQueues(This,pvPrivateQueues)	\
    (This)->lpVtbl -> get_PrivateQueues(This,pvPrivateQueues)

#define IMSMQApplication3_get_DirectoryServiceServer(This,pbstrDirectoryServiceServer)	\
    (This)->lpVtbl -> get_DirectoryServiceServer(This,pbstrDirectoryServiceServer)

#define IMSMQApplication3_get_IsConnected(This,pfIsConnected)	\
    (This)->lpVtbl -> get_IsConnected(This,pfIsConnected)

#define IMSMQApplication3_get_BytesInAllQueues(This,pvBytesInAllQueues)	\
    (This)->lpVtbl -> get_BytesInAllQueues(This,pvBytesInAllQueues)

#define IMSMQApplication3_put_Machine(This,bstrMachine)	\
    (This)->lpVtbl -> put_Machine(This,bstrMachine)

#define IMSMQApplication3_get_Machine(This,pbstrMachine)	\
    (This)->lpVtbl -> get_Machine(This,pbstrMachine)

#define IMSMQApplication3_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#define IMSMQApplication3_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IMSMQApplication3_Tidy(This)	\
    (This)->lpVtbl -> Tidy(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_get_ActiveQueues_Proxy( 
    IMSMQApplication3 * This,
    /* [retval][out] */ VARIANT *pvActiveQueues);


void __RPC_STUB IMSMQApplication3_get_ActiveQueues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_get_PrivateQueues_Proxy( 
    IMSMQApplication3 * This,
    /* [retval][out] */ VARIANT *pvPrivateQueues);


void __RPC_STUB IMSMQApplication3_get_PrivateQueues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_get_DirectoryServiceServer_Proxy( 
    IMSMQApplication3 * This,
    /* [retval][out] */ BSTR *pbstrDirectoryServiceServer);


void __RPC_STUB IMSMQApplication3_get_DirectoryServiceServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_get_IsConnected_Proxy( 
    IMSMQApplication3 * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsConnected);


void __RPC_STUB IMSMQApplication3_get_IsConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_get_BytesInAllQueues_Proxy( 
    IMSMQApplication3 * This,
    /* [retval][out] */ VARIANT *pvBytesInAllQueues);


void __RPC_STUB IMSMQApplication3_get_BytesInAllQueues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_put_Machine_Proxy( 
    IMSMQApplication3 * This,
    /* [in] */ BSTR bstrMachine);


void __RPC_STUB IMSMQApplication3_put_Machine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_get_Machine_Proxy( 
    IMSMQApplication3 * This,
    /* [retval][out] */ BSTR *pbstrMachine);


void __RPC_STUB IMSMQApplication3_get_Machine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_Connect_Proxy( 
    IMSMQApplication3 * This);


void __RPC_STUB IMSMQApplication3_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_Disconnect_Proxy( 
    IMSMQApplication3 * This);


void __RPC_STUB IMSMQApplication3_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQApplication3_Tidy_Proxy( 
    IMSMQApplication3 * This);


void __RPC_STUB IMSMQApplication3_Tidy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQApplication3_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("D7D6E086-DCCD-11d0-AA4B-0060970DEBAE")
MSMQApplication;
#endif

#ifndef __IMSMQDestination_INTERFACE_DEFINED__
#define __IMSMQDestination_INTERFACE_DEFINED__

/* interface IMSMQDestination */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQDestination;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b16-2168-11d3-898c-00e02c074f6b")
    IMSMQDestination : public IDispatch
    {
    public:
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsOpen( 
            /* [retval][out] */ VARIANT_BOOL *pfIsOpen) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_IADs( 
            /* [retval][out] */ IDispatch **ppIADs) = 0;
        
        virtual /* [id][propputref][hidden] */ HRESULT STDMETHODCALLTYPE putref_IADs( 
            /* [in] */ IDispatch *pIADs) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ADsPath( 
            /* [retval][out] */ BSTR *pbstrADsPath) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_ADsPath( 
            /* [in] */ BSTR bstrADsPath) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_PathName( 
            /* [retval][out] */ BSTR *pbstrPathName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_PathName( 
            /* [in] */ BSTR bstrPathName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_FormatName( 
            /* [retval][out] */ BSTR *pbstrFormatName) = 0;
        
        virtual /* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE put_FormatName( 
            /* [in] */ BSTR bstrFormatName) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Destinations( 
            /* [retval][out] */ IDispatch **ppDestinations) = 0;
        
        virtual /* [id][propputref][hidden] */ HRESULT STDMETHODCALLTYPE putref_Destinations( 
            /* [in] */ IDispatch *pDestinations) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ IDispatch **ppcolProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQDestinationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQDestination * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQDestination * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQDestination * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQDestination * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQDestination * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQDestination * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQDestination * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IMSMQDestination * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMSMQDestination * This);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen )( 
            IMSMQDestination * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsOpen);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_IADs )( 
            IMSMQDestination * This,
            /* [retval][out] */ IDispatch **ppIADs);
        
        /* [id][propputref][hidden] */ HRESULT ( STDMETHODCALLTYPE *putref_IADs )( 
            IMSMQDestination * This,
            /* [in] */ IDispatch *pIADs);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ADsPath )( 
            IMSMQDestination * This,
            /* [retval][out] */ BSTR *pbstrADsPath);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_ADsPath )( 
            IMSMQDestination * This,
            /* [in] */ BSTR bstrADsPath);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_PathName )( 
            IMSMQDestination * This,
            /* [retval][out] */ BSTR *pbstrPathName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_PathName )( 
            IMSMQDestination * This,
            /* [in] */ BSTR bstrPathName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQDestination * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propput][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *put_FormatName )( 
            IMSMQDestination * This,
            /* [in] */ BSTR bstrFormatName);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Destinations )( 
            IMSMQDestination * This,
            /* [retval][out] */ IDispatch **ppDestinations);
        
        /* [id][propputref][hidden] */ HRESULT ( STDMETHODCALLTYPE *putref_Destinations )( 
            IMSMQDestination * This,
            /* [in] */ IDispatch *pDestinations);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            IMSMQDestination * This,
            /* [retval][out] */ IDispatch **ppcolProperties);
        
        END_INTERFACE
    } IMSMQDestinationVtbl;

    interface IMSMQDestination
    {
        CONST_VTBL struct IMSMQDestinationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQDestination_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQDestination_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQDestination_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQDestination_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQDestination_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQDestination_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQDestination_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQDestination_Open(This)	\
    (This)->lpVtbl -> Open(This)

#define IMSMQDestination_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IMSMQDestination_get_IsOpen(This,pfIsOpen)	\
    (This)->lpVtbl -> get_IsOpen(This,pfIsOpen)

#define IMSMQDestination_get_IADs(This,ppIADs)	\
    (This)->lpVtbl -> get_IADs(This,ppIADs)

#define IMSMQDestination_putref_IADs(This,pIADs)	\
    (This)->lpVtbl -> putref_IADs(This,pIADs)

#define IMSMQDestination_get_ADsPath(This,pbstrADsPath)	\
    (This)->lpVtbl -> get_ADsPath(This,pbstrADsPath)

#define IMSMQDestination_put_ADsPath(This,bstrADsPath)	\
    (This)->lpVtbl -> put_ADsPath(This,bstrADsPath)

#define IMSMQDestination_get_PathName(This,pbstrPathName)	\
    (This)->lpVtbl -> get_PathName(This,pbstrPathName)

#define IMSMQDestination_put_PathName(This,bstrPathName)	\
    (This)->lpVtbl -> put_PathName(This,bstrPathName)

#define IMSMQDestination_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQDestination_put_FormatName(This,bstrFormatName)	\
    (This)->lpVtbl -> put_FormatName(This,bstrFormatName)

#define IMSMQDestination_get_Destinations(This,ppDestinations)	\
    (This)->lpVtbl -> get_Destinations(This,ppDestinations)

#define IMSMQDestination_putref_Destinations(This,pDestinations)	\
    (This)->lpVtbl -> putref_Destinations(This,pDestinations)

#define IMSMQDestination_get_Properties(This,ppcolProperties)	\
    (This)->lpVtbl -> get_Properties(This,ppcolProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_Open_Proxy( 
    IMSMQDestination * This);


void __RPC_STUB IMSMQDestination_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_Close_Proxy( 
    IMSMQDestination * This);


void __RPC_STUB IMSMQDestination_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_IsOpen_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsOpen);


void __RPC_STUB IMSMQDestination_get_IsOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_IADs_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ IDispatch **ppIADs);


void __RPC_STUB IMSMQDestination_get_IADs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_putref_IADs_Proxy( 
    IMSMQDestination * This,
    /* [in] */ IDispatch *pIADs);


void __RPC_STUB IMSMQDestination_putref_IADs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_ADsPath_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ BSTR *pbstrADsPath);


void __RPC_STUB IMSMQDestination_get_ADsPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_put_ADsPath_Proxy( 
    IMSMQDestination * This,
    /* [in] */ BSTR bstrADsPath);


void __RPC_STUB IMSMQDestination_put_ADsPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_PathName_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ BSTR *pbstrPathName);


void __RPC_STUB IMSMQDestination_get_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_put_PathName_Proxy( 
    IMSMQDestination * This,
    /* [in] */ BSTR bstrPathName);


void __RPC_STUB IMSMQDestination_put_PathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_FormatName_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ BSTR *pbstrFormatName);


void __RPC_STUB IMSMQDestination_get_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_put_FormatName_Proxy( 
    IMSMQDestination * This,
    /* [in] */ BSTR bstrFormatName);


void __RPC_STUB IMSMQDestination_put_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_Destinations_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ IDispatch **ppDestinations);


void __RPC_STUB IMSMQDestination_get_Destinations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_putref_Destinations_Proxy( 
    IMSMQDestination * This,
    /* [in] */ IDispatch *pDestinations);


void __RPC_STUB IMSMQDestination_putref_Destinations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQDestination_get_Properties_Proxy( 
    IMSMQDestination * This,
    /* [retval][out] */ IDispatch **ppcolProperties);


void __RPC_STUB IMSMQDestination_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQDestination_INTERFACE_DEFINED__ */


#ifndef __IMSMQPrivateDestination_INTERFACE_DEFINED__
#define __IMSMQPrivateDestination_INTERFACE_DEFINED__

/* interface IMSMQPrivateDestination */
/* [object][dual][hidden][uuid] */ 


EXTERN_C const IID IID_IMSMQPrivateDestination;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eba96b17-2168-11d3-898c-00e02c074f6b")
    IMSMQPrivateDestination : public IDispatch
    {
    public:
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Handle( 
            /* [retval][out] */ VARIANT *pvarHandle) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_Handle( 
            /* [in] */ VARIANT varHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQPrivateDestinationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQPrivateDestination * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQPrivateDestination * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQPrivateDestination * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQPrivateDestination * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQPrivateDestination * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQPrivateDestination * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQPrivateDestination * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Handle )( 
            IMSMQPrivateDestination * This,
            /* [retval][out] */ VARIANT *pvarHandle);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Handle )( 
            IMSMQPrivateDestination * This,
            /* [in] */ VARIANT varHandle);
        
        END_INTERFACE
    } IMSMQPrivateDestinationVtbl;

    interface IMSMQPrivateDestination
    {
        CONST_VTBL struct IMSMQPrivateDestinationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQPrivateDestination_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQPrivateDestination_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQPrivateDestination_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQPrivateDestination_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQPrivateDestination_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQPrivateDestination_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQPrivateDestination_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQPrivateDestination_get_Handle(This,pvarHandle)	\
    (This)->lpVtbl -> get_Handle(This,pvarHandle)

#define IMSMQPrivateDestination_put_Handle(This,varHandle)	\
    (This)->lpVtbl -> put_Handle(This,varHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQPrivateDestination_get_Handle_Proxy( 
    IMSMQPrivateDestination * This,
    /* [retval][out] */ VARIANT *pvarHandle);


void __RPC_STUB IMSMQPrivateDestination_get_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQPrivateDestination_put_Handle_Proxy( 
    IMSMQPrivateDestination * This,
    /* [in] */ VARIANT varHandle);


void __RPC_STUB IMSMQPrivateDestination_put_Handle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQPrivateDestination_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQDestination;

#ifdef __cplusplus

class DECLSPEC_UUID("eba96b18-2168-11d3-898c-00e02c074f6b")
MSMQDestination;
#endif

#ifndef __IMSMQCollection_INTERFACE_DEFINED__
#define __IMSMQCollection_INTERFACE_DEFINED__

/* interface IMSMQCollection */
/* [object][oleautomation][dual][hidden][uuid] */ 


EXTERN_C const IID IID_IMSMQCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0188AC2F-ECB3-4173-9779-635CA2039C72")
    IMSMQCollection : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ VARIANT *pvarRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pCount) = 0;
        
        virtual /* [restricted][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IMSMQCollection * This,
            /* [in] */ VARIANT *Index,
            /* [retval][out] */ VARIANT *pvarRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMSMQCollection * This,
            /* [retval][out] */ long *pCount);
        
        /* [restricted][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            IMSMQCollection * This,
            /* [retval][out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } IMSMQCollectionVtbl;

    interface IMSMQCollection
    {
        CONST_VTBL struct IMSMQCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQCollection_Item(This,Index,pvarRet)	\
    (This)->lpVtbl -> Item(This,Index,pvarRet)

#define IMSMQCollection_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IMSMQCollection__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMSMQCollection_Item_Proxy( 
    IMSMQCollection * This,
    /* [in] */ VARIANT *Index,
    /* [retval][out] */ VARIANT *pvarRet);


void __RPC_STUB IMSMQCollection_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMSMQCollection_get_Count_Proxy( 
    IMSMQCollection * This,
    /* [retval][out] */ long *pCount);


void __RPC_STUB IMSMQCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id] */ HRESULT STDMETHODCALLTYPE IMSMQCollection__NewEnum_Proxy( 
    IMSMQCollection * This,
    /* [retval][out] */ IUnknown **ppunk);


void __RPC_STUB IMSMQCollection__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQCollection_INTERFACE_DEFINED__ */


#ifndef __IMSMQManagement_INTERFACE_DEFINED__
#define __IMSMQManagement_INTERFACE_DEFINED__

/* interface IMSMQManagement */
/* [object][dual][hidden][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BE5F0241-E489-4957-8CC4-A452FCF3E23E")
    IMSMQManagement : public IDispatch
    {
    public:
        virtual /* [id][helpstringcontext] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [optional][in] */ VARIANT *Machine,
            /* [optional][in] */ VARIANT *Pathname,
            /* [optional][in] */ VARIANT *FormatName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_FormatName( 
            /* [retval][out] */ BSTR *pbstrFormatName) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_Machine( 
            /* [retval][out] */ BSTR *pbstrMachine) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_MessageCount( 
            /* [retval][out] */ long *plMessageCount) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_ForeignStatus( 
            /* [retval][out] */ long *plForeignStatus) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_QueueType( 
            /* [retval][out] */ long *plQueueType) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_IsLocal( 
            /* [retval][out] */ VARIANT_BOOL *pfIsLocal) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_TransactionalStatus( 
            /* [retval][out] */ long *plTransactionalStatus) = 0;
        
        virtual /* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_BytesInQueue( 
            /* [retval][out] */ VARIANT *pvBytesInQueue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQManagement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQManagement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQManagement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQManagement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQManagement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IMSMQManagement * This,
            /* [optional][in] */ VARIANT *Machine,
            /* [optional][in] */ VARIANT *Pathname,
            /* [optional][in] */ VARIANT *FormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQManagement * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Machine )( 
            IMSMQManagement * This,
            /* [retval][out] */ BSTR *pbstrMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MessageCount )( 
            IMSMQManagement * This,
            /* [retval][out] */ long *plMessageCount);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ForeignStatus )( 
            IMSMQManagement * This,
            /* [retval][out] */ long *plForeignStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueType )( 
            IMSMQManagement * This,
            /* [retval][out] */ long *plQueueType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsLocal )( 
            IMSMQManagement * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsLocal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionalStatus )( 
            IMSMQManagement * This,
            /* [retval][out] */ long *plTransactionalStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BytesInQueue )( 
            IMSMQManagement * This,
            /* [retval][out] */ VARIANT *pvBytesInQueue);
        
        END_INTERFACE
    } IMSMQManagementVtbl;

    interface IMSMQManagement
    {
        CONST_VTBL struct IMSMQManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQManagement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQManagement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQManagement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQManagement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQManagement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQManagement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQManagement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQManagement_Init(This,Machine,Pathname,FormatName)	\
    (This)->lpVtbl -> Init(This,Machine,Pathname,FormatName)

#define IMSMQManagement_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQManagement_get_Machine(This,pbstrMachine)	\
    (This)->lpVtbl -> get_Machine(This,pbstrMachine)

#define IMSMQManagement_get_MessageCount(This,plMessageCount)	\
    (This)->lpVtbl -> get_MessageCount(This,plMessageCount)

#define IMSMQManagement_get_ForeignStatus(This,plForeignStatus)	\
    (This)->lpVtbl -> get_ForeignStatus(This,plForeignStatus)

#define IMSMQManagement_get_QueueType(This,plQueueType)	\
    (This)->lpVtbl -> get_QueueType(This,plQueueType)

#define IMSMQManagement_get_IsLocal(This,pfIsLocal)	\
    (This)->lpVtbl -> get_IsLocal(This,pfIsLocal)

#define IMSMQManagement_get_TransactionalStatus(This,plTransactionalStatus)	\
    (This)->lpVtbl -> get_TransactionalStatus(This,plTransactionalStatus)

#define IMSMQManagement_get_BytesInQueue(This,pvBytesInQueue)	\
    (This)->lpVtbl -> get_BytesInQueue(This,pvBytesInQueue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_Init_Proxy( 
    IMSMQManagement * This,
    /* [optional][in] */ VARIANT *Machine,
    /* [optional][in] */ VARIANT *Pathname,
    /* [optional][in] */ VARIANT *FormatName);


void __RPC_STUB IMSMQManagement_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_FormatName_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ BSTR *pbstrFormatName);


void __RPC_STUB IMSMQManagement_get_FormatName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_Machine_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ BSTR *pbstrMachine);


void __RPC_STUB IMSMQManagement_get_Machine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_MessageCount_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ long *plMessageCount);


void __RPC_STUB IMSMQManagement_get_MessageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_ForeignStatus_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ long *plForeignStatus);


void __RPC_STUB IMSMQManagement_get_ForeignStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_QueueType_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ long *plQueueType);


void __RPC_STUB IMSMQManagement_get_QueueType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_IsLocal_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsLocal);


void __RPC_STUB IMSMQManagement_get_IsLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_TransactionalStatus_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ long *plTransactionalStatus);


void __RPC_STUB IMSMQManagement_get_TransactionalStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQManagement_get_BytesInQueue_Proxy( 
    IMSMQManagement * This,
    /* [retval][out] */ VARIANT *pvBytesInQueue);


void __RPC_STUB IMSMQManagement_get_BytesInQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQManagement_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQManagement;

#ifdef __cplusplus

class DECLSPEC_UUID("39CE96FE-F4C5-4484-A143-4C2D5D324229")
MSMQManagement;
#endif

#ifndef __IMSMQOutgoingQueueManagement_INTERFACE_DEFINED__
#define __IMSMQOutgoingQueueManagement_INTERFACE_DEFINED__

/* interface IMSMQOutgoingQueueManagement */
/* [object][dual][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQOutgoingQueueManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64C478FB-F9B0-4695-8A7F-439AC94326D3")
    IMSMQOutgoingQueueManagement : public IMSMQManagement
    {
    public:
        virtual /* [propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ long *plState) = 0;
        
        virtual /* [propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_NextHops( 
            /* [retval][out] */ VARIANT *pvNextHops) = 0;
        
        virtual /* [helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE EodGetSendInfo( 
            /* [retval][out] */ IMSMQCollection **ppCollection) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE EodResend( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQOutgoingQueueManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQOutgoingQueueManagement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQOutgoingQueueManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQOutgoingQueueManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQOutgoingQueueManagement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQOutgoingQueueManagement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQOutgoingQueueManagement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQOutgoingQueueManagement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IMSMQOutgoingQueueManagement * This,
            /* [optional][in] */ VARIANT *Machine,
            /* [optional][in] */ VARIANT *Pathname,
            /* [optional][in] */ VARIANT *FormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Machine )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ BSTR *pbstrMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MessageCount )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ long *plMessageCount);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ForeignStatus )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ long *plForeignStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueType )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ long *plQueueType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsLocal )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsLocal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionalStatus )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ long *plTransactionalStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BytesInQueue )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ VARIANT *pvBytesInQueue);
        
        /* [propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ long *plState);
        
        /* [propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_NextHops )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ VARIANT *pvNextHops);
        
        /* [helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *EodGetSendInfo )( 
            IMSMQOutgoingQueueManagement * This,
            /* [retval][out] */ IMSMQCollection **ppCollection);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IMSMQOutgoingQueueManagement * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMSMQOutgoingQueueManagement * This);
        
        /* [helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *EodResend )( 
            IMSMQOutgoingQueueManagement * This);
        
        END_INTERFACE
    } IMSMQOutgoingQueueManagementVtbl;

    interface IMSMQOutgoingQueueManagement
    {
        CONST_VTBL struct IMSMQOutgoingQueueManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQOutgoingQueueManagement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQOutgoingQueueManagement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQOutgoingQueueManagement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQOutgoingQueueManagement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQOutgoingQueueManagement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQOutgoingQueueManagement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQOutgoingQueueManagement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQOutgoingQueueManagement_Init(This,Machine,Pathname,FormatName)	\
    (This)->lpVtbl -> Init(This,Machine,Pathname,FormatName)

#define IMSMQOutgoingQueueManagement_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQOutgoingQueueManagement_get_Machine(This,pbstrMachine)	\
    (This)->lpVtbl -> get_Machine(This,pbstrMachine)

#define IMSMQOutgoingQueueManagement_get_MessageCount(This,plMessageCount)	\
    (This)->lpVtbl -> get_MessageCount(This,plMessageCount)

#define IMSMQOutgoingQueueManagement_get_ForeignStatus(This,plForeignStatus)	\
    (This)->lpVtbl -> get_ForeignStatus(This,plForeignStatus)

#define IMSMQOutgoingQueueManagement_get_QueueType(This,plQueueType)	\
    (This)->lpVtbl -> get_QueueType(This,plQueueType)

#define IMSMQOutgoingQueueManagement_get_IsLocal(This,pfIsLocal)	\
    (This)->lpVtbl -> get_IsLocal(This,pfIsLocal)

#define IMSMQOutgoingQueueManagement_get_TransactionalStatus(This,plTransactionalStatus)	\
    (This)->lpVtbl -> get_TransactionalStatus(This,plTransactionalStatus)

#define IMSMQOutgoingQueueManagement_get_BytesInQueue(This,pvBytesInQueue)	\
    (This)->lpVtbl -> get_BytesInQueue(This,pvBytesInQueue)


#define IMSMQOutgoingQueueManagement_get_State(This,plState)	\
    (This)->lpVtbl -> get_State(This,plState)

#define IMSMQOutgoingQueueManagement_get_NextHops(This,pvNextHops)	\
    (This)->lpVtbl -> get_NextHops(This,pvNextHops)

#define IMSMQOutgoingQueueManagement_EodGetSendInfo(This,ppCollection)	\
    (This)->lpVtbl -> EodGetSendInfo(This,ppCollection)

#define IMSMQOutgoingQueueManagement_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IMSMQOutgoingQueueManagement_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMSMQOutgoingQueueManagement_EodResend(This)	\
    (This)->lpVtbl -> EodResend(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQOutgoingQueueManagement_get_State_Proxy( 
    IMSMQOutgoingQueueManagement * This,
    /* [retval][out] */ long *plState);


void __RPC_STUB IMSMQOutgoingQueueManagement_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQOutgoingQueueManagement_get_NextHops_Proxy( 
    IMSMQOutgoingQueueManagement * This,
    /* [retval][out] */ VARIANT *pvNextHops);


void __RPC_STUB IMSMQOutgoingQueueManagement_get_NextHops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQOutgoingQueueManagement_EodGetSendInfo_Proxy( 
    IMSMQOutgoingQueueManagement * This,
    /* [retval][out] */ IMSMQCollection **ppCollection);


void __RPC_STUB IMSMQOutgoingQueueManagement_EodGetSendInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQOutgoingQueueManagement_Resume_Proxy( 
    IMSMQOutgoingQueueManagement * This);


void __RPC_STUB IMSMQOutgoingQueueManagement_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQOutgoingQueueManagement_Pause_Proxy( 
    IMSMQOutgoingQueueManagement * This);


void __RPC_STUB IMSMQOutgoingQueueManagement_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQOutgoingQueueManagement_EodResend_Proxy( 
    IMSMQOutgoingQueueManagement * This);


void __RPC_STUB IMSMQOutgoingQueueManagement_EodResend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQOutgoingQueueManagement_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQOutgoingQueueManagement;

#ifdef __cplusplus

class DECLSPEC_UUID("0188401c-247a-4fed-99c6-bf14119d7055")
MSMQOutgoingQueueManagement;
#endif

#ifndef __IMSMQQueueManagement_INTERFACE_DEFINED__
#define __IMSMQQueueManagement_INTERFACE_DEFINED__

/* interface IMSMQQueueManagement */
/* [object][dual][helpstringcontext][uuid] */ 


EXTERN_C const IID IID_IMSMQQueueManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FBE7759-5760-444d-B8A5-5E7AB9A84CCE")
    IMSMQQueueManagement : public IMSMQManagement
    {
    public:
        virtual /* [propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE get_JournalMessageCount( 
            /* [retval][out] */ long *plJournalMessageCount) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BytesInJournal( 
            /* [retval][out] */ VARIANT *pvBytesInJournal) = 0;
        
        virtual /* [helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE EodGetReceiveInfo( 
            /* [retval][out] */ VARIANT *pvCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSMQQueueManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSMQQueueManagement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSMQQueueManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSMQQueueManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSMQQueueManagement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSMQQueueManagement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSMQQueueManagement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSMQQueueManagement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IMSMQQueueManagement * This,
            /* [optional][in] */ VARIANT *Machine,
            /* [optional][in] */ VARIANT *Pathname,
            /* [optional][in] */ VARIANT *FormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_FormatName )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ BSTR *pbstrFormatName);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_Machine )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ BSTR *pbstrMachine);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_MessageCount )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ long *plMessageCount);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_ForeignStatus )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ long *plForeignStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_QueueType )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ long *plQueueType);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_IsLocal )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsLocal);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_TransactionalStatus )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ long *plTransactionalStatus);
        
        /* [id][propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_BytesInQueue )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ VARIANT *pvBytesInQueue);
        
        /* [propget][helpstringcontext] */ HRESULT ( STDMETHODCALLTYPE *get_JournalMessageCount )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ long *plJournalMessageCount);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BytesInJournal )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ VARIANT *pvBytesInJournal);
        
        /* [helpstringcontext][hidden] */ HRESULT ( STDMETHODCALLTYPE *EodGetReceiveInfo )( 
            IMSMQQueueManagement * This,
            /* [retval][out] */ VARIANT *pvCollection);
        
        END_INTERFACE
    } IMSMQQueueManagementVtbl;

    interface IMSMQQueueManagement
    {
        CONST_VTBL struct IMSMQQueueManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSMQQueueManagement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSMQQueueManagement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSMQQueueManagement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSMQQueueManagement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSMQQueueManagement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSMQQueueManagement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSMQQueueManagement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSMQQueueManagement_Init(This,Machine,Pathname,FormatName)	\
    (This)->lpVtbl -> Init(This,Machine,Pathname,FormatName)

#define IMSMQQueueManagement_get_FormatName(This,pbstrFormatName)	\
    (This)->lpVtbl -> get_FormatName(This,pbstrFormatName)

#define IMSMQQueueManagement_get_Machine(This,pbstrMachine)	\
    (This)->lpVtbl -> get_Machine(This,pbstrMachine)

#define IMSMQQueueManagement_get_MessageCount(This,plMessageCount)	\
    (This)->lpVtbl -> get_MessageCount(This,plMessageCount)

#define IMSMQQueueManagement_get_ForeignStatus(This,plForeignStatus)	\
    (This)->lpVtbl -> get_ForeignStatus(This,plForeignStatus)

#define IMSMQQueueManagement_get_QueueType(This,plQueueType)	\
    (This)->lpVtbl -> get_QueueType(This,plQueueType)

#define IMSMQQueueManagement_get_IsLocal(This,pfIsLocal)	\
    (This)->lpVtbl -> get_IsLocal(This,pfIsLocal)

#define IMSMQQueueManagement_get_TransactionalStatus(This,plTransactionalStatus)	\
    (This)->lpVtbl -> get_TransactionalStatus(This,plTransactionalStatus)

#define IMSMQQueueManagement_get_BytesInQueue(This,pvBytesInQueue)	\
    (This)->lpVtbl -> get_BytesInQueue(This,pvBytesInQueue)


#define IMSMQQueueManagement_get_JournalMessageCount(This,plJournalMessageCount)	\
    (This)->lpVtbl -> get_JournalMessageCount(This,plJournalMessageCount)

#define IMSMQQueueManagement_get_BytesInJournal(This,pvBytesInJournal)	\
    (This)->lpVtbl -> get_BytesInJournal(This,pvBytesInJournal)

#define IMSMQQueueManagement_EodGetReceiveInfo(This,pvCollection)	\
    (This)->lpVtbl -> EodGetReceiveInfo(This,pvCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][helpstringcontext] */ HRESULT STDMETHODCALLTYPE IMSMQQueueManagement_get_JournalMessageCount_Proxy( 
    IMSMQQueueManagement * This,
    /* [retval][out] */ long *plJournalMessageCount);


void __RPC_STUB IMSMQQueueManagement_get_JournalMessageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IMSMQQueueManagement_get_BytesInJournal_Proxy( 
    IMSMQQueueManagement * This,
    /* [retval][out] */ VARIANT *pvBytesInJournal);


void __RPC_STUB IMSMQQueueManagement_get_BytesInJournal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][hidden] */ HRESULT STDMETHODCALLTYPE IMSMQQueueManagement_EodGetReceiveInfo_Proxy( 
    IMSMQQueueManagement * This,
    /* [retval][out] */ VARIANT *pvCollection);


void __RPC_STUB IMSMQQueueManagement_EodGetReceiveInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSMQQueueManagement_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MSMQQueueManagement;

#ifdef __cplusplus

class DECLSPEC_UUID("33b6d07e-f27d-42fa-b2d7-bf82e11e9374")
MSMQQueueManagement;
#endif
#endif /* __MSMQ_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\logindlg.cpp ===
// logindlg.cpp : implementation file
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "disdraw.h"
#include "logindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog


CLoginDlg::CLoginDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLoginDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLoginDlg)
	m_strLogin = _T("");
	//}}AFX_DATA_INIT
}


void CLoginDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoginDlg)
	DDX_Text(pDX, IDC_EDIT_LOGIN, m_strLogin);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
	//{{AFX_MSG_MAP(CLoginDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by disdraw.rc
//
#define IDC_CONTINUE                    3
#define IDD_DISDRAW_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_LOGIN                       129
#define IDC_EDIT_FRIEND                 1000
#define IDC_BUTTON_ATTACH               1001
#define IDC_RADIO_EXPRESS               1002
#define IDC_RADIO_RECOVERABLE           1003
#define IDC_DRAWAREA_SCRIBLLE           1004
#define IDC_EDIT_LOGIN                  1005
#define IDC_EDIT_FRIEND_COMPUTER        1005
#define IDC_RADIO_DS                    1006
#define IDC_RADIO_WORKGROUP             1007
#define IDC_STATIC_CHOOSE_DS            1009
#define IDC_STATIC_Q_LABEL              1010
#define IDC_STATIC_CHOOSE_MESSAGE       1011
#define IDC_STATIC_C_LABEL              1012

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxtempl.h>		// MFC collection classes
#include <afxole.h>			// MFC OLE support

#include "mq.h"				// MSMQ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\drawdlg.cpp ===
// drawdlg.cpp : implementation file
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "disdraw.h"
#include "drawdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_FORMAT_NAME_LEN 256

#define MAX_VAR       20


//
// Distributed draw queue type.
//
CLSID guidDrawType =
{ 0x151ceac0, 0xacb5, 0x11cf, { 0x8b, 0x51, 0x00, 0x20, 0xaf, 0x92, 0x95, 0x46 } };

/////////////////////////////////////////////////////////////////////////////
// CDisdrawDlg dialog

CDisdrawDlg::CDisdrawDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDisdrawDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDisdrawDlg)
	m_strFriend = _T("");
	m_iDelivery = 0;
	m_iRadioDS = 0;
	m_strRemoteComputerName = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDisdrawDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDisdrawDlg)
	DDX_Control(pDX, IDC_STATIC_C_LABEL, m_cComputerLabel);
	DDX_Control(pDX, IDCANCEL, m_CancelButton);
	DDX_Control(pDX, IDC_STATIC_Q_LABEL, m_cQueueLabel);
	DDX_Control(pDX, IDC_STATIC_CHOOSE_MESSAGE, m_cMessageFrame);
	DDX_Control(pDX, IDC_STATIC_CHOOSE_DS, m_cDsFrame);
	DDX_Control(pDX, IDC_RADIO_EXPRESS, m_cRadioExpress);
	DDX_Control(pDX, IDC_RADIO_DS, m_cRadioDS);
	DDX_Control(pDX, IDC_EDIT_FRIEND_COMPUTER, m_cComputerInput);
	DDX_Control(pDX, IDC_EDIT_FRIEND, m_cQueueInput);
	DDX_Control(pDX, IDC_CONTINUE, m_cContinueButton);
	DDX_Control(pDX, IDC_DRAWAREA_SCRIBLLE, m_drawScribble);
	DDX_Control(pDX, IDC_BUTTON_ATTACH, m_btnAttach);
	DDX_Text(pDX, IDC_EDIT_FRIEND, m_strFriend);
	DDV_MaxChars(pDX, m_strFriend, 50);
	DDX_Radio(pDX, IDC_RADIO_EXPRESS, m_iDelivery);
	DDX_Radio(pDX, IDC_RADIO_DS, m_iRadioDS);
	DDX_Text(pDX, IDC_EDIT_FRIEND_COMPUTER, m_strRemoteComputerName);
	DDV_MaxChars(pDX, m_strRemoteComputerName, 50);
    DDX_Control(pDX, IDC_RADIO_WORKGROUP, m_cRadioWorkgroup);
    DDX_Control(pDX, IDC_RADIO_RECOVERABLE, m_cRadioRecoverable);
	//}}AFX_DATA_MAP
    

}

BEGIN_MESSAGE_MAP(CDisdrawDlg, CDialog)
	//{{AFX_MSG_MAP(CDisdrawDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_ATTACH, OnButtonAttach)
	ON_EN_CHANGE(IDC_EDIT_FRIEND, OnChangeEditFriend)
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_CONTINUE, OnConnect)
	ON_EN_CHANGE(IDC_EDIT_FRIEND_COMPUTER, OnChangeEditFriendComputer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDisdrawDlg message handlers


BOOL LocateQueue(CString m_strLabel, WCHAR *wcsFormatName, DWORD dwNumChars)
{
	//
	// Set restrictions to locate the draw queue with the specified label
	//
	DWORD cProps = 0;
	MQPROPERTYRESTRICTION aPropRestriction[2];
	MQRESTRICTION Restriction;

	aPropRestriction[cProps].rel           = PREQ;
	aPropRestriction[cProps].prop          = PROPID_Q_TYPE;
	aPropRestriction[cProps].prval.vt      = VT_CLSID;
	aPropRestriction[cProps].prval.puuid   = &guidDrawType;
	cProps++;

	WCHAR wcsLabel[MQ_MAX_Q_LABEL_LEN];
	mbstowcs(wcsLabel, m_strLabel, MQ_MAX_Q_LABEL_LEN);
	aPropRestriction[cProps].rel           = PREQ;
	aPropRestriction[cProps].prop          = PROPID_Q_LABEL;
	aPropRestriction[cProps].prval.vt      = VT_LPWSTR;
	aPropRestriction[cProps].prval.pwszVal = wcsLabel;
	cProps++;

	Restriction.cRes = cProps;
	Restriction.paPropRes = aPropRestriction;


	//
	// Request the queue instance for the specified queue
	//
	cProps = 0;
	QUEUEPROPID aPropId[1];
	MQCOLUMNSET Column;
	
	aPropId[cProps] = PROPID_Q_INSTANCE;
	cProps++;

	Column.cCol = cProps;
	Column.aCol = aPropId;


	//
	// Locate the specified queue.
	//
	HANDLE hEnum;
	BOOL fFound = FALSE;
	HRESULT hr = MQLocateBegin(NULL, &Restriction, &Column, NULL, &hEnum);
	if (!FAILED(hr))
	{
	    MQPROPVARIANT aPropVar[1];
		DWORD cQueue = 1;
		hr = MQLocateNext(hEnum, &cQueue, aPropVar);
		if (!FAILED(hr) && cQueue > 0)
		{
			//
			// Obtain the format name for the located queue.
			//
			hr = MQInstanceToFormatName(aPropVar[0].puuid, wcsFormatName, &dwNumChars);
            MQFreeMemory(aPropVar[0].puuid);
			if (!FAILED(hr))
				fFound = TRUE;
		}

		MQLocateEnd(hEnum);
	}


    return fFound;
}


BOOL CDisdrawDlg::OpenReceiveQueue()
{
    //
    // Do not create the receiving queue if it already exists in the enterprise.
    //
    HRESULT hr;
	WCHAR wcsFormatName[MAX_FORMAT_NAME_LEN];
    if (!LocateQueue(m_strLogin, wcsFormatName, MAX_FORMAT_NAME_LEN))
    {
    	//
    	// Form the pathname to the receiving queue.
    	//
    	char mbsPathName[MQ_MAX_Q_NAME_LEN];
    	DWORD dwNumChars = MQ_MAX_Q_NAME_LEN;
    	GetComputerName(mbsPathName, &dwNumChars);
		strcat(mbsPathName, "\\");
		strcat(mbsPathName, m_strLogin);


    	//
    	// Prepare the receiving queue properties.
    	//
    	DWORD cProps = 0;
    	QUEUEPROPID  aPropId[3];
    	MQPROPVARIANT aPropVar[3];
	    MQQUEUEPROPS propsQueue;
	    
		WCHAR wcsPathName[MQ_MAX_Q_NAME_LEN];
		mbstowcs(wcsPathName, mbsPathName, MQ_MAX_Q_NAME_LEN);
	    aPropId[cProps]			 = PROPID_Q_PATHNAME;
	    aPropVar[cProps].vt		 = VT_LPWSTR;
	    aPropVar[cProps].pwszVal = wcsPathName;
	    cProps++;

	    aPropId[cProps]			 = PROPID_Q_TYPE;
	    aPropVar[cProps].vt		 = VT_CLSID;
	    aPropVar[cProps].puuid	 = &guidDrawType;
	    cProps++;

		WCHAR wcsLabel[MQ_MAX_Q_LABEL_LEN];
		mbstowcs(wcsLabel, m_strLogin, MQ_MAX_Q_LABEL_LEN);
	    aPropId[cProps]			 = PROPID_Q_LABEL;
	    aPropVar[cProps].vt		 = VT_LPWSTR;
	    aPropVar[cProps].pwszVal = wcsLabel;
	    cProps++;

	    propsQueue.cProp	= cProps;
	    propsQueue.aPropID	= aPropId;
	    propsQueue.aPropVar = aPropVar;
	    propsQueue.aStatus	= NULL;


	    //
	    // Create the receiving queue.
	    //
	    dwNumChars = MAX_FORMAT_NAME_LEN;
	    hr = MQCreateQueue(NULL, &propsQueue, wcsFormatName, &dwNumChars);	


	    //
	    // If the receiving queue already exists, obtain its format name.
	    //
	    if (hr == MQ_ERROR_QUEUE_EXISTS)
		    hr = MQPathNameToFormatName(wcsPathName, wcsFormatName, &dwNumChars);

	    if (FAILED(hr))
		    return FALSE;
    }

	//
	// Open the receiving queue (may need to retry due to replication latency).
	//
    int iCount = 0;
	while ((hr = MQOpenQueue(wcsFormatName, 
                             MQ_RECEIVE_ACCESS, 
                             MQ_DENY_NONE ,
                             &m_hqIncoming)) == MQ_ERROR_QUEUE_NOT_FOUND)
    {
		
        Sleep (500);
        iCount++;
        if (iCount >=30)
        {
            //
            // 15 seconds have past without locating the queue.
            // We will allow the user to stop openning attempts 
            //
            int iRes = MessageBox("Failed to locate receiving queue.\nDo you wish to keep searching",
                                NULL,
                                MB_YESNO);
            if(iRes == IDYES)
            {
                //
                // Continue searching.
                //
                iCount =0;
            }
            else
            {
                //
                // Stop searching
                //
                break;
            }
        }
    }

	if (FAILED(hr))
		return FALSE;


	return TRUE;
}


DWORD ReceiveUpdates(CDisdrawDlg *pDrawDlg)
{
   	//
	// Prepare the message properties to receive.
	//
	DWORD cProps = 0;
	MQMSGPROPS    propsMessage;
	MQPROPVARIANT aPropVar[2];
	MSGPROPID     aPropId[2];

	WCHAR wcsBody[MAX_MSG_BODY_LEN];
	aPropId[cProps]				= PROPID_M_BODY;
	aPropVar[cProps].vt			= VT_UI1 | VT_VECTOR;
	aPropVar[cProps].caub.cElems = sizeof(wcsBody);
	aPropVar[cProps].caub.pElems = (UCHAR *)wcsBody;
	cProps++;

    aPropId[cProps]				= PROPID_M_BODY_SIZE;
	aPropVar[cProps].vt			= VT_UI4;
	cProps++;

	propsMessage.cProp    = cProps;
	propsMessage.aPropID  = aPropId;
	propsMessage.aPropVar = aPropVar;
	propsMessage.aStatus  = NULL;


    //
    // Keep receiving updates sent to the incoming queue.
    //
    HRESULT hr;
    LINE line;
	char mbsBody[MAX_MSG_BODY_LEN + 1];

    while (TRUE)
    {
        //
        // Synchronously receive a message from the incoming queue.
        //
        hr = MQReceiveMessage(pDrawDlg->m_hqIncoming, INFINITE, 
                              MQ_ACTION_RECEIVE, &propsMessage, 
							  NULL, NULL, NULL, NULL);

		//
		// Determine if the message contains a keystroke or a line .
		//
        if (!FAILED(hr))
        {
			//
			// Convert the body to a multi-byte null-terminated string. 
			//
            UINT uNumChars = aPropVar[1].ulVal/sizeof(WCHAR);
			wcstombs(mbsBody, wcsBody, uNumChars);
			mbsBody[uNumChars] = '\0';

			//
			// Add the keystroke to the drawing.
			//
			if (uNumChars == 1)
            {
				pDrawDlg->m_drawScribble.AddKeystroke(mbsBody);
            }
			
			//
			// Add the received line to the drawing.
			//
			else
			{
        		sscanf(mbsBody, "%07ld%07ld%07ld%07ld", 
					   &line.ptStart.x, &line.ptStart.y, 
					   &line.ptEnd.x, &line.ptEnd.y);
				pDrawDlg->m_drawScribble.AddLine(line);
			}
        }
    }


    return 0;
}


BOOL CDisdrawDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
    
	//
	// Display the login name in the window title.
	//
	SetWindowText(m_strLogin);


	//
	// No queues are open yet.
	//
	m_hqIncoming = NULL;
	m_hqOutgoing = NULL;
                               
    //
    // Establish connection mode.
    //
    m_fDsEnabledLocaly = IsDsEnabledLocaly();

    if (!m_fDsEnabledLocaly)
    {
        //
        // DS is disabled. this is the right place to open the receiving Queue.
        // since we open a local private queue, this operation is not time consuming. 
        //
        //
	    // Open the receiving queue and receive incoming messages.
	    //
        
        if (OpenPrivateReceiveQueue())
        {
            startReceiveUpdateThread();
        }
	    else
        {
            //
            // Failed to open receiving queue.
            //
		    MessageBox("Can't open receiving queue.");
        }

    }

    initializeUi(m_fDsEnabledLocaly);

   	return TRUE;  // return TRUE  unless you set the focus to a control.
}


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDisdrawDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}


// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDisdrawDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


void CDisdrawDlg::SendKeystroke(UINT uChar)
{
	//
	// Send the keystroke to the friend, if any
	//
	if (m_hqOutgoing != NULL)
	{
		//
		// Prepare the message properties to send
		//
		DWORD cProps = 0;
		MQMSGPROPS    propsMessage;
		MQPROPVARIANT aPropVar[5];
		MSGPROPID     aPropId[5];

		WCHAR wcsBody[1];
		swprintf(wcsBody, L"%c", uChar); 
		aPropId[cProps]				= PROPID_M_BODY;
		aPropVar[cProps].vt			= VT_UI1 | VT_VECTOR;
		aPropVar[cProps].caub.cElems = sizeof(wcsBody);
		aPropVar[cProps].caub.pElems = (UCHAR *)wcsBody;
		cProps++;

		WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN];
		swprintf(wcsLabel, L"Key: %c", uChar);
		aPropId[cProps]				= PROPID_M_LABEL;
		aPropVar[cProps].vt			= VT_LPWSTR;
		aPropVar[cProps].pwszVal	= wcsLabel;
		cProps++;

        UpdateData(TRUE);
		aPropId[cProps]				= PROPID_M_DELIVERY;
		aPropVar[cProps].vt			= VT_UI1;
		aPropVar[cProps].bVal		= m_iDelivery;
		cProps++;

		aPropId[cProps]				= PROPID_M_PRIORITY;
		aPropVar[cProps].vt			= VT_UI1;
		aPropVar[cProps].bVal		= 4;
		cProps++;

		aPropId[cProps]				= PROPID_M_BODY_TYPE;
		aPropVar[cProps].vt			= VT_UI4;
		aPropVar[cProps].lVal		= (long)VT_BSTR;
		cProps++;

		propsMessage.cProp    = cProps;
		propsMessage.aPropID  = aPropId;
		propsMessage.aPropVar = aPropVar;
		propsMessage.aStatus  = NULL;


		//
		// Send the message to the outgoing queue
		//
		MQSendMessage(m_hqOutgoing, &propsMessage, NULL);
	}
}


void CDisdrawDlg::SendMouseMovement(LINE line)
{
	//
	// Send the line to the friend, if any
	//
	if (m_hqOutgoing != NULL)
	{
		//
		// Prepare the message properties to send
		//
		DWORD cProps = 0;
		MQMSGPROPS    propsMessage;
		MQPROPVARIANT aPropVar[5];
		MSGPROPID     aPropId[5];

		WCHAR wcsBody[MAX_MSG_BODY_LEN];
		swprintf(wcsBody, L"%07ld%07ld%07ld%07ld", 
				 line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y);
		aPropId[cProps]				= PROPID_M_BODY;
		aPropVar[cProps].vt			= VT_UI1 | VT_VECTOR;
		aPropVar[cProps].caub.cElems = sizeof(wcsBody);
		aPropVar[cProps].caub.pElems = (UCHAR *)wcsBody;
		cProps++;

		WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN];
		swprintf(wcsLabel, L"%ld,%ld To %ld,%ld", 
				 line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y);
		aPropId[cProps]				= PROPID_M_LABEL;
		aPropVar[cProps].vt			= VT_LPWSTR;
		aPropVar[cProps].pwszVal	= wcsLabel;
		cProps++;

        UpdateData(TRUE);
		aPropId[cProps]				= PROPID_M_DELIVERY;
		aPropVar[cProps].vt			= VT_UI1;
		aPropVar[cProps].bVal		= m_iDelivery;
		cProps++;

		aPropId[cProps]				= PROPID_M_PRIORITY;
		aPropVar[cProps].vt			= VT_UI1;
		aPropVar[cProps].bVal		= 3;
		cProps++;

		aPropId[cProps]				= PROPID_M_BODY_TYPE;
		aPropVar[cProps].vt			= VT_UI4;
		aPropVar[cProps].lVal		= (long)VT_BSTR;
		cProps++;

		propsMessage.cProp    = cProps;
		propsMessage.aPropID  = aPropId;
		propsMessage.aPropVar = aPropVar;
		propsMessage.aStatus  = NULL;


		//
		// Send the message to the outgoing queue
		//
		MQSendMessage(m_hqOutgoing, &propsMessage, NULL);
	}
}


void CDisdrawDlg::OnButtonAttach() 
{

    //
    // change cursor to hourglass - the constructor will change the cursor;
    // when the object goes out of scope the cursor will return back to normal
    //
    CWaitCursor wait ;
    WCHAR wcsFormatName[MAX_FORMAT_NAME_LEN];

	if(m_fDsEnabledLocaly && m_iRadioDS == 0) 
    {
        //
        // Connect with a computer using Standard mode. 
        //
        
        //
	    // Obtain the name of the friend.
	    //
	    UpdateData(TRUE);
	    m_strFriend.MakeUpper();
        //
        // Make sure the friend queue exists.
        //
	    if (!LocateQueue(m_strFriend, wcsFormatName, MAX_FORMAT_NAME_LEN))
	    {
		    AfxMessageBox("No such friend, sorry...");
		    return;
	    }
	    
        
    }
    else if(!m_fDsEnabledLocaly || m_iRadioDS == 1) 
    {
        //
        // Connect with a computer using Direct mode. 
        //
        
        //
	    // Obtain the name of the friend and the remote computer.
	    //
	    UpdateData(TRUE);
	    m_strFriend.MakeUpper();
        m_strRemoteComputerName.MakeUpper();


        //
        // Make sure the friend queue exists - since we are connecting to 
        // a private queue cann't obtain it's format name
        // through the DS we will asuume it exists and try to open it.
        //
       
	    //
	    // Open the friend queue for sending (using DIRECT mode)
        // Please Note:
        // Openning a remote queue for sending will always  
        // succeed even if the queue or computer does not exists
	    //  When working in direct mode, we must use private queues. 
        // We're unable to know whether a given private queue on another computer exists or not,
        // so here we'll just assume it does. To make the application more robust,
        // an acknowledgement queue should be created on the local computer, and
        // a request for acknowledgement messages should be added to the sent messages.
        // Then the application can notify the user when a NACK message is received.
        //

   
        //
        // Form the format name.
        //
        char mbsFormatName[MAX_FORMAT_NAME_LEN];
        sprintf(mbsFormatName,"DIRECT=OS:%s\\private$\\%s",m_strRemoteComputerName,m_strFriend);
        mbstowcs(wcsFormatName,mbsFormatName,MAX_FORMAT_NAME_LEN);

    }

    //
	// Open the remote queue for sending.
    // The action is the same in both cases.
	//
	HANDLE hqNewFriend;
	HRESULT hr = MQOpenQueue(wcsFormatName, MQ_SEND_ACCESS, MQ_DENY_NONE , &hqNewFriend);
	if (FAILED(hr))
		AfxMessageBox("Can't open remote queue.");

	else
	{
		//
		// Close the previous friend and update the window title.
		//
		if (m_hqOutgoing != NULL)
        {
			MQCloseQueue(m_hqOutgoing);
        }
		m_hqOutgoing = hqNewFriend;
		CString strTitle = m_strLogin + " connected to " + m_strFriend;
		SetWindowText(strTitle);
		m_btnAttach.EnableWindow(FALSE);
	}
    
}


void CDisdrawDlg::OnChangeEditFriend() 
{

	m_btnAttach.EnableWindow(TRUE);
}


void CDisdrawDlg::OnClose() 
{
	// TODO: Add your message handler code here and/or call default

	//
	// Close the open queues, if any
	//
	if (m_hqIncoming != NULL)
		MQCloseQueue(m_hqIncoming);

	if (m_hqOutgoing != NULL)
		MQCloseQueue(m_hqOutgoing);

	CDialog::OnClose();
}


BOOL CDisdrawDlg::IsDsEnabledLocaly()
/*++

Routine Description:
    
      The rutine checked if the local computer is in DS-enabled Mode
      or he is in a DS-disabled mode

Arguments:
    
      None

Return Value:
    
      TRUE     -  DS-enabled mode.
      FALSE    -  DS-disabled mode.

--*/

{
       
    MQPRIVATEPROPS PrivateProps;
    QMPROPID       aPropId[MAX_VAR];
    MQPROPVARIANT  aPropVar[MAX_VAR];
    DWORD          cProp;  
    HRESULT        hr;
    //
    // Prepare DS-enabled property.
    //
    cProp = 0;

    aPropId[cProp] = PROPID_PC_DS_ENABLED;
    aPropVar[cProp].vt = VT_NULL;
    ++cProp;	
    //
    // Create a PRIVATEPROPS structure.
    //
    PrivateProps.cProp = cProp;
	PrivateProps.aPropID = aPropId;
	PrivateProps.aPropVar = aPropVar;
    PrivateProps.aStatus = NULL;

    //
    // Retrieve the information.
    //
    

    //
    // This code is used to detect DS connection.
    // This code is designed to allow compilation both on 
    // NT4 and Windows 2000.
    //
    HINSTANCE hMqrtLibrary = GetModuleHandle(TEXT("mqrt.dll"));
	ASSERT(hMqrtLibrary != NULL);

    typedef HRESULT (APIENTRY *MQGetPrivateComputerInformation_ROUTINE)(LPCWSTR , MQPRIVATEPROPS*);
    MQGetPrivateComputerInformation_ROUTINE pfMQGetPrivateComputerInformation = 
          (MQGetPrivateComputerInformation_ROUTINE)GetProcAddress(hMqrtLibrary,
													 "MQGetPrivateComputerInformation");
    if(pfMQGetPrivateComputerInformation == NULL)
    {
        //
        // There is no entry point in the dll matching to this routine
        // it must be an old version of mqrt.dll -> product one.
        // It will be OK to handle this case as a case of DS-enabled mode.
        //
        return TRUE;
    }

	hr = pfMQGetPrivateComputerInformation(
				     NULL,
					 &PrivateProps);
	if(FAILED(hr))
	{
        //
        // We were not able to determine if DS is enabled or disabled
        // notify the user and assume the worst case - (i.e. we are DS-disasbled).
        //
        MessageBox("Unable to detect DS connection");        
        return FALSE;
    }                             
	
    
    if(PrivateProps.aPropVar[0].boolVal == 0)
    {
        //
        // DS-disabled.
        //
        return FALSE;
    }

    return TRUE;

}




void CDisdrawDlg::initializeUi(BOOL fConnectedToDS)
{
    if(fConnectedToDS)
    {
        //
        // DS is enabled show relevant controls.
        //
        m_cDsFrame.ShowWindow(SW_SHOW);
        m_cRadioDS.ShowWindow(SW_SHOW);
        m_cRadioWorkgroup.ShowWindow(SW_SHOW);
        m_cContinueButton.ShowWindow(SW_SHOW);
        m_CancelButton.ShowWindow(SW_SHOW);




    }
    else
    {
        //
        //DS is disabled show relevant controls. 
        //
        m_cMessageFrame.ShowWindow(SW_SHOW);
        m_cRadioExpress.ShowWindow(SW_SHOW);
        m_cRadioRecoverable.ShowWindow(SW_SHOW);
        m_cQueueInput.ShowWindow(SW_SHOW);
        m_cQueueLabel.ShowWindow(SW_SHOW);
        m_cComputerInput.ShowWindow(SW_SHOW);
        m_cComputerLabel.ShowWindow(SW_SHOW);
        m_CancelButton.ShowWindow(SW_SHOW);
        m_btnAttach.ShowWindow(SW_SHOW);
       

    }


}

void CDisdrawDlg::OnConnect() 
{
    //
    // See what the user select.
    //
    UpdateData(TRUE);
    if(m_iRadioDS == 0)
    {
        //
        // DS is enabled localy , the user selected to connect using Standard mode.
        //
        
         CWaitCursor wait ;

        //
	    // Open the receiving queue and receive incoming messages.
	    //
        
        if (OpenReceiveQueue())
        {
            startReceiveUpdateThread();                         
        }
	    else
        {
		    AfxMessageBox("Cannot open receiving queue.");
        }


        //
        // ->Hide relevant Controles.
        //
        m_cDsFrame.ShowWindow(SW_HIDE);
        m_cRadioDS.ShowWindow(SW_HIDE);
        m_cRadioWorkgroup.ShowWindow(SW_HIDE);
        m_cContinueButton.ShowWindow(SW_HIDE);

        //
        // -> show relevant controls.
        //
        
        m_cMessageFrame.ShowWindow(SW_SHOW);
        m_cRadioExpress.ShowWindow(SW_SHOW);
        m_cRadioRecoverable.ShowWindow(SW_SHOW);
        m_cQueueInput.ShowWindow(SW_SHOW);
        m_cQueueLabel.ShowWindow(SW_SHOW);
        
        m_CancelButton.ShowWindow(SW_SHOW);
        m_btnAttach.ShowWindow(SW_SHOW);
        
    }
    else//m_iRadio == 1
    {
        //
        // DS is enabled localy and the user selected to connect using Direct mode.
        //
        //
        // Change cursor to hourglass - the constructor will change the cursor
        // When the object goes out of scope the cursor will return back to normal.
        //
        CWaitCursor wait ;

        //
	    // Open the receiving private queue and receive incoming messages.
	    //
        
        if (OpenPrivateReceiveQueue())
        {
            startReceiveUpdateThread();
        }
	    else
        {
		    AfxMessageBox("Can't open receiving queue.");
        }


        
        //
        // ->Hide relevant Controls.
        //
        m_cDsFrame.ShowWindow(SW_HIDE);
        m_cRadioDS.ShowWindow(SW_HIDE);
        m_cRadioWorkgroup.ShowWindow(SW_HIDE);
        m_cContinueButton.ShowWindow(SW_HIDE);
        
        //
        //-> Show relevant Controles.
        //
        m_cMessageFrame.ShowWindow(SW_SHOW);
        m_cRadioExpress.ShowWindow(SW_SHOW);
        m_cRadioRecoverable.ShowWindow(SW_SHOW);
        m_cQueueInput.ShowWindow(SW_SHOW);
        m_cQueueLabel.ShowWindow(SW_SHOW);
        m_cComputerInput.ShowWindow(SW_SHOW);
        m_cComputerLabel.ShowWindow(SW_SHOW);
        m_CancelButton.ShowWindow(SW_SHOW);
        m_btnAttach.ShowWindow(SW_SHOW);

    }

	
}

BOOL CDisdrawDlg::OpenPrivateReceiveQueue()
{ 
   
    //
    // Form the pathname to the receiving queue - make it private.
    //
    char mbsPathName[MQ_MAX_Q_NAME_LEN];
    DWORD dwNumChars = MQ_MAX_Q_NAME_LEN;
    GetComputerName(mbsPathName, &dwNumChars);
	strcat(mbsPathName, "\\");
    strcat(mbsPathName,"private$");
    strcat(mbsPathName, "\\");
	strcat(mbsPathName, m_strLogin);


    //
    // Prepare the receiving queue properties.
    //
    DWORD cProps = 0;
    QUEUEPROPID  aPropId[3];
    MQPROPVARIANT aPropVar[3];
	MQQUEUEPROPS propsQueue;
	
	WCHAR wcsPathName[MQ_MAX_Q_NAME_LEN];
	mbstowcs(wcsPathName, mbsPathName, MQ_MAX_Q_NAME_LEN);
	aPropId[cProps]			 = PROPID_Q_PATHNAME;
	aPropVar[cProps].vt		 = VT_LPWSTR;
	aPropVar[cProps].pwszVal = wcsPathName;
	cProps++;

	aPropId[cProps]			 = PROPID_Q_TYPE;
	aPropVar[cProps].vt		 = VT_CLSID;
	aPropVar[cProps].puuid	 = &guidDrawType;
	cProps++;

	WCHAR wcsLabel[MQ_MAX_Q_LABEL_LEN];
	mbstowcs(wcsLabel, m_strLogin, MQ_MAX_Q_LABEL_LEN);
	aPropId[cProps]			 = PROPID_Q_LABEL;
	aPropVar[cProps].vt		 = VT_LPWSTR;
	aPropVar[cProps].pwszVal = wcsLabel;
	cProps++;

	propsQueue.cProp	= cProps;
	propsQueue.aPropID	= aPropId;
	propsQueue.aPropVar = aPropVar;
	propsQueue.aStatus	= NULL;


	//
	// Create the receiving queue.
	//
    WCHAR wcsFormatName[MAX_FORMAT_NAME_LEN];
	dwNumChars = MAX_FORMAT_NAME_LEN;
	HRESULT hr = MQCreateQueue(NULL, &propsQueue, wcsFormatName, &dwNumChars);


	if (FAILED(hr) && hr != MQ_ERROR_QUEUE_EXISTS)
    {
		return FALSE;
    }


    if( hr ==  MQ_ERROR_QUEUE_EXISTS)
    {
       	//
    	// If the receiving queue already exists, create a format name.
	    //
        
        WCHAR wcsLoginName[MQ_MAX_Q_NAME_LEN];
        mbstowcs(wcsLoginName, m_strLogin, MQ_MAX_Q_LABEL_LEN);
        swprintf(wcsFormatName,L"DIRECT=OS:.\\private$\\%s",wcsLoginName);

    }

   	//
	// Open the receiving queue ( local private queue).
	//

	hr = MQOpenQueue(wcsFormatName, 
                             MQ_RECEIVE_ACCESS, 
                             MQ_DENY_NONE , 
                             &m_hqIncoming);

	if (FAILED(hr))
    {
		return FALSE;
    }
    return TRUE;

}

void CDisdrawDlg::OnChangeEditFriendComputer() 
{
    //
    // Allow to attach to another remote computer .
    //
	m_btnAttach.EnableWindow(TRUE);
	
}


void CDisdrawDlg::startReceiveUpdateThread()
{
    DWORD dwThreadID=NULL;
    CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE)ReceiveUpdates,
                 this,
                 0,
                 &dwThreadID);
    if( dwThreadID == NULL)
    {
       MessageBox("The system failed to initialize receiving queue.\nNo Drawing will be received");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\drawdlg.h ===
// drawdlg.h : header file
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "drawarea.h"

/////////////////////////////////////////////////////////////////////////////
// CDisdrawDlg dialog

class CDisdrawDlg : public CDialog
{
// Construction
public:
	
	
	CDisdrawDlg(CWnd* pParent = NULL);	// standard constructor

	void SendMouseMovement(LINE lineNew);
	void SendKeystroke(UINT uChar);

// Data
	CString m_strLogin;
	HANDLE m_hqIncoming;
	HANDLE m_hqOutgoing;

// Dialog Data
	//{{AFX_DATA(CDisdrawDlg)
	enum { IDD = IDD_DISDRAW_DIALOG };
	CStatic	m_cComputerLabel;
	CButton	m_CancelButton;
	CStatic	m_cQueueLabel;
	CButton	m_cMessageFrame;
	CButton	m_cDsFrame;
	CButton	m_cRadioExpress;
	CButton	m_cRadioDS;
	CEdit	m_cComputerInput;
	CEdit	m_cQueueInput;
	CButton	m_cContinueButton;
	CDrawArea	m_drawScribble;
	CButton	m_btnAttach;
	CString	m_strFriend;
	int		m_iDelivery;
	int		m_iRadioDS;
	CString	m_strRemoteComputerName;
    CButton	m_cRadioWorkgroup;
    CButton	m_cRadioRecoverable;
	//}}AFX_DATA
    


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDisdrawDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void startReceiveUpdateThread();
	BOOL OpenPrivateReceiveQueue();
	void initializeUi(BOOL fConnectedToDS);
	HICON m_hIcon;

	BOOL OpenReceiveQueue();
    BOOL IsDsEnabledLocaly();


	// Generated message map functions
	//{{AFX_MSG(CDisdrawDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnButtonAttach();
	afx_msg void OnChangeEditFriend();
	afx_msg void OnClose();
	afx_msg void OnConnect();
	afx_msg void OnChangeEditFriendComputer();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	BOOL m_fDsEnabledLocaly;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	disdraw.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\c_draw\logindlg.h ===
// logindlg.h : header file
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog

class CLoginDlg : public CDialog
{
// Construction
public:
	CLoginDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLoginDlg)
	enum { IDD = IDD_LOGIN };
	CString	m_strLogin;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoginDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLoginDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\drawarea.cpp ===
// drawarea.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "Imp_draw.h"
#include "Imp_dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDrawArea

CDrawArea::CDrawArea()
{
}

CDrawArea::~CDrawArea()
{
}


BEGIN_MESSAGE_MAP(CDrawArea, CEdit)
	//{{AFX_MSG_MAP(CDrawArea)
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_PAINT()
	ON_WM_RBUTTONUP()
	ON_WM_CTLCOLOR_REFLECT()
	ON_WM_KEYDOWN()
	ON_WM_CHAR()
	ON_WM_SETFOCUS()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDrawArea message handlers

void CDrawArea::AddKeystroke(char *mbsKey)
{
	//
	// The backspace keystroke should erase the last character
	//
	if (mbsKey[0] == VK_BACK)
	{
		int nStart, nEnd;
		GetSel(nStart, nEnd);
		SetSel(nEnd-1, nEnd);
		mbsKey[0] = '\0';

        //
        // Erasing a line feed should erase the preceding carriage return
        //
        CString strText;
        GetWindowText(strText);
        int iLength = strText.GetLength();
        if (iLength > 0 && strText.GetAt(strText.GetLength() - 1) == '\n')
            SetSel(nEnd-2, nEnd);
	}

	//
	// Append a line feed to a carriage return
	//
	else if (mbsKey[0] == VK_RETURN)
		strcat(mbsKey, "\xa");

	//
	// Store the new keystroke
	//
	ReplaceSel(mbsKey);
}


void CDrawArea::AddLine(LINE line)
{
	//
	// Set the clipping region for the drawing
	//
	CClientDC dc(this);
	RECT rect;
	GetClientRect(&rect);
	CRgn rgn;
	rgn.CreateRectRgnIndirect(&rect); 
	dc.SelectClipRgn(&rgn);

	//
	// Draw the line and save it for redrawing
	//
	dc.MoveTo(line.ptStart);
	dc.LineTo(line.ptEnd);
    m_listLines.AddTail(line);
}


void CDrawArea::OnLButtonDown(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	m_ptLast = point;
	SetFocus();
}


void CDrawArea::OnMouseMove(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	if (nFlags & MK_LBUTTON)
	{
		//
		// Add the drawn line to the drawing
		//
		LINE line;
		line.ptStart = m_ptLast;
		line.ptEnd = point;
        AddLine(line);

		//
		// Send the line to the friend
		//
		((CImp_DrawDlg *)GetParent())->SendMouseMovement(line);

		//
		// Remember the end point of the line 
		//
		m_ptLast = point;
	}
}


void CDrawArea::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here

	//
	// Set the clipping region for the drawing
	//
	RECT rect;
	GetClientRect(&rect);
	CRgn rgn;
	rgn.CreateRectRgnIndirect(&rect); 
	dc.SelectClipRgn(&rgn);

	//
	// Erase the drawing area
	//
	dc.FillSolidRect(&rect, GetSysColor(COLOR_MENU));

	//
	// Redisplay the text
	//
    CString strText;
    GetWindowText(strText);
    dc.SelectStockObject(ANSI_VAR_FONT);
    rect.top++;
    rect.left++;
    dc.DrawText(strText, &rect, DT_TOP | DT_WORDBREAK);

	//
	// Redraw each line
	//
	LINE line;
	POSITION posLine = m_listLines.GetHeadPosition();
	while (posLine != NULL)
	{
		line = m_listLines.GetNext(posLine);
		dc.MoveTo(line.ptStart);
		dc.LineTo(line.ptEnd);
	}

	// Do not call CEdit::OnPaint() for painting messages
}


void CDrawArea::OnRButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	//
	// Clear the drawing area
	//
	SetSel(0, -1);
	Clear();
	m_listLines.RemoveAll();
	RedrawWindow();
}


BOOL CDrawArea::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	// TODO: Add your message handler code here and/or call default
	
	return 0;
}


void CDrawArea::OnSetFocus(CWnd* pOldWnd) 
{
	CEdit::OnSetFocus(pOldWnd);
	
	// TODO: Add your message handler code here

	HideCaret();
}


HBRUSH CDrawArea::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	// TODO: Change any attributes of the DC here
	pDC->SetBkColor(GetSysColor(COLOR_MENU));
	
	// TODO: Return a non-NULL brush if the parent's handler should not be called
	return HBRUSH((CBrush *)pDC->SelectStockObject(LTGRAY_BRUSH));
}


void CDrawArea::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default

	switch (nChar)
	{
	case VK_LEFT:
	case VK_RIGHT:
	case VK_UP:
	case VK_DOWN:	
	case VK_HOME:	break;
	default:		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}


void CDrawArea::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	((CImp_DrawDlg *)GetParent())->SendKeystroke(nChar);
	
	CEdit::OnChar(nChar, nRepCnt, nFlags);

	RedrawWindow();
}


void CDrawArea::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\direncrypt\direncrypt.cpp ===
//
// file:  drctencp.cpp
//
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=




#include <windows.h>
#include <wincrypt.h>
#include <STDIO.H>
#include <mq.h>


//
// Globals.
//

BOOL   fEnhEncrypted = FALSE ;
QMPROPID propidPK = PROPID_QM_ENCRYPTION_PK;
WCHAR  wszMachineName[ 128 ] = {0} ;




void Usage(char * pszProgramName)
{
    fprintf(stderr, "...Usage:  %s\n", pszProgramName);
    fprintf(stderr, "\t-2 send encrypted, RC2\n") ;
    fprintf(stderr, "\t-4 send encrypted, RC4\n") ;
    fprintf(stderr, "\t-b <Message Body>\n") ;
    fprintf(stderr, "\t-e Enhanced Encryption\n") ;
    fprintf(stderr, "\t-l <Message Label>\n") ;
    fprintf(stderr, "\t-m <Name of destination machine>\n") ;
    fprintf(stderr, "\t-q <Queue name>\n") ;
    exit(1);
}

BOOL getPublicKeyBlob( PBYTE* pbPbKeyxKey, DWORD* pdwPbKeyxKeyLen)
/*++
  
Routine Description:    
    
    This routine retrieves the public key of the remote machine.
    The key is retrieved using the MQGetMachineProperties() API which connects to the Ds to retrieve 
    the specified properties .
    Usually when using Direct mode no DS connection is available.
    This routine comes only as a substitute to other means of obtaining the
    remote machine public key. (SSL protocol, via disk or file etc') .

Arguments:

    pbPbKeyxKey     - (OUT) pointer to the Key.
    pdwPbKeyxKeyLen - (OUT) pointer to the key length 

Return Value:

    TRUE  - if the Key was retreived .
    FALSE - if the Key couldn't be reteived.

--*/
{
    if (fEnhEncrypted)
    {
        propidPK = PROPID_QM_ENCRYPTION_PK_ENHANCED ;
    }

    QMPROPID aQmPropId[1] ;
    aQmPropId[0] = propidPK ;
    #define QMPROPS (sizeof(aQmPropId) / sizeof(*aQmPropId))

    MQPROPVARIANT aQmPropVar[QMPROPS];
    HRESULT       aQmStatus[QMPROPS];

    MQQMPROPS QmProps = {QMPROPS, aQmPropId, aQmPropVar, aQmStatus};

    aQmPropVar[0].vt = VT_NULL;

    HRESULT hr = MQGetMachineProperties(wszMachineName, NULL, &QmProps);
    if (FAILED(hr))
    {
        printf(
           "ERROR: Could not retrieve public key of %S, hr- %lxh\n",
                                                  wszMachineName, hr);

        return FALSE;
    }

    if (aQmPropVar[0].vt != (VT_UI1|VT_VECTOR))
    {
        printf(
        "Wrong VT after MQGetMachineProperties(), vt- %lxh, QMPROPS- %lut, hr- %lxh\n",
                                                 aQmPropVar[0].vt, QMPROPS, hr) ;
        return FALSE ;
    }

    *pbPbKeyxKey = aQmPropVar[0].caub.pElems;
    *pdwPbKeyxKeyLen = aQmPropVar[0].caub.cElems;

    return TRUE;
}


int main(int argc, char *argv[])
{
       
    DWORD  dwEncryptAlg = CALG_RC2 ;
    WCHAR  wszQueueName[ 128 ] = {0} ;
    WCHAR  wszMsgLabel[ 128 ] = {TEXT("MessageLabel")} ;
    WCHAR  wszMsgBody[ 128 ] = {TEXT("MessageBody")} ;
    LPSTR  lpszArg = NULL ;
    DWORD  dwMsgSize = sizeof(WCHAR) * (1 + wcslen(wszMsgBody)) ;
    DWORD  dwBufferSize = sizeof(wszMsgBody) ;
    LPWSTR pMsgBody = wszMsgBody ;

    //
    // allow the user to override settings with command line switches
    //
    for ( int i = 1; i < argc; i++)
    {
        if ((*argv[i] == '-') || (*argv[i] == '/'))
        {
            switch (*(argv[i]+1))
            {
            case '2':
                dwEncryptAlg = CALG_RC2 ;
                break ;

            case '4':
                dwEncryptAlg = CALG_RC4 ;
                break ;

            case 'e':
                fEnhEncrypted = TRUE ;
                break ;

            case 'b':
                lpszArg = argv[++i];
                mbstowcs(wszMsgBody, lpszArg, 127) ;
                break;

            case 'l':
                lpszArg = argv[++i];
                mbstowcs(wszMsgLabel, lpszArg, 127) ;
                break;

            case 'm':
                lpszArg = argv[++i];
                mbstowcs(wszMachineName, lpszArg, 127) ;
                break;

            case 'q':
                lpszArg = argv[++i];
                mbstowcs(wszQueueName, lpszArg, 127) ;
                break;

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
        {
            Usage(argv[0]);
        }
    }

    dwMsgSize = sizeof(WCHAR) * (1 + wcslen(wszMsgBody)) ;

    //
    // Get the public key blob of the destination computer.
    //

    PBYTE pbPbKeyxKey = NULL;
    DWORD dwPbKeyxKeyLen = 0;

    if (getPublicKeyBlob( &pbPbKeyxKey, &dwPbKeyxKeyLen))
    {
        printf("Public key of %S retrieved successfully, len- %lut\n",
                                     wszMachineName, dwPbKeyxKeyLen) ;

    }
    else
    {
        return -1 ;
    }

    //
    // Get a handle to the default CSP.
    //
    LPWSTR lpwszProviderName = MS_DEF_PROV ;
    if (fEnhEncrypted)
    {
        lpwszProviderName = MS_ENHANCED_PROV ;
    }
    HCRYPTPROV hProv = NULL;

    BOOL bRet = CryptAcquireContext( &hProv,
                                       NULL,
                                       lpwszProviderName,
                                       PROV_RSA_FULL,
                                       0 ) ;
    if (!bRet)
    {
        if (GetLastError() == NTE_BAD_KEYSET)
        {
            //
            // The default key container does not exist yet, create it.
            //
            if (!CryptAcquireContext( &hProv,
                                        NULL,
                                        lpwszProviderName,
                                        PROV_RSA_FULL,
                                        CRYPT_NEWKEYSET ))
            {
                printf(
                "CryptAcquireContext(%s, CRYPT_NEWKEYSET) failed, error- %lxh\n",
                                     lpwszProviderName, GetLastError());
                return -1;
            }
            printf("CryptAcquireContext(%s, CRYPT_NEWKEYSET) succeeded\n",
                                                       lpwszProviderName) ;
        }
        else
        {
            printf(
              "CryptAcquireContext(%s) failed, error- %lxh\n",
                                     lpwszProviderName, GetLastError());
            return -1;
        }
    }
    else
    {
        printf("CryptAcquireContext(%s) succeeded\n", lpwszProviderName) ;
    }

    //
    // Import the public key blob of the destination computer into the CSP.
    //
    HCRYPTKEY hPbKey = NULL;

    if (!CryptImportKey( hProv,
                         pbPbKeyxKey,
                         dwPbKeyxKeyLen,
                         NULL,
                         0,
                        &hPbKey ))
    {
        printf("CryptImportKey() failed, error- %lxh\n", GetLastError());
        return -1;
    }
    printf("CryptImportKey() succeeded\n") ;

    //
    // Free the public key blob of the destination computer.
    //
    MQFreeMemory(pbPbKeyxKey);

    //
    // Create a symmetric key.
    //                   
    HCRYPTKEY hSymmKey = NULL;

    if (!CryptGenKey(hProv, dwEncryptAlg, CRYPT_EXPORTABLE, &hSymmKey))
    {
        printf("CryptGenKey() failed, error- %lxh\n", GetLastError());
        return -1;
    }
    printf("CryptGenKey(alg- %lut) successfully created symmetric key\n",
                                                           dwEncryptAlg) ;
    //
    // Get the encrypted symmetric key blob. This blob should
    // be passed to MQSendMessage in PROPID_M_DEST_SYMM_KEY.
    //
    BYTE  abSymmKey[ 512 ];
    DWORD dwSymmKeyLen = sizeof(abSymmKey);

    if (!CryptExportKey( hSymmKey,
                         hPbKey,
                         SIMPLEBLOB,
                         0,
                         abSymmKey,
                         &dwSymmKeyLen ))
    {
        printf("CryptExportKey() failed, error- %lxh\n", GetLastError());
        return -1;
    }
    printf("CryptExportKey() succeeded\n") ;

    //
    // Get a handle to the destination queue.
    //
    WCHAR szQueueFormat[128];

    swprintf(szQueueFormat, TEXT("DIRECT=OS:%s\\%s"),
                                         wszMachineName, wszQueueName);

    QUEUEHANDLE hQueue = NULL;

    HRESULT hr = MQOpenQueue(szQueueFormat, MQ_SEND_ACCESS, 0, &hQueue);
    if (FAILED(hr))
    {
        printf("MQOpenQueue(%S) failed, error- %lxh\n", szQueueFormat, hr) ;
        return -1;
    }
    printf("MQOpenQueue(%S) succeeded\n", szQueueFormat) ;

    //
    // Prepare the message properties.
    //
	GUID guid ;

    MSGPROPID aMsgPropId[] = {PROPID_M_BODY,
                              PROPID_M_DEST_SYMM_KEY,
                              PROPID_M_ENCRYPTION_ALG,
                              PROPID_M_CONNECTOR_TYPE,
                              PROPID_M_LABEL,
                              PROPID_M_PRIV_LEVEL};
    #define MSGPROPS (sizeof(aMsgPropId) / sizeof(*aMsgPropId))

    MQPROPVARIANT aMsgPropVar[MSGPROPS];
    HRESULT       aMsgStatus[MSGPROPS];

    MQMSGPROPS MsgProps = {MSGPROPS, aMsgPropId, aMsgPropVar, aMsgStatus};

    aMsgPropVar[0].vt = VT_VECTOR | VT_UI1;
    aMsgPropVar[0].caub.pElems = (BYTE*) pMsgBody ;

    aMsgPropVar[1].vt = VT_VECTOR | VT_UI1;
    aMsgPropVar[1].caub.cElems = dwSymmKeyLen;
    aMsgPropVar[1].caub.pElems = abSymmKey;

    aMsgPropVar[2].vt = VT_UI4;
    aMsgPropVar[2].ulVal = dwEncryptAlg ;

    aMsgPropVar[3].vt = VT_CLSID;
	aMsgPropVar[3].puuid = &guid;

    aMsgPropVar[4].vt = VT_LPWSTR;
    aMsgPropVar[4].pwszVal = wszMsgLabel;

    //
    // The connector type (PROPID_M_CONNECTOR_TYPE) is not initialized
    // because it is assumed that nobody will bother about it on the
    // receiving side, otherwise it should be initialized.
    //

    //
    // Encrypt the line.
    //

    if (!CryptEncrypt( hSymmKey,
                       NULL,
                       TRUE,
                       0,
                       (BYTE*) pMsgBody,
                      &dwMsgSize,
                       dwBufferSize ))
    {
        printf("CryptEncrypt() failed, error- %lxh\n", GetLastError());
        return -1;
    }
    printf("CryptEncrypt() succeeded\n") ;

    //
    // Update the length of the message according to the result of the
    // encryption algorithm. RC4 may enlarge the message size. On the
    // destination, the message will be received as clear text with the
    // correct (original) message body size.
    //
    aMsgPropVar[0].caub.cElems = dwMsgSize ;
   
    aMsgPropVar[5].vt = VT_UI4;
    if(!fEnhEncrypted)
    {
        aMsgPropVar[5].ulVal= MQMSG_PRIV_LEVEL_NONE ;
    }
    else
    {
        aMsgPropVar[5].ulVal = MQMSG_PRIV_LEVEL_BODY_ENHANCED ;
    }
    MsgProps.cProp = MSGPROPS ;


    //
    // Send the mesasge.
    //
    hr = MQSendMessage(hQueue, &MsgProps, NULL);
    if (FAILED(hr))
    {
        printf("MQSendMessage() failed, hr- %lxh\n", hr) ;
		return -1;
    }	
    printf("MQSendMessage() succeeded\n") ;

    //
    // Free resources. This is actually not required here, it is just
    // to show how it should be done, if neccessary.
    //
    MQCloseQueue(hQueue);
    CryptDestroyKey(hSymmKey);
    CryptDestroyKey(hPbKey);
    CryptReleaseContext(hProv, 0);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\drawarea.h ===
// drawarea.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#include <afxtempl.h>

#define MAX_MSG_BODY_LEN 32

typedef struct tagLINE
{
	CPoint ptStart;
	CPoint ptEnd;
} LINE;

/////////////////////////////////////////////////////////////////////////////
// CDrawArea window

class CDrawArea : public CEdit
{
// Construction
public:
	CDrawArea();

// Attributes
public:

protected:
	CPoint m_ptLast;
	CList<LINE, LINE &> m_listLines;

// Operations
public:
	void AddLine(LINE line);
	void AddKeystroke(char *mbsKey);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDrawArea)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDrawArea();

	// Generated message map functions
protected:
	//{{AFX_MSG(CDrawArea)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\evhandle.cpp ===
// MQEventHandler.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#include "stdafx.h"
#include <afxdisp.h>
#include "Imp_Draw.h"
#include "Imp_Dlg.h"
#import <mqoa.tlb> no_namespace

// This is actually included in Imp_DrawDlg.h, but left here for reference purposes.
//#include "MQEventHandler.h"


// NOTE: DISP_FUNCTION_ID is a slighly unusual dispatch map macro, chosen because we
// neeed to specify the DispID of the functions we implement as well as the information
// normally given to the DISP_FUNCTION macro.

BEGIN_DISPATCH_MAP(CMSMQEventHandler, CCmdTarget)
	DISP_FUNCTION_ID(CMSMQEventHandler, "Arrived", 0, Arrived, VT_EMPTY, VTS_DISPATCH VTS_I4)
	DISP_FUNCTION_ID(CMSMQEventHandler, "ArrivedError", 1, ArrivedError, VT_EMPTY, VTS_DISPATCH VTS_I4 VTS_I4)
END_DISPATCH_MAP()


CMSMQEventHandler::CMSMQEventHandler()
{
	EnableAutomation();
	m_dwMyCookie = 0;
	m_pMyCP = NULL;
}

CMSMQEventHandler::~CMSMQEventHandler()
{
	if (m_pMyCP)	// If I'm currently connected to a connection point
	{
		m_pMyCP->Unadvise(m_dwMyCookie);	// Disconnect, giving it the identifier it gave me earlier,
		m_pMyCP->Release();					// and release it.
	};
	
}
//=--------------------------------------------------------------------------=
// CMSMQEventHandler::Arrived
// CMSMQEventHandler::ArrivedError
//=--------------------------------------------------------------------------=
// Purpose: These functions forward an "Arrived" or "ArrivedError" event from 
//			the queue to the event handler in the dialog code.
//  
//
// Parameters:
//    IDispatch*		-	The queue sending the event
//	  lCursor			-	Cursor value sent with the event.  Unused in
//							this function.
//
// Output:
//    none
//
// Notes:
//		These functions act nearly identically.  The only difference is if
//		a normal event arrives, S_OK is sent as the error code; if an
//		error event arrives, that error is passed on to the dialog's event
//		handler.
// 

void CMSMQEventHandler::Arrived(IDispatch* pdispQueue, long lCursor)
{
	CImp_DrawDlg* pDlg = (CImp_DrawDlg*) AfxGetApp()->m_pMainWnd;
	pDlg->Arrived(pdispQueue, S_OK, lCursor);
}

void CMSMQEventHandler::ArrivedError(IDispatch* pdispQueue, long lErrorCode, long lCursor)
{
	CImp_DrawDlg* pDlg = (CImp_DrawDlg*) AfxGetApp()->m_pMainWnd;
	pDlg->Arrived(pdispQueue, lErrorCode, lCursor);
}


//=--------------------------------------------------------------------------=
// CMSMQEventHandler::AdviseSource
//=--------------------------------------------------------------------------=
// Purpose: This function connects this class to an MSMQ connection point,
//			given an interface pointer to an MSMQ Event object.
//  
//
// Parameters:
//    IDispatch*	-	An MSMQ Event object to connect to
//
// Output:
//    HRESULT		-	S_OK if successful, otherwise any possible result from
//						QueryInterface, FindConnectionPoint, or Advise.
//
// Notes:
//		On the call to Advise, the GetIDispatch function (an MFC function) is 
//		called to retrieve the IDispatch pointer of this class in order to give
//		it to the connection point.  The cookie returned by Advise is stored
//		in a member variable, m_dwCookie.  The cookie is used when disconnecting
//		from the connection point, in the destructor.
// 

HRESULT CMSMQEventHandler::AdviseSource(IDispatch* pDispatch)
{
	LPCONNECTIONPOINTCONTAINER	pCPCont = NULL;
	HRESULT						hr;

	hr = pDispatch->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPCont);
	if (FAILED(hr))
		return hr;

	hr = pCPCont->FindConnectionPoint(__uuidof(_DMSMQEventEvents), &m_pMyCP);
	pCPCont->Release();
	if (FAILED(hr))
		return hr;

	return m_pMyCP->Advise(GetIDispatch(TRUE), &m_dwMyCookie);
};


//=--------------------------------------------------------------------------=
// CMSMQEventHandler::GetInterfaceHook
//=--------------------------------------------------------------------------=
// Purpose: This function is called by MFC's implementation of QueryInterface
//			and allows us to return our IDispatch interface in response to
//			DIID__DMSMQEventEvents
//  
//
// Parameters:
//    void*			-	IID that was passed to QueryInterface
//
// Output:
//    LPUNKNOWN		-	Our IDispatch if the passed iid is DIID__DMSMQEventEvents,
//						otherwise NULL.
//
// Notes:
//		CCmdTarget allows a derived class some control on the behavior of
//		QueryInterface. It calls this virtual function before it starts to
//		search in its map for the requested interface. This allows us to respond
//		with our IDispatch interface when requested for the sink interface
//		DIID__DMSMQEventEvents.
//		For other iid's we return NULL. This tells CCmdTarget to continue
//		the search for the interface in its maps
// 

LPUNKNOWN CMSMQEventHandler::GetInterfaceHook(const void* piid)
{
	if (IsEqualIID(__uuidof(_DMSMQEventEvents), *(IID*)piid))
	{
		return GetIDispatch(FALSE);
	}
	else
	{
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\imp_draw.cpp ===
// Imp_Draw.cpp : Defines the class behaviors for the application.
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "Imp_Draw.h"
#include "Imp_Dlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawApp

BEGIN_MESSAGE_MAP(CImp_DrawApp, CWinApp)
	//{{AFX_MSG_MAP(CImp_DrawApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawApp construction

CImp_DrawApp::CImp_DrawApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CImp_DrawApp object

CImp_DrawApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawApp initialization

BOOL CImp_DrawApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CImp_DrawDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\imp_draw.h ===
// Imp_Draw.h : main header file for the IMP_DRAW application
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#if !defined(AFX_IMP_DRAW_H__02EE0036_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_)
#define AFX_IMP_DRAW_H__02EE0036_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawApp:
// See Imp_Draw.cpp for the implementation of this class
//

class CImp_DrawApp : public CWinApp
{
public:
	CImp_DrawApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CImp_DrawApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CImp_DrawApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IMP_DRAW_H__02EE0036_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\imp_dlg.cpp ===
// Imp_DrawDlg.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#include "stdafx.h"
#include <afxdisp.h>
#include "Imp_Draw.h"
#include "Imp_Dlg.h"
#include "logindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawDlg dialog

CImp_DrawDlg::CImp_DrawDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CImp_DrawDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CImp_DrawDlg)
	m_csFriendName = _T("");
	m_iRadio = 0;
	//}}AFX_DATA_INIT
    m_iRadioDS = 0; 
    m_strRemoteComputerName = _T("");

	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	// Initialize my data members	
	m_vtguidDraw = "{151ceac0-acb5-11cf-8b51-0020af929546}";
	m_vtFriendName = "";
	m_pHandler = NULL;
}

CImp_DrawDlg::~CImp_DrawDlg()
{
	if (m_pHandler)
		delete m_pHandler;	// Handler's destructor will release event object
};

void CImp_DrawDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CImp_DrawDlg)
	DDX_Control(pDX, IDC_DRAWAREA_SCRIBLLE, m_drawScribble);
	DDX_Text(pDX, IDC_EDIT_FRIEND, m_csFriendName);
	DDV_MaxChars(pDX, m_csFriendName, 50);
	DDX_Radio(pDX, IDC_RADIO_EXPRESS, m_iRadio);
	DDX_Control(pDX, IDC_STATIC_C_LABEL, m_cComputerLabel);
	DDX_Control(pDX, IDCANCEL, m_CancelButton);
	DDX_Control(pDX, IDC_STATIC_Q_LABEL, m_cQueueLabel);
	DDX_Control(pDX, IDC_STATIC_CHOOSE_MESSAGE, m_cMessageFrame);
	DDX_Control(pDX, IDC_STATIC_CHOOSE_DS, m_cDsFrame);
	DDX_Control(pDX, IDC_RADIO_EXPRESS, m_cRadioExpress);
	DDX_Control(pDX, IDC_RADIO_DS, m_cRadioDS);
	DDX_Control(pDX, IDC_EDIT_FRIEND_COMPUTER, m_cComputerInput);
	DDX_Control(pDX, IDC_EDIT_FRIEND, m_cQueueInput);
	DDX_Control(pDX, IDC_CONTINUE, m_cContinueButton);
	DDX_Control(pDX, IDC_BUTTON_ATTACH, m_btnAttach);
	DDX_Radio(pDX, IDC_RADIO_DS, m_iRadioDS);
	DDX_Text(pDX, IDC_EDIT_FRIEND_COMPUTER, m_strRemoteComputerName);
	DDV_MaxChars(pDX, m_strRemoteComputerName, 50);
    DDX_Control(pDX, IDC_RADIO_WORKGROUP, m_cRadioWorkgroup);
    DDX_Control(pDX, IDC_RADIO_RECOVERABLE, m_cRadioRecoverable);
	//}}AFX_DATA_MAP
    
	

}

BEGIN_MESSAGE_MAP(CImp_DrawDlg, CDialog)
	//{{AFX_MSG_MAP(CImp_DrawDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_ATTACH, OnButtonAttach)
	ON_BN_CLICKED(IDC_CONTINUE, OnConnect)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//=--------------------------------------------------------------------------=
// CImp_DrawDlg::GetUserName
// CImp_DrawDlg::GetComputerName
//=--------------------------------------------------------------------------=
// Purpose: These functions wrap the GetUserName and GetComputerName Win32 APIs
//  
// Parameters:
//    none
//
// Output:
//    CString	-	the user name of the currently logged in user, or the
//					or the computer name of this computer.
//

CString CImp_DrawDlg::GetUserName()
{
	DWORD dwsize = 255;
	char username[255];
	if (::GetUserName(&username[0], &dwsize))
		return username;
	return "";
};

CString CImp_DrawDlg::GetComputerName()
{
	DWORD dwsize = 255;
	char username[255];
	if (::GetComputerName(&username[0], &dwsize))
		return username;
	return "";
}

//=--------------------------------------------------------------------------=
// CImp_DrawDlg::LoginPrompt
//=--------------------------------------------------------------------------=
// Purpose: This function pops up a login dialog and returns the name given
//  
//
// Parameters:
//    CString	-	This name will be given as a default name in the dialog
//
// Output:
//    CString	-	This is the name given by the user.
//
// 
CString CImp_DrawDlg::LoginPrompt(CString DefaultName)
{
	CLoginDlg	dialog;
	dialog.m_strLogin = DefaultName;
	UINT uId = dialog.DoModal();
    if (uId ==IDCANCEL)
    {
        //
        // exit
        //
        OnCancel();
    }
	return dialog.m_strLogin;
};

//=--------------------------------------------------------------------------=
// CImp_DrawDlg::SendMouseMovement
//=--------------------------------------------------------------------------=
// Purpose: This function sends my mouse movement information to the m_qFriend queue
//  
//
// Parameters:
//    LINE		-	this is a custom type defined in Drawarea.h
//
// Output:
//    none
//
// Notes:
//    This function encodes line data into a string, and passes that string
//		as the body of an MSMQ message.  This function is called by the 
//		CDrawArea class, which was ported from the MSMQ C_Draw sample.
// 
void CImp_DrawDlg::SendMouseMovement(LINE line)
{
	try
	{
		if (m_qFriend != NULL && m_qFriend->IsOpen)
		{
			m_msgOut->Priority = 3;

			/* Pack the data into one line (twice) */
			WCHAR wcsBody[MAX_MSG_BODY_LEN];
			swprintf(wcsBody, L"%07ld%07ld%07ld%07ld", 
					 line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y);

			WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN];
			swprintf(wcsLabel, L"%ld,%ld To %ld,%ld", 
					 line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y);

			/* Initialize a variant with the wcsbody data */
			_variant_t	vtBody(wcsBody);
			
			// Setup the message properties
			m_msgOut->Body = vtBody;
			m_msgOut->Label = wcsLabel;
			m_msgOut->Delivery = m_iRadio;

			// Send the message
			m_msgOut->Send(m_qFriend);
		};
	}
	catch(_com_error &comerr)
	{
		HandleErrors(comerr);
	};
};

//=--------------------------------------------------------------------------=
// CImp_DrawDlg::SendKeystroke
//=--------------------------------------------------------------------------=
// Purpose: This function sends my mouse movement information to the m_qFriend 
//			queue
//  
//
// Parameters:
//    uChar		-	Character value of keystroke to send.
//
// Output:
//    none
//
// Notes:
//    This function is a pretty straightforward way to send an MSMQ message.
//    This function is called by the CDrawArea class, which was ported from 
//	  the MSMQ C_Draw sample.
//
// 
void CImp_DrawDlg::SendKeystroke(UINT uChar)
{
	try
	{
		// First, the friend queue must be defined, and open
		if (m_qFriend != NULL && m_qFriend->IsOpen)
		{
			// Next, I push the character into a variant
			_variant_t vtChar((char*)&uChar);

			// Now I set up the message properties
			m_msgOut->Priority = 4;
			m_msgOut->Body = &vtChar;
			m_msgOut->Label = "Key: " + uChar;
			m_msgOut->Delivery = m_iRadio;

			// Lastly, I send the message
			m_msgOut->Send(m_qFriend);
		};
	}
	catch(_com_error &comerr)
	{
		HandleErrors(comerr);
	};
};

//=--------------------------------------------------------------------------=
// CImp_DrawDlg::Arrived
//=--------------------------------------------------------------------------=
// Purpose: This function handles events received from the opened queue.
//  
//
// Parameters:
//    IDispatch*		-	The queue sending the event
//	  lErrorCode		-	S_OK if no error, otherwise the error code sent
//							along with the queue event.
//	  lCursor			-	Cursor value sent with the event.  Unused in
//							this function.
//
// Output:
//    none
//
// Notes:
//    The queue is opened in the OnInitDialog() function.  An error event will
//	  popup a dialog and return from the function.  For a normal event I retrieve
//	  the message body, and interpret it either as a keystroke or as line data.
//	  Once you are finished handling an event you must signal your queue that you
//	  are ready to receive another event.
//
void CImp_DrawDlg::Arrived(IDispatch* pdispQueue, long lErrorCode, long lCursor)
{
	if (lErrorCode != S_OK)
	{
		// This code is what will run if the _DMSMQEventEvents->ArrivedError() Event is called
		char szErr[30]  = "";
		itoa(lErrorCode, szErr, 16);
		CString tempString = "Method returned HRESULT: ";
		tempString += szErr;
		MessageBox(tempString, NULL, MB_ICONSTOP | MB_OK);
		return;
	};

	IMSMQMessagePtr msgIn;
	LINE			line;
	char*			strTextIn = "";
	_variant_t		vtTimeout((short) 100);
	_bstr_t			btBody;


	try
	{
		IMSMQQueuePtr	q(pdispQueue);		// Creates a Queue smart pointer pointing to pdispQueue
		msgIn = q->Receive(&vtMissing, &vtMissing, &vtMissing, &vtTimeout);	// Any messages?
		btBody = msgIn->Body;				// copy message body to my own bstr
		strTextIn = (char*) btBody;			// convert to char*
		if (strlen(strTextIn) == 1)		
			m_drawScribble.AddKeystroke(strTextIn);
		else
		{
       		sscanf(strTextIn, "%07ld%07ld%07ld%07ld", 
				&line.ptStart.x, &line.ptStart.y, 
				&line.ptEnd.x, &line.ptEnd.y);
			m_drawScribble.AddLine(line);
		};
	}
	catch(_com_error &comerr)
	{
		HandleErrors(comerr);
	};

	m_queue->EnableNotification(m_qevent);		// IMPORTANT: Once you receive an event you must re-enable 
												// event notification
};


//=--------------------------------------------------------------------------=
// CImp_DrawDlg::HandleErrors
//=--------------------------------------------------------------------------=
// Purpose: This pops up an error dialog and aborts further execution
//  
//
// Parameters:
//    _com_error
//
// Output:
//    none
//
// Notes:
//    This demonstrates how to pull and HRESULT from the _com_error class.
//
void CImp_DrawDlg::HandleErrors(_com_error &comerr)
{
	HRESULT hr = comerr.Error();
	char szErr[30] = "";
	itoa(hr, szErr, 16);
	CString tempString = "Method returned HRESULT:0x";
	tempString += szErr;
	tempString += ".  Exiting.";
	MessageBox(tempString, NULL, MB_ICONSTOP | MB_OK);
	AfxAbort();
};

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawDlg message handlers

//=--------------------------------------------------------------------------=
// CImp_DrawDlg::OnInitDialog
//=--------------------------------------------------------------------------=
// Purpose: This handles the WM_INITDIALOG message by getting a login name 
//			from the user, opening their queue (creating it if need be) and
//			registering for events from that queue.
//  
//
// Parameters:
//    none
//
// Output:
//    BOOL	- to indicate success or failure to initialize the dialog.
//
// Notes:
//		This is the dialog initialization code.  The algorithm used in the try-catch 
//		block is taken from the MSMQ VB_Draw sample, in many cases on a 
//		line-for-line basis.
//

BOOL CImp_DrawDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
    
    //
    // Present Login dialog.
    //
    CString	csDefaultQueueName = GetUserName();
	m_csLogin = LoginPrompt(csDefaultQueueName);	
    while (m_csLogin == "")
    {
	    m_csLogin = LoginPrompt(csDefaultQueueName);
    }
    SetWindowText(m_csLogin);
    
    //
    // First, we have to initialize COM.
    //
	HRESULT hr = AfxOleInit();

    //
    // Establish DS connection status and set UI accordingly.
    //
    m_fDsEnabledLocaly = IsDsEnabledLocaly();

    if(!m_fDsEnabledLocaly)
    {
        //
        // DS is disabled. this is the right place to open the receiving Queue.
        // since we open a private queue, this operation is not time consuming. 
        //
        //
	    // Open the receiving queue and receive incoming messages.
	    //
        if (!OpenPrivateReceiveQueue())
        {
            //
            // Failed to open receiving Queue .
            //
            MessageBox("Can't open receiving queue.");

        }
    }
    initializeUI(m_fDsEnabledLocaly);
	
	
    return TRUE;  // return TRUE  unless you set the focus to a control
}

//=--------------------------------------------------------------------------=
// CImp_DrawDlg::OnButtonAttach
//=--------------------------------------------------------------------------=
// Purpose: This handles the Attach button by looking for the friend queue the
//			user has indicated, then opening that queue if possible.
//			
//
// Parameters:
//    none
//
// Output:
//    none
//
// Notes:
//		This is a straightforward way to look for a queue, then open it.
//		This is the last function modified for this project.  The next two
//		below were generated by MFC.
//

void CImp_DrawDlg::OnButtonAttach() 
{

    //
    // Change cursor to hourglass - the constructor will change the cursor;
    // When the object goes out of scope the cursor will return back to normal
    //
    CWaitCursor wait ;

    UpdateData(TRUE);
    IMSMQQueryPtr		queryFriend("MSMQ.MSMQQuery");	// Creates a Query object
	IMSMQQueueInfoPtr	qinfoFriend;
	IMSMQQueueInfosPtr	qinfos;

	try
    {

	    if(m_fDsEnabledLocaly && m_iRadioDS == 0) 
        {
            //
            // Connect with a  computer using Standard mode.
            //
            
		    m_csFriendName.MakeUpper();
		    m_vtFriendName = m_csFriendName;

            //
            // Locate the Queue.
            //
		    qinfos = queryFriend->LookupQueue(&vtMissing,&m_vtguidDraw, &m_vtFriendName);
		    qinfos->Reset();
		    qinfoFriend = qinfos->Next();
		    if (qinfoFriend == NULL)
		    {
			    MessageBox("No such friend, sorry...");
		    }
		      
        }
        else if(!m_fDsEnabledLocaly || m_iRadioDS == 1) 
        {
            //
            // Connect with a  computer using Direct mode.
            //
           
		    //
            // Obtain remote queueu  and machine name. 
            //
		    
		    m_csFriendName.MakeUpper();
            if (m_strRemoteComputerName == TEXT(""))
            {
                //
                // if no remote computer name was entered connect to local computer
                //
                // size of name buffer
 
                m_strRemoteComputerName = TEXT(GetComputerName()) ;
            }
            m_strRemoteComputerName.MakeUpper();
            //
            // Form format name.
            //
		    qinfoFriend.CreateInstance("MSMQ.MSMQQueueInfo");
            CString strTemp = "DIRECT=OS:";
		    qinfoFriend->FormatName = (_bstr_t) LPCTSTR(strTemp + m_strRemoteComputerName + "\\private$\\" + m_csFriendName);
		    qinfoFriend->Label = (_bstr_t) LPCTSTR(m_csLogin);
            //
            // When working in direct mode, we must use private queues. We're unable
            // to know whether a given private queue on another computer exists or not,
            // so here we'll just assume it does. To make the application more robust,
            // an acknowledgement queue should be created on the local computer, and
            // a request for acknowledgement messages should be added to the sent messages.
            // Then the application can notify the user when a NACK message is received.
            //
		    
        }
        //
		// If we have another friend queue open, close it.
        //
		if (m_qFriend != NULL && m_qFriend->IsOpen)
        {
			m_qFriend->Close();
        }
        //
        // Open the remote queue.
        //
		m_qFriend = qinfoFriend->Open(MQ_SEND_ACCESS, MQ_DENY_NONE); 
		SetWindowText(m_csLogin + " - Connected to " + m_csFriendName);
    }
    catch (_com_error &comerr)
	{
        HRESULT hr = comerr.Error();
		if (hr != MQ_ERROR_QUEUE_NOT_FOUND )
        {
		    HandleErrors(comerr);
        }
        else
        {                                                    
            MessageBox("No such friend, sorry...");
        }

    }

}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CImp_DrawDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CImp_DrawDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


BOOL CImp_DrawDlg::IsDsEnabledLocaly()
{
    BOOL fDSConnection = FALSE;
     IMSMQApplicationPtr qapp;
    //
    // This should work on NT4 & Windows 2000 
    //
    try
    { 
     qapp.CreateInstance("MSMQ.MSMQApplication");
    }
    catch(_com_error &comerr)
	{
        HandleErrors(comerr);
	};

     
    //
    // This part handles the diffrence between NT4 & Windows 2000.
    // It should work only on Windows 2000.
    //
    try
    {    
        IMSMQApplication2Ptr qapp2 = qapp;
        fDSConnection = qapp2->GetIsDsEnabled();
    }
	catch(_com_error &comerr)
	{
        HRESULT hr = comerr.Error();
		if (hr == E_NOINTERFACE || hr == E_POINTER)
        {
			//
            // No such interface implemented, we must be  using product one.
            // We can continue as if we are DS-enabled. 
            //
            return TRUE;
        }
        else
        {
            HandleErrors(comerr);
        }
	};
    return fDSConnection;
}

void CImp_DrawDlg::initializeUI(BOOL fConnectedToDS)
{   
    if(fConnectedToDS)
    {
        //
        // DS is enabled show relevant controls
        //
        m_cDsFrame.ShowWindow(SW_SHOW);
        m_cRadioDS.ShowWindow(SW_SHOW);
        m_cRadioWorkgroup.ShowWindow(SW_SHOW);
        m_cContinueButton.ShowWindow(SW_SHOW);
        m_CancelButton.ShowWindow(SW_SHOW);
    }
    else
    {
        //
        //DS is disabled show relevant controls (DS-dissabled).
        //
        m_cMessageFrame.ShowWindow(SW_SHOW);
        m_cRadioExpress.ShowWindow(SW_SHOW);
        m_cRadioRecoverable.ShowWindow(SW_SHOW);
        m_cQueueInput.ShowWindow(SW_SHOW);
        m_cQueueLabel.ShowWindow(SW_SHOW);
        m_cComputerInput.ShowWindow(SW_SHOW);
        m_cComputerLabel.ShowWindow(SW_SHOW);
        m_CancelButton.ShowWindow(SW_SHOW);
        m_btnAttach.ShowWindow(SW_SHOW);
    } 
    

}

void CImp_DrawDlg::OnConnect() 
{
    //
    // See what the user select.
    //
    UpdateData(TRUE);
    if(m_iRadioDS == 0)
    {
        //
        // DS is enabled and the user have selected to connect using Standard mode.
        //
        //
	    // Open the receiving queue and receive incoming messages.
	    //
        CWaitCursor wait;
        if (!OpenReceiveQueue())
        {
            //
            // Failed to open receiving Queue .
            //
            MessageBox("Can't open receiving queue.");

        }
	  
        //
        // Hide relevant Controles.
        //
        m_cDsFrame.ShowWindow(SW_HIDE);
        m_cRadioDS.ShowWindow(SW_HIDE);
        m_cRadioWorkgroup.ShowWindow(SW_HIDE);
        m_cContinueButton.ShowWindow(SW_HIDE);

        //
        // -> Show relevant controls.
        //
        
        m_cMessageFrame.ShowWindow(SW_SHOW);
        m_cRadioExpress.ShowWindow(SW_SHOW);
        m_cRadioRecoverable.ShowWindow(SW_SHOW);
        m_cQueueInput.ShowWindow(SW_SHOW);
        m_cQueueLabel.ShowWindow(SW_SHOW);
        
        m_CancelButton.ShowWindow(SW_SHOW);
        m_btnAttach.ShowWindow(SW_SHOW);
        
    }
    else//m_iRadio == 1
    {
        //
        // DS is enabled and the use chose to connect using Direct mode  
        //
        //
	    // Open the receiving queue and receive incoming messages.
	    //
        CWaitCursor wait ;
        if (!OpenPrivateReceiveQueue())
        {
            //
            // Failed to open receiving Queue.
            //
            MessageBox("Can't open receiving queue.");

        }
	  
        //
        // ->Hide relevant Controls.
        //
        m_cDsFrame.ShowWindow(SW_HIDE);
        m_cRadioDS.ShowWindow(SW_HIDE);
        m_cRadioWorkgroup.ShowWindow(SW_HIDE);
        m_cContinueButton.ShowWindow(SW_HIDE);
        
        //
        //-> Show relevant Controles.
        //
        m_cMessageFrame.ShowWindow(SW_SHOW);
        m_cRadioExpress.ShowWindow(SW_SHOW);
        m_cRadioRecoverable.ShowWindow(SW_SHOW);
        m_cQueueInput.ShowWindow(SW_SHOW);
        m_cQueueLabel.ShowWindow(SW_SHOW);
        m_cComputerInput.ShowWindow(SW_SHOW);
        m_cComputerLabel.ShowWindow(SW_SHOW);
        m_CancelButton.ShowWindow(SW_SHOW);
        m_btnAttach.ShowWindow(SW_SHOW);

    }	
}

BOOL CImp_DrawDlg::OpenReceiveQueue()
{
    try
	{
		
		CString	csComputerName;
		IMSMQQueryPtr		query("MSMQ.MSMQQuery");
		IMSMQQueueInfoPtr	qinfo;
		IMSMQQueueInfosPtr	qinfos;

        //
		// Note:  You can instantiate a smart pointer from a ProgID using either of
		// two methods.  As above (the query object) you can pass the ProgID during
		// construction or as below (m_msgOut) you can call the CreateInstance() 
		// member function.
        //
		m_msgOut.CreateInstance("MSMQ.MSMQMessage");	
		m_csLogin.MakeUpper();
		
		m_vtLogin = m_csLogin;
		qinfos = query->LookupQueue(&vtMissing,&m_vtguidDraw, &m_vtLogin);  // Look for user's queue
		qinfos->Reset();
		qinfo = qinfos->Next();

        //
        // If the queue doesn't exist, we'll create it.
        //
		if (qinfo == NULL)				
		{
			qinfo.CreateInstance("MSMQ.MSMQQueueInfo");
			csComputerName = GetComputerName();
			if (csComputerName == "")
            {
				csComputerName = ".";
            }
			qinfo->PathName = (_bstr_t) LPCTSTR(csComputerName + "\\" + m_csLogin);
			qinfo->Label = (_bstr_t) LPCTSTR(m_csLogin);
			qinfo->ServiceTypeGuid = (_bstr_t) m_vtguidDraw;
			qinfo->Create();			// Create this queue
		};

		for (int i = 0; i < 5; i++)
        {
			// We'll try to open it five times in case the creation takes time to replicate
			try
			{
				m_queue = NULL;
				m_queue = qinfo->Open(MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
				if (m_queue != NULL)
                {
                    //
                    // Found it.
                    //
                    break;
                }
			}
			catch (_com_error &comerr)
			{
				HRESULT hr = comerr.Error();
				if (hr != MQ_ERROR_QUEUE_NOT_FOUND)
                {
					throw comerr;
                }
			}
		} 

        if (m_queue == NULL)
		{
			//
            // Couldn't open the queue
            //
			return FALSE;
		};

		// Now we'll link up with the event source
		// the first five lines below imitate the VB lines

		// Dim WithEvents m_qevent as MSMQ.MSMQEvent
		// Set m_qevent = new MSMQ.MSMQEvent

		m_qevent.CreateInstance("MSMQ.MSMQEvent");
		if (m_pHandler)
        {
			delete m_pHandler;
        }
		m_pHandler = new CMSMQEventHandler();
		HRESULT hr = m_pHandler->AdviseSource(m_qevent);

		if (SUCCEEDED(hr))
        {
            //
            // if we connected in Advise Source, 
		    // tell MSMQ that we want events.
            //
			hr = m_queue->EnableNotification(m_qevent);		
        }
	}
	catch (_com_error &comerr)
	{
		HandleErrors(comerr);
	};

    return TRUE; //Queue was opened successfully .

}

BOOL CImp_DrawDlg::OpenPrivateReceiveQueue()
{
    try
	{
		
		
		IMSMQQueueInfoPtr	qinfo;
		m_msgOut.CreateInstance("MSMQ.MSMQMessage");
		m_csLogin.MakeUpper();
		m_vtLogin = m_csLogin;
		
        //
        // We can't locate a private Queue using the regular LookupQueue call
        // if the queue doesn't exist, we'll try to create it and open it
        //
        try
        {
		    qinfo.CreateInstance("MSMQ.MSMQQueueInfo");
		    CString csComputerName = GetComputerName();
		    if (csComputerName == "")
            {
			    csComputerName = ".";
            }
            qinfo->PathName = (_bstr_t) LPCTSTR(csComputerName + "\\private$\\" + m_csLogin);
		    qinfo->Label = (_bstr_t) LPCTSTR(m_csLogin);
		    qinfo->ServiceTypeGuid = (_bstr_t) m_vtguidDraw;
		    qinfo->Create();			// Create this queue
        }
        catch (_com_error &comerr)
        {
            HRESULT hr = comerr.Error();
			if (hr != MQ_ERROR_QUEUE_EXISTS )
            {
				throw comerr;
            }
        }

		for (int i = 0; i < 5; i++)
        {
			// We'll try to open it five times in case the creation takes time to replicate
			try
			{
				m_queue = NULL;
				m_queue = qinfo->Open(MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
				if (m_queue != NULL)
                {
                    //
                    // Found it.
                    //
                    break;
                }
			}
			catch (_com_error &comerr)
			{
				HRESULT hr = comerr.Error();
				if (hr != MQ_ERROR_QUEUE_NOT_FOUND )
                {
					throw comerr;
                }
			}
		} 

        if (m_queue == NULL)
		{
			//
            // Couldn't open the queue.
            //
			return FALSE;
		};

		// Now we'll link up with the event source
		// the first five lines below imitate the VB lines

		// Dim WithEvents m_qevent as MSMQ.MSMQEvent
		// Set m_qevent = new MSMQ.MSMQEvent

		m_qevent.CreateInstance("MSMQ.MSMQEvent");
		if (m_pHandler)
        {
			delete m_pHandler;
        }
		m_pHandler = new CMSMQEventHandler();
		HRESULT hr = m_pHandler->AdviseSource(m_qevent);

		if (SUCCEEDED(hr))
        {
            //
            // if we connected in Advise Source, 
		    // tell MSMQ that we want events.
            //
			hr = m_queue->EnableNotification(m_qevent);		
        }
	}
	catch (_com_error &comerr)
	{
       
        HandleErrors(comerr);
	}

    return TRUE; //Queue was opened successfully .

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\imp_dlg.h ===
// Imp_DrawDlg.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#import <mqoa.tlb> no_namespace

#include "EvHandle.h"
#include "drawarea.h"

#if !defined(AFX_IMP_DRAWDLG_H__02EE0038_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_)
#define AFX_IMP_DRAWDLG_H__02EE0038_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define MAXNUMLEN 7

/////////////////////////////////////////////////////////////////////////////
// CImp_DrawDlg dialog

class CImp_DrawDlg : public CDialog
{
// Construction
public:
	void initializeUI(BOOL fConnectedToDS);
	BOOL IsDsEnabledLocaly();
	CImp_DrawDlg(CWnd* pParent = NULL);	// standard constructor
	~CImp_DrawDlg();

// Dialog Data
	//{{AFX_DATA(CImp_DrawDlg)
	enum { IDD = IDD_IMP_DRAW_DIALOG };
	CDrawArea	m_drawScribble;
	CString	m_csFriendName;
	int		m_iRadio;
	CStatic	m_cComputerLabel;
	CButton	m_CancelButton;
	CStatic	m_cQueueLabel;
	CButton	m_cMessageFrame;
	CButton	m_cDsFrame;
	CButton	m_cRadioExpress;
	CButton	m_cRadioDS;
	CEdit	m_cComputerInput;
	CEdit	m_cQueueInput;
	CButton	m_cContinueButton;
	CButton	m_btnAttach;
	int		m_iRadioDS;
	CString	m_strRemoteComputerName;	
    CButton	m_cRadioWorkgroup;
    CButton	m_cRadioRecoverable;
    //}}AFX_DATA
 
	
       

	struct Line 
	{
		long X1;
		long Y1;
		long X2;
		long Y2;
	};

	_variant_t			m_vtLogin;
	_variant_t			m_vtFriendName;
	_variant_t			m_vtguidDraw;

	long	m_lLastX;
	long	m_lLastY;
	
	int			m_cLines;
	int			m_iArraySize;
	CString		m_csScreenText;
	int			m_iWasText;
	CString		m_csLogin;

	IMSMQQueuePtr		m_queue;
	IMSMQEventPtr		m_qevent;
	IMSMQQueuePtr		m_qFriend;
	IMSMQMessagePtr		m_msgOut;

	void SendMouseMovement(LINE line);
	void SendKeystroke(UINT uChar);

	void Arrived(	/*[in]*/ IDispatch* pdispQueue, 
					/*[in]*/ long lErrorCode, 
					/*[in]*/ long lCursor);

	void HandleErrors(_com_error &comerr);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CImp_DrawDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL OpenPrivateReceiveQueue();
	BOOL OpenReceiveQueue();
	BOOL m_fDsEnabledLocaly;
	HICON m_hIcon;

	CString GetUserName();
	CString GetComputerName();
	CString	LoginPrompt(CString DefaultName);

	CMSMQEventHandler*	m_pHandler;
	// Generated message map functions
	//{{AFX_MSG(CImp_DrawDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnButtonAttach();
	afx_msg void OnConnect();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IMP_DRAWDLG_H__02EE0038_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\logindlg.cpp ===
// logindlg.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


#include "stdafx.h"
#include "Imp_Draw.h"
#include "logindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog


CLoginDlg::CLoginDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLoginDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLoginDlg)
	m_strLogin = _T("");
	//}}AFX_DATA_INIT
}


void CLoginDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoginDlg)
	DDX_Text(pDX, IDC_EDIT_LOGIN, m_strLogin);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
	//{{AFX_MSG_MAP(CLoginDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\evhandle.h ===
// MQEventHandler.h : header file
// 
//=--------------------------------------------------------------------------=
// Copyright  1997-1998  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

class CMSMQEventHandler : public CCmdTarget
{
public:

	CMSMQEventHandler();
	~CMSMQEventHandler();


	virtual void Arrived(	/*[in]*/ IDispatch* pdispQueue, 
							/*[in]*/ long lCursor);
	virtual void ArrivedError(	/*[in]*/ IDispatch* pdispQueue, 
								/*[in]*/ long lErrorCode, 
								/*[in]*/ long lCursor);

	HRESULT AdviseSource(IDispatch* pDispatch);

	LPUNKNOWN GetInterfaceHook(const void* piid);

	DECLARE_DISPATCH_MAP()

private:
	DWORD				m_dwMyCookie;
	LPCONNECTIONPOINT	m_pMyCP;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Imp_Draw.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__02EE003A_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_)
#define AFX_STDAFX_H__02EE003A_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__02EE003A_FC6D_11D0_A14D_00C04FB9D5DF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\logindlg.h ===
// logindlg.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog

class CLoginDlg : public CDialog
{
// Construction
public:
	CLoginDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLoginDlg)
	enum { IDD = IDD_LOGIN };
	CString	m_strLogin;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoginDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLoginDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\imp_draw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Imp_Draw.rc
//
#define IDC_CONTINUE                    3
#define IDD_IMP_DRAW_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_LOGIN                       130
#define IDC_EDIT_FRIEND                 1000
#define IDC_BUTTON_ATTACH               1001
#define IDC_RADIO_EXPRESS               1002
#define IDC_RADIO_RECOVERABLE           1003
#define IDC_DRAWAREA_SCRIBLLE           1004
#define IDC_EDIT_LOGIN                  1005
#define IDC_EDIT_FRIEND_COMPUTER        1005
#define IDC_RADIO_DS                    1006
#define IDC_RADIO_WORKGROUP             1007
#define IDC_STATIC_CHOOSE_DS            1009
#define IDC_STATIC_Q_LABEL              1010
#define IDC_STATIC_CHOOSE_MESSAGE       1011
#define IDC_STATIC_C_LABEL              1012

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\closqdlg.h ===
// ClosQDlg.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



/////////////////////////////////////////////////////////////////////////////
// CCloseQueueDialog dialog

class CCloseQueueDialog : public CDialog
{
// Construction
public:
	CCloseQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCloseQueueDialog)
	enum { IDD = IDD_CLOSE_QUEUE_DIALOG };
	CComboBox	m_PathNameCB;
	CString	m_szPathName;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ; 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCloseQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCloseQueueDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void GetPathName(TCHAR szPathName[BUFFERSIZE])
	{
		_tcscpy (szPathName, m_szPathName);
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\crqdlg.cpp ===
// CrQDlg.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#include "stdafx.h"
#include "MQApitst.h"
#include "CrQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateQueueDialog dialog


CCreateQueueDialog::CCreateQueueDialog(CWnd* pParent /*=NULL*/)
   : CDialog(CCreateQueueDialog::IDD, pParent)
{
   TCHAR szTmpBuffer[BUFFERSIZE];
   DWORD dwTmpBufferSize = BUFFERSIZE;

   GetComputerName(szTmpBuffer, &dwTmpBufferSize);

   _tcscat(szTmpBuffer, TEXT("\\"));

   //{{AFX_DATA_INIT(CCreateQueueDialog)
   m_strLabel = TEXT("MQ API test");
   m_strPathName = szTmpBuffer;
   //}}AFX_DATA_INIT
}


void CCreateQueueDialog::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CCreateQueueDialog)
   DDX_Text(pDX, IDC_QUEUE_LABEL, m_strLabel);
   DDV_MaxChars(pDX, m_strLabel, 128);
   DDX_Text(pDX, IDC_QUEUE_PATHNAME, m_strPathName);
   DDV_MaxChars(pDX, m_strPathName, 128);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateQueueDialog, CDialog)
   //{{AFX_MSG_MAP(CCreateQueueDialog)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateQueueDialog message handlers

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\closqdlg.cpp ===
// ClosQDlg.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#include "stdafx.h"
#include "MQApitst.h"
#include "ClosQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCloseQueueDialog dialog


CCloseQueueDialog::CCloseQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*  pStrArray, CWnd* pParent /*=NULL*/)
	: CDialog(CCloseQueueDialog::IDD, pParent)
{
	m_pStrArray = pStrArray;

	//{{AFX_DATA_INIT(CCloseQueueDialog)
	m_szPathName = _T("");
	//}}AFX_DATA_INIT
}


void CCloseQueueDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCloseQueueDialog)
	DDX_Control(pDX, IDC_COMBO, m_PathNameCB);
	DDX_CBString(pDX, IDC_COMBO, m_szPathName);
	DDV_MaxChars(pDX, m_szPathName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCloseQueueDialog, CDialog)
	//{{AFX_MSG_MAP(CCloseQueueDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCloseQueueDialog message handlers

BOOL CCloseQueueDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	int i;
	
	// TODO: Add extra initialization here
	for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
		VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
	
    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);        

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\crqdlg.h ===
// CrQDlg.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



/////////////////////////////////////////////////////////////////////////////
// CCreateQueueDialog dialog

class CCreateQueueDialog : public CDialog
{
// Construction
public:
	CCreateQueueDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateQueueDialog)
	enum { IDD = IDD_CREATE_QUEUE_DIALOG };
	CString	m_strLabel;
	CString	m_strPathName;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateQueueDialog)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void GetPathName(TCHAR szPathNameBuffer[BUFFERSIZE])
	{
		_tcscpy (szPathNameBuffer, LPCTSTR(m_strPathName));
	}

	void GetLabel(TCHAR szLabelBuffer[BUFFERSIZE])
	{
		_tcscpy (szLabelBuffer, LPCTSTR(m_strLabel));
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\delqdlg.cpp ===
// DelQDlg.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#include "stdafx.h"
#include "MQApitst.h"
#include "DelQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteQueueDialog dialog


CDeleteQueueDialog::CDeleteQueueDialog(CArray<ARRAYQ*, ARRAYQ*>* pStrArray, CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteQueueDialog::IDD, pParent)
{
	m_pStrArray = pStrArray;

	//{{AFX_DATA_INIT(CDeleteQueueDialog)
	m_szPathName = _T("");
	//}}AFX_DATA_INIT
}


void CDeleteQueueDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteQueueDialog)
	DDX_Control(pDX, IDC_DELETE_QUEUE_COMBO, m_PathNameCB);
	DDX_CBString(pDX, IDC_DELETE_QUEUE_COMBO, m_szPathName);
	DDV_MaxChars(pDX, m_szPathName, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteQueueDialog, CDialog)
	//{{AFX_MSG_MAP(CDeleteQueueDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteQueueDialog message handlers

BOOL CDeleteQueueDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	int i;
	
	// TODO: Add extra initialization here
	for  (i=0 ; i<m_pStrArray->GetSize() ; i++)
		VERIFY (m_PathNameCB.AddString((*m_pStrArray)[i]->szPathName) != CB_ERR);
	
    if (m_PathNameCB.GetCount() > 0) m_PathNameCB.SetCurSel(0);        

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\locatdlg.h ===
// LocatDlg.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



/////////////////////////////////////////////////////////////////////////////
// CLocateDialog dialog

class CLocateDialog : public CDialog
{
// Construction
public:
	CLocateDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLocateDialog)
	enum { IDD = IDD_LOCATE_DIALOG };
	CString	m_szLabel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLocateDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLocateDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void GetLabel(TCHAR szLabelBuffer[BUFFERSIZE])
	{
		_tcscpy (szLabelBuffer, m_szLabel);
	}


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\delqdlg.h ===
// DelQDlg.h : header file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



/////////////////////////////////////////////////////////////////////////////
// CDeleteQueueDialog dialog

class CDeleteQueueDialog : public CDialog
{
// Construction
public:
	CDeleteQueueDialog(CArray <ARRAYQ*, ARRAYQ*>*, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteQueueDialog)
	enum { IDD = IDD_DELETE_QUEUE_DIALOG };
	CComboBox	m_PathNameCB;
	CString	m_szPathName;
	//}}AFX_DATA

	/* pointer to the array with the strings for the combo box (Queues PathName). */
	CArray <ARRAYQ*, ARRAYQ*>* m_pStrArray ; 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteQueueDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteQueueDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void GetPathName(TCHAR szPathName[BUFFERSIZE])
	{
		_tcscpy (szPathName, m_szPathName);
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\locatdlg.cpp ===
// LocatDlg.cpp : implementation file
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#include "stdafx.h"
#include "MQApitst.h"
#include "LocatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocateDialog dialog


CLocateDialog::CLocateDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CLocateDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLocateDialog)
	m_szLabel = TEXT("MQ API test");
	//}}AFX_DATA_INIT
}


void CLocateDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLocateDialog)
	DDX_Text(pDX, IDC_LOCATE_LABEL, m_szLabel);
	DDV_MaxChars(pDX, m_szLabel, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLocateDialog, CDialog)
	//{{AFX_MSG_MAP(CLocateDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocateDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\mqapitst.h ===
// MqApitest.h : main header file for the TEST application
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#include "mq.h"

/////////////////////////////////////////////////////////////////////////////
// CTestApp:
// See test.cpp for the implementation of this class
//

class CTestApp : public CWinApp
{
public:
	CTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CTestApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
protected:
	BOOL IsDsEnabledLocaly();
};


/////////////////////////////////////////////////////////////////////////////

#define BUFFERSIZE 256
#define MAX_Q_PATHNAME_LEN 256
#define MAX_Q_FORMATNAME_LEN 256
#define DEFAULT_M_TIMETOREACHQUEUE -1
#define DEFAULT_M_TIMETOBERECEIVED -1
#define MAX_VAR		 20
#define ACCESSBUFFERSIZE 50

//
// A structure for the array of queues that the application handles.
//
typedef struct {
	TCHAR szPathName[MAX_Q_PATHNAME_LEN];     // holds the Queue path name.
	TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]; // holds the Queue format name.
	QUEUEHANDLE hHandle;                         // a handle for an open Queue.
	DWORD dwAccess;                              // access for the queue.
} ARRAYQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=


/////////////////////////////////////////////////////////////////////////////


class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnApiCreateQueue();
	afx_msg void OnApiDeleteQueue();
	afx_msg void OnApiOpenQueue();
	afx_msg void OnApiCloseQueue();
	afx_msg void OnApiSendMessage();
	afx_msg void OnApiReceiveMessage();
	afx_msg void OnApiLocate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:

    void OnUpdateFrameTitle(BOOL bAddToTitle);

protected:
	//
	// An array to hold the pathnames of the queues that were created so far.
	//

    //
    // Holds information about all "located" queues
    //
	CArray<ARRAYQ*, ARRAYQ*> m_PathNameArray;

    //
    // Holds information about all "opened" queues
    //
	CArray<ARRAYQ*, ARRAYQ*> m_OpenedQueuePathNameArray;

public:

	//
	// Utility function to display status string based on received msg Class property
	//
	void ClassToString(unsigned short MsgClass,LPTSTR pszStatus);



	//
	// functions to manipulate the path names array.
	//

    //
    // Adds a given ARRAYQ pointer to the PathName array.
    //
	void Add2PathNameArray(ARRAYQ* NewPath) {m_PathNameArray.Add(NewPath);}
    //
    // Removes an ARRAYQ pointer whose pathname matches
    // the given pathname form the PathName array.
    //
	ARRAYQ* RemoveFromPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]);
    //
    // Empties the PathName array and frees all allocated memory.
    //
	void CleanPathNameArray();
    //
    // Looks for an ARRAYQ pointer whose pathname matches the given one,
    // and returns the formatname of that ARRAYQ.
    //
    BOOL TranslatePathNameToFormatName(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                       TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]);
    //
    // Prints to screen the pathname of all ARRAYQ's in the PathName array.
    //
    void DisplayPathNameArray();

	//
	// functions to manipulate the opened queues path name array.
	//
	
    //
    // Adds a given ARRAYQ pointer to the Opened Queue PathName array.
    //
    void Add2OpenedQueuePathNameArray(ARRAYQ* NewPath)
											{m_OpenedQueuePathNameArray.Add(NewPath);}
    //
    // Removes an ARRAYQ pointer whose pathname matches
    // the given pathname form the Opened Queue PathName array.
    //
	ARRAYQ* RemoveFromOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]);
    //
    // Checks if the Opened Queue PathName array is Empty.
    //
	BOOL IsOpenedQueueArrayEmpty();
    //
    // Looks for an ARRAYQ pointer whose pathname matches the given one,
    // and returns the formatname of that ARRAYQ.
    //
    BOOL TranslateOpenedQueuePathNameToFormatName(
                                           TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                           TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]);
    //
    // Looks for an ARRAYQ pointer whose pathname matches the given one,
    // and returns the Queue Handle of that ARRAYQ.
    //
	BOOL GetQueueHandle(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
													 QUEUEHANDLE* phClosedQueueHandle);
    //
    // Prints to screen the pathname of all ARRAYQ's in the PathName array.
    //
    void DisplayOpenedQueuePathNameArray();


	//
	// functions to manipulate both of the queues.
	//
	
    //
    // Moves an ARRAYQ pointer from the PathName array to the Opened Queue PathName array.
    //
    void MoveToOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
		                                           QUEUEHANDLE hQueue, DWORD dwAccess);
    //
    // Moves an ARRAYQ pointer from the Opened Queue PathName array array to the PathName.
    //
	void MoveToPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]);
    //
    // Looks for ARRAYQ's that are found in both arrays
    // and removes them from the PathName array.
    //
    void UpdatePathNameArrays();

};

extern "C" void  PrintToScreen(const TCHAR * Format, ...);
extern CWnd* pMainView;

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\mqapitst.cpp ===
// Mqapitest.cpp : Defines the class behaviors for the application.
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#include "stdafx.h"
#include "MQApitst.h"

#include "MainFrm.h"
#include "testDoc.h"
#include "testView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTestApp

BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
	//{{AFX_MSG_MAP(CTestApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestApp construction

CTestApp::CTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CTestApp object

CTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CTestApp initialization

BOOL CTestApp::InitInstance()
{
    //
    // This application should only be used when DS is enabled.
    // if we are in DS-disabled mode we should stop execution.
    //
    if (!IsDsEnabledLocaly())
    {
        ::MessageBox(NULL,"This application is not designed to run on DS-disabled  mode configuration",NULL,MB_OK);
        exit(0);
    }
    //
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CTestDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CTestView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CTestApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CTestApp commands


//
// Pointer to hold the main window pointer.
//
CWnd* pMainView;

extern "C" void  PrintToScreen(const TCHAR * Format, ...)
{
   

   TCHAR szText[500];
   va_list l;
   static len = 0;


    //Format the string
    va_start(l, Format); 
#ifdef UNICODE
    vswprintf(szText, Format, l);
#else
    vsprintf(szText, Format, l);
#endif


   	CEdit& rfMainEdit = ((CTestView*)pMainView)->GetEditCtrl();

	int i = rfMainEdit.GetLineCount();

	((CTestView*)pMainView)->GetEditCtrl().SetSel(INT_MAX,INT_MAX);
	((CTestView*)pMainView)->GetEditCtrl().ReplaceSel(szText);
	((CTestView*)pMainView)->GetEditCtrl().ReplaceSel(TEXT("\r\n"));
	len += lstrlen(szText) + 2;
	((CTestView*)pMainView)->GetDocument()->SetModifiedFlag(FALSE);
}

BOOL CTestApp::IsDsEnabledLocaly()
/*++

Routine Description:
    
      The rutine checked if the coomputer is DS -enabled/disabled 

Arguments:
    
      None

Return Value:
    
      TRUE     -  DS - enabled.
      FALSE    -  DS - disabled.

--*/

{
       
    MQPRIVATEPROPS PrivateProps;
    QMPROPID       aPropId[MAX_VAR];
    MQPROPVARIANT  aPropVar[MAX_VAR];
    DWORD          cProp;  
    HRESULT        hr;
    //
    // Prepare DS-enabled property.
    //
    cProp = 0;

    aPropId[cProp] = PROPID_PC_DS_ENABLED;
    aPropVar[cProp].vt = VT_NULL;
    ++cProp;	
    //
    // Create a PRIVATEPROPS structure.
    //
    PrivateProps.cProp = cProp;
	PrivateProps.aPropID = aPropId;
	PrivateProps.aPropVar = aPropVar;
    PrivateProps.aStatus = NULL;

    //
    // Retrieve the information.
    //


    //
    // This code detect DS connection.
    // This code is designed to allow the sample to compile both on NT4 and Windows 2000.
    // The MQGetPrivateComputerInformation() function can be called directly
    // on Windows 2000.
    //
    HINSTANCE hMqrtLibrary = GetModuleHandle(TEXT("mqrt.dll"));
	ASSERT(hMqrtLibrary != NULL);

    typedef HRESULT (APIENTRY *MQGetPrivateComputerInformation_ROUTINE)(LPCWSTR , MQPRIVATEPROPS*);
    MQGetPrivateComputerInformation_ROUTINE pfMQGetPrivateComputerInformation = 
          (MQGetPrivateComputerInformation_ROUTINE)GetProcAddress(hMqrtLibrary,
													 "MQGetPrivateComputerInformation");
    if(pfMQGetPrivateComputerInformation == NULL)
    {
        //
        // There is no entry point in the dll matching to this routine
        // it must be an old version of mqrt.dll -> product one.
        // It will be OK to handle this case as a case of DS-enabled mode.
        //
        return TRUE;
    }

	hr = pfMQGetPrivateComputerInformation(
				     NULL,
					 &PrivateProps);
	if(FAILED(hr))
	{
        //
        // we were not able to determine if DS is enabled or disabled
        // notify the user and assume the worst case - (i.e. we are DS-disasbled).
        //
        AfxMessageBox("Unable to detect DS connection");        
        return FALSE;
    }                             
	
    
    if(PrivateProps.aPropVar[0].boolVal == 0)
    {
        //
        // DS-disabled.
        //
        return FALSE;
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\sdk\samples\mqapitst\mainfrm.cpp ===
/* ************************************************************************ */
/*                                                                          */
/* Main file of the application MQ API test.                                */
/*                                                                          */
/* ************************************************************************ */

//
// MainFrm.cpp : implementation of the CMainFrame class
//
//=--------------------------------------------------------------------------=
// Copyright  1997-1999  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



#include "stdafx.h"
#include "MQApitst.h"
#include <afxtempl.h>

#include "MainFrm.h"
#include "CrQDlg.h"
#include "DelQDlg.h"
#include "OpenQDlg.h"
#include "ClosQDlg.h"
#include "SendMDlg.h"
#include "RecvMDlg.h"
#include "RecWDlg.h"
#include "LocatDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPSTR UnicodeStringToAnsiString(LPCWSTR lpcsUnicode)
{
    LPSTR lpAnsiString = NULL;

    if (lpcsUnicode)
    {
        DWORD dwSize = wcstombs(NULL, lpcsUnicode, 0);
        lpAnsiString = new char[dwSize+1];
        size_t rc = wcstombs(lpAnsiString, lpcsUnicode, dwSize);
        ASSERT(rc != (size_t)(-1));
        lpAnsiString[dwSize] = '\0';
    }

    return lpAnsiString;
}

void AnsiStringToUnicode(LPWSTR lpsUnicode, LPSTR  lpsAnsi, DWORD  nSize)
{
    if (lpsUnicode == NULL)
    {
        return;
    }

    ASSERT(lpsAnsi != NULL);

    size_t rc = mbstowcs(lpsUnicode, lpsAnsi, nSize);
    ASSERT(rc != (size_t)(-1));
    if (lpsUnicode[nSize-1] != L'\0')
        lpsUnicode[nSize] = L'\0';
}

#ifdef UNICODE
#define _mqscpy(dest, src)  wcscpy(dest, src)
#else
#define _mqscpy(dest, src)  AnsiStringToUnicode(dest, src, _tcslen(src)+1)
#endif

BOOL GetTextualSid(
    PSID pSid,          // binary SID
    LPTSTR TextualSID,   // buffer for textual representation of SID
    LPDWORD dwBufferLen // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // obtain SidIdentifierAuthority
    psia=&((SID *)pSid)->IdentifierAuthority;

    // obtain sidsubauthority count
    dwSubAuthorities=(DWORD)((SID *)pSid)->SubAuthorityCount;

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    TextualSID += _stprintf(TextualSID, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        TextualSID += _stprintf(TextualSID,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        TextualSID += _stprintf(TextualSID, TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        TextualSID += _stprintf(TextualSID, TEXT("-%lu"),
                    ((SID *)pSid)->SubAuthority[ dwCounter] );
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   //{{AFX_MSG_MAP(CMainFrame)
   ON_WM_CREATE()
   ON_COMMAND(ID_API_CREATE_QUEUE, OnApiCreateQueue)
   ON_COMMAND(ID_API_DELETE_QUEUE, OnApiDeleteQueue)
   ON_COMMAND(ID_API_OPEN_QUEUE, OnApiOpenQueue)
   ON_COMMAND(ID_API_CLOSE_QUEUE, OnApiCloseQueue)
   ON_COMMAND(ID_API_SEND_MESSAGE, OnApiSendMessage)
   ON_COMMAND(ID_API_RECEIVE_MESSAGE, OnApiReceiveMessage)
   ON_COMMAND(ID_API_LOCATE, OnApiLocate)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
   ID_SEPARATOR,           // status line indicator
   ID_INDICATOR_CAPS,
   ID_INDICATOR_NUM,
   ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
   // TODO: add member initialization code here.
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
        sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Remove this if you don't want tool tips or a resizeable toolbar
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

#define MAXINDEX 31


/* ************************************************************************ */
/*                        RemoveFromPathNameArray                           */
/* ************************************************************************ */
/* This function goes through the PathName Array and compares the given     */
/* PathName to the PathName's of the items in the array.                    */
/* If a match is found the item is removed from the array and the function  */
/* returns a pointer to the item, otherwise a NULL pointer is returned.     */
/* ************************************************************************ */
ARRAYQ* CMainFrame::RemoveFromPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN])
{
    int Index;
    int MaxIndex = m_PathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the PathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_PathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_PathNameArray[Index];
            m_PathNameArray.RemoveAt(Index);
            return pQueue;
        }
    }
    return NULL; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                             CleanPathNameArray                           */
/* ************************************************************************ */
/* This function goes through the PathName array and deletes all the items  */
/* in it. the function frees the allocated memory.                          */
/* ************************************************************************ */
void CMainFrame::CleanPathNameArray()
{
    ARRAYQ* pQueue;

    while (m_PathNameArray.GetSize() > 0)
    {
        pQueue = m_PathNameArray[0];
        m_PathNameArray.RemoveAt(0);
        delete pQueue;
    }
}

/* ************************************************************************ */
/*                        RemoveFromOpenedQueuePathNameArray                */
/* ************************************************************************ */
/* This function goes through the OpenedPathName Array and compares the     */
/* given PathName to the PathName's of the items in the array.              */
/* If a match is found the item is removed from the array and the function  */
/* returns a pointer to the item, otherwise a NULL pointer is returned.     */
/* ************************************************************************ */
ARRAYQ* CMainFrame::RemoveFromOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN])
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_OpenedQueuePathNameArray[Index];
            m_OpenedQueuePathNameArray.RemoveAt(Index);
            return pQueue;
        }
    }
    return NULL; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                           IsOpenedQueueArrayEmpty                        */
/* ************************************************************************ */
/* This function checks if the size of the OpenedPathName array is zero or  */
/* less and if so it returns TRUE otherwise it returns FALSE.               */
/* ************************************************************************ */
BOOL CMainFrame::IsOpenedQueueArrayEmpty()
{
    if (m_OpenedQueuePathNameArray.GetSize() <= 0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/* ************************************************************************ */
/*                        MoveToOpenedQueuePathNameArray                    */
/* ************************************************************************ */
/* This function moves an item from the PathName array to the               */
/* OpenedPathName array. also it updates the hadle and the access rights    */
/* to the moved queue.                                                      */
/* ************************************************************************ */
void CMainFrame::MoveToOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                                QUEUEHANDLE hQueue, DWORD dwAccess)
{
    ARRAYQ* pQueue;

    pQueue = RemoveFromPathNameArray(szPathName);
    pQueue->hHandle = hQueue;                     // add Queue Handle.
    pQueue->dwAccess = dwAccess;                  // add Queue Access rights.
    Add2OpenedQueuePathNameArray(pQueue);
}

/* ************************************************************************ */
/*                              MoveToPathNameArray                         */
/* ************************************************************************ */
/* This function moves an item from the OpenedPathName array to the         */
/* PathName array.                                                          */
/* ************************************************************************ */
void CMainFrame::MoveToPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN])
{
    ARRAYQ* pQueue;

    pQueue = RemoveFromOpenedQueuePathNameArray(szPathName);
    Add2PathNameArray(pQueue);
}

/* ************************************************************************ */
/*                             UpdatePathNameArrays                         */
/* ************************************************************************ */
/* This function goes through the Opened Queue PathName array and for every */
/* item in it, it checkes if the item is found in the PathName array as     */
/* well, if so the function removes the item from the PathName array.       */
/* ************************************************************************ */
void CMainFrame::UpdatePathNameArrays()
{
    int PathNameIndex;
    int OpenedPathNameIndex;
    int MaxPathNameIndex = m_PathNameArray.GetSize();
    int MaxOpenedPathNameIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (OpenedPathNameIndex=0; OpenedPathNameIndex<MaxOpenedPathNameIndex; OpenedPathNameIndex++)
    {
        for (PathNameIndex=0; PathNameIndex<MaxPathNameIndex; PathNameIndex++)
        {
            if (_tcscmp(m_OpenedQueuePathNameArray[OpenedPathNameIndex]->szPathName,
                m_PathNameArray[PathNameIndex]->szPathName) == 0)
            {
                //
                // Found a match, remove it from PathName Array.
                //
                pQueue = m_PathNameArray[PathNameIndex];
                m_PathNameArray.RemoveAt(PathNameIndex);
                delete pQueue;
                //
                // get out of inner for loop.
                //
                break;
            }
        }
    }
}


/* ************************************************************************ */
/*                              GetQueueHandle                              */
/* ************************************************************************ */
/* This function goes through the OpenedPathName array and retrieve the     */
/* Handle to the queue which matches the given PathName. If no match was    */
/* found the function returns FALSE.                                        */
/* ************************************************************************ */
BOOL CMainFrame::GetQueueHandle(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                QUEUEHANDLE* phClosedQueueHandle)
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_OpenedQueuePathNameArray[Index];
            *phClosedQueueHandle = pQueue->hHandle;
            return TRUE;
        }
    }
    return FALSE; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                       TranslatePathNameToFormatName                      */
/* ************************************************************************ */
/* This function goes through the PathName array and retrieve the           */
/* FormatName to the queue which matches the given PathName. If no match    */
/* was found the function returns FALSE.                                    */
/* ************************************************************************ */
BOOL CMainFrame::TranslatePathNameToFormatName(TCHAR szPathName[MAX_Q_PATHNAME_LEN],
                                               TCHAR szFormatName[MAX_Q_FORMATNAME_LEN])
{
    int Index;
    int MaxIndex = m_PathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the PathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_PathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_PathNameArray[Index];
            _tcsncpy (szFormatName, pQueue->szFormatName, MAX_Q_FORMATNAME_LEN);
            return TRUE;
        }
    }
    return FALSE; // ERROR - no match was found.
}

/* ************************************************************************ */
/*                  TranslateOpenedQueuePathNameToFormatName                */
/* ************************************************************************ */
/* This function goes through the OpenedPathName array and retrieve the     */
/* FormatName to the queue which matches the given PathName. If no match    */
/* was found the function returns FALSE.                                    */
/* ************************************************************************ */
BOOL CMainFrame::TranslateOpenedQueuePathNameToFormatName(
    TCHAR szPathName[MAX_Q_PATHNAME_LEN],
    TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]
    )
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    ARRAYQ* pQueue;

    //
    // Loop through the OpenedPathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]->szPathName) == 0)
        {
            //
            // Found a match.
            //
            pQueue = m_OpenedQueuePathNameArray[Index];
            _tcsncpy (szFormatName, pQueue->szFormatName, MAX_Q_FORMATNAME_LEN);
            return TRUE;
        }
    }
    return FALSE; // ERROR - no match was found.
}


/* ************************************************************************ */
/*                         DisplayPathNameArray                             */
/* ************************************************************************ */
/* This function goes through the PathName Array and prints it to screen.   */
/* ************************************************************************ */
void CMainFrame::DisplayPathNameArray()
{
    int Index;
    int MaxIndex = m_PathNameArray.GetSize();
    TCHAR szMsgBuffer[BUFFERSIZE];

    _stprintf(szMsgBuffer, TEXT("   Located Queues Path Name :"));
    PrintToScreen(szMsgBuffer);
    //
    // Loop through the PathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        //
        // Print the PathNames.
        //
        _stprintf(szMsgBuffer, TEXT("\t%d. %s"),Index+1, m_PathNameArray[Index]->szPathName);
        PrintToScreen(szMsgBuffer);
    }
}

/* ************************************************************************ */
/*                    DisplayOpenedQueuePathNameArray                       */
/* ************************************************************************ */
/* This function goes through the Opened Queues PathName Array and          */
/* prints it to screen.                                                     */
/* ************************************************************************ */
void CMainFrame::DisplayOpenedQueuePathNameArray()
{
    int Index;
    int MaxIndex = m_OpenedQueuePathNameArray.GetSize();
    TCHAR szMsgBuffer[BUFFERSIZE];

    _stprintf(szMsgBuffer, TEXT("   Currently Opened Queues Path Names:"));
    PrintToScreen(szMsgBuffer);
    //
    // Loop through the OpenedQueuePathName array.
    //
    for (Index=0; Index<MaxIndex; Index++)
    {
        //
        // Print the PathNames.
        //
        _stprintf(szMsgBuffer, TEXT("\t%d. %s"),Index+1, m_OpenedQueuePathNameArray[Index]->szPathName);
        PrintToScreen(szMsgBuffer);
    }
}

/* ************************************************************************ */
/*                          GetMsgClassStatus                               */
/* ************************************************************************ */
/* This function sets proper status string based on a given MQMSG class.    */
/* ************************************************************************ */

struct
{
	unsigned short	mclass;
	LPTSTR          pszDescription;
} StringClass[] =
  {
	{ MQMSG_CLASS_NORMAL, TEXT("The Message was received successfully.")},
	{ MQMSG_CLASS_ACK_REACH_QUEUE, TEXT("The REACH QUEUE ACK Message was read successfully.")},
	{ MQMSG_CLASS_ACK_RECEIVE, TEXT("The RECEIVE ACK Message was read successfully.")},
	{ MQMSG_CLASS_NACK_BAD_DST_Q, TEXT("The DESTINATION QUEUE HANDLE INVALID Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_RECEIVE_TIMEOUT, TEXT("The TIME TO RECEIVE EXPIRED Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, TEXT("The TIME TO REACH QUEUE EXPIRED Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_Q_EXCEED_QUOTA, TEXT("The QUEUE IS FULL Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_ACCESS_DENIED, TEXT("The SENDER HAVE NO SEND ACCESS RIGHTS ON QUEUE Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED, TEXT("The HOP COUNT EXCEEDED Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_BAD_SIGNATURE, TEXT("The MESSAGE RECEIVED WITH BAD SIGNATURE Nack Message was read successfully.")},
	{ MQMSG_CLASS_NACK_BAD_ENCRYPTION, TEXT("The MSG COULD NOT DECRYPTED Nack Message was read successfully.")},
    { MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT, TEXT("The SOURCE QM COULD NOT ENCRYPT MSG FOR DEST QM Nack Message was read successfully.")},
	{ 0, NULL}
  };
	
void CMainFrame::ClassToString(unsigned short MsgClass,LPTSTR pszStatus)
{
	//
	// loop the StringClass array to find MsgClass
	//
	DWORD dwIndex = 0;
	while (StringClass[dwIndex].pszDescription != NULL)
	{
		if (StringClass[dwIndex].mclass == MsgClass)
		{
			_stprintf(pszStatus,StringClass[dwIndex].pszDescription);
			return;
		}
		dwIndex++;
	}

	//
	// MsgClass not found - print default error
	//
	_stprintf(pszStatus,TEXT("The NACK (0x%X) Message was read successfully."),MsgClass);
}


/* ************************************************************************ */
/*                            OnApiCreateQueue                              */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName and Label. Then it creates the specified queue.                 */
/*                                                                          */
/* Uses: MQCreateQueue.                                                     */
/* ************************************************************************ */
void CMainFrame::OnApiCreateQueue()
{
    // TODO: Add your command handler code here

    TCHAR szMsgBuffer[BUFFERSIZE];

    MQQUEUEPROPS QueueProps;
    MQPROPVARIANT aVariant[MAXINDEX];
    QUEUEPROPID aPropId[MAXINDEX];
    DWORD PropIdCount = 0;
    HRESULT hr;

    PSECURITY_DESCRIPTOR pSecurityDescriptor;

    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    TCHAR szLabelBuffer[MAX_Q_PATHNAME_LEN];
    DWORD dwFormatNameBufferLength = MAX_Q_FORMATNAME_LEN;


    //
    // Display CreateQueue Dialog.
    //
    CCreateQueueDialog CreateQueueDialog;

    if(CreateQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }
    CreateQueueDialog.GetPathName(szPathNameBuffer);
    CreateQueueDialog.GetLabel(szLabelBuffer);

    //
    // Get the input fields from the dialog box
    // and prepare the property array PROPVARIANT
    //


    //
    // Set the PROPID_Q_PATHNAME property
    //
    aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;        //Type
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_Q_PATHNAME_LEN];
    _mqscpy(aVariant[PropIdCount].pwszVal, szPathNameBuffer); //Value

    PropIdCount++;

    //
    // Set the PROPID_Q_LABEL property
    //
    aPropId[PropIdCount] = PROPID_Q_LABEL;    //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;     //Type
    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_Q_PATHNAME_LEN];
    _mqscpy(aVariant[PropIdCount].pwszVal, szLabelBuffer); //Value

    PropIdCount++;


    //
    // Set the MQEUEUPROPS structure
    //
    QueueProps.cProp = PropIdCount;           //No of properties
    QueueProps.aPropID = aPropId;             //Id of properties
    QueueProps.aPropVar = aVariant;           //Value of properties
    QueueProps.aStatus = NULL;                //No error reports

    //
    // No security (default)
    //
    pSecurityDescriptor = NULL;

    //
    // Create the queue
    //
#ifdef UNICODE
    hr = MQCreateQueue(
            pSecurityDescriptor,            //Security
            &QueueProps,                    //Queue properties
            szFormatNameBuffer,             //Output: Format Name
            &dwFormatNameBufferLength       //Output: Format Name len
            );
#else
    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    hr = MQCreateQueue(
            pSecurityDescriptor,            //Security
            &QueueProps,                    //Queue properties
            szwFormatNameBuffer,            //Output: Format Name
            &dwFormatNameBufferLength       //Output: Format Name len
            );

    if (SUCCEEDED(hr))
    {
        size_t rc =wcstombs(szFormatNameBuffer, szwFormatNameBuffer, dwFormatNameBufferLength);
        ASSERT(rc != (size_t)(-1));
    }
#endif

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQCreateQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
    }
    else
    {
        //
        // Success - write in edit control.
        //
        _stprintf(szMsgBuffer, TEXT("The queue %s was created successfully. ( FormatName: %s )"),
            szPathNameBuffer, szFormatNameBuffer);
        PrintToScreen(szMsgBuffer);

        //
        // Add the new queue to the PathName Array.
        //
        ARRAYQ* pNewQueue = new ARRAYQ;
        //
        // Save PathName and FormatName in the ARRAYQ structure.
        //
        _tcsncpy (pNewQueue->szPathName, szPathNameBuffer, MAX_Q_PATHNAME_LEN);
        _tcsncpy (pNewQueue->szFormatName, szFormatNameBuffer, MAX_Q_FORMATNAME_LEN);
        Add2PathNameArray(pNewQueue);
    }

    //
    // Free allocated memory
    //
    delete   aVariant[0].pwszVal;
    delete   aVariant[1].pwszVal;
}

/* ************************************************************************ */
/*                            OnApiDeleteQueue                              */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName. then it deletes the specified queue.                           */
/*                                                                          */
/* Uses: MQDeleteQueue.                                                     */
/* ************************************************************************ */
void CMainFrame::OnApiDeleteQueue()
{
    // TODO: Add your command handler code here
    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szFormatNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szMsgBuffer[BUFFERSIZE];

    HRESULT hr;

    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN;

    CDeleteQueueDialog DeleteQueueDialog(&m_PathNameArray);

    //
    // Display DeleteQueue Dialog.
    //
    if (DeleteQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    DeleteQueueDialog.GetPathName(szPathNameBuffer);

    //
    // Translate the path name to format name using the ARRAYQ arrays.
    //
    if (TranslatePathNameToFormatName(szPathNameBuffer, szFormatNameBuffer) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("Queue wasn't found"));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        return;
    }

    //
    // Delete the queue.
    //
#ifdef UNICODE
    hr = MQDeleteQueue(szFormatNameBuffer);  // FormatName of the Queue to be deleted.
#else
    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    size_t rc = mbstowcs(szwFormatNameBuffer, szFormatNameBuffer, _tcslen(szFormatNameBuffer)+1);
    ASSERT(rc != (size_t)(-1));
    hr = MQDeleteQueue(szwFormatNameBuffer);  // FormatName of the Queue to be deleted.
#endif

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQDeleteQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer, TEXT("The queue %s was deleted successfully."), szPathNameBuffer);
        PrintToScreen(szMsgBuffer);
        //
        // Delete the name from the Path Names array.
        //
        ARRAYQ* DeletedQueue = RemoveFromPathNameArray(szPathNameBuffer);
        if (DeletedQueue != NULL)
        {
            delete DeletedQueue;
        }
    }
}

/* ************************************************************************ */
/*                             OnApiOpenQueue                               */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName. then it opens the specified queue.                             */
/*                                                                          */
/* Uses: MQOpenQueue.                                                       */
/* ************************************************************************ */
void CMainFrame::OnApiOpenQueue()
{
    // TODO: Add your command handler code here
    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szFormatNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szAccessBuffer[ACCESSBUFFERSIZE]; 
    TCHAR szMsgBuffer[BUFFERSIZE];

    HRESULT hr;

    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN;
    DWORD dwAccess;

    QUEUEHANDLE hQueue;

    COpenQueueDialog OpenQueueDialog(&m_PathNameArray);

    //
    // Display the OpenQueue dialog.
    //
    if (OpenQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    OpenQueueDialog.GetPathName(szPathNameBuffer);
    dwAccess = OpenQueueDialog.GetAccess();
    //
    // Set the access buffer string.
    //
    switch (dwAccess)
    {
    case (MQ_RECEIVE_ACCESS | MQ_SEND_ACCESS):

        _tcscpy(szAccessBuffer, TEXT("MQ_RECEIVE_ACCESS, MQ_SEND_ACCESS."));
        break;

    case MQ_RECEIVE_ACCESS:

        _tcscpy(szAccessBuffer, TEXT("MQ_RECEIVE_ACCESS."));
        break;

    case MQ_SEND_ACCESS:

        _tcscpy(szAccessBuffer, TEXT("MQ_SEND_ACCESS."));
        break;

    default:

        _tcscpy(szAccessBuffer, TEXT("NONE."));
        break;
    }

    //
    // Translate the path name to format name using the ARRAYQ arrays.
    //
    if (TranslatePathNameToFormatName(szPathNameBuffer, szFormatNameBuffer) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("Queue wasn't found"));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        return;
    }

    //
    // Open the queue. (no sharing)
    //
#ifdef UNICODE
    hr = MQOpenQueue(
            szFormatNameBuffer,     // Format Name of the queue to be opened.
            dwAccess,               // Access rights to the Queue.
            0,                      // No receive Exclusive.
            &hQueue                 // OUT: handle to the opened Queue.
            );
#else
    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    size_t rc = mbstowcs(szwFormatNameBuffer, szFormatNameBuffer, _tcslen(szFormatNameBuffer)+1);
    ASSERT(rc != (size_t)(-1));

    hr = MQOpenQueue(
            szwFormatNameBuffer,    // Format Name of the queue to be opened.
            dwAccess,               // Access rights to the Queue.
            0,                      // No receive Exclusive.
            &hQueue                 // OUT: handle to the opened Queue.
            );
#endif

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQOpenQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer,
            TEXT("The queue %s was opened successfully.\r\n\tQueueHandle: 0x%x\r\n\tQueue Access : %s"),
            szPathNameBuffer,
            hQueue,
            szAccessBuffer);
        PrintToScreen(szMsgBuffer);

        //
        // move the queue to the opened queues array.
        //
        MoveToOpenedQueuePathNameArray(szPathNameBuffer, hQueue, dwAccess);
    }
}

/* ************************************************************************ */
/*                            OnApiCloseQueue                               */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName. then it closes the specified queue.                            */
/*                                                                          */
/* Uses: MQCloseQueue.                                                      */
/* ************************************************************************ */
void CMainFrame::OnApiCloseQueue()
{
    // TODO: Add your command handler code here

    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szMsgBuffer[BUFFERSIZE];

    HRESULT hr;

    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN;

    QUEUEHANDLE hClosedQueueHandle;

    //
    // Display CloseQueue Dialog.
    //
    CCloseQueueDialog CloseQueueDialog(&m_OpenedQueuePathNameArray);

    if (CloseQueueDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    CloseQueueDialog.GetPathName(szPathNameBuffer);

    //
    // Get the closed queue handle.
    //
    if (GetQueueHandle(szPathNameBuffer, &hClosedQueueHandle) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("The Queue couldn't be closed since it was not opened before."));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        return;
    }

    //
    // Close the queue.
    //
    hr = MQCloseQueue(hClosedQueueHandle);   // the handle of the Queue to be closed.
    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQCloseQueue failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer, TEXT("The queue %s was closed successfully."), szPathNameBuffer);
        PrintToScreen(szMsgBuffer);
        //
        // Move the queue form the opened queues array to the path name array.
        //
        MoveToPathNameArray(szPathNameBuffer);
    }
}

/* ************************************************************************ */
/*                            OnApiSendMessage                              */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName and some message properties. Then it sends the message to the   */
/* specified queue.                                                         */
/*                                                                          */
/* Uses: MQSendMessage.                                                     */
/* ************************************************************************ */

//
// two static buffers to hold the last message body and label for the next time.
//
TCHAR szLastMessageBody[BUFFERSIZE];
TCHAR szLastMessageLabel[BUFFERSIZE];

void CMainFrame::OnApiSendMessage()
{
    // TODO: Add your command handler code here

    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szAdminPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szAdminFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    TCHAR szMsgBuffer[BUFFERSIZE];

    MQMSGPROPS MsgProps;
    MQPROPVARIANT aVariant[MAXINDEX];
    MSGPROPID aPropId[MAXINDEX];
    DWORD PropIdCount = 0;

    HRESULT hr;

    unsigned char bPriority;
    unsigned char bDelivery;
    unsigned char bJournal;
    unsigned char bDeadLetter;
	unsigned char bAuthenticated;
	unsigned char bEncrypted;
    unsigned char bAcknowledge;

    WCHAR szMessageBodyBuffer [BUFFERSIZE];
    WCHAR szMessageLabelBuffer[BUFFERSIZE];
    DWORD dwTimeToReachQueue;
	DWORD dwTimeToBeReceived;

    QUEUEHANDLE hQueue;

    CSendMessageDialog SendMessageDialog(&m_OpenedQueuePathNameArray);

    //
    // Display the SendMessage dialog.
    //
    if (SendMessageDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    //
    // Retrieve the properties from the dialog box.
    //
    SendMessageDialog.GetPathName(szPathNameBuffer);
    SendMessageDialog.GetAdminPathName(szAdminPathNameBuffer);
    bPriority = SendMessageDialog.GetPriority();
    bDelivery = SendMessageDialog.GetDelivery();
    bJournal = SendMessageDialog.GetJournal();
    bDeadLetter = SendMessageDialog.GetDeadLetter();
	bAuthenticated = SendMessageDialog.GetAuthenticated();
	bEncrypted = SendMessageDialog.GetEncrypted();
    bAcknowledge = SendMessageDialog.GetAcknowledge();
    SendMessageDialog.GetMessageBody(szLastMessageBody);
    SendMessageDialog.GetMessageLabel(szLastMessageLabel);
    dwTimeToReachQueue = SendMessageDialog.GetTimeToReachQueue();
	dwTimeToBeReceived = SendMessageDialog.GetTimeToBeReceived();

    //
    // Update the Last message properties.
    //
    _mqscpy(szMessageBodyBuffer, szLastMessageBody);
    _mqscpy(szMessageLabelBuffer, szLastMessageLabel);

    //
    // Get the target queue handle.
    //
    if (GetQueueHandle(szPathNameBuffer, &hQueue) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("GetQueueHandle failed. Queue not opened yet."));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        return;
    }

    //
    // Get the admin queue FormatName.
    //
    if (TranslateOpenedQueuePathNameToFormatName(szAdminPathNameBuffer, szAdminFormatNameBuffer) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("TranslatePathNameToFormatName failed, Queue has not been opened yet."));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        return;
    }

    //
    // prepare the property array PROPVARIANT.
    //

    //
    // Set the PROPID_M_PRIORITY property.
    //
    aPropId[PropIdCount] = PROPID_M_PRIORITY;    //PropId
    aVariant[PropIdCount].vt = VT_UI1;           //Type
    aVariant[PropIdCount].bVal = bPriority;      //Value

    PropIdCount++;

    //
    // Set the PROPID_M_DELIVERY property.
    //
    aPropId[PropIdCount] = PROPID_M_DELIVERY;    //PropId
    aVariant[PropIdCount].vt = VT_UI1;           //Type
    aVariant[PropIdCount].bVal = bDelivery;      //Value

    PropIdCount++;

    //
    // Set the PROPID_M_ACKNOWLEDGE property.
    //
    aPropId[PropIdCount] = PROPID_M_ACKNOWLEDGE; //PropId
    aVariant[PropIdCount].vt = VT_UI1;           //Type
    aVariant[PropIdCount].bVal = bAcknowledge;   //Value

    PropIdCount++;

    //
    // Set the PROPID_M_BODY property.
    //
    aPropId[PropIdCount] = PROPID_M_BODY;                  //PropId
    aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;           //Type
    aVariant[PropIdCount].caub.cElems =
        (wcslen(szMessageBodyBuffer) + 1) * sizeof(WCHAR); //Value
    aVariant[PropIdCount].caub.pElems = (unsigned char *)szMessageBodyBuffer;

    PropIdCount++;

    //
    // Set the PROPID_M_LABEL property.
    //
    aPropId[PropIdCount] = PROPID_M_LABEL;                  //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;                   //Type
    aVariant[PropIdCount].pwszVal = szMessageLabelBuffer;     //Value

    PropIdCount++;

    //
    // Set the PROPID_M_TIME_TO_REACH_QUEUE property.
    //
    aPropId[PropIdCount] = PROPID_M_TIME_TO_REACH_QUEUE;    //PropId
    aVariant[PropIdCount].vt = VT_UI4;                      //Type
    aVariant[PropIdCount].ulVal = dwTimeToReachQueue;       //Value

    PropIdCount++;

    //
    // Set the PROPID_M_TIME_TO_BE_RECEIVED property.
    //
    aPropId[PropIdCount] = PROPID_M_TIME_TO_BE_RECEIVED;    //PropId
    aVariant[PropIdCount].vt = VT_UI4;                      //Type
    aVariant[PropIdCount].ulVal = dwTimeToBeReceived;       //Value

    PropIdCount++;


    if (bJournal || bDeadLetter)
    {
        //
        // Set the PROPID_M_JOURNAL property.
        //
        aPropId[PropIdCount] = PROPID_M_JOURNAL;            //PropId
        aVariant[PropIdCount].vt = VT_UI1;                  //Type

        if (bJournal)
            aVariant[PropIdCount].bVal = MQMSG_JOURNAL;
        else
            aVariant[PropIdCount].bVal = 0;
        if (bDeadLetter)
            aVariant[PropIdCount].bVal |= MQMSG_DEADLETTER;

        PropIdCount++;
    }


	if (bAuthenticated)
	{
		//
		// Set the PROPID_M_AUTH_LEVEL property.
		//
		aPropId[PropIdCount] = PROPID_M_AUTH_LEVEL;            //PropId
		aVariant[PropIdCount].vt = VT_UI4;                     //Type
		aVariant[PropIdCount].ulVal = MQMSG_AUTH_LEVEL_ALWAYS; //Value

		PropIdCount++;
	}

	if (bEncrypted)
	{
		//
		// Set the PROPID_M_ENCRYPTION_ALG property.
		//
		aPropId[PropIdCount] = PROPID_M_PRIV_LEVEL;            //PropId
		aVariant[PropIdCount].vt = VT_UI4;                     //Type
		aVariant[PropIdCount].ulVal = MQMSG_PRIV_LEVEL_BODY;   //Value

		PropIdCount++;
	}


    //
    // Set the PROPID_M_ADMIN_QUEUE property.
    //
    aPropId[PropIdCount] = PROPID_M_ADMIN_QUEUE;               //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;                      //Type
#ifdef UNICODE
    aVariant[PropIdCount].pwszVal = szAdminFormatNameBuffer;   //Value
#else
    WCHAR szwAdminFormatNameBuffer[MAX_Q_FORMATNAME_LEN];
    size_t rc = mbstowcs(szwAdminFormatNameBuffer,
                    szAdminFormatNameBuffer,
                    _tcslen(szAdminFormatNameBuffer)+1);
    ASSERT(rc != (size_t)(-1));
    aVariant[PropIdCount].pwszVal = szwAdminFormatNameBuffer;  //Value
#endif

    PropIdCount++;

    //
    // Set the MQMSGPROPS structure
    //
    MsgProps.cProp = PropIdCount;       //Number of properties.
    MsgProps.aPropID = aPropId;         //Id of properties.
    MsgProps.aPropVar = aVariant;       //Value of properties.
    MsgProps.aStatus  = NULL;           //No Error report.

    //
    // Send the message.
    //
    hr = MQSendMessage(
            hQueue,                     // handle to the Queue.
            &MsgProps,                  // Message properties to be sent.
            NULL                        // No transaction
            );

    if (FAILED(hr))
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("MQSendMessage failed, Error code = 0x%x."),hr);
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
    }
    else
    {
        //
        // Success - write in edit control
        //
        _stprintf(szMsgBuffer, TEXT("The Message \"%s\" was sent successfully."), szLastMessageLabel);
        PrintToScreen(szMsgBuffer);
    }
}

/* ************************************************************************ */
/*                           OnApiReceiveMessage                            */
/* ************************************************************************ */
/* This function opens a dialog box and asks the user for the queue's       */
/* PathName and the Time to wait for the message. Then it tries to get a    */
/* message from the specified queue at the given time.                      */
/*                                                                          */
/* Uses: MQReceiveMessage, MQFreeMemory.                                    */
/* ************************************************************************ */
void CMainFrame::OnApiReceiveMessage()
{
    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN];
    TCHAR szMsgBuffer[2*BUFFERSIZE];
    TCHAR szDomainName[BUFFERSIZE];
	 TCHAR szAccountName[BUFFERSIZE];
    DWORD dwActNameSize = sizeof(szAccountName);
    DWORD dwDomNameSize = sizeof(szDomainName);
    TCHAR szTextSid[BUFFERSIZE];
    DWORD dwTextSidSize = sizeof(szTextSid);
    BYTE  blobBuffer[BUFFERSIZE];

    MQMSGPROPS MsgProps;
    MQPROPVARIANT aVariant[MAXINDEX];
    MSGPROPID aPropId[MAXINDEX];
    DWORD PropIdCount = 0;

    HRESULT hr;

    WCHAR szMessageLabelBuffer[BUFFERSIZE];
    DWORD dwTimeout;

    QUEUEHANDLE hQueue;

    CReceiveWaitDialog    WaitDialog;
    CReceiveMessageDialog ReceiveMessageDialog(&m_OpenedQueuePathNameArray);

    //
    // Display the ReceiveMessage dialog.
    //
    if (ReceiveMessageDialog.DoModal() == IDCANCEL)
    {
        return;
    }

    ReceiveMessageDialog.DestroyWindow();
    ReceiveMessageDialog.GetPathName(szPathNameBuffer);

    //
    // Get the queue handle.
    //
    if (GetQueueHandle(szPathNameBuffer, &hQueue) == FALSE)
    {
        //
        // Error - display message
        //
        _stprintf(szMsgBuffer, TEXT("GetQueueHandle failed. Queue was not found in Opened Queue Array"));
        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK);
        return;
    }

    //
    // Retrieve the properties form the dialog box.
    //
    dwTimeout = ReceiveMessageDialog.GetTimeout();


    //
    // prepare the property array PROPVARIANT of
    // message properties that we want to receive
    //

    //
    // Set the PROPID_M_BODY property.
    //
    aPropId[PropIdCount] = PROPID_M_BODY;                                //PropId
    aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;                         //Type
    aVariant[PropIdCount].caub.cElems = ReceiveMessageDialog.GetBodySize() ;
    aVariant[PropIdCount].caub.pElems = (unsigned char *) new
                               char [ aVariant[PropIdCount].caub.cElems ] ;

    int iBodyIndex = PropIdCount ;
    PropIdCount++;

    //
    // Set the PROPID_M_LABEL property.
    //
    aPropId[PropIdCount] = PROPID_M_LABEL;                   //PropId
    aVariant[PropIdCount].vt = VT_LPWSTR;                    //Type
    aVariant[PropIdCount].pwszVal = szMessageLabelBuffer;

    PropIdCount++;

    //
    // Set the PROP