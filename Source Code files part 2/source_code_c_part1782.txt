ctualLen = 0;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrStrCommon::CLockInfo

HRESULT CMLStrAttrStrCommon::CLockInfo::UnlockAll(void)
{
    if (m_pLockArray)
    {
        for (int n = 0; n < MAX_LOCK_COUNT; n++)
        {
            if (m_pLockArray[n].m_psz)
                Unlock(&m_pLockArray[n], m_pLockArray[n].m_psz, m_pLockArray[n].m_cchLen, NULL, NULL);
        }
    }

    return S_OK;
}

HRESULT CMLStrAttrStrCommon::CLockInfo::Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (!m_pLockArray)
    {
        m_pLockArray = new CLockInfoEntry[MAX_LOCK_COUNT];

        if (m_pLockArray)
        {
            for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
                m_pLockArray[nIndex].m_psz = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (!m_pLockArray[nIndex].m_psz)
                break;
        }
        if (nIndex >= MAX_LOCK_COUNT)
            hr = MLSTR_E_TOOMANYNESTOFLOCK;
    }

    if (SUCCEEDED(hr))
    {
        m_pLockArray[nIndex].m_psz = psz;
        m_pLockArray[nIndex].m_pfnUnlockProc = pfnUnlockProc;
        m_pLockArray[nIndex].m_lFlags = lFlags;
        m_pLockArray[nIndex].m_uCodePage = uCodePage;
        m_pLockArray[nIndex].m_lPos = lPos;
        m_pLockArray[nIndex].m_lLen = lLen;
        m_pLockArray[nIndex].m_cchPos = cchPos;
        m_pLockArray[nIndex].m_cchLen = cchLen;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::CLockInfo::Find(const void* psz, long, void** ppKey)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (m_pLockArray)
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (psz == m_pLockArray[nIndex].m_psz)
                break;
        }
    }
    if (!m_pLockArray || nIndex >= MAX_LOCK_COUNT)
        hr = E_INVALIDARG;

    if (ppKey)
    {
        if (SUCCEEDED(hr))
            *ppKey = &m_pLockArray[nIndex];
        else
            *ppKey = NULL;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::CLockInfo::Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen)
{
    CLockInfoEntry* const pEntry = (CLockInfoEntry*)pKey;
    HRESULT hr;

    if (!(pEntry->m_lFlags & MLSTR_WRITE))
    {
        cch = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    hr = (m_pCommon->*(pEntry->m_pfnUnlockProc))(pKey, psz, cch, pcchActual, plActualLen);

    if (SUCCEEDED(hr))
        hr = EndLock(pEntry->m_lFlags & MLSTR_WRITE);

    pEntry->m_psz = NULL; // Remove from lock array anyway

    if (FAILED(hr))
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrStrCommon::CMLStrBufStandardW

long CMLStrAttrStrCommon::CMLStrBufStandardW::RoundBufSize(long cchStr)
{
    for (int n = 8; n < 12; n++)
    {
        if (cchStr < (1L << n))
            break;
    }
    const long cchTick = (1L << (n - 4));
    return (cchStr + cchTick - 1) / cchTick * cchTick;
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\codepage.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       codepage.h
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_

/*
 *  Code Page Default Values.
 */
enum CODEPAGE
{
    CP_UNDEFINED    = -1L,
    CP_DEFAULT      = CP_ACP, 
    CP_US_OEM       = 437L,
    CP_852          = 852L,
    CP_THAI         = 874L,
    CP_JPN_SJ       = 932L,
    CP_CHN_GB       = 936L,
    CP_KOR_5601     = 949L,
    CP_KOR_JOHAB    = 1361L,
    CP_TWN          = 950L,
    CP_UCS_2        = 1200L,
    CP_UCS_2_BE     = 1201L,
    CP_1250         = 1250L,
    CP_1251         = 1251L,
    CP_1252         = 1252L,
    CP_1253         = 1253L,
    CP_1254         = 1254L,
    CP_1255         = 1255L,
    CP_1256         = 1256L,
    CP_1257         = 1257L,
    CP_1258         = 1258L,
    CP_20127        = 20127L,
    CP_KOI8R        = 20866L,
    CP_KOI8RU       = 21866L,
    CP_ISO_8859_1   = 28591L,
    CP_ISO_8859_2   = 28592L,
    CP_ISO_8859_3   = 28593L,
    CP_ISO_8859_9   = 28599L,
    CP_ISO_8859_15  = 28605L,
    CP_USER_DEFINED = 50000L,

    CP_AUTO         = 50001L,

    CP_ISO_2022_JP   = 50220L,
    CP_ISO_2022_JP_ESC   = 50221L,
    CP_ISO_2022_JP_SIO   = 50222L,
    CP_ISO_2022_KR   = 50225L,
    CP_ISO_2022_TW   = 50226L,
    CP_ISO_2022_CH   = 50227L,

    CP_JP_AUTO      = 50932L,
    CP_CHS_AUTO     = 50936L,
    CP_KR_AUTO      = 50949L,
    CP_CHT_AUTO     = 50950L,

    CP_CYRILLIC_AUTO = 51251L,
    CP_GREEK_AUTO   = 51253L,
    CP_ARABIC_AUTO  = 51256L,

    CP_EUC_JP       = 51932L,
    CP_EUC_CH       = 51936L,
    CP_EUC_KR       = 51949L,
    CP_EUC_TW       = 51950L,

    CP_CHN_HZ       = 52936L,
    CP_18030        = 54936L,

    CP_UTF_7        = 65000L,
    CP_UTF_8        = 65001L
};

enum CP_STATE
{
    INVALID_CP      = 0,
    VALID_CP          = 1,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\convbase.h ===
#ifndef CONVBASE_H_
#define CONVBASE_H_

#define MAXOVERFLOWCHARS 16

class CINetCodeConverter
{
private:
	UINT m_uCodePage;
	int m_nCodeSet;
	BOOL m_fOutput;
	LPSTR m_lpDestStr;
	int m_cchDest;
	int m_cchOutput;
	int m_cchOverflow;
	UCHAR m_OverflowBuffer[MAXOVERFLOWCHARS];

public:
	CINetCodeConverter();
	CINetCodeConverter(UINT uCodePage, int nCodeSet);
	virtual ~CINetCodeConverter() {}
	int GetCodeSet() {return m_nCodeSet;}
	HRESULT GetStringSizeA(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize = NULL);
	HRESULT ConvertStringA(LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, LPINT lpnSize = NULL);
	virtual int GetUnconvertBytes() = 0 ;
	virtual DWORD GetConvertMode() = 0 ;
	virtual void SetConvertMode(DWORD mode) = 0 ;

private:
	HRESULT WalkString(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize);
	BOOL EndOfDest(UCHAR tc);
	BOOL OutputOverflowBuffer();

protected:
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1) = 0;
	virtual BOOL CleanUp() = 0;

protected:
	inline BOOL Output(UCHAR tc)
	{
		BOOL fDone = TRUE;

		if (m_fOutput) {
			if (m_cchOutput < m_cchDest) {
				*m_lpDestStr++ = tc;
			} else {
				(void)EndOfDest(tc);
				fDone = FALSE;
			}
		}

		m_cchOutput++;

		return fDone;
	}
};

#endif /* CONVBASE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\convbase.cpp ===
// ============================================================================
// Internet Character Set Conversion: Base Class
// ============================================================================

#include "private.h"
#include "convbase.h"
#include "fechrcnv.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CINetCodeConverter::CINetCodeConverter()
{
	m_uCodePage = 0;
	m_nCodeSet = CP_UNDEFINED;
	m_cchOverflow = 0;
}

CINetCodeConverter::CINetCodeConverter(UINT uCodePage, int nCodeSet)
{
	m_uCodePage = uCodePage;
	m_nCodeSet = nCodeSet;
	m_cchOverflow = 0;
}

/******************************************************************************
********************   G E T   S T R I N G   S I Z E   A   ********************
******************************************************************************/

HRESULT CINetCodeConverter::GetStringSizeA(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize)
{
	m_fOutput = FALSE;

	return WalkString(lpSrcStr, cchSrc, lpnSize);
}

/******************************************************************************
*********************   C O N V E R T   S T R I N G   A   *********************
******************************************************************************/

HRESULT CINetCodeConverter::ConvertStringA(LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, LPINT lpnSize)
{
	m_fOutput = TRUE;
	m_lpDestStr = lpDestStr;
	m_cchDest = cchDest;

	if ( !OutputOverflowBuffer() ) // Output those chars which could not be output at previous time.
		return FALSE;

	return WalkString(lpSrcStr, cchSrc, lpnSize);
}

/******************************************************************************
**************************   W A L K   S T R I N G   **************************
******************************************************************************/

HRESULT CINetCodeConverter::WalkString(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize)
{
        HRESULT hr = S_OK;

        m_cchOutput = 0;

        if (lpSrcStr) {
            while (cchSrc-- > 0) {
            HRESULT _hr = ConvertChar(*lpSrcStr++, cchSrc);
            if (!SUCCEEDED(_hr))
            {   
                hr = _hr;
                break;
            }
            else
                if (hr == S_OK && _hr == S_FALSE)
                    hr = S_FALSE;
            }
	} else {
        if (!CleanUp())
            hr = E_FAIL;
	}

	if (lpnSize)
		*lpnSize = m_cchOutput;

	return hr;
}

/******************************************************************************
**************************   E N D   O F   D E S T   **************************
******************************************************************************/

BOOL CINetCodeConverter::EndOfDest(UCHAR tc)
{
	if (m_cchOverflow < MAXOVERFLOWCHARS) {
		m_OverflowBuffer[m_cchOverflow++] = tc;
		return TRUE;
	} else {
		return FALSE; // Overflow on Overflow buffer, No way
	}
}

/******************************************************************************
***************   O U T P U T   O V E R F L O W   B U F F E R   ***************
******************************************************************************/

BOOL CINetCodeConverter::OutputOverflowBuffer()
{
	for (int n = 0; n < m_cchOverflow; n++) {
		if (m_cchOutput < m_cchDest) {
			*m_lpDestStr++ = m_OverflowBuffer[n];
			m_cchOutput++;
		} else {
			// Overflow again
			for (int n2 = 0; n < m_cchOverflow; n++, n2++)
				m_OverflowBuffer[n2] = m_OverflowBuffer[n];
			m_cchOverflow = n2;
			return FALSE;
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\convobj.h ===
#ifndef _CONVOBJ_H_
#define _CONVOBJ_H_

#ifdef  __cplusplus

#include "mlatl.h"
#include "fechrcnv.h"
#include "convbase.h"
#include "ichrcnv.h"

//
//  CMLangConvertCharset declaration with IMLangConvertCharset Interface
//
class ATL_NO_VTABLE CMLangConvertCharset :
    public CComObjectRoot,
    public CComCoClass<CMLangConvertCharset, &CLSID_CMLangConvertCharset>,
    public IMLangConvertCharset
{
public:
    CMLangConvertCharset(void);
    ~CMLangConvertCharset(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLangConvertCharset)
        COM_INTERFACE_ENTRY(IMLangConvertCharset)
    END_COM_MAP()

public:
    // IMLangConvertCharset
    STDMETHOD(Initialize)(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty);
    STDMETHOD(GetSourceCodePage)(UINT *puiSrcCodePage);
    STDMETHOD(GetDestinationCodePage)(UINT *puiDstCodePage);
    STDMETHOD(GetDeterminedSrcCodePage)(UINT *puiCodePage);
    STDMETHOD(GetProperty)(DWORD *pdwProperty);
    STDMETHOD(DoConversion)(BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize);
    STDMETHOD(DoConversionToUnicode)(CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize);
    STDMETHOD(DoConversionFromUnicode)(WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize);

private:

    DWORD m_dwSrcEncoding;
    DWORD m_dwDetectSrcEncoding;
    DWORD m_dwDstEncoding;
    DWORD m_dwMode;
    DWORD m_dwProperty;

    CICharConverter* lpCharConverter;

};

#endif  // __cplusplus

#endif  // _CONVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\convobj.cpp ===
#include "private.h"
#include "convobj.h"

#include "detcbase.h"
#include "codepage.h"
#include "detcjpn.h"
#include "detckrn.h"


CMLangConvertCharset::CMLangConvertCharset(void)
{
    DllAddRef();
    lpCharConverter = NULL ;

    m_dwSrcEncoding = 0 ;
    m_dwDetectSrcEncoding = 0 ;
    m_dwDstEncoding = 0 ;
    m_dwMode = 0 ;

    return ;
}

CMLangConvertCharset::~CMLangConvertCharset(void)
{
    if (lpCharConverter)
        delete lpCharConverter ;
    DllRelease();
    return ;
}

//
//  CMLangConvertCharset implementation
//
STDAPI CMLangConvertCharset::Initialize(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty)
{
    HRESULT hr = S_OK ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::Initialize called."));

    if ( m_dwSrcEncoding != uiSrcCodePage ||
            m_dwDstEncoding != uiDstCodePage )
    {
        m_dwSrcEncoding = uiSrcCodePage ;
        m_dwDstEncoding = uiDstCodePage ;

        if (lpCharConverter)
            delete lpCharConverter ;

        lpCharConverter = new CICharConverter ;

        if (!lpCharConverter)
            return E_FAIL ;

        hr = lpCharConverter->ConvertSetup(&m_dwSrcEncoding, m_dwDstEncoding);
    }

    m_dwMode = 0 ;
    m_dwProperty = dwProperty ;

    return hr ;
}

STDAPI CMLangConvertCharset::GetSourceCodePage(UINT *puiSrcCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetSourceCodePage called."));

    if (puiSrcCodePage)
    {
        *puiSrcCodePage = m_dwSrcEncoding ;
        return S_OK ;
    }
    else
        return E_INVALIDARG ;
}

STDAPI CMLangConvertCharset::GetDestinationCodePage(UINT *puiDstCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetDestinationCodePage called."));

    if (puiDstCodePage)
    {
        *puiDstCodePage = m_dwDstEncoding ;
        return S_OK ;
    }
    else
        return E_INVALIDARG ;
}

STDAPI CMLangConvertCharset::GetDeterminedSrcCodePage(UINT *puiCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetDeterminedSrcCodePage called."));

    if (m_dwDetectSrcEncoding)
    {
        if (puiCodePage)
        {
            *puiCodePage = m_dwDetectSrcEncoding;
            return S_OK ;
        }
        else
            return E_INVALIDARG ;
    }
    else
        return S_FALSE ;
}

STDAPI CMLangConvertCharset::GetProperty(DWORD *pdwProperty)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetProperty called."));

    if (pdwProperty)
    {
        *pdwProperty = m_dwProperty;
        return S_OK ;
    }
    else
        return E_INVALIDARG ;
}

STDAPI CMLangConvertCharset::DoConversion(BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize)
{
    HRESULT hr ;
    DWORD dwMode = m_dwMode ;
    int nSrcSize = -1 ;
    int nDstSize = 0 ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::DoConversion called."));

    // no converter was set up 
    if (!lpCharConverter)
        return E_FAIL ;

    if (pcSrcSize)
        nSrcSize = *pcSrcSize ;

    if ( pSrcStr && nSrcSize == -1 ) // Get length of lpSrcStr if not given, assuming lpSrcStr is a zero terminate string.
    {
        if ( m_dwSrcEncoding == CP_UCS_2 )
    		nSrcSize = (lstrlenW( (WCHAR*) pSrcStr) << 1 ) ;
        else
    		nSrcSize = lstrlenA( (CHAR*) pSrcStr) ;
    }

    if (pcDstSize)
        nDstSize = *pcDstSize ;

    if ( m_dwSrcEncoding == CP_JP_AUTO ) // Auto Detection for Japan
    {
        CIncdJapanese DetectJapan;
        DWORD dwSrcEncoding ;

        dwSrcEncoding = DetectJapan.DetectStringA((LPSTR)pSrcStr, nSrcSize);
        // if dwSrcEncoding is zero means there is an ambiguity, we don't return
        // the detected codepage to caller, instead we defaut its codepage internally
        // to SJIS
        if (dwSrcEncoding)
        {
            m_dwDetectSrcEncoding = m_dwSrcEncoding = dwSrcEncoding ;
            m_dwProperty |= MLCONVCHARF_AUTODETECT ;
        }
        else
            dwSrcEncoding = CP_JPN_SJ;
        hr = lpCharConverter->ConvertSetup(&dwSrcEncoding, m_dwDstEncoding);
        if ( hr != S_OK )
            return hr ;
    }
    else if ( m_dwSrcEncoding == CP_KR_AUTO ) // Auto Detection for Korean
    {
        CIncdKorean DetectKorean;

        m_dwDetectSrcEncoding = m_dwSrcEncoding = DetectKorean.DetectStringA((LPSTR)pSrcStr, nSrcSize);
        hr = lpCharConverter->ConvertSetup(&m_dwSrcEncoding, m_dwDstEncoding);
        if ( hr != S_OK )
            return hr ;
        m_dwProperty |= MLCONVCHARF_AUTODETECT ;
    }
    else if ( m_dwSrcEncoding == CP_AUTO ) // General Auto Detection for all code pages
    {
        int _nSrcSize = DETECTION_MAX_LEN < nSrcSize ?  DETECTION_MAX_LEN : nSrcSize;
        INT nScores = 1;
        DWORD dwSrcEncoding ;
        DetectEncodingInfo Encoding;

        if ( S_OK == _DetectInputCodepage(MLDETECTCP_HTML, 1252, (char *)pSrcStr, &_nSrcSize, &Encoding, &nScores))
        {
            m_dwDetectSrcEncoding = m_dwSrcEncoding = dwSrcEncoding = Encoding.nCodePage;
            m_dwProperty |= MLCONVCHARF_AUTODETECT ;
        }
        else
        {
            dwSrcEncoding = 1252;
        }

        hr = lpCharConverter->ConvertSetup(&dwSrcEncoding, m_dwDstEncoding);
        if ( hr != S_OK )
        {
            return hr ;
        }
    }

    hr = lpCharConverter->DoCodeConvert(&dwMode, (LPCSTR) pSrcStr, &nSrcSize, (LPSTR) pDstStr, &nDstSize, m_dwProperty, NULL);

    // return the number of bytes processed for the source. 
    if (pcSrcSize)
        *pcSrcSize = lpCharConverter->_nSrcSize ;

    if (pcDstSize)
        *pcDstSize = nDstSize;

    if (pDstStr)
        m_dwMode = dwMode ;

    lpCharConverter->ConvertCleanUp();
    return hr ;
}

STDAPI CMLangConvertCharset::DoConversionToUnicode(CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize)
{

    HRESULT hr ;
    UINT nByteCountSize = (pcDstSize ? *pcDstSize * sizeof(WCHAR) : 0 ) ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::DoConversionToUnicode called."));

    hr = DoConversion((BYTE*)pSrcStr,pcSrcSize,(BYTE*)pDstStr,&nByteCountSize);

    if (pcDstSize)
        *pcDstSize = nByteCountSize / sizeof(WCHAR);

    return hr;
}

STDAPI CMLangConvertCharset::DoConversionFromUnicode(WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize)
{
    HRESULT hr ;
    UINT nByteCountSize = (pcSrcSize ? *pcSrcSize * sizeof(WCHAR) : 0 ) ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::DoConversionFromUnicode called."));

    hr = DoConversion((BYTE*)pSrcStr,&nByteCountSize,(BYTE*)pDstStr,pcDstSize);

    if (pcSrcSize)
        *pcSrcSize = nByteCountSize / sizeof(WCHAR);

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\cpdetect.cpp ===
#include "private.h"
#include "detcbase.h"
#include "codepage.h"
#include "detcjpn.h"
#include "detckrn.h"

#include "fechrcnv.h"

#include "msencode.h"
#include "lcdetect.h"
#include "cpdetect.h"

CCpMRU *g_pCpMRU = NULL;



// Get data from registry and construct cache
HRESULT CCpMRU::Init(void)
{
    BOOL    bRegKeyReady = TRUE;
    HRESULT hr = S_OK;
    HKEY    hkey;

    _pCpMRU = NULL;

    // HKCR\\Software\\Microsoft\internet explorer\\international\\CpMRU
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, 
                         REGSTR_PATH_CPMRU,
                         0, KEY_READ|KEY_SET_VALUE, &hkey)) 
    {
        DWORD dwAction = 0;
        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                REGSTR_PATH_CPMRU,
                                0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwAction))
        {
            bRegKeyReady = FALSE;
            dwCpMRUEnable = 0;
            hr = E_FAIL;
        }
    }

    if (bRegKeyReady)
    {
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);
        BOOL  bUseDefault = FALSE;

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_ENABLE, 0, &dwType, (LPBYTE)&dwCpMRUEnable, &dwSize))
        {
            dwCpMRUEnable = 1;
            RegSetValueEx(hkey, REG_KEY_CPMRU_ENABLE, 0, REG_DWORD, (LPBYTE)&dwCpMRUEnable, sizeof(dwCpMRUEnable));
        }

        // If fail to open registry data or find unreasonable cache parameters, use default settings
        if ((ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_NUM, 0, &dwType, (LPBYTE)&dwCpMRUNum, &dwSize)) ||
            (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_INIT_HITS, 0, &dwType, (LPBYTE)&dwCpMRUInitHits, &dwSize)) ||
            (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_PERCENTAGE_FACTOR, 0, &dwType, (LPBYTE)&dwCpMRUFactor, &dwSize)) ||
            (dwCpMRUNum > MAX_CPMRU_NUM) || !dwCpMRUFactor || !dwCpMRUInitHits)
        {
            dwCpMRUNum = DEFAULT_CPMRU_NUM;
            dwCpMRUInitHits = DEFAULT_CPMRU_INIT_HITS;
            dwCpMRUFactor = DEFAULT_CPMRU_FACTOR;
            bUseDefault = TRUE;

            // Store default value in registry
            RegSetValueEx(hkey, REG_KEY_CPMRU_NUM, 0, REG_DWORD, (LPBYTE)&dwCpMRUNum, sizeof(dwCpMRUNum));
            RegSetValueEx(hkey, REG_KEY_CPMRU_INIT_HITS, 0, REG_DWORD, (LPBYTE)&dwCpMRUInitHits, sizeof(dwCpMRUInitHits));
            RegSetValueEx(hkey, REG_KEY_CPMRU_PERCENTAGE_FACTOR, 0, REG_DWORD, (LPBYTE)&dwCpMRUFactor, sizeof(dwCpMRUFactor));
        }

        dwSize = sizeof(CODEPAGE_MRU)*dwCpMRUNum;

        if (!dwSize || NULL == (_pCpMRU = (PCODEPAGE_MRU)LocalAlloc(LPTR, dwSize)))
        {
            hr = E_FAIL;
            dwCpMRUEnable = 0;
        }

        if (_pCpMRU && !bUseDefault)
        {
            dwType = REG_BINARY;        

            if (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU, 0, &dwType, (LPBYTE)_pCpMRU, &dwSize))
            {
                ZeroMemory(_pCpMRU,sizeof(CODEPAGE_MRU)*dwCpMRUNum);
            }
        }
        RegCloseKey(hkey);      
    }

    return hr;
}

// Update registry's cache value
CCpMRU::~CCpMRU(void)
{
    HKEY hkey;

    if (bCpUpdated)
    {

        if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     REGSTR_PATH_CPMRU,
                     0, KEY_READ|KEY_SET_VALUE, &hkey) == ERROR_SUCCESS) 
        {                
            DWORD dwType = REG_BINARY;
            DWORD dwSize = sizeof(CODEPAGE_MRU)*dwCpMRUNum;
            if (_pCpMRU)
            {
                RegSetValueEx(hkey, REG_KEY_CPMRU, 0, dwType, (LPBYTE)_pCpMRU, dwSize);
                LocalFree(_pCpMRU);
                _pCpMRU = NULL;
            }

            RegCloseKey(hkey);
        }
        bCpUpdated = FALSE;
            
    }
}

HRESULT CCpMRU::GetCpMRU(PCODEPAGE_MRU pCpMRU, UINT *puiCpNum)
{
        DWORD   dwTotalHits = 0;
        UINT    i;
        HRESULT hr = E_FAIL;

        if (!(*puiCpNum))
            return E_INVALIDARG;

        if (!_pCpMRU)
            return hr;

        if (!dwCpMRUEnable || !dwCpMRUInitHits)
        {
            *puiCpNum = 0;
            return S_FALSE;
        }

        ZeroMemory(pCpMRU, sizeof(CODEPAGE_MRU)*(*puiCpNum));

        // Get total hits acount
        for (i=0; i<dwCpMRUNum; i++)
        {
            if (_pCpMRU[i].dwHistoryHits)
                dwTotalHits += _pCpMRU[i].dwHistoryHits;
            else
                break;  
        }

        // Not enough hits count to determin the result, keep collecting
        if (dwTotalHits < dwCpMRUInitHits)
        {
            *puiCpNum = 0;
            return S_FALSE;
        }

        for (i=0; i<dwCpMRUNum && i<*puiCpNum; i++)
        {
            // Percentage is 1/MIN_CPMRU_FACTOR
            if (_pCpMRU[i].dwHistoryHits*dwCpMRUFactor/dwTotalHits < 1)
                break;
        }

        if (i != 0)
        {
            CopyMemory(pCpMRU, _pCpMRU, sizeof(CODEPAGE_MRU)*(i));
            *puiCpNum = i;
            hr = S_OK;
        }

        return hr;

}

// Update code page MRU
void CCpMRU::UpdateCPMRU(DWORD dwEncoding)
{
        UINT i,j;

        if (!_pCpMRU)
            return;

        if ((dwEncoding == CP_AUTO) ||
            (dwEncoding == CP_JP_AUTO) ||
            (dwEncoding == CP_KR_AUTO))
            return;

        if (!bCpUpdated)
            bCpUpdated = TRUE;


        // Sorted         
        for (i=0; i< dwCpMRUNum; i++)
        {
            if (!_pCpMRU[i].dwEncoding || (_pCpMRU[i].dwEncoding == dwEncoding))
                break;
        }

        // If not found, replace the last encoding
        if (i == dwCpMRUNum)
        {
            _pCpMRU[dwCpMRUNum-1].dwEncoding = dwEncoding;
            _pCpMRU[dwCpMRUNum-1].dwHistoryHits = 1;
        }
        else
        {
            _pCpMRU[i].dwHistoryHits ++;

            // If it is an already exist encoding, change order as needed
            if (_pCpMRU[i].dwEncoding)
            {
                for (j=i; j>0; j--)
                {
                    if (_pCpMRU[j-1].dwHistoryHits >= _pCpMRU[i].dwHistoryHits)
                    {
                        break;
                    }
                }
                if (j < i)
                {
                    // Simple sorting
                    CODEPAGE_MRU tmpCPMRU  = _pCpMRU[i];

                    MoveMemory(&_pCpMRU[j+1], &_pCpMRU[j], (i-j)*sizeof(CODEPAGE_MRU));
                    _pCpMRU[j].dwEncoding = tmpCPMRU.dwEncoding;
                    _pCpMRU[j].dwHistoryHits = tmpCPMRU.dwHistoryHits;

                }

            }
            else
            {
                _pCpMRU[i].dwEncoding = dwEncoding;
            }

        }

        // Cached too many hits?
        if (_pCpMRU[0].dwHistoryHits > 0xFFFFFFF0)
        {
            // Find the smallest one
            // This loop will always terminate
            // because at worst, it will stop at i=0 (which we know
            // is a huge number from the "if" above).
            for (i=dwCpMRUNum-1; ; i--)
            {
                if (_pCpMRU[i].dwHistoryHits > 1)
                    break;
            }

            // Decrease Cache value
            for (j=0; j<dwCpMRUNum && _pCpMRU[j].dwHistoryHits; j++)
            {
                // We still keep those one hit encodings if any
                _pCpMRU[j].dwHistoryHits /= _pCpMRU[i].dwHistoryHits;
            }
        }
}


UINT CheckEntity(LPSTR pIn, UINT nIn)
{
    UINT uiRet = 0;
    UINT uiSearchRange;
    UINT i;
    
    uiSearchRange = (nIn > MAX_ENTITY_LENTH)? MAX_ENTITY_LENTH:nIn;

    if (*pIn == '&')
    {
        for(i=0; i<uiSearchRange; i++)
        {
            if (pIn[i] == ';')
                break;
        }
        if (i < uiSearchRange)
        {
            uiSearchRange = i+1;
            // NCR Entity
            if (pIn[1] == '#')
            {
                for (i=2; i<uiSearchRange-1; i++)
                    if (!IS_DIGITA(pIn[i]))
                    {
                        uiSearchRange = 0;
                        break;
                    }
            }
            // Name Entity
            else
            {
                for (i=1; i<uiSearchRange-1; i++)
                    if (!IS_CHARA(pIn[i]))
                    {
                        uiSearchRange = 0;
                        break;
                    }
            }
        }
        else
        {
            uiSearchRange = 0;
        }
    }
    else
    {
        uiSearchRange = 0;
    }

    return uiSearchRange;
}

void RemoveHtmlTags (LPSTR pIn, UINT *pnBytes)
//
// Remove HTML tags from pIn and compress whitespace, in-place.
// On input *pnBytes is the input length; on return *pnBytes is 
// set to the resulting length.
//
// Name Entity and NCR Entity strings also removed
{
    UINT    nIn = *pnBytes;
    UINT    nOut = 0;
    UINT    nEntity = 0;
    LPSTR   pOut = pIn;
    BOOL    fSkippedSpace = FALSE;


    while ( nIn > 0 /*&& nOut + 2 < *pnBytes */) {

        if (*pIn == '<' && nIn > 1/* && !IsNoise (pIn[1])*/) {

            // Discard text until the end of this tag.  The handling here
            // is pragmatic and imprecise; what matters is detecting mostly
            // contents text, not tags or comments.
            pIn++;
            nIn--;

            LPCSTR pSkip;
            DWORD nLenSkip;

            if ( nIn > 1 && *pIn == '%' )
            {
                pSkip = "%>";			// Skip <% to %> 
                nLenSkip = 2;
            }
            else if ( nIn > 3 && *pIn == '!' && !LowAsciiStrCmpNIA(pIn, "!--", 3) )
            {
                pSkip = "-->";			// Skip <!-- to -->
                nLenSkip = 3;
            }
            else if ( nIn > 5 && !LowAsciiStrCmpNIA(pIn, "style", 5) )
            {
                pSkip = "</style>";		// Skip <style ...> to </style>
                nLenSkip = 8;
            }
            else if ( nIn > 6 && !LowAsciiStrCmpNIA(pIn, "script", 6) )
            {
                pSkip = "</script>";	// Skip <script ...> to </script>
                nLenSkip = 9;
            }
            else if ( nIn > 3 && !LowAsciiStrCmpNIA(pIn, "xml", 3) )
            {
                pSkip = "</xml>";
                nLenSkip = 6;
            }
            else
            {
                pSkip = ">";			// match any end tag
                nLenSkip = 1;
            }

            // Skip up to a case-insensitive match of pSkip / nLenSkip

            while ( nIn > 0 )
            {
                // Spin fast up to a match of the first char.
                // NOTE: the first-char compare is NOT case insensitive
                // because this char is known to never be alphabetic.

                while ( nIn > 0 && *pIn != *pSkip )
                {
                    pIn++;
                    nIn--;
                }

                if ( nIn > nLenSkip && !LowAsciiStrCmpNIA(pIn, pSkip, nLenSkip) )
                {
                    pIn += nLenSkip;
                    nIn -= nLenSkip;
                    fSkippedSpace = TRUE;

                    break;
                }

                if ( nIn > 0)
                {
                    pIn++;
                    nIn--;
                }
            }

            // *pIn is either one past '>' or at end of input

        } 
        else 
            if (IsNoise (*pIn) || (nEntity = CheckEntity(pIn, nIn)))
            {		
			
			    // Collapse whitespace -- remember it but don't copy it now
			    fSkippedSpace = TRUE;		
                if (nEntity)
                {
                    pIn+=nEntity;
                    nIn-=nEntity;
                    nEntity = 0;
                }
                else
                {
			        while (nIn > 0 && IsNoise (*pIn))
				    pIn++, nIn--;
                }
            } 
            // *pIn is non-ws char
            else 
            {
                // Pass through all other characters
                // Compress all previous noise characters to a white space
			    if (fSkippedSpace) 
                {
                    *pOut++ = ' ';
				    nOut++;
				    fSkippedSpace = FALSE;
                }

                *pOut++ = *pIn++;
                nIn--;
                nOut++;
            }
    }

    *pnBytes = nOut;
}

static unsigned char szKoi8ru[] = {0xA4, 0xA6, 0xA7, 0xB4, 0xB6, 0xB7, 0xAD, 0xAE, 0xBD, 0xBE};
static unsigned char sz28592[]  = {0xA1, 0xA6, /*0xAB,*/ 0xAC, 0xB1, 0xB5, 0xB6, 0xB9, /*0xBB, 0xE1*/}; // Need to fine tune this data

const CPPATCH CpData[] = 
{
    {CP_KOI8R,  CP_KOI8RU,      ARRAYSIZE(szKoi8ru),    szKoi8ru},
    {CP_1250,   CP_ISO_8859_2,  ARRAYSIZE(sz28592),     sz28592},
};


// Distinguish similar western encodings
UINT PatchCodePage(UINT uiEncoding, unsigned char *pStr, int nSize)
{
    int i, l,m, n, iPatch=0;

    while (iPatch < ARRAYSIZE(CpData))
    {
        if (uiEncoding == CpData[iPatch].srcEncoding)
        { 
            for (i=0; i<nSize; i++)
            {
                if (*pStr > HIGHEST_ASCII)
                {
                    l = 0;
                    m = CpData[iPatch].nSize-1;
                    n = m / 2;
                    while (l <= m)
                    {
                        if (*pStr == CpData[iPatch].pszUch[n])
                            return CpData[iPatch].destEncoding;
                        else
                        {
                            if (*pStr < CpData[iPatch].pszUch[n])
                            {
                                m = n-1;
                            }
                            else
                            {
                                l = n+1;
                            }
                            n = (l+m)/2;
                        }
                    }
                }
                pStr++;
            }
        }
        iPatch++;
    }

    return uiEncoding;
}



#if 0

const unsigned char szKOIRU[] = {0xA4, 0xA6, 0xA7, 0xB4, 0xB6, 0xB7, 0xAD, 0xAE, 0xBD, 0xBE};

BOOL _IsKOI8RU(unsigned char *pStr, int nSize)
{
    int     i,j;
    BOOL    bRet = FALSE;

    // Skip parameter check since this is internal
    for (i=0; i<nSize; i++)
    {
        if (*pStr >= szKOIRU[0] && *pStr <= szKOIRU[ARRAYSIZE(szKOIRU)-1])
        {
            for (j=0; j<ARRAYSIZE(szKOIRU); j++)
            {
                if (*pStr == szKOIRU[j])
                {
                    bRet = TRUE;
                    break;
                    
                }
            }
        }

        if (bRet)
            break;

        pStr++;
    }

    return bRet;
}

#endif


HRESULT WINAPI _DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScores)
{

    HRESULT hr = S_OK;
    IStream *pstmTmp = NULL;
    BOOL bGuess = FALSE;
    BOOL bLCDetectSucceed = FALSE;
    int nBufSize = *pnScores;
    CHAR *_pSrcStr = pSrcStr;
    UINT nSrcSize;
    int  i;
    BOOL bMayBeAscii = FALSE;

    // Check parameters
    if (!pSrcStr || !(*pcSrcSize) || !lpEncoding || *pnScores == 0)
        return E_INVALIDARG;

    nSrcSize = *pcSrcSize;

    // Zero out return buffer
    ZeroMemory(lpEncoding, sizeof(DetectEncodingInfo)*(*pnScores));

    // Simple Unicode detection
    if (nSrcSize >= sizeof(WCHAR))
    {
        UINT uiCp = 0;

        if (*((WCHAR *)pSrcStr) == 0xFEFF)      // Unicode
            uiCp = CP_UCS_2;
        else if (*((WCHAR *)pSrcStr) == 0xFFFE) // Uncode Big Endian
            uiCp = CP_UCS_2_BE;

        if (uiCp)
        {
            *pnScores = 1;
            lpEncoding[0].nCodePage = uiCp;
            lpEncoding[0].nConfidence = 100;
            lpEncoding[0].nDocPercent = 100;
            lpEncoding[0].nLangID = -1;
            return S_OK;
        }
    }
    
    // HTML: take off HTML 'decoration'
    if (dwFlag & MLDETECTCP_HTML)
    {
        // Dup buffer for HTML parser
        if (NULL == (_pSrcStr = (char *)LocalAlloc(LPTR, nSrcSize)))
            return E_OUTOFMEMORY;        
        CopyMemory(_pSrcStr, pSrcStr, nSrcSize);
        RemoveHtmlTags (_pSrcStr, &nSrcSize);
    }

    // if blank page/file...
    if (!nSrcSize)
        return E_FAIL;

    if (nSrcSize >= MIN_TEXT_SIZE)
    {
        // Initialize LCDetect
        if (NULL == g_pLCDetect) 
        {
            EnterCriticalSection(&g_cs);
            if (NULL == g_pLCDetect)
            {
                LCDetect *pLC = new LCDetect ((HMODULE)g_hInst);
                if (pLC)
                {
                    if (pLC->LoadState() == NO_ERROR)
                        g_pLCDetect = pLC;
                    else
                    {
                        delete pLC;                    
                    }
                }
            }
            LeaveCriticalSection(&g_cs);
        }

        if (g_pLCDetect)
        {
            LCD_Detect(_pSrcStr, nSrcSize, (PLCDScore)lpEncoding, pnScores, NULL);
            if (*pnScores)
            {
                hr = S_OK;
                bLCDetectSucceed = TRUE;
            }
        }
    }

    if (!bLCDetectSucceed)
    {
        *pnScores = 0;
        hr = E_FAIL;
    }
    
    unsigned int uiCodepage = 0;        
    LARGE_INTEGER li = {0,0};
    ULARGE_INTEGER uli = {0,0};


    if (S_OK == CreateStreamOnHGlobal(NULL, TRUE, &pstmTmp))
    {
        ULONG cb = (ULONG) nSrcSize ;
        if (S_OK == pstmTmp->Write(_pSrcStr,cb,&cb))
        {
            uli.LowPart = cb ;
            if (S_OK != pstmTmp->SetSize(uli))
            {
                hr = E_OUTOFMEMORY;
                goto DETECT_DONE;
            }
        }
        else
        {
            goto DETECT_DONE;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto DETECT_DONE;
    }
       
    pstmTmp->Seek(li,STREAM_SEEK_SET, NULL);

    switch (CceDetectInputCode(pstmTmp, grfDetectResolveAmbiguity|grfDetectUseCharMapping|grfDetectIgnoreEof, (EFam) 0, 0, &uiCodepage, &bGuess))
    {
        case cceSuccess:  
            if (*pnScores)
            {
                // LCDETECT never detects wrong on Arabic and Russian, don't consider it as DBCS in this case
                // because MSEncode might misdetect Arabic and Russian as Japanese
                // Same goes for Korean JOHAB, MSENCODE doesn't support it at all
                if (((lpEncoding[0].nLangID == LANG_ARABIC )|| (lpEncoding[0].nLangID == LANG_RUSSIAN) || (lpEncoding[0].nCodePage == CP_KOR_JOHAB)) &&
                    (lpEncoding[0].nConfidence >= MIN_ACCEPTABLE_CONFIDENCE) 
                    && (lpEncoding[0].nDocPercent >= MIN_DOCPERCENT) && !bGuess)
                    bGuess = TRUE;

                for (i=0;i<*pnScores;i++)
                {
                    if (lpEncoding[i].nCodePage == uiCodepage)
                    {
                        if ((i != 0) && !bGuess)
                        {
                            DetectEncodingInfo TmpEncoding;
                            // Re-arrange lanugage list for MSEncode result
                            MoveMemory(&TmpEncoding, &lpEncoding[0], sizeof(DetectEncodingInfo));
                            MoveMemory(&lpEncoding[0], &lpEncoding[i], sizeof(DetectEncodingInfo));
                            MoveMemory(&lpEncoding[i], &TmpEncoding, sizeof(DetectEncodingInfo));
                        }
                        // Boost confidence for double hits
                        lpEncoding[0].nDocPercent = 100;
                        if (lpEncoding[0].nConfidence < 100)
                            lpEncoding[0].nConfidence = 100;
                        break;
                    }
                }

                if (i == *pnScores)
                {
                    if (bGuess)
                    {
                        if (nBufSize > *pnScores)
                        {
                            lpEncoding[*pnScores].nCodePage = uiCodepage;
                            lpEncoding[*pnScores].nConfidence = MIN_CONFIDENCE;
                            lpEncoding[*pnScores].nDocPercent = MIN_DOCPERCENT;
                            lpEncoding[*pnScores].nLangID = -1;
                            (*pnScores)++;
                        }
                    }
                    else
                    {
                        if (nBufSize > *pnScores)
                        {
                            MoveMemory(lpEncoding+1, lpEncoding, sizeof(DetectEncodingInfo) * (*pnScores));
                            (*pnScores)++;
                        }
                        else
                        {
                            MoveMemory(lpEncoding+1, lpEncoding, sizeof(DetectEncodingInfo) * (*pnScores-1));
                        }
                        lpEncoding[0].nCodePage = uiCodepage;
                        lpEncoding[0].nConfidence = 100;
                        lpEncoding[0].nDocPercent = MIN_DOCPERCENT;
                        lpEncoding[0].nLangID = -1;
                    }
                }

            }
            else
            {
                lpEncoding[0].nCodePage = uiCodepage;
                if (bGuess) 
                    lpEncoding[0].nConfidence = MIN_CONFIDENCE;
                else
                    lpEncoding[0].nConfidence = 100;
                lpEncoding[0].nDocPercent = MIN_DOCPERCENT;
                lpEncoding[0].nLangID = -1;
                (*pnScores)++;
            }

            //hr = (g_pLCDetect || (nSrcSize < MIN_TEXT_SIZE)) ? S_OK : S_FALSE;
            hr = (!g_pLCDetect || (bGuess && !bLCDetectSucceed )) ? S_FALSE : S_OK;
            break;

        // Currently MSEncode doesn't provide any useful information in 'cceAmbiguousInput' case.
        // We may update our code here if Office team enhance MSEncode for ambiguous input later.
        case cceAmbiguousInput:
            break;

        case cceMayBeAscii:
            bMayBeAscii = TRUE;
            if (!(*pnScores))
            {
                lpEncoding[0].nCodePage = uiCodepage;
                lpEncoding[0].nConfidence = MIN_CONFIDENCE;
                lpEncoding[0].nDocPercent = -1;
                lpEncoding[0].nLangID = -1;
                (*pnScores)++;
            }
            else
            {
                for (i=0;i<*pnScores;i++)
                {
                    if (lpEncoding[i].nCodePage == uiCodepage)
                    {
                        break;
                    }
                }

                if (i == *pnScores)
                {
                    if(nBufSize > *pnScores) // Append MSEncode result to the language list
                    {
                       lpEncoding[i].nCodePage = uiCodepage;
                       lpEncoding[i].nConfidence = -1;
                       lpEncoding[i].nDocPercent = -1;
                       lpEncoding[i].nLangID = -1;
                       (*pnScores)++;
                    }
                }
            }
            hr = bLCDetectSucceed ? S_OK : S_FALSE;
            break;

        // MSEncode failed
        default:
            break;
    }




    for (i=0; i<*pnScores; i++)
    {
        switch (lpEncoding[i].nCodePage) {

            case 850:
                if ((*pnScores>1) && (lpEncoding[1].nConfidence >= MIN_CONFIDENCE))
                {
                    // Remove 850 from detection result if there is other detection results
                    (*pnScores)--;
                    if (i < *pnScores)
                        MoveMemory(&lpEncoding[i], &lpEncoding[i+1], (*pnScores-i)*sizeof(DetectEncodingInfo));
                    ZeroMemory(&lpEncoding[*pnScores], sizeof(DetectEncodingInfo));
                }
                else
                {
                    // Replace it with 1252 if it is the only result we get
                    lpEncoding[0].nCodePage = CP_1252; 
                    lpEncoding[0].nConfidence =
                    lpEncoding[0].nDocPercent = 100;
                    lpEncoding[0].nLangID = LANG_ENGLISH;
                }
                break;

            case CP_1250:
            case CP_KOI8R:
                lpEncoding[i].nCodePage = PatchCodePage(lpEncoding[i].nCodePage, (unsigned char *)_pSrcStr, nSrcSize);
                break;

            default:
                break;
        }
    }

    // If not a high confidence CP_1254 (Windows Turkish), 
    // we'll check if there're better detection results, and swap results if needed
    if ((lpEncoding[0].nCodePage == CP_1254) &&
        (*pnScores>1) && 
        ((lpEncoding[0].nDocPercent < 90) || (lpEncoding[1].nCodePage == CP_CHN_GB) || 
        (lpEncoding[1].nCodePage == CP_TWN) || (lpEncoding[1].nCodePage == CP_JPN_SJ) || (lpEncoding[1].nCodePage == CP_KOR_5601)))
    {
        MoveMemory(&lpEncoding[0], &lpEncoding[1], sizeof(DetectEncodingInfo)*(*pnScores-1));
        lpEncoding[*pnScores-1].nCodePage = CP_1254;
        lpEncoding[*pnScores-1].nLangID = LANG_TURKISH;
    }

    // 852 and 1258 text only have one sure detection result
    if (((lpEncoding[0].nCodePage == CP_852) || (lpEncoding[0].nCodePage == CP_1258)) &&
        (*pnScores>1) && 
        (lpEncoding[1].nConfidence >= MIN_CONFIDENCE))
    {
        DetectEncodingInfo tmpDetect = {0};
        MoveMemory(&tmpDetect, &lpEncoding[0], sizeof(DetectEncodingInfo));
        MoveMemory(&lpEncoding[0], &lpEncoding[1], sizeof(DetectEncodingInfo));
        MoveMemory(&lpEncoding[1], &tmpDetect, sizeof(DetectEncodingInfo));
    }

// Considering guessed value from MSENCODE is pretty accurate, we don't change S_OK to S_FALSE
#if 0
    if ((S_OK == hr) && !bLCDetectSucceed && bGuess) 
    {
        hr = S_FALSE;
    }
#endif

    if (uiPrefWinCodepage && *pnScores)
    {
        if (uiPrefWinCodepage == CP_AUTO && g_pCpMRU && !IS_ENCODED_ENCODING(lpEncoding[0].nCodePage))
        {
            UINT uiCpNum = CP_AUTO_MRU_NUM;
            CODEPAGE_MRU CpMRU[CP_AUTO_MRU_NUM];

            if (S_OK == g_pCpMRU->GetCpMRU(CpMRU, &uiCpNum))
            {
                for (i = 0; i<*pnScores; i++)
                {
                    for (UINT j = 0; j < uiCpNum; j++)
                    {
                        if (lpEncoding[i].nCodePage == CpMRU[j].dwEncoding)
                        {
                            uiPrefWinCodepage = CpMRU[j].dwEncoding;
                            break;
                        }
                    }
                    if (uiPrefWinCodepage != CP_AUTO)
                        break;
                }

                // If detection result is not in MRU
                if (uiPrefWinCodepage == CP_AUTO)
                {
                    // Don't take Unicode as perferred encoding if it is not in detection results for following reasons
                    // 1. Unicode is usually tagged with charset or Unicode BOM
                    // 2. Currently, we don't support Unicode detection in all detection engines
                    if (CpMRU[0].dwEncoding != CP_UCS_2 && CpMRU[0].dwEncoding != CP_UCS_2_BE)
                        uiPrefWinCodepage = CpMRU[0].dwEncoding;
                }
            }
        }

        // End preferred CP check if we can't get a valid one
        if (uiPrefWinCodepage == CP_AUTO)
            goto PREFERCPCHECK_DONE;

        for (i = 1; i<*pnScores; i++)
        {
            if (uiPrefWinCodepage == lpEncoding[i].nCodePage)
            {
                DetectEncodingInfo TmpEncoding;
                // Re-arrange lanugage list for prefered codepage
                TmpEncoding = lpEncoding[i];
                MoveMemory(&lpEncoding[1], &lpEncoding[0], sizeof(DetectEncodingInfo)*i);
                lpEncoding[0] = TmpEncoding;
                break;
            }
        }

        if ((uiPrefWinCodepage != lpEncoding[0].nCodePage) && 
            ((bMayBeAscii && (lpEncoding[0].nConfidence <= MIN_CONFIDENCE)) ||
            (hr != S_OK && nSrcSize >= MIN_TEXT_SIZE) ||
            (nSrcSize < MIN_TEXT_SIZE && !IS_ENCODED_ENCODING(lpEncoding[0].nCodePage))))
        {
            lpEncoding[0].nCodePage = uiPrefWinCodepage;
            lpEncoding[0].nConfidence = -1;
            lpEncoding[0].nDocPercent = -1;
            lpEncoding[0].nLangID = -1;
            *pnScores = 1;
        }
    }

PREFERCPCHECK_DONE:

    // Assume LCDETECT won't misdetect 1252 for files over MIN_TEXT_SIZE
    // and MSENCODE can handle encoded text even they're below MIN_TEXT_SIZE
    if (((nSrcSize < MIN_TEXT_SIZE) && (bMayBeAscii || E_FAIL == hr)) ||
        (lpEncoding[0].nCodePage == CP_1252) ||
        (lpEncoding[0].nCodePage == CP_UTF_8))
    {
        UINT j;
        for (j=0; j < nSrcSize; j++)
            if (*((LPBYTE)(_pSrcStr+j)) > HIGHEST_ASCII)
                break;
        if (j == nSrcSize)
        {
            if (lpEncoding[0].nCodePage == CP_1252)
            {
                lpEncoding[0].nCodePage = CP_20127;
            }
            else
            {
                *pnScores = 1;
                lpEncoding[0].nCodePage = CP_20127; 
                lpEncoding[0].nConfidence =
                lpEncoding[0].nDocPercent = 100;
                lpEncoding[0].nLangID = LANG_ENGLISH;
                hr = S_OK;
            }
        }
    }

    // UTF-8 doesn't really have distinctive signatures, 
    // if text amout is small, we won't return low confidence UTF-8 detection result.
    if (hr == S_FALSE && IS_ENCODED_ENCODING(lpEncoding[0].nCodePage) &&
        !((nSrcSize < MIN_TEXT_SIZE) && (lpEncoding[0].nCodePage == CP_UTF_8)))
        hr = S_OK;

DETECT_DONE:

    if ((dwFlag & MLDETECTCP_HTML) && _pSrcStr)
        LocalFree(_pSrcStr);

    if (pstmTmp)
    {
        pstmTmp->Release();
    }

    return hr ;
}

HRESULT WINAPI _DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScores)
{

    HRESULT hr= S_OK, hrWarnings=S_OK;
    LARGE_INTEGER  libOrigin = { 0, 0 };
    ULARGE_INTEGER  ulPos = {0, 0};
    LPSTR lpstrIn = NULL ; 
    ULONG nlSrcSize ;
    INT nSrcUsed ;

    if (!pstmIn)
        return E_INVALIDARG ;

    // get size
    hr = pstmIn->Seek(libOrigin, STREAM_SEEK_END,&ulPos);
    if (S_OK != hr)
        hrWarnings = hr;

    if ( ulPos.LowPart == 0 && ulPos.HighPart == 0 )
        return E_INVALIDARG ;

    nlSrcSize = ulPos.LowPart ;

    // allocate a temp input buffer 
    if ( (lpstrIn = (LPSTR) LocalAlloc(LPTR, nlSrcSize )) == NULL )
    {
        hrWarnings = E_OUTOFMEMORY ;
        goto exit;
    }

    // reset the pointer
    hr = pstmIn->Seek(libOrigin, STREAM_SEEK_SET, NULL);
    if (S_OK != hr)
        hrWarnings = hr;

    hr = pstmIn->Read(lpstrIn, nlSrcSize, &nlSrcSize);
    if (S_OK != hr)
        hrWarnings = hr;

    nSrcUsed = (INT) nlSrcSize ;
    hr = _DetectInputCodepage(dwFlag, uiPrefWinCodepage, lpstrIn, &nSrcUsed, lpEncoding, pnScores);

exit :
    if (lpstrIn)
    {
        LocalFree(lpstrIn);
    }

    return (hr == S_OK) ? hrWarnings : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\cpdetect.h ===
#ifndef _CPDETECT_H_
#define _CPDETECT_H_

#define MAX_CONFIDENCE     100  
#define MIN_CONFIDENCE     86
#define MIN_DOCPERCENT     60
#define MIN_TEXT_SIZE      200
#define HIGHEST_ASCII      127
#define MIN_ACCEPTABLE_CONFIDENCE   60

#define DEFAULT_CPMRU_INIT_HITS 100
#define DEFAULT_CPMRU_FACTOR    20
#define CP_AUTO_MRU_NUM         6
#define DEFAULT_CPMRU_NUM       10
#define MAX_CPMRU_NUM           20
#define MAX_ENTITY_LENTH        10

#define IsNoise(c) ((unsigned)(c) <= 0x20 && (c) != 0 && (c) != 0x1B)
#define IS_ENCODED_ENCODING(cp) ((cp) == CP_ISO_2022_JP || (cp) == CP_CHN_HZ || (cp) == CP_UTF_7 || (cp) == CP_UTF_8 || (cp) == CP_ISO_2022_KR)

typedef struct _CODEPAGE_MRU 
{
    DWORD   dwEncoding;
    DWORD   dwHistoryHits;
} CODEPAGE_MRU, *PCODEPAGE_MRU;

typedef struct tagCpPatch
{
    UINT            srcEncoding;
    UINT            destEncoding;
    UINT            nSize;
    unsigned char   *pszUch;
} CPPATCH;

// Dump everything under
// HKCU\\Software\\Microsoft\\Internet Explorer\\International
#define REGSTR_PATH_CPMRU TSZMICROSOFTPATH TEXT("\\Internet Explorer\\International\\CpMRU")
#define REG_KEY_CPMRU                   TEXT("Cache")
#define REG_KEY_CPMRU_ENABLE            TEXT("Enable")
#define REG_KEY_CPMRU_NUM               TEXT("Size")
#define REG_KEY_CPMRU_INIT_HITS         TEXT("InitHits")
#define REG_KEY_CPMRU_PERCENTAGE_FACTOR TEXT("Factor")


// CCpMRU
class CCpMRU
{
    PCODEPAGE_MRU   _pCpMRU;

    DWORD           dwCpMRUNum;
    DWORD           dwCpMRUInitHits;
    DWORD           dwCpMRUFactor;

public:
    DWORD           dwCpMRUEnable;
    BOOL            bCpUpdated;

    CCpMRU::CCpMRU(void)
    {
        // No update at initial time
        bCpUpdated = FALSE;
        _pCpMRU = NULL;
    }

    ~CCpMRU(void);
    HRESULT Init(void);
    HRESULT GetCpMRU(PCODEPAGE_MRU pCpMRU, UINT *puiCpNum);
    void UpdateCPMRU(DWORD dwEncoding);

};
void RemoveHtmlTags (LPSTR pIn, UINT *pnBytes);
UINT PatchCodePage(UINT uiEncoding, unsigned char *pStr, int nSize);
extern class CCpMRU * g_pCpMRU;

#endif  // _CPDETECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\convinet.cpp ===
#include "private.h"
#include "jisobj.h"
#include "eucjobj.h"
#include "hzgbobj.h"
#include "kscobj.h"

#include "utf8obj.h"
#include "utf7obj.h"

#include "fechrcnv.h"

#include "codepage.h"

#include "ichrcnv.h"



HRESULT CICharConverter::KSC5601ToEUCKR(LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize)
{
    int nSize=0;
    int i=0;
    HRESULT hr = S_OK;
    UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    


    if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
    {
        // only take SBCS, no DBCS character
        if ( 1 != WideCharToMultiByte(CP_KOR_5601, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
            szDefaultChar[0] = 0x3f;
    }


    while(i < *lpnSrcSize)
    {
        // Check space
        if (lpDestStr && (nSize > cchDest))
            break;

        //  DBCS
        if (((UCHAR)lpSrcStr[i] >= 0x81 && (UCHAR)lpSrcStr[i] <= 0xFE) && (i+1 < *lpnSrcSize))
        {

            // UHC 
            if (!((UCHAR)lpSrcStr[i] >= 0xA1 && (UCHAR)lpSrcStr[i] <= 0xFE &&
                  (UCHAR)lpSrcStr[i+1] >= 0xA1 && (UCHAR)lpSrcStr[i+1] <= 0xFE))

            {
                // use NCR if flag specified
                if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
                {
                    char    szDstStr[10] = {0};
                    WCHAR   szwChar[2];
                    int     cCount;
               
                    if (MultiByteToWideChar(CP_KOR_5601, 0, &lpSrcStr[i], 2, szwChar, ARRAYSIZE(szwChar)))
                    {
                        // Caculate NCR length
                        _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                        cCount = lstrlenA(szDstStr)+3;
                        // Not enough space for NCR entity
                        if (lpDestStr)
                        {
                            if (nSize+cCount > cchDest)
                                break;
                            // Output NCR entity
                            else
                            {                                    
                                *lpDestStr ++= '&';
                                *lpDestStr ++= '#';
                                for (int j=0; j< cCount-3; j++)
                                    *lpDestStr++=szDstStr[j];
                                *lpDestStr ++= ';';
                            }
                        }
                        nSize += cCount;
                    }
                    else
                    {
                        if (lpDestStr)
                        {
                            if (nSize+1 > cchDest)
                                break;
                            *lpDestStr++=szDefaultChar[0];
                        }
                        nSize++;
                        hr = S_FALSE;
                    }
                }
                // use default char, question mark
                else
                {
                    if (lpDestStr)
                    {
                        if (nSize+1 > cchDest)
                            break;
                        *lpDestStr++=szDefaultChar[0];
                    }
                    nSize++;
                    hr = S_FALSE;
                }
                i += 2;
            }
            // Wansung
            else
            {
                if (lpDestStr)
                {
                    if (nSize+2 > cchDest)
                        break;
                    *lpDestStr++=lpSrcStr[i];
                    *lpDestStr++=lpSrcStr[i+1];
                }
                i+=2;
                nSize += 2;
            }
        }
        // SBCS
        else
        {
            if (lpDestStr)
            {
                if (nSize+1 > cchDest)
                    break; 
                *lpDestStr++=lpSrcStr[i];
            }
            nSize++;
            i++;
        }
    } // End of loop

    if (lpnSize)
        *lpnSize = nSize;

    return hr;
}


/******************************************************************************
******************   C O N V E R T   I N E T   S T R I N G   ******************
******************************************************************************/
HRESULT CICharConverter::CreateINetString(BOOL fInbound, UINT uCodePage, int nCodeSet)
{
    if (_hcins)
    {
        delete _hcins ;
        _hcins = NULL ;
    }

    if (fInbound) { // Inbound
        if (uCodePage == CP_JPN_SJ && ( nCodeSet == CP_ISO_2022_JP ||
            nCodeSet == CP_ISO_2022_JP_ESC || nCodeSet == CP_ISO_2022_JP_SIO ))
            // JIS
            _hcins = new CInccJisIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_JPN_SJ && nCodeSet == CP_EUC_JP ) // EUC
            _hcins = new CInccEucJIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_CHN_GB && nCodeSet == CP_CHN_HZ ) // HZ-GB
            _hcins = new CInccHzGbIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_KOR_5601 && nCodeSet == CP_ISO_2022_KR )
            _hcins = new CInccKscIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_8 )
            _hcins = new CInccUTF8In(uCodePage, nCodeSet);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_7 )
            _hcins = new CInccUTF7In(uCodePage, nCodeSet);

    } else { // Outbound
        if (uCodePage == CP_JPN_SJ && ( nCodeSet == CP_ISO_2022_JP ||
            nCodeSet == CP_ISO_2022_JP_ESC || nCodeSet == CP_ISO_2022_JP_SIO ))
            // JIS
            _hcins = new CInccJisOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_JPN_SJ && nCodeSet == CP_EUC_JP ) // EUC
            _hcins = new CInccEucJOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_CHN_GB && nCodeSet == CP_CHN_HZ ) // HZ-GB
            _hcins = new CInccHzGbOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_KOR_5601 && nCodeSet == CP_ISO_2022_KR )
            _hcins = new CInccKscOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_8 )
            _hcins = new CInccUTF8Out(uCodePage, nCodeSet);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_7 )
            _hcins = new CInccUTF7Out(uCodePage, nCodeSet);

    }

    // recode the dst codepage
    if ( _hcins )
        _hcins_dst =  nCodeSet ;

    return S_OK ;
}

HRESULT CICharConverter::DoConvertINetString(LPDWORD lpdwMode, BOOL fInbound, UINT uCodePage, int nCodeSet,
      LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize)
{
    HRESULT hr = S_OK;
    HCINS hcins = NULL;
    int nSize = 0 ;
    int cchSrc = *lpnSrcSize ;

    if (!lpnSize)
        lpnSize = &nSize;

    if (!uCodePage) // Get default code page if nothing speicified
        uCodePage = g_uACP;

    if (!lpSrcStr && cchSrc < 0) // Get length of lpSrcStr if not given, assuming lpSrcStr is a zero terminate string.
        cchSrc = lstrlenA(lpSrcStr) + 1;

    if (!_hcins || ( nCodeSet != _hcins_dst ) )
        CreateINetString(fInbound,uCodePage,nCodeSet);

    if (_hcins ) { // Context created, it means DBCS
        int nTempSize = 0 ;
        
        // restore previous mode SO/SI ESC etc.
        ((CINetCodeConverter*)_hcins)->SetConvertMode(*lpdwMode);

        // if it is a JIS output set Kana mode
        if (!fInbound && uCodePage == CP_JPN_SJ && ( nCodeSet == CP_ISO_2022_JP ||
            nCodeSet == CP_ISO_2022_JP_ESC || nCodeSet == CP_ISO_2022_JP_SIO ))
            // JIS
            ((CInccJisOut*)_hcins)->SetKanaMode(nCodeSet);

        if (!lpDestStr || !cchDest) // Get the converted size
        {
            hr = ((CINetCodeConverter*)_hcins)->GetStringSizeA(lpSrcStr, cchSrc, lpnSize);
            if (0 == fInbound) 
            {
                HRESULT _hr = ((CINetCodeConverter*)_hcins)->GetStringSizeA(NULL, 0, &nTempSize);
                if (S_OK != _hr)
                    hr = _hr;
            }
        }
        else // Perform actual converting
        {
            hr = ((CINetCodeConverter*)_hcins)->ConvertStringA(lpSrcStr, cchSrc, lpDestStr, cchDest, lpnSize);
            if (0 == fInbound) 
            {
                HRESULT _hr = ((CINetCodeConverter*)_hcins)->ConvertStringA(NULL, 0, lpDestStr+*lpnSize, cchDest-*lpnSize, &nTempSize);
                if (S_OK != _hr)
                    hr = _hr;
            }
        }

        *lpnSize += nTempSize;

        // get number of unconvetable bytes 
        if ( lpnSrcSize && ((CINetCodeConverter*)_hcins)->GetUnconvertBytes() )
            *lpnSrcSize = cchSrc -((CINetCodeConverter*)_hcins)->GetUnconvertBytes();

        // only save current mode SO/SI ESC if we are perform actual converting
        // we need this if statement because for two stages plus conversion.
        // It will inquire the size first then convert from IWUU or UUWI.

        if (lpDestStr && lpdwMode )
            *lpdwMode = ((CINetCodeConverter*)_hcins)->GetConvertMode();

//        delete hcins;
    } else { 
        // Internet encodings that have same encoding scheme as their family encodings
        switch (nCodeSet)
        {
            case CP_EUC_KR:
                hr = KSC5601ToEUCKR(lpSrcStr, lpnSrcSize, lpDestStr, cchDest, lpnSize);
                break;

            default:
                if (!lpDestStr || !cchDest) // Get the converted size
                   *lpnSize = cchSrc ;
                else
                {
                   *lpnSize = min(cchSrc, cchDest);
                   if (*lpnSize)
                      MoveMemory(lpDestStr, lpSrcStr, *lpnSize);
                }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detcbase.h ===
class CINetCodeDetector
{
public:
	CINetCodeDetector() {}
	virtual ~CINetCodeDetector() {}
	int DetectStringA(LPCSTR lpSrcStr, int cchSrc);

protected:
	virtual BOOL DetectChar(UCHAR tc) = 0;
	virtual BOOL CleanUp() = 0;
	virtual int GetDetectedCodeSet() = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detcbase.cpp ===
// ============================================================================
// Internet Code Set Detection: Base Class
// ============================================================================

#include "private.h"
#include "detcbase.h"

/******************************************************************************
**********************   D E T E C T   S T R I N G   A   **********************
******************************************************************************/

int CINetCodeDetector::DetectStringA(LPCSTR lpSrcStr, int cchSrc)
{
	BOOL fDetected = FALSE;

	while (cchSrc-- > 0) {
		if (fDetected = DetectChar(*lpSrcStr++))
			break;
	}

	if (!fDetected)
		(void)CleanUp();

	return GetDetectedCodeSet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "mlang"
#define SZ_MODULE       "MLANG"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detckrn.h ===
#define SCORE_NONE	0
#define SCORE_MINOR	1
#define SCORE_MAJOR	2

class CIncdKorean : public CINetCodeDetector
{
private:

	enum {NO_ESC, sESC, sESC_1, sESC_2 } m_nEscMode;
	BOOL m_bFindDesigator;
	INT  m_nCharCount;

public:
	CIncdKorean();
	~CIncdKorean() {}

protected:
	virtual BOOL DetectChar(UCHAR tc);
	virtual BOOL CleanUp() {return FALSE;}
	virtual int GetDetectedCodeSet();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detcjpn.cpp ===
// =================================================================================
// Internet Character Set Detection: For Japanese
// =================================================================================

#include "private.h"
#include "detcbase.h"
#include "detcjpn.h"
#include "fechrcnv.h"
#include "codepage.h"

CIncdJapanese::CIncdJapanese(DWORD nCp)
{
    m_nScoreJis = 0;
    m_nScoreEuc = 0;
    m_nScoreSJis = 0;

    m_nISOMode = NONE ;
    m_nJISMode = REGULAR;
    m_nEucMode = REGULAR;
    m_fDoubleByteSJis = FALSE;
    // If Jpn autoselect, we'll bias to Shift-Jis like we did before
    m_nPreferredCp = (nCp == CP_JP_AUTO)? CP_JPN_SJ : nCp;
}

BOOL CIncdJapanese::CheckISOChar(UCHAR tc)
{
    switch (m_nISOMode) {
    case NONE:
        if ( tc == ESC )
            m_nISOMode = ISO_ESC ;
        break;
    case ISO_ESC:
        if ( tc == ISO2022_IN_CHAR )        // '$'
            m_nISOMode = ISO_ESC_IN ;
        else if ( tc == ISO2022_OUT_CHAR )
            m_nISOMode = ISO_ESC_OUT ;      // '('
        else
            m_nISOMode = NONE ;
        break;
    case ISO_ESC_IN:    // esc '$'
        m_nISOMode = NONE ;
        if ( tc == ISO2022_IN_JP_CHAR1 ||       // 'B'
                tc == ISO2022_IN_JP_CHAR2 )     // '@'
        {
            m_nJISMode = DOUBLEBYTE ;
            return TRUE ;
        }
        break;
    case ISO_ESC_OUT:   // esc '('
        m_nISOMode = NONE ;
        if ( tc == ISO2022_OUT_JP_CHAR1 ||      //	'B'
                tc == ISO2022_OUT_JP_CHAR2 )    //	'J'
        {
            m_nJISMode = REGULAR ;
            return TRUE ;
        }
        else if ( tc == ISO2022_OUT_JP_CHAR3 )   //	'I'
        {
            m_nJISMode = KATAKANA;
            return TRUE ;
        }
        break;
    }
    return FALSE;
}

BOOL CIncdJapanese::DetectChar(UCHAR tc)
{
	// JIS
	if ( CheckISOChar(tc) )
	    return FALSE;   // JIS mode change, don't need to check other type

	switch (m_nJISMode) {
	case REGULAR:
	    if (tc < 0x80)
	        m_nScoreJis += SCORE_MAJOR;
	    break;
	case DOUBLEBYTE:
	case KATAKANA:
	    m_nScoreJis += SCORE_MAJOR;
	    return FALSE;   // In JIS mode for sure, don't need to check other type
	}

	// EUC-J
	switch (m_nEucMode) {
	case REGULAR:
		if (tc >= 0xa1 && tc <= 0xfe) // Double Byte
			m_nEucMode = DOUBLEBYTE;
		else if (tc == 0x8e) // Single Byte Katakana
			m_nEucMode = KATAKANA;
		else if (tc < 0x80)
			m_nScoreEuc += SCORE_MAJOR;
		break;
	case DOUBLEBYTE:
		if (tc >= 0xa1 && tc <= 0xfe)
			m_nScoreEuc += SCORE_MAJOR * 2;
		m_nEucMode = REGULAR;
		break;
	case KATAKANA:
		if (tc >= 0xa1 && tc <= 0xdf) // Katakana range
			m_nScoreEuc += SCORE_MAJOR * 2;
		m_nEucMode = REGULAR;
		break;
	}

	// Shift-JIS
	if (!m_fDoubleByteSJis) {
		if ((tc >= 0x81 && tc <= 0x9f) || (tc >= 0xe0 && tc <= 0xfc)) // Double Byte
			m_fDoubleByteSJis = TRUE;
		else if (tc <= 0x7e || (tc >= 0xa1 && tc <= 0xdf))
			m_nScoreSJis += SCORE_MAJOR;
	} else {
		if (tc >= 0x40 && tc <= 0xfc && tc != 0x7f) // Trail Byte range
			m_nScoreSJis += SCORE_MAJOR * 2;
		m_fDoubleByteSJis = FALSE;
	}

	return FALSE;
}

int CIncdJapanese::GetDetectedCodeSet()
{
    int nMaxScore = m_nScoreSJis;
    int nCodeSet = CP_JPN_SJ;

    if (m_nScoreEuc > nMaxScore) {
	    nMaxScore = m_nScoreEuc;
	    nCodeSet = CP_EUC_JP ; // EUC
    } else if (m_nScoreEuc == nMaxScore) {
        if (m_nScoreEuc > MIN_JPN_DETECTLEN * SCORE_MAJOR) 
            // If the given string is not long enough, we should rather choose SJIS
            // This helps fix the bug when we are just given Window Title
            // at Shell HyperText view.
	        nCodeSet = CP_EUC_JP ; // EUC
        else
            // If we can't distinguish between EUC and Shift-Jis, we use the preferred one
            nCodeSet = m_nPreferredCp;
    }

    // JIS
    if (m_nScoreJis > nMaxScore) 
	    nCodeSet = CP_ISO_2022_JP ; 
    // Even score means all 7bits chars
    // in this case, it maybe just pure ANSI data, we return it is ambiguous.
    else if (m_nScoreJis == nMaxScore) 
	    nCodeSet = 0 ;    

    return nCodeSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detcjpn.h ===
#include "codepage.h"
#define SCORE_NONE	0
#define SCORE_MINOR	1
#define SCORE_MAJOR	2

class CIncdJapanese : public CINetCodeDetector
{
private:
    long m_nScoreJis;
    long m_nScoreEuc;
    long m_nScoreSJis;
    DWORD m_nPreferredCp;

    enum {NONE, ISO_ESC, ISO_ESC_IN, ISO_ESC_OUT } m_nISOMode;
    enum {REGULAR, DOUBLEBYTE, KATAKANA} m_nEucMode, m_nJISMode ;
    BOOL m_fDoubleByteSJis;

public:
    CIncdJapanese(DWORD nCp = CP_JPN_SJ);
    ~CIncdJapanese() {}

protected:
    virtual BOOL CheckISOChar(UCHAR tc);
    virtual BOOL DetectChar(UCHAR tc);
    virtual BOOL CleanUp() {return FALSE;}
    virtual int GetDetectedCodeSet();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detckrn.cpp ===
// =================================================================================
// Internet Character Set Detection: For Korean
// =================================================================================

#include "private.h"
#include "detcbase.h"
#include "detckrn.h"
#include "fechrcnv.h"
#include "codepage.h"

CIncdKorean::CIncdKorean()
{
    m_nEscMode = NO_ESC ;
	m_bFindDesigator = FALSE ;
	m_nCharCount = 0 ;
}

BOOL CIncdKorean::DetectChar(UCHAR tc)
{
	switch ( tc ) 
    {
	    case ESC:
	   	    if ( m_nEscMode == NO_ESC )
        	    m_nEscMode = sESC ;
            else
        	    m_nEscMode = NO_ESC ;
		    break;
        case ISO2022_IN_CHAR :      // 	'$'
	   	    if ( m_nEscMode == sESC )
        	    m_nEscMode = sESC_1 ;
            else
        	    m_nEscMode = NO_ESC ;
		    break;
        case ISO2022_IN_KR_CHAR_1 : //	')'
	   	    if ( m_nEscMode == sESC_1 )
        	    m_nEscMode = sESC_2 ;
            else
        	    m_nEscMode = NO_ESC ;
		    break;
        case ISO2022_IN_KR_CHAR_2 : //	'C'
	   	    if ( m_nEscMode == sESC_2 )
            {
                m_bFindDesigator = TRUE ;
            	return TRUE ;
            }
		    break;
        default:
       	    m_nEscMode = NO_ESC ;
		    break;
    }

    // only look ahead a max 1024 char
    if ( ++m_nCharCount > 1024 )
	    return TRUE;

	return FALSE;
}

int CIncdKorean::GetDetectedCodeSet()
{
    if ( m_bFindDesigator )
		return CP_ISO_2022_KR ; // ISO
    else
		return CP_KOR_5601 ; // Korean Windows 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\detect.h ===
/*
 * Automatic language and codepage detector
 * 
 * Bob Powell, 2/97
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 */

#ifdef  __cplusplus

#include <wtypes.h>
#include <limits.h>

#include "lcdetect.h"
#include "lccommon.h"

#include <qsort.h>


// Turn this on in SOURCES to enable debug output
#ifdef DEBUG_LCDETECT
#include <stdio.h>
extern int g_fDebug;
#define debug(x) { if (g_fDebug) { x; }}
#define unmapch(x) ((x) >= 2 ? (x)+'a'-2 : ' ')
#else
#define debug(x)
#endif

class LCDetect;
typedef LCDetect *PLCDetect;

class Language;
class Language7Bit;
class Language8Bit;
class LanguageUnicode;
typedef Language *PLanguage;
typedef Language7Bit *PLanguage7Bit;
typedef Language8Bit *PLanguage8Bit;
typedef LanguageUnicode *PLanguageUnicode;

class CScore;
class CScores;

/****************************************************************/

#define MAXSCORES 50			// Max possible simultaneous # of scores

#define MINRAWSCORE 100			// Score threshhold (weight * char count) 
								// for further processing

/****************************************************************/

// Histograms

// A histogram stores an array of n-gram occurrence counts.  
// HElt stores the count, at present this is an unsigned char.

// The in-memory structure is similar to the file.
// The histogram array pointers m_panElts point into the mapped file image.

class Histogram {

public:
	Histogram (const PFileHistogramSection pHS, const PHIdx pMap);
	Histogram (const Histogram &H, const PHIdx pMap);
	virtual ~Histogram (void);

	DWORD Validate (DWORD nBytes) const;

	UCHAR Dimensionality (void) { return m_nDimensionality; }
	UCHAR EdgeSize (void) { return m_nEdgeSize; }
	USHORT CodePage (void) { return m_nCodePage; }
	USHORT GetRangeID (void) { return m_nRangeID; }
	USHORT NElts (void) { return m_nElts; }
	PHIdx GetMap (void) { return m_pMap; }

	HElt Ref (USHORT i1) const { return m_panElts[i1]; }
	HElt Ref (UCHAR i1, UCHAR i2) const {
		return m_panElts[(i1 * m_nEdgeSize) + i2]; }
	HElt Ref (UCHAR i1, UCHAR i2, UCHAR i3) const {
		return m_panElts[((i1 * m_nEdgeSize) + i2) * m_nEdgeSize + i3]; }

	HElt *Array (void) { return m_panElts; }

protected:
	UCHAR m_nDimensionality;		// 1=unigram, 2=digram etc.
	UCHAR m_nEdgeSize;				// edge size (is a function of char map)
	union {
		USHORT m_nCodePage;			// For 7 and 8-bit, is code page
		USHORT m_nRangeID;			// For Unicode, is sub-language range ID
	};
	USHORT m_nElts;					// (edge size ^ dimensionality)
	PHIdx m_pMap;					// char/WCHAR to histogram idx mapping

	HElt *m_panElts;				// array of elements / counts
};
typedef Histogram *PHistogram;

/****************************************************************/

// A Language object stores all the detection state for a given language,
// i.e. primary language ID.

class Language {
public:
	// nCodePages is same as nSubLangs
	Language (PLCDetect pL, int nLangID, int nCodePages, int nRangeID = 0);
	virtual ~Language (void) { }

	virtual DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx) = 0;

	// Score the code pages for this language
	virtual void ScoreCodePage (LPCSTR, int nCh, CScore &S, int &idx) const;

	int LanguageID (void) const { return m_nLangID; }
	int NCodePages (void) const { return m_nCodePages; }
	int NSubLangs (void) const { return m_nSubLangs; }
	int RangeID (void) const { return m_nRangeID; }
	int GetScoreIdx (void) const { return m_nScoreIdx; }
	void SetScoreIdx (int nScoreIdx) { m_nScoreIdx = nScoreIdx; }

	virtual int GetCodePage (int n) const { return 0; }
	virtual int GetSublangRangeID (int n) const { return 0; }
	virtual int GetSublangID (int n) const { return 0; }

	virtual DetectionType Type (void) = 0;
	virtual Language7Bit const * GetLanguage7Bit (void) const { return NULL; }
	virtual Language8Bit const * GetLanguage8Bit (void) const { return NULL; }
	virtual LanguageUnicode const * GetLanguageUnicode (void) const { return NULL; }

protected:
	PLCDetect m_pLC;

	int m_nLangID;		// Win32 primary language ID
	int m_nRangeID;		// Unicode range ID, for Unicode langs
	union {
		int m_nCodePages;	// # of code pages trained for this language
		int m_nSubLangs;
	};
	int m_nScoreIdx;	// Used to create a unique index into the score arrays
						// for each lang + cp combination, to eliminate the
						// need to search the arrays to merge scores.  Add
						// the code page index to this to get the array index.
};

////////////////////////////////////////////////////////////////

class Language7Bit : public Language {
public:
	Language7Bit (PLCDetect pL, int nLangID, int nCodePages);
	~Language7Bit (void);

	DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx);

	void ScoreCodePage (LPCSTR, int nCh, CScore &S, int &idx) const;

	int GetCodePage (int n) const { return m_ppCodePageHistogram[n]->CodePage();}
	virtual DetectionType Type (void) { return DETECT_7BIT; }

	PHistogram GetLangHistogram (void) const { return m_pLangHistogram; }
	PHistogram GetCodePageHistogram (int i) const { 
		return m_ppCodePageHistogram[i]; }

	virtual Language7Bit const * GetLanguage7Bit (void) const { return this; }

	const PHElt * GetPHEltArray (void) const { return m_paHElt; }

private:
	PHistogram m_pLangHistogram;
	PHistogram m_ppCodePageHistogram[MAXSUBLANG];

	PHElt m_paHElt[MAXSUBLANG];
};

////////////////////////////////////////////////////////////////

class Language8Bit : public Language {
public:
	Language8Bit (PLCDetect pL, int nLangID, int nCodePages);
	~Language8Bit (void);

	DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx);

	int GetCodePage (int n) const { return m_ppHistogram[n]->CodePage(); }

	virtual DetectionType Type (void) { return DETECT_8BIT; }

	PHistogram GetHistogram (int i) const { return m_ppHistogram[i]; }

	virtual Language8Bit const * GetLanguage8Bit (void) const { return this; }

private:
	PHistogram m_ppHistogram[MAXSUBLANG];
};

////////////////////////////////////////////////////////////////

class LanguageUnicode : public Language {
public:
	LanguageUnicode (PLCDetect pL, int nLangID, int nRecordCount, int nRangeID);
	~LanguageUnicode (void);
	
	DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx);
	
	void ScoreSublanguages (LPCWSTR wcs, int nch, CScores &S) const;

	int GetSublangRangeID (int i) const{return GetHistogram(i)->GetRangeID();}
	PLanguageUnicode GetSublanguage (int n) const;

	virtual DetectionType Type (void) { return DETECT_UNICODE; }

	PHistogram GetHistogram (int i) const { return m_ppSubLangHistogram[i]; }

	virtual LanguageUnicode const * GetLanguageUnicode (void) const { 
		return this; 
	}

	const PHElt * GetPHEltArray (void) const { return m_paHElt; }

private:
	PHistogram m_ppSubLangHistogram[MAXSUBLANG];

	PHElt m_paHElt[MAXSUBLANG];
};

/****************************************************************/

class Charmap {

public:
	Charmap (PFileMapSection pMS) :	m_nID(pMS->m_dwID),	m_nSize(pMS->m_dwSize),
		m_nUnique(pMS->m_dwNUnique), m_pElts( (PHIdx) (&pMS[1]) ) { }

//	int ID (void) const { return m_nID; }
	int Size (void) const { return m_nSize; }
	int NUnique (void) const { return m_nUnique; }
	PHIdx Map (void) const { return m_pElts; }
	HIdx Map (WCHAR x) const { return m_pElts[x]; }

private:
	int m_nID;			// ID by which hardwired code finds the table
	int	m_nSize;		// size of table (256 or 65536)
	int m_nUnique;		// # of unique output values
	
	PHIdx m_pElts;
};
typedef Charmap *PCharmap;

/****************************************************************/

// class CScore -- score for one lang and/or code page, variously used for
// individual chunks and also for an entire document.

class CScore {
public:
	// Only these two slots need to be initialized
	CScore (void) : m_nScore(0), m_nChars(0) {}
	~CScore (void) { }
	
	const PLanguage GetLang (void) const { return m_pLang; }
	int GetScore (void) const { return m_nScore; }
	unsigned short GetCodePage (void) const { return m_nCodePage; }
	unsigned short GetCharCount (void) const { return m_nChars; }

	void SetLang (PLanguage p) { m_pLang = p; }
	void SetScore (int x) { m_nScore = x; }
	void SetCharCount (unsigned x) { m_nChars = (unsigned short)x; }
	void SetCodePage (unsigned x) { m_nCodePage = (unsigned short)x; }

	void Add (CScore &S) { 
		SetLang(S.GetLang());
		SetCodePage(S.GetCodePage());
		SetScore(GetScore() + S.GetScore());
		SetCharCount(GetCharCount() + S.GetCharCount());
	}
	CScore & operator += (CScore &S) { Add (S); return *this; }

	int operator <= (CScore &S) {
		// Special:  always put 8-bit langs first since the code page
		// matters more for them.
		if (GetLang()->Type() != S.GetLang()->Type())
			return GetLang()->Type() == DETECT_8BIT ? -1 : 1;
		return GetScore() <= S.GetScore();
	}

#ifdef DEBUG_LCDETECT
	void Print(void) {
		printf("Lang=%d CodePage=%d Score=%d NChars=%d\n",
			GetLang() ? GetLang()->LanguageID() : -1, 
			GetCodePage(), GetScore(), GetCharCount());
	}
#endif

private:
	PLanguage m_pLang;
	int m_nScore;
	unsigned short m_nCodePage;
	unsigned short m_nChars;
};
typedef CScore *PScore;

////////////////////////////////////////////////////////////////

// class CScores
//
// For SBCS detection, the index e.g. Ref(i) is the language+codepage index,
// one of a contiguous set of values which identifies each unique supported
// language and codepage combination.
//
// For DBCS detection, the index is just the Unicode language group.

class CScores {
public:
	CScores (int nAlloc, PScore p) : m_nAlloc(nAlloc), m_nUsed(0), m_p(p) { }
	virtual ~CScores (void) { }

	void Reset (void) {
		memset ((void *)m_p, 0, sizeof(CScore) * m_nUsed);
		m_nUsed = 0;
	}

	unsigned int &NElts (void) { return m_nUsed; }
	CScore &Ref (unsigned int n) {
		if (m_nUsed <= n)
			m_nUsed = n + 1; 
		return m_p[n]; 
	}

	void SelectCodePages (void);

	void RemoveZeroScores (void) {
		for (unsigned int i = 0, j = 0; i < m_nUsed; i++)
		{
			if (m_p[i].GetScore() > MINRAWSCORE)
				m_p[j++] = m_p[i];
		}
		m_nUsed = j;
	}

	// Sort by decreasing score.
	// Instantiates template qsort using CScore::operator <=

	void SortByScore (void) {
		RemoveZeroScores ();
		if (m_nUsed)
			QSort (m_p, m_nUsed, FALSE);
	}

	CScore & FindHighScore (void) {
		int highscore = 0;
		for (unsigned int i = 0, highidx = 0; i < m_nUsed; i++) {
			if (m_p[i].GetScore() > highscore)
			{
				highscore = m_p[i].GetScore();
				highidx = i;
			}
		}
		return m_p[highidx];
	}

protected:
	unsigned int m_nAlloc;
	unsigned int m_nUsed;	// high water mark to optimize NElts(), Reset()
	PScore m_p;				// score array, typically per TScores<NNN>
};

template<ULONG Size>class TScores : public CScores {

public:
	TScores (void) : CScores (Size, m_S) { }
	virtual ~TScores (void) { }

private:
	CScore m_S[Size];
};

////////////////////////////////////////////////////////////////

class LCDetect {

public:
	LCDetect (HMODULE hM);
	~LCDetect (void);

	unsigned int GetNCharmaps() const { return m_nCharmaps; }
	unsigned int GetN7BitLanguages() const { return m_n7BitLanguages; }
	unsigned int GetN8BitLanguages() const { return m_n8BitLanguages; }
	unsigned int GetNUnicodeLanguages() const { return m_nUnicodeLanguages; }

	PLanguage7Bit Get7BitLanguage (int i) const { return m_pp7BitLanguages[i]; }
	PLanguage8Bit Get8BitLanguage (int i) const { return m_pp8BitLanguages[i]; }
	PLanguageUnicode GetUnicodeLanguage (int i) const { return m_ppUnicodeLanguages[i]; }

	PHIdx GetMap (int i) const { return m_ppCharmaps[i]->Map(); }

	const LCDConfigure &GetConfig () const { return m_LCDConfigureDefault; }

	DWORD LoadState (void);

	DWORD DetectA (LPCSTR pStr, int nChars, PLCDScore paScores, 
							int *pnScores, PCLCDConfigure pLCDC) const;

	DWORD DetectW (LPCWSTR wcs, int nInputChars, PLCDScore paScores, 
							int *pnScores, PCLCDConfigure pLCDC) const;

private:
	DWORD Initialize7BitLanguage (PFileLanguageSection pLS, PLanguage *ppL);
	DWORD Initialize8BitLanguage (PFileLanguageSection pLS, Language **ppL);
	DWORD InitializeUnicodeLanguage (PFileLanguageSection pLS,Language **ppL);
	DWORD LoadLanguageSection (void *pv, int nSectionSize, PLanguage *ppL);
	DWORD LoadHistogramSection (void *pv, int nSectionSize, Language *pL);
	DWORD LoadMapSection (void *pv, int nSectionSize);
	DWORD BuildState (DWORD nFileSize);

	void Score7Bit (LPCSTR pcszText, int nChars, CScores &S) const;
	void Score8Bit (LPCSTR pcszText, int nChars, CScores &S) const;
	int ScoreCodePage (LPCSTR pStr, int nChars, CScore &S) const;
	int ChooseDetectionType (LPCSTR pcszText, int nChars) const;
	void ScoreLanguageA (LPCSTR pStr, int nChars, CScores &S) const;
	void ScoreLanguageW (LPCWSTR wcs, int nChars, CScores &S, PCLCDConfigure) const;
	void ScoreLanguageAsSBCS (LPCWSTR wcs, int nch, CScores &S) const;
	void ScoreUnicodeSublanguages (PLanguageUnicode pL, LPCWSTR wcs, 
			int nch, CScores &S) const;

private:
	// Language training info virtual-mapped in training file

	unsigned int m_nCharmaps;
	unsigned int m_n7BitLanguages;
	unsigned int m_n8BitLanguages;
	unsigned int m_nUnicodeLanguages;

	PCharmap *m_ppCharmaps;
	PLanguage7Bit *m_pp7BitLanguages;
	PLanguage8Bit *m_pp8BitLanguages;
	PLanguageUnicode *m_ppUnicodeLanguages;

	// Cached information for the optimized scoring inner-loops.

	PHElt m_paHElt7Bit[MAX7BITLANG];
	PHElt m_paHElt8Bit[MAXSCORES];
	int m_nHElt8Bit;

	// Special 7-bit lang histogram for ScoreLanguageAsSBCS()

	PHistogram m_pHU27Bit;

	// Initialization state variables

	unsigned int m_n7BitLangsRead;
	unsigned int m_n8BitLangsRead;
	unsigned int m_nUnicodeLangsRead;
	unsigned int m_nMapsRead;
	int m_nHistogramsRead;
	int m_nScoreIdx;

	// Default configuration to use when NULL parameter passed to detect

	LCDConfigure m_LCDConfigureDefault;

	// File mapping information for the training data file

	HANDLE m_hf;
	HANDLE m_hmap;
	void *m_pv;

	HMODULE m_hModule;
};

////////////////////////////////////////////////////////////////

inline PLanguageUnicode 
LanguageUnicode::GetSublanguage (int n) const 
{ 
	return m_pLC->GetUnicodeLanguage(GetSublangRangeID(n));
}

#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\eucjobj.h ===
#include "convbase.h"

class CInccEucJIn : public CINetCodeConverter
{
private:
	BOOL (CInccEucJIn::*m_pfnConv)(UCHAR tc);
	BOOL (CInccEucJIn::*m_pfnCleanUp)();
	UCHAR m_tcLeadByte;                             /* perserve the last lead byte */

public:
	CInccEucJIn(UINT uCodePage, int nCodeSet);
	~CInccEucJIn() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
	BOOL ConvMain(UCHAR tc);
	BOOL CleanUpMain();
	BOOL ConvDoubleByte(UCHAR tc);
	BOOL CleanUpDoubleByte();
	BOOL ConvKatakana(UCHAR tc);
	BOOL CleanUpKatakana();
};

class CInccEucJOut : public CINetCodeConverter
{
private:
	BOOL m_fDoubleByte;
	BYTE m_tcLeadByte;
    DWORD   _dwFlag;
    WCHAR   *_lpFallBack;

public:
	CInccEucJOut(UINT uCodePage, int nCodeSet,  DWORD dwFlag, WCHAR *lpFallBack);
	~CInccEucJOut() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);
private:
    void Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\enumcp.cpp ===
#include "private.h"
const MIMERFC1766 MimeRfc1766[] =
{
    { 0x0436, L"af",    IDS_RFC1766_LCID0436 },
    { 0x041C, L"sq",    IDS_RFC1766_LCID041C },
    { 0x0001, L"ar",    IDS_RFC1766_LCID0001 },
    { 0x0401, L"ar-sa", IDS_RFC1766_LCID0401 },
    { 0x0801, L"ar-iq", IDS_RFC1766_LCID0801 },
    { 0x0C01, L"ar-eg", IDS_RFC1766_LCID0C01 },
    { 0x1001, L"ar-ly", IDS_RFC1766_LCID1001 },
    { 0x1401, L"ar-dz", IDS_RFC1766_LCID1401 },
    { 0x1801, L"ar-ma", IDS_RFC1766_LCID1801 },
    { 0x1C01, L"ar-tn", IDS_RFC1766_LCID1C01 },
    { 0x2001, L"ar-om", IDS_RFC1766_LCID2001 },
    { 0x2401, L"ar-ye", IDS_RFC1766_LCID2401 },
    { 0x2801, L"ar-sy", IDS_RFC1766_LCID2801 },
    { 0x2C01, L"ar-jo", IDS_RFC1766_LCID2C01 },
    { 0x3001, L"ar-lb", IDS_RFC1766_LCID3001 },
    { 0x3401, L"ar-kw", IDS_RFC1766_LCID3401 },
    { 0x3801, L"ar-ae", IDS_RFC1766_LCID3801 },
    { 0x3C01, L"ar-bh", IDS_RFC1766_LCID3C01 },
    { 0x4001, L"ar-qa", IDS_RFC1766_LCID4001 },
    { 0x042D, L"eu",    IDS_RFC1766_LCID042D },
    { 0x0402, L"bg",    IDS_RFC1766_LCID0402 },
    { 0x0423, L"be",    IDS_RFC1766_LCID0423 },
    { 0x0403, L"ca",    IDS_RFC1766_LCID0403 },
    { 0x0004, L"zh",    IDS_RFC1766_LCID0004 },
    { 0x1404, L"zh-mo", IDS_RFC1766_LCID1404 },
    { 0x0404, L"zh-tw", IDS_RFC1766_LCID0404 },
    { 0x0804, L"zh-cn", IDS_RFC1766_LCID0804 },
    { 0x0C04, L"zh-hk", IDS_RFC1766_LCID0C04 },
    { 0x1004, L"zh-sg", IDS_RFC1766_LCID1004 },
    { 0x041A, L"hr",    IDS_RFC1766_LCID041A },
    { 0x0405, L"cs",    IDS_RFC1766_LCID0405 },
    { 0x0406, L"da",    IDS_RFC1766_LCID0406 },
    { 0x0413, L"nl",    IDS_RFC1766_LCID0413 },
    { 0x0813, L"nl-be", IDS_RFC1766_LCID0813 },
    { 0x0009, L"en",    IDS_RFC1766_LCID0009 },
    { 0x2409, L"en",    IDS_RFC1766_LCID2409 },
    { 0x0409, L"en-us", IDS_RFC1766_LCID0409 },
    { 0x0809, L"en-gb", IDS_RFC1766_LCID0809 },
    { 0x0C09, L"en-au", IDS_RFC1766_LCID0C09 },
    { 0x1009, L"en-ca", IDS_RFC1766_LCID1009 },
    { 0x1409, L"en-nz", IDS_RFC1766_LCID1409 },
    { 0x1809, L"en-ie", IDS_RFC1766_LCID1809 },
    { 0x1C09, L"en-za", IDS_RFC1766_LCID1C09 },
    { 0x3009, L"en-zw", IDS_RFC1766_LCID3009 },
    { 0x2009, L"en-jm", IDS_RFC1766_LCID2009 },
    { 0x2809, L"en-bz", IDS_RFC1766_LCID2809 },
    { 0x2C09, L"en-tt", IDS_RFC1766_LCID2C09 },
    { 0x3409, L"en-ph", IDS_RFC1766_LCID3409 },
    { 0x0425, L"et",    IDS_RFC1766_LCID0425 },
    { 0x0438, L"fo",    IDS_RFC1766_LCID0438 },
    { 0x0429, L"fa",    IDS_RFC1766_LCID0429 },
    { 0x040B, L"fi",    IDS_RFC1766_LCID040B },
    { 0x040C, L"fr",    IDS_RFC1766_LCID040C },
    { 0x080C, L"fr-be", IDS_RFC1766_LCID080C },
    { 0x0C0C, L"fr-ca", IDS_RFC1766_LCID0C0C },
    { 0x100C, L"fr-ch", IDS_RFC1766_LCID100C },
    { 0x140C, L"fr-lu", IDS_RFC1766_LCID140C },
    { 0x180C, L"fr-mc", IDS_RFC1766_LCID180C },
    { 0x043C, L"gd",    IDS_RFC1766_LCID043C },
    { 0x0407, L"de",    IDS_RFC1766_LCID0407 },
    { 0x0807, L"de-ch", IDS_RFC1766_LCID0807 },
    { 0x0C07, L"de-at", IDS_RFC1766_LCID0C07 },
    { 0x1007, L"de-lu", IDS_RFC1766_LCID1007 },
    { 0x1407, L"de-li", IDS_RFC1766_LCID1407 },
    { 0x0408, L"el",    IDS_RFC1766_LCID0408 },
    { 0x040D, L"he",    IDS_RFC1766_LCID040D },
    { 0x0439, L"hi",    IDS_RFC1766_LCID0439 },
    { 0x040E, L"hu",    IDS_RFC1766_LCID040E },
    { 0x040F, L"is",    IDS_RFC1766_LCID040F },
    { 0x0421, L"id",    IDS_RFC1766_LCID0421 },
    { 0x0410, L"it",    IDS_RFC1766_LCID0410 },
    { 0x0810, L"it-ch", IDS_RFC1766_LCID0810 },
    { 0x0411, L"ja",    IDS_RFC1766_LCID0411 },
    { 0x0412, L"ko",    IDS_RFC1766_LCID0412 },
    { 0x0426, L"lv",    IDS_RFC1766_LCID0426 },
    { 0x0427, L"lt",    IDS_RFC1766_LCID0427 },
    { 0x042F, L"mk",    IDS_RFC1766_LCID042F },
    { 0x043E, L"ms",    IDS_RFC1766_LCID043E },
    { 0x043A, L"mt",    IDS_RFC1766_LCID043A },
    { 0x0415, L"pl",    IDS_RFC1766_LCID0415 },
    { 0x0416, L"pt-br", IDS_RFC1766_LCID0416 },
    { 0x0816, L"pt",    IDS_RFC1766_LCID0816 },
    { 0x0417, L"rm",    IDS_RFC1766_LCID0417 },
    { 0x0418, L"ro",    IDS_RFC1766_LCID0418 },
    { 0x0818, L"ro-md", IDS_RFC1766_LCID0818 },
    { 0x0419, L"ru",    IDS_RFC1766_LCID0419 },
    { 0x0819, L"ru-md", IDS_RFC1766_LCID0819 },
    { 0x0C1A, L"sr",    IDS_RFC1766_LCID0C1A },
    { 0x081A, L"sr",    IDS_RFC1766_LCID081A },
    { 0x041B, L"sk",    IDS_RFC1766_LCID041B },
    { 0x0424, L"sl",    IDS_RFC1766_LCID0424 },
    { 0x042E, L"sb",    IDS_RFC1766_LCID042E },
    { 0x040A, L"es",    IDS_RFC1766_LCID040A },
    { 0x080A, L"es-mx", IDS_RFC1766_LCID080A },
    { 0x0C0A, L"es",    IDS_RFC1766_LCID0C0A },
    { 0x100A, L"es-gt", IDS_RFC1766_LCID100A },
    { 0x140A, L"es-cr", IDS_RFC1766_LCID140A },
    { 0x180A, L"es-pa", IDS_RFC1766_LCID180A },
    { 0x1C0A, L"es-do", IDS_RFC1766_LCID1C0A },
    { 0x200A, L"es-ve", IDS_RFC1766_LCID200A },
    { 0x240A, L"es-co", IDS_RFC1766_LCID240A },
    { 0x280A, L"es-pe", IDS_RFC1766_LCID280A },
    { 0x2C0A, L"es-ar", IDS_RFC1766_LCID2C0A },
    { 0x300A, L"es-ec", IDS_RFC1766_LCID300A },
    { 0x340A, L"es-cl", IDS_RFC1766_LCID340A },
    { 0x380A, L"es-uy", IDS_RFC1766_LCID380A },
    { 0x3C0A, L"es-py", IDS_RFC1766_LCID3C0A },
    { 0x400A, L"es-bo", IDS_RFC1766_LCID400A },
    { 0x440A, L"es-sv", IDS_RFC1766_LCID440A },
    { 0x480A, L"es-hn", IDS_RFC1766_LCID480A },
    { 0x4C0A, L"es-ni", IDS_RFC1766_LCID4C0A },
    { 0x500A, L"es-pr", IDS_RFC1766_LCID500A },
    { 0x0430, L"sx",    IDS_RFC1766_LCID0430 },
    { 0x041D, L"sv",    IDS_RFC1766_LCID041D },
    { 0x081D, L"sv-fi", IDS_RFC1766_LCID081D },
    { 0x041E, L"th",    IDS_RFC1766_LCID041E },
    { 0x0431, L"ts",    IDS_RFC1766_LCID0431 },
    { 0x0432, L"tn",    IDS_RFC1766_LCID0432 },
    { 0x041F, L"tr",    IDS_RFC1766_LCID041F },
    { 0x0422, L"uk",    IDS_RFC1766_LCID0422 },
    { 0x0420, L"ur",    IDS_RFC1766_LCID0420 },
    { 0x0443, L"uz",    IDS_RFC1766_LCID0443 },
    { 0x0843, L"uz",    IDS_RFC1766_LCID0843 },
    { 0x042A, L"vi",    IDS_RFC1766_LCID042A },
    { 0x0434, L"xh",    IDS_RFC1766_LCID0434 },
    { 0x043D, L"yi",    IDS_RFC1766_LCID043D },
    { 0x0435, L"zu",    IDS_RFC1766_LCID0435 },
    { 0x042B, L"hy",    IDS_RFC1766_LCID042B },
    { 0x0437, L"ka",    IDS_RFC1766_LCID0437 },
    { 0x043F, L"kk",    IDS_RFC1766_LCID043F },
    { 0x0441, L"sw",    IDS_RFC1766_LCID0441 },
    { 0x0444, L"tt",    IDS_RFC1766_LCID0444 },
    { 0x0445, L"bn",    IDS_RFC1766_LCID0445 },
    { 0x0446, L"pa",    IDS_RFC1766_LCID0446 },
    { 0x0447, L"gu",    IDS_RFC1766_LCID0447 },
    { 0x0448, L"or",    IDS_RFC1766_LCID0448 },
    { 0x0449, L"ta",    IDS_RFC1766_LCID0449 },
    { 0x044A, L"te",    IDS_RFC1766_LCID044A },
    { 0x044B, L"kn",    IDS_RFC1766_LCID044B },
    { 0x044C, L"ml",    IDS_RFC1766_LCID044C },
    { 0x044D, L"as",    IDS_RFC1766_LCID044D },
    { 0x044E, L"mr",    IDS_RFC1766_LCID044E },
    { 0x083E, L"ms",    IDS_RFC1766_LCID083E },
    { 0x0861, L"ne",    IDS_RFC1766_LCID0861 },
    { 0x044F, L"sa",    IDS_RFC1766_LCID044F },
//  Sync W2K NLS, remove 0x0827 RFC1766 entry
//  { 0x0827, L"lt",    IDS_RFC1766_LCID0827 },
    { 0x0457, L"kok",   IDS_RFC1766_LCID0457 },

// Following rfc1766 names are over already published MAX_RFC1766_NAME
// We have to modify them for IE5 release, will do better later

//  { 0x082C, L"x-az-cyrillic", IDS_RFC1766_LCID082C },
//  { 0x042C, L"x-az-latin",    IDS_RFC1766_LCID042C },
    { 0x0414, L"no",   IDS_RFC1766_LCID0414 },
    { 0x0414, L"nb-no",   IDS_RFC1766_LCID0414 },
    { 0x0814, L"nn-no",   IDS_RFC1766_LCID0814 },
    { 0x082C, L"az",    IDS_RFC1766_LCID082C },
    { 0x042C, L"az",    IDS_RFC1766_LCID042C },
// More stuffs from Whistler NLS
    { 0x0440, L"kz",    IDS_RFC1766_LCID0440 },
    { 0x0450, L"mn",    IDS_RFC1766_LCID0450 },
    { 0x0456, L"gl",    IDS_RFC1766_LCID0456 },
    { 0x045A, L"syr",   IDS_RFC1766_LCID045A },
    { 0x0465, L"div",   IDS_RFC1766_LCID0465 },
// Whistler bug#350772, for Hispanic US
    { 0x540A, L"es-us", IDS_RFC1766_LCID540A },
};

UINT g_cRfc1766 = ARRAYSIZE(MimeRfc1766);
//
//  CEnumCodePage implementation
//
CEnumCodePage::CEnumCodePage(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource) : _dwLevel( grfFlags ), _LangId( LangId), dwMimeSource(dwSource)
{
    DebugMsg(DM_TRACE, TEXT("constructor of CEnumCodePage 0x%08x"), this);
    DllAddRef();

    _cRef = 1;
    _iCur = 0;
}

CEnumCodePage::~CEnumCodePage()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CEnumCodePage 0x%08x"), this);
    DllRelease();
}

STDAPI CEnumCodePage::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::QueryInterface called."));
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumCodePage))
    {
        *ppvObj = SAFECAST(this, IEnumCodePage*);
        AddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEnumCodePage::AddRef()
{
    _cRef++;
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::AddRef called. _cRef=%d"), _cRef);
    return _cRef;
}

STDAPI_(ULONG) CEnumCodePage::Release()
{
    _cRef--;
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Release called. _cRef=%d"), _cRef);
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

STDAPI CEnumCodePage::Clone(IEnumCodePage **ppEnumCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Clone called."));
    return E_NOTIMPL;
}

STDAPI CEnumCodePage::Next(ULONG celt, PMIMECPINFO rgcpInfo, ULONG *pceltFetched)
{    
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Next called."));


    UINT cNum = 0;
    MIMECPINFO cpInfo;

    if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
    {
        if (NULL != g_pMimeDatabaseReg && NULL != rgcpInfo)
        {
            if (0 == _iCur)
                if (S_OK != g_pMimeDatabaseReg->EnumCodePageInfo())
                    return E_FAIL;

            while (cNum < celt)
            {
                HRESULT hr = g_pMimeDatabaseReg->GetCodePageInfoWithIndex(_iCur++, &cpInfo);
                if (SUCCEEDED(hr))
                {
                    if (_dwLevel == (cpInfo.dwFlags & _dwLevel))
                    {
                        *(rgcpInfo + cNum) = cpInfo;
                        cNum++;
                    }
                }
                else
                    break;
            }
            if (NULL != pceltFetched)
                *pceltFetched = cNum;
            return (0 < cNum)? S_OK: S_FALSE;
        }
        else
            return E_FAIL;
    } 

    while (cNum < celt)
    {
        if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfoWithIndex(_iCur++, _LangId, &cpInfo)))
        {
            if (_dwLevel == (cpInfo.dwFlags & _dwLevel) &&
                (cpInfo.dwFlags & dwMimeSource))
            {
                *(rgcpInfo + cNum) = cpInfo;
                cNum++;
            }
        }
        else
            break;
    }

    if (NULL != pceltFetched)
       *pceltFetched = cNum;

    return (0 < cNum)? S_OK: S_FALSE;

}


STDAPI CEnumCodePage::Reset()
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Reset called."));
    _iCur = 0;
    return NOERROR;
}

STDAPI CEnumCodePage::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Skip called."));
    _iCur += celt;
    return NOERROR;
}

//
//  CEnumRfc1766 implementation
//
CEnumRfc1766::CEnumRfc1766(MIMECONTF dwSource, LANGID LangId) : _LangID(LangId)
{
    DebugMsg(DM_TRACE, TEXT("constructor of CEnumRfc1766 0x%08x"), this);
    dwMimeSource = dwSource;
    DllAddRef();
    _cRef = 1;
    _uCur = 0;
}

CEnumRfc1766::~CEnumRfc1766()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CEnumRfc1766 0x%08x"), this);
    DllRelease();
}

STDAPI CEnumRfc1766::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::QueryInterface called."));
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumRfc1766))
    {
        *ppvObj = SAFECAST(this, IEnumRfc1766*);
        AddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEnumRfc1766::AddRef()
{
    _cRef++;
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::AddRef called. _cRef=%d"), _cRef);
    return _cRef;
}

STDAPI_(ULONG) CEnumRfc1766::Release()
{
    _cRef--;
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Release called. _cRef=%d"), _cRef);
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

STDAPI CEnumRfc1766::Clone(IEnumRfc1766 **ppEnumRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Clone called."));
    return E_NOTIMPL;
}

STDAPI CEnumRfc1766::Next(ULONG celt, PRFC1766INFO rgRfc1766Info, ULONG *pceltFetched)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Next called."));

    if (g_pMimeDatabaseReg && (dwMimeSource &  MIMECONTF_MIME_REGISTRY))
    {
        g_pMimeDatabaseReg->EnsureRfc1766Table();
        if (NULL != g_pRfc1766Reg && NULL != rgRfc1766Info)
        {
            UINT cNum = 0;

            while (cNum < celt)
            {
                if (_uCur < g_cRfc1766)
                {
                    (rgRfc1766Info + cNum)->lcid = g_pRfc1766Reg[_uCur].lcid;
                    MultiByteToWideChar(CP_ACP, 0, g_pRfc1766Reg[_uCur].szRfc1766, -1, (rgRfc1766Info + cNum)->wszRfc1766, MAX_RFC1766_NAME);
                    (rgRfc1766Info + cNum)->wszRfc1766[MAX_RFC1766_NAME-1] = 0;
                    MultiByteToWideChar(CP_ACP, 0, g_pRfc1766Reg[_uCur].szLocaleName, -1, (rgRfc1766Info + cNum)->wszLocaleName, MAX_LOCALE_NAME);
                    (rgRfc1766Info + cNum)->wszLocaleName[MAX_LOCALE_NAME-1] = 0;
                    cNum++;
                    _uCur++;
                }
                else
                    break;
            }
            if (NULL != pceltFetched)
                *pceltFetched = cNum;
            return (0 < cNum)? S_OK: S_FALSE;
        }
        else
            return E_FAIL;
    }
    if (NULL != rgRfc1766Info)
    {
        UINT cNum = 0;

        while (cNum < celt)
        {
            if (_uCur < g_cRfc1766)
            {
                (rgRfc1766Info + cNum)->lcid = MimeRfc1766[_uCur].LcId;
                MLStrCpyNW((rgRfc1766Info + cNum)->wszRfc1766, MimeRfc1766[_uCur].szRfc1766, MAX_RFC1766_NAME);

                (rgRfc1766Info + cNum)->wszRfc1766[MAX_RFC1766_NAME-1] = 0; 
                
                if (!_LoadStringExW(g_hInst, MimeRfc1766[_uCur].uidLCID, (rgRfc1766Info + cNum)->wszLocaleName, 
                                    MAX_LOCALE_NAME, _LangID))
                {
                        // Last try, switch to English, US
                        if (!_LoadStringExW(g_hInst, MimeRfc1766[_uCur].uidLCID, (rgRfc1766Info + cNum)->wszLocaleName, 
                                       MAX_LOCALE_NAME, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)))
                             (rgRfc1766Info + cNum)->wszLocaleName[0] = 0x0000;
                }
                (rgRfc1766Info + cNum)->wszLocaleName[MAX_LOCALE_NAME-1] = 0;

                cNum++;
                _uCur++;
            }
            else
                break;
        }
        if (NULL != pceltFetched)
            *pceltFetched = cNum;
        return (0 < cNum)? S_OK: S_FALSE;
    }
    else
        return E_FAIL;
}

STDAPI CEnumRfc1766::Reset()
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Reset called."));
    _uCur = 0;
    return NOERROR;
}

STDAPI CEnumRfc1766::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Skip called."));
    _uCur += celt;
    return NOERROR;
}

//
// CEnumScript implementation
//
CEnumScript::CEnumScript(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource) : _dwLevel(grfFlags), _LangId( LangId)
{
    DebugMsg(DM_TRACE, TEXT("constructor of CEnumScript 0x%08x"), this);
    DllAddRef();

    _cRef = 1;
    _uCur = 0;
}

CEnumScript::~CEnumScript()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CEnumScript 0x%08x"), this);
    DllRelease();
}

STDAPI CEnumScript::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::QueryInterface called."));
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumScript))
    {
        *ppvObj = SAFECAST(this, IEnumScript*);
        AddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEnumScript::AddRef()
{
    _cRef++;
    DebugMsg(DM_TRACE, TEXT("CEnumScript::AddRef called. _cRef=%d"), _cRef);
    return _cRef;
}

STDAPI_(ULONG) CEnumScript::Release()
{
    _cRef--;
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Release called. _cRef=%d"), _cRef);
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

STDAPI CEnumScript::Clone(IEnumScript **ppEnumScript)
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Clone called."));
    return E_NOTIMPL;
}

STDAPI CEnumScript::Next(ULONG celt, PSCRIPTINFO rgScriptInfo, ULONG *pceltFetched)
{    
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Next called."));

    if (!_dwLevel)
        _dwLevel = ~0;

    if (NULL != rgScriptInfo)
    {
        UINT cNum = 0;
        LANGID LangId = _LangId;

        while (cNum < celt)
        {
            if (_uCur < g_cScript)
            {
                if (!(ScriptTable[_uCur].dwFlags & _dwLevel))
                { 
                    _uCur++;
                    continue;
                }

                (rgScriptInfo + cNum)->ScriptId = ScriptTable[_uCur].sid;

                (rgScriptInfo + cNum)->uiCodePage = ScriptTable[_uCur].uiCodePage;

                (rgScriptInfo + cNum)->wszDescription[0] = 0x0000;

                if (!_LoadStringExW(g_hInst, ScriptTable[_uCur].uidDescription, (rgScriptInfo + cNum)->wszDescription, 
                                    MAX_SCRIPT_NAME, LangId))
                {
                        // Last try, switch to English, US
                        LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                        _LoadStringExW(g_hInst, ScriptTable[_uCur].uidDescription, (rgScriptInfo + cNum)->wszDescription, 
                                       MAX_SCRIPT_NAME, LangId);
                }

                (rgScriptInfo + cNum)->wszFixedWidthFont[0] = 0x0000;
                if (ScriptTable[_uCur].uidFixedWidthFont)
                {
                    _LoadStringExW(g_hInst, ScriptTable[_uCur].uidFixedWidthFont, (rgScriptInfo + cNum)->wszFixedWidthFont,
                                   MAX_MIMEFACE_NAME, LangId);
                }

                (rgScriptInfo + cNum)->wszProportionalFont[0] = 0x0000;
                if (ScriptTable[_uCur].uidProportionalFont)
                {
                    _LoadStringExW(g_hInst, ScriptTable[_uCur].uidProportionalFont, (rgScriptInfo + cNum)->wszProportionalFont,
                                   MAX_MIMEFACE_NAME, LangId);
                }

                cNum++;
                _uCur++;
            }
            else
                break;
        }

        if (NULL != pceltFetched)
            *pceltFetched = cNum;
        return (0 < cNum)? S_OK: S_FALSE;
    }
    else
        return E_FAIL;
}


STDAPI CEnumScript::Reset()
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Reset called."));
    _uCur = 0;
    return NOERROR;
}

STDAPI CEnumScript::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Skip called."));
    _uCur += celt;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
#include <winsock.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? _hinst : (_hinst = LoadLibrary(#_dll)))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- OLEAUT32.DLL ---------------

HINSTANCE g_hinstOLEAUT32 = NULL;

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, RegisterTypeLib,
    (ITypeLib *ptlib, OLECHAR *szFullPath, OLECHAR *szHelpDir), (ptlib, szFullPath, szHelpDir));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadTypeLib,
    (const OLECHAR *szFile, ITypeLib **pptlib), (szFile, pptlib));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, CreateErrorInfo,
    (ICreateErrorInfo **pperrinfo), (pperrinfo));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SetErrorInfo,
   (unsigned long dwReserved, IErrorInfo*perrinfo), (dwReserved, perrinfo));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadRegTypeLib,
    (REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib **pptlib),
    (rguid, wVerMajor, wVerMinor, lcid, pptlib));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocString, (const OLECHAR*pch), (pch));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringLen, 
    (const OLECHAR*pch, unsigned int i), (pch, i));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringByteLen,
    (LPCSTR psz, UINT i), (psz, i));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringLen, (BSTR bstr), (bstr));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringByteLen, (BSTR bstr), (bstr));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, SysFreeString, (BSTR bs), (bs));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, VariantInit, (VARIANTARG *pvarg), (pvarg));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantCopy,
    (VARIANTARG *pvargDest, VARIANTARG *pvargSrc), (pvargDest, pvargSrc));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantChangeType,
    (VARIANTARG *pvargDest, VARIANTARG *pvargSrc, unsigned short wFlags, VARTYPE vt),
    (pvargDest, pvargSrc, wFlags, vt));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantClear, (VARIANTARG *pvarg), (pvarg));

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\eucjobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from EUC-JP
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "eucjobj.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccEucJIn::CInccEucJIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccEucJIn::Reset()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccEucJIn::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccEucJIn::CleanUp()
{
	return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccEucJIn::ConvMain(UCHAR tc)
{
	BOOL fDone = TRUE;



	if (tc >= 0xa1 && tc <= 0xfe) {
		m_pfnConv = ConvDoubleByte;
		m_pfnCleanUp = CleanUpDoubleByte;
		m_tcLeadByte = tc;
	} else if (tc == 0x8e) { // Single Byte Katakana
		m_pfnConv = ConvKatakana;
		m_pfnCleanUp = CleanUpKatakana;
	} else {
		fDone = Output(tc);
	}
	return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccEucJIn::CleanUpMain()
{
	return TRUE;
}

/******************************************************************************
*********************   C O N V   D O U B L E   B Y T E   *********************
******************************************************************************/

BOOL CInccEucJIn::ConvDoubleByte(UCHAR tc)
{
	BOOL fRet ;

	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	if (m_tcLeadByte <= 0xde) { // && m_tcLeadByte >= 0xa1
		if (m_tcLeadByte % 2) // odd
			(void)Output((m_tcLeadByte - 0xa1) / 2 + 0x81);
		else // even
			(void)Output((m_tcLeadByte - 0xa2) / 2 + 0x81);
	} else { // m_tcLeadByte >= 0xdf && m_tcLeadByte <= 0xfe
		if (m_tcLeadByte % 2) // odd
			(void)Output((m_tcLeadByte - 0xdf) / 2 + 0xe0);
		else // even
			(void)Output((m_tcLeadByte - 0xe0) / 2 + 0xe0);
	}
	if (m_tcLeadByte % 2) { // odd
		if (tc >= 0xa1 && tc <= 0xdf)
			fRet = Output(tc - 0x61);
		else
			fRet = Output(tc - 0x60);
	} else { // even
		fRet = Output(tc - 2);
	}
	m_tcLeadByte = 0 ;
	return fRet ;
}

/******************************************************************************
*****************   C L E A N   U P   D O U B L E   B Y T E   *****************
******************************************************************************/

BOOL CInccEucJIn::CleanUpDoubleByte()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	return TRUE;
}

/******************************************************************************
************************   C O N V   K A T A K A N A   ************************
******************************************************************************/

BOOL CInccEucJIn::ConvKatakana(UCHAR tc)
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	return Output(tc);
}

/******************************************************************************
********************   C L E A N   U P   K A T A K A N A   ********************
******************************************************************************/

BOOL CInccEucJIn::CleanUpKatakana()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	return TRUE;
}

int CInccEucJIn::GetUnconvertBytes()
{
    if (m_tcLeadByte || m_pfnConv == ConvKatakana)
    	return 1;
    else
    	return 0;
}

DWORD CInccEucJIn::GetConvertMode()
{
    // 0xCADC -> 51932 EUC-JP (codepage)
 	return 0xCADC0000 ;
}

void CInccEucJIn::SetConvertMode(DWORD mode)
{
    Reset();
 	return ;
}


// ============================================================================
// Internet Character Set Conversion: Output to EUC-JP
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccEucJOut::CInccEucJOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/
void CInccEucJOut::Reset()
{
	m_fDoubleByte = FALSE;
	m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccEucJOut::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = TRUE;
    HRESULT hr = S_OK;

	if (!m_fDoubleByte) {
		if ((tc >= 0x81 && tc <= 0x9f) || (tc >= 0xe0 && tc <= 0xfc )) { // Double Byte Code
			m_fDoubleByte = TRUE;
			m_tcLeadByte = tc;
		} else if (tc >= 0xa1 && tc <= 0xdf) { // Single Byte Katakana Code
			(void) Output( (UCHAR) 0x8e);
			fDone = Output(tc);
		} else {
			fDone = Output(tc);
		}
	} else {

        // map extended char (0xfa40-0xfc4b) to a special range
        if (m_tcLeadByte >= 0xfa && m_tcLeadByte <= 0xfc && tc >= 0x40 )
        {
            WCHAR  wcDBCS ;

            wcDBCS = ((WCHAR) m_tcLeadByte ) << 8 | tc ;

            if ( wcDBCS >= 0xfa40 && wcDBCS <= 0xfa5b )
            {
                if ( wcDBCS <= 0xfa49 )
                    wcDBCS = wcDBCS - 0x0b51 ;
                else if ( wcDBCS >= 0xfa4a && wcDBCS <= 0xfa53 )
                    wcDBCS = wcDBCS - 0x072f6 ;
                else if ( wcDBCS >= 0xfa54 && wcDBCS <= 0xfa57 )
                    wcDBCS = wcDBCS - 0x0b5b ;
                else if ( wcDBCS == 0xfa58 )
                    wcDBCS = 0x878a ;
                else if ( wcDBCS == 0xfa59 )
                    wcDBCS = 0x8782 ;
                else if ( wcDBCS == 0xfa5a )
                    wcDBCS = 0x8784 ;
                else if ( wcDBCS == 0xfa5b )
                    wcDBCS = 0x879a ;
            }
            else if ( wcDBCS >= 0xfa5c && wcDBCS <= 0xfc4b )
            {
                if ( tc < 0x5c )
                    wcDBCS = wcDBCS - 0x0d5f;
                else if ( tc >= 0x80 && tc <= 0x9B )
                    wcDBCS = wcDBCS - 0x0d1d;
                else
                    wcDBCS = wcDBCS - 0x0d1c;
            }
            tc = (UCHAR) wcDBCS ;
            m_tcLeadByte = (UCHAR) ( wcDBCS >> 8 ) ;
        }

        // Do conversion
		if (m_tcLeadByte <= 0xef) {
			if (m_tcLeadByte <= 0x9f) { // && m_tcLeadByte >= 0x81
				if (tc <= 0x9e)
					(void)Output((m_tcLeadByte - 0x81) * 2 + 0xa1);
				else
					(void)Output((m_tcLeadByte - 0x81) * 2 + 0xa2);
			} else { // m_tcLeadByte >= 0xe0 && m_tcLeadByte <= 0xef
				if (tc <= 0x9e)
					(void)Output((m_tcLeadByte - 0xe0) * 2 + 0xdf);
				else
					(void)Output((m_tcLeadByte - 0xe0) * 2 + 0xe0);
			}
			if (tc >= 0x40 && tc <= 0x7e)
				fDone = Output(tc + 0x61);
			else if (tc >= 0x80 && tc <= 0x9e)
				fDone = Output(tc + 0x60);
			else
				fDone = Output(tc + 0x02);
		} else if (m_tcLeadByte >= 0xfa) { // && m_tcLeadByte <= 0xfc; IBM Extended Char
            UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    


            if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
            {
                // only take SBCS, no DBCS character
                if ( 1 != WideCharToMultiByte(CP_JPN_SJ, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                    szDefaultChar[0] = 0x3f;
            }

            if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
            {
                char    szChar[2];
                char    szDstStr[10];
                WCHAR   szwChar[2];
                int     cCount;

                szChar[0] = m_tcLeadByte;
                szChar[1] = tc;
                
                if (MultiByteToWideChar(CP_JPN_SJ, 0, szChar, 2, szwChar, ARRAYSIZE(szwChar)))
                {

                    // Output NCR entity
                    Output('&');
                    Output('#');
                    _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                    cCount = lstrlenA(szDstStr);
                    for (int i=0; i< cCount; i++)
                    {
                        Output(szDstStr[i]);
                    }
                    fDone = Output(';');
                }
                else
                {
    		        fDone = Output(szDefaultChar[0]);
                    hr = S_FALSE;
                }
            }
            else
            {
    		        fDone = Output(szDefaultChar[0]);
                    hr = S_FALSE;
            }
		} else {
			(void)Output(m_tcLeadByte);
			fDone = Output(tc);
		}
		m_fDoubleByte = FALSE;
		m_tcLeadByte = 0 ;
	}

    if (!fDone)
        hr = E_FAIL;

    return hr;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccEucJOut::CleanUp()
{
	m_fDoubleByte = FALSE;
	return TRUE;
}

int CInccEucJOut::GetUnconvertBytes()
{
    if (m_tcLeadByte)
    	return 1;
    else
    	return 0;
}

DWORD CInccEucJOut::GetConvertMode()
{
 	return 0 ;
}

void CInccEucJOut::SetConvertMode(DWORD mode)
{
    Reset();
 	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\enumcp.h ===
#ifndef _ENUMCP_H_
#define _ENUMCP_H_

#ifdef  __cplusplus
//
//  CEnumCodePage declaration with IEnumCodePage Interface
//
class CEnumCodePage : public IEnumCodePage
{
    MIMECONTF       dwMimeSource;

public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumCodePage methods
    virtual STDMETHODIMP Clone(IEnumCodePage **ppEnumCodePage);
    virtual STDMETHODIMP Next(ULONG celt, PMIMECPINFO rgcpInfo, ULONG *pceltFetched);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Skip(ULONG celt);

    // Constructor & Destructor
    CEnumCodePage(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource);
    ~CEnumCodePage();

protected:
    int _cRef;
    int _iCur;
    DWORD   _dwLevel;
    LANGID  _LangId;
};

//
//  CEnumRfc1766 declaration with IEnumRfc1766 Interface
//
class CEnumRfc1766 : public IEnumRfc1766
{
    MIMECONTF   dwMimeSource;

public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumCodePage methods
    virtual STDMETHODIMP Clone(IEnumRfc1766 **ppEnumRfc1766);
    virtual STDMETHODIMP Next(ULONG celt, PRFC1766INFO rgRfc1766Info, ULONG *pceltFetched);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Skip(ULONG celt);

    // Constructor & Destructor
    CEnumRfc1766(MIMECONTF dwSource, LANGID LangId);
    ~CEnumRfc1766();

protected:
    LANGID  _LangID;
    int     _cRef;
    UINT    _uCur;
};

class CEnumScript : public IEnumScript
{
public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumScript methods
    virtual STDMETHODIMP Clone(IEnumScript **ppEnumScript);
    virtual STDMETHODIMP Next(ULONG celt, PSCRIPTINFO rgScriptInfo, ULONG *pceltFetched);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Skip(ULONG celt);

    // Constructor & Destructor
    CEnumScript(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource);
    ~CEnumScript();

protected:
    int     _cRef;
    UINT    _uCur;
    LANGID  _LangId;
    DWORD   _dwLevel;
};


#endif  // __cplusplus

typedef struct tagRFC1766INFOA
{
    LCID    lcid;
    char    szRfc1766[MAX_RFC1766_NAME];
    char    szLocaleName[MAX_LOCALE_NAME];
} RFC1766INFOA, *PRFC1766INFOA;

#endif  // _ENUMCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\fechmap_.h ===
/*----------------------------------------------------------------------------
	%%File: fechmap_.h
	%%Unit: fechmap
	%%Contact: jpick

	Internal header file for FarEast character conversion module.
----------------------------------------------------------------------------*/

#ifndef FECHMAP__H
#define FECHMAP__H

#include <windows.h>
#include <stdio.h>
#include <stddef.h>

#include "msencode.h"
//#include "assert.h"


// Character encoding types supported by this module.
// Internal version -- broader than the set exposed publicly.
// (Doing this since much of the groundwork is already in
// for future support don't want to remove or ifdef out that
// code).
//
// Main DLL entry points manage the correspondence between
// external and internal encoding types.
//
typedef enum _icet		// Internal Character Encoding Type
	{
	icetNil = -1,
	icetEucCn = 0,
	icetEucJp,
	icetEucKr,
	icetEucTw,
	icetIso2022Cn,
	icetIso2022Jp,
	icetIso2022Kr,
	icetIso2022Tw,
	icetBig5,
	icetGbk,
	icetHz,
	icetShiftJis,
	icetWansung,
	icetUtf7,
	icetUtf8,
	icetCount,
	} ICET;


// Miscellaneous useful definitions
//
#define fTrue	(BOOL) 1
#define fFalse	(BOOL) 0


// MS Code Page Definitions
//
#define nCpJapan		932
#define nCpChina		936
#define nCpKorea		949
#define nCpTaiwan		950

#define FIsFeCp(cp) \
	(((cp) == nCpJapan) || ((cp) == nCpChina) || ((cp) == nCpKorea) || ((cp) == nCpTaiwan))

#define WchFromUchUch(uchLead, uchTrail) \
	(WCHAR) ((((UCHAR)(uchLead)) << 8) | ((UCHAR)(uchTrail)))

// Prototype for internal auto-detection code
//
CCE CceDetermineInputType(
    IStream   *pstmIn,           // input stream
	DWORD     dwFlags,
	EFam      efPref,
	int       nPrefCp,
	ICET     *lpicet,
	BOOL     *lpfGuess
);

// Prototype for ISO-2022 escape sequence interpreter.
//
CCE CceReadEscSeq(IStream *pstmIn, ICET *lpicet);

#endif					// #ifndef FECHMAP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\fechmap.cpp ===
/*----------------------------------------------------------------------------
	%%File: fechmap.c
	%%Unit: fechmap
	%%Contact: jpick

	DLL entry points for FarEast conversion module.
----------------------------------------------------------------------------*/

#include "private.h"
#include "fechmap_.h"

#include "codepage.h"

static CODEPAGE _mpicetce[icetCount] =
{
    CP_EUC_CH,  			// icetEucCn
    CP_EUC_JP, 				// icetEucJp
    CP_EUC_KR, 				// icetEucKr
    CP_UNDEFINED,			// icetEucTw		(Not externally supported)
    CP_UNDEFINED,			// icetIso2022Cn	(Not externally supported)
    CP_ISO_2022_JP,			// icetIso2022Jp
    CP_ISO_2022_KR,			// icetIso2022Kr
    CP_UNDEFINED,			// icetIso2022Tw	(Not externally supported)
    CP_TWN,   				// icetBig5
    CP_CHN_GB,				// icetGbk
    CP_CHN_HZ,				// icetHz
    CP_JPN_SJ,				// icetShiftJis
    CP_KOR_5601,			// icetWansung
    CP_UTF_7,				// icetUtf7
    CP_UTF_8, 				// icetUtf8
};

/* C C E  D E T E C T  I N P U T  C O D E */
/*----------------------------------------------------------------------------
	%%Function: CceDetectInputCode
	%%Contact: jpick

	Routine that will analyze contents of file to make a best guess
	as to what encoding method was used on it.  Caller-supplied get
	and unget routines used for data access.
----------------------------------------------------------------------------*/
EXPIMPL(CCE)
CceDetectInputCode(
    IStream   *pstmIn,           // input stream
	DWORD     dwFlags,			// configuration flags
	EFam      efPref,			// optional: preferred encoding family
	int       nPrefCp,			// optional: preferred code page
	UINT      *lpCe,				// set to detected encoding
	BOOL      *lpfGuess			// set to fTrue if function "guessed"
)
{
	CCE cceRet;
	ICET icet;
	
	if (!pstmIn || !lpCe || !lpfGuess)
		return cceInvalidParameter;
		
	// DEBUG, only.  Prepare the assert handler.  This macro will
	// return cceInternal to the calling app if an assert is hit
	// before the handler is cleared, below.
	//
	//	InitAndCatchAsserts();
		
	cceRet = CceDetermineInputType(pstmIn, dwFlags, efPref, 
					nPrefCp, &icet, lpfGuess);
	
	if ((cceRet == cceSuccess) || (cceRet == cceMayBeAscii))
		{
		if (_mpicetce[icet] != CP_UNDEFINED )
			*lpCe = (UINT) _mpicetce[icet];
		else
			cceRet = cceUnknownInput;
		}
		
	// Done with the assert handler.
	//
	//	ClearAsserts();

	return cceRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\fechauto.cpp ===
/*----------------------------------------------------------------------------
	%%File: fechauto.c
	%%Unit: fechmap
	%%Contact: jpick

	Module that attempts to auto-detect encoding for a given stream.
----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stddef.h>

#include "private.h"
#include "fechmap_.h"
#include "lexint_.h"

// Code marked by these #defines will be deleted eventually ...
// (It prints out useful information and statistics about how
// auto-detect is doing and what it's finding in the input).
//
#define JPDEBUG			0
#define JPDEBUG2		0
#define JPDEBUG3		0

#define NEED_NAMES		0

#if JPDEBUG || JPDEBUG2 || JPDEBUG3
#undef NEED_NAMES
#define NEED_NAMES		1
#endif

#if NEED_NAMES
static char *rgszIcetNames[icetCount] =
{
	"icetEucCn",
	"icetEucJp",
	"icetEucKr",
	"icetEucTw",
	"icetIso2022Cn",
	"icetIso2022Jp",
	"icetIso2022Kr",
	"icetIso2022Tw",
	"icetBig5",
	"icetGbk",
	"icetHz",
	"icetShiftJis",
	"icetWansung",
	"icetUtf7",
	"icetUtf8",
};
#endif

// Characters we care about
//
#define chSo		(UCHAR) 0x0e
#define chSi		(UCHAR) 0x0f
#define chEsc		(UCHAR) 0x1b

// Minimum Sample Size
//
#define	cchMinSample		64

// High-ASCII character threshold.  If this routine is unable
// to absolutely determine the encoding of this file, it will
// need to guess.  Files that are ASCII, but contain high-ASCII
// characters (e.g., a file with some Cyrillic characters) may
// confuse us.  If the number of high-ASCII characters falls
// below this threshold, return the encoding we guessed but 
// also return a special rc that says the file "might be ASCII."
//
// 5%, for now.
//
// 40%, for now, of the high-ascii characters must be in high-
// ascii pairs.  (Pulled down because of Big5 and the other
// DBCS encodings that can have trail bytes in the low range).
//
#define nHighCharThreshold		 5		// %
#define nHighPairThreshold		40		// %

// Used by CceDetermineInputTypeReturnAll() to determine whether any icet has
// high enough count to rule out all other icets.
//
#define CchCountThreshold(icet)	(((icet) == icetHz || (icet) == icetUtf7) ? 5 : 10)



// Tokens
//
// Stop tokens (negative) imply special handling and will cause
// the processing loop to stop (eof, err, si, so and esc are
// stop tokens).
//
#define xmn			  0
#define esc			(-1)
#define  so			(-2)
#define  si			(-3)
#define eof			(-4)
#define err			(-5)

#define _FStopToken(tk)		((tk) < 0)


// Masks used in _CBitsOnFromUlong()
//
#define lMaskBitCount1	(LONG) 0x55555555
#define lMaskBitCount2	(LONG) 0x33333333
#define lMaskBitCount3	(LONG) 0x0F0F0F0F
#define lMaskBitCount4	(LONG) 0x00FF00FF
#define lMaskBitCount5	(LONG) 0x0000FFFF

/* _  C  B I T S  O N  F R O M  U L O N G */
/*----------------------------------------------------------------------------
	%%Function: _CBitsOnFromUlong
	%%Contact: jpick

	(adapted from code in convio.c)
----------------------------------------------------------------------------*/
int __inline _CBitsOnFromUlong(ULONG ulBits)
{
	ulBits = (ulBits & lMaskBitCount1) + ((ulBits & ~lMaskBitCount1) >> 1);
	ulBits = (ulBits & lMaskBitCount2) + ((ulBits & ~lMaskBitCount2) >> 2);
	ulBits = (ulBits & lMaskBitCount3) + ((ulBits & ~lMaskBitCount3) >> 4);
	ulBits = (ulBits & lMaskBitCount4) + ((ulBits & ~lMaskBitCount4) >> 8);
	ulBits = (ulBits & lMaskBitCount5) + ((ulBits & ~lMaskBitCount5) >> 16);
	
	return (int)ulBits;
}
	
// Masks for the encodings
//
#define grfEucCn        (ULONG) 0x0001
#define grfEucJp        (ULONG) 0x0002
#define grfEucKr        (ULONG) 0x0004
#define grfEucTw        (ULONG) 0x0008
#define grfIso2022Cn    (ULONG) 0x0010
#define grfIso2022Jp    (ULONG) 0x0020
#define grfIso2022Kr    (ULONG) 0x0040
#define grfIso2022Tw    (ULONG) 0x0080
#define grfBig5         (ULONG) 0x0100
#define grfGbk          (ULONG) 0x0200
#define grfHz           (ULONG) 0x0400 
#define grfShiftJis     (ULONG) 0x0800
#define grfWansung      (ULONG) 0x1000
#define grfUtf7         (ULONG) 0x2000 	
#define grfUtf8         (ULONG) 0x4000

// grfAll assumes that the tests for Euc-Kr fall within those
// for Wansung (as far as I can tell from reading, Euc-Kr is a
// strict subset of Wansung).  The same for Euc-Cn and Gbk.  No
// need to test for both the subset and the whole.
//
#define grfAll              (ULONG) 0x7FFA
#define grfAllButIso2022    (ULONG) 0x7F0A
#define cAll                13				// == number bits set in grfAll
#define cAllButIso2022      9				// == number bits set in grfAllButIso2022

// Array that maps an encoding to its mask
//
static ULONG _mpicetgrf[icetCount] =
{
	grfEucCn,
	grfEucJp,
	grfEucKr,
	grfEucTw,
	grfIso2022Cn,
	grfIso2022Jp,
	grfIso2022Kr,
	grfIso2022Tw,
	grfBig5,
	grfGbk,
	grfHz,
	grfShiftJis,
	grfWansung,
	grfUtf7,
	grfUtf8,
};

// Prototypes
//
static int  _NGetNextUch(IStream *pstmIn, unsigned char *c, BOOL *lpfIsHigh);
static ICET _IcetFromIcetMask(ULONG ulMask);
static ICET _IcetDefaultFromIcetMask(ULONG ulMask);
static CCE  _CceResolveAmbiguity(ULONG grfIcet, ICET *lpicet, int nPrefCp, EFam efPref);
static CCE  _CceReadEscSeq(IStream *pstmIn, int nPrefCp, ICET *lpicet, BOOL *lpfGuess);


/* C C E  D E T E R M I N E  I N P U T  T Y P E */
/*----------------------------------------------------------------------------
	%%Function: CceDetermineInputType
	%%Contact: jpick

	Attempt to determine the appropriate ICET type for the given 
	stream.  Caller-supplied get/unget routines used for data access.
----------------------------------------------------------------------------*/
CCE CceDetermineInputType(
    IStream   *pstmIn,           // input stream
	DWORD     dwFlags,			// configuration flags
	EFam      efPref,			// optional: preferred encoding family
	int       nPrefCp,			// optional: preferred code page
	ICET     *lpicet,			// set to detected encoding
	BOOL     *lpfGuess			// set to fTrue if function "guessed"
)
{
	unsigned char uch;
	int nToken;
	CCE cceRet;
	BOOL fGuess;
	ICET icet;
	int cIcetActive;
	ULONG grfIcetActive;	// Bitarray tracks which encodings are still active candidates.
	ICET icetSeq;
	int i, nCount, nCountCurr;
	DWORD dwValFlags;
	BOOL fIsHigh;
	int cchHigh = 0;
	int cchHighPairs = 0;
	int cchTotal = 0;
	BOOL fLastHigh = fFalse;
	
#if JPDEBUG3
	ULONG grfIcetNoCommonChars;
#endif

#if JPDEBUG
	printf("flags: %d\n", dwFlags);
#endif
	
	// Initialize parsers
	//
	dwValFlags = grfCountCommonChars;
	if (dwFlags & grfDetectUseCharMapping)
		dwValFlags |= grfValidateCharMapping;
	ValidateInitAll(dwValFlags);
	
	// Initialize locals -- be optimistic
	//
	cceRet = cceSuccess;
	fGuess = fFalse;
	grfIcetActive = grfAllButIso2022;
	cIcetActive = cAllButIso2022;
	
#if JPDEBUG3
	grfIcetNoCommonChars = grfAllButIso2022;
#endif
	
	while (fTrue)
		{
		nToken = _NGetNextUch(pstmIn, &uch, &fIsHigh);
		if (_FStopToken(nToken))
			break;
			
		// Update (admittedly dumb) statistics -- really counts high
		// ascii characters in runs (not really pairs).  But threshold
		// constants (defined, above) were determined by calculating
        // exactly these numbers for ~25 files, so it should be ok (?).
		//
		++cchTotal;
		if (fIsHigh)
			{
			++cchHigh;
			if (fLastHigh)
				++cchHighPairs;
			}
		fLastHigh = fIsHigh;
			
		for (i = 0; i < icetCount; i++)
			{
			if (!(grfIcetActive & _mpicetgrf[i]) || (NValidateUch((ICET)i, uch, fFalse) != 0))
				continue;
				
			grfIcetActive &= ~_mpicetgrf[i];
			--cIcetActive;
#if JPDEBUG
			printf("Log:  Lost %s at offset 0x%.4x (%d), char 0x%.2x\n", rgszIcetNames[i], (cchTotal-1), (cchTotal-1), uch);
#endif
			}
			
#if JPDEBUG3
		for (i = 0; i < icetCount; i++)
			{
			if (!(grfIcetActive & _mpicetgrf[i]) || !(grfIcetNoCommonChars & _mpicetgrf[i]))
				continue;
				
			if (!FValidateCharCount(i, &nCount) || (nCount == 0))
				continue;
				
			grfIcetNoCommonChars &= ~_mpicetgrf[i];
			printf("Log:  Found first common seq for %s at offset 0x%.4x (%d)\n", rgszIcetNames[i], (cchTotal-1), (cchTotal-1));
			}
#endif
			
		if ((cIcetActive == 0) || ((cIcetActive == 1) && (cchTotal > cchMinSample)))
			break;
		}
		
	// Figure out why we exited the loop.
	//
	if (nToken == err)
		{
		cceRet = cceRead;
		goto _LRet;
		}
		
	// Process escapes separately.  Interpret the escape sequence
	// to determine for real which ISO7 flavor we have found.
	//
	if ((nToken == esc) || (nToken == so) || (nToken == si))
		{
        LARGE_INTEGER   li;
        HRESULT hr;

        LISet32(li, -1 );
        hr = pstmIn->Seek(li,STREAM_SEEK_CUR, NULL);

//		if (!pfnUnget(uch, lpvPrivate))
//			{
//			cceRet = cceUnget;
//			goto _LRet;
//			}
		cceRet = _CceReadEscSeq(pstmIn, nPrefCp, &icet, &fGuess);
#if JPDEBUG
		if (cceRet == cceSuccess)
			printf("Log:  Found encoding %s at offset 0x%.4x (%d)\n", rgszIcetNames[icet], cchTotal, cchTotal);
#endif
		// ISO is a special case -- no need to check statistics.
		//
		goto _LRet;
		}
		
#if JPDEBUG2
	printf("Counts:  %d total chars, %d high chars, %d high pairs\n", cchTotal, cchHigh, cchHighPairs); 
#endif
			
	// If the token was eof, and we're not ignoring eof, transition
	// the remaining active sets on eof.
	//
	if ((nToken == eof) && !(dwFlags & grfDetectIgnoreEof))
		{
		for (i = 0; i < icetCount; i++)
			{
			if (!(grfIcetActive & _mpicetgrf[i]) || (NValidateUch((ICET)i, 0, fTrue) != 0))
				continue;
#if JPDEBUG
			printf("Log:  Lost %s at EOF\n", rgszIcetNames[i]);
#endif
			grfIcetActive &= ~_mpicetgrf[i];
			--cIcetActive;
			}
		}
		
	Assert(cIcetActive >= 0);	// better *not* be less than 0

	// See how we've narrowed our field of choices and set the 
	// return status accordingly.
	//
	if (cIcetActive <= 0)
		{
#if JPDEBUG
		printf("Log:  Bailed out entirely at offset 0x%.4x (%d)\n", cchTotal, cchTotal);
#endif
		cceRet = cceUnknownInput;
		goto _LRet;
		}
	else if (cIcetActive == 1)
		{
		icet = _IcetFromIcetMask(grfIcetActive);
#if JPDEBUG
		printf("Log:  Found encoding %s at offset 0x%.4x (%d)\n", rgszIcetNames[icet], cchTotal, cchTotal);
#endif
		// If we matched an encoding type and also found matching 
		// common character runs, skip statistics (see comment,
		// below).
		//
		if (FValidateCharCount(icet, &nCount) && (nCount > 0))
			{
#if JPDEBUG3
			printf("Log:  %d common sequences for %s\n", nCount, rgszIcetNames[icet]);
#endif
			goto _LRet;
			}
		else
			{
			goto _LStats;
			}
		}
		
	// Did we learn anything from counting characters?
	//
	icetSeq = (ICET)-1;
	nCountCurr = 0;
	for (i = 0; i < icetCount; i++)
		{
		if (!(grfIcetActive & _mpicetgrf[i]) || !FValidateCharCount((ICET)i, &nCount))
			continue;
			
		if (nCount > nCountCurr)
			{
			icetSeq = (ICET)i;
			nCountCurr = nCount;
			}
			
#if JPDEBUG3
		printf("Log:  %d common sequences for %s\n", nCount, rgszIcetNames[i]);
#endif
		}
			
	// Any luck?  If so, return.  Don't bother checking statistics.
	// We just proved that we found at least one common run of 
	// characters in this input.  The odds against this for just a
	// plain ASCII file with some high characters seem pretty high.
	// Ignore the statistics and just return the encoding type we
	// found.
	//
	if (icetSeq != -1)
		{
		icet = icetSeq;
		goto _LRet;
		}
		
#if JPDEBUG
	printf("Log:  Active Icet Mask 0x%.8x, %d left\n", grfIcetActive, cIcetActive);
	printf("Log:  Icet's left -- ");
	for (i = 0; i < icetCount; i++)
		{
		if (grfIcetActive & _mpicetgrf[i])
            printf("%s, ", rgszIcetNames[i]);
		}
    printf("\n");
#endif

	// If caller did not want us to try to guess at the encoding
	// in the absence of definitive data, bail out.
	//
	if (!(dwFlags & grfDetectResolveAmbiguity))
		{
		cceRet = cceAmbiguousInput;
		goto _LRet;
		}
		
	// We're guessing -- note it.
	//
	fGuess = fTrue;
		
	// More than one active encoding.  Attempt to resolve ambiguity.
	//
	cceRet = _CceResolveAmbiguity(grfIcetActive, &icet, nPrefCp, efPref);
	if (cceRet != cceSuccess)
		return cceRet;
		
_LStats:
		
	// Adjust the return code based on the "statistics" we gathered,
	// above.
	//
	if (cchHigh > 0)
		{
		if ((cchTotal < cchMinSample) ||
			(((cchHigh * 100) / cchTotal) < nHighCharThreshold) ||
			(((cchHighPairs * 100) / cchHigh) < nHighPairThreshold))
			{
			cceRet = cceMayBeAscii;
			}
		}
	else
		{
		cceRet = cceMayBeAscii;		// no high-ascii characters?  definitely maybe!
		}

#if JPDEBUG2
	if (cchHigh > 0)
		{
		int nPercent1 = ((cchHigh * 100) / cchTotal);
		int nPercent2 = ((cchHighPairs * 100) / cchHigh);
		printf("Ratios -- high/total: %d%%, runs/high: %d%%\n", nPercent1, nPercent2);
		}
#endif
		
_LRet:

	// Set the return variables, if successful.
	//
	if ((cceRet == cceSuccess) || (cceRet == cceMayBeAscii))
		{
		*lpicet = icet;
		*lpfGuess = fGuess;
		}
		
#if JPDEBUG
		if (cceRet == cceSuccess)
			{
			printf("Log:  Returning %s, fGuess = %s\n", rgszIcetNames[icet], (fGuess ? "fTrue" : "fFalse"));
			}
		else if (cceRet == cceMayBeAscii)
			{
			printf("Log:  Returning %s, fGuess = %s, may-be-ASCII\n", rgszIcetNames[icet], (fGuess ? "fTrue" : "fFalse"));
			}
#endif
		
	return cceRet;
}


/* _ N  G E T  N E X T  U C H */
/*----------------------------------------------------------------------------
	%%Function: _NGetNextUch
	%%Contact: jpick

	Get the next character from the input stream.  Classify the character.
----------------------------------------------------------------------------*/
static int _NGetNextUch(IStream *pstmIn, unsigned char *c, BOOL *lpfIsHigh)
{
	ULONG rc;
	unsigned char uch;
    HRESULT hr;
		  
    hr = pstmIn->Read(&uch, 1, &rc);
	
    if (rc == 0)
		return eof;
	else if (hr != S_OK )
		return err;
		
	*lpfIsHigh = (uch >= 0x80);
	*c = uch;
		
	switch (uch)
		{
		case chEsc:
			return esc;
		case chSo:
			return so;
		case chSi:
			return si;
		default:
			return xmn;
		}
}


// Masks for _CceResolveAmbiguity() -- only externally supported character
// sets are used in ambiguity resolution.  Don't include Euc-Tw here.
//
#define grfJapan			(ULONG) (grfShiftJis | grfEucJp)
#define grfChina			(ULONG) (grfEucCn | grfGbk)
#define grfKorea			(ULONG) (grfEucKr | grfWansung)
#define grfTaiwan			(ULONG) (grfBig5)
#define grfDbcs				(ULONG) (grfShiftJis | grfGbk | grfWansung | grfBig5)
#define grfEuc				(ULONG) (grfEucJp | grfEucKr | grfEucCn)


/* _ C E  F R O M  C E  M A S K */
/*----------------------------------------------------------------------------
	%%Function: _IcetFromIcetMask
	%%Contact: jpick
----------------------------------------------------------------------------*/
static ICET _IcetFromIcetMask(ULONG ulMask)
{
	switch (ulMask)
	{
	case grfEucCn:
		return icetEucCn;
	case grfEucJp:
		return icetEucJp;
	case grfEucKr:
		return icetEucKr;
	case grfEucTw:
		return icetEucTw;
	case grfIso2022Cn:
		return icetIso2022Cn;
	case grfIso2022Jp:
		return icetIso2022Jp;
	case grfIso2022Kr:
		return icetIso2022Kr;
	case grfIso2022Tw:
		return icetIso2022Tw;
	case grfBig5:
		return icetBig5;
	case grfGbk:
		return icetGbk;
	case grfHz:
		return icetHz;
	case grfShiftJis:
		return icetShiftJis;
	case grfWansung:
		return icetWansung;
	case grfUtf7:
		return icetUtf7;
	case grfUtf8:
		return icetUtf8;
	default:
		break;
	}
	
	// Should never get here ...
	//
//	NotReached();
	
	// Can't return a bogus value, here.
	//
	return icetShiftJis;
}

/* _ C E  D E F A U L T  F R O M  C E  M A S K */
/*----------------------------------------------------------------------------
	%%Function: _IcetDefaultFromIcetMask
	%%Contact: jpick
----------------------------------------------------------------------------*/
static ICET _IcetDefaultFromIcetMask(ULONG ulMask)
{
	// Priorities -- DBCS, EUC, Japan, Taiwan, China and Korea (???).
	//
	if (ulMask & grfDbcs)
		{
		if (ulMask & grfJapan)
			return icetShiftJis;
		if (ulMask & grfChina)
			return icetGbk;
		if (ulMask & grfTaiwan)
			return icetBig5;
		if (ulMask & grfKorea)
			return icetWansung;
		}
	else // EUC
		{
		if (ulMask & grfJapan)
			return icetEucJp;
		if (ulMask & grfChina)
			return icetEucCn;
		if (ulMask & grfKorea)
			return icetEucKr;			// may be able to return icetWansung, here
		}
		
	// (Assert);
	return icetShiftJis;  // ???
}

/* _ U L  C E  M A S K  F R O M  C P  E T P */
/*----------------------------------------------------------------------------
	%%Function: _UlIcetMaskFromCpEf
	%%Contact: jpick
----------------------------------------------------------------------------*/
static ULONG _UlIcetMaskFromCpEf(int nCp, EFam ef)
{
	ULONG grf = grfAll;
	
	switch (nCp)
	{
	case nCpJapan:
		grf &= grfJapan;
		break;
	case nCpChina:
		grf &= grfChina;
		break;
	case nCpKorea:
		grf &= grfKorea;
		break;
	case nCpTaiwan:
		grf &= grfTaiwan;
		break;
	default:
		break;
	}
	
	switch (ef)
	{
	case efDbcs:
		grf &= grfDbcs;
		break;
	case efEuc:
		grf &= grfEuc;
		break;
	default:
		break;
	}
	return grf;
}


/* _ C C E  R E S O L V E  A M B I G U I T Y */
/*----------------------------------------------------------------------------
	%%Function: _CceResolveAmbiguity
	%%Contact: jpick

	Attempt to resolve ambiguous input encoding based on user
	preferences, if set, and system code page.  grfIcet contains a
	bitmask representing the encodings that are still possible after
	examining the input sample.
----------------------------------------------------------------------------*/
static CCE _CceResolveAmbiguity(ULONG grfIcet, ICET *lpicet, int nPrefCp, EFam efPref)
{
    ULONG grfIcetOrig = grfIcet;
	ULONG grfPref;
	ULONG grfSys;
	ULONG grfResult;
	int cIcet;
	
	// Build "list" of encodings based on user-prefs.
	//
	grfPref = _UlIcetMaskFromCpEf(nPrefCp, efPref);
	
	// See if the user's preferences make any difference.
	//
	grfResult = grfIcet & grfPref;
	
	if (grfResult)
		{
		cIcet = _CBitsOnFromUlong(grfResult);
		if (cIcet == 1)
			{
			*lpicet = _IcetFromIcetMask(grfResult);
			return cceSuccess;
			}
		else
			grfIcet = grfResult;			// see comment, below
		}
		
	// Now look to the system code page for help.  Look at
	// the set of encodings as modified by the user
	// preferences (??? do we want to do this ???).
	//
	if (!FIsFeCp(g_uACP) || (grfIcetOrig & grfUtf8))
		goto _LDefault;
		
	// Build "list" of encodings based on system cp.
	//
	grfSys = _UlIcetMaskFromCpEf(g_uACP, (EFam) 0);
	
	// See if the system cp makes any difference.
	//
	grfResult = grfIcet & grfSys;
	
	if (grfResult)
		{
		cIcet = _CBitsOnFromUlong(grfResult);
		if (cIcet == 1)
			{
			*lpicet = _IcetFromIcetMask(grfResult);
			return cceSuccess;
			}
		}
			
_LDefault:

    // Special case -- pick UTF-8 if it's legal and the prefs
    // don't help us.
    //
	*lpicet =
        (grfIcetOrig & grfUtf8) ? icetUtf8 : _IcetDefaultFromIcetMask(grfIcet);
	return cceSuccess;
}


/* _ C C E  R E A D  E S C  S E Q */
/*----------------------------------------------------------------------------
	%%Function: _CceReadEscSeq
	%%Contact: jpick

	We've read (and put back) an escape character.  Call the ISO-2022
	escape sequence converter to have it map the escape sequence to the
	appropriate character set.  We may be looking at the escape sequence
	for ASCII, so be prepared to read ahead to the next one.
----------------------------------------------------------------------------*/
static CCE _CceReadEscSeq(
    IStream   *pstmIn,           // input stream
	int       nPrefCp,
	ICET     *lpicet,
	BOOL     *lpfGuess
)
{
	unsigned char uch;
	CCE cceRet;
	int nToken;
	BOOL fDummy;
	
	do
		{
		cceRet = CceReadEscSeq(pstmIn, lpicet); 
		
		if ((cceRet == cceSuccess) || (cceRet != cceMayBeAscii))
			break;
		
		while (fTrue)
			{
			nToken = _NGetNextUch(pstmIn, &uch, &fDummy);
			if (_FStopToken(nToken))
				break;
			}
			
		// Why did we stop?
		//
		if (nToken == err)
			{
			cceRet = cceRead;
			break;
			}
		else if (nToken == eof)
			{
			// Means this is legal ISO-2022 input, but we've seen nothing
			// but non-flavor-specific escape sequences (e.g., only ASCII
			// or shift sequences).  Choose the encoding type based on
			// preferences (only pick from those currently supported
			// externally).
			//
			switch (nPrefCp)
				{
				case nCpKorea:
					*lpicet = icetIso2022Kr;
					break;
				case nCpJapan:
				default:						// Right ??? (gotta pick something ...)
					*lpicet = icetIso2022Jp;
					break;
				}
			*lpfGuess = fTrue;					// not *really* guessing, but ... (???)
			cceRet = cceSuccess;
			break;
			}
			
		Assert((nToken == esc) || (nToken == so) || (nToken == si));
		{
        LARGE_INTEGER   li;
        HRESULT hr;

        LISet32(li, -1 );

        hr = pstmIn->Seek(li,STREAM_SEEK_CUR, NULL);
        }
		// Put it back for CceReadEscSeq() to process.
		//
//		if (!pfnUnget(uch, lpvPrivate))
//			{
//			cceRet = cceUnget;
//			break;
//			}
			
		} while (fTrue);
	
	return cceRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\hzgbobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from HZ-GB-2312
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "hzgbobj.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccHzGbIn::CInccHzGbIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccHzGbIn::Reset()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_fGBMode = FALSE;
	m_tcLeadByte = 0 ;
	m_nESCBytes = 0 ;  
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccHzGbIn::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccHzGbIn::CleanUp()
{
	return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccHzGbIn::ConvMain(UCHAR tc)
{
	BOOL fDone = TRUE;

	if (!m_fGBMode) {
		if (tc == '~') {
			m_pfnConv = ConvTilde;
			m_pfnCleanUp = CleanUpTilde;
			m_nESCBytes = 1 ;  
		} else {
			fDone = Output(tc);
		}
	} else {
		if (tc >= 0x20 && tc <= 0x7e) {
			m_pfnConv = ConvDoubleByte;
			m_pfnCleanUp = CleanUpDoubleByte;
			m_tcLeadByte = tc;
		} else {
			fDone = Output(tc);
		}
	}
	return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccHzGbIn::CleanUpMain()
{
	return TRUE;
}

/******************************************************************************
***************************   C O N V   T I L D E   ***************************
******************************************************************************/

BOOL CInccHzGbIn::ConvTilde(UCHAR tc)
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	m_nESCBytes = 0 ;  

	switch (tc) {
	case '~':
		return Output('~');

	case '{':
		m_fGBMode = TRUE;
		return TRUE;

	case '\n':
		return TRUE; // Just eat it

	default:
		(void)Output('~');
		if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
***********************   C L E A N   U P   T I L D E   ***********************
******************************************************************************/

BOOL CInccHzGbIn::CleanUpTilde()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	return Output('~');
}

/******************************************************************************
*********************   C O N V   D O U B L E   B Y T E   *********************
******************************************************************************/

BOOL CInccHzGbIn::ConvDoubleByte(UCHAR tc)
{
	BOOL fRet ;
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	if (m_tcLeadByte >= 0x21 && m_tcLeadByte <= 0x77 && tc >= 0x21 && tc <= 0x7e) { // Check if GB char
		(void)Output(m_tcLeadByte | 0x80);
		fRet = Output(tc | 0x80);
	} else if (m_tcLeadByte == '~' && tc == '}') { // 0x7e7d
		m_fGBMode = FALSE;
		fRet = TRUE;
	} else if (m_tcLeadByte >= 0x78 && m_tcLeadByte <= 0x7d && tc >= 0x21 && tc <= 0x7e) { // Check if non standard extended code
		(void)Output((UCHAR)0xa1); // Output blank box symbol
		fRet = Output((UCHAR)0xf5);
	} else if (m_tcLeadByte == '~') {
		(void)Output('~'); // Output blank box symbol
		fRet = Output(tc);
	} else if (m_tcLeadByte == ' ') {
		fRet = Output(tc);
	} else if (tc == ' ') {
		(void)Output((UCHAR)0xa1); // Output space symbol
		fRet = Output((UCHAR)0xa1);
	} else {
		(void)Output(m_tcLeadByte);
		fRet = Output(tc);
	}
	m_tcLeadByte = 0 ;
	return fRet ;
}

/******************************************************************************
*****************   C L E A N   U P   D O U B L E   B Y T E   *****************
******************************************************************************/

BOOL CInccHzGbIn::CleanUpDoubleByte()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	return Output(m_tcLeadByte);
}

int CInccHzGbIn::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1;
    else if ( m_nESCBytes )
        return 1;
    else
	    return 0;
}

DWORD CInccHzGbIn::GetConvertMode()
{
    return ( m_fGBMode ? 1 : 0 ) ;
}

void CInccHzGbIn::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    if ( mode & 0x01 )
        m_fGBMode = TRUE ;
    else
        m_fGBMode = FALSE ;

 	return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to HZ-GB-2312
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccHzGbOut::CInccHzGbOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR * lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/
void CInccHzGbOut::Reset()
{
	m_fDoubleByte = FALSE;
	m_fGBMode = FALSE;
	m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccHzGbOut::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = TRUE;
	HRESULT hr = S_OK;


    if (!m_fDoubleByte) 
    {
        //
        // We're not using IsDBCSLeadByteEx() due to perf. concern
        // We should assert that our hard code table match IsDBCSLeadByteEx(), 
        // But, MLang ships with down level platforms and assert won't be valid if there is a range change
        //
        if (IS_CHS_LEADBYTE(tc)) 
        {
            m_fDoubleByte = TRUE;
            m_tcLeadByte = tc;
        }
        else 
        {
            if (m_fGBMode) 
            {
                Output('~');
                fDone = Output('}');
                m_fGBMode = FALSE;
            }
            // tilde should be encoded as two tildes
            if (tc == '~') 
                Output('~');
            fDone = Output(tc);
        }
    } 
    else 
    {
        m_fDoubleByte = FALSE;
// a-ehuang: Bug# 31726, send all out of range code to convert to NCR
//			 RFC 1843 => valid HZ code range: leading byte 0x21 - 0x77, 2nd byte 0x21 - 0x7e
        if ( (m_tcLeadByte < 0xa1 || m_tcLeadByte > 0xf7) || (tc < 0xa1 || tc > 0xfe) )
// end-31726
        {
            UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    

            if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
            {
                // only take SBCS, no DBCS character
                if ( 1 != WideCharToMultiByte(CP_CHN_GB, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                    szDefaultChar[0] = 0x3f;
            }

            // End Escape sequence for NCR entity output
            if (m_fGBMode)
            {
                Output('~');
                Output('}');
                m_fGBMode = FALSE;
            }

            if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
            {
                char    szChar[2];
                char    szDstStr[10];
                WCHAR   szwChar[2];
                int     cCount;

                szChar[0] = m_tcLeadByte;
                szChar[1] = tc;
                
                if (MultiByteToWideChar(CP_CHN_GB, 0, szChar, 2, szwChar, ARRAYSIZE(szwChar)))
                {

                    // Output NCR entity
                    Output('&');
                    Output('#');
                    _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                    cCount = lstrlenA(szDstStr);
                    for (int i=0; i< cCount; i++)
                    {
                        Output(szDstStr[i]);
                    }
                    fDone = Output(';');
                }
                else
                {
    		        fDone = Output(szDefaultChar[0]);
                    hr = S_FALSE;
                }
            }
            else
            {
                fDone = Output(szDefaultChar[0]);
                hr = S_FALSE;
            }
        }
        else
        {
            if (!m_fGBMode) 
            {
                Output('~');
                Output('{');
                m_fGBMode = TRUE;
            }

            Output(m_tcLeadByte & 0x7f);
            fDone = Output(tc & 0x7f);
        }
        m_tcLeadByte = 0 ;
    }

    if (!fDone)
        hr = E_FAIL;

    return hr;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccHzGbOut::CleanUp()
{
	if (!m_fGBMode) {
		return TRUE;
	} else {
		m_fGBMode = FALSE ;
		(void)Output('~');
		return Output('}');
	}
}

int CInccHzGbOut::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1;
    else
	    return 0;
}

DWORD CInccHzGbOut::GetConvertMode()
{
 	return 0 ;
}

void CInccHzGbOut::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
 	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\font.h ===
/********************************************************************
 *
 *  Header Name : font.h 
 *  Font structures defines for MLang fontlink2
 *
 ********************************************************************/

#ifndef __FONT_H__
#define __FONT_H__

#define  TWO_BYTE_NUM(p)   (((p[0])<<8)|(p[1]))
#define  FOUR_BYTE_NUM(p)  (((p[0])<<24)|((p[1])<<16)|((p[2])<<8)|(p[3]))
#define  OFFSET_OS2CPRANGE sizeof(SHORT) * 24 + sizeof(PANOSE) + sizeof(ULONG) * 4 + sizeof(CHAR) * 4 
#define  MAX_FONT_FILE_NAME     48
#define  FONT_TABLE_INIT_SIZE   100
#define  FONT_DATA_FILE_NAME    TEXT("mlfcache.dat")
#define  FONT_DATA_SIGNATURE    "mlang font data"
#define  REGFONTKEYNT           TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts")
#define  REGFONTKEY95           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fonts")
#define  FONT_FOLDER            TEXT("fonts")
#define  MAX_FONT_INDEX         30
#define  FONTDATATABLENUM       2

// Font database file format:
// Table header
// Table Entry [Table Entry]
// Table data [Table data]
typedef struct tagFontDataHeader{
    char    FileSig[16];
    DWORD   dwVersion;
    DWORD   dwCheckSum;
    WORD    nTable;
} FONTDATAHEADER;

typedef struct tagFontTable{
    char    szName[4];
    DWORD   dwOffset;
    DWORD   dwSize;
} FONTDATATABLE;

typedef struct {
  char  TTCTag    [4];
  BYTE  Version   [4];
  BYTE  DirCount  [4];
  BYTE  OffsetTTF1[4];
} TTC_HEAD;

typedef struct {
  BYTE  Version      [4];
  BYTE  NumTables    [2];
  BYTE  SearchRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} TTF_HEAD;

typedef struct {
  char  Tag     [4];
  BYTE  CheckSum[4];
  BYTE  Offset  [4];
  BYTE  Length  [4];
} TABLE_DIR;

typedef struct {
  BYTE  Format[2];
  BYTE  NumRec[2];
  BYTE  Offset[2];
} NAME_TABLE;

#define FONT_SUBFAMILY_NAME 2
#define FONT_NAME           4
#define MICROSOFT_PLATFORM  3
#define UNICODE_INDEXING    1
#define CMAP_FORMAT_FOUR    4
#define APPLE_UNICODE_PLATFORM  0
#define APPLE_UNICODE_INDEXING  3
#define UNICODE_SYMBOL_INDEXING 0


typedef struct {
  BYTE  Platform[2];
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  LangID  [2];
  BYTE  NameID  [2];  // = 2 for font subfamily name
  BYTE  Length  [2];
  BYTE  Offset  [2];
} NAME_RECORD;

typedef struct {
  BYTE  Version  [2];
  BYTE  NumTables[2];
} CMAP_HEAD;

typedef struct {
  BYTE  Platform[2];  // = 3 if Microsoft
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  Offset  [4];
} CMAP_TABLE;

typedef struct {
  BYTE  Platform[2];  // = 3 if Microsoft
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  Offset  [4];
} OS2_TABLE;

typedef struct {
  BYTE  Format       [2];  // must be 4
  BYTE  Length       [2];
  BYTE  Version      [2];
  BYTE  SegCountX2   [2];
  BYTE  SeachgRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} CMAP_FORMAT;

// font table
typedef struct tagFontInfo{
    TCHAR   szFaceName[LF_FACESIZE];
    TCHAR   szFileName[MAX_FONT_FILE_NAME];
    DWORD   dwCodePages[2];
    LOGFONT lf;
    DWORD   dwUniSubRanges[4];
    SCRIPT_IDS scripts;
} FONTINFO;

typedef struct tagSCRIPT
{
    SCRIPT_ID   sid;
    UINT        uidDescription;     // script name (localization needed)
    UINT        uiCodePage;         // can be NULL to indicate no Windows code pages 
    WCHAR       wcCandidate;        // primary candiate for the script
    UINT        uidFixedWidthFont;  // default fixed width font (localization needed)
    UINT        uidProportionalFont;// default proportional font (localization needed)
    DWORD       dwFlags;            // script level flag
} SCRIPT;

//Unicode range table
typedef struct tagURangeFont{
    WCHAR wcFrom;
    WCHAR wcTo;
    int   nFonts;
    int   *pFontIndex;
} URANGEFONT;

extern UINT     g_cScript;

extern const    SCRIPT ScriptTable[];

//Script 


#endif  // __FONT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\ichrcnv.cpp ===
#include "private.h"
#include "detcbase.h"
#include "codepage.h"
#include "detcjpn.h"
#include "detckrn.h"
#include "fechrcnv.h"
#include "ichrcnv.h"
#include "cpdetect.h"


#define CONV_UU     12
#define CONV_UUW    10
#define CONV_UUWI   9
#define CONV_UW     6
#define CONV_UWI    5
#define CONV_WI     3

#define MAX_CHAR_SIZE   4

#define MAPUSERDEF(x) (((x) == 50000) ? 1252 : (x))
#define CONVERT_IS_VALIDCODEPAGE(x) (((x) == CP_USER_DEFINED) ? TRUE: IsValidCodePage(x))
#define CONV_CHK_NLS 0x00000001

struct ENCODINGINFO
{
    DWORD       dwEncoding;
    DWORD       dwCodePage;
    BYTE        bTypeUUIW;
    CP_STATE    nCP_State ;                 // whether this is a valid windows codepage  ?
    DWORD       dwFlags;                    // give us more flexibilities to handle different encodings differently
};

static WCHAR UniocdeSignature = { 0xFFFE } ;

/*
    Bit 4 (16) - Unicode <-> Internet Encoding
    Bit 3 (8) - UTF8, UTF7
    Bit 2 (4) - Unicode
    Bit 1 (2) - Windows CodePage
    Bit 0 (1) - Internet Encoding

     P.S. if bit 4 is set, it means it should convert between Unicode and Internet
     Encoding directly, no intermediate step - Windows CodePage
*/

// these codepages including Unicode need special convertor
static struct ENCODINGINFO aEncodingInfo[] =
{

    {  CP_JPN_SJ,            932,       0x02,   INVALID_CP,     0 }, // W-Japanese Shift JIS
    {  CP_CHN_GB,            936,       0x02,   INVALID_CP,     0 }, // W-Simplified Chinese
    {  CP_KOR_5601,          949,       0x02,   INVALID_CP,     0 }, // W-Krean Unified Hangul
    {  CP_TWN,               950,       0x02,   INVALID_CP,     0 }, // W-Traditional Chinese
    {  CP_UCS_2,               0,       0x04,   INVALID_CP,     0 }, // U-Unicode 
    {  CP_UCS_2_BE,            0,       0x04,   INVALID_CP,     0 }, // U-Unicode Big Endian
    {  CP_1252,             1252,       0x02,   INVALID_CP,     0 }, // W-Latin 1
    {  CP_20127,            1252,       0x11,   INVALID_CP,     CONV_CHK_NLS }, // US ASCII
    {  CP_ISO_8859_1,       1252,       0x11,   INVALID_CP,     CONV_CHK_NLS }, // I-ISO 8859-1 Latin 1 
    {  CP_ISO_8859_15,      1252,       0x11,   INVALID_CP,     CONV_CHK_NLS }, // I-ISO 8859-1 Latin 1 
    {  CP_AUTO,             1252,       0x01,   INVALID_CP,     0 }, // General auto detect 
    {  CP_ISO_2022_JP,       932,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-JP No Halfwidth Katakana 
    {  CP_ISO_2022_JP_ESC,   932,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-JP w/esc Halfwidth Katakana 
    {  CP_ISO_2022_JP_SIO,   932,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-JP w/sio Halfwidth Katakana 
    {  CP_ISO_2022_KR,       949,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-KR
    {  CP_ISO_2022_TW,       950,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-TW
    {  CP_ISO_2022_CH,       936,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-CH
    {  CP_JP_AUTO,           932,       0x01,   INVALID_CP,     0 }, // JP auto detect 
    {  CP_CHS_AUTO,          936,       0x01,   INVALID_CP,     0 }, // Simplified Chinese auto detect 
    {  CP_KR_AUTO,           949,       0x01,   INVALID_CP,     0 }, // KR auto detect 
    {  CP_CHT_AUTO,          950,       0x01,   INVALID_CP,     0 }, // Traditional Chinese auto detect 
    {  CP_CYRILLIC_AUTO,    1251,       0x01,   INVALID_CP,     0 }, // Cyrillic auto detect 
    {  CP_GREEK_AUTO,       1253,       0x01,   INVALID_CP,     0 }, // Greek auto detect 
    {  CP_ARABIC_AUTO,      1256,       0x01,   INVALID_CP,     0 }, // Arabic auto detect 
    {  CP_EUC_JP,            932,       0x01,   INVALID_CP,     0 }, // EUC Japanese 
    {  CP_EUC_CH,            936,       0x01,   INVALID_CP,     0 }, // EUC Chinese 
    {  CP_EUC_KR,            949,       0x01,   INVALID_CP,     0 }, // EUC Korean
    {  CP_EUC_TW,            950,       0x01,   INVALID_CP,     0 }, // EUC Taiwanese 
    {  CP_CHN_HZ,            936,       0x01,   INVALID_CP,     0 }, // Simplify Chinese HZ-GB 
    {  CP_UTF_7,               0,       0x08,   INVALID_CP,     0 }, // U-UTF7 
    {  CP_UTF_8,               0,       0x08,   INVALID_CP,     0 }, // U-UTF8 
};


// HTML name entity table for Latin-1 Supplement - from 0x00A0-0x00FF

#define NAME_ENTITY_OFFSET  0x00A0
#define NAME_ENTITY_MAX     0x00FF
#define NAME_ENTITY_ENTRY   96

static CHAR *g_lpstrNameEntity[NAME_ENTITY_ENTRY] =
{
    "&nbsp;",   // "&#160;" -- no-break space = non-breaking space,
    "&iexcl;",  // "&#161;" -- inverted exclamation mark, U+00A1 ISOnum -->
    "&cent;",   // "&#162;" -- cent sign, U+00A2 ISOnum -->
    "&pound;",  // "&#163;" -- pound sign, U+00A3 ISOnum -->
    "&curren;", // "&#164;" -- currency sign, U+00A4 ISOnum -->
    "&yen;",    // "&#165;" -- yen sign = yuan sign, U+00A5 ISOnum -->
    "&brvbar;", // "&#166;" -- broken bar = broken vertical bar,
    "&sect;",   // "&#167;" -- section sign, U+00A7 ISOnum -->
    "&uml;",    // "&#168;" -- diaeresis = spacing diaeresis,
    "&copy;",   // "&#169;" -- copyright sign, U+00A9 ISOnum -->
    "&ordf;",   // "&#170;" -- feminine ordinal indicator, U+00AA ISOnum -->
    "&laquo;",  // "&#171;" -- left-pointing double angle quotation mark
    "&not;",    // "&#172;" -- not sign = discretionary hyphen,
    "&shy;",    // "&#173;" -- soft hyphen = discretionary hyphen,
    "&reg;",    // "&#174;" -- registered sign = registered trade mark sign,
    "&macr;",   // "&#175;" -- macron = spacing macron = overline
    "&deg;",    // "&#176;" -- degree sign, U+00B0 ISOnum -->
    "&plusmn;", // "&#177;" -- plus-minus sign = plus-or-minus sign,
    "&sup2;",   // "&#178;" -- superscript two = superscript digit two
    "&sup3;",   // "&#179;" -- superscript three = superscript digit three
    "&acute;",  // "&#180;" -- acute accent = spacing acute,
    "&micro;",  // "&#181;" -- micro sign, U+00B5 ISOnum -->
    "&para;",   // "&#182;" -- pilcrow sign = paragraph sign,
    "&middot;", // "&#183;" -- middle dot = Georgian comma
    "&cedil;",  // "&#184;" -- cedilla = spacing cedilla, U+00B8 ISOdia -->
    "&sup1;",   // "&#185;" -- superscript one = superscript digit one,
    "&ordm;",   // "&#186;" -- masculine ordinal indicator,
    "&raquo;",  // "&#187;" -- right-pointing double angle quotation mark
    "&frac14;", // "&#188;" -- vulgar fraction one quarter
    "&frac12;", // "&#189;" -- vulgar fraction one half
    "&frac34;", // "&#190;" -- vulgar fraction three quarters
    "&iquest;", // "&#191;" -- inverted question mark
    "&Agrave;", // "&#192;" -- latin capital letter A with grave
    "&Aacute;", // "&#193;" -- latin capital letter A with acute,
    "&Acirc;",  // "&#194;" -- latin capital letter A with circumflex,
    "&Atilde;", // "&#195;" -- latin capital letter A with tilde,
    "&Auml;",   // "&#196;" -- latin capital letter A with diaeresis,
    "&Aring;",  // "&#197;" -- latin capital letter A with ring above
    "&AElig;",  // "&#198;" -- latin capital letter AE
    "&Ccedil;", // "&#199;" -- latin capital letter C with cedilla,
    "&Egrave;", // "&#200;" -- latin capital letter E with grave,
    "&Eacute;", // "&#201;" -- latin capital letter E with acute,
    "&Ecirc;",  // "&#202;" -- latin capital letter E with circumflex,
    "&Euml;",   // "&#203;" -- latin capital letter E with diaeresis,
    "&Igrave;", // "&#204;" -- latin capital letter I with grave,
    "&Iacute;", // "&#205;" -- latin capital letter I with acute,
    "&Icirc;",  // "&#206;" -- latin capital letter I with circumflex,
    "&Iuml;",   // "&#207;" -- latin capital letter I with diaeresis,
    "&ETH;",    // "&#208;" -- latin capital letter ETH, U+00D0 ISOlat1 -->
    "&Ntilde;", // "&#209;" -- latin capital letter N with tilde,
    "&Ograve;", // "&#210;" -- latin capital letter O with grave,
    "&Oacute;", // "&#211;" -- latin capital letter O with acute,
    "&Ocirc;",  // "&#212;" -- latin capital letter O with circumflex,
    "&Otilde;", // "&#213;" -- latin capital letter O with tilde,
    "&Ouml;",   // "&#214;" -- latin capital letter O with diaeresis,
    "&times;",  // "&#215;" -- multiplication sign, U+00D7 ISOnum -->
    "&Oslash;", // "&#216;" -- latin capital letter O with stroke
    "&Ugrave;", // "&#217;" -- latin capital letter U with grave,
    "&Uacute;", // "&#218;" -- latin capital letter U with acute,
    "&Ucirc;",  // "&#219;" -- latin capital letter U with circumflex,
    "&Uuml;",   // "&#220;" -- latin capital letter U with diaeresis,
    "&Yacute;", // "&#221;" -- latin capital letter Y with acute,
    "&THORN;",  // "&#222;" -- latin capital letter THORN,
    "&szlig;",  // "&#223;" -- latin small letter sharp s = ess-zed,
    "&agrave;", // "&#224;" -- latin small letter a with grave
    "&aacute;", // "&#225;" -- latin small letter a with acute,
    "&acirc;",  // "&#226;" -- latin small letter a with circumflex,
    "&atilde;", // "&#227;" -- latin small letter a with tilde,
    "&auml;",   // "&#228;" -- latin small letter a with diaeresis,
    "&aring;",  // "&#229;" -- latin small letter a with ring above
    "&aelig;",  // "&#230;" -- latin small letter ae
    "&ccedil;", // "&#231;" -- latin small letter c with cedilla,
    "&egrave;", // "&#232;" -- latin small letter e with grave,
    "&eacute;", // "&#233;" -- latin small letter e with acute,
    "&ecirc;",  // "&#234;" -- latin small letter e with circumflex,
    "&euml;",   // "&#235;" -- latin small letter e with diaeresis,
    "&igrave;", // "&#236;" -- latin small letter i with grave,
    "&iacute;", // "&#237;" -- latin small letter i with acute,
    "&icirc;",  // "&#238;" -- latin small letter i with circumflex,
    "&iuml;",   // "&#239;" -- latin small letter i with diaeresis,
    "&eth;",    // "&#240;" -- latin small letter eth, U+00F0 ISOlat1 -->
    "&ntilde;", // "&#241;" -- latin small letter n with tilde,
    "&ograve;", // "&#242;" -- latin small letter o with grave,
    "&oacute;", // "&#243;" -- latin small letter o with acute,
    "&ocirc;",  // "&#244;" -- latin small letter o with circumflex,
    "&otilde;", // "&#245;" -- latin small letter o with tilde,
    "&ouml;",   // "&#246;" -- latin small letter o with diaeresis,
    "&divide;", // "&#247;" -- division sign, U+00F7 ISOnum -->
    "&oslash;", // "&#248;" -- latin small letter o with stroke,
    "&ugrave;", // "&#249;" -- latin small letter u with grave,
    "&uacute;", // "&#250;" -- latin small letter u with acute,
    "&ucirc;",  // "&#251;" -- latin small letter u with circumflex,
    "&uuml;",   // "&#252;" -- latin small letter u with diaeresis,
    "&yacute;", // "&#253;" -- latin small letter y with acute,
    "&thorn;",  // "&#254;" -- latin small letter thorn with,
    "&yuml;",   // "&#255;" -- latin small letter y with diaeresis,
};


#ifdef MORE_NAME_ENTITY   // in case we decide to do more name entity latter
// Additional HTML 4.0 name entity table for CP 1252 extension character set
#define CP1252EXT_BASE  (UINT)0x0080
#define CP1252EXT_MAX   (UINT)0x009F
#define NONUNI          0xFFFF
#define UNDEFCHAR       "???????"
#define CP1252EXT_NCR_SIZE  7

struct NAME_ENTITY_EXT
{
    UWORD     uwUniCode;
    LPCTSTR   lpszNameEntity;
};

static struct NAME_ENTITY_EXT aNameEntityExt[] =
{
//      UniCode  NCR_Enty          Name_Enty        CP1252Ext  Comment
    {   0x20AC,  "&#8364;"  },  // "&euro;"    },  // &#128;  #EURO SIGN
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#129;  #UNDEFINED
    {   0x201A,  "&#8218;"  },  // "&sbquo;"   },  // &#130;  #SINGLE LOW-9 QUOTATION MARK
    {   0x0192,  "&#0402;"  },  // "&fnof;"    },  // &#131;  #LATIN SMALL LETTER F WITH HOOK
    {   0x201E,  "&#8222;"  },  // "&bdquo;"   },  // &#132;  #DOUBLE LOW-9 QUOTATION MARK
    {   0x2026,  "&#8230;"  },  // "&hellip;"  },  // &#133;  #HORIZONTAL ELLIPSIS
    {   0x2020,  "&#8224;"  },  // "&dagger;"  },  // &#134;  #DAGGER
    {   0x2021,  "&#8225;"  },  // "&Dagger;"  },  // &#135;  #DOUBLE DAGGER
    {   0x02C6,  "&#0710;"  },  // "&circ;"    },  // &#136;  #MODIFIER LETTER CIRCUMFLEX ACCENT
    {   0x2030,  "&#8240;"  },  // "&permil;"  },  // &#137;  #PER MILLE SIGN
    {   0x0160,  "&#0352;"  },  // "&Scaron;"  },  // &#138;  #LATIN CAPITAL LETTER S WITH CARON
    {   0x2039,  "&#8249;"  },  // "&lsaquo;"  },  // &#139;  #SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    {   0x0152,  "&#0338;"  },  // "&OElig;"   },  // &#140;  #LATIN CAPITAL LIGATURE OE
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#141;  #UNDEFINED
    {   0x017D,  "&#0381;"  },  // "&;"        },  // &#142;  #LATIN CAPITAL LETTER Z WITH CARON, ***no name entity defined in HTML 4.0***
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#143;  #UNDEFINED
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#144;  #UNDEFINED
    {   0x2018,  "&#8216;"  },  // "&lsquo;"   },  // &#145;  #LEFT SINGLE QUOTATION MARK
    {   0x2019,  "&#8217;"  },  // "&rsquo;"   },  // &#146;  #RIGHT SINGLE QUOTATION MARK
    {   0x201C,  "&#8220;"  },  // "&ldquo;"   },  // &#147;  #LEFT DOUBLE QUOTATION MARK
    {   0x201D,  "&#8221;"  },  // "&rdquo;"   },  // &#148;  #RIGHT DOUBLE QUOTATION MARK
    {   0x2022,  "&#8226;"  },  // "&bull;"    },  // &#149;  #BULLET
    {   0x2013,  "&#8211;"  },  // "&ndash;"   },  // &#150;  #EN DASH
    {   0x2014,  "&#8212;"  },  // "&mdash;"   },  // &#151;  #EM DASH
    {   0x20DC,  "&#0732;"  },  // "&tilde;"   },  // &#152;  #SMALL TILDE
    {   0x2122,  "&#8482;"  },  // "&trade;"   },  // &#153;  #TRADE MARK SIGN
    {   0x0161,  "&#0353;"  },  // "&scaron;"  },  // &#154;  #LATIN SMALL LETTER S WITH CARON
    {   0x203A,  "&#8250;"  },  // "&rsaquo;"  },  // &#155;  #SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    {   0x0153,  "&#0339;"  },  // "&oelig;"   },  // &#156;  #LATIN SMALL LIGATURE OE
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#157;  #UNDEFINED
    {   0x017E,  "&#0382;"  },  // "&;"        },  // &#158;  #LATIN SMALL LETTER Z WITH CARON, ***no name entity defined in HTML 4.0***
    {   0x0178,  "&#0376;"  },  // "&Yuml;"    },  // &#159;  #LATIN CAPITAL LETTER Y WITH DIAERESIS
};
#endif


HRESULT WINAPI DoConvertINetString(LPDWORD lpdwMode, BOOL fInbound, UINT uCodePage, int nCodeSet, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize);


/******************************************************************************
*****************************   U T I L I T I E S   ***************************
******************************************************************************/
void DataByteSwap(LPSTR DataBuf, int len )
{
    int i ;
    UCHAR tmpData ;

    if ( len )
        for ( i = 0 ; i < len-1 ; i+=2 )
        {
            tmpData = DataBuf[i] ;
            DataBuf[i] = DataBuf[i+1] ;
            DataBuf[i+1] = tmpData ;
        }

    return ;
}

void CheckUnicodeDataType(DWORD dwDstEncoding, LPSTR DataBuf, int len )
{
    
    if ( DataBuf && len )
    {
        if ( dwDstEncoding == CP_UCS_2_BE )
            DataByteSwap(DataBuf,len);
    }
    return ;
}

/******************************************************************************
******************   C O N V E R T   I N E T   S T R I N G   ******************
******************************************************************************/
HRESULT CICharConverter::UnicodeToMultiByteEncoding(DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{

    int nBuffSize, i ;
    BOOL UseDefChar = FALSE ;
    LPSTR lpDefFallBack = NULL ;
    UCHAR DefaultCharBuff[3]; // possible DBCS + null    
    HRESULT hr = E_FAIL;
    int _nDstSize = *lpnDstSize;    

    if ( _dwUnicodeEncoding == CP_UCS_2_BE && _cvt_count == 0 )
    {
       if ( _lpUnicodeStr = (LPSTR)LocalAlloc(LPTR, *lpnSrcSize ) )
       {
          MoveMemory(_lpUnicodeStr, lpSrcStr, *lpnSrcSize ) ;
          lpSrcStr = _lpUnicodeStr ;
       }
       else
       {
          hr = E_OUTOFMEMORY;
          goto EXIT;
       }
    }

    CheckUnicodeDataType(_dwUnicodeEncoding, (LPSTR) lpSrcStr, *lpnSrcSize);
    
    nBuffSize = *lpnSrcSize / sizeof(WCHAR);

    // We force to use MLang NO_BEST_FIT_CHAR check on ISCII encoding since system don't accept default chars
    if (IS_NLS_DLL_CP(dwDstEncoding) && (dwFlag & MLCONVCHARF_USEDEFCHAR))
        dwFlag |= MLCONVCHARF_NOBESTFITCHARS;

    if ( lpFallBack && ( dwFlag & MLCONVCHARF_USEDEFCHAR ))
    {
        // only take SBCS, no DBCS character
        if ( 1 == WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                               (LPCWSTR)lpFallBack, 1,
                               (LPSTR)DefaultCharBuff, sizeof(DefaultCharBuff), NULL, NULL ))
            lpDefFallBack = (LPSTR) DefaultCharBuff;        
    }

    if(!(*lpnDstSize = WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                                           (LPCWSTR)lpSrcStr, nBuffSize,
                                           lpDstStr, *lpnDstSize, IS_NLS_DLL_CP(dwDstEncoding)? NULL:(LPCSTR)lpDefFallBack, IS_NLS_DLL_CP(dwDstEncoding)? NULL:&UseDefChar)))
    {
        hr = E_FAIL;
        goto EXIT;
    }

    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = nBuffSize * sizeof(WCHAR);

    if (*lpnDstSize)
    {
        if (dwFlag & ( MLCONVCHARF_NCR_ENTITIZE | MLCONVCHARF_NAME_ENTITIZE | MLCONVCHARF_NOBESTFITCHARS ))
        {
            char    *lpDstStrTmp = lpDstStr;
            WCHAR   *lpwStrTmp = NULL;
            WCHAR   *lpwStrTmpSave = NULL;
            char    *lpDstStrTmp2 = NULL;
            char    *lpDstStrTmp2Save = NULL;
            int     cCount, ConvCount = 0, nCount = 0;
            WCHAR   *lpwSrcStrTmp = (WCHAR *)lpSrcStr;
            int     *lpBCharOffset = NULL;
            int     *lpBCharOffsetSave = NULL;

            if (!(lpwStrTmpSave = lpwStrTmp = (WCHAR *)LocalAlloc(LPTR, *lpnSrcSize)))
            {
                hr = E_OUTOFMEMORY;
                goto ENTITIZE_DONE;
            }

            // Make sure we have real converted buffer to check BEST_FIT_CHAR and DEFAULT_CHAR
            if (!_nDstSize)
            {
                lpDstStrTmp2Save = lpDstStrTmp2 = (char *)LocalAlloc(LPTR, *lpnDstSize);
                if (lpDstStrTmp2)
                {
                    WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                               (LPCWSTR)lpSrcStr, nBuffSize,
                               lpDstStrTmp2, *lpnDstSize, NULL, NULL );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto ENTITIZE_DONE;
                }
            }

            if (nBuffSize == 
                MultiByteToWideChar(MAPUSERDEF(dwDstEncoding), 0, _nDstSize? lpDstStr : lpDstStrTmp2, *lpnDstSize, lpwStrTmp, _nSrcSize))
            {
                // Pre scan to get number of best fit chars.
                for (i=0; i<nBuffSize; i++)
                {
                    // make special case for ?(yen sign) in Shift-JIS
                    if (*lpwStrTmp++ != *lpwSrcStrTmp++)
                    {
                        if ((dwDstEncoding == CP_JPN_SJ) && (*(lpwSrcStrTmp - 1) == 0x00A5))
                            *(lpwStrTmp - 1) = 0x00A5;
                        else
                            nCount ++;
                    }
                }

                lpwSrcStrTmp -= nBuffSize;
                lpwStrTmp -= nBuffSize;

                if (nCount)
                {
                    int j = 0;

                    if (!(dwFlag & ( MLCONVCHARF_NCR_ENTITIZE | MLCONVCHARF_NAME_ENTITIZE | MLCONVCHARF_USEDEFCHAR)))
                    {
                        hr = E_FAIL;
                        goto ENTITIZE_DONE;
                    }

                    if (!(lpBCharOffsetSave = lpBCharOffset = (int *) LocalAlloc(LPTR, nCount*sizeof(int))))
                    {
                        hr = E_OUTOFMEMORY;
                        goto ENTITIZE_DONE;
                    }

                    // Record the offset position of each best fit char.
                    for (i=0; i<nBuffSize; i++)
                    {
                        if (*lpwStrTmp++ != *lpwSrcStrTmp++)
                        {
                            *lpBCharOffset = i-j;
                            lpBCharOffset++;
                            j = i+1;
                        }
                    }

                    lpBCharOffset -= nCount;
                    lpwSrcStrTmp -= nBuffSize;
                    lpwStrTmp -= nBuffSize;

                    for (i=0; i<nCount; i++)
                    {
                        BOOL bIsSurrogatePair = FALSE;

                        if (*lpBCharOffset)
                        {
                            cCount = WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                                   (LPCWSTR)lpwSrcStrTmp, *lpBCharOffset,
                                   lpDstStrTmp,  _nDstSize? _nDstSize-ConvCount : 0, NULL, NULL );

                            ConvCount += cCount;
                            if (_nDstSize)
                            {
                                lpDstStrTmp += cCount;
                            }
                            lpwSrcStrTmp += *lpBCharOffset;
                        }

                        BOOL fConverted = FALSE;

                        // check if unconvertable character falls in NAME ENTITY area
                        if (dwFlag & MLCONVCHARF_NAME_ENTITIZE)
                        {
                            // for beta2, make assmption that name entity implys NCR.
                            dwFlag |= MLCONVCHARF_NCR_ENTITIZE;

#ifdef MORE_NAME_ENTITY   // in case we decide do more name entity latter
                            BOOL      fDoNEnty = FALSE;
                            LPCTSTR   lpszNEnty = NULL;

                            // check if character is in the Latin-1 Supplement range
                            if ((*lpwSrcStrTmp >= NAME_ENTITY_OFFSET) && (*lpwSrcStrTmp <= NAME_ENTITY_MAX ))
                            {
                                fDoNEnty = TRUE;
                                lpszNEnty = g_lpstrNameEntity[(*lpwSrcStrTmp) - NAME_ENTITY_OFFSET];
                            }

                            // check if character is in the additional name entity table for CP 1252 extension
                            if (!fDoNEnty)
                            {
                                for (int idx = 0; idx < ARRAYSIZE(aNameEntityExt); idx++)
                                    if (*lpwSrcStrTmp == aNameEntityExt[idx].uwUniCode)
                                    {
                                        fDoNEnty = TRUE;
                                        lpszNEnty = aNameEntityExt[idx].lpszNameEntity;
                                        break;
                                    }
                            }

                            if (fDoNEnty)
                            {
                                cCount = lstrlenA(lpszNEnty);
                                if (_nDstSize)
                                {
                                    CopyMemory(lpDstStrTmp, lpszNEnty, cCount);
                                    lpDstStrTmp += cCount ;
                                }

                                ConvCount += cCount;
                                fConverted = TRUE;
                            }
#else
                            // check if character is in the Latin-1 Supplement range
                            if ((*lpwSrcStrTmp >= NAME_ENTITY_OFFSET)
                                && (*lpwSrcStrTmp < ARRAYSIZE(g_lpstrNameEntity)+NAME_ENTITY_OFFSET))
                                
                            {
                                LPCTSTR   lpszNEnty = NULL;

                                if (!(lpszNEnty = g_lpstrNameEntity[(*lpwSrcStrTmp) - NAME_ENTITY_OFFSET]))
                                {
#ifdef DEBUG
                                    AssertMsg((BOOL)FALSE, "Name entity table broken"); 
#endif
                                    hr = E_FAIL;
                                    goto ENTITIZE_DONE;
                                }

                                    cCount = lstrlenA(lpszNEnty);
                                    if (_nDstSize)
                                    {
                                        CopyMemory(lpDstStrTmp, lpszNEnty, cCount);
                                        lpDstStrTmp += cCount ;
                                    }
                                
                                ConvCount += cCount;
                                fConverted = TRUE;
                            }
#endif
                        }

                        // check if NCR requested
                        if ((!fConverted) && (dwFlag & MLCONVCHARF_NCR_ENTITIZE))
                        {
                            if ((nCount-i >= 2) &&
                                (*lpwSrcStrTmp >= 0xD800 && *lpwSrcStrTmp <= 0xDBFF) &&
                                (*(lpwSrcStrTmp+1) >= 0xDC00 && *(lpwSrcStrTmp+1) <= 0xDFFF))
                                bIsSurrogatePair = TRUE;
                            else
                                bIsSurrogatePair = FALSE;
                          
                            if (_nDstSize)
                            {
                                lpDstStrTmp[0] = '&' ;
                                lpDstStrTmp[1] = '#' ;
                                lpDstStrTmp += 2 ;
                                // If it is a Unicode surrogates pair, we convert it to real Unicode value
                                if (bIsSurrogatePair)
                                {
                                    DWORD dwUnicode = ((*lpwSrcStrTmp - 0xD800) << 10) + *(lpwSrcStrTmp+1) - 0xDC00 + 0x10000;
                                    _ultoa( dwUnicode, (char*)lpDstStrTmp, 10);
                                }
                                else
                                    _ultoa( *lpwSrcStrTmp, (char*)lpDstStrTmp, 10);
                                cCount = lstrlenA(lpDstStrTmp);
                                lpDstStrTmp += cCount;
                                ConvCount += cCount;
                                *(lpDstStrTmp++) = ';' ;
                            }
                            else
                            {
                                char szTmpString[10];
                                if (bIsSurrogatePair)
                                {
                                    DWORD dwUnicode = ((*lpwSrcStrTmp - 0xD800) << 10) + *(lpwSrcStrTmp+1) - 0xDC00 + 0x10000;
                                    _ultoa( dwUnicode, szTmpString, 10);
                                }
                                else
                                    _ultoa( *lpwSrcStrTmp, szTmpString, 10);
                                ConvCount += lstrlenA(szTmpString);
                            }
                        
                            fConverted = TRUE;
                            ConvCount += 3;                    
                        }

                        // handle MLCONVCHARF_USEDEFCHAR here - less priority and default method
                        if (!fConverted)
                        {
                            if (_nDstSize)
                            {
                                *lpDstStrTmp = lpDefFallBack ? *lpDefFallBack : '?';
                                lpDstStrTmp++;
                            }

                            ConvCount++;
                            if (!UseDefChar)
                                UseDefChar = TRUE;
                        }

                        lpBCharOffset++;
                        lpwSrcStrTmp++;
                        // Skip next character if it is a Unicode surrogates pair
                        if (bIsSurrogatePair)
                        {
                            lpBCharOffset++;
                            lpwSrcStrTmp++;
                            i++;
                        }
                    }
                    lpBCharOffset -= nCount ;
                }

                int nRemain = (*lpnSrcSize - (int)((char*)lpwSrcStrTmp - (char *)lpSrcStr))/sizeof(WCHAR);

                ConvCount += WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                                   (LPCWSTR)lpwSrcStrTmp, nRemain,
                                   lpDstStrTmp, _nDstSize? _nDstSize-ConvCount : 0, NULL, NULL );

                *lpnDstSize = ConvCount ;

                hr = S_OK;
            } 
            else
            {
                hr = E_FAIL;
            }

ENTITIZE_DONE:
            if (lpwStrTmpSave)
                LocalFree(lpwStrTmpSave);
            if (lpDstStrTmp2Save)
                LocalFree(lpDstStrTmp2Save);
            if (lpBCharOffsetSave)
                LocalFree(lpBCharOffsetSave);
        }
        else
        {
            hr = S_OK;
        }       

        if (S_OK == hr && UseDefChar)
            hr = S_FALSE;
    }
    else
    {
        hr = E_FAIL;
    }

EXIT:
    return hr;
}

HRESULT CICharConverter::UTF78ToUnicode(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{
    HRESULT hr ;

    hr = DoConvertINetString(lpdwMode, TRUE, CP_UCS_2, _dwUTFEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);

    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = *lpnSrcSize ;

    CheckUnicodeDataType(_dwUnicodeEncoding, lpDstStr, *lpnDstSize);

    return hr ;
}

HRESULT CICharConverter::UnicodeToUTF78(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{
    HRESULT hr ;

    if ( _dwUnicodeEncoding == CP_UCS_2_BE && _cvt_count == 0 )
    {
       if ( _lpUnicodeStr = (LPSTR)LocalAlloc(LPTR, *lpnSrcSize ) )
       {
          MoveMemory(_lpUnicodeStr, lpSrcStr, *lpnSrcSize ) ;
          lpSrcStr = _lpUnicodeStr ;
       }
       else
        return E_OUTOFMEMORY ;
    }

    CheckUnicodeDataType(_dwUnicodeEncoding, (LPSTR) lpSrcStr, *lpnSrcSize);

    hr = DoConvertINetString(lpdwMode, FALSE, CP_UCS_2, _dwUTFEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);
    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = *lpnSrcSize ;


    return hr ;
}

HRESULT CICharConverter::UnicodeToWindowsCodePage(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    hr = UnicodeToMultiByteEncoding(_dwWinCodePage,lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize,dwFlag,lpFallBack);

    return hr ;
}

HRESULT CICharConverter::UnicodeToInternetEncoding(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    hr = UnicodeToMultiByteEncoding(_dwInternetEncoding,lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize,dwFlag,lpFallBack);

    return hr ;
}

HRESULT CICharConverter::InternetEncodingToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{
    int cch = 0 ;
    int cb = *lpnSrcSize;

    if ( !_cvt_count )
    {
        // If we have a multibyte character encoding, we are at risk of splitting
        // some characters at the read boundary.  We must Make sure we have a
        // discrete number of characters first.

        UINT uMax = MAX_CHAR_SIZE ;
        cb++; // pre-increment
        do
        {
            cch = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding),
                                        MB_ERR_INVALID_CHARS | MB_PRECOMPOSED,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!cch && uMax && cb);
    }

    if ( cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value

    *lpnDstSize = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding), 0,
                               lpSrcStr, cb,
                               (LPWSTR)lpDstStr, *lpnDstSize/sizeof(WCHAR) );
    *lpnDstSize = *lpnDstSize * sizeof(WCHAR);
    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = cb ;

    CheckUnicodeDataType(_dwUnicodeEncoding, lpDstStr, *lpnDstSize);

    if (*lpnDstSize==0 && (cb || cb != *lpnSrcSize))
        return E_FAIL ;
    else
        return S_OK ;
}

HRESULT CICharConverter::WindowsCodePageToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{

    int cch = 0 ;
    int cb = *lpnSrcSize;

    if ( !_cvt_count )
    {
        UINT uMax = MAX_CHAR_SIZE ;
        cb++; // pre-increment
        do
        {
            cch = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                        MB_ERR_INVALID_CHARS | MB_PRECOMPOSED,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!cch && uMax && cb);
    }

    if ( cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value

    *lpnDstSize = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage), 0,
                               lpSrcStr, cb,
                               (LPWSTR)lpDstStr, *lpnDstSize/sizeof(WCHAR) );
    *lpnDstSize = *lpnDstSize * sizeof(WCHAR);
    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = cb ;

    CheckUnicodeDataType(_dwUnicodeEncoding, lpDstStr, *lpnDstSize);
    
    // Whistler Bug#360429, 
    // Web page could have a splitting DBCS character at the very end of the page,
    // To work around it, we allow one byte of dangling DBCS character.
    if (*lpnDstSize==0 && (cb || (cb != *lpnSrcSize && ++cb != *lpnSrcSize)))
        return E_FAIL ;
    else
        return S_OK ;
}

HRESULT CICharConverter::WindowsCodePageToInternetEncoding(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    // check if the conversion should go through Unicode indirectly
    if ( _dwConvertType & 0x10 )
        hr = WindowsCodePageToInternetEncodingWrap(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
    else
    {

        hr = DoConvertINetString(lpdwMode, FALSE, _dwWinCodePage, _dwInternetEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = *lpnSrcSize ;
    }
    return hr ;
}

HRESULT CICharConverter::InternetEncodingToWindowsCodePage(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    // check if the conversion should go through Unicode indirectly
    if ( _dwConvertType & 0x10 )
        hr = InternetEncodingToWindowsCodePageWrap(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
    else
    {
        hr = DoConvertINetString(lpdwMode, TRUE, _dwWinCodePage, _dwInternetEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = *lpnSrcSize ;
    }
    return hr ;
}

HRESULT CICharConverter::WindowsCodePageToInternetEncodingWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    int nBuffSize = 0 ;
    int cb = *lpnSrcSize;
    UINT uMax = MAX_CHAR_SIZE ;
    BOOL UseDefChar = FALSE ;
    HRESULT hr = S_OK;

    if ( !_cvt_count )
    {
        cb++; // pre-increment
        do
        {
            nBuffSize = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                        MB_ERR_INVALID_CHARS | MB_PRECOMPOSED,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!nBuffSize && uMax && cb);
    }

    if ( cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value

    if (!nBuffSize)  // in case there are illeage characters
        nBuffSize = cb ;

    if ( _lpInterm1Str = (LPSTR) LocalAlloc(LPTR, (nBuffSize * sizeof(WCHAR))))
    {
        nBuffSize = MultiByteToWideChar(MAPUSERDEF(_dwWinCodePage), 0,
                        lpSrcStr, cb, (LPWSTR)_lpInterm1Str, nBuffSize );

        int iSrcSizeTmp = nBuffSize * sizeof(WCHAR);
        hr = UnicodeToMultiByteEncoding(MAPUSERDEF(_dwInternetEncoding), (LPCSTR)_lpInterm1Str, &iSrcSizeTmp,
                                        lpDstStr, lpnDstSize, dwFlag, lpFallBack);
//        *lpnDstSize = WideCharToMultiByte( MAPUSERDEF(_dwInternetEncoding), 0,
//                        (LPCWSTR)_lpInterm1Str, nBuffSize, lpDstStr, *lpnDstSize, NULL, &UseDefChar );

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = cb ;
    }
    else        
        hr = E_FAIL;

    if (hr == S_OK)
    {
        if (*lpnDstSize==0 && cb)
            hr = E_FAIL ;
        else 
        {
            if ( UseDefChar )
                return S_FALSE ;
            else
                return S_OK ;
        }
    }

    return hr;
}

HRESULT CICharConverter::InternetEncodingToWindowsCodePageWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{

    int nBuffSize = 0 ;
    int cb = *lpnSrcSize;
    UINT uMax = MAX_CHAR_SIZE ;
    BOOL UseDefChar = FALSE ;
    HRESULT hr = S_OK;

    if ( !_cvt_count )
    {
        cb++; // pre-increment
        do
        {
            nBuffSize = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding),
                                        MB_ERR_INVALID_CHARS | MB_PRECOMPOSED,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!nBuffSize && uMax && cb);
    }

    if ( cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value

    if (!nBuffSize)  // in case there are illeage characters
        nBuffSize = cb ;

    if ( _lpInterm1Str = (LPSTR) LocalAlloc(LPTR,nBuffSize * sizeof (WCHAR) ))
    {
        nBuffSize = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding), 0,
                        lpSrcStr, cb, (LPWSTR)_lpInterm1Str, nBuffSize );

        int iSrcSizeTmp = nBuffSize * sizeof(WCHAR);
        hr = UnicodeToMultiByteEncoding(MAPUSERDEF(_dwWinCodePage), (LPCSTR)_lpInterm1Str, &iSrcSizeTmp,
                                        lpDstStr, lpnDstSize, dwFlag, lpFallBack);
//        *lpnDstSize = WideCharToMultiByte( MAPUSERDEF(_dwWinCodePage), 0,
//                        (LPCWSTR)_lpInterm1Str, nBuffSize, lpDstStr, *lpnDstSize, NULL, &UseDefChar );

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = cb ;
    }
    else
        hr = E_FAIL;

    if (hr == S_OK)
    {
        if (*lpnDstSize==0 && cb)
            hr = E_FAIL ;
        else 
        {
            if ( UseDefChar )
                return S_FALSE ;
            else
                return S_OK ;
        }
    }

    return hr;
}

HRESULT CICharConverter::ConvertIWUU(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    int nBuffSize = 0 ;
    HRESULT hr = S_OK ;
    HRESULT hrWarnings = S_OK ;

    // InternetEncodingToWindowsCodePage
    if ( _dwConvertType % 2 && _dwConvertType < 21 ) /* start from Internet Encoding */
    {
        if ( _dwConvertType == 5 || _dwConvertType == 9 ) /* use interm buffer */
        {
            hr = InternetEncodingToWindowsCodePage(lpdwMode, lpSrcStr, lpnSrcSize, NULL, &nBuffSize, dwFlag, lpFallBack);
            if ( _lpInterm1Str = (LPSTR) LocalAlloc(LPTR,nBuffSize) )
            {
                hr = InternetEncodingToWindowsCodePage(lpdwMode, lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize, dwFlag, lpFallBack);
                lpSrcStr = _lpInterm1Str ;
                *lpnSrcSize = nBuffSize ;
            }
            else
                goto fail ;
        }
        else
            hr = InternetEncodingToWindowsCodePage(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;
        
    // WindowsCodePageToUnicode or InternetEncodingToUnicode
    if ( _dwConvertType == 21 || _dwConvertType == 25 )
    {
        if ( _dwConvertType == 21 )
            hr = InternetEncodingToUnicode(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
        else // _dwConvertType == 25 
        {
            hr = InternetEncodingToUnicode(lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
            {
                hr = InternetEncodingToUnicode(lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);
                lpSrcStr = _lpInterm1Str ;
                *lpnSrcSize = nBuffSize ;
            }
            else
                goto fail ;
        }
        _cvt_count ++ ;
    }
    else if ( _dwConvertType >= 4 && _dwConvertType <= 10 )
    {
        if ( _dwConvertType > 8 )
        {
            nBuffSize = 0 ;
            hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if ( _cvt_count )
            {
                if ( _lpInterm2Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, _lpInterm2Str, &nBuffSize);
                    lpSrcStr = _lpInterm2Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;

            }
            else
            {
                if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);
                    lpSrcStr = _lpInterm1Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;
            }
        }
        else
            hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;

    // UnicodeToUTF78
    if ( _dwConvertType & 0x08 )
#ifndef UNIX
        hr = UnicodeToUTF78(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
#else
        {
        /* we now hack the lpSrcStr to be the same as 2 byte Unicode so mlang
         * lowlevel code can work right.
         */
        LPWSTR lpwSrcStr = (LPWSTR)lpSrcStr;
        INT tmpSize = *lpnSrcSize/sizeof(WCHAR);
        UCHAR *pTmp = new UCHAR[(tmpSize+1)*2];
        if(pTmp) {
            for(int i = 0; i < tmpSize; i++) {
                pTmp[i*2] = *lpwSrcStr++;
                pTmp[i*2+1] = 0x00;
            }
            pTmp[i*2] = pTmp[i*2+1] = 0x00;
            tmpSize *= 2;
            hr = UnicodeToUTF78(lpdwMode, (LPCSTR)pTmp, &tmpSize, lpDstStr, lpnDstSize);
        }
        else
            hr = E_FAIL;
        delete [] pTmp;
        }
#endif /* UNIX */

    return ( hr == S_OK ? hrWarnings : hr ) ;

fail :
    return E_FAIL ;
}

HRESULT CICharConverter::ConvertUUWI(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    int nBuffSize = 0 ;
    HRESULT hr = S_OK ;
    HRESULT hrWarnings = S_OK ;

    // UTF78ToUnicode
    if ( _dwConvertType & 0x08 )
    {
        if ( _dwConvertType == 12 ) /* convert UTF78 -> Unicode only */
            hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
        else /* use interm buffer, type = 10 or 9 */
        {
            hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
            {
                hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);
                lpSrcStr = _lpInterm1Str ;
                *lpnSrcSize = nBuffSize ;
            }
            else
                goto fail ;
        }
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;

    // UnicodeToWindowsCodePage or UnicodeToInternetEncoding
    if ( _dwConvertType == 21 || _dwConvertType == 25 )
    {
        hr = UnicodeToInternetEncoding(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
        _cvt_count ++ ;
    }
    else if ( _dwConvertType >= 4 && _dwConvertType <= 10 )
    {
        if ( _dwConvertType % 2 ) /* use interm buffer */
        {
            nBuffSize = 0 ;
            hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, NULL, &nBuffSize, dwFlag, lpFallBack);
            if ( _cvt_count )
            {
                if ( _lpInterm2Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, _lpInterm2Str, &nBuffSize, dwFlag, lpFallBack);
                    lpSrcStr = _lpInterm2Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;
            }
            else
            {
                if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize, dwFlag, lpFallBack);
                    lpSrcStr = _lpInterm1Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;
            }
        }
        else
            hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;

    // WindowsCodePageToInternetEncoding
    if ( _dwConvertType % 2 && _dwConvertType < 21 )
        hr = WindowsCodePageToInternetEncoding(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);

    return ( hr == S_OK ? hrWarnings : hr ) ;

fail :
    return E_FAIL ;
}

#if 0
struct CODEPAGEINFO
{
    UINT        uCodePage ;
    CP_STATE    nCP_State ;    // whether this is a valid windows codepage  ?
};

// ValidCodepageInfo is used to cache whether a codepage is a vaild code
// It uses circular-FIFO cache algorithm
#define MAX_CP_CACHE    32
static int cp_cache_count = 0 ;
static int cp_cache_ptr = 0 ;
static struct CODEPAGEINFO ValidCodepageInfo[MAX_CP_CACHE];

// ValidCodepageInfo is used to cache whether a codepage is a vaild codepage
// It uses circular-FIFO cache algorithm

BOOL CheckIsValidCodePage (UINT uCodePage)
{
    if ( uCodePage == 50000 ) // User defined
        return TRUE ;

    int i ;
    BOOL bRet ;

    for ( i = 0 ; i < cp_cache_count ; i++ )
    {
        if ( uCodePage == ValidCodepageInfo[i].uCodePage )
        {
            if ( ValidCodepageInfo[i].nCP_State == VALID_CP )
                return TRUE ;
            else
                return FALSE ;
        }
    }

    // not found, call IsValidCodePage and cache the return value
    bRet = IsValidCodePage(uCodePage);

    EnterCriticalSection(&g_cs);
    ValidCodepageInfo[cp_cache_ptr].uCodePage = uCodePage ;
    if (bRet)
        ValidCodepageInfo[cp_cache_ptr].nCP_State = VALID_CP ;
    else
        ValidCodepageInfo[cp_cache_ptr].nCP_State = INVALID_CP ;
    if ( cp_cache_count < MAX_CP_CACHE )
        cp_cache_count++ ;
    cp_cache_ptr = ( ++cp_cache_ptr ) % MAX_CP_CACHE ;
    LeaveCriticalSection(&g_cs);

    return bRet ;
}
#endif

/*
    Conversion Flag:

    Bit 7 - Convert Direction.

    Bit 4 (16) - Unicode <-> Internet Encoding
    Bit 3 (8) - UTF8, UTF7
    Bit 2 (4) - Unicode
    Bit 1 (2) - Windows CodePage
    Bit 0 (1) - Internet Encoding

    12, 6, 3 (19) - one step convert
    10, 5 (21)  - two steps convert
    9 (25) - three steps convert

*/

int GetWindowsEncodingIndex(DWORD dwEncoding)
{
    int nr = sizeof (aEncodingInfo) / sizeof(ENCODINGINFO) ;
    int i, half = nr / 2, index = -1 ;

    if (aEncodingInfo[half].dwEncoding > dwEncoding )
    {
        for ( i = 0 ; i < half ; i++ )
            if (aEncodingInfo[i].dwEncoding == dwEncoding )
                index = i ;

    }
    else if (aEncodingInfo[half].dwEncoding < dwEncoding )
    {
        for ( i = half + 1 ; i < nr ; i++ )
            if (aEncodingInfo[i].dwEncoding == dwEncoding )
                index = i ;
    }
    else
        index = half ;

    if (index>=0) // found
    {
        if ( aEncodingInfo[index].nCP_State != VALID_CP &&
                aEncodingInfo[index].dwCodePage )
        {

            if ( aEncodingInfo[index].dwCodePage == 50000 || IsValidCodePage(aEncodingInfo[index].dwCodePage ) ) // 50000 means user defined
                aEncodingInfo[index].nCP_State = VALID_CP ;
            else
                aEncodingInfo[index].nCP_State = INVALID_CP ;

            if ((aEncodingInfo[index].nCP_State == VALID_CP) &&
                (aEncodingInfo[index].dwFlags & CONV_CHK_NLS) &&
                !IsValidCodePage(aEncodingInfo[index].dwEncoding))
                aEncodingInfo[index].nCP_State = INVALID_CP ;
        }
    }

    return index ;
}

HRESULT CICharConverter::ConvertSetup(DWORD * pdwSrcEncoding, DWORD dwDstEncoding)
{
    DWORD SrcFlag = 0, DstFlag = 0 ;
    int index, unknown = 0 ;
    // IE bug 109708 - WEIWU 5/11/00
    // Always consider US-ASCII as a valid source encoding for conversion
/*
    if (*pdwSrcEncoding == CP_20127 && !IsValidCodePage(CP_20127))
    	*pdwSrcEncoding = CP_1252;
*/    	
    /* check source & destination encoding type */
    index = GetWindowsEncodingIndex(*pdwSrcEncoding);
    if ( index >=0 )
    {
        SrcFlag = (DWORD) aEncodingInfo[index].bTypeUUIW ;
        if ( aEncodingInfo[index].dwCodePage )
        {
            _dwWinCodePage = (DWORD) aEncodingInfo[index].dwCodePage ;
            if (aEncodingInfo[index].nCP_State == INVALID_CP )
                goto fail ;
        }
        if ( SrcFlag & 0x08 )
            _dwUTFEncoding = *pdwSrcEncoding ;
        if ( SrcFlag & 0x01 )
            _dwInternetEncoding = *pdwSrcEncoding ;
        if ( SrcFlag & 0x04 )
            _dwUnicodeEncoding = *pdwSrcEncoding ;
    }
    // assume it is a unknown Window Codepage
    else
    {
        if ( !CONVERT_IS_VALIDCODEPAGE(*pdwSrcEncoding))
            goto fail ;

        SrcFlag = 0x02 ;
        _dwWinCodePage = *pdwSrcEncoding ;

        unknown ++ ;
    }

    index = GetWindowsEncodingIndex(dwDstEncoding);
    if ( index >=0 )
    {
        // check if two codepages are compatiable
        if ( _dwWinCodePage && aEncodingInfo[index].dwCodePage )
        {
            if (_dwWinCodePage != (DWORD) aEncodingInfo[index].dwCodePage )
                goto fail ;
        }
        DstFlag = (DWORD) aEncodingInfo[index].bTypeUUIW ;
        if ( aEncodingInfo[index].dwCodePage )
        {
            _dwWinCodePage = (DWORD) aEncodingInfo[index].dwCodePage ;
            if (aEncodingInfo[index].nCP_State == INVALID_CP )
                goto fail ;
        }
        if ( DstFlag & 0x08 )
        {
            if (_dwUTFEncoding)
                _dwUTFEncoding2 = dwDstEncoding ;
            else
                _dwUTFEncoding = dwDstEncoding ;
        }
        if ( DstFlag & 0x01 )
            _dwInternetEncoding = dwDstEncoding ;
        if ( DstFlag & 0x04 )
            _dwUnicodeEncoding = dwDstEncoding ;
    }
    // 1) First time unknown, assume it is a unknown Window Codepage
    //    the conversion become UTF78 <-> Unicode <-> Window Codepage
    // 2) Second time unknown, assume it is a unknown Internet Encoding
    //    the conversion become Windows Codepage <-> Unicode <-> Internet Encoding
    else
    {
        if ( !CONVERT_IS_VALIDCODEPAGE(dwDstEncoding))
            goto fail ;

        if ( unknown == 0 )
        {
            if ( _dwWinCodePage )
            {
                if (_dwWinCodePage != dwDstEncoding )
                    goto fail ;
            }

            DstFlag = 0x02 ;
            _dwWinCodePage = dwDstEncoding ;
        }
        else
        {
            DstFlag = 0x11 ;
            _dwInternetEncoding = dwDstEncoding ;
        }
    }

    if ( !SrcFlag | !DstFlag )
        goto fail ;

    if ( SrcFlag == DstFlag && *pdwSrcEncoding != dwDstEncoding && ( 4 != SrcFlag ) && ( 8 != SrcFlag ))
        goto fail ;

    _dwConvertType = SrcFlag | DstFlag ;

    _bConvertDirt = ( SrcFlag & 0x0f ) > ( DstFlag & 0x0f )  ;

    // if code convertor has been allocated, deallocate it
    if (_hcins)
    {
        delete _hcins ;
        _hcins = NULL ;
    }

    return S_OK ;

fail :
    return S_FALSE ;
}


HRESULT CICharConverter::DoCodeConvert(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr = S_OK ;

    if ( 4 == _dwConvertType ) // CP_UCS_2 <-> CP_UCS_2_BE 
    {
        if (!lpDstStr)
        {   
            _nSrcSize = *lpnDstSize = *lpnSrcSize ;
        }
        else
        {
            int nSize = min(*lpnDstSize,*lpnSrcSize);

            _nSrcSize = *lpnSrcSize ;
            if ( lpDstStr && nSize > 0 )
            {
                MoveMemory(lpDstStr, lpSrcStr, nSize );
                DataByteSwap(lpDstStr, nSize );
                _nSrcSize = nSize ;
                *lpnDstSize = nSize ;
            }
        }
    }
    else if ( 8 == _dwConvertType) // UTF7 <-> UTF8
    {
        if (_dwUTFEncoding == _dwUTFEncoding2)
        {
            _nSrcSize = *lpnDstSize = min(*lpnDstSize,*lpnSrcSize);
            if (*lpnDstSize > 0)
                MoveMemory(lpDstStr, lpSrcStr, *lpnDstSize);
        }
        else
        {
            int nBuffSize = 0;
            // Always succeeds
            hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if (_lpInterm1Str)
                LocalFree(_lpInterm1Str);
            if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
            {            
                DWORD dwTmpEncoding = _dwUTFEncoding;
                int nTmpSrcSize;

                hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);                
                _dwUTFEncoding = _dwUTFEncoding2 ;
                nTmpSrcSize = _nSrcSize;
                // We don't need to create another dwMode since only UTF7 conversion needs it
                hr = UnicodeToUTF78(lpdwMode, _lpInterm1Str, &nBuffSize, lpDstStr, lpnDstSize);
                _nSrcSize = nTmpSrcSize;
                _dwUTFEncoding = dwTmpEncoding ;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }		
    else if ( _bConvertDirt )
        hr = ConvertUUWI(lpdwMode, lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize, dwFlag, lpFallBack);
    else
        hr = ConvertIWUU(lpdwMode, lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize, dwFlag, lpFallBack);

    return hr ;
}

BOOL CICharConverter::ConvertCleanUp()
{
    if (_lpInterm1Str)
    {
         LocalFree(_lpInterm1Str);
         _lpInterm1Str = NULL ;
    }
    if (_lpInterm2Str)
    {
         LocalFree(_lpInterm2Str);
         _lpInterm2Str = NULL ;
    }
    if (_lpUnicodeStr)
    {
         LocalFree(_lpUnicodeStr);
         _lpUnicodeStr = NULL ;
    }
    _cvt_count = 0 ;
    _nSrcSize = 0 ;

    return TRUE ;
}

CICharConverter::CICharConverter()
{
    _lpInterm1Str = NULL ;
    _lpInterm2Str = NULL ;
    _lpUnicodeStr = NULL ;
    _hcins = NULL ;
    _cvt_count = 0 ;
    _dwWinCodePage = 0;
    _dwInternetEncoding = 0;
    _dwUTFEncoding = 0;
    _dwUTFEncoding2 = 0;
    _dwUnicodeEncoding = 0;
    _dwConvertType = 0;
    _nSrcSize = 0 ;
    _hcins_dst = 0 ;

    return ;
}

CICharConverter::CICharConverter(DWORD dwFlag, WCHAR *lpFallBack)
{
    _lpInterm1Str = NULL ;
    _lpInterm2Str = NULL ;
    _lpUnicodeStr = NULL ;
    _hcins = NULL ;
    _cvt_count = 0 ;
    _dwWinCodePage = 0;
    _dwInternetEncoding = 0;
    _dwUTFEncoding = 0;
    _dwUTFEncoding2 = 0;
    _dwUnicodeEncoding = 0;
    _dwConvertType = 0;
    _nSrcSize = 0 ;
    _hcins_dst = 0 ;
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;

    return ;
}


CICharConverter::~CICharConverter()
{
    if (_lpInterm1Str)
    {
         LocalFree(_lpInterm1Str);
         _lpInterm1Str = NULL ;
    }
    if (_lpInterm2Str)
    {
         LocalFree(_lpInterm2Str);
         _lpInterm2Str = NULL ;
    }
    if (_lpUnicodeStr)
    {
         LocalFree(_lpUnicodeStr);
         _lpUnicodeStr = NULL ;
    }
    if (_hcins)
    {
        delete _hcins ;
        _hcins = NULL ;
    }
}

CICharConverter::CICharConverter(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    _lpInterm1Str = NULL ;
    _lpInterm2Str = NULL ;
    _lpUnicodeStr = NULL ;
    _hcins = NULL ;
    _cvt_count = 0 ;
    _dwWinCodePage = 0;
    _dwInternetEncoding = 0;
    _dwUTFEncoding = 0;
    _dwUTFEncoding2 = 0;
    _dwUnicodeEncoding = 0;
    _dwConvertType = 0;
    _nSrcSize = 0 ;
    _hcins_dst = 0 ;
    
    ConvertSetup(&dwSrcEncoding,dwDstEncoding);
    return ;
}

HRESULT WINAPI IsConvertINetStringAvailable(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    HRESULT hr;
    CICharConverter * INetConvert = new CICharConverter ;

    if (!INetConvert)
        return E_OUTOFMEMORY;

    hr = INetConvert->ConvertSetup(&dwSrcEncoding, dwDstEncoding);
    delete INetConvert;

    return hr ;
}

#define DETECTION_BUFFER_NUM    3


// In CP_AUTO and detection result is UTF7 case, private converter might use high word of *lpdwMode to store internal data, but we need 
// to use it to notify Trident the detection result, currently, we bias to returning correct detection result.
// This is currently by design. If we get a change to re-prototype conversion object, we can resovle this issue
HRESULT WINAPI ConvertINetStringEx(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    CICharConverter * INetConvert;
    int nSrcSize;
    int nDstSize;
    DWORD   dwMode = 0 ;
    // dwDetectResult 
    // CP_UNDEFINED :Fail to detect
    //      0       :Not a auto-detect scenario
    // Others       :Detected encoding
    DWORD   dwDetectResult = CP_UNDEFINED;
    HRESULT hr ;

    if(lpnSrcSize)
    {
        nSrcSize = *lpnSrcSize;
    }
    else
        nSrcSize = -1;

    if ( lpSrcStr && nSrcSize == -1 ) // Get length of lpSrcStr if not given, assuming lpSrcStr is a zero terminate string.
    {
        if ( dwSrcEncoding == CP_UCS_2 )
            nSrcSize = (lstrlenW((WCHAR*)lpSrcStr) << 1) ;
        else
            nSrcSize = lstrlenA(lpSrcStr) ;
    }

    // If there is nothing need to be converted, we return S_OK;
    if (!nSrcSize || !lpSrcStr)
    {
        if (lpnDstSize)
           *lpnDstSize = 0;
        return S_OK;
    }

    INetConvert = new CICharConverter(dwFlag, lpFallBack) ;    

    if (!INetConvert)
        return E_OUTOFMEMORY;

    // ASSERT(CP_AUTO != dwDstEncoding);

    // if null specified at dst buffer we'll get the size of required buffer.
    if(!lpDstStr)
        nDstSize = 0;
    else if (lpnDstSize)
        nDstSize = *lpnDstSize;
    else 
        nDstSize = 0;

    if (lpdwMode)
        dwMode = *lpdwMode ;

    // In real world, clients uses 28591 as 1252, 28599 as 1254, 
    // To correctly convert those extended characters to Unicode,
    // We internally replace it with 1252 
    if (dwDstEncoding == CP_UCS_2 || dwDstEncoding == CP_UCS_2_BE)
    {
        if ((dwSrcEncoding == CP_ISO_8859_1) && _IsValidCodePage(CP_1252))
            dwSrcEncoding = CP_1252;

        if ((dwSrcEncoding == CP_ISO_8859_9) && _IsValidCodePage(CP_1254))
            dwSrcEncoding = CP_1254;
    }

    if ((dwDstEncoding == CP_1252) && (dwSrcEncoding == CP_ISO_8859_1))
    {
        dwSrcEncoding = CP_1252;
    }

    if ((dwDstEncoding == CP_1254) && (dwSrcEncoding == CP_ISO_8859_9))
    {
        dwSrcEncoding = CP_1254;
    }

    //
    // Auto Detection for Japan
    // Japanese user often tag their data incorrectly, so, if MLCONVCHARF_DETECTJPN specified, 
    // we'll do extra detection for Shift-Jis and EUC
    //
    if ( dwSrcEncoding == CP_JP_AUTO ||                                 
        ((dwFlag & MLCONVCHARF_DETECTJPN) && 
        (dwSrcEncoding == CP_JPN_SJ || dwSrcEncoding == CP_EUC_JP))) // Auto Detection for Japan
    {        
        CIncdJapanese DetectJapan(dwSrcEncoding);
        UINT uiCodePage ;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
        {
            dwSrcEncoding = uiCodePage ;
            dwDetectResult = 0;
        }
        else
        {
            dwSrcEncoding = DetectJapan.DetectStringA(lpSrcStr, nSrcSize);
            // if dwSrcEncoding is zero means there is an ambiguity, we don't return
            // the detected codepage to caller, instead we defaut its codepage internally
            // to SJIS
            if (dwSrcEncoding)
            {
                dwDetectResult = dwSrcEncoding << 16 ;
            }
            else
                dwSrcEncoding = CP_JPN_SJ;
        }
    }
    // bug #43190, we auto-detect again for euc-kr page because IMN ver 1.0
    // mislabel an ISO-KR page as a ks_c_5601-1987 page. This is the only way 
    // we can fix that mistake. 
    else if ( dwSrcEncoding == CP_KR_AUTO || dwSrcEncoding == CP_KOR_5601 ||
        dwSrcEncoding == CP_EUC_KR )
    {
        CIncdKorean DetectKorean;
        UINT uiCodePage ;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
        {
            dwSrcEncoding = uiCodePage ;
            dwDetectResult = 0;
        }
        else
        {
            dwSrcEncoding = DetectKorean.DetectStringA(lpSrcStr, nSrcSize);
            if (dwSrcEncoding)
            {
                dwDetectResult = dwSrcEncoding << 16 ;
            }
            else
                dwSrcEncoding = CP_KOR_5601;
        }

    }
    else if ( dwSrcEncoding == CP_AUTO ) // General Auto Detection for all code pages
    {
        int _nSrcSize = DETECTION_MAX_LEN < nSrcSize ?  DETECTION_MAX_LEN : nSrcSize;
        int nScores = DETECTION_BUFFER_NUM;
        DetectEncodingInfo Encoding[DETECTION_BUFFER_NUM];
        UINT uiCodePage ;


        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
        {
            dwSrcEncoding = uiCodePage ;
            dwDetectResult = 0;
        }
        else
        {
            dwSrcEncoding = g_uACP;
            if ( S_OK == _DetectInputCodepage(MLDETECTCP_HTML, CP_AUTO, (char *)lpSrcStr, &_nSrcSize, &Encoding[0], &nScores))
            {
                MIMECPINFO cpInfo;

                if (Encoding[0].nCodePage == CP_20127)
                    Encoding[0].nCodePage = dwSrcEncoding;

                if (NULL != g_pMimeDatabase)
                {
                    if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(Encoding[0].nCodePage, 0x409, &cpInfo)) && 
                        (cpInfo.dwFlags & MIMECONTF_VALID))
                    {
                        dwSrcEncoding = Encoding[0].nCodePage;     
                        dwDetectResult = dwSrcEncoding << 16 ;  
                    }
                }
            }

            // If we failed in general detection and system locale is Jpn, we try harder 
            // with our Japanese detection engine
            if (dwSrcEncoding == CP_JPN_SJ && dwDetectResult == CP_UNDEFINED)
            {
                CIncdJapanese DetectJapan;
                DWORD dwSrcEncodingJpn = DetectJapan.DetectStringA(lpSrcStr, nSrcSize);
                if (dwSrcEncodingJpn)
                {
                    // We only change conversion encoding without returnning this result to browser 
                    // if it is in the middle of detection, this is to prevent other encodings been mis-detected as Jpn encodings.
                    dwSrcEncoding = dwSrcEncodingJpn;   
                    
                    // Set search range for end tag as 10 bytes
                    if (nSrcSize >= 10)
                    {
                        char szTmpStr[11] = {0};
                        char *lpTmpStr = szTmpStr;
                        MLStrCpyN(szTmpStr, (char *)&lpSrcStr[nSrcSize-10], 10);                        

                        //ToLower
                        while(*lpTmpStr)
                        {
                            if (*lpTmpStr >= 'A' && *lpTmpStr <= 'W')
                                *lpTmpStr += 0x20;
                            lpTmpStr++;
                        }

                        // If end of page, return this result
                        if (MLStrStr(szTmpStr, "</html>"))
                            dwDetectResult = dwSrcEncoding << 16 ;  
                    }

                }
            }
            //aEncodingInfo[GetWindowsEncodingIndex(CP_AUTO)].dwCodePage = dwSrcEncoding;         
        }     
    }
    else
    {
        // Not a auto-detect scenario
        dwDetectResult = 0;
    }

    if ( S_OK == ( hr = INetConvert->ConvertSetup(&dwSrcEncoding,dwDstEncoding )))
    {
       if ( dwSrcEncoding != dwDstEncoding )
       {
            // if high word of dwMode is CP_UTF_7, it must be detection result, don't pass it to UTF7 converter
            if ( dwSrcEncoding == CP_UTF_7 && (dwMode >> 16) == CP_UTF_7)
                dwMode &= 0xFFFF;
            // ASSERT(!((IS_ENCODED_ENCODING(dwSrcEncoding) || IS_ENCODED_ENCODING(dwDstEncoding)) && (NULL == lpdwMode)));
            hr = INetConvert->DoCodeConvert(&dwMode, lpSrcStr, &nSrcSize, lpDstStr, &nDstSize, dwFlag, lpFallBack);

            // return the number of bytes processed for the source. 
            if (lpnSrcSize)
                *lpnSrcSize = INetConvert->_nSrcSize ;
            INetConvert->ConvertCleanUp();
       }
       else
       {
            int nSize, i ;
            hr = S_OK ;
            BOOL bLeadByte = FALSE ;

            // only check for windows codepage
            if ( INetConvert->_dwConvertType == 02 && lpSrcStr )
            { 
                for ( i=0; i<nSrcSize; i++)
                {
                   if (bLeadByte)
                       bLeadByte = FALSE ;
                   else if (IsDBCSLeadByteEx(dwSrcEncoding,lpSrcStr[i]))
                       bLeadByte = TRUE ;
                }
                if (bLeadByte)
                    nSrcSize-- ;
            }
            // set input size
            if (lpnSrcSize)
                *lpnSrcSize = nSrcSize ;
            // set output size and copy if we need to
            if (lpDstStr && *lpnDstSize)
            {
                nSize = min(*lpnDstSize,nSrcSize);
                MoveMemory(lpDstStr, lpSrcStr, nSize);
                nDstSize = nSize ;
            }
            else
                nDstSize = nSrcSize ;
       }
    }
    else
            nDstSize = 0 ;

    delete INetConvert;

    // return the number of bytes copied for the destination,
    if (lpnDstSize)
        *lpnDstSize = nDstSize;

    if (lpdwMode && lpDstStr)
    {        
        if (dwDetectResult)                     // CP_AUTO conversion
        {
            dwMode &= 0xFFFF;                   // Clear HIGHWORD in case private converter set it
            // If we have detection result, return it in HIGHWORD
            // in the case of UTF7 conversion, private converter might use high word to store internal data,
            // this will conflict with our logic of returning detection result in high word, it is a design flaw, 
            // currently, we ignore conversion setting and give detection result more priority
            if (dwDetectResult != CP_UNDEFINED) 
                dwMode |= dwDetectResult;
        }
        *lpdwMode = dwMode ;
    }

    return hr ;
}

// We already published this API, keep it for backward compatibility
HRESULT WINAPI ConvertINetReset(void)
{
    // Always suceed
    return S_OK ;
}

HRESULT WINAPI ConvertINetMultiByteToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;
    int nByteCountSize = 0;

    if (lpnWideCharCount)
    {
        nByteCountSize = *lpnWideCharCount * sizeof(WCHAR);
    }

#ifdef UNIX
   int saved_nByteCountSize = nByteCountSize;
#endif /* UNIX */

    hr = ConvertINetStringEx(lpdwMode,dwEncoding, CP_UCS_2, lpSrcStr, lpnMultiCharCount, (LPSTR)lpDstStr, &nByteCountSize, dwFlag, lpFallBack) ;

#ifdef UNIX
    if(dwEncoding == 1200 || dwEncoding == 65000 || dwEncoding == 65001 ||
       (dwEncoding == 50001 && !_IsValidCodePage(dwEncoding)) )
    {
        /*
         * On unix we need to convert the little endian mode 2 byte unicode
         * format to unix mode 4 byte wChars.
         */
        if(lpDstStr && (saved_nByteCountSize < (nByteCountSize/2)*sizeof(WCHAR)))
            hr = E_FAIL;
        else
        {
            /*
             * Use a temporary array to do the 2byte -> 4byte conversion
             */
            LPSTR pTmp = (LPSTR) lpDstStr;
            LPWSTR pw4 = NULL;

            if(pTmp) /* allocate only if we have a lpDstStr */
                pw4 = new WCHAR[nByteCountSize/2];
            if(pw4)
            {
                int i = 0;
                LPWSTR pw4Tmp = pw4;
                for(; i < nByteCountSize/2; i++)
                    *pw4Tmp++ = (UCHAR)pTmp[i*2];
                pw4Tmp = pw4;
                for(i = 0; i < nByteCountSize/2; i++)
                    *lpDstStr++ = *pw4Tmp++;
            }
            if(!pw4 && pTmp) /* if lpDstStr and allocate fails bail out */
                hr = E_FAIL;
            delete [] pw4;
        }
        nByteCountSize *= 2; // Expand twice as we have 4 byte wchars.
    }
#endif
    *lpnWideCharCount = nByteCountSize / sizeof(WCHAR);

    return hr ;
}


HRESULT WINAPI ConvertINetUnicodeToMultiByteEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;
    int nByteCountSize=-1;

    if(lpnWideCharCount && *lpnWideCharCount != -1) 
        nByteCountSize = *lpnWideCharCount * sizeof(WCHAR);

    hr = ConvertINetStringEx(lpdwMode,CP_UCS_2, dwEncoding, (LPCSTR) lpSrcStr, &nByteCountSize, lpDstStr, lpnMultiCharCount, dwFlag, lpFallBack);

#ifdef UNIX
    if(dwEncoding == 1200 || dwEncoding == 65000 || dwEncoding == 65001) {
        nByteCountSize *= 2; // Expand twice as we have 4 byte wchars.
    }
#endif /* UNIX */

    if (lpnWideCharCount)
        *lpnWideCharCount = nByteCountSize / sizeof(WCHAR);

    return hr ;
}

HRESULT WINAPI ConvertINetString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize)
{
    HRESULT hr ;

    hr = ConvertINetStringEx(lpdwMode,dwSrcEncoding,dwDstEncoding,lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize, 0, NULL);

    return hr ;
}

HRESULT WINAPI ConvertINetUnicodeToMultiByte(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount)
{
    HRESULT hr ;
    DWORD dwFlag = 0 ;

    if ( lpdwMode )
        dwFlag |= ( *lpdwMode & 0x00008000 ) ? MLCONVCHARF_ENTITIZE : 0 ;

    hr = ConvertINetUnicodeToMultiByteEx(lpdwMode,dwEncoding,lpSrcStr,lpnWideCharCount,lpDstStr,lpnMultiCharCount,dwFlag,NULL);

    return hr ;
}

HRESULT WINAPI ConvertINetMultiByteToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount)
{
    HRESULT hr ;

    hr = ConvertINetMultiByteToUnicodeEx(lpdwMode,dwEncoding,lpSrcStr,lpnMultiCharCount,lpDstStr,lpnWideCharCount, 0, NULL);

    return hr ;
}

#define STR_BUFFER_SIZE 2048

HRESULT _ConvertINetStringInIStream(CICharConverter * INetConvert, LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD dwFlag, WCHAR *lpFallBack)
{
    DWORD   dwMode, dwModeTemp ;
    HRESULT hr= S_OK, hrWarnings=S_OK;
    LPSTR lpstrIn = NULL, lpstrOut = NULL; 
    ULONG nSrcSize, nSrcUsed, nSrcLeft, nDstSize, _nDstSize, nOutBuffSize ;

    if (lpdwMode)
        dwMode = *lpdwMode ;

    // allocate a temp input buffer - 2K in size
    if ( (lpstrIn = (LPSTR) LocalAlloc(LPTR, STR_BUFFER_SIZE )) == NULL )
    {
        hrWarnings = E_OUTOFMEMORY ;
        goto exit;
    }

    if ( (lpstrOut = (LPSTR) LocalAlloc(LPTR, STR_BUFFER_SIZE * 2 )) == NULL )
    {
        hrWarnings = E_OUTOFMEMORY ;
        goto exit;
    }

    nOutBuffSize = STR_BUFFER_SIZE * 2 ;
    nSrcLeft = 0 ;

    // In real world, clients uses 28591 as 1252, 28599 as 1254, 
    // To correctly convert those extended characters to Unicode,
    // We internally replace it with 1252 
    if (dwDstEncoding == CP_UCS_2 || dwDstEncoding == CP_UCS_2_BE)
    {
        if ((dwSrcEncoding == CP_ISO_8859_1) && _IsValidCodePage(CP_1252))
            dwSrcEncoding = CP_1252;

        if ((dwSrcEncoding == CP_ISO_8859_9) && _IsValidCodePage(CP_1254))
            dwSrcEncoding = CP_1254;
    }

    if ((dwDstEncoding == CP_1252) && (dwSrcEncoding == CP_ISO_8859_1))
    {
        dwSrcEncoding = CP_1252;
    }

    if ((dwDstEncoding == CP_1254) && (dwSrcEncoding == CP_ISO_8859_9))
    {
        dwSrcEncoding = CP_1254;
    }


    if ( dwSrcEncoding == CP_JP_AUTO ) // Auto Detection for Japan
    {
        CIncdJapanese DetectJapan;
        UINT uiCodePage ;
        LARGE_INTEGER   li;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
            dwSrcEncoding = uiCodePage ;
        else
        {
            LISet32(li, 0);

            hr = pstmIn->Read(lpstrIn, STR_BUFFER_SIZE , &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;
            hr = pstmIn->Seek(li,STREAM_SEEK_SET, NULL);
            if (S_OK != hr)
                hrWarnings = hr;

            dwSrcEncoding = DetectJapan.DetectStringA(lpstrIn, nSrcSize);
            // if dwSrcEncoding is zero means there is an ambiguity, we don't return
            // the detected codepage to caller, instead we defaut its codepage internally
            // to SJIS
            if (dwSrcEncoding)
            {
                dwMode &= 0x0000ffff ;
                dwMode |= dwSrcEncoding << 16 ; 
            }
            else
                dwSrcEncoding = CP_JPN_SJ;
        }
    }
    // bug #43190, we auto-detect again for euc-kr page because IMN ver 1.0
    // mislabel an ISO-KR page as a ks_c_5601-1987 page. This is the only way 
    // we can fix that mistake. 
    else if ( dwSrcEncoding == CP_KR_AUTO || dwSrcEncoding == CP_KOR_5601 ||
        dwSrcEncoding == CP_EUC_KR )
    {
        CIncdKorean DetectKorean;
        UINT uiCodePage ;
        LARGE_INTEGER   li;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
            dwSrcEncoding = uiCodePage ;
        else
        {
            LISet32(li, 0);
            
            hr = pstmIn->Read(lpstrIn, STR_BUFFER_SIZE, &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;
            hr = pstmIn->Seek(li,STREAM_SEEK_SET, NULL);
            if (S_OK != hr)
                hrWarnings = hr;
            dwSrcEncoding = DetectKorean.DetectStringA(lpstrIn, nSrcSize);
            if (dwSrcEncoding)
            {
                dwMode &= 0x0000ffff ;
                dwMode |= dwSrcEncoding << 16 ; 
            }
            else
                dwSrcEncoding = CP_KOR_5601;
        }
    }
    else if ( dwSrcEncoding == CP_AUTO ) // General Auto Detection for all code pages
    {
        INT nScores = 1;
        DWORD dwSrcEncoding ;
        DetectEncodingInfo Encoding;
        UINT uiCodePage ;
        LARGE_INTEGER   li;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
            dwSrcEncoding = uiCodePage ;
        else
        {
            LISet32(li, 0);

            hr = pstmIn->Read(lpstrIn, STR_BUFFER_SIZE , &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;
            hr = pstmIn->Seek(li,STREAM_SEEK_SET, NULL);
            if (S_OK != hr)
                hrWarnings = hr;

            if (DETECTION_MAX_LEN < nSrcSize)
                nSrcSize =  DETECTION_MAX_LEN;

            if ( S_OK == _DetectInputCodepage(MLDETECTCP_HTML, 1252, lpstrIn, (int *)&nSrcSize, &Encoding, &nScores))
            {
                dwSrcEncoding = Encoding.nCodePage;
                dwMode &= 0x0000ffff ;
                dwMode |= dwSrcEncoding << 16 ; 
            }
            else
            {
                dwSrcEncoding = CP_ACP;
            }
            aEncodingInfo[GetWindowsEncodingIndex(CP_AUTO)].dwCodePage = dwSrcEncoding;
        }
    }

    if ( S_OK == ( hr = INetConvert->ConvertSetup(&dwSrcEncoding,dwDstEncoding )))
    {
        // Loop for ever
        while(1)
        {
            // Read a buffer
            hr = pstmIn->Read(&lpstrIn[nSrcLeft], STR_BUFFER_SIZE-nSrcLeft, &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;

            // Done
            if (0 == nSrcSize)
                break;

            nSrcSize += nSrcLeft ;
            nSrcUsed = nSrcSize ;
            dwModeTemp = dwMode ;
            nDstSize = 0 ;

            // get the size of output buffer
            hr = INetConvert->DoCodeConvert(&dwModeTemp, (LPCSTR)lpstrIn, (LPINT)&nSrcUsed, NULL, (LPINT)&nDstSize, dwFlag, lpFallBack);
            if (S_OK != hr)
                hrWarnings = hr;

            // Reallocate output buffer if so
            if ( nDstSize > nOutBuffSize )
            {
                LPSTR psz = (LPSTR) LocalReAlloc(lpstrOut, nDstSize, LMEM_ZEROINIT|LMEM_MOVEABLE);
                if (psz == NULL)
                {
                    hrWarnings = E_OUTOFMEMORY ;
                    goto exit;
                }
                lpstrOut = psz;
                nOutBuffSize = nDstSize ;
            }
            _nDstSize = nDstSize;

            // Due to multi_stage conversion, this is the actual size is used
            nSrcUsed = INetConvert->_nSrcSize ;
            nSrcLeft = nSrcSize - nSrcUsed ;

#if 0
            // restore Src size
            nSrcUsed = nSrcSize ;
#endif
            // do conversion
            hr = INetConvert->DoCodeConvert(&dwMode, (LPCSTR)lpstrIn, (LPINT)&nSrcUsed, lpstrOut, (LPINT)&_nDstSize, dwFlag, lpFallBack);
            if (S_OK != hr)
                hrWarnings = hr;

            // Write It
            hr = pstmOut->Write(lpstrOut, nDstSize, &nDstSize);
            if (S_OK != hr)
                hrWarnings = hr;

            if (nSrcLeft )
                MoveMemory(lpstrIn, &lpstrIn[nSrcSize-nSrcLeft],nSrcLeft);

            INetConvert->ConvertCleanUp();
        }
    }

    if (nSrcLeft )
    {
        LARGE_INTEGER   li;

        LISet32(li, -(LONG)nSrcLeft );
        hr = pstmIn->Seek(li,STREAM_SEEK_CUR, NULL);
    }

    if (lpdwMode)
        *lpdwMode = dwMode ;

exit :
    if (lpstrIn)
        LocalFree(lpstrIn);
    if (lpstrOut)
        LocalFree(lpstrOut);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}


HRESULT WINAPI ConvertINetStringInIStream(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr;
    CICharConverter * INetConvert = new CICharConverter(dwFlag, lpFallBack) ;

    if (!INetConvert)
        return E_OUTOFMEMORY;

    hr = _ConvertINetStringInIStream(INetConvert,lpdwMode,dwSrcEncoding,dwDstEncoding,pstmIn,pstmOut,dwFlag,lpFallBack);

    delete INetConvert;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\hzgbobj.h ===
#include "convbase.h"

class CInccHzGbIn : public CINetCodeConverter
{
private:
	BOOL (CInccHzGbIn::*m_pfnConv)(UCHAR tc);
	BOOL (CInccHzGbIn::*m_pfnCleanUp)();
	BOOL m_fGBMode;
	UCHAR m_tcLeadByte;
	UINT  m_nESCBytes;                     /* # bytes of ESC sequence */

public:
	CInccHzGbIn();
	CInccHzGbIn(UINT uCodePage, int nCodeSet);
	~CInccHzGbIn() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
	BOOL ConvMain(UCHAR tc);
	BOOL CleanUpMain();
	BOOL ConvTilde(UCHAR tc);
	BOOL CleanUpTilde();
	BOOL ConvDoubleByte(UCHAR tc);
	BOOL CleanUpDoubleByte();
};

class CInccHzGbOut : public CINetCodeConverter
{
private:
    BOOL    m_fDoubleByte;
    UCHAR   m_tcLeadByte;
    BOOL    m_fGBMode;
    DWORD   _dwFlag;
    WCHAR   *_lpFallBack;

public:
	CInccHzGbOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack);
	~CInccHzGbOut() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);
private:
    void Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\fechrcnv.h ===
#ifndef _FECHRCNV_H_
#define _FECHRCNV_H_

#ifdef __cplusplus
extern "C" {
#endif 

// Code Page
#define CP_JAPAN				932
#define CP_PRC					936
#define CP_KOREA				949
#define CP_TAIWAN				950

// Code Definition
#define ESC						0x1b
#define SO						0x0e
#define SI						0x0f
#define ISO2022_IN_CHAR			'$'
#define ISO2022_IN_JP_CHAR1		'B'
#define ISO2022_IN_JP_CHAR2		'@'
#define ISO2022_IN_JP_CHAR3_1	'('
#define ISO2022_IN_JP_CHAR3_2	'D'
#define ISO2022_IN_KR_CHAR_1	')'
#define ISO2022_IN_KR_CHAR_2	'C'
#define ISO2022_OUT_CHAR		'('
#define ISO2022_OUT_JP_CHAR1	'B'
#define ISO2022_OUT_JP_CHAR2	'J'
#define ISO2022_OUT_JP_CHAR3	'I' /* esc ( I - Kana mode */
#define ISO2022_OUT_JP_CHAR4	'H' /* treated as ESC ( J */

// Minimum length to determine if the string is EUC
#define MIN_JPN_DETECTLEN      48

typedef LPVOID HCINS;
typedef HCINS FAR* LPHCINS;

#ifdef __cplusplus
}
#endif 

#endif  // _FECHRCNV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\ichrcnv.h ===
#ifndef ICHRCNV_H_
#define ICHRCNV_H_

#define MAXOVERFLOWCHARS 16


class CICharConverter
{
private:

    DWORD _dwWinCodePage;
    DWORD _dwInternetEncoding;
    DWORD _dwUTFEncoding;
    DWORD _dwUTFEncoding2;
    DWORD _dwUnicodeEncoding;
    DWORD _dwFlag;  
    WCHAR * _lpFallBack;

    BOOL  _bConvertDirt;

    LPSTR _lpUnicodeStr;
    LPSTR _lpInterm1Str;
    LPSTR _lpInterm2Str;

    HCINS _hcins;
    int   _hcins_dst;
    int   _cvt_count;


public:
	DWORD _dwConvertType;
	LPSTR _lpDstStr;
	LPSTR _lpSrcStr;
	int _nSrcSize;

	CICharConverter();
   	CICharConverter(DWORD dwFlag, WCHAR *lpFallBack);
	CICharConverter(DWORD dwSrcEncoding, DWORD dwDstEncoding);
	~CICharConverter();
	HRESULT ConvertSetup(DWORD * pdwSrcEncoding, DWORD dwDstEncoding);
	HRESULT DoCodeConvert(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
		 LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
	BOOL ConvertCleanUp();

private:
    HRESULT ConvertUUWI(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT ConvertIWUU(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT UnicodeToMultiByteEncoding(DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT UTF78ToUnicode(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT UnicodeToUTF78(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT UnicodeToWindowsCodePage(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT UnicodeToInternetEncoding(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT WindowsCodePageToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT InternetEncodingToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT WindowsCodePageToInternetEncoding(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT InternetEncodingToWindowsCodePage(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT WindowsCodePageToInternetEncodingWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT InternetEncodingToWindowsCodePageWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);

    HRESULT CreateINetString(BOOL fInbound, UINT uCodePage, int nCodeSet);
    HRESULT DoConvertINetString(LPDWORD lpdwMode, BOOL fInbound, UINT uCodePage, int nCodeSet,
      LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize);

    HRESULT KSC5601ToEUCKR(LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize);
protected:

};

HRESULT WINAPI _IStreamConvertINetString(CICharConverter * INetConvert, LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD *pdwProperty);

#endif /* ICHRCNV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\jislex.cpp ===
/*----------------------------------------------------------------------------
	%%File: jislex.c
	%%Unit: fechmap
	%%Contact: jpick

	Simple converter for decoding a subset of possible ISO-2022-7 encoded
	files (ISO-2022).  Data is translated to and from Unicode.  Converter
	operates according to user options.
	
	Module currently handles ISO-2022-JP (and JIS) and ISO-2022-KR.  
	
	Converter is set up to handle ISO-2022-TW and ISO-2022-CN, but there
	are as yet no conversion tables for these.
----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stddef.h>

#include "private.h"
#include "fechmap_.h"
#include "lexint_.h"


// State table for reading ISO-2022-7 encoded text
//
// Lexer recognizes the following designator sequences, used 
// to select a one or two byte character set:
//
//    <esc> $ @				-- JIS C 6626-1978	(synonym of <esc> $ ( @)
//    <esc> $ A				-- GB 2312-80		(synonym of <esc> $ ( A)
//    <esc> $ B				-- JIS X 0208-1983	(synonym of <esc> $ ( B)
//
//    <esc> $ ( @			-- JIS C 6626-1978
//    <esc> $ ( A			-- GB 2312-80
//    <esc> $ ( B			-- JIS X 0208-1983
//    <esc> $ ( C			-- KS C 5601-1992
//    <esc> $ ( D			-- JIS X 0212-1990
//    <esc> $ ( E			-- ??? (ISO-IR-165:1992) ???
//    <esc> $ ( G			-- CNS 11643-1992 Plane 1
//    <esc> $ ( H			-- CNS 11643-1992 Plane 2
//    <esc> $ ( I			-- CNS 11643-1992 Plane 3
//    <esc> $ ( J			-- CNS 11643-1992 Plane 4
//    <esc> $ ( K			-- CNS 11643-1992 Plane 5
//    <esc> $ ( L			-- CNS 11643-1992 Plane 6
//    <esc> $ ( M			-- CNS 11643-1992 Plane 7
//
//    <esc> $ ) C			-- KSC 5601-1987 (Implies ISO-2022-KR ??)
//
//    <esc> & @ <esc> $ B	-- JIS X 0208-1990
//
//    <esc> ( B 			-- Ascii
//    <esc> ( H 			-- Deprecated variant of JIS-Roman
//    <esc> ( I 			-- Half-Width Katakana
//    <esc> ( J 			-- JIS-Roman
//    <esc> ( T 			-- GB 1988-89 Roman
//
// Lexer recognizes the following shift sequences, used to allow
// interpretation of a given byte or bytes:
//
//    <si>					-- locking shift, interpret bytes as G0
//    <so>					-- locking shift, interpret bytes as G1
//    <esc> n				-- locking shift, interpret bytes as G2
//    <esc> o				-- locking shift, interpret bytes as G3
//    <esc> N				-- single shift, interpret bytes as G2
//    <esc> O				-- single shift, interpret bytes as G3
//
// REVIEW (jpick): don't currently need the final four shift
//   sequences.  If we support ISO-2022-CN, we'll need to use
//   G2 and G3 and potentially, then, the last four shifts.
//

/*----------------------------------------------------------------------------
	Character Classification Table
----------------------------------------------------------------------------*/

// Tokens
//
#define	txt			(JTK) 0
#define	ext			(JTK) 1		// extended characters that are legal under certain circumstances
#define	esc			(JTK) 2
#define	si			(JTK) 3
#define	so			(JTK) 4
#define	dlr			(JTK) 5
#define	at			(JTK) 6
#define	amp			(JTK) 7
#define	opr			(JTK) 8
#define	cpr			(JTK) 9
#define	tkA			(JTK) 10
#define	tkB			(JTK) 11
#define	tkC			(JTK) 12
#define	tkD			(JTK) 13
#define	tkE			(JTK) 14
#define	tkG			(JTK) 15
#define	tkH			(JTK) 16
#define	tkI			(JTK) 17
#define	tkJ			(JTK) 18
#define	tkK			(JTK) 19
#define	tkL			(JTK) 20
#define	tkM			(JTK) 21
#define	tkT			(JTK) 22
#define	unk			(JTK) 23	// Unexpected character
#define	eof			(JTK) 24	// end-of-file
#define	err			(JTK) 25	// read error

#define nTokens		26

// Lookup table for ISO-2022-7 encoded files
//
static JTK _rgjtkCharClass[256] =
//  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    {
//  nul  soh  stx  etx  eot  enq  ack  bel  bs   tab  lf   vt   np   cr   so   si		0
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, so,  si, 

//  dle  dc1  dc2  dc3  dc4  nak  syn  etb  can  em   eof  esc  fs   gs   rs   us		1
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, esc, txt, txt, txt, txt, 

//  sp   !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /		2
    txt, txt, txt, txt, dlr, txt, amp, txt, opr, cpr, txt, txt, txt, txt, txt, txt, 

//  0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?		3
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//  @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O		4
    at,  tkA, tkB, tkC, tkD, tkE, txt, tkG, tkH, tkI, tkJ, tkK, tkL, tkM, txt, txt, 

//  P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _		5
    txt, txt, txt, txt, tkT, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//  `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o		6
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//  p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~    del		7
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//																		                8
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//																		                9
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//																		                a
    unk, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//																		                b
    ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//																		                c
    ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//																		                d
    ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//																		                e
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//																		                f
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
};


/*----------------------------------------------------------------------------
	State Table
----------------------------------------------------------------------------*/

// Final states have the high-bit set.  States that represent the reading
// of a valid character escape sequence also encode the character set
// "name" (moniker??) -- the state with the high bit masked off.
//
// Table State
//
typedef unsigned char TST;

// Final State Mask, Related
//
#define grfFinal 							(TST) 0x80
#define _NEscTypeFromState(nState)			(int) ((nState) & 0x7f)

// ASCII Escape Sequence (Final State)
#define ASC		(TST) (grfFinal | 0x00)		// Ascii

// Japanese Escape Sequences (Final States)
#define JS0		(TST) (grfFinal | 0x01)		// JIS-Roman
#define JS1		(TST) (grfFinal | 0x02)		// Half-Width Katakana
#define JS2 	(TST) (grfFinal | 0x03)		// JIS C 6226-1978
#define JS3		(TST) (grfFinal | 0x04)		// JIS X 0208-1983
#define JS4		(TST) (grfFinal | 0x05)		// JIS X 0208-1990
#define JS5		(TST) (grfFinal | 0x06)		// JIS X 0212-1990

// Chinese (PRC) Escape Sequences (Final States)
#define CS0		(TST) (grfFinal | 0x07)		// GB 1988-89 Roman
#define CS1		(TST) (grfFinal | 0x08)		// GB 2312-80

// Chinese (Taiwan) Escape Sequences (Final States)
#define TS0		(TST) (grfFinal | 0x09)		// CNS 11643-1992 Plane 1
#define TS1		(TST) (grfFinal | 0x0a)		// CNS 11643-1992 Plane 2
#define TS2		(TST) (grfFinal | 0x0b)		// CNS 11643-1992 Plane 3
#define TS3		(TST) (grfFinal | 0x0c)		// CNS 11643-1992 Plane 4
#define TS4		(TST) (grfFinal | 0x0d)		// CNS 11643-1992 Plane 5
#define TS5		(TST) (grfFinal | 0x0e)		// CNS 11643-1992 Plane 6
#define TS6		(TST) (grfFinal | 0x0f)		// CNS 11643-1992 Plane 7

// Korean Escape Sequences (Final State)
#define KS0		(TST) (grfFinal | 0x10)		// KS C 5601-1992

// Document "Signal" for ISO-2022-KR (Doc needs special processing)
#define KSD		(TST) (grfFinal | 0x11)		// ISO-2022-KR Document Signal

// Number of unique *character set* escape sequences
//
#define cCsEsc	18

// Special States (not escape sequence) (Final States)
//
#define TXT		(TST) (grfFinal | (cCsEsc + 1))		// Process Text
#define EXT		(TST) (grfFinal | (cCsEsc + 2))		// Process (Possibly Illegal) Extended Chars
#define FIN		(TST) (grfFinal | (cCsEsc + 3))		// Finish
#define EOI		(TST) (grfFinal | (cCsEsc + 4))		// Unexpected End-Of-Input
#define UNK		(TST) (grfFinal | (cCsEsc + 5))		// Unknown State (Unexpected Character)
#define ERR		(TST) (grfFinal | (cCsEsc + 6))		// Read Error

// Shift Sequences (do not specify character set) (Final States)
//
#define LSO		(TST) (grfFinal | (cCsEsc + 7))		// Locking shift out (g1 into GL)
#define LSI		(TST) (grfFinal | (cCsEsc + 8))		// Locking shift in (g0 into GL)

// For convenience, also define constants for the sets
// that the states represent.
//
#define csNIL		(-1)							// Invalid Designator
#define csASC		(_NEscTypeFromState(ASC))		// Ascii
#define csJS0		(_NEscTypeFromState(JS0))		// JIS-Roman
#define csJS1		(_NEscTypeFromState(JS1))		// Half-Width Katakana
#define csJS2		(_NEscTypeFromState(JS2))		// JIS C 6226-1978
#define csJS3		(_NEscTypeFromState(JS3))		// JIS X 0208-1983
#define csJS4		(_NEscTypeFromState(JS4))		// JIS X 0208-1990
#define csJS5		(_NEscTypeFromState(JS5))		// JIS X 0212-1990
#define csCS0		(_NEscTypeFromState(CS0))		// GB 1988-89 Roman
#define csCS1		(_NEscTypeFromState(CS1))		// GB 2312-80
#define csTS0		(_NEscTypeFromState(TS0))		// CNS 11643-1992 Plane 1
#define csTS1		(_NEscTypeFromState(TS1))		// CNS 11643-1992 Plane 2
#define csTS2		(_NEscTypeFromState(TS2))		// CNS 11643-1992 Plane 3
#define csTS3		(_NEscTypeFromState(TS3))		// CNS 11643-1992 Plane 4
#define csTS4		(_NEscTypeFromState(TS4))		// CNS 11643-1992 Plane 5
#define csTS5		(_NEscTypeFromState(TS5))		// CNS 11643-1992 Plane 6
#define csTS6		(_NEscTypeFromState(TS6))		// CNS 11643-1992 Plane 7
#define csKS0		(_NEscTypeFromState(KS0))		// KS C 5601-1992 (into G0)
#define csKSD		(_NEscTypeFromState(KSD))		// KS C 5601-1992 (into G1)

// Table States (Intermediate States)
#define ST0		(TST)  0
#define ST1		(TST)  1
#define ST2		(TST)  2
#define ST3		(TST)  3
#define ST4		(TST)  4
#define ST5		(TST)  5
#define ST6		(TST)  6
#define ST7		(TST)  7
#define ST8		(TST)  8
#define ST9		(TST)  9

// Number of "real" (table) states
//
#define nStates		10

#define	IsFinal(state)	((state) & grfFinal)


// State	Have Seen				Looking For
// ----------------------------------------------------------
// ST0		-- Start State --		<ESC> Text
// ST1		<ESC>					$ & (
// ST2		<ESC> $					( ) @ A B   (**)
// ST3		<ESC> $ (				@ A B C D E G H I J K L M
// ST4		<ESC> $ )				C
// ST5		<ESC> &					@
// ST6		<ESC> & @				<ESC>
// ST7		<ESC> & @ <ESC>			$
// ST8		<ESC> & @ <ESC> $		B
// ST9		<ESC> (					B H I J T
//
// (**)  "<ESC> $ ID" is a synonym of "<ESC> $ ( ID" for ID=(@, A, B)
//
// Because of the large number of tokens, this table is
// inverted (tokens x states).
//
static signed char _rgchNextState[nTokens][nStates] =
{
//
//           S     S     S     S     S     S     S     S     S     S 
//           T     T     T     T     T     T     T     T     T     T  
//           0     1     2     3     4     5     6     7     8     9   
//--------------------------------------------------------------------
//
/* txt */  TXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* ext */  EXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* esc */  ST1,  UNK,  UNK,  UNK,  UNK,  UNK,  ST7,  UNK,  UNK,  UNK,
/* si  */  LSI,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* so  */  LSO,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* $   */  TXT,  ST2,  UNK,  UNK,  UNK,  UNK,  UNK,  ST8,  UNK,  UNK,
/* @   */  TXT,  UNK,  JS2,  JS2,  UNK,  ST6,  UNK,  UNK,  UNK,  UNK,
/* &   */  TXT,  ST5,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* (   */  TXT,  ST9,  ST3,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* )   */  TXT,  UNK,  ST4,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* A   */  TXT,  UNK,  CS1,  CS1,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* B   */  TXT,  UNK,  JS3,  JS3,  UNK,  UNK,  UNK,  UNK,  JS4,  ASC,
/* C   */  TXT,  UNK,  UNK,  KS0,  KSD,  UNK,  UNK,  UNK,  UNK,  UNK,
/* D   */  TXT,  UNK,  UNK,  JS5,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* E   */  TXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* G   */  TXT,  UNK,  UNK,  TS0,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* H   */  TXT,  UNK,  UNK,  TS1,  UNK,  UNK,  UNK,  UNK,  UNK,  JS0,
/* I   */  TXT,  UNK,  UNK,  TS2,  UNK,  UNK,  UNK,  UNK,  UNK,  JS1,
/* J   */  TXT,  UNK,  UNK,  TS3,  UNK,  UNK,  UNK,  UNK,  UNK,  JS0,
/* K   */  TXT,  UNK,  UNK,  TS4,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* L   */  TXT,  UNK,  UNK,  TS5,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* M   */  TXT,  UNK,  UNK,  TS6,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* T   */  TXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  CS0,
/* unk */  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* eof */  FIN,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,
/* err */  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
};


// Also for ISO-2022 out.  Build arrays of possible character
// sets for each type of input character set.  Character sets
// should appear in order of hit probability (e.g., in 2022-Jp
// JS3 is the most common set).  Mark the end of array with -1.
// (Only store these for non-ascii sets).
//
//
// China (icetIso2022Cn)
static int _rgceCn[] = { -1, };

// Japan (icetIso2022Jp)
static int _rgceJp[] = { csJS3, csJS1, csJS5, -1, };

// Korea (icetIso2022Kr)
static int _rgceKr[] = { -1, };

// Taiwan (icetIso2022Tw)
static int _rgceTw[] = { -1, };

static int *_mpicetrgce[icetCount] =
	{
	0,				// icetEucCn
	0,				// icetEucJp
	0,				// icetEucKr
	0,				// icetEucTw
	_rgceCn,		// icetIso2022Cn
	_rgceJp,		// icetIso2022Jp
	_rgceKr,		// icetIso2022Kr
	_rgceTw,		// icetIso2022Tw
	0,				// icetBig5
	0,				// icetGbk
	0,				// icetShiftJis
	0,				// icetWansung
	0,				// icetUtf8
	};

/* _ J T K  G E T  N E X T */
/*----------------------------------------------------------------------------
	%%Function: _JtkGetNext
	%%Contact: jpick

	Get the next character and classify it.  Return the token.
----------------------------------------------------------------------------*/
static JTK __inline _JtkGetNext(IStream *pstmIn, PUCHAR puch)
{
	ULONG rc;
    HRESULT hr;
		  
    hr = pstmIn->Read(puch, 1, &rc);
	
	if (hr != S_OK )
		return err;
	else if (rc == 0)
		return eof;
	else
		return _rgjtkCharClass[*puch];
}

/* C C E  R E A D  E S C  S E Q */
/*----------------------------------------------------------------------------
	%%Function: CceReadEscSeq
	%%Contact: jpick

	Read pointer is positioned at an escape sequence, figure out
	which escape sequence it is.
----------------------------------------------------------------------------*/
CCE CceReadEscSeq(IStream *pstmIn, ICET *lpicet)
{
    UCHAR uch;
	TST tstCurr;
	JTK jtk;
	CCE cceRet;
#ifdef DEBUG
	TST tstPrev;
#endif

	// Sanity checks ...
	//
#ifdef DEBUG
	if (!pstmIn || !lpicet)
		return cceInvalidParameter;
#endif
		
	tstCurr = ST0;

	while (1)
		{
		// Find the next stopping state.
		//
		do
			{
			// Get the next character and clasify it.
			//
			jtk = _JtkGetNext(pstmIn, &uch);
				
#ifdef DEBUG
			// Save the previous state for debugging purposes, only.
			//
			tstPrev = tstCurr;
#endif
			// Transition -- note that order is different than
			// "normal" transition tables.
			//
			tstCurr = _rgchNextState[jtk][tstCurr];
		
			} while (!IsFinal(tstCurr));
		
		switch (tstCurr)
			{
			case JS0:			// JIS-Roman
			case JS1:			// Half-Width Katakana
			case JS2:			// JIS C 6226-1978
			case JS3:			// JIS X 0208-1983
			case JS4:			// JIS X 0208-1990
			case JS5:			// JIS X 0212-1990
				*lpicet = icetIso2022Jp;
				cceRet = cceSuccess;
				goto _LRet;
			case CS0:			// GB 1988-89 Roman
			case CS1:			// GB 2312-80
				*lpicet = icetIso2022Cn;
				cceRet = cceSuccess;
				goto _LRet;
			case TS0:			// CNS 11643-1992 Plane 1
			case TS1:			// CNS 11643-1992 Plane 2
			case TS2:			// CNS 11643-1992 Plane 3
			case TS3:			// CNS 11643-1992 Plane 4
			case TS4:			// CNS 11643-1992 Plane 5
			case TS5:			// CNS 11643-1992 Plane 6
			case TS6:			// CNS 11643-1992 Plane 7
				*lpicet = icetIso2022Tw;
				cceRet = cceSuccess;
				goto _LRet;
			case KS0:			// KS C 5601-1992
			case KSD:			// ISO-2022-KR Document Signal
				*lpicet = icetIso2022Kr;
				cceRet = cceSuccess;
				goto _LRet;
			case ASC:			// Ascii
			case LSO:
			case LSI:
			case TXT:
			case EXT:
			case FIN:
				// Insufficient information to choose a flavor ...
				cceRet = cceMayBeAscii;
				goto _LRet;
			case ERR:
				cceRet = cceRead;
				goto _LRet;
			default:			// UNK, EOI
				cceRet = cceUnknownInput;
				goto _LRet;
			}
		}
		
_LRet:

	return cceRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\init.cpp ===
#include "private.h"
#include "mlmain.h"
#include "mlstr.h"
#include "convobj.h"
#include "cpdetect.h"
#ifdef NEWMLSTR
#include "attrstrw.h"
#include "attrstra.h"
#include "attrloc.h"
#include "util.h"
#endif
#define DECL_CRTFREE
#include <crtfree.h>

#define _WINDLL
#include <atlimpl.cpp>

#include <shlwapi.h>    // for IsOS() flags

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CMultiLanguage, CMultiLanguage)
    OBJECT_ENTRY(CLSID_CMLangString, CMLStr)
    OBJECT_ENTRY(CLSID_CMLangConvertCharset, CMLangConvertCharset)
#ifdef NEWMLSTR
    OBJECT_ENTRY(CLSID_CMLStrAttrWStr, CMLStrAttrWStr)
    OBJECT_ENTRY(CLSID_CMLStrAttrAStr, CMLStrAttrAStr)
    OBJECT_ENTRY(CLSID_CMLStrAttrLocale, CMLStrAttrLocale)
#endif
END_OBJECT_MAP()

//
//  Globals
//
HINSTANCE   g_hInst = NULL;
HINSTANCE   g_hUrlMon = NULL;
CRITICAL_SECTION g_cs;
CComModule _Module;
#ifdef NEWMLSTR
CMLAlloc* g_pMalloc;
#endif
BOOL g_bIsNT5;
BOOL g_bIsNT;
BOOL g_bIsWin98;
UINT g_uACP;
//
//  Build Global Objects
//
void BuildGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("BuildGlobalObjects called."));
    EnterCriticalSection(&g_cs);
    // Build CMimeDatabase Object
    if (NULL == g_pMimeDatabase)
        g_pMimeDatabase = new CMimeDatabase;
#ifdef NEWMLSTR
    if (NULL == g_pMalloc)
        g_pMalloc = new CMLAlloc;
#endif
    LeaveCriticalSection(&g_cs);
}

void FreeGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("FreeGlobalObjects called."));
    // Free CMimeDatabase Object
    if (NULL != g_pMimeDatabase)
    {
        delete g_pMimeDatabase;
        g_pMimeDatabase = NULL;
    }
#ifdef NEWMLSTR
    if (NULL != g_pMalloc)
    {
        delete g_pMalloc;
        g_pMalloc = NULL;
    }
#endif

    // LCDETECT
    if ( NULL != g_pLCDetect )
    {
        delete (LCDetect *)g_pLCDetect;
        g_pLCDetect = NULL;
    }

    if (NULL != g_pCpMRU)
    {
        delete g_pCpMRU;
        g_pCpMRU = NULL;
    }

    if (g_pMimeDatabaseReg)
    {
        delete g_pMimeDatabaseReg;
        g_pMimeDatabaseReg = NULL;
    }

    CMLangFontLink_FreeGlobalObjects();
}

//
//  DLL part of the Object
//
extern "C" BOOL WINAPI DllMain(HMODULE hInstance, DWORD dwReason, LPVOID)
{
    BOOL fRet = TRUE;

    DebugMsg(DM_TRACE, TEXT("DllMain called. dwReason=0x%08x"), dwReason);
    switch (dwReason)
    {
        LPVOID lpv;

        case DLL_PROCESS_ATTACH:

            SHFusionInitializeFromModule(hInstance);    
            InitializeCriticalSection(&g_cs);
            g_hInst = (HINSTANCE)hInstance;
            DisableThreadLibraryCalls(g_hInst);
            
            _Module.Init(ObjectMap, g_hInst);
            // HACKHACK (reinerf) - because ATL2.1 bites the big one, we have to malloc some memory
            // here so that it will cause _Module.m_hHeap to be initialized. They do not init this
            // member variable in a thread safe manner, so we will alloc and free a small chunk of
            // memory right now to ensure that the heap is created only once.
            lpv = malloc(2 * sizeof(CHAR));
            if (lpv)
            {
                free(lpv);
            }

            g_bIsNT5 = staticIsOS(OS_WIN2000ORGREATER);
            g_bIsNT = staticIsOS(OS_NT);
            g_bIsWin98 = staticIsOS(OS_WIN98ORGREATER);
            g_uACP = GetACP();
            break;

        case DLL_PROCESS_DETACH:
            FreeGlobalObjects();
            _Module.Term();
            DeleteCriticalSection(&g_cs);
            if (g_hUrlMon)
            {
               FreeLibrary(g_hUrlMon);
            }
            SHFusionUninitialize();
            break;
    }
    return TRUE;
}

void DllAddRef(void)
{
    _Module.Lock();
}

void DllRelease(void)
{
    _Module.Unlock();
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("DllGetClassObject called."));
    if (NULL == g_pMimeDatabase)
        BuildGlobalObjects();

    //
    // See comments in util.cpp NeedToLoadMLangForOutlook()
    //
    if (NeedToLoadMLangForOutlook())
        LoadLibrary(TEXT("mlang.dll"));

    return _Module.GetClassObject(rclsid, riid, ppvObj);
}

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//
//  Self Registration part
//
#if 0
HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    DebugMsg(DM_TRACE, TEXT("CallRegInstall called for %s."), szSection);
    if (NULL != hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (NULL != pfnri)
            hr = pfnri(g_hInst, szSection, NULL);
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}
#endif

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, TEXT("DllRegisterServer called."));

#if 0
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    OSVERSIONINFO osvi;
    BOOL fRunningOnNT;


    // Determine which version of NT or Windows we're running on
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);
    
    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    CallRegInstall("UnReg");
    hr = CallRegInstall(fRunningOnNT? "Reg.NT": "Reg");
    if (NULL != hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    // Need to register TypeLib here ...
    // Get the full path of this module
    GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));

    // Register our TypeLib
    MultiByteToWideChar(CP_ACP, 0, szModule, -1, wszTemp, ARRAYSIZE(wszTemp));
    hr = LoadTypeLib(wszTemp, &pTypeLib);
    if (SUCCEEDED(hr))
    {
        hr = RegisterTypeLib(pTypeLib, wszTemp, NULL);
        pTypeLib->Release();
    }
#else
    hr = RegisterServerInfo();
// Legacy registry MIME DB code, keep it for backward compatiblility
    MimeDatabaseInfo();
#endif
    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, TEXT("DllUnregisterServer called."));
#if 0
    hr = CallRegInstall("UnReg");
#else
    hr = UnregisterServerInfo();
#endif
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\kscobj.h ===
#include "convbase.h"

class CInccKscIn : public CINetCodeConverter
{
private:
	BOOL (CInccKscIn::*m_pfnConv)(UCHAR tc);
	BOOL (CInccKscIn::*m_pfnCleanUp)();
	BOOL m_fShift;
	BOOL m_fKorea;
	BOOL m_fLeadByte;
	UINT m_nESCBytes;                               /* # bytes of ESC sequence */

public:
	CInccKscIn(UINT uCodePage, int nCodeSet);
	~CInccKscIn() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
	BOOL ConvMain(UCHAR tc);
	BOOL CleanUpMain();
	BOOL ConvEsc(UCHAR tc);
	BOOL CleanUpEsc();
	BOOL ConvIsoIn(UCHAR tc);
	BOOL CleanUpIsoIn();
	BOOL ConvIsoInKr(UCHAR tc);
	BOOL CleanUpIsoInKr();
};

class CInccKscOut : public CINetCodeConverter
{
private:
    BOOL    m_fDoubleByte;
    BYTE    m_tcLeadByte;
    DWORD   _dwFlag;
    BOOL    m_fShift;
    BOOL    m_fKorea;
    WCHAR  *_lpFallBack;

public:
    CInccKscOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack);
    ~CInccKscOut() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\jisobj.h ===
#include "convbase.h"

enum KANA_MODE
{
    FULL_MODE    = 0,
    ESC_MODE     = 1,
    SIO_MODE     = 2,
};

enum JIS_ESC_STATE
{
    JIS_ASCII    = 0,
    JIS_Roman    = 1,
    JIS_Kana     = 2,
    JIS_DoubleByte = 3,
};

class CInccJisIn : public CINetCodeConverter
{
private:
	BOOL (CInccJisIn::*m_pfnConv)(UCHAR tc);        
	BOOL (CInccJisIn::*m_pfnCleanUp)();
	BOOL m_fShift;                                  /* Shift in/out control */
	BOOL m_fJapan;                                  /* IN_JP OUT_JP control */
	BOOL m_fLeadByte;                               /* Shift in and lead byte flag */
	UCHAR m_tcLeadByte;                             /* perserve the last lead byte */
	UINT m_nESCBytes;                               /* # bytes of ESC sequence */
	JIS_ESC_STATE m_eEscState;                      /* State of ESC sequence */

public:
	CInccJisIn(UINT uCodePage, int nCodeSet);
	~CInccJisIn() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
	BOOL ConvMain(UCHAR tc);
	BOOL CleanUpMain();
	BOOL ConvEsc(UCHAR tc);
	BOOL CleanUpEsc();
	BOOL ConvIsoIn(UCHAR tc);
	BOOL CleanUpIsoIn();
	BOOL ConvIsoInJp(UCHAR tc);
	BOOL CleanUpIsoInJp();
	BOOL ConvIsoOut(UCHAR tc);
	BOOL CleanUpIsoOut();
	BOOL ConvStar(UCHAR tc);
	BOOL CleanUpStar();
	BOOL ConvDoubleByte(UCHAR tc);
	BOOL CleanUpDoubleByte();
};

class CInccJisOut : public CINetCodeConverter
{
private:
    BOOL m_fDoubleByte;
    UCHAR m_tcLeadByte;     // use for DBCS lead byte
    UCHAR m_tcPrevByte;     // use for half width kana as a saved previous byte

    BOOL m_fKana;
    BOOL m_fJapan;
    BOOL m_fSaveByte;
    DWORD  m_dwFlag;
    WCHAR  *m_lpFallBack;

    KANA_MODE m_eKanaMode ;  // half width kana convert method

public:
    CInccJisOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack);
    ~CInccJisOut() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
    void SetKanaMode(UINT uCodePage);
private:
    void Reset();
    HRESULT ConvFullWidthKana(UCHAR tc);
    BOOL KanaCleanUp();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\kscobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from ISO-2022-KR
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "kscobj.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccKscIn::CInccKscIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccKscIn::Reset()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_fShift = FALSE;
    // bug #57570, Korean ISP DACOM only labels one designator in the 
    // conversion of a MIME mail. To decode the other part of MIME correctly, 
    // we need to decode the ISO document or MIME message even there is no
    // designator "esc ) C".
	m_fKorea = TRUE;
	m_nESCBytes = 0 ;
	m_fLeadByte = FALSE ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccKscIn::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccKscIn::CleanUp()
{
	return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccKscIn::ConvMain(UCHAR tc)
{
	BOOL fDone = TRUE;

	if (tc == ESC) {
		m_pfnConv = ConvEsc;
		m_pfnCleanUp = CleanUpEsc;
		m_nESCBytes++ ;
	} else {
		if (m_fKorea) {
			switch (tc) {
			case SO:
				m_fShift = TRUE;
				break;

			case SI:
				m_fShift = FALSE;
				m_fLeadByte = FALSE ;
				break;

			default:
				if (m_fShift) {
					switch (tc) {
					case ' ':
					case '\t':
					case '\n':
						fDone = Output(tc);
						break;

					default:
						fDone = Output(tc | 0x80);
						m_fLeadByte = ~m_fLeadByte ;
						break;
					}
				} else {
					fDone = Output(tc);
				}
				break;
			}
		} else {
			fDone = Output(tc);
		}
	}
	return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccKscIn::CleanUpMain()
{
	return TRUE;
}

/******************************************************************************
*****************************   C O N V   E S C   *****************************
******************************************************************************/

BOOL CInccKscIn::ConvEsc(UCHAR tc)
{
	if (tc == ISO2022_IN_CHAR) {
		m_pfnConv = ConvIsoIn;
		m_pfnCleanUp = CleanUpIsoIn;
		m_nESCBytes++ ;
		return TRUE;
	} else {
		m_pfnConv = ConvMain;
		m_pfnCleanUp = CleanUpMain;
		m_nESCBytes = 0 ;
		(void)Output(ESC);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
*************************   C L E A N   U P   E S C   *************************
******************************************************************************/

BOOL CInccKscIn::CleanUpEsc()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_nESCBytes = 0 ;
	return Output(ESC);
}

/******************************************************************************
**************************   C O N V   I S O   I N   **************************
******************************************************************************/

BOOL CInccKscIn::ConvIsoIn(UCHAR tc)
{
	if (tc == ISO2022_IN_KR_CHAR_1) {
		m_pfnConv = ConvIsoInKr;
		m_pfnCleanUp = CleanUpIsoInKr;
		m_nESCBytes++ ;
		return TRUE;
	} else {
		m_pfnConv = ConvMain;
		m_pfnCleanUp = CleanUpMain;
		m_nESCBytes = 0 ;
		(void)Output(ESC);
		(void)ConvertChar(ISO2022_IN_CHAR);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
**********************   C L E A N   U P   I S O   I N   **********************
******************************************************************************/

BOOL CInccKscIn::CleanUpIsoIn()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
   	m_nESCBytes = 0 ;

	(void)Output(ESC);
	(void)ConvertChar(ISO2022_IN_CHAR);
	return CleanUp();
}

/******************************************************************************
***********************   C O N V   I S O   I N   K R   ***********************
******************************************************************************/

BOOL CInccKscIn::ConvIsoInKr(UCHAR tc)
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
   	m_nESCBytes = 0 ;

	if (tc == ISO2022_IN_KR_CHAR_2) {
		m_fKorea = TRUE;
		return TRUE;
	} else {
		(void)Output(ESC);
		(void)ConvertChar(ISO2022_IN_CHAR);
		(void)ConvertChar(ISO2022_IN_KR_CHAR_1);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
*******************   C L E A N   U P   I S O   I N   K R   *******************
******************************************************************************/

BOOL CInccKscIn::CleanUpIsoInKr()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
   	m_nESCBytes = 0 ;

	(void)Output(ESC);
	(void)ConvertChar(ISO2022_IN_CHAR);
	(void)ConvertChar(ISO2022_IN_KR_CHAR_1);
	return CleanUp();
}

int CInccKscIn::GetUnconvertBytes()
{
    if ( m_fLeadByte )
        return 1 ;
    else if ( m_nESCBytes )
        return m_nESCBytes < 4 ? m_nESCBytes : 3 ;
    else
        return 0 ;
}

DWORD CInccKscIn::GetConvertMode()
{
    // 0xC431 -> 50225 ISO-2022-KR
    return ( m_fKorea ? 1 : 0 ) + ( m_fShift ? 2 : 0 ) | 0xC4310000 ;
}

void CInccKscIn::SetConvertMode(DWORD mode)
{
    Reset();    // initialization

    if ( mode & 0x00000001 )
        m_fKorea = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fShift = TRUE ;
    return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to ISO-2022-KSC
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccKscOut::CInccKscOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccKscOut::Reset()
{
	m_fDoubleByte = FALSE;
	m_fShift = FALSE;
	m_fKorea = FALSE;
	m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccKscOut::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    HRESULT hr = S_OK;

//
//IE RAID #103403 weiwu 03/16/00
//
//Per Korean PM (sykim), we don't have to prepend iso-2022-kr designator to conversion result string
//Also considering that URLMON can't handle encoded ASCII iso-2022-kr string
//We now remove following code, if it triggers any compatibility issues, we should re-enable it
//
#if 0
    // put designator to the top of the document
	if (!m_fKorea) {
		(void)Output(ESC);
		(void)Output(ISO2022_IN_CHAR);
		(void)Output(ISO2022_IN_KR_CHAR_1);
		(void)Output(ISO2022_IN_KR_CHAR_2);
		m_fKorea = TRUE;
	}
#endif

	if (!m_fDoubleByte) {
        //
        // We're not using IsDBCSLeadByteEx() due to perf. concern
        // We should assert that our hard code table match IsDBCSLeadByteEx(), 
        // But, MLang ships with down level platforms and assert won't be valid if there is a range change
        //
		if (IS_KOR_LEADBYTE(tc)) {
			m_fDoubleByte = TRUE;
			m_tcLeadByte = tc;
		} else {
			if (m_fKorea && m_fShift) {
				(void)Output(SI);
				m_fShift = FALSE;
			}
			fDone = Output(tc);
		}
	} else {
		m_fDoubleByte = FALSE;
		if (tc > 0x40) { // Check if trail byte indicates Hangeul
			if (m_tcLeadByte > 0xa0 && tc > 0xa0) { // Check if it's a Wansung
			    if (!m_fShift) {
				    if (!m_fKorea) {
					    (void)Output(ESC);
					    (void)Output(ISO2022_IN_CHAR);
					    (void)Output(ISO2022_IN_KR_CHAR_1);
					    (void)Output(ISO2022_IN_KR_CHAR_2);
					    m_fKorea = TRUE;
				    }
				    (void)Output(SO);
				    m_fShift = TRUE;
			    }                
				(void)Output(m_tcLeadByte & 0x7f);
				fDone = Output(tc & 0x7f);
			} else {
                UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    


                if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
                {
                    // only take SBCS, no DBCS character
                    if ( 1 != WideCharToMultiByte(CP_KOR_5601, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                        szDefaultChar[0] = 0x3f;
                }

			    // shift out if we're in DBCS mode
                if (m_fKorea && m_fShift) {
				    (void)Output(SI);
				    m_fShift = FALSE;
			    }

                if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
                {
                    char    szChar[2];
                    char    szDstStr[10];
                    WCHAR   szwChar[2];
                    int     cCount;

                    szChar[0] = m_tcLeadByte;
                    szChar[1] = tc;
                
                    if (MultiByteToWideChar(CP_KOR_5601, 0, szChar, 2, szwChar, ARRAYSIZE(szwChar)))
                    {
                        // Output NCR entity
                        Output('&');
                        Output('#');
                        _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                        cCount = lstrlenA(szDstStr);
                        for (int i=0; i< cCount; i++)
                        {
                            Output(szDstStr[i]);
                        }
                        fDone = Output(';');
                    }
                    else
                    {
				        fDone = Output(szDefaultChar[0]); // use default char
                        hr = S_FALSE;
                    }
                }
                else
                {
				    fDone = Output(szDefaultChar[0]); // use default char
                    hr = S_FALSE;
                }
			}
		} else {
			if (m_fKorea && m_fShift) {
				(void)Output(SI);
				m_fShift = FALSE;
			}
			(void)Output(m_tcLeadByte);
			fDone = Output(tc);
		}
		m_tcLeadByte = 0 ;
	}

    if (!fDone)
        hr = E_FAIL;

	return hr;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccKscOut::CleanUp()
{
    BOOL fDone = TRUE;

    if ( m_fShift) 
    {
        fDone = Output(SI);
        m_fShift = FALSE;
    }
    return fDone ;
}

int CInccKscOut::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1 ;
    else
        return 0 ;
}

DWORD CInccKscOut::GetConvertMode()
{
    // for output, we don't need write back code page. 0xC431 -> 50225 ISO-2022-KR
    return ( m_fKorea ? 1 : 0 ) +  ( m_fShift ? 2 : 0 ) ;
}

void CInccKscOut::SetConvertMode(DWORD mode)
{
    Reset();    // initialization

    if ( mode & 0x00000001 ) 
        m_fKorea = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fShift = TRUE ;
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\lccommon.h ===
/*
 * Declarations common to compiler and detector.
 *
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 * 
 *  History:    1-Feb-97    BobP      Created
 *              5-Aug-97    BobP      Added Unicode support, and persisting
 *                                    Charmaps in the data file.
 */

#ifndef __INC_LCDCOMP_COMMON_H
#define __INC_LCDCOMP_COMMON_H

/****************************************************************/

// Compiled detection data file, in lcdetect.dll module directory
#define DETECTION_DATA_FILENAME "mlang.dat"

// Limits
#define MAX7BITLANG 30
#define MAX8BITLANG 30
#define MAXUNICODELANG 30
#define MAXSUBLANG 5			// max # of sublanguages or codepages per lang
#define MAXCHARMAPS 10			// max # of Charmaps, overall


// Special case entries for the training script and detector.
// These language IDs are never returned by the detector.

#define LANGID_UNKNOWN		0x400
#define LANGID_LATIN_GROUP	0x401
#define LANGID_CJK_GROUP	0x402

// Value type of a histogram array index.
// This is the output value of the SBCS/DBCS or WCHAR reduction mapping,
// and is used as the index into the n-gram arrays and for the Unicode
// language group IDs.
// 
typedef unsigned char HIdx;
typedef HIdx *PHIdx;
#define HIDX_MAX UCHAR_MAX		// keep consistent w/ HIdx

// Fixed index values for mapped characters
#define HIDX_IGNORE		0
#define HIDX_EXTD		1
#define HIDX_LETTER_A	2
#define HIDX_LETTER_Z	(HIDX_LETTER_A + 25)


// Value type of a histogram element
typedef unsigned char HElt;
typedef HElt *PHElt;
#define HELT_MAX UCHAR_MAX		// keep consistent w/ HElt


#define LANG7_DIM 3				// 7-bit language uses trigrams

// Fixed IDs of the Charmaps
#define CHARMAP_UNICODE  0		// Built from RANGE directives
#define CHARMAP_7BITLANG 1		// Built from CHARMAP 1
#define CHARMAP_8BITLANG 2		// From CHARMAP 2
#define CHARMAP_CODEPAGE 3		// From CHARMAP 3
#define CHARMAP_U27BIT 4		// Built internally for Unicode to 7-bit lang
#define CHARMAP_NINTERNAL 5		// First ID for dynamic subdetection maps


#define DEFAULT_7BIT_EDGESIZE 28
#define DEFAULT_8BIT_EDGESIZE 155


#define UNICODE_DEFAULT_CHAR_SCORE  50

/****************************************************************/

// Compiled file format.

// These declarations directly define the raw file format.
// Be careful making changes here, and be sure to change the
// header version number when appropriate.

#define APP_SIGNATURE 0x5444434C	// "LCDT"
#define APP_VERSION   2

enum SectionTypes {				// for m_dwType below
	SECTION_TYPE_LANGUAGE = 1,	// any language definition
	SECTION_TYPE_HISTOGRAM = 2,	// any histogram
	SECTION_TYPE_MAP = 3		// any character mapping table
};

enum DetectionType {			// SBCS/DBCS detection types
	DETECT_NOTDEFINED = 0, 
	DETECT_7BIT,
	DETECT_8BIT,
	DETECT_UNICODE,
		
	DETECT_NTYPES
};

// FileHeader -- one-time header at start of file

typedef struct FileHeader {
	DWORD	m_dwAppSig;			// 'DTCT'
	DWORD	m_dwVersion;
	DWORD	m_dwHdrSizeBytes;	// byte offset of 1st real section
	DWORD	m_dwN7BitLanguages;
	DWORD	m_dwN8BitLanguages;
	DWORD	m_dwNUnicodeLanguages;
	DWORD	m_dwNCharmaps;
	DWORD	m_dwMin7BitScore;
	DWORD	m_dwMin8BitScore;
	DWORD	m_dwMinUnicodeScore;
	DWORD	m_dwRelativeThreshhold;
	DWORD	m_dwDocPctThreshhold;
	DWORD	m_dwChunkSize;
} FileHeader;
typedef FileHeader *PFileHeader;

// FileSection -- common header that begins each file section

typedef struct FileSection {
	DWORD	m_dwSizeBytes;		// section size incl. header (offset to next)
	DWORD	m_dwType;			// type of entry this section
} FileSection;
typedef FileSection *PFileSection;

// FileLanguageSection -- 1st entry of sequence for an SBCS/DBCS language
//
// Followed by 1 or more histogram sections

typedef struct FileLanguageSection {
	// preceded by struct FileSection
	DWORD	m_dwDetectionType;
	DWORD	m_dwLangID;
	DWORD	m_dwUnicodeRangeID;	// Unicode range mapping value for this lang
	DWORD	m_dwRecordCount;	// # of histograms following this record
} FileLanguageSection;
typedef FileLanguageSection *PFileLanguageSection;

// FileHistogramSection -- entry for one histogram (SBCS/DBCS or WCHAR)

typedef struct FileHistogramSection {
	// preceded by struct FileSection
	union {
		DWORD	m_dwCodePage;	// for 7 or 8-bit, Codepage this indicates
		DWORD	m_dwRangeID;	// for Unicode, the sublanguage group ID
	};
	DWORD	m_dwDimensionality;
	DWORD	m_dwEdgeSize;
	DWORD	m_dwMappingID;		// ID of Charmap to use
	// HElt m_Elts[]
} FileHistogramSection;
typedef struct FileHistogramSection *PFileHistogramSection;

// FileMapSection -- entry for one character map (SBCS/DBCS or WCHAR)

typedef struct FileMapSection {
	// preceded by struct FileSection
	DWORD	m_dwID;				// ID by which hardwired code finds the table
	DWORD	m_dwSize;			// size of table (256 or 65536)
	DWORD	m_dwNUnique;		// # of unique output values
	// HIdx m_map[]
} FileMapSection;
typedef struct FileMapSection *PFileMapSection;

////////////////////////////////////////////////////////////////

// LangNames - lookup table to get from English-localized names to a Win32
// primary language ID.

struct LangNames {
	LPCSTR			pcszName;
	unsigned short	nLangID;
};
LPCSTR GetLangName (int id);
int GetLangID (LPCSTR pcszName);
extern const struct LangNames LangNames[];

////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\jisobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from ISO-2022-JP
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "jisobj.h"

#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccJisIn::CInccJisIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccJisIn::Reset()
{
	m_pfnConv = ConvMain;   
	m_pfnCleanUp = CleanUpMain;
	m_fShift = FALSE;
	m_fJapan = FALSE;
	m_fLeadByte = FALSE ; 
	m_tcLeadByte = 0 ;
	m_nESCBytes = 0 ;
	m_eEscState = JIS_ASCII ; 
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccJisIn::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccJisIn::CleanUp()
{
	return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccJisIn::ConvMain(UCHAR tc)
{
	BOOL fDone = TRUE;

	switch (tc) {
	case SO:
		m_fShift = TRUE;
		break;

	case SI:
		m_fShift = FALSE;
		m_fLeadByte = FALSE;
		break;

	default:
		if (m_fShift) {
			fDone = Output(tc | 0x80);
			// it may continue to convert to Unicode, so we need to know
			// whether current byte is a lead byte or not
			m_fLeadByte = ~m_fLeadByte ;
		} else {
			if (tc == ESC) {
				m_pfnConv = ConvEsc;
				m_pfnCleanUp = CleanUpEsc;
				m_nESCBytes++;
			} else {
				if (m_fJapan) {
					if (tc == '*') {
						m_pfnConv = ConvStar;
						m_pfnCleanUp = CleanUpStar;
					} else {
						m_pfnConv = ConvDoubleByte;
						m_pfnCleanUp = CleanUpDoubleByte;
						m_tcLeadByte = tc;
					}
				} else {
                    switch ( m_eEscState )
                    {
                        case JIS_ASCII:
                            fDone = Output(tc);
                            break ;
                        case JIS_Roman:
#if 0
                            if ( tc == 0x7e ) /* tilde in ACSII -> overline */
                            {
                                Output(0x81);
                                fDone = Output(0x50);
                            }
                            else
                                fDone = Output(tc);
#else
                            fDone = Output(tc);
#endif
                            break ;
                        case JIS_Kana:
                            fDone = Output(tc | 0x80 );
                            break ;
                        default:
                            fDone = Output(tc);
                            break ;
                    }
				}
			}
		}
		break;
	}
	return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccJisIn::CleanUpMain()
{
	return TRUE;
}

/******************************************************************************
*****************************   C O N V   E S C   *****************************
******************************************************************************/

BOOL CInccJisIn::ConvEsc(UCHAR tc)
{
	switch (tc) {
	case ISO2022_IN_CHAR:
		m_pfnConv = ConvIsoIn;
		m_pfnCleanUp = CleanUpIsoIn;
		m_nESCBytes++;
		return TRUE;

	case ISO2022_OUT_CHAR:
		m_pfnConv = ConvIsoOut;
		m_pfnCleanUp = CleanUpIsoOut;
		m_nESCBytes++;
		return TRUE;

	default:
		m_pfnConv = ConvMain;
		m_pfnCleanUp = CleanUpMain;
		m_nESCBytes = 0 ;
		(void)Output(ESC);
		if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
*************************   C L E A N   U P   E S C   *************************
******************************************************************************/

BOOL CInccJisIn::CleanUpEsc()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	return Output(ESC);
}

/******************************************************************************
**************************   C O N V   I S O   I N   **************************
******************************************************************************/

BOOL CInccJisIn::ConvIsoIn(UCHAR tc)
{
	switch (tc) {
	case ISO2022_IN_JP_CHAR1:       /* 'B' */
	case ISO2022_IN_JP_CHAR2:       /* '@' */
		m_pfnConv = ConvMain;
		m_pfnCleanUp = CleanUpMain;
		m_fJapan = TRUE;
		m_nESCBytes = 0 ;
		return TRUE;

	case ISO2022_IN_JP_CHAR3_1:     /* '(' */
		m_pfnConv = ConvIsoInJp;
		m_pfnCleanUp = CleanUpIsoInJp;
		m_nESCBytes++ ;
		return TRUE;

	default:
		m_pfnConv = ConvMain;
		m_pfnCleanUp = CleanUpMain;
		m_nESCBytes = 0 ;
		(void)Output(ESC);
		(void)ConvertChar(ISO2022_IN_CHAR);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
**********************   C L E A N   U P   I S O   I N   **********************
******************************************************************************/

BOOL CInccJisIn::CleanUpIsoIn()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	(void)Output(ESC);
	(void)ConvertChar(ISO2022_IN_CHAR);
	return CleanUp();
}

/******************************************************************************
***********************   C O N V   I S O   I N   J P   ***********************
******************************************************************************/

BOOL CInccJisIn::ConvIsoInJp(UCHAR tc)
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_nESCBytes = 0 ;

	if (tc == ISO2022_IN_JP_CHAR3_2) {
		m_fJapan = TRUE;
		return TRUE;
	} else {
		(void)Output(ESC);
		(void)ConvertChar(ISO2022_IN_CHAR);
		(void)ConvertChar(ISO2022_IN_JP_CHAR3_1);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
*******************   C L E A N   U P   I S O   I N   J P   *******************
******************************************************************************/

BOOL CInccJisIn::CleanUpIsoInJp()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_nESCBytes = 0 ;

	(void)Output(ESC);
	(void)ConvertChar(ISO2022_IN_CHAR);
	(void)ConvertChar(ISO2022_IN_JP_CHAR3_1);
	return CleanUp();
}

/******************************************************************************
*************************   C O N V   I S O   O U T   *************************
******************************************************************************/

BOOL CInccJisIn::ConvIsoOut(UCHAR tc)
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_nESCBytes = 0 ;

	switch (tc) {
	case ISO2022_OUT_JP_CHAR1:  /* B */
		m_fJapan = FALSE;
		m_eEscState = JIS_ASCII ;
		return TRUE;

	case ISO2022_OUT_JP_CHAR2:  /* J */
	case ISO2022_OUT_JP_CHAR4:  /* H */
		m_fJapan = FALSE;
		m_eEscState = JIS_Roman ;
		return TRUE;       

	case ISO2022_OUT_JP_CHAR3: /* I */
		m_fJapan = FALSE;
		m_eEscState = JIS_Kana ; 
		return TRUE;       

	default:
		(void)Output(ESC);
		(void)ConvertChar(ISO2022_OUT_CHAR);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
	}
}

/******************************************************************************
*********************   C L E A N   U P   I S O   O U T   *********************
******************************************************************************/

BOOL CInccJisIn::CleanUpIsoOut()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_nESCBytes = 0 ;

	(void)Output(ESC);
	(void)ConvertChar(ISO2022_OUT_CHAR);
	return CleanUp();
}

/******************************************************************************
****************************   C O N V   S T A R   ****************************
******************************************************************************/

BOOL CInccJisIn::ConvStar(UCHAR tc)
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	return Output(tc | 0x80);
}

/******************************************************************************
************************   C L E A N   U P   S T A R   ************************
******************************************************************************/

BOOL CInccJisIn::CleanUpStar()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	return Output('*');
}

/******************************************************************************
*********************   C O N V   D O U B L E   B Y T E   *********************
******************************************************************************/

BOOL CInccJisIn::ConvDoubleByte(UCHAR tc)
{
	BOOL bRet ;
	UCHAR tcSJisLB;
	UCHAR tcSJisTB;

	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	tcSJisLB = ((m_tcLeadByte - 0x21) >> 1) + 0x81;
	if (tcSJisLB > 0x9f)
		tcSJisLB += 0x40;

	tcSJisTB = tc + (m_tcLeadByte & 1 ? 0x1f : 0x7d);
	if (tcSJisTB >= 0x7f)
		tcSJisTB++;

	(void)Output(tcSJisLB);
	bRet = Output(tcSJisTB);

	m_tcLeadByte = 0 ;
	return bRet ;
}

/******************************************************************************
*****************   C L E A N   U P   D O U B L E   B Y T E   *****************
******************************************************************************/

BOOL CInccJisIn::CleanUpDoubleByte()
{
	BOOL bRet ;
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;

	bRet = Output(m_tcLeadByte);
	m_tcLeadByte = 0 ;
	return bRet ;
}

int CInccJisIn::GetUnconvertBytes()
{
    if ( m_tcLeadByte || m_fLeadByte )
        return 1 ;
    else if ( m_nESCBytes )
        return m_nESCBytes < 4 ? m_nESCBytes : 3 ;
    else
        return 0 ;
}

DWORD CInccJisIn::GetConvertMode()
{
    // 0xC42C -> 50220 ISO-2022-JP
    return ( m_fJapan ? 1 : 0 ) + ( m_fShift ? 2 : 0 ) | 0xC42C0000 ;
}

void CInccJisIn::SetConvertMode(DWORD mode)
{
    Reset();
    if ( mode & 0x00000001 )
        m_fJapan = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fShift = TRUE ;

 	return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to ISO-2022-JP
// ============================================================================

#define VOICE_MARK_OFFSET       0xA0
#define VOICE_MARK_DEDF_OFFSET  0xC8

#if 0   // Shift JIS Table - not used
// this is the table used to determine whether the kana char is voiced sound markable
// if it is, what is the combined full width kana.
static WCHAR g_wVoiceMarkKana[48] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x8394,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,
  /* b0-bf */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x834B, 0x834D, 0x834f, 0x8351, 0x8353, 0x8355, 0x8357, 0x8359, 0x835B, 0x835D,
  /* c0-cf */ 0x835F, 0x8361, 0x8364, 0x8366, 0x8368,    0x0,    0x0,    0x0,    0x0,    0x0, 0x836F, 0x8372, 0x8375, 0x8378, 0x837B,    0x0,

};

// special voiced sound mark '0xde' conversion
static WCHAR g_wMarkDEKana[16] =
{
  /* c8-cf */  0x0, 0x0, 0x836F, 0x8372, 0x8375, 0x8378, 0x837B, 0x0,
};


// special voiced sound mark '0xdf' conversion
static WCHAR g_wMarkDFKana[16] =
{
  /* c8-cf */ 0x0, 0x0, 0x8370, 0x8373, 0x8376, 0x8379, 0x837C, 0x0,
};

// this is the table used to convert half width kana to full width kana
static WCHAR g_wFullWKana[64] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0, 0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x8392, 0x8340, 0x8342, 0x8344, 0x8346, 0x8348, 0x8383, 0x8385, 0x8387, 0x8362,
  /* b0-bf */ 0x815B, 0x8341, 0x8343, 0x8345, 0x8347, 0x8349, 0x834A, 0x834C, 0x834E, 0x8350, 0x8352, 0x8354, 0x8356, 0x8358, 0x835A, 0x835C,
  /* c0-cf */ 0x835E, 0x8360, 0x8363, 0x8365, 0x8367, 0x8369, 0x836A, 0x836B, 0x836C, 0x836D, 0x836E, 0x8371, 0x8374, 0x8377, 0x837A, 0x837D,
  /* d0-df */ 0x837E, 0x8380, 0x8381, 0x8382, 0x8384, 0x8386, 0x8388, 0x8389, 0x838A, 0x838B, 0x838C, 0x838D, 0x838F, 0x8393, 0x814A, 0x814B,
};
#endif

// JIS Table

// this is the table used to determine whether the kana char is voiced sound markable
// if it is, what is the combined full width kana.
static WCHAR g_wVoiceMarkKana[48] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x2574,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,
  /* b0-bf */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x252c, 0x252e, 0x2530, 0x2532, 0x2534, 0x2536, 0x2538, 0x253A, 0x253C, 0x253E,
  /* c0-cf */ 0x2540, 0x2542, 0x2545, 0x2547, 0x2549,    0x0,    0x0,    0x0,    0x0,    0x0, 0x2550, 0x2553, 0x2556, 0x2559, 0x255C,    0x0,

};

// special voiced sound mark '0xde' conversion
static WCHAR g_wMarkDEKana[16] =
{
  /* c8-cf */  0x0, 0x0, 0x2550, 0x2553, 0x2556, 0x2559, 0x255C, 0x0,
};

// special voiced sound mark '0xdf' conversion
static WCHAR g_wMarkDFKana[16] =
{
  /* c8-cf */ 0x0, 0x0, 0x2551, 0x2554, 0x2557, 0x255A, 0x255D, 0x0,
};

// this is the table used to convert half width kana to full width kana
static WCHAR g_wFullWKana[64] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0, 0x2123, 0x2156, 0x2157, 0x2122, 0x2126, 0x2572, 0x2521, 0x2523, 0x2525, 0x2527, 0x2529, 0x2563, 0x2565, 0x2567, 0x2543,
  /* b0-bf */ 0x213C, 0x2522, 0x2524, 0x2526, 0x2528, 0x252A, 0x252B, 0x252D, 0x252f, 0x2531, 0x2533, 0x2535, 0x2537, 0x2539, 0x253B, 0x253D,
  /* c0-cf */ 0x253F, 0x2541, 0x2544, 0x2546, 0x2548, 0x254A, 0x254B, 0x254C, 0x254D, 0x254E, 0x254F, 0x2552, 0x2555, 0x2558, 0x255B, 0x255E,
  /* d0-df */ 0x255F, 0x2560, 0x2561, 0x2562, 0x2564, 0x2566, 0x2568, 0x2569, 0x256A, 0x256B, 0x256C, 0x256D, 0x256F, 0x2573, 0x212B, 0x212C,
};

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccJisOut::CInccJisOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    m_dwFlag = dwFlag;
    // Per Office team's request, we should disable BESTFITCHARS feature for now.
    m_dwFlag &= ~MLCONVCHARF_NOBESTFITCHARS;
    m_lpFallBack = lpFallBack;
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccJisOut::Reset()
{
	m_fDoubleByte = FALSE;
	m_fKana = FALSE;
	m_fJapan = FALSE;
	m_fSaveByte = FALSE;
	m_tcLeadByte = 0 ;
	m_tcPrevByte = 0 ;
	m_eKanaMode = SIO_MODE ; 
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccJisOut::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = TRUE;
    HRESULT hr = S_OK;

	if (!m_fDoubleByte) {
		if ((tc >= 0x81 && tc <= 0x9f) || (tc >= 0xe0 && tc <= 0xfc )) { 
			// Switch to Double Byte Code
			if (m_fKana) {
			    if ( SIO_MODE == m_eKanaMode )
    				fDone = Output(SI);
			    else if ( (FULL_MODE == m_eKanaMode) && !(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))
			    {
				    fDone = KanaCleanUp();
				    m_fJapan = TRUE; // in FULL mode, Kana are bouble byte code too.
			    }
			    m_fKana = FALSE;
			}
			if (!m_fJapan) {
				(void)Output(ESC);  // ESC $ B - JIS-83
				(void)Output(ISO2022_IN_CHAR);
				fDone = Output(ISO2022_IN_JP_CHAR1);
				m_fJapan = TRUE;
			}
			m_fDoubleByte = TRUE;
			m_tcLeadByte = tc;
		} else if (tc >= 0xa1 && tc <= 0xdf) { 
			// Single Byte Katakana Code
			if (m_fJapan) {
			    if ( (FULL_MODE == m_eKanaMode) && !(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))
				    m_fKana = TRUE; // no mode changing
			    else if ( (SIO_MODE == m_eKanaMode) || (FULL_MODE == m_eKanaMode))
			    {
    				(void)Output(ESC);  // ESC ( B - ACSII
	    			(void)Output(ISO2022_OUT_CHAR);
		    		fDone = Output(ISO2022_OUT_JP_CHAR1);
			    }
				m_fJapan = FALSE;
			}
			if (!m_fKana) {
			    switch ( m_eKanaMode )
			    {
			        case SIO_MODE :
        				fDone = Output(SO);
        				break ;
			        case ESC_MODE :
		        		(void)Output(ESC);  // ESC ( I - Kana mode
		        		(void)Output(ISO2022_OUT_CHAR);
        				fDone = Output(ISO2022_OUT_JP_CHAR3);
        				break ;
			        case FULL_MODE :
						// Don't switch if NO_BEST_FIT_CHAR
						if (!(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))
						{
        					(void)Output(ESC);  // ESC $ B - JIS 83
		        			(void)Output(ISO2022_IN_CHAR);
		        			fDone = Output(ISO2022_IN_JP_CHAR1);        				
						}
						break;

			    }
			    m_fKana = TRUE;
			}
			if ( FULL_MODE ==  m_eKanaMode )
			{
			    hr = ConvFullWidthKana(tc);
				if (SUCCEEDED(hr))
					fDone = TRUE;
				else
					fDone = FALSE;
			}
			else
			    fDone = Output(tc & 0x7f);
		} else {
			// Single Byte Code
			if (m_fKana) {
			    if ( SIO_MODE == m_eKanaMode )
    				fDone = Output(SI);
			    else {
    				if ( FULL_MODE == m_eKanaMode )
    				    fDone = KanaCleanUp();
    				(void)Output(ESC);  // ESC ( B - ACSII
	    			(void)Output(ISO2022_OUT_CHAR);
		    		fDone = Output(ISO2022_OUT_JP_CHAR1);
			    }
			    m_fKana = FALSE;
			}
			if (m_fJapan) {
				(void)Output(ESC);  // ESC ( B - ACSII
				(void)Output(ISO2022_OUT_CHAR);
				fDone = Output(ISO2022_OUT_JP_CHAR1);
				m_fJapan = FALSE;
			}
			fDone = Output(tc);
		}
	} else {

        // map extended char (0xfa40-0xfc4b) to a special range
        if (m_tcLeadByte >= 0xfa && m_tcLeadByte <= 0xfc && tc >= 0x40 )
        {
            WCHAR  wcDBCS ;

            wcDBCS = ((WCHAR) m_tcLeadByte ) << 8 | tc ;

            if ( wcDBCS >= 0xfa40 && wcDBCS <= 0xfa5b )
            {
                if ( wcDBCS <= 0xfa49 )
                    wcDBCS = wcDBCS - 0x0b51 ;
                else if ( wcDBCS >= 0xfa4a && wcDBCS <= 0xfa53 )
                    wcDBCS = wcDBCS - 0x072f6 ;
                else if ( wcDBCS >= 0xfa54 && wcDBCS <= 0xfa57 )
                    wcDBCS = wcDBCS - 0x0b5b ;
                else if ( wcDBCS == 0xfa58 )
                    wcDBCS = 0x878a ;
                else if ( wcDBCS == 0xfa59 )
                    wcDBCS = 0x8782 ;
                else if ( wcDBCS == 0xfa5a )
                    wcDBCS = 0x8784 ;
                else if ( wcDBCS == 0xfa5b )
                    wcDBCS = 0x879a ;
            }
            else if ( wcDBCS >= 0xfa5c && wcDBCS <= 0xfc4b )
            {
                if ( tc < 0x5c )
                    wcDBCS = wcDBCS - 0x0d5f;
                else if ( tc >= 0x80 && tc <= 0x9B )
                    wcDBCS = wcDBCS - 0x0d1d;
                else
                    wcDBCS = wcDBCS - 0x0d1c;
            }
            tc = (UCHAR) wcDBCS ;
            m_tcLeadByte = (UCHAR) ( wcDBCS >> 8 ) ;
        }

		// Convert Double Byte Code
		m_tcLeadByte -= ((m_tcLeadByte > 0x9f) ? 0xb1 : 0x71);
		m_tcLeadByte = m_tcLeadByte * 2 + 1;
		if (tc > 0x9e) {
			tc -= 0x7e;
			m_tcLeadByte++;
		} else {
			if (tc > 0x7e)
				tc--;
			tc -= 0x1f;
		}
		(void)Output(m_tcLeadByte);
		fDone = Output(tc);
		m_fDoubleByte = FALSE;
		m_tcLeadByte = 0 ;
	}

    if (fDone)
        return hr;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccJisOut::CleanUp()
{
	BOOL fDone = TRUE;

	// Discard m_byLeadByte: if (m_fDoubleByte) Output(m_byLeadByte);

	fDone = KanaCleanUp();

	if (m_fKana)
	{
		if ( SIO_MODE == m_eKanaMode )
		    fDone = Output(SI);
		else if (!(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))   // FULL mode and ESC mode
		{
		    (void)Output(ESC); // ESC ( B - ASCII
		    (void)Output(ISO2022_OUT_CHAR);
		    fDone = Output(ISO2022_OUT_JP_CHAR1);
		}
		m_fKana = FALSE ;
	}

	if (m_fJapan) {
		(void)Output(ESC); // ESC ( B - ASCII
		(void)Output(ISO2022_OUT_CHAR);
		fDone = Output(ISO2022_OUT_JP_CHAR1);
		m_fJapan = FALSE ;
	}

	return fDone;
}


/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccJisOut::ConvFullWidthKana(UCHAR tc)
{
    BOOL fDone = TRUE ;
    int index ;
    WCHAR DoubleBytes ;
    HRESULT hr = S_OK;

    if (m_dwFlag & MLCONVCHARF_NOBESTFITCHARS)
    {
        UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null

        if (m_lpFallBack && (m_dwFlag & MLCONVCHARF_USEDEFCHAR))
        {
            // only take SBCS, no DBCS character
            if ( 1 != WideCharToMultiByte(CP_JPN_SJ, 0,
                         (LPCWSTR)m_lpFallBack, 1,
                         (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                szDefaultChar[0] = 0x3f;
        }

        if (m_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
        {
            char    szChar[2] = {0};
            char    szDstStr[10] = {0};
            WCHAR   szwChar[2];
            int     cCount;

            szChar[0] = tc;
                
            if (MultiByteToWideChar(CP_JPN_SJ, 0, szChar, -1, szwChar, ARRAYSIZE(szwChar)))
            {
                // Output NCR entity
                Output('&');
                Output('#');
                _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                cCount = lstrlenA(szDstStr);
                for (int i=0; i< cCount; i++)
                {
                    Output(szDstStr[i]);
                }
                fDone = Output(';');
            }
            else
            {
				fDone = Output(szDefaultChar[0]); // use default char
                hr = S_FALSE;
            }
        }
        else
        {
 		    fDone = Output(szDefaultChar[0]); // use default char
            hr = S_FALSE;
        }
    }
    else
	{
		// voiced sound mark or semi-voiced sound mark 
		if ( m_fSaveByte && ( tc == 0xde || tc == 0xdf ) )
		{
			if ( m_tcPrevByte >= 0x0CA && m_tcPrevByte <= 0x0CE ) 
			{
				index = m_tcPrevByte - VOICE_MARK_DEDF_OFFSET ;
				if ( tc == 0xde )
					DoubleBytes = g_wMarkDEKana[index] ;
				else
					DoubleBytes = g_wMarkDFKana[index] ;
			}
			else
			{
				index = m_tcPrevByte - VOICE_MARK_OFFSET ;
				DoubleBytes = g_wVoiceMarkKana[index] ;
			}
			Output( (UCHAR) (DoubleBytes >> 8 ));
			fDone = Output( (UCHAR) DoubleBytes );
			m_fSaveByte = FALSE ;
			m_tcPrevByte = '\0' ;
		}
		else 
		{

			// output previous saved voice sound markable char
			if ( m_fSaveByte )
			{
				index = m_tcPrevByte - VOICE_MARK_OFFSET ;
				DoubleBytes = g_wFullWKana[index] ;
				Output( (UCHAR) (DoubleBytes >> 8 ) );
				fDone = Output( (UCHAR) DoubleBytes );
				m_fSaveByte = FALSE ;
				m_tcPrevByte = '\0' ;
			}

			// half width kana
			if ( tc >= 0xa1 && tc <= 0xdf )
			{
				index = tc - VOICE_MARK_OFFSET ;
				// check if this char can be combined with voice sound mark
				if ( g_wVoiceMarkKana[index] )
				{
					m_fSaveByte = TRUE ;
					m_tcPrevByte = tc ;
				}
				// convert half width kana to full width kana
				else
				{
					DoubleBytes = g_wFullWKana[index] ;
					Output( (UCHAR) ( DoubleBytes >> 8 ));
					fDone = Output( (UCHAR) DoubleBytes );
				}
			}
			else
				fDone = Output(tc);
		}
    }

    if (fDone)
        return hr;
    else
        return E_FAIL;

}

/******************************************************************************
*************************** K A N A  C L E A N   U P   ************************
******************************************************************************/

BOOL CInccJisOut::KanaCleanUp()
{
    BOOL fDone = TRUE;
    WCHAR DoubleBytes ;
    int index ;

    // output previous saved voice sound markable char
    if ( m_fSaveByte )
    {
        index = m_tcPrevByte - VOICE_MARK_OFFSET ;
        DoubleBytes = g_wFullWKana[index] ;
        Output( (UCHAR) ( DoubleBytes >> 8 ));
        fDone = Output( (UCHAR) DoubleBytes );
        m_fSaveByte = FALSE ;
        m_tcPrevByte = '\0' ;
    }

	return fDone;
}

int CInccJisOut::GetUnconvertBytes()
{
    if ( m_tcLeadByte )
        return 1 ;
    else
        return 0 ;
}

DWORD CInccJisOut::GetConvertMode()
{
    return ( m_fJapan ? 1 : 0 ) +  ( m_fKana ? 2 : 0 ) ;
}

void CInccJisOut::SetConvertMode(DWORD mode)
{
    Reset();
    if ( mode & 0x00000001 ) 
        m_fJapan = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fKana = TRUE ;
    return ;
}

void CInccJisOut::SetKanaMode(UINT uCodePage)
{
    switch ( uCodePage )
    {
        case    CP_ISO_2022_JP_ESC:
            m_eKanaMode = ESC_MODE ; 
            break ;
        case    CP_ISO_2022_JP_SIO:
            m_eKanaMode = SIO_MODE ; 
            break ;
        default :
            m_eKanaMode = FULL_MODE ; 
            break ;
    }
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\lcdetect.h ===
/*
 * Automatic language and codepage detection
 * 
 * Bob Powell, 2/97
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 */

#if !defined( __LCDETECT_H__ )
#define __LCDETECT_H__

typedef struct LCDScore {
	UINT nLangID;			// Win32 primary language ID
	UINT nCodePage;			// Win32 code page (valid for SBCS input only!)
	int nDocPercent;		// % of doc in this language, 0-100
	int nConfidence;		// Relative confidence measure, approx 0-100
} LCDScore;
typedef struct LCDScore * PLCDScore;

typedef struct LCDConfigure {
	int nMin7BitScore;		// per-char score threshhold for 7-bit detection
	int nMin8BitScore;		// " " for 8-bit
	int nMinUnicodeScore;	// " " for Unicode
	int nRelativeThreshhold;// relative "" as % of the top scoring doc, 0-100
	int nDocPctThreshhold;	// min % of doc in a language to score it, 0-100
	int nChunkSize;			// # of chars to process at a time
} LCDConfigure;
typedef struct LCDConfigure *PLCDConfigure;
typedef struct LCDConfigure const *PCLCDConfigure;

// Pass in rough body text in pStr, length nChars
// Pass in preallocated LCDScore array in paScores, array size in *pnScores.
// On return, *pnScores is set to number of elements containing result data.
//
// If pLCDC is NULL, the default configuration is used.
// To detect with a custom configuration, call LCD_GetConfig() to fill in
// a copy of an LCDConfigure, and then pas it to LCD_Detect().

extern "C" DWORD WINAPI LCD_Detect (LPCSTR pStr, int nChars, 
							PLCDScore paScores, int *pnScores,
							PCLCDConfigure pLCDC);

extern "C" DWORD WINAPI LCD_DetectW (LPCWSTR pwStr, int nChars,
							PLCDScore paScores, int *pnScores,
							PCLCDConfigure pLCDC);

extern "C" void WINAPI LCD_GetConfig (PLCDConfigure pLCDC);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\lcinit.cpp ===
/*
 * Automatic language and codepage detector
 * 
 * Bob Powell, 2/97
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 * 
 *  History:    1-Feb-97    BobP      Created
 *              5-Aug-97    BobP      Unicode support; Charmaps in data file.
 */
#include "private.h"
/****************************************************************/



Histogram::Histogram (const PFileHistogramSection pHS, const PHIdx pMap)
: m_nDimensionality((UCHAR)pHS->m_dwDimensionality),
  m_nEdgeSize((UCHAR)pHS->m_dwEdgeSize),
  m_nCodePage((USHORT)pHS->m_dwCodePage),
  m_pMap(pMap),
  m_panElts((HElt *)&pHS[1])	// table follows header struct  in the file
{
	// #elements = #unique character values ^ #dimensions

	m_nElts = 1;
	for (UCHAR i = 0; i < m_nDimensionality; i++)
		m_nElts *= m_nEdgeSize;
}

DWORD
Histogram::Validate (DWORD nBytes) const
{
	if ( nBytes < m_nElts * sizeof(HElt) ||
		 m_nDimensionality > 4 )
	{
		return ERROR_INTERNAL_DB_CORRUPTION;
	}

	return NO_ERROR;
}

Histogram::Histogram (const Histogram &H, const PHIdx pMap)
: m_nDimensionality(H.m_nDimensionality),
  m_nEdgeSize(H.m_nEdgeSize),
  m_nCodePage(H.m_nCodePage),
  m_nElts(H.m_nElts),
  m_pMap(pMap),
  m_panElts(H.m_panElts)
//
// Clone a histogram but use a different Charmap.
{
}

Histogram::~Histogram (void)
//
// The pointer members point to the mapped file and do not need to be freed.
{
}

/****************************************************************/

Language::Language (PLCDetect pL, int nLangID, int nCodePages, int nRangeID)
: m_pLC(pL),
  m_nLangID(nLangID),
  m_nCodePages(nCodePages),
  m_nRangeID(nRangeID)
{
}

Language7Bit::Language7Bit (PLCDetect pL, int nLangID, int nCodePages)
: Language(pL, nLangID, nCodePages),
  m_pLangHistogram(NULL)
{
	memset ((void *)m_ppCodePageHistogram, 0, sizeof(m_ppCodePageHistogram));
}

Language7Bit::~Language7Bit (void)
{
	if (m_pLangHistogram)
		delete m_pLangHistogram;

	for (int i = 0; i < MAXSUBLANG; i++)
		if (m_ppCodePageHistogram[i])
			delete m_ppCodePageHistogram[i];
}

DWORD
Language7Bit::AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx)
//
// Add the raw histogram at *pHS in the mapped file to this language object.  
// The histograms must be for 7-bit detection.
{
	DWORD hr = NO_ERROR;

	PHIdx pMap = m_pLC->GetMap( pHS->m_dwMappingID );

	if (nIdx == 0)
	{
		// The first histogram for a language is its language-detection table.

		if ( (m_pLangHistogram = new Histogram (pHS, pMap)) == NULL)
			return ERROR_OUTOFMEMORY;

		if ((hr = m_pLangHistogram->Validate (nBytes)) != NO_ERROR)
			return hr;
	}
	else
	{
		// Each subsequent histogram is a code page detection table.

		if (nIdx - 1 >= m_nCodePages)
			return ERROR_INTERNAL_DB_CORRUPTION;

		Histogram *pH;

		if ((pH = new Histogram (pHS, pMap)) == NULL)
			return ERROR_OUTOFMEMORY;

		if ((hr = pH->Validate (nBytes)) != NO_ERROR)
			return hr;

		m_ppCodePageHistogram[nIdx - 1] = pH;

		// Cache for the scoring vector math

		m_paHElt[nIdx - 1] = pH->Array();
	}

	return hr;
}

/****************************************************************/

Language8Bit::Language8Bit (PLCDetect pL, int nLangID, int nCodePages)
: Language(pL, nLangID, nCodePages)
{
	memset ((void *)m_ppHistogram, 0, sizeof(m_ppHistogram));
}

Language8Bit::~Language8Bit (void)
{
	for (int i = 0; i < MAXSUBLANG; i++)
		if (m_ppHistogram[i])
			delete m_ppHistogram[i];
}

DWORD
Language8Bit::AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx)
//
// Add the raw histogram at *pHS to this language object.  
// This language is known to use 8-bit detection.
{
	DWORD hr = NO_ERROR;

	PHIdx pMap = m_pLC->GetMap( pHS->m_dwMappingID );

	// The histograms are the direct language-code page tables

	if (nIdx >= m_nCodePages)
		return ERROR_INTERNAL_DB_CORRUPTION;

	Histogram *pH;

	if ((pH = new Histogram (pHS, pMap)) == NULL)
		return ERROR_OUTOFMEMORY;

	if ((hr = pH->Validate (nBytes)) != NO_ERROR)
		return hr;

	m_ppHistogram[nIdx] = pH;

	return hr;
}

/****************************************************************/

LanguageUnicode::LanguageUnicode (PLCDetect pL, int nLangID, 
	int nSubLangs, int nRangeID)
: Language(pL, nLangID, nSubLangs, nRangeID)
{
	memset ((void *)m_ppSubLangHistogram, 0, sizeof(m_ppSubLangHistogram));
}

LanguageUnicode::~LanguageUnicode (void)
{
	for (int i = 0; i < MAXSUBLANG; i++)
		if (m_ppSubLangHistogram[i])
			delete m_ppSubLangHistogram[i];
}

DWORD
LanguageUnicode::AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx)
{
	DWORD hr = NO_ERROR;

	// All histograms for are sublanguage detection

	if (nIdx >= m_nSubLangs)
		return ERROR_INTERNAL_DB_CORRUPTION;

	// Get the custom charmap used for scoring this sublanguage group

	PHIdx pMap = m_pLC->GetMap( pHS->m_dwMappingID );

	Histogram *pH;

	if ((pH = new Histogram (pHS, pMap)) == NULL)
		return ERROR_OUTOFMEMORY;

	if ((hr = pH->Validate (nBytes)) != NO_ERROR)
		return hr;

	m_ppSubLangHistogram[nIdx] = pH;

	m_paHElt[nIdx] = pH->Array();

	return hr;
}

/****************************************************************/

LCDetect::LCDetect (HMODULE hM)
: m_hModule(hM),
  m_nCharmaps(0),
  m_n7BitLanguages(0),
  m_n8BitLanguages(0),
  m_nUnicodeLanguages(0),
  m_n7BitLangsRead(0),
  m_n8BitLangsRead(0),
  m_nUnicodeLangsRead(0),
  m_nMapsRead(0),
  m_nHistogramsRead(0),
  m_nScoreIdx(0),
  m_pp7BitLanguages(NULL),
  m_pp8BitLanguages(NULL),
  m_ppUnicodeLanguages(NULL),
  m_ppCharmaps(NULL),
  m_pv(NULL),
  m_hmap(0),
  m_hf(0),
  m_pHU27Bit(0)
{
}

LCDetect::~LCDetect ()
{
    delete m_pHU27Bit;

    for (unsigned int i = 0; i < m_n7BitLanguages; i++)
        delete m_pp7BitLanguages[i];
    delete m_pp7BitLanguages;

    for (i = 0; i < m_n8BitLanguages; i++)
        delete m_pp8BitLanguages[i];
    delete m_pp8BitLanguages;

    for (i = 0; i < m_nUnicodeLanguages; i++)
        delete m_ppUnicodeLanguages[i];
    delete m_ppUnicodeLanguages;

    for (i = 0; i < m_nCharmaps; i++)
        delete m_ppCharmaps[i];
    delete m_ppCharmaps;

    if (m_pv)
        UnmapViewOfFile (m_pv);

    CloseHandle (m_hmap);
    CloseHandle (m_hf);
}

DWORD
LCDetect::Initialize7BitLanguage (PFileLanguageSection pLS, PLanguage *ppL)
//
// Set *ppL to the Language object created from this section.
{
	// nRecordCount is lang histogram (1) + # of code page histograms

	if ( m_n7BitLangsRead >= m_n7BitLanguages || pLS->m_dwRecordCount < 1)
		return ERROR_INTERNAL_DB_CORRUPTION;

	PLanguage7Bit pL = new Language7Bit (this, pLS->m_dwLangID, pLS->m_dwRecordCount - 1);

	if (pL == NULL)
		return ERROR_OUTOFMEMORY;


	// Each 7-bit lang uses one score index slot per code page.
	// The range starts with the 7-bit langs, since both the 8-bit
	// and Unicode langs follow it.

	if (m_n7BitLangsRead == 0 && m_nScoreIdx != 0)
		return ERROR_INTERNAL_DB_CORRUPTION;;

	pL->SetScoreIdx(m_nScoreIdx);

	m_nScoreIdx += pLS->m_dwRecordCount - 1;	// skip 1st record (Language)

	m_pp7BitLanguages[ m_n7BitLangsRead++ ] = pL;

	*ppL = pL;

	return NO_ERROR;
}

DWORD
LCDetect::Initialize8BitLanguage (PFileLanguageSection pLS, Language **ppL)
//
// Set *ppL to the Language object created from this section.
{
	// nRecordCount is # of combined language / code page histograms

	if ( m_n8BitLangsRead >= m_n8BitLanguages || pLS->m_dwRecordCount < 1)
		return ERROR_INTERNAL_DB_CORRUPTION;

	PLanguage8Bit pL = new Language8Bit (this, pLS->m_dwLangID, pLS->m_dwRecordCount);

	if (pL == NULL)
		return ERROR_OUTOFMEMORY;


	// The 8-bit score indices follow the 7-bit languages

	// Each 8-bit lang uses a score index slot for each of its code pages,
	// since all the code pages are scored in the initial scoring pass.
	// The number of slots is the number of code page histograms, which is
	// one less than the number of records following this language.

	pL->SetScoreIdx(m_nScoreIdx);
	m_nScoreIdx += pLS->m_dwRecordCount;


	m_pp8BitLanguages[ m_n8BitLangsRead++ ] = pL;

	*ppL = pL;

	return NO_ERROR;
}

DWORD
LCDetect::InitializeUnicodeLanguage (PFileLanguageSection pLS, Language **ppL)
//
// Set *ppL to the Language object created from this section.
{
	// nRecordCount is # of sublanguage histograms

	if ( m_nUnicodeLangsRead >= m_nUnicodeLanguages ||
		 pLS->m_dwUnicodeRangeID >= m_nUnicodeLanguages )
	{
		return ERROR_INTERNAL_DB_CORRUPTION;
	}

	PLanguageUnicode pL = new LanguageUnicode (this, pLS->m_dwLangID, 
						pLS->m_dwRecordCount, pLS->m_dwUnicodeRangeID);

	if (pL == NULL)
		return ERROR_OUTOFMEMORY;


	// The Unicode score indices follow the 7-bit languages, and overlay the
	// 8-bit slots since they aren't used at the same time.

	if (m_nUnicodeLangsRead == 0 && GetN8BitLanguages() > 0)
		m_nScoreIdx = Get8BitLanguage(0)->GetScoreIdx();

	// Each Unicode entry uses exactly one score index.  SBCS subdetection
	// (Latin group) uses the slots for the corresponding 7-bit languages,
	// and Unicode subdetection (CJK) uses the slots already defined for the
	// Unicode sub-languages.

	pL->SetScoreIdx(m_nScoreIdx);

	m_nScoreIdx++;

	// For Unicode, the range ID is used as the Language array index.

	m_ppUnicodeLanguages[ pLS->m_dwUnicodeRangeID ] = pL;
	m_nUnicodeLangsRead++;

	*ppL = pL;

	return NO_ERROR;
}

DWORD
LCDetect::LoadLanguageSection (void *pv, int nSectionSize, PLanguage *ppL)
//
// A language section begins the definition of data for a language.
// Each language has exactly one of these records.  One or more
// histogram sections follow each language, and are always associated
// with the language of the preceding language section.
//
// Set *ppL to the Language object created from this section.
{
	DWORD hr = NO_ERROR;

	PFileLanguageSection pLS;

	pLS = (PFileLanguageSection)&((char *)pv)[sizeof(FileSection)];

	switch ( pLS->m_dwDetectionType ) {

	case DETECT_7BIT:
		hr = Initialize7BitLanguage (pLS, ppL);
		break;

	case DETECT_8BIT:
		hr = Initialize8BitLanguage (pLS, ppL);
		break;

	case DETECT_UNICODE:
		hr = InitializeUnicodeLanguage (pLS, ppL);
		break;
	}

	return hr;
}

DWORD
LCDetect::LoadHistogramSection (void *pv, int nSectionSize, Language *pL)
{
	PFileHistogramSection pHS;

	pHS = (PFileHistogramSection)&((char *)pv)[sizeof(FileSection)];

	int nBytes = nSectionSize - sizeof(FileSection) - sizeof(*pHS);

	return pL->AddHistogram ( pHS, nBytes, m_nHistogramsRead++);
}

DWORD
LCDetect::LoadMapSection (void *pv, int nSectionSize)
{
	PFileMapSection pMS;

	pMS = (PFileMapSection)&((char *)pv)[sizeof(FileSection)];

	int nBytes = nSectionSize - sizeof(FileSection) - sizeof(*pMS);

	if (m_nMapsRead >= m_nCharmaps)
		return ERROR_INTERNAL_DB_CORRUPTION;

	PCharmap pM = new Charmap (pMS);

	if (pM == NULL)
		return ERROR_OUTOFMEMORY;

	m_ppCharmaps[ m_nMapsRead++ ]  = pM;

	return NO_ERROR;
}

DWORD
LCDetect::BuildState (DWORD nFileSize)
//
// Build the detection structures from the mapped training file image at *m_pv
{
	PLanguage pL;
	PFileHeader pFH;
	PFileSection pFS;

	DWORD hr = NO_ERROR;

	// Validate header

	pFH = (PFileHeader) m_pv;

	if ( nFileSize < sizeof(*pFH) || 
		 pFH->m_dwAppSig != APP_SIGNATURE ||
		 pFH->m_dwVersion != APP_VERSION ||
		 pFH->m_dwHdrSizeBytes >= nFileSize ||
		 pFH->m_dwN7BitLanguages == 0 ||
		 pFH->m_dwN8BitLanguages == 0 ||
		 pFH->m_dwNUnicodeLanguages == 0 ||
		 pFH->m_dwNCharmaps == 0 )
	{
		return ERROR_INTERNAL_DB_CORRUPTION;
	}

	// Allocate language pointer table per header

	m_n7BitLanguages = pFH->m_dwN7BitLanguages;
	m_pp7BitLanguages = new PLanguage7Bit [m_n7BitLanguages];

	m_n8BitLanguages = pFH->m_dwN8BitLanguages;
	m_pp8BitLanguages = new PLanguage8Bit [m_n8BitLanguages];

	m_nUnicodeLanguages = pFH->m_dwNUnicodeLanguages;
	m_ppUnicodeLanguages = new PLanguageUnicode [m_nUnicodeLanguages];

	m_nCharmaps = pFH->m_dwNCharmaps;
	m_ppCharmaps = new PCharmap [m_nCharmaps];

	if ( m_pp7BitLanguages == NULL || 
		 m_pp8BitLanguages == NULL || 
		 m_ppUnicodeLanguages == NULL ||
		 m_ppCharmaps == NULL )
	{
		return ERROR_OUTOFMEMORY;
	}

	// Clear, because not all slots may be assigned
	memset (m_ppUnicodeLanguages, 0, sizeof(PLanguageUnicode) * m_nUnicodeLanguages);

	// Remember other header info

	m_LCDConfigureDefault.nMin7BitScore = pFH->m_dwMin7BitScore;
	m_LCDConfigureDefault.nMin8BitScore = pFH->m_dwMin8BitScore;
	m_LCDConfigureDefault.nMinUnicodeScore = pFH->m_dwMinUnicodeScore;
	m_LCDConfigureDefault.nRelativeThreshhold = pFH->m_dwRelativeThreshhold;
	m_LCDConfigureDefault.nDocPctThreshhold = pFH->m_dwDocPctThreshhold;
	m_LCDConfigureDefault.nChunkSize = pFH->m_dwChunkSize;

	// Position to first section

	pFS = (PFileSection) &((char *)m_pv)[pFH->m_dwHdrSizeBytes];

	// Read and process each file section

	while ( hr == NO_ERROR ) {

		// check alignment

		if (((DWORD_PTR)pFS & 3) != 0) {
			hr = ERROR_INTERNAL_DB_CORRUPTION;
			break;
		}

		// zero-length section marks end of data

		if (pFS->m_dwSizeBytes == 0)
			break;

		if ( &((char *)pFS)[pFS->m_dwSizeBytes] >= &((char *)m_pv)[nFileSize]) {
			hr = ERROR_INTERNAL_DB_CORRUPTION;
			break;
		}

		switch ( pFS->m_dwType ) {

		case SECTION_TYPE_LANGUAGE:								// sets pL
			hr = LoadLanguageSection ((void*)pFS, pFS->m_dwSizeBytes, &pL);
			m_nHistogramsRead = 0;
			break;

		case SECTION_TYPE_HISTOGRAM:							// uses pL
			hr = LoadHistogramSection ((void*)pFS, pFS->m_dwSizeBytes, pL);
			break;

		case SECTION_TYPE_MAP:
			hr = LoadMapSection ((void*)pFS, pFS->m_dwSizeBytes);
			break;

		default:					// ignore unrecognized sections
			break;
		}

		pFS = (PFileSection) &((char *)pFS)[pFS->m_dwSizeBytes];
	}

	if (hr != NO_ERROR)
		return hr;

	if ( m_nMapsRead != m_nCharmaps )
		return ERROR_INTERNAL_DB_CORRUPTION;


	// Set up quick-reference arrays used by the scoring inner loops

	for (unsigned int i = 0; i < GetN7BitLanguages(); i++)
		m_paHElt7Bit[i] = Get7BitLanguage(i)->GetLangHistogram()->Array();

	m_nHElt8Bit = 0;
	for (i = 0; i < GetN8BitLanguages(); i++) 
	{
		PLanguage8Bit pL = Get8BitLanguage(i);

		for (int j = 0; j < pL->NCodePages(); j++)
			m_paHElt8Bit[m_nHElt8Bit++] = pL->GetHistogram(j)->Array();
	}

	// Set up the Histogram used for ScoreVectorW() for scoring Unicode
	// text for 7-bit language detection.  Clone the first 7-bit language
	// histogram and replace its map with CHARMAP_U27BIT.

	m_pHU27Bit = new Histogram ( *Get7BitLanguage(0)->GetLangHistogram(),
								 GetMap(CHARMAP_U27BIT));

	return hr;
}


DWORD
LCDetect::LoadState (void)
//
// Overall initialization and state loading.  Open the compiled training
// file from its fixed location in the System32 directory, and assemble
// in-memory detection tables from its contents.
{
	DWORD hr = NO_ERROR;
	DWORD nFileSize;
#define MODULENAMELEN 100
	char szFilename[MODULENAMELEN+50], *p;

	// Find out if NT or Windows

	OSVERSIONINFOA OSVersionInfo;
	int nOSWinNT = 0;
	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFOA );
	if ( GetVersionExA( &OSVersionInfo ) )
		nOSWinNT = OSVersionInfo.dwPlatformId;

	// Open the training data file,
	// look in the directory that contains the DLL.

	if (GetModuleFileNameA (m_hModule, szFilename, MODULENAMELEN) == 0)
		return GetLastError();

	if ( (p = strrchr (szFilename, '\\')) != NULL ||
		 (p = strrchr (szFilename, ':')) != NULL )
	{
		*++p = 0;
	}
	else
		*szFilename = 0;
	strcat (szFilename, DETECTION_DATA_FILENAME);

    if ((m_hf = CreateFileA (szFilename, GENERIC_READ, FILE_SHARE_READ, 
                    NULL, OPEN_EXISTING, 
                    FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) 
    {
        return E_FAIL;
    }

	if ((nFileSize = GetFileSize (m_hf, NULL)) == 0xffffffff) {
		hr = GetLastError();
		CloseHandle (m_hf);
		return hr;
	}

	// Virtual-map the file

	if ( nOSWinNT == VER_PLATFORM_WIN32_NT )
		m_hmap = CreateFileMapping (m_hf, NULL, PAGE_READONLY, 0, nFileSize, NULL);
	else
		m_hmap = CreateFileMappingA (m_hf, NULL, PAGE_READONLY, 0, nFileSize, NULL);

	if (m_hmap == NULL) {
		hr = GetLastError();
		CloseHandle (m_hf);
		return hr;
	}

	if ((m_pv = MapViewOfFile (m_hmap, FILE_MAP_READ, 0, 0, 0 )) == NULL) {
		hr = GetLastError();
		CloseHandle (m_hmap);
		CloseHandle (m_hf);
		return hr;
	}
		
	// Build the in-memory structures from the file

	hr = BuildState (nFileSize);

	return hr;
}

/****************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\lcdetect.cpp ===
/*
 * Automatic language and codepage detector
 * 
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 * 
 *  History:    1-Feb-97    BobP      Created
 *              5-Aug-97    BobP      Added Unicode support and rewrote
 *                                    scoring to use vector math.
 * 
 * This is the runtime detector.
 * 
 * See the comments in lcdcomp.cpp for a description of the compilation
 * process and training data format.
 *
 * See design.txt for a description of the detection and scoring algorithm.
 *
 * Performance note:  60-80% of execution time in this code is AddVector(),
 * which is probably memory-cycle bound by its random data access, but is
 * still a candidate for further optimizing with an intrinsic vector operator,
 * should one become available.
 * 
 * to-do (as needed):
 * - Adjust 7-bit and 8-bit scores to make them more comparable
 * - detect UTF-8 in the SBCS entry point, via heuristic and via
 *   subdetection as 7-bit lang and as Unicode.
 */

#include "private.h"

// This is all the global (per-process) state
//
// It is set at DLL process init and its contents are const after that.

LCDetect * g_pLCDetect;

#ifdef DEBUG_LCDETECT
int g_fDebug;
#endif

/****************************************************************/

static inline unsigned int
FindHighIdx (const int *pn, unsigned int n)
//
// Return the INDEX of the highest-valued integer in the given array.
{
	int nMax = 0;
	unsigned int nIdx = 0;

	for (unsigned int i = 0; i < n; i++)
	{
		if (pn[i] > nMax)
		{
			nMax = pn[i];
			nIdx = i;
		}
	}

	return nIdx;
}

/****************************************************************/

void
CScores::SelectCodePages (void)
//
// Find the highest scoring code page for each language, and remove
// all the other scores from the array such that the array contains
// exactly one score per detected language instead of one score per
// code page per language.
//
// When multiple scores are present for different code pages of the same
// language, this function combines the scores into a single score.
// The resulting entry will have the code page of the top-scoring code page
// for the various entries for that language, and the score and char count
// will be the SUM of the scores and char counts for ALL the entries for
// that language.
//
// For example, if the input contains:
//		Lang		Codepage	Score	Char count
//		Russian		1251		42		200
//		Russian		20866		69		300
//
// Then on output, the array will contain only one score for Russian:
//		Russian		20866		111		500
//
// This overwrites the entries in place, and sets m_nUsed to the resulting
// number of active slots.
//
// The scores are already grouped by language, no need to sort by language.
//
// After return, the score array must NOT be referenced via ScoreIdx()
// because the index of the entries has changed.
{
	// The score indices no longer matter, remove slots that scored zero.

	RemoveZeroScores ();

	if (m_nUsed == 0)
		return;

	// Select top score per language.  This is fundamentally dependent
	// on the score array already being ordered by language.  This won't
	// combine scores for the same language as both a 7-bit and 8-bit lang,
	// but that's not worth fixing.

	int maxscore = 0;					// highest score for a given language
	int totalscore = m_p[0].GetScore();	// sum of scores  " "
	int totalchars = m_p[0].GetCharCount();// sum of character counts  " "

	int nReturned = 0;			// index and ultimate count of elts returned
	unsigned int maxscoreidx = 0; // array index of the top-scoring code page,
								  // *** for the current language ***

	for (unsigned int i = 1; i < m_nUsed; i++) {
		if (m_p[i-1].GetLang() != m_p[i].GetLang())
		{
			// [i] indicates a different language from the previous entry
			
			// Add the entry for the previous language to the result
			// by copying the slot for its highest-scoring code page,
			// and overwriting its score and char count with the sum counts.

			m_p[maxscoreidx].SetScore(totalscore);
			m_p[maxscoreidx].SetCharCount(totalchars);
			m_p[nReturned++] = m_p[maxscoreidx];

			// Start remembering the top and total scores for the new lang.

			maxscore = m_p[i].GetScore();
			totalscore = m_p[i].GetScore();
			totalchars = m_p[i].GetCharCount();
			maxscoreidx = i;		// remember which [] had the top score
		}
		else 
		{
			// Accumulate more scores for the same language

			if (m_p[i].GetScore() > maxscore) {
				maxscore = m_p[i].GetScore();
				maxscoreidx = i;
			}
			totalscore += m_p[i].GetScore();
			totalchars += m_p[i].GetCharCount();
		}
	}

	// Process the the last language.  Return the slot from its
	// highest-scoring code page.

	if (m_nUsed > 0)
	{
		m_p[maxscoreidx].SetScore(totalscore);
		m_p[maxscoreidx].SetCharCount(totalchars);
		m_p[nReturned++] = m_p[maxscoreidx];
	}

	m_nUsed = nReturned;
}

/****************************************************************/

static void __fastcall
AddVector (int *pS, const PHElt *pH, int idx, unsigned int nScores)
//
// Add the score vector for a single n-gram to the running sum score
// vector at pS.
//
// On return, paS[0..nScores-1] is filled with the sum scores for each
// language.
//
// **** PERFORMANCE NOTE ****
//
// This is the critical inner-loop of the entire subsystem.
// 
// Code generation and performance have been checked for various code
// organization.  Ironically, making AddVector() a true function is
// FASTER than inlining it because when inlined, the registers are used
// for the OUTER loop variables and the inner loop here does approximately
// twice as many memory references per pass.
//
// On x86, all four loop variables are registered, and each pass makes only
// three memory references, which is optimal for the given representation.
// 
// Future note: the histogram tables could be pivoted to collect all the
// scores for each n-gram in a block; that would eliminate the double 
// indirection through ph and reduce the memory refs to two per pass.
{
	nScores++;		// makes faster end-test

	while (--nScores != 0)
		*pS++ += (*pH++)[idx];
}

static inline void
ScoreUnigramVector (LPCSTR pcsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for a unigram histogram.  Each individual character is
// mapped to a histogram slot to yield a score for that character in each
// language.
{
	if (nCh < 1)
		return;

	const PHIdx pMap = pH->GetMap();

	unsigned char *p = (unsigned char *)pcsz;

	while (nCh-- > 0)
		AddVector (paS, paH, pMap[*p++], nScores);
}

static inline void
ScoreUnigramVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// WCHAR version.  Only difference is the use of a map that maps the
// full 64K WCHAR space into the histogram index range.
{
	if (nCh < 1)
		return;

	const PHIdx pMap = pH->GetMap();

	while (nCh-- > 0)
		AddVector (paS, paH, pMap[*pcwsz++], nScores);
}

static inline void
ScoreDigramVector (LPCSTR pcsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for a digram histogram.  Each adjacent pair of characters
// are mapped to the index range and the mapped values combined to form an
// array index unique to that digram.  The scores for that array slot are
// summed for each language.
{
	if (nCh < 2)
		return;

	unsigned char *p = (unsigned char *)pcsz;

	const PHIdx pMap = pH->GetMap();

	unsigned char ch1 = pMap[*p++];

	while (nCh-- > 1)
	{
		unsigned char ch2 = pMap[*p++];

		AddVector (paS, paH, ch1 * pH->EdgeSize() + ch2, nScores);

		ch1 = ch2;
	}
}

static inline void
ScoreTrigramVector (LPCSTR pcsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for a trigram histogram.  Each adjacent three-letter set 
// of characters are mapped to the index range and the mapped values combined
// to form an array index unique to that trgram.
{
	if (nCh < 3)
		return;

	unsigned char *p = (unsigned char *)pcsz;

	const PHIdx pMap = pH->GetMap();

	unsigned char ch1 = pMap[*p++];
	unsigned char ch2 = pMap[*p++];

	while (nCh-- > 2)
	{
		unsigned char ch3 = pMap[*p++];
		debug(printf("  '%c%c%c':",unmapch(ch1),unmapch(ch2),unmapch(ch3)));

		int idx = ((ch1 * pH->EdgeSize()) + ch2) * pH->EdgeSize() + ch3;
		ch1 = ch2;
		ch2 = ch3;

		AddVector (paS, paH, idx, nScores);

		debug(for (UINT i = 0; i < nScores; i++) printf(" %3d", paH[i][idx]));
		debug(printf("\n"));
	}
}

static inline void
ScoreTrigramVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// WCHAR version.
{
	if (nCh < 3)
		return;

	const PHIdx pMap = pH->GetMap();

	unsigned char ch1 = pMap[*pcwsz++];
	unsigned char ch2 = pMap[*pcwsz++];

	while (nCh-- > 2)
	{
		unsigned char ch3 = pMap[*pcwsz++];

		int idx = ((ch1 * pH->EdgeSize()) + ch2) * pH->EdgeSize() + ch3;
		ch1 = ch2;
		ch2 = ch3;

		AddVector (paS, paH, idx, nScores);
	}
}

static inline void
ScoreNgramVector (LPCSTR pcsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// Score this text for any dimension of n-gram.  Get "N" from the
// dimensionality of the histogram.
//
//  Each adjacent n-letter set of characters are mapped to the index range
// and the scores the reference summed for each language.  This code is
// never used for the current data file, instead an optimized scoring
// loop exists for each existing case.  This exists to enable trying
// different dimension scoring without requiring a new DLL.
{
	if (nCh < pH->Dimensionality())
		return;

	unsigned char *p = (unsigned char *)pcsz;

	const PHIdx pMap = pH->GetMap();

	// Fill the pipeline

	int idx = 0;
	if (pH->Dimensionality() >= 2)
		idx = idx * pH->EdgeSize() + pMap[*p++];
	if (pH->Dimensionality() >= 3)
		idx = idx * pH->EdgeSize() + pMap[*p++];
	if (pH->Dimensionality() >= 4)
		idx = idx * pH->EdgeSize() + pMap[*p++];

	unsigned int nLoopCount = nCh - (pH->Dimensionality() - 1);

	while (nLoopCount-- > 0)
	{
		idx = (idx * pH->EdgeSize() + pMap[*p++]) % pH->NElts();

		AddVector (paS, paH, idx, nScores);
	}
}

static inline void
ScoreNgramVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// WCHAR version.
{
	if (nCh < pH->Dimensionality())
		return;

	const PHIdx pMap = pH->GetMap();

	// Fill the pipeline

	int idx = 0;
	if (pH->Dimensionality() >= 2)
		idx = idx * pH->EdgeSize() + pMap[*pcwsz++];
	if (pH->Dimensionality() >= 3)
		idx = idx * pH->EdgeSize() + pMap[*pcwsz++];
	if (pH->Dimensionality() >= 4)
		idx = idx * pH->EdgeSize() + pMap[*pcwsz++];

	unsigned int nLoopCount = nCh - (pH->Dimensionality() - 1);

	while (nLoopCount-- > 0)
	{
		idx = (idx * pH->EdgeSize() + pMap[*pcwsz++]) % pH->NElts();

		AddVector (paS, paH, idx, nScores);
	}
}

void
ScoreVector (LPCSTR pcsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// Score a string into an array of scores using an array of histograms
//
// Each character n-gram is mapped to a histogram slot to yield a score
// for that character in each array at paH.
//
// On return, paS[0..nScores-1] is filled with the sum scores.
{
	memset (paS, 0, sizeof(int) * nScores);

	switch (pH->Dimensionality()) 
	{
	case 1:
		ScoreUnigramVector (pcsz, nCh, pH, paS, paH, nScores);
		break;

	case 2:
		ScoreDigramVector (pcsz, nCh, pH, paS, paH, nScores);
		break;

	case 3:
		ScoreTrigramVector (pcsz, nCh, pH, paS, paH, nScores);
		break;

	default:
		ScoreNgramVector (pcsz, nCh, pH, paS, paH, nScores);
		break;
	}
}

void
ScoreVectorW (LPCWSTR pcwsz, int nCh, PHistogram pH,
	int *paS, const PHElt *paH, unsigned int nScores)
//
// Score a string into an array of scores using an array of histograms.
{
	memset (paS, 0, sizeof(int) * nScores);

	switch (pH->Dimensionality()) 
	{
	case 1:
		ScoreUnigramVectorW (pcwsz, nCh, pH, paS, paH, nScores);
		break;

	case 3:
		ScoreTrigramVectorW (pcwsz, nCh, pH, paS, paH, nScores);
		break;

	default:
		ScoreNgramVectorW (pcwsz, nCh, pH, paS, paH, nScores);
		break;
	}
}

void
LCDetect::Score7Bit (LPCSTR pcszText, int nChars, CScores &S) const
//
// Do 7-bit language detection.  Compute scores for all 7-bit languages
// and store the raw language score in S at the language's base score-idx.
//
// Fill in only the first score slot per language.  Uses ScoreIdx() for
// the first code page, but does not detect or set the code page.
{
	const PHistogram pH = Get7BitLanguage(0)->GetLangHistogram();

	debug(printf("       "));
	debug(for(unsigned int x=0;x<GetN7BitLanguages();x++)printf(" %3d", Get7BitLanguage(x)->LanguageID()));
	debug(printf("\n"));

	int sc[MAXSCORES];

	// Compute the raw score vector

	ScoreVector (pcszText, nChars, pH, sc, m_paHElt7Bit, GetN7BitLanguages());


	// Fill in the CScores array from it

	for (unsigned int i = 0; i < GetN7BitLanguages(); i++)
	{
		PLanguage7Bit pL = Get7BitLanguage(i);

		CScore &s = S.Ref(pL->GetScoreIdx());

		s.SetLang(pL);
		s.SetCodePage(0);
		s.SetScore(sc[i]);
		s.SetCharCount(nChars);
	}
}

void
LCDetect::Score8Bit (LPCSTR pcszText, int nChars, CScores &S) const
//
// Do 8-bit detection.  Compute a combined language / code page score
// for each trained language / code page combination for the 8-bit languages.
// Store all the raw scores in S at the language+each codepage score-idx.
//
// May store multiple entries in S for each language, one per code page.
{
	const PHistogram pH = Get8BitLanguage(0)->GetHistogram(0);

	int sc[MAXSCORES];

	// Compute the raw score vector

	ScoreVector (pcszText, nChars, pH, sc, m_paHElt8Bit, m_nHElt8Bit);

	// Fill in the CScores array from it

	int nSc = 0;
	for (unsigned int i = 0; i < GetN8BitLanguages(); i++)
	{
		PLanguage8Bit pL = Get8BitLanguage(i);

		for (int j = 0; j < pL->NCodePages(); j++)
		{
			CScore &s = S.Ref(pL->GetScoreIdx() + j);

			s.SetLang(pL);
			s.SetCodePage(pL->GetCodePage(j));
			s.SetScore( sc[ nSc++ ] );
			s.SetCharCount(nChars);
		}
	}
}

void
LCDetect::ScoreLanguageAsSBCS (LPCWSTR wcs, int nch, CScores &S) const
//
// This scores Unicode text known to contain mostly characters in the
// script ranges used for 7-bit languages.  This uses a special mapping,
// m_pH727Bit, that converts n-grams in the WCHAR text directly to the same
// mapping output space used for 7-bit language detection.  It is then scored
// using the same language-only histograms used for 7-bit SBCS detection.
//
// The output is the same as if Score7Bit() had been called on the SBCS
// equivalent to this text.  The same slots in S are filled in, using the
// 7-bit score indices, NOT the Unicode language score indices.
{
	debug(printf("    scoring as SBCS\n"));

	debug(printf("       "));
	debug(for(unsigned int x=0;x<GetN7BitLanguages();x++)printf(" %3d", Get7BitLanguage(x)->LanguageID()));
	debug(printf("\n"));

	// Call ScoreVectorW(), passing the histogram set up or the WCHAR map.

	int sc[MAXSCORES];

	// Compute the raw score vector

	ScoreVectorW (wcs, nch, m_pHU27Bit, sc, m_paHElt7Bit,GetN7BitLanguages());


	// Fill in the CScores array from it

	for (unsigned int i = 0; i < GetN7BitLanguages(); i++)
	{
		PLanguage7Bit pL = Get7BitLanguage(i);

		CScore &s = S.Ref(pL->GetScoreIdx());

		s.SetLang(pL);
		s.SetCodePage(0);
		s.SetScore(sc[i]);
		s.SetCharCount(nch);
	}
}

////////////////////////////////////////////////////////////////

void
Language::ScoreCodePage (LPCSTR, int nCh, CScore &S, int &idx) const 
//
// The default handler for scoring the code page for text for which the
// language is already known.  Initially used only for Unicode.
{
	idx = 0; 
	S.SetCodePage(0); 
}

void
Language7Bit::ScoreCodePage (LPCSTR pStr, int nCh, CScore &S, int &idx) const
//
// Detect the code page for text whose language has already been detected
// and is indicated in S.  Set S.CodePage(), do not change other
// fields of S.  
//
// Set idx to the index of the high-scoring code page.  The caller uses this
// to place the score in the correct ScoreIdx slot.
//
// Note that the arg is a single CScore, not an array.  The CScore S is
// filled in with the score of the high-scoring code page, and no information
// about the other code pages is returned.
{
	if (NCodePages() == 1)
	{
		// If lang is trained with only one codepage, just return it.

		idx = 0;
		S.SetCodePage(GetCodePage(0));

		debug(printf("  score code page: only one; cp=%d\n",GetCodePage(0)));
	}

	debug(printf("scoring 7-bit code pages: "));

	int sc[MAXSUBLANG];

	// Compute the raw score vector

	ScoreVector (pStr, nCh, GetCodePageHistogram(0),
			sc, GetPHEltArray(), NCodePages());

	// Find the high-scoring code page and fill in S with its values

	idx = FindHighIdx (sc, NCodePages());

	debug(printf("selecting cp=%d idx=%d\n", GetCodePage(idx), idx));

	S.SetCodePage (GetCodePage(idx));
}

void
LanguageUnicode::ScoreSublanguages (LPCWSTR wcs, int nch, CScores &S) const
//
// Score wcs for each sub-language and add the raw scores to S.
// The scores are not qualified at this time.
// 
// Relevant only for Unicode language groups that require subdetection,
// initially CJK.
{
	if (m_nSubLangs == 0)
		return;

	debug(printf("    scoring Unicode sublanguages:\n"));

	int sc[MAXSUBLANG];

	// Compute the raw score vector

	ScoreVectorW (wcs, nch, GetHistogram(0), sc, m_paHElt, m_nSubLangs);

	// Fill in the CScores array from it

	for (int i = 0; i < NSubLangs(); i++)
	{
		PLanguageUnicode pSL = GetSublanguage(i);

		CScore &s = S.Ref(pSL->GetScoreIdx());
		s.SetLang (pSL);
		s.SetScore (sc[i]);
		s.SetCharCount (nch);
		s.SetCodePage (0);

		debug(printf("      lang=%d score=%d\n", pSL->LanguageID(), sc[i]));
	}
}

int
LCDetect::ChooseDetectionType (LPCSTR pcszText, int nChars) const
//
// Histogram the raw char values to determine whether to use 7-bit or
// 8-bit detection for this block.
{
	// Count the proportion of chars < vs. >= 0x80

	int nHi = 0;

	for (int i = nChars; i-- > 0; )
		nHi += ((unsigned char)*pcszText++) & 0x80;

	nHi /= 0x80;
	int nLo = nChars - nHi;

	// Make sure there is sufficient data to make a good choice

	// work here -- try  if abs(nHi - nLo) < 10

	if (nHi + nLo < 10)
		return DETECT_NOTDEFINED;

	if (nHi * 2 > nLo)
		return DETECT_8BIT;
	else
		return DETECT_7BIT;
}

void
LCDetect::ScoreLanguageA (LPCSTR pStr, int nChars, CScores &S) const
//
//
// Score the text at pStr for each language that it potentially contains.
//
// Add the scores to S at the ScoreIdx() for each language and codepage
// combination.
// 
// This adds all the raw scores for either all the 7-bit or all the
// 8-bit entries, depending on which category the rough initial analysis
// indicates.  At this time, there are no entries for which both methods
// are required.
//
// For 7-bit detection, code page is always set to 0 and the language's score
// is placed in the 0'th slot for each language.  The caller later scores
// code pages if needed, and fills the remaining slots.
// 
// For 8-bit detection, scores are generated for each code page and all
// ScoreIdx() slots are used.
{
	switch (ChooseDetectionType (pStr, nChars)) {

	case DETECT_7BIT:
		Score7Bit (pStr, nChars, S);
		break;

	case DETECT_8BIT:
		Score8Bit (pStr, nChars, S);
		break;
	}
}

void
LCDetect::ScoreLanguageW (LPCWSTR wcs, int nch, CScores &S, PCLCDConfigure pC) const
//
// Score the text at wcs for each language that it potentially contains.
//
// Add the scores to S at the ScoreIdx() for each language.
// 
// This first determines the Unicode script groups represented in wcs.
// Each WCHAR is mapped through CHARMAP_UNICODE to yield its "language group
// ID".  The IDs for each char are counted and the top scoring IDs indicate
// the probable languages or language groups.  Note that unlike all other
// use of n-gram scoring, NO WEIGHTS are associated with the IDs -- whichever
// group contains the most raw chars, wins.
// 
// Some languages are indicated by presence of characters in a particular
// script group; these scores are immediately added to S.
// 
// For script groups that indicate multiple languages, subdetection within
// the group is done only when the score for the group exceeds a threshhold
// that indicates the sub-detected languages are likely to be included in
// the final result.  This is purely a performance optimization, not to
// be confused with the uniform score threshhold applied by the caller.
//
// The "Group" entries themselves are never included in the result; they
// exist only to invoke subdetection.
//
// In many cases even a single Unicode character provides sufficient
// identification of script and language, so there is no minimum
// qualification for scores in the script ranges that indicate a
// specific language by range alone.
{
	// Score the chars according to the Unicode script group they belong to.
	// The array indices are the raw outputs of the primary Unicode Charmap
	// NOT to be confused with the ScoreIdx() of each language.  Further,
	// the scores are the simple count of the characters in each script
	// range, and are NOT weighted by any histogram.
	
	// In this initial step, the simple majority of characters per range
	// determines which further detection steps to take.

	const PHIdx map = GetMap (CHARMAP_UNICODE);

	int anScore[MAXSCORES];
	memset (anScore, 0, sizeof(int) * GetNUnicodeLanguages());

	for (int x = 0; x < nch; x++)
		anScore[map[wcs[x]]]++;

	debug(printf("    char_ignore score=%d\n",anScore[HIDX_IGNORE]));

	// Ignore scores for chars that correlate with no language

	anScore[HIDX_IGNORE] = 0;


	// Identify the scores that qualify a language for immediate inclusion
	// in the result, or that qualify a language group for further detection.


	// Find the high score to use as a relative threshhold for inclusion.
	
	int nMaxScore = 0;

	for (unsigned int i = 0; i < GetNUnicodeLanguages(); i++)
	{
		if (anScore[i] > nMaxScore)
			nMaxScore = anScore[i];
	}

	debug(printf("  unicode range max score=%d\n",nMaxScore));

	// Process all individual and group scores above a threshhold.

	// The threshhold logic is different from the logic for SBCS/DBCS
	// detection, because presence of even a single character in certain
	// Unicode script ranges can be a strong correct indicator for a
	// specific language.  The threshhold for subdetected scores is
	// higher, since that is a statistical result; single characters
	// are not as strong an indicator.

	// Set the threshhold for subdetecting.

	int nRelThresh = 1 + (nMaxScore * pC->nRelativeThreshhold) / 100;


	for (i = 0; i < GetNUnicodeLanguages(); i++)
	{
		// Threshhold for any range is at least this many raw chars in range.

		if (anScore[i] >= 2)
		{
			PLanguageUnicode pL = GetUnicodeLanguage(i);

			debug(printf("  using lang=%d score=%d:\n", pL->LanguageID(), anScore[i]));

			if (pL->LanguageID() == LANGID_UNKNOWN)
			{
				// DO NOTHING -- text is an unknown language

				debug(printf("    lang=unknown\n"));

			}
			else if (pL->NSubLangs() > 0)
			{
				// Subdetect language within a Unicode group, and add all the
				// unqualified raw scores directly to S.

				pL->ScoreSublanguages (wcs, nch, S);
			}
			else if ( pL->LanguageID() == LANGID_LATIN_GROUP &&
				      anScore[i] >= nRelThresh )
			{
				// Subdetect Latin/Western languages, and add all the
				// unqualified raw scores to S.
				
				ScoreLanguageAsSBCS (wcs, nch, S);
			} 
			else
			{
				debug(printf("    range identifies language\n"));

				// This range identifies a specific language; add it.

				CScore &s = S.Ref(pL->GetScoreIdx());
				s.SetLang (pL);
				s.SetScore (anScore[i] * UNICODE_DEFAULT_CHAR_SCORE);
				s.SetCharCount (nch);
				s.SetCodePage (0);
			}
		}
	}
}

/****************************************************************/

DWORD
LCDetect::DetectA (LPCSTR pStr, int nInputChars, 
	PLCDScore paScores, int *pnScores,
	PCLCDConfigure pLCDC) const
//
// Do SBCS / DBCS detection.  Detect language and code page of pStr, 
// fill paScores[] with the result and set *pnScores to the result count.
// On input, *pnScores is the available capacity of paScores.
//
// The text at pStr is broken into chunks, typically several hundred
// bytes.  
//
// In the first phase, each chunk is scored by language.  The scores for 
// a single chunk are qualified by both an absolute threshhold and by a 
// threshhold based on the high score of just that chunk.  Scores exceeding
// the threshhold are remembered towards the second phase; other scores
// are discarded.  
//
// For each score that will be remembered, if a code page is not already
// known for it then the code page for the chunk is determined and included
// with the score.  Note that the score refers only to the language, NOT
// to the confidence of the code page.
// 
// In the second phase, the combined scores for all chunks are examined.
// The scores are further qualified by a relative threshhold.  Only
// languages with scores exceeding the threshhold are included in the
// final result; the remainder are discarded.
//
// The two-step process is designed to yield good results for input containing
// text in multiple languages, or containing a high portion of whitespace or
// symbol characters that correlate with no language.  It also is designed
// to optimally handle tie-cases whether due to similar languages or to
// mixed-language input, and to avoid applying threshholds based on
// absolute scores.
//
// The presumption is that each chunk, generally, represents text in a single
// language, and no matter what the absolute high score is, its high score
// most likely is for that language.  The point of the first phase is to
// identify all the languages that are known with some confidence to be
// represented in the text.  For a given chunk, multiple languages scores may
// meet this criteria and be remembered towards the result.  Specifically,
// when a tie occurs, BOTH scores are always included.  (Choosing just one
// would be wrong too often to be worthwhile.)
//
// The point of the second phase is to filter out the noise allowed by the
// first phase.
{
	TScores<MAXSCORES> SChunk;		// Scores for one chunk at a time
	TScores<MAXSCORES> SAll;		// Qualified scores for ultimate result

	if (pLCDC == NULL)				// Use the default config if not specified
		pLCDC = &m_LCDConfigureDefault;

	if (*pnScores == 0)
		return NO_ERROR;

#define MAX_INPUT (USHRT_MAX-1)
	// CScore.NChars() is a USHORT to save space+time, so only this # of chars
	// can be accepted per call or the scoring would overflow.

	nInputChars = min (nInputChars, MAX_INPUT);
	debug(printf("LCD_Detect: detecting %d chars\n", nInputChars));

	// The first loop processed fixed-size chunks and accumulates all the
	// credibly-detected languages in SAll.  This is the "coarse" accuracy
	// qualification:  detect the language of text blocks small enough to
	// typically be in *one* language, and remember only the highest scoring
	// language for that chunk.  Then generate a multivalued result that
	// shows the distribution of language in the doc, instead of simply
	// returning the dominant language.  This is necessary because it is
	// much harder to determine the sole language than to determine the
	// multivalued result.

	int nProcessed = 0;

	while (nProcessed < nInputChars)
	{
		SChunk.Reset();				// reset is cheaper than constructing

		// Process nChunkSize worth of text if that will leave at least
		// another nChunkSize piece for the final pass.  If that would
		// leave a smaller final chunk, go ahead and process the entire
		// remaining input.

		int nch = nInputChars - nProcessed;

		if (nch >= pLCDC->nChunkSize * 2)
			nch = pLCDC->nChunkSize;


		debug(printf("\nStarting chunk: %d ch\n\"%.*s\"\n", nch, nch, &pStr[nProcessed]));

		ScoreLanguageA (&pStr[nProcessed], nch, SChunk);

		// Compute the threshhold for inclusion of each score in the
		// overall result.

		int nRelThresh = 1 + (SChunk.FindHighScore().GetScore() * pLCDC->nRelativeThreshhold) / 100;
		int nThresh7 = max (pLCDC->nMin7BitScore * nch, nRelThresh);
		int nThresh8 = max (pLCDC->nMin8BitScore * nch, nRelThresh);

		debug(printf("high score=%d min7=%d thresh7=%d thresh8=%d\n", SChunk.FindHighScore().GetScore(),pLCDC->nMin7BitScore*nch,nThresh7,nThresh8));

		// Qualify each score, remember only scores well-above the noise.

		for (unsigned int i = 0; i < SChunk.NElts(); i++)
		{
			CScore &s = SChunk.Ref(i);
			PLanguage pL = s.GetLang();

//			debug(if (s.GetScore()) printf("  raw: lang=%d score=%d cp=%d\n",pL->LanguageID(),s.GetScore(),s.GetCodePage()));

			if ( (s.GetScore() >= nThresh7 && pL->Type() == DETECT_7BIT) ||
				 (s.GetScore() >= nThresh8 && pL->Type() == DETECT_8BIT) )
			{
				debug(printf("    qual: lang=%d score=%d cp=%d\n",pL->LanguageID(),s.GetScore(),s.GetCodePage()));

				// If code page is not already set, detect it, and store
				// the score for this language using the scoreidx slot 
				// for that code page.  Store no score in the slots for
				// other code pages for the same language.

				int idx = 0;

				if (s.GetCodePage() == 0)
					pL->ScoreCodePage (&pStr[nProcessed], nch, s, idx);

				// Remember this score for the overall results

				SAll.Ref(i + idx) += s;
			}
		}

		nProcessed += nch;
	}

	// SAll has entries for each unique { lang ID, code page }
	// with the char count and total raw score (not normalized per char) 
	// for those chunks whose score qualifies as a confident result and
	// that contributed to the entry.

	// Select the top-scoring code page for each language
	// and remove all other code page scores.
	
	debug(printf("Selecting top-scoring code pages\n"));

	SAll.SelectCodePages ();

	// Sort by decreasing score

	SAll.SortByScore ();

	// Build the client return structure
	//		Language ID
	//		Code page
	//		Doc percent 0-100
	//		Confidence 0-100

	int nScoresReturned = 0;

	for (unsigned i = 0; i < SAll.NElts() && nScoresReturned < *pnScores; i++)
	{
		CScore &s = SAll.Ref(i);

		LCDScore R;

		R.nLangID = s.GetLang()->LanguageID();
		R.nCodePage = s.GetCodePage();

		// Percent of doc for which this language scored above the
		// confidence threshhold, even if not 1st place for that chunk.

		R.nDocPercent = (s.GetCharCount() * 100) / nProcessed;

		debug(printf("s.CharCount=%d nProcessed=%d\n", s.GetCharCount(), nProcessed));

		// Confidence is the raw score for all the chunks for which this
		// language was detected above the confidence threshhold, divided
		// by the number of characters in those chunks.
		
		R.nConfidence = s.GetScore() / s.GetCharCount();

		debug(printf("Examining: lang=%d cp=%d docpct=%d\n", R.nLangID, R.nCodePage, R.nDocPercent));

		// Return only scores for languages detected in over a
		// minimum % of the doc.

		if (R.nDocPercent > pLCDC->nDocPctThreshhold)
		{
			debug(printf("  returning score\n"));
			paScores[nScoresReturned++] = R;
		}
	}

	debug(printf("Returning %d scores\n", nScoresReturned));

	*pnScores = nScoresReturned;

	return NO_ERROR;
}

DWORD
LCDetect::DetectW (LPCWSTR pwStr, int nInputChars,
	PLCDScore paScores, int *pnScores, PCLCDConfigure pLCDC) const
// 
// WCHAR (Unicode) version of LCD_Detect.  Score into paScores, one score
// per language.
{
	if (pLCDC == NULL)				// Use the default config if not specified
		pLCDC = &m_LCDConfigureDefault;

	if (*pnScores == 0)
		return NO_ERROR;

	// CScore.NChars() is a USHORT to save space+time, so only this # of chars
	// can be accepted per call or the scoring would overflow.

	nInputChars = min (nInputChars, MAX_INPUT);
	debug(printf("LCD_DetectW: detecting %d chars\n", nInputChars));

	TScores<MAXSCORES> SChunk;		// Raw score for one chunk at a time
	TScores<MAXSCORES> SAll;		// Qualifying scores for final result

	// SChunk is defined outside the loop since it's cheaper to Reset() it
	// than to reconstruct it each time.

	int nProcessed = 0;

	// Process one chunk of the input per loop

	while (nProcessed < nInputChars)
	{
		SChunk.Reset();


		// Process nChunkSize worth of text if that will leave at least
		// another nChunkSize piece for the final pass.  If that would
		// leave a smaller final chunk, go ahead and process the entire
		// remaining input.

		int nch = nInputChars - nProcessed;

		if (nch >= pLCDC->nChunkSize * 2)
			nch = pLCDC->nChunkSize;


		debug(printf("\nStarting chunk: %d ch\n", nch));

		// Compute the raw scores for the chunk.
		// This automatically includes the sub-detected language scores
		// for the Latin/Western group and Unicode groups, <<< when the 
		// group itself >>> scores above the inclusion threshhold.
		// But, the sub-detected scores themselves still need to be
		// qualified.

		ScoreLanguageW (&pwStr[nProcessed], nch, SChunk, pLCDC);

		// Compute the threshhold for inclusion of each score in the
		// overall result.

		int nRelThresh = 1 + (SChunk.FindHighScore().GetScore() * pLCDC->nRelativeThreshhold) / 100;
		int nThresh7 = max (pLCDC->nMin7BitScore * nch, nRelThresh);
		int nThreshU = max (pLCDC->nMinUnicodeScore * nch, nRelThresh);

		debug(printf("scores: nElts=%d rel=%d%% high=%d min=%d min7=%d minU=%d\n", SChunk.NElts(), pLCDC->nRelativeThreshhold, SChunk.FindHighScore().GetScore(), nRelThresh,nThresh7,nThreshU));

		// Qualify each score, remember only scores well-above the noise.

		for (unsigned int i = 0; i < SChunk.NElts(); i++)
		{
			CScore &s = SChunk.Ref(i);
			PLanguage pL = s.GetLang();

			if ( (s.GetScore() >= nThresh7 && pL->Type() == DETECT_7BIT) ||
				 (s.GetScore() >= nThreshU && pL->Type() == DETECT_UNICODE) )
			{
				debug(printf("    using lang=%d score=%d nch=%d\n",pL->LanguageID(),s.GetScore(),s.GetCharCount()));

				// Remember this score for the overall results

				SAll.Ref(i) += s;
			}
		}

		nProcessed += nch;
	}

	// SAll has entries for each unique language with char count and total
	// raw score (not normalized per char) for those chunks whose score
	// qualifies as a confident result.

	// SAll may contain entries only for 7-bit and Unicode languages,
	// at most one entry per unique Win32 language ID
	
	debug(printf("Selecting scores for result:\n"));

	// Sort by decreasing score

	SAll.SortByScore ();

	// Build the client return structure
	//		Language ID
	//		Code page
	//		Doc percent 0-100
	//		Confidence 0-100

	int nScoresReturned = 0;

	for (unsigned i = 0; i < SAll.NElts() && nScoresReturned < *pnScores; i++)
	{
		CScore &s = SAll.Ref(i);

		LCDScore R;

		R.nLangID = s.GetLang()->LanguageID();
		R.nCodePage = s.GetCodePage();

		// Percent of doc for which this language scored above the
		// confidence threshhold, even if not 1st place for that chunk.

		R.nDocPercent = (s.GetCharCount() * 100) / nProcessed;

		// Confidence is the raw score for all the chunks for which this
		// language was detected above the confidence threshhold, divided
		// by the number of characters in those chunks.
		
		R.nConfidence = s.GetScore() / s.GetCharCount();

		debug(printf("  testing: lang=%d nch=%d docpct=%d\n", R.nLangID,s.GetCharCount(),R.nDocPercent));

		// Return only scores for languages detected in over a
		// minimum % of the doc.

		if (R.nDocPercent > pLCDC->nDocPctThreshhold)
		{
			debug(printf("  returning score\n"));
			paScores[nScoresReturned++] = R;
		}
	}

	debug(printf("Returning %d scores\n", nScoresReturned));

	*pnScores = nScoresReturned;

	return NO_ERROR;
}

/****************************************************************/
/****************************************************************/

#if 0
// Export functions

BOOL APIENTRY 
DllMain (HANDLE hM, DWORD ul_reason, LPVOID lpReserved)
{
	switch (ul_reason) {

	case DLL_PROCESS_ATTACH:
		{
			DisableThreadLibraryCalls( (HINSTANCE)hM );

			LCDetect *pLC = new LCDetect ( (HMODULE)hM );
			if (pLC == NULL)
				return FALSE;

			if (pLC->LoadState() != NO_ERROR)
			{
				delete pLC;
				return FALSE;
			}

			g_pLCDetect = pLC;
		}
		return TRUE;

	case DLL_PROCESS_DETACH:
		if (g_pLCDetect != NULL)
			delete (LCDetect *)g_pLCDetect;
		g_pLCDetect = NULL;
		return TRUE;

	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}

	return TRUE;
}
#endif 

extern "C" void WINAPI 
LCD_GetConfig (PLCDConfigure pLCDC)
{
	if (g_pLCDetect)
		*pLCDC = g_pLCDetect->GetConfig();
}

extern "C" DWORD WINAPI
LCD_Detect (LPCSTR pStr, int nInputChars, 
	PLCDScore paScores, int *pnScores,
	PCLCDConfigure pLCDC)
// 
// Score into paScores, one score per language, "qualifying" scores only.
// Return ranked by decreasing score.
{
	if (g_pLCDetect == NULL)
		return ERROR_INVALID_FUNCTION;

	return g_pLCDetect->DetectA(pStr, nInputChars, paScores, pnScores, pLCDC);
}

extern "C" DWORD WINAPI
LCD_DetectW (LPCWSTR wcs, int nInputChars,
	PLCDScore paScores, int *pnScores,
	PCLCDConfigure pLCDC)
{
	if (g_pLCDetect == NULL)
		return ERROR_INVALID_FUNCTION;

	return g_pLCDetect->DetectW(wcs, nInputChars, paScores, pnScores, pLCDC);
}

extern "C" void WINAPI
LCD_SetDebug (int f)
{
#ifdef DEBUG_LCDETECT
	g_fDebug = f;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\lexint_.h ===
/*----------------------------------------------------------------------------
	%%File: lexint_.h
	%%Unit: fechmap
	%%Contact: jpick

	Header file for internal FarEast lexer modules.
----------------------------------------------------------------------------*/

#ifndef LEXINT__H
#define LEXINT__H

#include <windows.h>
#include <stdio.h>
#include <stddef.h>


// REVIEW:  other common internal lexer defs go here.
//

// Token type
//
typedef unsigned char JTK;

// Two-Byte Character Mode Mask
//
#define grfTwoByte		(JTK) 0x80

// Longest *character* sequence (not escape sequence -- this
// is the length of the longest multi-byte character).
//
#define cchSeqMax		4

// Prototypes/Defines for the format validation module
//
#define grfValidateCharMapping		0x0001
#define grfCountCommonChars			0x0002

void ValidateInit(ICET icetIn, DWORD dwFlags);
void ValidateInitAll(DWORD dwFlags);
void ValidateReset(ICET icetIn);
void ValidateResetAll(void);
int  NValidateUch(ICET icetIn, UCHAR uch, BOOL fEoi);
BOOL FValidateCharCount(ICET icetIn, int *lpcMatch);

#endif     // #ifndef LEXINT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mimedb.cpp ===
#include "private.h"

// Table pre-sorted by charset for binary search !!!
const MIMECHARSET MimeCharSet[] =
{
//  { Charset, CodePage, InternetEncoding, Flags }
    { L"_autodetect", 50932, 50932, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"_autodetect_all", 50001, 50001, MIMECONTF_MIME_LATEST},
    { L"_autodetect_kr", 50949, 50949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$ESC", 932, 50221, MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$SIO", 932, 50222, MIMECONTF_MIME_IE4 },
    { L"437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ANSI_X3.4-1986", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1986", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"arabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"arabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ASMO-708", 1256, 708, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"Big5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"Big5-HKSCS", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CCSID00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CCSID00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CCSID01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CCSID01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CCSID01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CCSID01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CCSID01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CCSID01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CCSID01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CCSID01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CCSID01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CCSID01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"chinese", 936, 936, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"cn-big5", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CN-GB", 936, 936, MIMECONTF_MIME_LATEST },
    { L"CP00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CP00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CP01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CP01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CP01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CP01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CP01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CP01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CP01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CP01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CP01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CP01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"cp037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"cp1025", 1251, 21025, MIMECONTF_MIME_LATEST },
    { L"CP1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"cp1256", 1256, 1256, MIMECONTF_MIME_LATEST },
    { L"CP273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"CP278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"CP280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"CP284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"CP285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"cp290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"cp297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"cp367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"cp367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"cp423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"cp424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"cp437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"CP500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"cp819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"cp819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"cp852", 1250, 852, MIMECONTF_MIME_LATEST},
    { L"cp852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"cp855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"cp857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"cp858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"cp860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"cp861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"cp862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"cp863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"cp864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"cp865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"cp866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"cp866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"cp869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"CP870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"CP871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"cp875", 1253, 875, MIMECONTF_MIME_LATEST },
    { L"cp880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"CP905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"cp930", 932, 50930, MIMECONTF_MIME_LATEST },
    { L"cp933", 949, 50933, MIMECONTF_MIME_LATEST },
    { L"cp935", 936, 50935, MIMECONTF_MIME_LATEST },
    { L"cp937", 950, 50937, MIMECONTF_MIME_LATEST },
    { L"cp939", 932, 50939, MIMECONTF_MIME_LATEST },
    { L"csASCII", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"csASCII", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"csbig5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"csEUCKR", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"csEUCPkdFmtJapanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csIBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"csIBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"csIBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"csIBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"csIBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"csIBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"csIBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"csIBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"csIBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"csIBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"csIBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"csIBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"csIBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"csIBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"csIBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"csIBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"csIBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"csIBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"csIBMThai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"csISO2022JP", 932, 50221, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO2022KR", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO58GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"csISOLatin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"csISOLatin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"csISOLatin5", 1251, 28595, MIMECONTF_MIME_IE4},
    { L"csISOLatin9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"csISOLatinArabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"csISOLatinArabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"csISOLatinCyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinGreek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinHebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKOI8R", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKSC56011987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csPC8CodePage437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"csShiftJIS", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csUnicode11UTF7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csWindows31J", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"cyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"DIN_66003", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"DOS-720", 1256, 720, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-862", 1255, 862, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-874", 874, 874, MIMECONTF_MIME_LATEST},
    { L"ebcdic-cp-ar1", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-be", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ca", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ch", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-DK", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-es", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fi", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fr", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gb", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gr", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-he", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-is", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-it", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-nl", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-NO", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-roece", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-se", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-tr", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-us", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-wt", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-yu", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-Cyrillic", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"ebcdic-de-273+euro", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"ebcdic-dk-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-es-284+euro", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fi-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fr-297+euro", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"ebcdic-gb-285+euro", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"ebcdic-international-500+euro", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"ebcdic-is-871+euro", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"ebcdic-it-280+euro", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-JP-kana", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"ebcdic-Latin9--euro", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"ebcdic-no-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-se-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-us-37+euro", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"ECMA-114", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ECMA-114", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ECMA-118", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ELOT_928", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-kr", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"euc-kr", 949, 949, MIMECONTF_MIME_IE4 },
    { L"Extended_UNIX_Code_Packed_Format_for_Japanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"GB_2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"GB18030", 936, 54936, MIMECONTF_MIME_LATEST}, 
    { L"GB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GBK", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"greek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"greek8", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hz-gb-2312", 936, 52936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"IBM00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"IBM00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"IBM01047", 1252, 1047, MIMECONTF_MIME_LATEST },
    { L"IBM01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"IBM01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"IBM01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"IBM01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"IBM01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"IBM01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"IBM01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"IBM01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"IBM01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"IBM01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"IBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"IBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"IBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"IBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"IBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"IBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"IBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"IBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"IBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"IBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"IBM367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"IBM367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"IBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"IBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"IBM437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"IBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ibm737", 1252, 737, MIMECONTF_MIME_LATEST},
    { L"ibm775", 1257, 775, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"IBM852", 1250, 852, MIMECONTF_MIME_LATEST },
    { L"IBM852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"IBM855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"IBM857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"IBM860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"IBM861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"IBM862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"IBM863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"IBM864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"IBM865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"IBM866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"IBM866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"IBM869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"IBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"IBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"IBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"IBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"IBM-Thai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"irv", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 1252,  MIMECONTF_MIME_IE4},
    { L"iso_8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso_8859-1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"iso_8859-1:1987", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso_8859-1:1987", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso_8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso_8859-2:1987", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-3:1988", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-4:1988", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5:1988", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-6", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-6:1987", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6:1987", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-7",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-7:1987",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8:1988", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8-I", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9:1989", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9:1989", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-2022-jp", 932, 50220, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-jpeuc", 932, 51932, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-kr-7", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-7bit", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-8", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"iso-2022-kr-8bit", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 20127, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso8859-1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso8859-1", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-8859-1", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso-8859-11", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-13", 1257, 28603, MIMECONTF_MIME_LATEST},
    { L"iso-8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-3", 1254, 28593, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-6", 1256, 28596, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-7", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ISO-8859-8 Visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"ISO-8859-8 Visual", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"iso-8859-8-i", 1255, 38598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-100", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-ir-100", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-ir-101", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-109", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"iso-ir-110", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-126",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-127", 1256, 28596, MIMECONTF_MIME_LATEST },
    { L"iso-ir-127", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"iso-ir-138", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-144", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-148", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-ir-148", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-149", 949, 949, MIMECONTF_MIME_LATEST},
    { L"iso-ir-58", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-6", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"iso-ir-6", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"Johab", 1361, 1361, MIMECONTF_MIME_LATEST},
    { L"koi", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"koi8", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8r", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8-r", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-ru", 1251, 21866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-u", 1251, 21866, MIMECONTF_MIME_LATEST},
    { L"korean", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601_1987", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks_c_5601-1987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ks_c_5601-1989", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC_5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks-c5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks-c-5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"l1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"l2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"l4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"l5", 1251, 28595, MIMECONTF_MIME_IE4 },
    { L"l9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"latin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"latin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin5", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"latin5", 1254, 1254, MIMECONTF_MIME_IE4},
    { L"latin9", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"macintosh", 1252, 10000, MIMECONTF_MIME_LATEST},
    { L"ms_Kanji", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"NS_4551-1", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"PC-Multilingual-850+euro", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"SEN_850200_B", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"shift_jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"shift-jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"sjis", 932, 932, MIMECONTF_MIME_LATEST},
    { L"Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"TIS-620", 874, 874, MIMECONTF_MIME_LATEST},
    { L"unicode", 1200, 1200, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"unicode-2-0-utf-8",1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicodeFFFE", 1200, 1201, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"us", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"us-ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us-ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"utf-16", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"UTF-16BE", 1200, 1201, MIMECONTF_MIME_LATEST },
    { L"UTF-16LE", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"visual", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"windows-1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1252", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1253", 1253, 1253, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Windows-1254", 1254, 1254, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1255", 1255, 1255, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1256", 1256, 1256, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1257", 1257, 1257, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1258", 1258, 1258, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-874", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-ansi", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Chinese-CNS", 950, 20000, MIMECONTF_MIME_LATEST},
    { L"x-Chinese-Eten", 950, 20002, MIMECONTF_MIME_LATEST},
    { L"x-cp1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-cp1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-cp20001", 1252, 20001, MIMECONTF_MIME_LATEST },
    { L"x-cp20003", 1252, 20003, MIMECONTF_MIME_LATEST },
    { L"x-cp20004", 1252, 20004, MIMECONTF_MIME_LATEST },
    { L"x-cp20005", 1252, 20005, MIMECONTF_MIME_LATEST },
    { L"x-cp20261", 1252, 20261, MIMECONTF_MIME_LATEST },
    { L"x-cp20269", 1252, 20269, MIMECONTF_MIME_LATEST },
    { L"x-cp20936", 1252, 20936, MIMECONTF_MIME_LATEST },
    { L"x-cp20949", 1252, 20949, MIMECONTF_MIME_LATEST },
    { L"x-cp21027", 1252, 21027, MIMECONTF_MIME_LATEST },
    { L"x-cp50227", 1252, 50227, MIMECONTF_MIME_LATEST },
    { L"x-cp50229", 1252, 50229, MIMECONTF_MIME_LATEST },
    { L"X-EBCDIC-JapaneseAndUSCanada", 932, 50931, MIMECONTF_MIME_LATEST },
    { L"X-EBCDIC-KoreanExtended", 949, 20833, MIMECONTF_MIME_LATEST },
    { L"x-euc", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"x-euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Europa", 1252, 29001, MIMECONTF_MIME_LATEST},
    { L"x-IA5", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"x-IA5-German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"x-iscii-as", 57006, 57006, MIMECONTF_MIME_LATEST},
    { L"x-iscii-be", 57003, 57003, MIMECONTF_MIME_LATEST},
    { L"x-iscii-de", 57002, 57002, MIMECONTF_MIME_LATEST},
    { L"x-iscii-gu", 57010, 57010, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ka", 57008, 57008, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ma", 57009, 57009, MIMECONTF_MIME_LATEST},
    { L"x-iscii-or", 57007, 57007, MIMECONTF_MIME_LATEST},
    { L"x-iscii-pa", 57011, 57011, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ta", 57004, 57004, MIMECONTF_MIME_LATEST},
    { L"x-iscii-te", 57005, 57005, MIMECONTF_MIME_LATEST},
    { L"x-mac-arabic", 1256, 10004, MIMECONTF_MIME_LATEST},
    { L"x-mac-ce", 1250, 10029, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesesimp", 936, 10008, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesetrad", 950, 10002, MIMECONTF_MIME_LATEST},
    { L"x-mac-croatian", 1250, 10082, MIMECONTF_MIME_LATEST}, 
    { L"x-mac-cyrillic", 1251, 10007, MIMECONTF_MIME_LATEST},
    { L"x-mac-greek", 1253, 10006, MIMECONTF_MIME_LATEST},
    { L"x-mac-hebrew", 1255, 10005, MIMECONTF_MIME_LATEST},
    { L"x-mac-icelandic", 1252, 10079, MIMECONTF_MIME_LATEST},
    { L"x-mac-japanese", 932, 10001, MIMECONTF_MIME_LATEST},
    { L"x-mac-korean", 949, 10003, MIMECONTF_MIME_LATEST},
    { L"x-mac-romanian", 1250, 10010, MIMECONTF_MIME_LATEST},
    { L"x-mac-thai", 874, 10021, MIMECONTF_MIME_LATEST},
    { L"x-mac-turkish", 1254, 10081, MIMECONTF_MIME_LATEST},
    { L"x-mac-ukrainian", 1251, 10017, MIMECONTF_MIME_LATEST},
    { L"x-ms-cp932", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-sjis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"x-unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST},
    { L"x-unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-unicode-2-0-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-user-defined", 50000, 50000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-x-big5", 950, 950, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
//  { Charset, CodePage, InternetEncoding, Flags }
};

// Hard code sorted table by code page description and family code page.

MIMECODEPAGE MimeCodePage[] =
{
//  { CodePage, HeaderCharset, BodyCharset, WebCharset, FixedWidthFont, ProportionalFont, Description, FamilyCodePage, Flags }
    { 864, NULL, L"IBM864", NULL, 0, 0, IDS_DESC_864, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 708, NULL, L"ASMO-708", NULL, 0, 0, IDS_DESC_708, 1256, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 708, NULL, L"ASMO-708", NULL, 0, 0, IDS_DESC_708, 1256, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 51256, NULL, L"_autodetect_arabic", L"windows-1256", 0,  0, IDS_DESC_51256, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT },
    { 720, NULL, L"DOS-720", NULL, 0, 0, IDS_DESC_720, 1256, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 720, NULL, L"DOS-720", NULL, 0, 0, IDS_DESC_720, 1256, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28596, NULL, L"iso-8859-6", NULL, 0, 0, IDS_DESC_28596, 1256, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10004, NULL, L"x-mac-arabic", NULL, 0, 0, IDS_DESC_10004, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1256, NULL, L"windows-1256", NULL, IDS_FONT_ARABIC_FIXED, IDS_FONT_ARABIC_PROP, IDS_DESC_1256, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1256, NULL, L"windows-1256", L"windows-1256", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1256, 0, 0x00000707| MIMECONTF_MIME_IE4},
    { 50001, NULL, L"_autodetect_all", NULL, 0, 0, IDS_DESC_50001, 0, 0x00000007|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT},
    { 775, NULL, L"ibm775", NULL, 0, 0, IDS_DESC_775, 1257, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28594, NULL, L"iso-8859-4", NULL, 0, 0, IDS_DESC_28594, 1257, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28594, NULL, L"iso-8859-4", NULL, 0, 0, IDS_DESC_28594, 1257, 0x00000301|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1257, L"windows-1257", L"windows-1257", L"windows-1257", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1257, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1257, NULL, L"iso-8859-4", L"windows-1257", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1257, 0, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 852, NULL, L"ibm852", NULL, 0, 0, IDS_DESC_852, 1250, 0x00000202|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28592, NULL, L"iso-8859-2", NULL, 0, 0, IDS_DESC_28592, 1250, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10029, NULL, L"x-mac-ce", NULL, 0, 0, IDS_DESC_10029, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1250, L"windows-1250", L"iso-8859-2", L"windows-1250", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1250, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1250, NULL, L"iso-8859-2", L"windows-1250", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1250, 0, 0x00000303|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50936, NULL, L"_autodetect_chs", NULL, 0, 0, IDS_DESC_50936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_IMPORT },
    { 51936, NULL, L"EUC-CN", NULL, 0, 0, IDS_DESC_51936, 936, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_EXPORT|MIMECONTF_IMPORT},
    { 54936, NULL, L"GB18030", NULL, IDS_FONT_CHINESE_FIXED, IDS_FONT_CHINESE_PROP, IDS_DESC_54936, 936, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 936, NULL, L"gb2312", NULL, IDS_FONT_CHINESE_FIXED, IDS_FONT_CHINESE_PROP, IDS_DESC_936, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },    
    { 20936, NULL, L"x-cp20936", NULL, 0, 0, IDS_DESC_20936, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 52936, NULL, L"hz-gb-2312", NULL, 0, 0, IDS_DESC_52936, 936, 0x00000303|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50227, NULL, L"x-cp50227", NULL, 0, 0, IDS_DESC_50227, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10008, NULL, L"x-mac-chinesesimp", NULL, 0, 0, IDS_DESC_10008, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50950, NULL, L"_autodetect_cht", NULL, 0, 0, IDS_DESC_50950, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT},
    { 950, NULL, L"big5", NULL, IDS_FONT_TAIWAN_FIXED, IDS_FONT_TAIWAN_PROP, IDS_DESC_950, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20000, NULL, L"x-Chinese-CNS", NULL, 0, 0, IDS_DESC_20000, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20002, NULL, L"x-Chinese-Eten", NULL, 0, 0, IDS_DESC_20002, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50229, NULL, L"x-cp50229", NULL, 0, 0, IDS_DESC_50229, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10002, NULL, L"x-mac-chinesetrad", NULL, 0, 0, IDS_DESC_10002, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10082, NULL, L"x-mac-croatian", NULL, 0, 0, IDS_DESC_10082, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 51251, NULL, L"_auto_detect_cyrillic", L"windows-1251", 0, 0, IDS_DESC_51251, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT},
    { 866, NULL, L"cp866", NULL, 0, 0, IDS_DESC_866, 1251, 0x00000202|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28595, NULL, L"iso-8859-5", NULL, 0, 0, IDS_DESC_28595, 1251, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20866, NULL, L"koi8-r", NULL, 0, 0, IDS_DESC_20866, 1251, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 21866, NULL, L"koi8-u", NULL, 0, 0, IDS_DESC_21866, 1251, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 21866, NULL, L"koi8-ru", NULL, 0, 0, IDS_DESC_21866, 1251, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10007, NULL, L"x-mac-cyrillic", NULL, 0, 0, IDS_DESC_10007, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1251, L"windows-1251", L"koi8-r", L"windows-1251", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1251, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1251, NULL, L"koi8-r", L"windows-1251", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1251, 0, 0x00000303|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28603, NULL, L"iso-8859-13", NULL, 0, 0, IDS_DESC_28603, 1257, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 29001, NULL, L"x-Europa", NULL, 0, 0, IDS_DESC_29001, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 21027, NULL, L"x-cp21027", NULL, 0, 0, IDS_DESC_21027, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 863, NULL, L"IBM863", NULL, 0, 0, IDS_DESC_863, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20106, NULL, L"x-IA5-German", NULL, 0, 0, IDS_DESC_20106, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 51253, NULL, L"_auto_detect_greek", L"windows-1253", 0, 0, IDS_DESC_51253, 1253, MIMECONTF_MIME_LATEST| MIMECONTF_IMPORT},
    { 737, NULL, L"ibm737", NULL, 0, 0, IDS_DESC_737, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28597, NULL, L"iso-8859-7", NULL, 0, 0, IDS_DESC_28597, 1253, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10006, NULL, L"x-mac-greek", NULL, 0, 0, IDS_DESC_10006, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1253, L"windows-1253", L"iso-8859-7", L"windows-1253", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1253, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1253, NULL, L"iso-8859-7", L"windows-1253", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1253, 0, 0x00000303|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 869, NULL, L"ibm869", NULL, 0, 0, IDS_DESC_869, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 862, NULL, L"DOS-862", NULL, 0, 0, IDS_DESC_862, 1255, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 862, NULL, L"DOS-862", NULL, 0, 0, IDS_DESC_862, 1255, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 38598, NULL, L"iso-8859-8-i", NULL, 0, 0, IDS_DESC_38598, 1255, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28598, NULL, L"iso-8859-8", NULL, 0, 0, IDS_DESC_28598, 1255, 0x00000606|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10005, NULL, L"x-mac-hebrew", NULL, 0, 0, IDS_DESC_10005, 1255, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1255, NULL, L"windows-1255", NULL, IDS_FONT_HEBREW_FIXED, IDS_FONT_HEBREW_PROP, IDS_DESC_1255, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1255, NULL, L"iso-8859-8", L"windows-1255", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1255, 0, 0x00000707|MIMECONTF_MIME_IE4},
    { 20003, NULL, L"x-cp20003", NULL, 0, 0, IDS_DESC_20003, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20420, NULL, L"IBM420", NULL, 0, 0, IDS_DESC_20420, 1256, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20880, NULL, L"IBM880", NULL, 0, 0, IDS_DESC_20880, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 21025, NULL, L"cp1025", NULL, 0, 0, IDS_DESC_21025, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20277, NULL, L"IBM277", NULL, 0, 0, IDS_DESC_20277, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1142, NULL, L"IBM01142", NULL, 0, 0, IDS_DESC_1142, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20278, NULL, L"IBM278", NULL, 0, 0, IDS_DESC_20278, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1143, NULL, L"IBM01143", NULL, 0, 0, IDS_DESC_1143, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20297, NULL, L"IBM297", NULL, 0, 0, IDS_DESC_20297, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1147, NULL, L"IBM01147", NULL, 0, 0, IDS_DESC_1147, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20273, NULL, L"IBM273", NULL, 0, 0, IDS_DESC_20273, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1141, NULL, L"IBM01141", NULL, 0, 0, IDS_DESC_1141, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20423, NULL, L"IBM423", NULL, 0, 0, IDS_DESC_20423, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 875, NULL, L"cp875", NULL, 0, 0, IDS_DESC_875, 1253, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20424, NULL, L"IBM424", NULL, 0, 0, IDS_DESC_20424, 1255, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20871, NULL, L"IBM871", NULL, 0, 0, IDS_DESC_20871, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1149, NULL, L"IBM01149", NULL, 0, 0, IDS_DESC_1149, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 500, NULL, L"IBM500", NULL, 0, 0, IDS_DESC_500, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1148, NULL, L"IBM01148", NULL, 0, 0, IDS_DESC_1148, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20280, NULL, L"IBM280", NULL, 0, 0, IDS_DESC_20280, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1144, NULL, L"IBM01144", NULL, 0, 0, IDS_DESC_1144, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50930, NULL, L"cp930", NULL, 0, 0, IDS_DESC_50930, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50939, NULL, L"cp939", NULL, 0, 0, IDS_DESC_50939, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50931, NULL, L"x-EBCDIC-JapaneseAndUSCanada", NULL, 0, 0, IDS_DESC_50931, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20290, NULL, L"IBM290", NULL, 0, 0, IDS_DESC_20290, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50933, NULL, L"cp933", NULL, 0, 0, IDS_DESC_50933, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20833, NULL, L"x-EBCDIC-KoreanExtended", NULL, 0, 0, IDS_DESC_20833, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 870, NULL, L"IBM870", NULL, 0, 0, IDS_DESC_870, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50935, NULL, L"cp935", NULL, 0, 0, IDS_DESC_50935, 936, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20284, NULL, L"IBM284", NULL, 0, 0, IDS_DESC_20284, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1145, NULL, L"IBM01145", NULL, 0, 0, IDS_DESC_1145, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20838, NULL, L"IBM-Thai", NULL, 0, 0, IDS_DESC_20838, 874, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50937, NULL, L"cp937", NULL, 0, 0, IDS_DESC_50937, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20905, NULL, L"IBM905", NULL, 0, 0, IDS_DESC_20905, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1026, NULL, L"IBM1026", NULL, 0, 0, IDS_DESC_1026, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20285, NULL, L"IBM285", NULL, 0, 0, IDS_DESC_20285, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1146, NULL, L"IBM01146", NULL, 0, 0, IDS_DESC_1146, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 37, NULL, L"IBM037", NULL, 0, 0, IDS_DESC_37, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1140, NULL, L"IBM01140", NULL, 0, 0, IDS_DESC_1140, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1047, NULL, L"IBM01047", NULL, 0, 0, IDS_DESC_1047, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20924, NULL, L"IBM00924", NULL, 0, 0, IDS_DESC_20924, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },    
    { 861, NULL, L"ibm861", NULL, 0, 0, IDS_DESC_861, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 10079, NULL, L"x-mac-icelandic", NULL, 0, 0, IDS_DESC_10079, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57006, NULL, L"x-iscii-as", NULL, 0, 0, IDS_DESC_57006, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57003, NULL, L"x-iscii-be", NULL, 0, 0, IDS_DESC_57003, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57002, NULL, L"x-iscii-de", NULL, IDS_FONT_DEVANAGARI_FIXED, IDS_FONT_DEVANAGARI_PROP, IDS_DESC_57002, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57010, NULL, L"x-iscii-gu", NULL, 0, 0, IDS_DESC_57010, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57008, NULL, L"x-iscii-ka", NULL, 0, 0, IDS_DESC_57008, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57009, NULL, L"x-iscii-ma", NULL, 0, 0, IDS_DESC_57009, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57007, NULL, L"x-iscii-or", NULL, 0, 0, IDS_DESC_57007, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57011, NULL, L"x-iscii-pa", NULL, 0, 0, IDS_DESC_57011, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57004, NULL, L"x-iscii-ta", NULL, IDS_FONT_TAMIL_FIXED, IDS_FONT_TAMIL_PROP, IDS_DESC_57004, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 57005, NULL, L"x-iscii-te", NULL, 0, 0, IDS_DESC_57005, 0, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20269, NULL, L"x-cp20269", NULL, 0, 0, IDS_DESC_20269, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50932, NULL, L"_autodetect", NULL, 0, 0, IDS_DESC_50932, 932, 0x00000007|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT},
    { 51932, NULL, L"euc-jp", NULL, 0, 0, IDS_DESC_51932, 932, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50220, NULL, L"iso-2022-jp", NULL, 0, 0, IDS_DESC_50220, 932, 0x00000101|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20932, NULL, L"EUC-JP", NULL, 0, 0, IDS_DESC_20932, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 50221, NULL, L"iso-2022-jp", L"csISO2022JP", 0, 0, IDS_DESC_50221, 932, 0x00000301|MIMECONTF_MIME_LATEST|MIMECONTF_EXPORT},
    { 50221, NULL, L"_iso-2022-jp$ESC", L"csISO2022JP", 0, 0, IDS_DESC_50221, 932, 0x00000301|MIMECONTF_MIME_IE4|MIMECONTF_EXPORT},
    { 50222, NULL, L"iso-2022-jp", NULL, 0, 0, IDS_DESC_50222, 932, MIMECONTF_MIME_LATEST|MIMECONTF_EXPORT},
    { 50222, NULL, L"_iso-2022-jp$SIO", L"iso-2022-jp", 0, 0, IDS_DESC_50222, 932, MIMECONTF_MIME_IE4|MIMECONTF_EXPORT},
    { 10001, NULL, L"x-mac-japanese", NULL, 0, 0, IDS_DESC_10001, 932, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 932, NULL, L"iso-2022-jp", L"shift_jis", IDS_FONT_JAPANESE_FIXED, IDS_FONT_JAPANESE_PROP, IDS_DESC_932, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 949, NULL, L"ks_c_5601-1987", NULL, IDS_FONT_KOREAN_FIXED, IDS_FONT_KOREAN_PROP, IDS_DESC_949, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 949, L"euc-kr", L"euc-kr", L"ks_c_5601-1987", IDS_FONT_KOREAN_FIXED4, IDS_FONT_KOREAN_PROP4, IDS_DESC_949, 0, 0x00000707| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50949, NULL, L"_autodetect_kr", NULL, 0, 0, IDS_DESC_50949, 949, 0x00000001|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT},
    { 51949, NULL, L"euc-kr", NULL, 0, 0, IDS_DESC_51949, 949, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT|MIMECONTF_MAILNEWS|MIMECONTF_SAVABLE_MAILNEWS},
    { 51949, NULL, L"euc-kr", NULL, 0, 0, IDS_DESC_51949, 949, 0x00000000| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50225, L"euc-kr", L"iso-2022-kr", L"iso-2022-kr", 0, 0, IDS_DESC_50225, 949, 0x00000001|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 50225, NULL, L"iso-2022-kr", L"iso-2022-kr", 0, 0, IDS_DESC_50225, 949, 0x00000101| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1361, NULL, L"Johab", NULL,IDS_FONT_KOREAN_FIXED, IDS_FONT_KOREAN_PROP, IDS_DESC_1361, 949, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10003, NULL, L"x-mac-korean", NULL, 0, 0, IDS_DESC_10003, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20949, NULL, L"x-cp20949", NULL, 0, 0, IDS_DESC_20949, 949, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28593, NULL, L"iso-8859-3", NULL, 0, 0, IDS_DESC_28593, 1254, 0x00000501|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 28605, NULL, L"iso-8859-15", NULL, 0, 0, IDS_DESC_28605, 1252, 0x00000701|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 865, NULL, L"IBM865", NULL, 0, 0, IDS_DESC_865, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20108, NULL, L"x-IA5-Norwegian", NULL, 0, 0, IDS_DESC_20108, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 855, NULL, L"IBM855", NULL, 0, 0, IDS_DESC_855, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 437, NULL, L"IBM437", NULL, 0, 0, IDS_DESC_437, 1252, 0x00000000|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 858, NULL, L"IBM00858", NULL, 0, 0, IDS_DESC_858, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 860, NULL, L"IBM860", NULL, 0, 0, IDS_DESC_860, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10010, NULL, L"x-mac-romanian", NULL, 0, 0, IDS_DESC_10010, 1250, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20107, NULL, L"x-IA5-Swedish", NULL, 0, 0, IDS_DESC_20107, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20261, NULL, L"x-cp20261", NULL, 0, 0, IDS_DESC_20261, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20001, NULL, L"x-cp20001", NULL, 0, 0, IDS_DESC_20001, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20004, NULL, L"x-cp20004", NULL, 0, 0, IDS_DESC_20004, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },    
    { 10021, NULL, L"x-mac-thai", NULL, IDS_FONT_THAI_FIXED, IDS_FONT_THAI_PROP, IDS_DESC_10021, 874, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 874, NULL, L"windows-874", NULL, IDS_FONT_THAI_FIXED, IDS_FONT_THAI_PROP, IDS_DESC_874, 0, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 874, NULL, L"windows-874", NULL, IDS_FONT_THAI_FIXED2, IDS_FONT_THAI_PROP2, IDS_DESC_874, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 857, NULL, L"ibm857", NULL, 0, 0, IDS_DESC_857, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28599, NULL, L"iso-8859-9", NULL, 0, 0, IDS_DESC_28599, 1254, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_IMPORT|MIMECONTF_EXPORT},    
    { 10081, NULL, L"x-mac-turkish", NULL, 0, 0, IDS_DESC_10081, 1254, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1254, L"windows-1254", L"iso-8859-9", L"windows-1254", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1254, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10017, NULL, L"x-mac-ukrainian", NULL, 0, 0, IDS_DESC_10017, 1251, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1254, NULL, L"iso-8859-9", L"iso-8859-9", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1254, 0, 0x00000707|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1200, NULL, L"unicode", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1200, 0, 0x00000204|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1201, NULL, L"unicodeFFFE",   NULL, 0, 0, IDS_DESC_1201, 1200, 0x00000000|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 65000, NULL, L"utf-7", NULL, 0, 0, IDS_DESC_65000, 1200, 0x00000101|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 65001, NULL, L"utf-8", NULL, 0, 0, IDS_DESC_65001, 1200, 0x00000303|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20127, NULL, L"us-ascii", NULL, 0, 0, IDS_DESC_20127, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT|MIMECONTF_MAILNEWS|MIMECONTF_SAVABLE_MAILNEWS},
    { 50000, NULL, L"x-user-defined", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_UNICODE_PROP, IDS_DESC_50000, 0, 0x00000707|MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 1258, NULL, L"windows-1258", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1258, 0, 0x00000303|MIMECONTF_MIME_LATEST|MIMECONTF_MIME_IE4|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 20005, NULL, L"x-cp20005", NULL, 0, 0, IDS_DESC_20005, 950, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1252, NULL, L"iso-8859-1", NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1252_IE4, 0, 0x00000707| MIMECONTF_MIME_IE4},
    { 850, NULL, L"ibm850", NULL, 0, 0, IDS_DESC_850, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 20105, NULL, L"x-IA5", NULL, 0, 0, IDS_DESC_20105, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 28591, NULL, L"iso-8859-1", NULL, 0, 0, IDS_DESC_28591, 1252, 0x00000703|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 10000, NULL, L"macintosh", NULL, 0, 0, IDS_DESC_10000, 1252, MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT },
    { 1252, L"Windows-1252", L"iso-8859-1", L"Windows-1252", IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1252, 0, 0x00000707|MIMECONTF_MIME_LATEST|MIMECONTF_IMPORT|MIMECONTF_EXPORT},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0},
//  { CodePage, HeaderCharset, BodyCharset, WebCharset, FixedWidthFont, ProportionalFont, Description, FamilyCodePage, Flags }

}; 


#ifdef UNIX
/* Convert from little endian to big endian format */
#define CONVERTLONG(a,b,c,d) (((unsigned long )a) + \
                           ((unsigned long )b << 8) + \
                           ((unsigned long )c << 16) + \
                           ((unsigned long )d << 24))
#endif /* UNIX */

//
//  Globals
//
CMimeDatabase *g_pMimeDatabase = NULL;

//
//  CMimeDatabase implementation
//
STDAPI CMimeDatabase::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
    HRESULT hr = S_OK;
    if (pcCodePage)
    {
        *pcCodePage = 0;
        for (int i=0;i<ARRAYSIZE(MimeCodePage);i++)
        {
            if (MimeCodePage[i].dwFlags & dwMimeSource)
               (*pcCodePage)++;
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

STDAPI CMimeDatabase::GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo )
{
    int idx;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfo called."));

    for (idx=0; idx < ARRAYSIZE(MimeCodePage); idx++)
    {
        if ((uiCodePage == MimeCodePage[idx].uiCodePage) &&
            (MimeCodePage[idx].dwFlags & dwMimeSource))
            break;
    }

    if (idx < ARRAYSIZE(MimeCodePage))
    {
        hr = GetCodePageInfoWithIndex(idx, LangId, pcpInfo);
    }

    return hr;
}


STDAPI CMimeDatabase::GetCodePageInfoWithIndex(UINT uidx, LANGID LangId, PMIMECPINFO pcpInfo)
{    
    HRESULT hr = E_FAIL;
    LANGID langid = LangId;
    CHARSETINFO rCharsetInfo;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfoWithIndex called."));

    if (uidx >= ARRAYSIZE(MimeCodePage))
        return hr;  

    if (!_LoadStringExW(g_hInst, MimeCodePage[uidx].uidDescription, pcpInfo->wszDescription, MAX_MIMECP_NAME, langid))
    {
            // Last try, switch to English, US
            langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            if (!_LoadStringExW(g_hInst, MimeCodePage[uidx].uidDescription, pcpInfo->wszDescription, MAX_MIMECP_NAME, langid))
                return hr;
    }

    if ((0 == MimeCodePage[uidx].uidFixedWidthFont || 0 == MimeCodePage[uidx].uidProportionalFont))         
    {
        pcpInfo->wszFixedWidthFont[0] = 0;
        pcpInfo->wszProportionalFont[0] = 0;

        if (0 != MimeCodePage[uidx].uiFamilyCodePage)
        {
            for (UINT j = 0; j < ARRAYSIZE(MimeCodePage); j++)
            {
                if (MimeCodePage[uidx].uiFamilyCodePage == MimeCodePage[j].uiCodePage)
                {
                    _LoadStringExW(g_hInst, MimeCodePage[j].uidFixedWidthFont, pcpInfo->wszFixedWidthFont, MAX_MIMEFACE_NAME, langid);
                    _LoadStringExW(g_hInst, MimeCodePage[j].uidProportionalFont, pcpInfo->wszProportionalFont, MAX_MIMEFACE_NAME, langid);
                    break;
                }
            }
        }

    }
    else
    {
        _LoadStringExW(g_hInst, MimeCodePage[uidx].uidFixedWidthFont, pcpInfo->wszFixedWidthFont, MAX_MIMEFACE_NAME, langid);
        _LoadStringExW(g_hInst, MimeCodePage[uidx].uidProportionalFont, pcpInfo->wszProportionalFont, MAX_MIMEFACE_NAME,langid);
    }


    // Copy internal buffer information
    pcpInfo->dwFlags = MimeCodePage[uidx].dwFlags;
    pcpInfo->uiCodePage = MimeCodePage[uidx].uiCodePage;
    if (MimeCodePage[uidx].uiFamilyCodePage)
        pcpInfo->uiFamilyCodePage = MimeCodePage[uidx].uiFamilyCodePage;
    else
        pcpInfo->uiFamilyCodePage = MimeCodePage[uidx].uiCodePage;
    MLStrCpyNW(pcpInfo->wszBodyCharset, MimeCodePage[uidx].wszBodyCharset, MAX_MIMECSET_NAME);

    if (MimeCodePage[uidx].wszWebCharset)
        MLStrCpyNW(pcpInfo->wszWebCharset, MimeCodePage[uidx].wszWebCharset, MAX_MIMECSET_NAME);
    else
        MLStrCpyNW(pcpInfo->wszWebCharset, MimeCodePage[uidx].wszBodyCharset, MAX_MIMECSET_NAME);

    if (MimeCodePage[uidx].wszHeaderCharset)
        MLStrCpyNW(pcpInfo->wszHeaderCharset, MimeCodePage[uidx].wszHeaderCharset, MAX_MIMECSET_NAME);
    else
        MLStrCpyNW(pcpInfo->wszHeaderCharset, MimeCodePage[uidx].wszBodyCharset, MAX_MIMECSET_NAME);

    if (0 != TranslateCharsetInfo(IntToPtr_(LPDWORD, pcpInfo->uiFamilyCodePage), &rCharsetInfo, TCI_SRCCODEPAGE))
        pcpInfo->bGDICharset = (BYTE)rCharsetInfo.ciCharset;
    else
        pcpInfo->bGDICharset = DEFAULT_CHARSET;

    if (1200 == pcpInfo->uiFamilyCodePage || 50000 == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiFamilyCodePage)) // 50000 means user defined
    {
       if (TRUE == CheckFont(pcpInfo->bGDICharset))
       {
           if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID_NLS;
           else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID_NLS;
       }
       else
       {
           if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
           else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
              pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
       }

    }

        
    hr = S_OK;

    return hr;
}


STDAPI CMimeDatabase::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    int idx = -1;
    int iStart, iEnd, iMiddle, iCmpResult;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCharsetInfo called."));

    iStart = 0;
    iEnd = ARRAYSIZE(MimeCharSet) - 1;

    while (iStart <= iEnd)
    {
        iMiddle = (iStart + iEnd) / 2;
        iCmpResult = MLStrCmpIW(Charset, MimeCharSet[iMiddle].szCharset);
        if (iCmpResult < 0)
            iEnd = iMiddle - 1;
        else if (iCmpResult > 0)
            iStart = iMiddle + 1;
        else
        {
            if (MimeCharSet[iMiddle].dwFlags & dwMimeSource)
            {
                idx = iMiddle;                
            }
            else
                // !!! Tricky, search neighbors for correct data which matches MIME version
                // Only works for now, if we have data over two versions, we have to change here
                if ((iMiddle+1 <= iEnd) && 
                    MimeCharSet[iMiddle+1].dwFlags & dwMimeSource &&
                    !MLStrCmpIW(Charset, MimeCharSet[iMiddle+1].szCharset))
                {
                    idx = iMiddle+1;
                }
                else 
                    if ((iMiddle-1 >= 0) &&
                        MimeCharSet[iMiddle-1].dwFlags & dwMimeSource &&
                        !MLStrCmpIW(Charset, MimeCharSet[iMiddle-1].szCharset))
                    {
                
                        idx = iMiddle-1;
                    }
                    else
                    {
                        idx = ARRAYSIZE(MimeCharSet);
                    }
            break;
        }
    }


    if (0 <= idx && idx < ARRAYSIZE(MimeCharSet) && pcsetInfo )
    {
        MLStrCpyNW(pcsetInfo->wszCharset, MimeCharSet[idx].szCharset, MAX_MIMECSET_NAME);
        pcsetInfo->uiCodePage = MimeCharSet[idx].uiCodePage;
        pcsetInfo->uiInternetEncoding = MimeCharSet[idx].uiInternetEncoding;
        hr = S_OK;
    }

    return hr;
}

int CALLBACK EnumFontFamExProc(ENUMLOGFONTEX *lpelf, NEWTEXTMETRICEX *lpntm, int iFontType, LPARAM lParam)
{
    LOGFONT *lplf;
    BOOL *lpfOK = (BOOL *)lParam;

    lplf = &(lpelf->elfLogFont);
    // We don't use non TrueType fonts
    if (iFontType == DEVICE_FONTTYPE || iFontType == RASTER_FONTTYPE)
        return 1;   // keep going but don't use this font

    // We don't use the SYMBOL, Mac Charset fonts
    if(lplf->lfCharSet == SYMBOL_CHARSET || lplf->lfCharSet == MAC_CHARSET)
        return 1;

    // We don't handle vertical fonts
    if (TEXT('@') == lplf->lfFaceName[0])
        return 1;

    *lpfOK = TRUE;
    return 0;       // stop enumeration if we find any
}

BOOL CMimeDatabase::CheckFont(BYTE bGDICharset)
{
    BOOL fRet = FALSE;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::CheckFont called."));

    // It is safe to assume that system always support DEFAULT_CHAR and ANSI_CHARSET
    if ((DEFAULT_CHARSET == bGDICharset) || (ANSI_CHARSET == bGDICharset))
        fRet = TRUE;
    else
    {
        HDC     hDC;
        LOGFONT lf;
        HWND    hWnd;

        hWnd = GetTopWindow(GetDesktopWindow());
        hDC = GetDC(hWnd);

        if (NULL != hDC)
        {
            lf.lfFaceName[0] = TEXT('\0');
            lf.lfPitchAndFamily = 0;
            lf.lfCharSet = bGDICharset;
            EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)&fRet, 0);
        }
        ReleaseDC(hWnd, hDC);
    }
    return fRet;
}

// validates all cps that are in the same
// family of the given codepage
STDAPI CMimeDatabase::ValidateCP(UINT uiCodePage)
{
    UINT i;

    for (i = 0; i < ARRAYSIZE(MimeCodePage); i++)
    {
        if (MimeCodePage[i].uiFamilyCodePage == uiCodePage)
            MimeCodePage[i].dwFlags |=  MIMECONTF_VALID|MIMECONTF_VALID_NLS;
    }
        
    return S_OK; // never fail?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mimedb.h ===
#ifndef _MIMEDB_H_
#define _MIMEDB_H_

#define ALLOC_BLOCK             10

typedef struct tagMIMECODEPAGE {
   UINT    uiCodePage;
   LPWSTR  wszHeaderCharset;
   LPWSTR  wszBodyCharset;
   LPWSTR  wszWebCharset;
   UINT    uidFixedWidthFont;  
   UINT    uidProportionalFont;
   UINT    uidDescription;     
   UINT    uiFamilyCodePage;
   DWORD   dwFlags;
} MIMECODEPAGE;

typedef struct tagMIMEREGCHARSET
{
    LPCWSTR szCharset;
    UINT uiCodePage;
    UINT uiInternetEncoding;
    DWORD   dwFlags;
}   MIMECHARSET;

typedef struct tagMIMERFC1766
{
    LCID    LcId;
    LPCWSTR szRfc1766;
    UINT    uidLCID;
    DWORD   dwFlags;
}   MIMERFC1766;


extern MIMECODEPAGE MimeCodePage[];
extern const MIMERFC1766  MimeRfc1766[];
extern const MIMECHARSET  MimeCharSet[];


#ifdef  __cplusplus
//
//  CMimeDatabase declaration without IMimeDatabase Interface
//
class CMimeDatabase     // This would support IMimeDatabase when available
{
    MIMECONTF dwMimeSource;
public:
    // Possible IMimeDatabase methods
    STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    STDMETHODIMP EnumCodePageInfo(void);
    STDMETHODIMP GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCodePageInfoWithIndex(UINT uidx, LANGID LangId, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    STDMETHODIMP ValidateCP(UINT uiCodePage);
    STDMETHODIMP SetMimeDBSource(MIMECONTF dwSource)
    {        
        if ((dwSource != MIMECONTF_MIME_IE4) &&
            (dwSource != MIMECONTF_MIME_LATEST) &&
            (dwSource != MIMECONTF_MIME_REGISTRY))
        {
            return E_INVALIDARG;
        }
        dwMimeSource = dwSource;
        return S_OK;
    }
    CMimeDatabase(void)
    {
        dwMimeSource = MIMECONTF_MIME_LATEST;
    }


protected:
    void FreeMimeDatabase(void);
    BOOL CheckFont(BYTE bGDICharset);


};

//
//  Globals
//
extern CMimeDatabase    *g_pMimeDatabase;
//
//  CMimeDatabase declaration without IMimeDatabase Interface
//

class CMimeDatabaseReg     // This would support IMimeDatabase when available
{
public:
    // Possible IMimeDatabase methods
    STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    STDMETHODIMP EnumCodePageInfo(void);
    STDMETHODIMP GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCodePageInfoWithIndex(UINT uidx, PMIMECPINFO pcpInfo);
    STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    STDMETHODIMP ValidateCP(UINT uiCodePage);
    STDMETHODIMP LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength);
    STDMETHODIMP LcidToRfc1766W(LCID Locale, LPWSTR pwszRfc1766, int nChar);
    STDMETHODIMP Rfc1766ToLcidA(PLCID pLocale, LPCSTR pszRfc1766);
    STDMETHODIMP Rfc1766ToLcidW(PLCID pLocale, LPCWSTR pwszRfc1766);
    void EnsureRfc1766Table(void);

    // Constructor & Destructor
    CMimeDatabaseReg();
    ~CMimeDatabaseReg();

protected:
    void BuildCodePageMimeDatabase(void);
    void BuildCharsetMimeDatabase(void);
    void FreeMimeDatabase(void);
    int FindCodePageFromCache(UINT uiCodePage);
    BOOL FindCodePageFromRegistry(UINT uiCodePage, MIMECPINFO *pCPInfo);
    int FindCharsetFromCache(BSTR Charset);
    int FindCharsetFromRegistry(BSTR Charset, BOOL fFromAlias);
    BOOL CheckFont(BYTE bGDICharset);
    void QSortCodePageInfo(LONG left, LONG right);
    void QSortCharsetInfo(LONG left, LONG right);
    void BuildRfc1766Table(void);
    void FreeRfc1766Table(void);

    CRITICAL_SECTION _cs;

    BOOL            _fAllCPCached;    
    PMIMECPINFO     _pCodePage;
    UINT            _cCodePage;
    UINT            _cMaxCodePage;
    PMIMECSETINFO   _pCharset;
    UINT            _cCharset;
    UINT            _cMaxCharset;
};

extern CMimeDatabaseReg    *g_pMimeDatabaseReg;

#endif  // __cplusplus


#endif  // _MIMEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlang.cpp ===
#include "private.h"
#include "mlmain.h"
#include "cpdetect.h"
#include "codepage.h"

STDAPI CMultiLanguage::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetNumberOfCodePageInfo(pcCodePage);
    else
        return E_FAIL;
}

STDAPI CMultiLanguage::GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo)
{

    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetCodePageInfo(uiCodePage, GetSystemDefaultLangID(), pcpInfo);
    else
        return E_FAIL;
}

STDAPI CMultiLanguage::GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage)
{
        HRESULT hr = S_OK;
        int idx = 0;

        DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetFamilyCodePage called."));

        while(MimeCodePage[idx].uiCodePage)
        {
            if ((uiCodePage == MimeCodePage[idx].uiCodePage) &&
                (MimeCodePage[idx].dwFlags & dwMimeSource))
                break;
            idx++;
        }

        if (MimeCodePage[idx].uiCodePage)
        {
            if (MimeCodePage[idx].uiFamilyCodePage)
                *puiFamilyCodePage = MimeCodePage[idx].uiFamilyCodePage;
            else
                *puiFamilyCodePage = uiCodePage;
        }
        else
        {
            hr = E_FAIL;
            *puiFamilyCodePage = 0;
        }
        return hr;
}

STDAPI CMultiLanguage::EnumCodePages(DWORD grfFlags, IEnumCodePage **ppEnumCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumCodePages called."));
    *ppEnumCodePage = NULL;

    // Return IE4 MIME DB data in IMultiLanguage    
    CEnumCodePage *pCEnumCodePage = new CEnumCodePage(grfFlags, GetSystemDefaultLangID(), MIMECONTF_MIME_IE4);

    if (NULL != pCEnumCodePage)
    {
        HRESULT hr = pCEnumCodePage->QueryInterface(IID_IEnumCodePage, (void**)ppEnumCodePage);
        pCEnumCodePage->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage2::EnumCodePages(DWORD grfFlags, LANGID LangId, IEnumCodePage **ppEnumCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumCodePages called."));
    *ppEnumCodePage = NULL;

    CEnumCodePage *pCEnumCodePage = new CEnumCodePage(grfFlags, LangId, dwMimeSource);
    if (NULL != pCEnumCodePage)
    {
        HRESULT hr = pCEnumCodePage->QueryInterface(IID_IEnumCodePage, (void**)ppEnumCodePage);
        pCEnumCodePage->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage2::EnumScripts(DWORD dwFlags, LANGID LangId, IEnumScript **ppEnumScript)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::EnumScripts called."));
    *ppEnumScript = NULL;

    CEnumScript *pCEnumScript = new CEnumScript(dwFlags, LangId, dwMimeSource);
    if (NULL != pCEnumScript)
    {
        HRESULT hr = pCEnumScript->QueryInterface(IID_IEnumScript, (void**)ppEnumScript);
        pCEnumScript->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetCharsetInfo(Charset, pcsetInfo);
    else
        return E_FAIL;
}

STDAPI CMultiLanguage::IsConvertible(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::IsConvertINetStringAvailable called."));
    return IsConvertINetStringAvailable(dwSrcEncoding, dwDstEncoding);
}

STDAPI CMultiLanguage::ConvertString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::ConvertStringEx called."));
    return ConvertINetString(lpdwMode, dwSrcEncoding, dwDstEncoding, (LPCSTR)pSrcStr, (LPINT)pcSrcSize, (LPSTR)pDstStr, (LPINT)pcDstSize);
}

STDAPI CMultiLanguage::ConvertStringToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::ConvertStringToUnicode called."));
    return ConvertINetMultiByteToUnicode(lpdwMode, dwEncoding, (LPCSTR)pSrcStr, (LPINT)pcSrcSize, (LPWSTR)pDstStr, (LPINT)pcDstSize);
}

STDAPI CMultiLanguage::ConvertStringFromUnicode(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::ConvertStringFromUnicode called."));
    return ConvertINetUnicodeToMultiByte(lpdwMode, dwEncoding, (LPCWSTR)pSrcStr, (LPINT)pcSrcSize, (LPSTR)pDstStr, (LPINT)pcDstSize);
}

STDAPI CMultiLanguage::ConvertStringReset(void)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::Reset called."));
    return ConvertINetReset();
}

STDAPI CMultiLanguage::GetRfc1766FromLcid(LCID Locale, BSTR *pbstrRfc1766)
{
    HRESULT hr = E_INVALIDARG;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetRfc1766FromLcid called."));

    if (NULL != pbstrRfc1766)
    {
        WCHAR wsz[MAX_RFC1766_NAME];

        hr = LcidToRfc1766W(Locale, wsz, ARRAYSIZE(wsz));
        if (SUCCEEDED(hr))
            *pbstrRfc1766 = SysAllocString(wsz);
        else
            *pbstrRfc1766 = NULL;
    }
    return hr;
}

STDAPI CMultiLanguage::GetLcidFromRfc1766(PLCID pLocale, BSTR bstrRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetLcidFromRfc1766 called."));
    return Rfc1766ToLcidW(pLocale, bstrRfc1766);   
}

STDAPI CMultiLanguage::EnumRfc1766(IEnumRfc1766 **ppEnumRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumRfc1766 called."));
    *ppEnumRfc1766 = NULL;

    CEnumRfc1766 *pCEnumRfc1766 = new CEnumRfc1766(dwMimeSource,GetSystemDefaultLangID());
    if (NULL != pCEnumRfc1766)
    {
        HRESULT hr = pCEnumRfc1766->QueryInterface(IID_IEnumRfc1766, (void**)ppEnumRfc1766);
        pCEnumRfc1766->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage2::EnumRfc1766(LANGID LangId, IEnumRfc1766 **ppEnumRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::EnumRfc1766 called."));
    *ppEnumRfc1766 = NULL;

    CEnumRfc1766 *pCEnumRfc1766 = new CEnumRfc1766(dwMimeSource, LangId);
    if (NULL != pCEnumRfc1766)
    {
        HRESULT hr = pCEnumRfc1766->QueryInterface(IID_IEnumRfc1766, (void**)ppEnumRfc1766);
        pCEnumRfc1766->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

STDAPI CMultiLanguage::GetRfc1766Info(LCID Locale, PRFC1766INFO pRfc1766Info)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetRfc1766Info called."));


    if (NULL != pRfc1766Info)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            pRfc1766Info->lcid = MimeRfc1766[i].LcId;
            MLStrCpyNW(pRfc1766Info->wszRfc1766, MimeRfc1766[i].szRfc1766, MAX_RFC1766_NAME);
            _LoadStringExW(g_hInst, MimeRfc1766[i].uidLCID, pRfc1766Info->wszLocaleName, 
                 MAX_LOCALE_NAME, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

STDAPI CMultiLanguage2::GetRfc1766Info(LCID Locale, LANGID LangId, PRFC1766INFO pRfc1766Info)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::GetRfc1766Info called."));


    if (NULL != pRfc1766Info)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            if (!LangId)
                LangId = GetSystemDefaultLangID();

            pRfc1766Info->lcid = MimeRfc1766[i].LcId;
            MLStrCpyNW(pRfc1766Info->wszRfc1766, MimeRfc1766[i].szRfc1766, MAX_RFC1766_NAME);

            if (!_LoadStringExW(g_hInst, MimeRfc1766[i].uidLCID, pRfc1766Info->wszLocaleName, 
                 MAX_LOCALE_NAME, LangId))
            {
                    _LoadStringExW(g_hInst, MimeRfc1766[i].uidLCID, pRfc1766Info->wszLocaleName, 
                         MAX_LOCALE_NAME, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
            }
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

STDAPI CMultiLanguage::CreateConvertCharset(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty, IMLangConvertCharset **ppMLangConvertCharset)
{
    HRESULT hr;
    IClassFactory* pClassObj;

    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::CreateCharsetConvert called."));

    if (SUCCEEDED(hr = _Module.GetClassObject(CLSID_CMLangConvertCharset, IID_IClassFactory, (void**)&pClassObj)))
    {
        hr = pClassObj->CreateInstance(NULL, IID_IMLangConvertCharset, (void**)ppMLangConvertCharset);
        pClassObj->Release();
    }

    if (ppMLangConvertCharset && FAILED(hr))
        *ppMLangConvertCharset = NULL;

    if (NULL != *ppMLangConvertCharset)
        hr = (*ppMLangConvertCharset)->Initialize(uiSrcCodePage, uiDstCodePage, dwProperty);

    return hr;
}

STDAPI CMultiLanguage2::ConvertStringInIStream(LPDWORD lpdwMode, DWORD dwFlag, WCHAR *lpFallBack, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ConvertStringInIStream called."));
    return ConvertINetStringInIStream(lpdwMode,dwSrcEncoding,dwDstEncoding,pstmIn,pstmOut,dwFlag,lpFallBack);
}

STDAPI CMultiLanguage2::ConvertStringToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ConvertBufferStringToUnicodeEx called."));
    return ConvertINetMultiByteToUnicodeEx(lpdwMode, dwEncoding, (LPCSTR)pSrcStr, (LPINT)pcSrcSize, (LPWSTR)pDstStr, (LPINT)pcDstSize, dwFlag, lpFallBack);
}

STDAPI CMultiLanguage2::ConvertStringFromUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ConvertBufferStringFromUnicodeEx called."));
    return ConvertINetUnicodeToMultiByteEx(lpdwMode, dwEncoding, (LPCWSTR)pSrcStr, (LPINT)pcSrcSize, (LPSTR)pDstStr, (LPINT)pcDstSize, dwFlag, lpFallBack);
}

STDAPI CMultiLanguage2::DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScores)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::DetectCodepageInIStream called. "));
    return _DetectCodepageInIStream(dwFlag, uiPrefWinCodepage, pstmIn, lpEncoding, pnScores);
}

STDAPI CMultiLanguage2::DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScores)
{
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::DetectInputCodepage called. "));
    return _DetectInputCodepage(dwFlag, uiPrefWinCodepage, pSrcStr, pcSrcSize, lpEncoding, pnScores);
}

STDAPI CMultiLanguage2::ValidateCodePage(UINT uiCodePage, HWND hwnd)
{
    return ValidateCodePageEx(uiCodePage, hwnd, 0);
}
// this is private function to serve both for IML2 and IML3
STDAPI CMultiLanguage2::ValidateCodePageEx(UINT uiCodePage, HWND hwnd, DWORD dwfIODControl)
{
    MIMECPINFO cpInfo;
    CLSID      clsid;
    UINT       uiFamCp;
    HRESULT    hr;
    
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::ValidateCodePage called. "));
    
    if (NULL != g_pMimeDatabase)
        hr = g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo);
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        return E_INVALIDARG;

    EnterCriticalSection(&g_cs);
    if (NULL == g_pCpMRU)
        if (g_pCpMRU = new CCpMRU)
            g_pCpMRU->Init();
    LeaveCriticalSection(&g_cs);

    if (g_pCpMRU && g_pCpMRU->dwCpMRUEnable)
        g_pCpMRU->UpdateCPMRU(uiCodePage);

    if (cpInfo.dwFlags & MIMECONTF_VALID)
        return S_OK;

    // always handle family codepage because a caller
    // of this function is not generally aware if
    // the codepage is primary one. i.e., they can
    // call with cp=20268 to validate the entire 1251
    // family.
    //
    uiFamCp = cpInfo.uiFamilyCodePage;

    // Bug 394904, IOD won't be able to get us gb18030 support, 
    // so we won't ask UrlMon for CHS langpack if gb2312 is valid
    if (uiCodePage == CP_18030)
    {
        g_pMimeDatabase->GetCodePageInfo(uiFamCp, 0x409, &cpInfo);

        if (cpInfo.dwFlags & MIMECONTF_VALID)
            return S_FALSE;
    }
    
    // Ignore IOD check on NT5
    if (g_bIsNT5)
    {
        // Currently, NT5 doesn't install 20127 and 28605 NLS files.
        // We should prevent langpack installation loop and let clients resolve 
        // them with CP_ACP in case of 20127 and 28605 validation.
        // This hack can be removed once NT5 bundles these NLS files by default.
        if ((uiCodePage == CP_20127 || uiCodePage == CP_ISO_8859_15) && IsValidCodePage(uiFamCp))
            return E_FAIL;
        hr = IsNTLangpackAvailable(uiFamCp);
        if (hr != S_OK)
            return hr;
    }
    else
    {
        // check if JIT langpack is enabled.
        //
        hr = EnsureIEStatus();
        if (hr == S_OK) 
        {
            if (!m_pIEStat || m_pIEStat->IsJITEnabled() != TRUE)
            {
                // the codepage is neither valid or installable
                return S_FALSE;
            }
        }
    }    

    if (hwnd == NULL)
    {
        hwnd = GetForegroundWindow();   
    }

    // Special handling for NT.
    if (g_bIsNT5)
    {
        DWORD   dwInstallLpk = 1;
        HKEY    hkey;
        DWORD   dwAction = 0;

        // HKCR\\Software\\Microsoft\internet explorer\\international
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, 
                         REGSTR_PATH_INTERNATIONAL,
                         NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwAction)) 
        {
            DWORD dwType = REG_DWORD;
            DWORD dwSize = sizeof(DWORD);

            if (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_NT5LPK, 0, &dwType, (LPBYTE)&dwInstallLpk, &dwSize))
            {
                dwInstallLpk = 1;
                RegSetValueEx(hkey, REG_KEY_NT5LPK, 0, REG_DWORD, (LPBYTE)&dwInstallLpk, sizeof(dwInstallLpk));
            }
            RegCloseKey(hkey);
        }

        hr = S_FALSE;

        // Pops up NT5 langpack dialog box if langpack is enabled or user selects it from encoding menu
        if (dwInstallLpk || (dwfIODControl & CPIOD_FORCE_PROMPT))
        {
            LPCDLGTEMPLATE pTemplate;
            HRSRC   hrsrc;
            INT_PTR iRet;
            LANGID  LangId = GetNT5UILanguage();

            dwInstallLpk |= uiFamCp << 16;

            // Load correct resource to match NT5 UI language
            hrsrc = FindResourceExW(g_hInst, (LPCWSTR) RT_DIALOG, (LPCWSTR) MAKEINTRESOURCE(IDD_DIALOG_LPK), LangId);

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            
            // Pack LPARAM, code page value in HIWORD, installation flag in LOWORD
            if (hrsrc &&
                (pTemplate = (LPCDLGTEMPLATE)LoadResource(g_hInst, hrsrc)))
            {
                iRet = DialogBoxIndirectParamW(g_hInst, pTemplate,
                   hwnd, LangpackDlgProc, (LPARAM) dwInstallLpk);
            }
            else 
                iRet = DialogBoxParamW(g_hInst, (LPCWSTR) MAKEINTRESOURCE(IDD_DIALOG_LPK), hwnd, LangpackDlgProc, (LPARAM) dwInstallLpk); 

            if (iRet)
            {
                hr = _InstallNT5Langpack(hwnd, uiFamCp);
                if (S_OK == hr)
                {                
                    WCHAR wszLangInstall[MAX_PATH];
                    WCHAR wszNT5LangPack[1024];
                    

                    // Fall back to English (US) if we don't have a specific language resource
                    if (!_LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId) ||
                        !_LoadStringExW(g_hInst, IDS_NT5_LANGPACK, wszNT5LangPack, ARRAYSIZE(wszNT5LangPack), LangId))
                    {
                        LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                        _LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId);
                        _LoadStringExW(g_hInst, IDS_NT5_LANGPACK, wszNT5LangPack, ARRAYSIZE(wszNT5LangPack), LangId);
                    }
                
                    MessageBoxW(hwnd, wszNT5LangPack, wszLangInstall, MB_OK);
                }
            }
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }


        goto SKIP_IELANGPACK;
    }

    // Initiate JIT using CLSID give to the langpack
    hr = _GetJITClsIDForCodePage(uiFamCp, &clsid);
    if (SUCCEEDED(hr))
    {
        hr = InstallIEFeature(hwnd, &clsid, dwfIODControl);
    }

    // if JIT returns S_OK, we now have everything installed
    // then we'll validate the codepage and add font
    // NOTE: there can be more than codepage to validate here,
    //      for example, PE langpack contains more than one 
    //      NLS file to get greek, cyrillic and Turkish at the
    //      same time.
    if (hr == S_OK)
    {
        hr = _ValidateCPInfo(uiFamCp);
        if (SUCCEEDED(hr))
        {
            _AddFontForCP(uiFamCp);
        }
    }
    
SKIP_IELANGPACK:      
    return hr;
}


// IMultiLanguage2::GetCodePageDescription
//
// Provide native code page description in UNICODE.
// If not resource is vailable for the specified LCID, 
// we'll try the primary language first, then English.
// In this case, we'll return S_FALSE to caller.
STDAPI CMultiLanguage2::GetCodePageDescription(
    UINT uiCodePage,        // Specifies the required code page for description.
    LCID lcid,              // Specifies locale ID for prefered language.
    LPWSTR lpWideCharStr,   // Points to a buffer that receives the code page description.
    int cchWideChar)        // Specifies the size, in wide characters, of the buffer 
                            // pointed by lpWideCharStr.
{
    HRESULT hr = E_FAIL;
    UINT    CountCPId;
    UINT    i = 0, j = 0;

    g_pMimeDatabase->GetNumberOfCodePageInfo(&CountCPId);
    
    if (cchWideChar == 0)
    {
        return E_INVALIDARG;
    }        

    while (i < CountCPId)
    {
        if (MimeCodePage[j].dwFlags & dwMimeSource)
        {
            if ((MimeCodePage[j].uiCodePage == uiCodePage))
            {
                if (_LoadStringExW(g_hInst, MimeCodePage[j].uidDescription, lpWideCharStr,
                            cchWideChar, LANGIDFROMLCID(lcid))) 
                {
                    hr = S_OK;
                }
                else // Resource not find in the specificed language
                {
                        if (_LoadStringExW(g_hInst, MimeCodePage[j].uidDescription, lpWideCharStr,
                            cchWideChar, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)))
                        {
                            hr = S_FALSE;                
                        }
                }
                break;
            }  
            i++;
        }
        j++;
    }
    
    if (i >= CountCPId) // Code page description is not available in MLANG
    {
        hr = E_INVALIDARG;
    }

    return (hr);
}

STDAPI CMultiLanguage2::IsCodePageInstallable(UINT uiCodePage)
{
    MIMECPINFO cpInfo;
    UINT       uiFamCp;
    HRESULT    hr;
    
    DebugMsg(DM_TRACE, TEXT("CMultiLanguage::IsCPInstallable called. "));

    if (NULL != g_pMimeDatabase)
        hr = g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo);
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        return E_INVALIDARG;

    // if it's already valid, no need to check if it's installable
    if (cpInfo.dwFlags & MIMECONTF_VALID)
    {
        hr = S_OK;
    }
    else
    {        
        uiFamCp = cpInfo.uiFamilyCodePage;

        // it is currently not valid, if NT5, ignore IOD check
        if (g_bIsNT5)
        {
            hr = IsNTLangpackAvailable(uiFamCp);
        }
        else
        {
            // now check to see if the cp can be IOD
            hr = EnsureIEStatus();
        
            // we'll return FALSE if we couldn't get IOD status
            if (hr == S_OK)
            {
                if (!m_pIEStat || !m_pIEStat->IsJITEnabled())
                    hr = S_FALSE;
            }

            // then see if we have langpack for
            // the family codepage
            if (hr == S_OK)
            {
                CLSID      clsid;
                // clsid is just used for place holder
                hr = _GetJITClsIDForCodePage(uiFamCp, &clsid);
            }
        }
    }
    return hr;
}

STDAPI CMultiLanguage2::SetMimeDBSource(MIMECONTF dwSource)
{        
        if ((dwSource != MIMECONTF_MIME_IE4) &&
            (dwSource != MIMECONTF_MIME_LATEST) &&
            (dwSource != MIMECONTF_MIME_REGISTRY))
        {
            return E_INVALIDARG;
        }

        if (dwSource & MIMECONTF_MIME_REGISTRY)
        {
            EnterCriticalSection(&g_cs);
            if (!g_pMimeDatabaseReg)
            {
                g_pMimeDatabaseReg = new CMimeDatabaseReg;
            }
            LeaveCriticalSection(&g_cs);
        }

        dwMimeSource = dwSource;
        if (NULL != m_pMimeDatabase)
            m_pMimeDatabase->SetMimeDBSource(dwSource);
        return S_OK;
}

CMultiLanguage2::CMultiLanguage2(void)
{
        DllAddRef();
        
        CComCreator< CComPolyObject< CMultiLanguage > >::CreateInstance( NULL, IID_IMultiLanguage, (void **)&m_pIML );

        m_pMimeDatabase = new CMimeDatabase;
        dwMimeSource = MIMECONTF_MIME_LATEST;
        if (m_pMimeDatabase)
            m_pMimeDatabase->SetMimeDBSource(MIMECONTF_MIME_LATEST);

        m_pIEStat = NULL;
}

CMultiLanguage2::~CMultiLanguage2(void)
{
        if (m_pIML)
        {
            m_pIML->Release();
            m_pIML = NULL;
        }

        if (m_pMimeDatabase)
        {
            delete m_pMimeDatabase;
        }

        if (m_pIEStat)
        {
            delete m_pIEStat;
        }

        DllRelease();
}

STDAPI CMultiLanguage2::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
        if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)         
        {
            if (NULL != g_pMimeDatabaseReg)
                return g_pMimeDatabaseReg->GetNumberOfCodePageInfo(pcCodePage);
            else
                return E_FAIL;
        }    
        else
        {    
            if (NULL != m_pMimeDatabase)
                return m_pMimeDatabase->GetNumberOfCodePageInfo(pcCodePage);
            else
                return E_FAIL;
        }
}

STDAPI CMultiLanguage2::GetNumberOfScripts(UINT *pnScripts)
{
    if (pnScripts)
        *pnScripts = g_cScript;

    return NOERROR;
}


STDAPI CMultiLanguage2::GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo)
{
    if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
    {
        if (NULL != g_pMimeDatabaseReg)
            return g_pMimeDatabaseReg->GetCodePageInfo(uiCodePage, pcpInfo);
        else
            return E_FAIL;
    }
    else
    {
        if (m_pMimeDatabase)
            return m_pMimeDatabase->GetCodePageInfo(uiCodePage, LangId, pcpInfo);
        else
            return E_FAIL;
    }
}

// Optimized for performance
// Skip unecessary resource loading
STDAPI CMultiLanguage2::GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage)
{
        HRESULT hr = S_OK;
        int idx = 0;

        if (puiFamilyCodePage)
            *puiFamilyCodePage = 0;
        else
            return E_INVALIDARG;

        DebugMsg(DM_TRACE, TEXT("CMultiLanguage2::GetFamilyCodePage called."));
        // Keep registry version IE4 implementation
        if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
        {

            if (NULL != g_pMimeDatabaseReg)
            {
                MIMECPINFO cpInfo;
                hr = g_pMimeDatabaseReg->GetCodePageInfo(uiCodePage, &cpInfo);
                if (S_OK == hr)
                    *puiFamilyCodePage = cpInfo.uiFamilyCodePage;
            }
        }
        else
        {
            while(MimeCodePage[idx].uiCodePage)
            {
                if ((uiCodePage == MimeCodePage[idx].uiCodePage) &&
                    (MimeCodePage[idx].dwFlags & dwMimeSource))
                    break;
                idx++;
            }

            if (MimeCodePage[idx].uiCodePage)
            {
                if (MimeCodePage[idx].uiFamilyCodePage)
                    *puiFamilyCodePage = MimeCodePage[idx].uiFamilyCodePage;
                else
                    *puiFamilyCodePage = uiCodePage;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        return hr;
}

STDAPI CMultiLanguage2::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
    {
        if (NULL != g_pMimeDatabaseReg)
            return g_pMimeDatabaseReg->GetCharsetInfo(Charset, pcsetInfo);
        else
            return E_FAIL;
    }

    if (NULL != m_pMimeDatabase)
        return m_pMimeDatabase->GetCharsetInfo(Charset, pcsetInfo);
    else
        return E_FAIL;
}

//
// System default code page stack
//
// We support following code pages for outbound encoding detection
//      Windows  : 1252, 1250, 1251, 1253, 1254, 1257, 1258, 1256, 1255, 874, 932, 949, 950, 936
//      Unicode  : 65001, 65000, 1200
//      ISO      : 28591, 28592, 20866, 21866, 28595, 28597, 28593, 28594, 28596, 28598, 38598, 28605, 28599
//      Others   : 20127, 50220, 50221, 50222, 51932, 51949, 50225, 52936
//
// Default priorities
//       20127 > Windows single byte code page> ISO > Windows DBCS code page > Others > Unicode
//
UINT SysPreCp[] = 
    {20127, 
    1252, 1250, 1251, 1253, 1254, 1257, 1258, 1256, 1255, 874, 
    28591, 28592, 20866, 21866, 28595, 28597, 28593, 28594, 28596, 28598, 38598, 28605, 28599,
    932, 949, 950, 936,
    50220, 50221, 50222, 51932, 51949, 50225, 52936, 
    65001, 65000, 1200 };
            
//
// IMultiLanguage3
// Outbound encoding detection for plain Unicode text encoding detection
// We ride on CMultiLanguage2 class to implement this funciton
//
STDAPI CMultiLanguage2::DetectOutboundCodePage(
            DWORD   dwFlags,                // Flags control our behaviour
            LPCWSTR lpWideCharStr,          // Source Unicode string
            UINT    cchWideChar,            // Source Unicode character size
            UINT*   puiPreferredCodePages,  // Preferred code page array  
            UINT    nPreferredCodePages,    // Number of preferred code pages
            UINT*   puiDetectedCodePages,   // Detected code page arrayNumber of detected code pages
            UINT*   pnDetectedCodePages,    // [in] Maxium number of code pages we can return
                                            // [out] Num of detected code pages
            WCHAR*  lpSpecialChar           // Optional NULL terminated Unicode string for client specified special chars
            )
{
    DWORD dwCodePages = 0, dwCodePagesExt = 0;
    LONG lNum1 = 0, lNum2 = 0;
    HRESULT hr = E_FAIL;
    UINT ui;
    DWORD dwStrFlags;
    LPWSTR lpwszTmp = NULL;

    // Parameter checks
    if (!cchWideChar || !lpWideCharStr || !puiDetectedCodePages || !*pnDetectedCodePages)
        return E_INVALIDARG;

    // We need extra buffer to perform best fit char filtering
    if (dwFlags & MLDETECTF_FILTER_SPECIALCHAR)
        lpwszTmp = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cchWideChar);

    // String sniffing for CJK, HINDI and BESTFIT
    dwStrFlags = OutBoundDetectPreScan((WCHAR *)lpWideCharStr, cchWideChar, lpwszTmp, lpSpecialChar);

    hr = GetStrCodePagesEx(lpwszTmp? lpwszTmp:lpWideCharStr, cchWideChar, 0, &dwCodePages, &lNum1, CPBITS_WINDOWS|CPBITS_STRICT);
    if (SUCCEEDED(hr))
        hr = GetStrCodePagesEx(lpwszTmp? lpwszTmp:lpWideCharStr, cchWideChar, 0, &dwCodePagesExt,&lNum2, CPBITS_EXTENDED|CPBITS_STRICT);

    // Clear bits if it is not a complete pass
    if ((UINT)lNum1 != cchWideChar)
        dwCodePages = 0;

    if ((UINT)lNum2 != cchWideChar)
        dwCodePagesExt = 0;

    if (lpwszTmp)
        LocalFree(lpwszTmp);

    // If Hindi, we don't return any non-Unicode code pages since there is no offical ones 
    // and we don't recomment client to render Hindi text in ANSI
    if (dwStrFlags & (FS_HINDI|FS_PUA))
    {
        dwCodePages = 0;
        dwCodePagesExt = 0;
    }    

    dwCodePagesExt |= FS_MLANG_65001;
    dwCodePagesExt |= FS_MLANG_65000;
    dwCodePagesExt |= FS_MLANG_1200;

    if (dwCodePagesExt & FS_MLANG_28598)
        dwCodePagesExt |= FS_MLANG_38598;
    if (dwCodePagesExt & FS_MLANG_50220)
        dwCodePagesExt |= FS_MLANG_50221|FS_MLANG_50222;


    if (SUCCEEDED(hr))
    {    
        DWORD dwTempCodePages;
        DWORD dwTempCodePages2;
        UINT nCp = 0;

        // Pick preferred code pages first
        if (nPreferredCodePages && puiPreferredCodePages)
        for (ui=0; nCp<*pnDetectedCodePages && (dwCodePages | dwCodePagesExt) && ui<nPreferredCodePages; ui++)
        {
            if (S_OK == CodePageToCodePagesEx(puiPreferredCodePages[ui], &dwTempCodePages, &dwTempCodePages2))
            {
                if (dwTempCodePages & dwCodePages)
                {
                    puiDetectedCodePages[nCp] = puiPreferredCodePages[ui];
                    dwCodePages &= ~dwTempCodePages;
                    nCp++;

                }
                else if (dwTempCodePages2 & dwCodePagesExt)
                {
                    puiDetectedCodePages[nCp] = puiPreferredCodePages[ui];
                    dwCodePagesExt &= ~dwTempCodePages2;
                    nCp++;
                }
            }
        }

        // Fill in non-preferred code pages if we still have space in destination buffer
        if (!((dwFlags & MLDETECTF_PREFERRED_ONLY) && nPreferredCodePages && puiPreferredCodePages))
        {
            for (ui=0; nCp<*pnDetectedCodePages && (dwCodePages | dwCodePagesExt) && ui < sizeof(SysPreCp)/sizeof(UINT); ui++)
            {
                if (S_OK == CodePageToCodePagesEx(SysPreCp[ui], &dwTempCodePages, &dwTempCodePages2))
                {
                    if (dwTempCodePages & dwCodePages)
                    {
                        puiDetectedCodePages[nCp] = SysPreCp[ui];
                        dwCodePages &= ~dwTempCodePages;
                        nCp++;

                    }
                    else if (dwTempCodePages2 & dwCodePagesExt)
                    {
                        puiDetectedCodePages[nCp] = SysPreCp[ui];
                        dwCodePagesExt &= ~dwTempCodePages2;
                        nCp++;
                    }
                }
            }
        }

        
        // Smart adjustment for DBCS
        // If string doesn't contains CJK characters, we bump up UTF8
        if (!(dwFlags & MLDETECTF_PRESERVE_ORDER) && !(dwStrFlags & FS_CJK) && (puiDetectedCodePages[0] == 932||
            puiDetectedCodePages[0] == 936||puiDetectedCodePages[0] == 950||puiDetectedCodePages[0] == 949))
        {
            for (ui = 1; ui < nCp; ui++)
            {
                if (puiDetectedCodePages[ui] == 65001) //Swap
                {
                    MoveMemory((LPVOID)(puiDetectedCodePages+1), (LPVOID)(puiDetectedCodePages), ui*sizeof(UINT));
                    puiDetectedCodePages[0] = 65001;
                    break;
                }
            }
        }

        // Check validation
        if (dwFlags & MLDETECTF_VALID || dwFlags & MLDETECTF_VALID_NLS)
        {
            MIMECPINFO cpInfo;
            UINT * puiBuffer = puiDetectedCodePages;

            if (!g_pMimeDatabase)
                BuildGlobalObjects();

            if (g_pMimeDatabase)
            {
                for (ui = 0; ui < nCp; ui++)
                {
                    if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(puiDetectedCodePages[ui], 0x0409, &cpInfo)))
                    {
                        if ((cpInfo.dwFlags & MIMECONTF_VALID)  || 
                            ((cpInfo.dwFlags & MIMECONTF_VALID_NLS) && (dwFlags & MLDETECTF_VALID_NLS)))
                        {
                            // In place adjustment
                            *puiBuffer = puiDetectedCodePages[ui];
                            puiBuffer++;
                        }
                    }
                }
                nCp =(UINT) (puiBuffer-puiDetectedCodePages);                
            }
        }

        // Be nice, clean up detection buffer for client
        if (nCp < *pnDetectedCodePages)
            ZeroMemory(&puiDetectedCodePages[nCp], *pnDetectedCodePages-nCp);

        *pnDetectedCodePages = nCp;
    }

    return hr;
    
}

// IStream object
STDAPI CMultiLanguage2::DetectOutboundCodePageInIStream(
            DWORD        dwFlags,                // Detection flags
            IStream*     pStmIn,                 // IStream object pointer
            UINT*        puiPreferredCodePages,  // Preferred code page array  
            UINT         nPreferredCodePages,    // Num of preferred code pages
            UINT*        puiDetectedCodePages,   // Buffer for detection result
            UINT*        pnDetectedCodePages,    // [in] Maxium number of code pages we can return
                                                 // [out] Num of detected code pages
            WCHAR*       lpSpecialChar           // Optional NULL terminated Unicode string for client specified special chars
            )                               

{
    HRESULT hr;
    LARGE_INTEGER  libOrigin = { 0, 0 };
    ULARGE_INTEGER ulPos = {0, 0};
    ULONG   ulSrcSize;
    CHAR    *pStr;    

    // Get buffer size
    hr = pStmIn->Seek(libOrigin, STREAM_SEEK_END,&ulPos);

    if (SUCCEEDED(hr))
    {
        ulSrcSize = ulPos.LowPart ;
        if (pStr=(char *)LocalAlloc(LPTR, ulSrcSize))
        {
            // Reset the pointer
            hr = pStmIn->Seek(libOrigin, STREAM_SEEK_SET, NULL);
            if (S_OK == hr)
            {
                hr = pStmIn->Read(pStr, ulSrcSize, &ulSrcSize);
                if (S_OK == hr)
                    hr = DetectOutboundCodePage(dwFlags, (LPCWSTR)pStr, ulSrcSize/sizeof(WCHAR), puiPreferredCodePages, 
                                                nPreferredCodePages, puiDetectedCodePages, pnDetectedCodePages, lpSpecialChar);
            }
            LocalFree(pStr);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mimereg.cpp ===
#include "private.h"
#ifdef UNIX
/* Convert from little endian to big endian format */
#define CONVERTLONG(a,b,c,d) (((unsigned long )a) + \
                           ((unsigned long )b << 8) + \
                           ((unsigned long )c << 16) + \
                           ((unsigned long )d << 24))
#endif /* UNIX */

//
//  Globals
//
CMimeDatabaseReg *g_pMimeDatabaseReg = NULL;

//
//  Globals
//
PRFC1766INFOA   g_pRfc1766Reg = NULL;
UINT            g_cRfc1766Reg = 0, g_cMaxRfc1766 = 0;

//
//  Functions
//
void CMimeDatabaseReg::BuildRfc1766Table(void)
{
    HKEY hKey = NULL;
    DWORD dwIndex, dwType, cInfo, cbMaxValueLen, cbLCID, cb;
    TCHAR szLCID[8], sz[MAX_RFC1766_NAME +  MAX_LOCALE_NAME + 1];

    DebugMsg(DM_TRACE, TEXT("CRfc1766::BuildRfc1766Table called."));
    EnterCriticalSection(&g_cs);
    if (NULL == g_pRfc1766Reg)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_RFC1766, 0, KEY_READ, &hKey))
        {
            ASSERT(NULL != hKey);
            if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, NULL, NULL, NULL, &cInfo, &cbMaxValueLen, NULL, NULL, NULL))
            {
                g_pRfc1766Reg = (PRFC1766INFOA)LocalAlloc(LPTR, sizeof(RFC1766INFOA) * cInfo);
                if (NULL != g_pRfc1766Reg)
                {
                    g_cRfc1766Reg = 0;
                    g_cMaxRfc1766 = cInfo;
                    dwIndex = 0;
                    while (g_cRfc1766Reg < g_cMaxRfc1766)
                    {
                        LONG lRet;

                        cbLCID = ARRAYSIZE(szLCID) - 2;
                        cb = sizeof(sz);
                        lRet = RegEnumValue(hKey, dwIndex++, szLCID + 2, &cbLCID, 0, &dwType, (LPBYTE)sz, &cb);
                        if (ERROR_SUCCESS == lRet)
                        {
                            int iLCID;

                            szLCID[0] = TEXT('0');
                            szLCID[1] = TEXT('x');
                            // StrToInt
                            if (iLCID = HexToNum(szLCID + 2))
                            {
                                g_pRfc1766Reg[g_cRfc1766Reg].lcid = (LCID)iLCID;
                                if (REG_SZ == dwType)
                                {
                                    TCHAR *psz = sz;

                                    while (*psz)
                                    {
                                        if (TEXT(';') == *psz)
                                        {
                                            *psz = TEXT('\0');
                                            break;
                                        }
                                        psz = CharNext(psz);
                                    }
                                    lstrcpyn(g_pRfc1766Reg[g_cRfc1766Reg].szRfc1766, sz, MAX_RFC1766_NAME);
                                    lstrcpyn(g_pRfc1766Reg[g_cRfc1766Reg].szLocaleName, psz + 1, MAX_LOCALE_NAME);
                                    g_cRfc1766Reg++;
                                }
                            }
                        }
                        else if (ERROR_NO_MORE_ITEMS == lRet)
                            break;
                    }
                }
            }
            RegCloseKey(hKey);
        }
    }
    LeaveCriticalSection(&g_cs);
}

void CMimeDatabaseReg::FreeRfc1766Table(void)
{
    DebugMsg(DM_TRACE, TEXT("CRfc1766::FreeRfc1766Table called."));
    EnterCriticalSection(&g_cs);
    if (NULL != g_pRfc1766Reg)
    {
        LocalFree(g_pRfc1766Reg);
        g_pRfc1766Reg = NULL;
        g_cRfc1766Reg = g_cMaxRfc1766 = 0;
    }
    LeaveCriticalSection(&g_cs);
}

void CMimeDatabaseReg::EnsureRfc1766Table(void)
{
    // Ensure g_pRfc1766 is initialized
    if (NULL == g_pRfc1766Reg)
        BuildRfc1766Table();
}


STDAPI CMimeDatabaseReg::LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    EnsureRfc1766Table();
    if (NULL != pszRfc1766 && 0 < iMaxLength)
    {
        for (i = 0; i < g_cRfc1766Reg; i++)
        {
            if (g_pRfc1766Reg[i].lcid == Locale)
                break;
        }
        if (i < g_cRfc1766Reg)
        {
            lstrcpyn(pszRfc1766, g_pRfc1766Reg[i].szRfc1766, iMaxLength);
            hr = S_OK;
        }
        else
        {
            TCHAR sz[MAX_RFC1766_NAME];

            if (GetLocaleInfoA(Locale, LOCALE_SABBREVLANGNAME, sz, ARRAYSIZE(sz)))
            {
                CharLowerA(sz);
                if (!lstrcmpA(sz, TEXT("cht")))
                    lstrcpynA(pszRfc1766, TEXT("zh-cn"), iMaxLength);
                else if (!lstrcmpA(sz, TEXT("chs")))
                    lstrcpynA(pszRfc1766, TEXT("zh-tw"), iMaxLength);
                else if (!lstrcmpA(sz, TEXT("jpn")))
                    lstrcpynA(pszRfc1766, TEXT("ja"), iMaxLength);
                else
                {
                    sz[2] = TEXT('\0');
                    lstrcpynA(pszRfc1766, sz, iMaxLength);
                }
                hr = S_OK;
            }
            else
                hr = E_FAIL;
        }
    }
    return hr;
}    

STDAPI CMimeDatabaseReg::LcidToRfc1766W(LCID Locale, LPWSTR pwszRfc1766, int nChar)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pwszRfc1766 && 0 < nChar)
    {
        TCHAR sz[MAX_RFC1766_NAME];

        hr = LcidToRfc1766A(Locale, (LPSTR)sz, ARRAYSIZE(sz));
        if (S_OK == hr)
        {
            int i;

            for (i = 0; i < nChar - 1; i++)
            {
                pwszRfc1766[i] = (WCHAR)sz[i];
                if (L'\0' == pwszRfc1766[i])
                    break;
            }
            if (i == nChar - 1)
                pwszRfc1766[i] = L'\0';            
        }
    }
    return hr;
}    

STDAPI CMimeDatabaseReg::Rfc1766ToLcidA(PLCID pLocale, LPCSTR pszRfc1766)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    EnsureRfc1766Table();
    if (NULL != pLocale && NULL != pszRfc1766)
    {
        for (i = 0; i < g_cRfc1766Reg; i++)
        {
            if (!lstrcmpi(g_pRfc1766Reg[i].szRfc1766, pszRfc1766))
                break;
        }
        if (i < g_cRfc1766Reg)
        {
            *pLocale = g_pRfc1766Reg[i].lcid;
            hr = S_OK;
        }
        else
        {
            if (2 < lstrlen(pszRfc1766))
            {
                TCHAR sz[3];

                sz[0] = pszRfc1766[0];
                sz[1] = pszRfc1766[1];
                sz[2] = TEXT('\0');
                for (i = 0; i < g_cRfc1766Reg; i++)
                {
                    if (!lstrcmpi(g_pRfc1766Reg[i].szRfc1766, sz))
                        break;                
                }
                if (i < g_cRfc1766Reg)
                {
                    *pLocale = g_pRfc1766Reg[i].lcid;
                    hr = S_FALSE;
                }
                else
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
    }
    return hr;
}

STDAPI CMimeDatabaseReg::Rfc1766ToLcidW(PLCID pLocale, LPCWSTR pwszRfc1766)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pLocale && NULL != pwszRfc1766)
    {
        int i;
        TCHAR sz[MAX_RFC1766_NAME];

        for (i = 0; i < MAX_RFC1766_NAME - 1; i++)
        {
            sz[i] = (TCHAR)pwszRfc1766[i];
            if (TEXT('\0') == sz[i])
                break;
        }
        if (i == MAX_RFC1766_NAME -1)
            sz[i] = TEXT('\0');

        hr = Rfc1766ToLcidA(pLocale, (LPCSTR)sz);
    }
    return hr;
}


//
//  CMimeDatabase implementation
//
CMimeDatabaseReg::CMimeDatabaseReg()
{
    DebugMsg(DM_TRACE, TEXT("constructor of CMimeDatabase 0x%08x"), this);
    _pCodePage = NULL;
    _cCodePage = _cMaxCodePage = 0;
    _pCharset = NULL;
    _cCharset = _cMaxCharset = 0;
    _fAllCPCached = FALSE;
    InitializeCriticalSection(&_cs);
}

CMimeDatabaseReg::~CMimeDatabaseReg()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CMimeDatabase 0x%08x"), this);
    FreeMimeDatabase();
    DeleteCriticalSection(&_cs);
}

void CMimeDatabaseReg::BuildCodePageMimeDatabase(void)
{
    HKEY hKey = NULL;
    DWORD cInfo, cbMaxSubKeyLen;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::BuildCodePageMimeDatabase called."));
    // Open CodePage Mime Database Key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_CODEPAGE, 0, KEY_READ, &hKey))
    {
        ASSERT(NULL != hKey);
        if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, &cInfo, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            if (NULL == _pCodePage)
            {
                _pCodePage = (PMIMECPINFO)LocalAlloc(LPTR, sizeof(MIMECPINFO) * cInfo);
                if (NULL != _pCodePage)
                    _cMaxCodePage = cInfo;

            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }

}

void CMimeDatabaseReg::BuildCharsetMimeDatabase(void)
{
    HKEY hKey = NULL;
    DWORD cInfo, cbMaxSubKeyLen;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::BuildCharsetMimeDatabase called."));
    // Open Charset Mime Database Key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_CHARSET, 0, KEY_READ, &hKey))
    {
        ASSERT(NULL != hKey);
        if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, 0, &cInfo, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            if (NULL == _pCharset)
            {
                _pCharset = (PMIMECSETINFO)LocalAlloc(LPTR, sizeof(MIMECSETINFO) * cInfo);
                if (NULL != _pCharset)
                    _cMaxCharset = cInfo;
            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
}

void CMimeDatabaseReg::FreeMimeDatabase(void)
{
    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::FreeMimeDatabase called."));
    EnterCriticalSection(&_cs);
    if (NULL != _pCodePage)
    {
        LocalFree(_pCodePage);
        _pCodePage = NULL;
        _cCodePage = _cMaxCodePage = 0;
    }
    if (NULL != _pCharset)
    {
        LocalFree(_pCharset);
        _pCharset = NULL;
        _cCharset = _cMaxCharset = 0;
    }
    LeaveCriticalSection(&_cs);
    FreeRfc1766Table();
}

STDAPI CMimeDatabaseReg::EnumCodePageInfo(void)
{
    HKEY hKey = NULL;
    DWORD dwIndex = 0;
    MIMECPINFO CPInfo;
    TCHAR szCodePage[15];
    HRESULT hr = S_OK;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::EnumCodePageInfo called."));
    EnterCriticalSection(&_cs);
    if (FALSE == _fAllCPCached)
    {
        if (NULL == _pCodePage)
            BuildCodePageMimeDatabase();
        if (_pCodePage)
        {
            // Open CodePage Mime Database Key
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_KEY_MIME_DATABASE_CODEPAGE, 0, KEY_READ, &hKey))
            {
                ASSERT(NULL != hKey);
                while (ERROR_SUCCESS == RegEnumKey(hKey, dwIndex++, szCodePage, ARRAYSIZE(szCodePage)))
                {
                    UINT uiCodePage = MLStrToInt(szCodePage);
    
                    if (0 <= FindCodePageFromCache(uiCodePage))
                        continue;

                    if (TRUE == FindCodePageFromRegistry(uiCodePage, &CPInfo))
                    {
                        _pCodePage[_cCodePage] = CPInfo;
                        _cCodePage++;
                    }
                }
                _fAllCPCached = TRUE;
                RegCloseKey(hKey);
                hKey = NULL;
            }
            if (0 < _cCodePage)
                QSortCodePageInfo(0, _cCodePage-1);

            // Fill empty font face field base on its FamilyCodePage
            for (UINT i = 0; i < _cCodePage; i++)
            {
                UINT uiFamily;
                WCHAR wszFixed[MAX_MIMEFACE_NAME], wszProp[MAX_MIMEFACE_NAME];

                uiFamily = 0;
                wszFixed[0] = wszProp[0] = TEXT('\0');

                if (TEXT('\0') == _pCodePage[i].wszFixedWidthFont[0] || TEXT('\0') == _pCodePage[i].wszProportionalFont[0])
                {
                    if (uiFamily != _pCodePage[i].uiFamilyCodePage)
                    {
                        for (UINT j = 0; j < _cCodePage; j++)
                        {
                            if (_pCodePage[i].uiFamilyCodePage == _pCodePage[j].uiCodePage)
                            {
                                uiFamily = _pCodePage[j].uiCodePage;
                                MLStrCpyNW(wszFixed, _pCodePage[j].wszFixedWidthFont, MAX_MIMEFACE_NAME);
                                MLStrCpyNW(wszProp, _pCodePage[j].wszProportionalFont, MAX_MIMEFACE_NAME);
                                break;
                            }
                        }                
                    }
                    MLStrCpyNW(_pCodePage[i].wszFixedWidthFont, wszFixed, MAX_MIMEFACE_NAME);
                    MLStrCpyNW(_pCodePage[i].wszProportionalFont, wszProp, MAX_MIMEFACE_NAME);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LeaveCriticalSection(&_cs);

    return hr;
}

STDAPI CMimeDatabaseReg::GetNumberOfCodePageInfo(UINT *pcCodePage)
{
    EnterCriticalSection(&_cs);
    if (NULL == _pCodePage)
        BuildCodePageMimeDatabase();
    *pcCodePage = _cMaxCodePage;
    LeaveCriticalSection(&_cs);
    return NOERROR;
}

STDAPI CMimeDatabaseReg::GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo)
{
    int idx;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfo called."));
    if (NULL != pcpInfo)
    {
        EnterCriticalSection(&_cs);
        if (NULL == _pCodePage)
            BuildCodePageMimeDatabase();

        if (_pCodePage)
        {
            idx = FindCodePageFromCache(uiCodePage);
            if (0 > idx)
            {
                MIMECPINFO CPInfo = {0};

                if (TRUE == FindCodePageFromRegistry(uiCodePage, &CPInfo))
                {
                    if (CPInfo.uiCodePage != CPInfo.uiFamilyCodePage)
                    {
                        idx = FindCodePageFromCache(CPInfo.uiFamilyCodePage);
                        if (0 > idx)
                        {
                            MIMECPINFO FamilyCPInfo;

                            if (TRUE == FindCodePageFromRegistry(CPInfo.uiFamilyCodePage, &FamilyCPInfo))
                            {
                                idx = _cCodePage;
                                _pCodePage[_cCodePage] = FamilyCPInfo;
                                _cCodePage++;
                            }
                        }
                        MLStrCpyNW(CPInfo.wszFixedWidthFont, _pCodePage[idx].wszFixedWidthFont, MAX_MIMEFACE_NAME);
                        MLStrCpyNW(CPInfo.wszProportionalFont, _pCodePage[idx].wszProportionalFont, MAX_MIMEFACE_NAME);
                    }
                    _pCodePage[_cCodePage] = CPInfo;
                    _cCodePage++;
                    QSortCodePageInfo(0, _cCodePage-1);
                    idx = FindCodePageFromCache(uiCodePage);
                }
            }
            if (0 <= idx)
            {
                *pcpInfo = _pCodePage[idx];
                hr = S_OK;
            }
            LeaveCriticalSection(&_cs);
        }
    }
    return hr;
}

int CMimeDatabaseReg::FindCodePageFromCache(UINT uiCodePage)
{
    UINT i;
    int iRet = -1;

    for (i = 0; i < _cCodePage; i++)
    {
        if (_pCodePage[i].uiCodePage == uiCodePage)
        {
            iRet = i;
            break;
        }
    }
    return iRet;
}

BOOL CMimeDatabaseReg::FindCodePageFromRegistry(UINT uiCodePage, PMIMECPINFO pcpInfo)
{
    HKEY hKey;
    DWORD dw, cb;
    TCHAR szKey[256],  sz[MAX_MIMECP_NAME];
    BOOL fRet = FALSE;

    wsprintf(szKey, TEXT("%s\\%d"), REGSTR_KEY_MIME_DATABASE_CODEPAGE, uiCodePage);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey))
    {
        TCHAR *psz, *pszComma;
        CHARSETINFO rCharsetInfo;

        pcpInfo->uiCodePage = uiCodePage;

        cb = sizeof(dw);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_FAMILY, 0, NULL, (LPBYTE)&dw, &cb))
            pcpInfo->uiFamilyCodePage = (UINT)dw;
        else
            pcpInfo->uiFamilyCodePage = pcpInfo->uiCodePage;

        cb = sizeof(dw);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_LEVEL, 0, NULL, (LPBYTE)&dw, &cb))
#ifdef UNIX
        {
           BYTE* px = (BYTE*)&dw;
           pcpInfo->dwFlags = CONVERTLONG(px[0], px[1], px[2], px[3]);
        }
#else
            pcpInfo->dwFlags = dw;
#endif /* UNIX */
        else
            pcpInfo->dwFlags = 0;

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_DESCRIPTION, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszDescription, ARRAYSIZE(pcpInfo->wszDescription));
        else
        {
            TCHAR szDef[MAX_MIMECP_NAME];

            LoadString(g_hInst, IDS_MIME_LANG_DEFAULT, szDef, ARRAYSIZE(szDef));
            wsprintf(sz, szDef, pcpInfo->uiCodePage);
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszDescription, ARRAYSIZE(pcpInfo->wszDescription));
        }

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_FIXEDWIDTHFONT, NULL, NULL, (LPBYTE)sz, &cb))
        {
            psz = sz;
            pszComma =  MLStrChr(sz, TEXT(','));
            if (NULL != pszComma)               // If there are multiple font name
            {
                if (uiCodePage != g_uACP)
                    psz = pszComma + 1;         // Take right side(English) fontname for non-native codepage info
                else
                    *pszComma = TEXT('\0');     // Take left side(DBCS) fontname for native codepage info
            }
            if (lstrlen(psz) >= MAX_MIMEFACE_NAME)
                psz[MAX_MIMEFACE_NAME-1] = TEXT('\0');
            MultiByteToWideChar(CP_ACP, 0, psz, -1, pcpInfo->wszFixedWidthFont, ARRAYSIZE(pcpInfo->wszFixedWidthFont));
        }
        else
            pcpInfo->wszFixedWidthFont[0] = L'\0';

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_PROPORTIONALFONT, NULL, NULL, (LPBYTE)sz, &cb))
        {
            psz = sz;
            pszComma = MLStrChr(sz, TEXT(','));
            if (NULL != pszComma)               // If there are multiple font name
            {
                if (uiCodePage != g_uACP)
                    psz = pszComma + 1;         // Take right side(English) fontname for non-native codepage info
                else
                    *pszComma = TEXT('\0');     // Take left side(DBCS) fontname for native codepage info
            }
            if (lstrlen(psz) >= MAX_MIMEFACE_NAME)
                psz[MAX_MIMEFACE_NAME-1] = TEXT('\0');
            MultiByteToWideChar(CP_ACP, 0, psz, -1, pcpInfo->wszProportionalFont, ARRAYSIZE(pcpInfo->wszProportionalFont));
        }
        else
            pcpInfo->wszProportionalFont[0] = L'\0';

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_BODYCHARSET, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszBodyCharset, ARRAYSIZE(pcpInfo->wszBodyCharset));
        else
            pcpInfo->wszBodyCharset[0] = L'\0';

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_HEADERCHARSET, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszHeaderCharset, ARRAYSIZE(pcpInfo->wszHeaderCharset));
        else
            MLStrCpyNW(pcpInfo->wszHeaderCharset, pcpInfo->wszBodyCharset, MAX_MIMECSET_NAME);

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_WEBCHARSET, NULL, NULL, (LPBYTE)sz, &cb))
            MultiByteToWideChar(CP_ACP, 0, sz, -1, pcpInfo->wszWebCharset, ARRAYSIZE(pcpInfo->wszWebCharset));
        else
            MLStrCpyNW(pcpInfo->wszWebCharset, pcpInfo->wszBodyCharset, MAX_MIMECSET_NAME);

        cb = sizeof(sz);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_PRIVCONVERTER, NULL, NULL, (LPBYTE)sz, &cb))
            pcpInfo->dwFlags |= MIMECONTF_PRIVCONVERTER;

        if (0 != TranslateCharsetInfo(IntToPtr_(LPDWORD, pcpInfo->uiFamilyCodePage), &rCharsetInfo, TCI_SRCCODEPAGE))
            pcpInfo->bGDICharset = (BYTE)rCharsetInfo.ciCharset;
        else
            pcpInfo->bGDICharset = DEFAULT_CHARSET;


        if (1200 == pcpInfo->uiFamilyCodePage || 50000 == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiFamilyCodePage)) // 50000 means user defined
        {
            if (TRUE == CheckFont(pcpInfo->bGDICharset))
            {
                if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID;
                else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID|MIMECONTF_VALID;
            }
            else
            {
                if (pcpInfo->uiCodePage == pcpInfo->uiFamilyCodePage || TRUE == _IsValidCodePage(pcpInfo->uiCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
                else if (S_OK == IsConvertINetStringAvailable(pcpInfo->uiCodePage, pcpInfo->uiFamilyCodePage))
                    pcpInfo->dwFlags |= MIMECONTF_VALID_NLS;
            }

        }
        RegCloseKey(hKey);
        fRet = TRUE;
    }
    return fRet;
}

STDAPI CMimeDatabaseReg::GetCodePageInfoWithIndex(UINT uidx, PMIMECPINFO pcpInfo)
{
    HRESULT hr = NOERROR;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCodePageInfoWithIndex called."));
    EnterCriticalSection(&_cs);
    if (NULL == _pCodePage)
        BuildCodePageMimeDatabase();
    if (uidx < _cCodePage && _pCodePage)
        *pcpInfo = _pCodePage[uidx];
    else
        hr = E_FAIL;
    LeaveCriticalSection(&_cs);
    return hr;
}

STDAPI CMimeDatabaseReg::GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo)
{
    int idx;
    HRESULT hr = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::GetCharsetInfo called."));
    if (NULL != pcsetInfo)
    {
        EnterCriticalSection(&_cs);
        if (NULL == _pCharset)
            BuildCharsetMimeDatabase();
        if (_pCharset)
        {
            idx = FindCharsetFromCache(Charset);
            if (0 > idx)
                idx = FindCharsetFromRegistry(Charset, FALSE);
            if (0 <= idx)
            {
                *pcsetInfo = _pCharset[idx];
                hr = S_OK;
            }
        }
        LeaveCriticalSection(&_cs);
    }
    return hr;
}

int CMimeDatabaseReg::FindCharsetFromCache(BSTR Charset)
{
    int iStart, iEnd, iMiddle, iCmpResult, iRet = -1;

    iStart = 0;
    iEnd = _cCharset - 1;
    while (iStart <= iEnd)
    {
        iMiddle = (iStart + iEnd) / 2;
        iCmpResult = MLStrCmpIW(Charset, _pCharset[iMiddle].wszCharset);
        if (iCmpResult < 0)
            iEnd = iMiddle - 1;
        else if (iCmpResult > 0)
            iStart = iMiddle + 1;
        else
        {
            iRet = iMiddle;
            break;
        }
    }
    return iRet;
}

int CMimeDatabaseReg::FindCharsetFromRegistry(BSTR Charset, BOOL fFromAlias)
{
    HKEY hKey;
    TCHAR szKey[256], szCharset[MAX_MIMECSET_NAME];
    int iRet = -1;

    WideCharToMultiByte(CP_ACP, 0, Charset, -1, szCharset, ARRAYSIZE(szCharset), NULL, NULL);
    lstrcpy(szKey, REGSTR_KEY_MIME_DATABASE_CHARSET);
    lstrcat(szKey, TEXT("\\"));
    lstrcat(szKey, szCharset);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey))
    {
        DWORD cb, dw;
        TCHAR sz[MAX_MIMECSET_NAME];
        WCHAR wsz[MAX_MIMECSET_NAME];

        cb = sizeof(sz);
        if (FALSE == fFromAlias && ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_ALIASTO, NULL, NULL, (LPBYTE)sz, &cb))
        {
            MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, ARRAYSIZE(wsz));
            iRet = FindCharsetFromCache(wsz);
            if (0 > iRet)
                iRet = FindCharsetFromRegistry(wsz, TRUE);
            if (0 <= iRet)
            {
                MLStrCpyNW(_pCharset[_cCharset].wszCharset, Charset, MAX_MIMECSET_NAME);
                _pCharset[_cCharset].uiCodePage = _pCharset[iRet].uiCodePage;
                _pCharset[_cCharset].uiInternetEncoding = _pCharset[iRet].uiInternetEncoding;
                _cCharset++;
                QSortCharsetInfo(0, _cCharset-1);
                iRet = FindCharsetFromCache(Charset);
            }
        }
        else
        {
            MLStrCpyNW(_pCharset[_cCharset].wszCharset, Charset, MAX_MIMECSET_NAME);
            cb = sizeof(dw);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_CODEPAGE, 0, NULL, (LPBYTE)&dw, &cb))
            {
                _pCharset[_cCharset].uiCodePage = (UINT)dw;
                cb = sizeof(dw);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_INETENCODING, 0, NULL, (LPBYTE)&dw, &cb))
                {
                    _pCharset[_cCharset].uiInternetEncoding = (UINT)dw;
                    _cCharset++;
                    QSortCharsetInfo(0, _cCharset-1);
                    iRet = FindCharsetFromCache(Charset);
                }
            }
        }
        RegCloseKey(hKey);
    }
    return iRet;
}


BOOL CMimeDatabaseReg::CheckFont(BYTE bGDICharset)
{
    BOOL fRet = FALSE;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::CheckFont called."));
    if (DEFAULT_CHARSET == bGDICharset)
        fRet = TRUE;
    else
    {
        HDC     hDC;
        LOGFONT lf;
        HWND    hWnd;

        hWnd = GetTopWindow(GetDesktopWindow());
        hDC = GetDC(hWnd);

        if (NULL != hDC)
        {
            lf.lfFaceName[0] = TEXT('\0');
            lf.lfPitchAndFamily = 0;
            lf.lfCharSet = bGDICharset;
            EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)&fRet, 0);
        }
        ReleaseDC(hWnd, hDC);
    }
    return fRet;
}

void CMimeDatabaseReg::QSortCodePageInfo(LONG left, LONG right)
{
    register LONG i, j;
    WCHAR k[MAX_MIMECP_NAME];
    MIMECPINFO t;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::QSortCodePageInfo called."));
    i = left;
    j = right;
    MLStrCpyW(k, _pCodePage[(left + right) / 2].wszDescription);

    do  
    {
        while(MLStrCmpIW(_pCodePage[i].wszDescription, k) < 0 && i < right)
            i++;
        while (MLStrCmpIW(_pCodePage[j].wszDescription, k) > 0 && j > left)
            j--;

        if (i <= j)
        {
            t = _pCodePage[i];
            _pCodePage[i] = _pCodePage[j];
            _pCodePage[j] = t;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        QSortCodePageInfo(left, j);
    if (i < right)
        QSortCodePageInfo(i, right);
}

void CMimeDatabaseReg::QSortCharsetInfo(LONG left, LONG right)
{
    register LONG i, j;
    WCHAR k[MAX_MIMECSET_NAME];
    MIMECSETINFO t;

    DebugMsg(DM_TRACE, TEXT("CMimeDatabase::QSortCharsetInfo called."));
    i = left;
    j = right;
    MLStrCpyW(k, _pCharset[(left + right) / 2].wszCharset);

    do  
    {
        while(MLStrCmpIW(_pCharset[i].wszCharset, k) < 0 && i < right)
            i++;
        while (MLStrCmpIW(_pCharset[j].wszCharset, k) > 0 && j > left)
            j--;

        if (i <= j)
        {
            t = _pCharset[i];
            _pCharset[i] = _pCharset[j];
            _pCharset[j] = t;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        QSortCharsetInfo(left, j);
    if (i < right)
        QSortCharsetInfo(i, right);
}

// validates all cps that are in the same
// family of the given codepage
STDAPI CMimeDatabaseReg::ValidateCP(UINT uiCodePage)
{
    UINT i;

    if (NULL == _pCodePage)
        BuildCodePageMimeDatabase();
    //
    // just look into already cached codepages
    // 
    for (i = 0; i < _cCodePage; i++)
    {
        if (_pCodePage[i].uiFamilyCodePage == uiCodePage)
            _pCodePage[i].dwFlags |=  MIMECONTF_VALID|MIMECONTF_VALID_NLS;
    }
        
    return S_OK; // never fail?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlatl.h ===
#ifndef _MLATL_H_
#define _MLATL_H_

#define _ATL_FREE_THREADED
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#endif //_MLATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mllbcons.cpp ===
// MLLBCons.cpp : Implementation of CMLLBCons
#include "private.h"
#include "mllbcons.h"
#ifdef ASTRIMPL
#include "mlswalk.h"
#endif
#include "mlstrbuf.h"

/////////////////////////////////////////////////////////////////////////////
// Line Break Character Table

const WCHAR awchNonBreakingAtLineEnd[] = {
    0x0028, // LEFT PARENTHESIS
    0x005B, // LEFT SQUARE BRACKET
    0x007B, // LEFT CURLY BRACKET
    0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x2018, // LEFT SINGLE QUOTATION MARK
    0x201C, // LEFT DOUBLE QUOTATION MARK
    0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x2045, // LEFT SQUARE BRACKET WITH QUILL
    0x207D, // SUPERSCRIPT LEFT PARENTHESIS
    0x208D, // SUBSCRIPT LEFT PARENTHESIS
    0x226A, // MUCH LESS THAN
    0x3008, // LEFT ANGLE BRACKET
    0x300A, // LEFT DOUBLE ANGLE BRACKET
    0x300C, // LEFT CORNER BRACKET
    0x300E, // LEFT WHITE CORNER BRACKET
    0x3010, // LEFT BLACK LENTICULAR BRACKET
    0x3014, // LEFT TORTOISE SHELL BRACKET
    0x3016, // LEFT WHITE LENTICULAR BRACKET
    0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
    0x301A, // LEFT WHITE SQUARE BRACKET
    0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
    0xFD3E, // ORNATE LEFT PARENTHESIS
    0xFE35, // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
    0xFE37, // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
    0xFE39, // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET
    0xFE3B, // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET
    0xFE3D, // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET
    0xFE3F, // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET
    0xFE41, // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
    0xFE43, // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET
    0xFE59, // SMALL LEFT PARENTHESIS
    0xFE5B, // SMALL LEFT CURLY BRACKET
    0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
    0xFF08, // FULLWIDTH LEFT PARENTHESIS
    0xFF1C, // FULLWIDTH LESS-THAN SIGN
    0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
    0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
    0xFF62, // HALFWIDTH LEFT CORNER BRACKET
    0xFFE9  // HALFWIDTH LEFTWARDS ARROW
};

const WCHAR awchNonBreakingAtLineStart[] = {
    0x0029, // RIGHT PARENTHESIS
    0x002D, // HYPHEN
    0x005D, // RIGHT SQUARE BRACKET
    0x007D, // RIGHT CURLY BRACKET
    0x00AD, // OPTIONAL HYPHEN
    0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x02C7, // CARON
    0x02C9, // MODIFIER LETTER MACRON
    0x055D, // ARMENIAN COMMA
    0x060C, // ARABIC COMMA
    0x2013, // EN DASH
    0x2014, // EM DASH
    0x2016, // DOUBLE VERTICAL LINE
    0x201D, // RIGHT DOUBLE QUOTATION MARK
    0x2022, // BULLET
    0x2025, // TWO DOT LEADER
    0x2026, // HORIZONTAL ELLIPSIS
    0x2027, // HYPHENATION POINT
    0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x2046, // RIGHT SQUARE BRACKET WITH QUILL
    0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
    0x208E, // SUBSCRIPT RIGHT PARENTHESIS
    0x226B, // MUCH GREATER THAN
    0x2574, // BOX DRAWINGS LIGHT LEFT
    0x3001, // IDEOGRAPHIC COMMA
    0x3002, // IDEOGRAPHIC FULL STOP
    0x3003, // DITTO MARK
    0x3005, // IDEOGRAPHIC ITERATION MARK
    0x3009, // RIGHT ANGLE BRACKET
    0x300B, // RIGHT DOUBLE ANGLE BRACKET
    0x300D, // RIGHT CORNER BRACKET
    0x300F, // RIGHT WHITE CORNER BRACKET
    0x3011, // RIGHT BLACK LENTICULAR BRACKET
    0x3015, // RIGHT TORTOISE SHELL BRACKET
    0x3017, // RIGHT WHITE LENTICULAR BRACKET
    0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
    0x301B, // RIGHT WHITE SQUARE BRACKET
    0x301E, // DOUBLE PRIME QUOTATION MARK
    0x3041, // HIRAGANA LETTER SMALL A
    0x3043, // HIRAGANA LETTER SMALL I
    0x3045, // HIRAGANA LETTER SMALL U
    0x3047, // HIRAGANA LETTER SMALL E
    0x3049, // HIRAGANA LETTER SMALL O
    0x3063, // HIRAGANA LETTER SMALL TU
    0x3083, // HIRAGANA LETTER SMALL YA
    0x3085, // HIRAGANA LETTER SMALL YU
    0x3087, // HIRAGANA LETTER SMALL YO
    0x308E, // HIRAGANA LETTER SMALL WA
    0x309B, // KATAKANA-HIRAGANA VOICED SOUND MARK
    0x309C, // KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
    0x309D, // HIRAGANA ITERATION MARK
    0x309E, // HIRAGANA VOICED ITERATION MARK
    0x30A1, // KATAKANA LETTER SMALL A
    0x30A3, // KATAKANA LETTER SMALL I
    0x30A5, // KATAKANA LETTER SMALL U
    0x30A7, // KATAKANA LETTER SMALL E
    0x30A9, // KATAKANA LETTER SMALL O
    0x30C3, // KATAKANA LETTER SMALL TU
    0x30E3, // KATAKANA LETTER SMALL YA
    0x30E5, // KATAKANA LETTER SMALL YU
    0x30E7, // KATAKANA LETTER SMALL YO
    0x30EE, // KATAKANA LETTER SMALL WA
    0x30F5, // KATAKANA LETTER SMALL KA
    0x30F6, // KATAKANA LETTER SMALL KE
    0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0x30FD, // KATAKANA ITERATION MARK
    0x30FE, // KATAKANA VOICED ITERATION MARK
    0xFD3F, // ORNATE RIGHT PARENTHESIS
    0xFE30, // VERTICAL TWO DOT LEADER
    0xFE31, // VERTICAL EM DASH
    0xFE33, // VERTICAL LOW LINE
    0xFE34, // VERTICAL WAVY LOW LINE
    0xFE36, // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
    0xFE38, // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    0xFE3A, // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET
    0xFE3C, // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET
    0xFE3E, // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET
    0xFE40, // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
    0xFE42, // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET
    0xFE44, // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET
    0xFE4F, // WAVY LOW LINE
    0xFE50, // SMALL COMMA
    0xFE51, // SMALL IDEOGRAPHIC COMMA
    0xFE5A, // SMALL RIGHT PARENTHESIS
    0xFE5C, // SMALL RIGHT CURLY BRACKET
    0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
    0xFF09, // FULLWIDTH RIGHT PARENTHESIS
    0xFF0C, // FULLWIDTH COMMA
    0xFF0E, // FULLWIDTH FULL STOP
    0xFF1E, // FULLWIDTH GREATER-THAN SIGN
    0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
    0xFF40, // FULLWIDTH GRAVE ACCENT
    0xFF5C, // FULLWIDTH VERTICAL LINE
    0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
    0xFF5E, // FULLWIDTH TILDE
    0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
    0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
    0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA
    0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
    0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
    0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
    0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
    0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
    0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
    0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
    0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
    0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
    0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0xFF9E, // HALFWIDTH KATAKANA VOICED SOUND MARK
    0xFF9F, // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
    0xFFEB  // HALFWIDTH RIGHTWARDS ARROW
};

const WCHAR awchRomanInterWordSpace[] = {
    0x0009, // TAB
    0x0020, // SPACE
    0x2002, // EN SPACE
    0x2003, // EM SPACE
    0x2004, // THREE-PER-EM SPACE
    0x2005, // FOUR-PER-EM SPACE
    0x2006, // SIX-PER-EM SPACE
    0x2007, // FIGURE SPACE
    0x2008, // PUNCTUATION SPACE
    0x2009, // THIN SPACE
    0x200A, // HAIR SPACE
    0x200B  // ZERO WIDTH SPACE
};

BOOL ScanWChar(const WCHAR awch[], int nArraySize, WCHAR wch)
{
    int iMin = 0;
    int iMax = nArraySize - 1;

    while (iMax - iMin >= 2)
    {
        int iTry = (iMax + iMin + 1) / 2;
        if (wch < awch[iTry])
            iMax = iTry;
        else if  (wch > awch[iTry])
            iMin = iTry;
        else
            return TRUE;
    }

    return (wch == awch[iMin] || wch == awch[iMax]);
}

#ifdef MLLBCONS_DEBUG
void TestTable(const WCHAR awch[], int nArraySize)
{
    int nDummy;

    for (int i = 0; i < nArraySize - 1; i++)
    {
        if (awch[i] >= awch[i + 1])
            nDummy = 0;
    }

    int cFound = 0;
    for (int n = 0; n < 0x10000; n++)
    {
        if (ScanWChar(awch, nArraySize, n))
        {
            cFound++;
            for (i = 0; i < nArraySize; i++)
            {
                if (awch[i] == n)
                    break;
            }
            ASSERT(i < nArraySize);
        }
    }
    ASSERT(cFound == nArraySize);
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLLBCons

STDMETHODIMP CMLLBCons::BreakLineML(IMLangString* pSrcMLStr, long lSrcPos, long lSrcLen, long cMinColumns, long cMaxColumns, long* plLineLen, long* plSkipLen)
{
#ifdef MLLBCONS_DEBUG
    TestTable(awchNonBreakingAtLineEnd, ARRAYSIZE(awchNonBreakingAtLineEnd));
    TestTable(awchNonBreakingAtLineStart, ARRAYSIZE(awchNonBreakingAtLineStart));
    TestTable(awchRomanInterWordSpace, ARRAYSIZE(awchRomanInterWordSpace));
#endif
    ASSERT_THIS;
    ASSERT_READ_PTR(pSrcMLStr);
    ASSERT_WRITE_PTR_OR_NULL(plLineLen);
    ASSERT_WRITE_PTR_OR_NULL(plSkipLen);

    HRESULT hr;
    IMLangStringWStr* pMLStrWStr;
    long lStrLen;
    long lBreakPos = -1; // Break at default position(cMaxColumns)
    long lSkipLen = 0;
    long lPrevBreakPos = 0;
    long lPrevSkipLen = 0;

    if (SUCCEEDED(hr = pSrcMLStr->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrWStr)) &&
        SUCCEEDED(hr = pSrcMLStr->GetLength(&lStrLen)) &&
        SUCCEEDED(hr = ::RegularizePosLen(lStrLen, &lSrcPos, &lSrcLen)))
    {
        long cColumns = 0;
#ifndef ASTRIMPL
        long lSrcPosTemp = lSrcPos;
        long lSrcLenTemp = lSrcLen;
#endif
        long lCandPos = 0;
        struct {
            unsigned fDone : 1;
            unsigned fInSpaces : 1;
            unsigned fFEChar : 1;
            unsigned fInFEChar : 1;
            unsigned fBreakByEndOfLine : 1;
            unsigned fNonBreakNext : 1;
            unsigned fHaveCandPos : 1;
            unsigned fSlashR : 1;
        } Flags = {0, 0, 0, 0, 0, 0, 0, 0};
#ifdef ASTRIMPL
        CCharType<CT_CTYPE3, 128> ct3;
        CMLStrWalkW StrWalk(pMLStrWStr, lSrcPos, lSrcLen);
#else

        LCID locale;
        hr = pMLStrWStr->GetLocale(0, -1, &locale, NULL, NULL);
        CCharType<CT_CTYPE3, 128> ct3(locale);
#endif


#ifdef ASTRIMPL
        while (StrWalk.Lock(hr))
        {
                ct3.Flush();

                for (int iCh = 0; iCh < StrWalk.GetCCh(); iCh++)
                {
                    const WCHAR wch = StrWalk.GetStr()[iCh];
                    const WORD wCharType3 = ct3.GetCharType(pSrcMLStr, StrWalk.GetPos() + iCh, StrWalk.GetLen() - iCh, &hr);
                    if (FAILED(hr))
                        break;
#else
        while (lSrcLenTemp > 0 && SUCCEEDED(hr))
        {
            WCHAR* pszBuf;
            long cchBuf;
            long lLockedLen;

            ct3.Flush();

            if (SUCCEEDED(hr = pMLStrWStr->LockWStr(lSrcPosTemp, lSrcLenTemp, MLSTR_READ, 0, &pszBuf, &cchBuf, &lLockedLen)))
            {
                for (int iCh = 0; iCh < cchBuf; iCh++)
                {
                    const WCHAR wch = pszBuf[iCh];
                    const WORD wCharType3 = ct3.GetCharType(pszBuf + iCh, cchBuf - iCh);
#endif
                    const int nWidth = (wCharType3 & C3_HALFWIDTH) ? 1 : 2;

                    if (wch == L'\r' && !Flags.fSlashR)
                    {
                        Flags.fSlashR = TRUE;
                    }
                    else if (wch == L'\n' || Flags.fSlashR) // End of line
                    {
                        Flags.fDone = TRUE;
                        Flags.fBreakByEndOfLine = TRUE;
                        if (Flags.fInSpaces)
                        {
                            Flags.fHaveCandPos = FALSE;
                            lBreakPos = lCandPos;
                            lSkipLen++; // Skip spaces and line break character
                        }
                        else
                        {
#ifdef ASTRIMPL
                            lBreakPos = StrWalk.GetPos() + iCh; // Break at right before the end of line
#else
                            lBreakPos = lSrcPosTemp + iCh; // Break at right before the end of line
#endif
                            if (Flags.fSlashR)
                                lBreakPos--;

                            lSkipLen = 1; // Skip line break character
                        }
                        if (wch == L'\n' && Flags.fSlashR)
                            lSkipLen++;
                        break;
                    }
                    else if (ScanWChar(awchRomanInterWordSpace, ARRAYSIZE(awchRomanInterWordSpace), wch)) // Spaces
                    {
                        if (!Flags.fInSpaces)
                        {
                            Flags.fHaveCandPos = TRUE;
#ifdef ASTRIMPL
                            lCandPos = StrWalk.GetPos() + iCh; // Break at right before the spaces
#else
                            lCandPos = lSrcPosTemp + iCh; // Break at right before the spaces
#endif
                            lSkipLen = 0;
                        }
                        Flags.fInSpaces = TRUE;
                        lSkipLen++; // Skip continuous spaces after breaking
                    }
                    else // Other characters
                    {
                        Flags.fFEChar = ((wCharType3 & (C3_KATAKANA | C3_HIRAGANA | C3_FULLWIDTH | C3_IDEOGRAPH)) != 0);

                        if ((Flags.fFEChar || Flags.fInFEChar) && !Flags.fNonBreakNext && !Flags.fInSpaces)
                        {
                            Flags.fHaveCandPos = TRUE;
#ifdef ASTRIMPL
                            lCandPos = StrWalk.GetPos() + iCh; // Break at right before or after the FE char
#else
                            lCandPos = lSrcPosTemp + iCh; // Break at right before or after the FE char
#endif
                            lSkipLen = 0;
                        }
                        Flags.fInFEChar = Flags.fFEChar;
                        Flags.fInSpaces = FALSE;

                        if (Flags.fHaveCandPos)
                        {
                            Flags.fHaveCandPos = FALSE;
                            if (!ScanWChar(awchNonBreakingAtLineStart, ARRAYSIZE(awchNonBreakingAtLineStart), wch))
                                lBreakPos = lCandPos;
                        }

                        if (cColumns + nWidth > cMaxColumns)
                        {
                            Flags.fDone = TRUE;
                            if (Flags.fNonBreakNext && lPrevSkipLen)
                            {
                                lBreakPos = lPrevBreakPos;
                                lSkipLen = lPrevSkipLen;
                            }
                            break;
                        }

                        Flags.fNonBreakNext = ScanWChar(awchNonBreakingAtLineEnd, ARRAYSIZE(awchNonBreakingAtLineEnd), wch);
                        
                        if (Flags.fNonBreakNext)
                        {
                            // Need to remember previous break postion in case the line been terminated by the max columns
                            lPrevBreakPos = lBreakPos;
                            lPrevSkipLen = lSkipLen;
                        }
                    }

                    cColumns += nWidth;
                }
#ifdef ASTRIMPL
                StrWalk.Unlock(hr);

                if (Flags.fDone && SUCCEEDED(hr))
                    break;
#else
                HRESULT hrTemp = pMLStrWStr->UnlockWStr(pszBuf, 0, NULL, NULL);
                if (FAILED(hrTemp) && SUCCEEDED(hr))
                    hr = hrTemp;

                if (Flags.fDone && SUCCEEDED(hr))
                    break;

                lSrcPosTemp += lLockedLen;
                lSrcLenTemp -= lLockedLen;
            }
#endif
        }

        pMLStrWStr->Release();

        if (Flags.fHaveCandPos)
            lBreakPos = lCandPos;

        if (SUCCEEDED(hr) && !Flags.fBreakByEndOfLine && lBreakPos - lSrcPos < cMinColumns)
        {
            lBreakPos = min(lSrcLen, cMaxColumns) + lSrcPos; // Default breaking
            lSkipLen = 0;
        }

        if (SUCCEEDED(hr) && !Flags.fDone)
        {
            if (Flags.fInSpaces)
            {
                lBreakPos = lSrcLen - lSkipLen;
            }
            else
            {
                lBreakPos = lSrcLen;
                lSkipLen = 0;
            }
            if (Flags.fSlashR)
            {
                lBreakPos--;
                lSkipLen++;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (plLineLen)
            *plLineLen = lBreakPos - lSrcPos;
        if (plSkipLen)
            *plSkipLen = lSkipLen;
    }
    else
    {
        if (plLineLen)
            *plLineLen = 0;
        if (plSkipLen)
            *plSkipLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLLBCons::BreakLineW(LCID locale, const WCHAR* pszSrc, long cchSrc, long lMaxColumns, long* pcchLine, long* pcchSkip)
{
    ASSERT_THIS;
	ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchLine);
    ASSERT_WRITE_PTR_OR_NULL(pcchSkip);

    HRESULT hr = S_OK;
    IMLangStringWStr* pMLStrW;

    if (SUCCEEDED(hr = PrepareMLStrClass()) &&
        SUCCEEDED(hr = m_pMLStrClass->CreateInstance(NULL, IID_IMLangStringWStr, (void**)&pMLStrW)))
    {
        CMLStrBufConstStackW StrBuf((LPWSTR)pszSrc, cchSrc);
        long lLineLen;
        long lSkipLen;
    
        hr = pMLStrW->SetStrBufW(0, -1, &StrBuf, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pMLStrW->SetLocale(0, -1, locale);

        if (SUCCEEDED(hr))
            hr = BreakLineML(pMLStrW, 0, -1, 0, lMaxColumns, (pcchLine || pcchSkip) ? &lLineLen : NULL, (pcchSkip) ? &lSkipLen : NULL);

        if (SUCCEEDED(hr) && pcchLine)
            hr = pMLStrW->GetWStr(0, lLineLen, NULL, 0, pcchLine, NULL);

        if (SUCCEEDED(hr) && pcchSkip)
            hr = pMLStrW->GetWStr(lLineLen, lSkipLen, NULL, 0, pcchSkip, NULL);

        pMLStrW->Release();
    }

    if (FAILED(hr))
    {
        if (pcchLine)
            *pcchLine = 0;
        if (pcchSkip)
            *pcchSkip = 0;
    }

    return hr;
}

STDMETHODIMP CMLLBCons::BreakLineA(LCID locale, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long lMaxColumns, long* pcchLine, long* pcchSkip)
{
    ASSERT_THIS;
	ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchLine);
    ASSERT_WRITE_PTR_OR_NULL(pcchSkip);

    HRESULT hr = S_OK;
    IMLangStringAStr* pMLStrA;

    if (uCodePage == 50000)
        uCodePage = 1252;

    if (SUCCEEDED(hr = PrepareMLStrClass()) &&
        SUCCEEDED(hr = m_pMLStrClass->CreateInstance(NULL, IID_IMLangStringAStr, (void**)&pMLStrA)))
    {
        CMLStrBufConstStackA StrBuf((LPSTR)pszSrc, cchSrc);
        long lLineLen;
        long lSkipLen;
    
        hr = pMLStrA->SetStrBufA(0, -1, uCodePage, &StrBuf, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pMLStrA->SetLocale(0, -1, locale);

        if (SUCCEEDED(hr))
            hr = BreakLineML(pMLStrA, 0, -1, 0, lMaxColumns, (pcchLine || pcchSkip) ? &lLineLen : NULL, (pcchSkip) ? &lSkipLen : NULL);

        if (SUCCEEDED(hr) && pcchLine)
            hr = pMLStrA->GetAStr(0, lLineLen, uCodePage, NULL, NULL, 0, pcchLine, NULL);

        if (SUCCEEDED(hr) && pcchSkip)
            hr = pMLStrA->GetAStr(lLineLen, lSkipLen, uCodePage, NULL, NULL, 0, pcchSkip, NULL);

        pMLStrA->Release();
    }

    if (FAILED(hr))
    {
        if (pcchLine)
            *pcchLine = 0;
        if (pcchSkip)
            *pcchSkip = 0;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlflink.cpp ===
// MLFLink.cpp : Implementation of CMLFLink
#include "private.h"
#include "mlmain.h"
#include "codepage.h"

#ifdef UNIX
inline WORD READWINTELWORD(WORD w)
{
  return ( w << 8 | w >> 8 );
}

inline DWORD READWINTELDWORD(DWORD dw)
{
  return READWINTELWORD( (WORD)(dw >> 16 )) | ((DWORD)READWINTELWORD( dw & 0xffff)) << 16;
}
#else
#define READWINTELWORD
#define READWINTELDWORD
#endif

IMLangFontLink *g_pMLFLink = NULL;

CMLFLink::CCodePagesCache* CMLFLink::m_pCodePagesCache = NULL;
CMLFLink::CFontMappingCache* CMLFLink::m_pFontMappingCache = NULL;
CMLFLink2::CFontMappingCache2* CMLFLink2::m_pFontMappingCache2 = NULL;

// Strings to identify regular font
const char szRegular[]    = "Regular";
const char szNormal[]     = "Normal";

// font table
FONTINFO *g_pfont_table = NULL;

// Unicode range table for non Windows code page code points
// Data is provided by NT international group.
URANGEFONT g_urange_table[] = {
{0x0108, 0x010B, 0},
{0x0114, 0x0115, 0},
{0x011C, 0x011D, 0},
{0x0120, 0x0121, 0},
{0x0124, 0x0125, 0},
{0x0128, 0x0129, 0},
{0x012C, 0x012D, 0},
{0x0134, 0x0135, 0},
{0x014E, 0x014F, 0},
{0x015C, 0x015D, 0},
{0x0168, 0x0169, 0},
{0x016C, 0x016D, 0},
{0x0174, 0x0177, 0},
{0x017F, 0x0191, 0},
{0x0193, 0x019F, 0},
{0x01A2, 0x01AE, 0},
{0x01B1, 0x01CD, 0},
{0x01CF, 0x01CF, 0},
{0x01D1, 0x01D1, 0},
{0x01D3, 0x01D3, 0},
{0x01D5, 0x01D5, 0},
{0x01D7, 0x01D7, 0},
{0x01D9, 0x01D9, 0},
{0x01DB, 0x01DB, 0},
{0x01DD, 0x01F5, 0},
{0x01FA, 0x0217, 0},
{0x0250, 0x0250, 0},
{0x0252, 0x0260, 0},
{0x0262, 0x02A8, 0},
{0x02B0, 0x02C5, 0},
{0x02C8, 0x02C8, 0},
{0x02CC, 0x02CC, 0},
{0x02CE, 0x02CF, 0},
{0x02D1, 0x02D7, 0},
{0x02DE, 0x02DE, 0},
{0x02E0, 0x02E9, 0},
{0x0302, 0x0302, 0},
{0x0304, 0x0308, 0},
{0x030A, 0x0322, 0},
{0x0324, 0x0345, 0},
{0x0360, 0x0361, 0},
{0x0374, 0x0375, 0},
{0x037A, 0x037A, 0},
{0x037E, 0x037E, 0},
{0x0387, 0x0387, 0},
{0x03D0, 0x03D6, 0},
{0x03DA, 0x03DA, 0},
{0x03DC, 0x03DC, 0},
{0x03DE, 0x03DE, 0},
{0x03E0, 0x03E0, 0},
{0x03E2, 0x03F3, 0},
{0x0460, 0x0486, 0},
{0x0492, 0x04C4, 0},
{0x04C7, 0x04C8, 0},
{0x04CB, 0x04CC, 0},
{0x04D0, 0x04EB, 0},
{0x04EE, 0x04F5, 0},
{0x04F8, 0x04F9, 0},
{0x0531, 0x0556, 0},
{0x0559, 0x055F, 0},
{0x0561, 0x0587, 0},
{0x0589, 0x0589, 0},
{0x0591, 0x05A1, 0},
{0x05A3, 0x05AF, 0},
{0x05C4, 0x05C4, 0},
{0x0660, 0x066D, 0},
{0x0670, 0x067D, 0},
{0x067F, 0x0685, 0},
{0x0687, 0x0697, 0},
{0x0699, 0x06AE, 0},
{0x06B0, 0x06B7, 0},
{0x06BA, 0x06BE, 0},
{0x06C0, 0x06CE, 0},
{0x06D0, 0x06ED, 0},
{0x06F0, 0x06F9, 0},
{0x0901, 0x0903, 0},
{0x0905, 0x0939, 0},
{0x093C, 0x094D, 0},
{0x0950, 0x0954, 0},
{0x0958, 0x0970, 0},
{0x0981, 0x0983, 0},
{0x0985, 0x098C, 0},
{0x098F, 0x0990, 0},
{0x0993, 0x09A8, 0},
{0x09AA, 0x09B0, 0},
{0x09B2, 0x09B2, 0},
{0x09B6, 0x09B9, 0},
{0x09BC, 0x09BC, 0},
{0x09BE, 0x09C4, 0},
{0x09C7, 0x09C8, 0},
{0x09CB, 0x09CD, 0},
{0x09D7, 0x09D7, 0},
{0x09DC, 0x09DD, 0},
{0x09DF, 0x09E3, 0},
{0x09E6, 0x09FA, 0},
{0x0A02, 0x0A02, 0},
{0x0A05, 0x0A0A, 0},
{0x0A0F, 0x0A10, 0},
{0x0A13, 0x0A28, 0},
{0x0A2A, 0x0A30, 0},
{0x0A32, 0x0A33, 0},
{0x0A35, 0x0A36, 0},
{0x0A38, 0x0A39, 0},
{0x0A3C, 0x0A3C, 0},
{0x0A3E, 0x0A42, 0},
{0x0A47, 0x0A48, 0},
{0x0A4B, 0x0A4D, 0},
{0x0A59, 0x0A5C, 0},
{0x0A5E, 0x0A5E, 0},
{0x0A66, 0x0A74, 0},
{0x0A81, 0x0A83, 0},
{0x0A85, 0x0A8B, 0},
{0x0A8D, 0x0A8D, 0},
{0x0A8F, 0x0A91, 0},
{0x0A93, 0x0AA8, 0},
{0x0AAA, 0x0AB0, 0},
{0x0AB2, 0x0AB3, 0},
{0x0AB5, 0x0AB9, 0},
{0x0ABC, 0x0AC5, 0},
{0x0AC7, 0x0AC9, 0},
{0x0ACB, 0x0ACD, 0},
{0x0AD0, 0x0AD0, 0},
{0x0AE0, 0x0AE0, 0},
{0x0AE6, 0x0AEF, 0},
{0x0B01, 0x0B03, 0},
{0x0B05, 0x0B0C, 0},
{0x0B0F, 0x0B10, 0},
{0x0B13, 0x0B28, 0},
{0x0B2A, 0x0B30, 0},
{0x0B32, 0x0B33, 0},
{0x0B36, 0x0B39, 0},
{0x0B3C, 0x0B43, 0},
{0x0B47, 0x0B48, 0},
{0x0B4B, 0x0B4D, 0},
{0x0B56, 0x0B57, 0},
{0x0B5C, 0x0B5D, 0},
{0x0B5F, 0x0B61, 0},
{0x0B66, 0x0B70, 0},
{0x0B82, 0x0B83, 0},
{0x0B85, 0x0B8A, 0},
{0x0B8E, 0x0B90, 0},
{0x0B92, 0x0B95, 0},
{0x0B99, 0x0B9A, 0},
{0x0B9C, 0x0B9C, 0},
{0x0B9E, 0x0B9F, 0},
{0x0BA3, 0x0BA4, 0},
{0x0BA8, 0x0BAA, 0},
{0x0BAE, 0x0BB5, 0},
{0x0BB7, 0x0BB9, 0},
{0x0BBE, 0x0BC2, 0},
{0x0BC6, 0x0BC8, 0},
{0x0BCA, 0x0BCD, 0},
{0x0BD7, 0x0BD7, 0},
{0x0BE7, 0x0BF2, 0},
{0x0C01, 0x0C03, 0},
{0x0C05, 0x0C0C, 0},
{0x0C0E, 0x0C10, 0},
{0x0C12, 0x0C28, 0},
{0x0C2A, 0x0C33, 0},
{0x0C35, 0x0C39, 0},
{0x0C3E, 0x0C44, 0},
{0x0C46, 0x0C48, 0},
{0x0C4A, 0x0C4D, 0},
{0x0C55, 0x0C56, 0},
{0x0C60, 0x0C61, 0},
{0x0C66, 0x0C6F, 0},
{0x0C82, 0x0C83, 0},
{0x0C85, 0x0C8C, 0},
{0x0C8E, 0x0C90, 0},
{0x0C92, 0x0CA8, 0},
{0x0CAA, 0x0CB3, 0},
{0x0CB5, 0x0CB9, 0},
{0x0CBE, 0x0CC4, 0},
{0x0CC6, 0x0CC8, 0},
{0x0CCA, 0x0CCD, 0},
{0x0CD5, 0x0CD6, 0},
{0x0CDE, 0x0CDE, 0},
{0x0CE0, 0x0CE1, 0},
{0x0CE6, 0x0CEF, 0},
{0x0D02, 0x0D03, 0},
{0x0D05, 0x0D0C, 0},
{0x0D0E, 0x0D10, 0},
{0x0D12, 0x0D28, 0},
{0x0D2A, 0x0D39, 0},
{0x0D3E, 0x0D43, 0},
{0x0D46, 0x0D48, 0},
{0x0D4A, 0x0D4D, 0},
{0x0D57, 0x0D57, 0},
{0x0D60, 0x0D61, 0},
{0x0D66, 0x0D6F, 0},
{0x0E81, 0x0E82, 0},
{0x0E84, 0x0E84, 0},
{0x0E87, 0x0E88, 0},
{0x0E8A, 0x0E8A, 0},
{0x0E8D, 0x0E8D, 0},
{0x0E94, 0x0E97, 0},
{0x0E99, 0x0E9F, 0},
{0x0EA1, 0x0EA3, 0},
{0x0EA5, 0x0EA5, 0},
{0x0EA7, 0x0EA7, 0},
{0x0EAA, 0x0EAB, 0},
{0x0EAD, 0x0EB9, 0},
{0x0EBB, 0x0EBD, 0},
{0x0EC0, 0x0EC4, 0},
{0x0EC6, 0x0EC6, 0},
{0x0EC8, 0x0ECD, 0},
{0x0ED0, 0x0ED9, 0},
{0x0EDC, 0x0EDD, 0},
{0x0F00, 0x0F47, 0},
{0x0F49, 0x0F69, 0},
{0x0F71, 0x0F8B, 0},
{0x0F90, 0x0F95, 0},
{0x0F97, 0x0F97, 0},
{0x0F99, 0x0FAD, 0},
{0x0FB1, 0x0FB7, 0},
{0x0FB9, 0x0FB9, 0},
{0x10A0, 0x10C5, 0},
{0x10D0, 0x10F6, 0},
{0x10FB, 0x10FB, 0},
{0x1100, 0x1159, 0},
{0x115F, 0x11A2, 0},
{0x11A8, 0x11F9, 0},
{0x1E00, 0x1E9B, 0},
{0x1EA0, 0x1EF9, 0},
{0x1F00, 0x1F15, 0},
{0x1F18, 0x1F1D, 0},
{0x1F20, 0x1F45, 0},
{0x1F48, 0x1F4D, 0},
{0x1F50, 0x1F57, 0},
{0x1F59, 0x1F59, 0},
{0x1F5B, 0x1F5B, 0},
{0x1F5D, 0x1F5D, 0},
{0x1F5F, 0x1F7D, 0},
{0x1F80, 0x1FB4, 0},
{0x1FB6, 0x1FC4, 0},
{0x1FC6, 0x1FD3, 0},
{0x1FD6, 0x1FDB, 0},
{0x1FDD, 0x1FEF, 0},
{0x1FF2, 0x1FF4, 0},
{0x1FF6, 0x1FFE, 0},
{0x2000, 0x200B, 0},
{0x2011, 0x2012, 0},
{0x2017, 0x2017, 0},
{0x201B, 0x201B, 0},
{0x201F, 0x201F, 0},
{0x2023, 0x2024, 0},
{0x2028, 0x202E, 0},
{0x2031, 0x2031, 0},
{0x2034, 0x2034, 0},
{0x2036, 0x2038, 0},
{0x203C, 0x2046, 0},
{0x206A, 0x2070, 0},
{0x2075, 0x207E, 0},
{0x2080, 0x2080, 0},
{0x2085, 0x208E, 0},
{0x20A0, 0x20A9, 0},
{0x20D0, 0x20E1, 0},
{0x2100, 0x2102, 0},
{0x2104, 0x2104, 0},
{0x2106, 0x2108, 0},
{0x210A, 0x2112, 0},
{0x2114, 0x2115, 0},
{0x2117, 0x2120, 0},
{0x2123, 0x2125, 0},
{0x2127, 0x212A, 0},
{0x212C, 0x2138, 0},
{0x2155, 0x215A, 0},
{0x215F, 0x215F, 0},
{0x216C, 0x216F, 0},
{0x217A, 0x2182, 0},
{0x219A, 0x21D1, 0},
{0x21D3, 0x21D3, 0},
{0x21D5, 0x21EA, 0},
{0x2201, 0x2201, 0},
{0x2204, 0x2206, 0},
{0x2209, 0x220A, 0},
{0x220C, 0x220E, 0},
{0x2210, 0x2210, 0},
{0x2212, 0x2214, 0},
{0x2216, 0x2219, 0},
{0x221B, 0x221C, 0},
{0x2221, 0x2222, 0},
{0x2224, 0x2224, 0},
{0x2226, 0x2226, 0},
{0x222D, 0x222D, 0},
{0x222F, 0x2233, 0},
{0x2238, 0x223B, 0},
{0x223E, 0x2247, 0},
{0x2249, 0x224B, 0},
{0x224D, 0x2251, 0},
{0x2253, 0x225F, 0},
{0x2262, 0x2263, 0},
{0x2268, 0x2269, 0},
{0x226C, 0x226D, 0},
{0x2270, 0x2281, 0},
{0x2284, 0x2285, 0},
{0x2288, 0x2294, 0},
{0x2296, 0x2298, 0},
{0x229A, 0x22A4, 0},
{0x22A6, 0x22BE, 0},
{0x22C0, 0x22F1, 0},
{0x2300, 0x2300, 0},
{0x2302, 0x2311, 0},
{0x2313, 0x237A, 0},
{0x2400, 0x2424, 0},
{0x2440, 0x244A, 0},
{0x24B6, 0x24CF, 0},
{0x24EA, 0x24EA, 0},
{0x254C, 0x254F, 0},
{0x2575, 0x2580, 0},
{0x2590, 0x2591, 0},
{0x25A2, 0x25A2, 0},
{0x25AA, 0x25B1, 0},
{0x25B4, 0x25B5, 0},
{0x25B8, 0x25BB, 0},
{0x25BE, 0x25BF, 0},
{0x25C2, 0x25C5, 0},
{0x25C9, 0x25CA, 0},
{0x25CC, 0x25CD, 0},
{0x25D2, 0x25E1, 0},
{0x25E6, 0x25EE, 0},
{0x2600, 0x2604, 0},
{0x2607, 0x2608, 0},
{0x260A, 0x260D, 0},
{0x2610, 0x2613, 0},
{0x261A, 0x261B, 0},
{0x261D, 0x261D, 0},
{0x261F, 0x263F, 0},
{0x2641, 0x2641, 0},
{0x2643, 0x265F, 0},
{0x2662, 0x2662, 0},
{0x2666, 0x2666, 0},
{0x266B, 0x266B, 0},
{0x266E, 0x266E, 0},
{0x2701, 0x2704, 0},
{0x2706, 0x2709, 0},
{0x270C, 0x2727, 0},
{0x2729, 0x274B, 0},
{0x274D, 0x274D, 0},
{0x274F, 0x2752, 0},
{0x2756, 0x2756, 0},
{0x2758, 0x275E, 0},
{0x2761, 0x2767, 0},
{0x2776, 0x2794, 0},
{0x2798, 0x27AF, 0},
{0x27B1, 0x27BE, 0},
{0x3004, 0x3004, 0},
{0x3018, 0x301C, 0},
{0x3020, 0x3020, 0},
{0x302A, 0x3037, 0},
{0x303F, 0x303F, 0},
{0x3094, 0x3094, 0},
{0x3099, 0x309A, 0},
{0x30F7, 0x30FA, 0},
{0x312A, 0x312C, 0},
{0x3190, 0x319F, 0},
{0x322A, 0x3230, 0},
{0x3233, 0x3238, 0},
{0x323A, 0x3243, 0},
{0x3280, 0x32A2, 0},
{0x32A9, 0x32B0, 0},
{0x32C0, 0x32CB, 0},
{0x32D0, 0x32FE, 0},
{0x3300, 0x3302, 0},
{0x3304, 0x330C, 0},
{0x330E, 0x3313, 0},
{0x3315, 0x3317, 0},
{0x3319, 0x3321, 0},
{0x3324, 0x3325, 0},
{0x3328, 0x332A, 0},
{0x332C, 0x3335, 0},
{0x3337, 0x333A, 0},
{0x333C, 0x3348, 0},
{0x334B, 0x334C, 0},
{0x334E, 0x3350, 0},
{0x3352, 0x3356, 0},
{0x3358, 0x3376, 0},
{0x337F, 0x337F, 0},
{0x3385, 0x3387, 0},
{0x33CB, 0x33CC, 0},
{0x33D4, 0x33D4, 0},
{0x33D7, 0x33D7, 0},
{0x33D9, 0x33DA, 0},
{0x33E0, 0x33FE, 0},
{0xFB00, 0xFB06, 0},
{0xFB13, 0xFB17, 0},
{0xFB1E, 0xFB36, 0},
{0xFB38, 0xFB3C, 0},
{0xFB3E, 0xFB3E, 0},
{0xFB40, 0xFB41, 0},
{0xFB43, 0xFB44, 0},
{0xFB46, 0xFBB1, 0},
{0xFBD3, 0xFD3F, 0},
{0xFD50, 0xFD8F, 0},
{0xFD92, 0xFDC7, 0},
{0xFDF0, 0xFDFB, 0},
{0xFE20, 0xFE23, 0},
{0xFE32, 0xFE32, 0},
{0xFE58, 0xFE58, 0},
{0xFE70, 0xFE72, 0},
{0xFE74, 0xFE74, 0},
{0xFE76, 0xFEFC, 0},
{0xFEFF, 0xFEFF, 0},
{0xFFA0, 0xFFBE, 0},
{0xFFC2, 0xFFC7, 0},
{0xFFCA, 0xFFCF, 0},
{0xFFD2, 0xFFD7, 0},
{0xFFDA, 0xFFDC, 0},
{0xFFE8, 0xFFEE, 0},
{0xFFFD, 0xFFFD, 0}
};

const struct {
    int         nCharSet;
    UINT        uCodePage;
    DWORD       dwCodePages;
    SCRIPT_ID   sid[3];
} g_CharSetTransTable[] = 
{
    ANSI_CHARSET,        1252, FS_LATIN1,   sidAsciiLatin,  sidLatin,   sidDefault,  
    EASTEUROPE_CHARSET,  1250, FS_LATIN2,   sidAsciiLatin,  sidLatin,   sidDefault,  
    RUSSIAN_CHARSET,     1251, FS_CYRILLIC, sidCyrillic,    sidDefault, sidDefault,
    GREEK_CHARSET,       1253, FS_GREEK,    sidGreek,       sidDefault, sidDefault,
    TURKISH_CHARSET,     1254, FS_TURKISH,  sidAsciiLatin,  sidLatin,   sidDefault,
    HEBREW_CHARSET,      1255, FS_HEBREW,   sidHebrew,      sidDefault, sidDefault,
    ARABIC_CHARSET,      1256, FS_ARABIC,   sidArabic,      sidDefault, sidDefault,
    BALTIC_CHARSET,      1257, FS_BALTIC,   sidAsciiLatin,  sidLatin,   sidDefault,
    VIETNAMESE_CHARSET,  1258, FS_VIETNAMESE, sidAsciiLatin,  sidLatin, sidDefault,
    THAI_CHARSET,         874, FS_THAI ,    sidThai,        sidDefault, sidDefault,
    SHIFTJIS_CHARSET,     932, FS_JISJAPAN, sidKana,        sidDefault, sidDefault, //sidKana,        sidHan,     sidDefault,
    GB2312_CHARSET,       936, FS_CHINESESIMP,sidHan,       sidDefault, sidDefault, //sidKana,     sidHan,     sidBopomofo,
    HANGEUL_CHARSET,      949, FS_WANSUNG,  sidHangul,      sidDefault, sidDefault, //sidHangul,   sidKana,    sidHan,
    CHINESEBIG5_CHARSET,  950, FS_CHINESETRAD, sidBopomofo, sidDefault, sidDefault, //sidKana,     sidHan,     sidBopomofo,     
    JOHAB_CHARSET,       1361, FS_JOHAB,    sidHangul,     sidDefault, sidDefault,
    DEFAULT_CHARSET,        0, 0,           sidDefault,     sidDefault, sidDefault,
};

//
// Extended code page table
//
const struct {
    int         nCharSet;
    UINT        uCodePage;
    DWORD       dwCodePages;
} g_CharSetTransTableExt[] = 
{
    ANSI_CHARSET,        28591, FS_MLANG_28591,
    EASTEUROPE_CHARSET,  28592, FS_MLANG_28592,
    RUSSIAN_CHARSET,     28595, FS_MLANG_28595,
    GREEK_CHARSET,       28597, FS_MLANG_28597,
    TURKISH_CHARSET,     28593, FS_MLANG_28593,
    HEBREW_CHARSET,      28598, FS_MLANG_28598,
    HEBREW_CHARSET,      38598, FS_MLANG_38598,
    ARABIC_CHARSET,      28596, FS_MLANG_28596,
    BALTIC_CHARSET,      28594, FS_MLANG_28594,
    VIETNAMESE_CHARSET,  28599, FS_MLANG_28599,
    THAI_CHARSET,        28605, FS_MLANG_28605,
    ANSI_CHARSET,        20127, FS_MLANG_20127,
    ANSI_CHARSET,        50220, FS_MLANG_50220,
    ANSI_CHARSET,        51932, FS_MLANG_51932,
    ANSI_CHARSET,        51949, FS_MLANG_51949,
    ANSI_CHARSET,        50225, FS_MLANG_50225,
    ANSI_CHARSET,        52936, FS_MLANG_52936,
    ANSI_CHARSET,        65000, FS_MLANG_65000,
    ANSI_CHARSET,        65001, FS_MLANG_65001,
    ANSI_CHARSET,        1200,  FS_MLANG_1200,
    ANSI_CHARSET,        20866, FS_MLANG_20866,
    ANSI_CHARSET,        21866, FS_MLANG_21866,
    ANSI_CHARSET,        50221, FS_MLANG_50221,
    ANSI_CHARSET,        50222, FS_MLANG_50222,
    DEFAULT_CHARSET,     0,     0, 
};

// Primary chars for scripts
// Pre-sorted by Unicode characters to speed up CMAP search.
const struct {
    WCHAR       wch;    //Can be extended to a character list
    SCRIPT_ID   sid;
} g_wCharToScript[] =
{
        0x0531, sidArmenian,
        0x0710, sidSyriac,
        0x0780, sidThaana,
        0x0905, sidDevanagari,
        0x0985, sidBengali,
        0x0a05, sidGurmukhi,
        0x0a85, sidGujarati,
        0x0b05, sidOriya,
        0x0b85, sidTamil,
        0x0c05, sidTelugu,
        0x0c85, sidKannada,
        0x0d05, sidMalayalam,
        0x0d85, sidSinhala,
        0x0e81, sidLao,
        0x0f40, sidTibetan,
        0x10a0, sidGeorgian,
        0x10d0, sidGeorgian,
        0x1300, sidEthiopic,
        0x1401, sidCanSyllabic,
        0x13a0, sidCherokee,
        0xa000, sidYi,
        0x1680, sidOgham,
        0x16a0, sidRunic,
        0x1700, sidBurmese,
        0x1780, sidKhmer,
        0x2800, sidBraille,
//      0x0020, sidUserDefined
    };

// Script tables ported from Trident
static SCRIPT_ID s_asidUnicodeSubRangeScriptMapping[] =
{
    sidAsciiLatin, sidLatin,      sidLatin,      sidLatin,        // 128-131
    sidLatin,      sidLatin,      0,             sidGreek,        // 132-135
    sidGreek,      sidCyrillic,   sidArmenian,   sidHebrew,       // 136-139
    sidHebrew,     sidArabic,     sidArabic,     sidDevanagari,   // 140-143
    sidBengali,    sidGurmukhi,   sidGujarati,   sidOriya,        // 144-147
    sidTamil,      sidTelugu,     sidKannada,    sidMalayalam,    // 148-151
    sidThai,       sidLao,        sidGeorgian,   sidGeorgian,     // 152-155
    sidHangul,     sidLatin,      sidGreek,      0,               // 156-159
    0,             0,             0,             0,               // 160-163
    0,             0,             0,             0,               // 164-167
    0,             0,             0,             0,               // 168-171
    0,             0,             0,             0,               // 172-175
    sidHan,        sidKana,       sidKana,       sidBopomofo,     // 176-179
    sidHangul,     0,             0,             0,               // 180-183
    sidHangul,     sidHangul,     sidHangul,     sidHan,          // 184-187
    0,             sidHan,        0,             0,               // 188-191
    0,             0,             0,             0,               // 192-195
    0,             0,             sidHangul,     0,               // 196-199
};


// Script table (raw data from MichelSu)
// Rendered by script ID
const SCRIPT ScriptTable[] = 
{

    {sidDefault,    IDS_SIDDEFAULT,     0,  0,  0,  0, SCRIPTCONTF_SCRIPT_SYSTEM},      // 0
    {sidMerge,      IDS_SIDMERGE,       0,  0,  0,  0, SCRIPTCONTF_SCRIPT_SYSTEM},      // 1
    {sidAsciiSym,   IDS_SIDASCIISYM,    0,  0,  0,  0, SCRIPTCONTF_SCRIPT_SYSTEM},      // 2
    {sidAsciiLatin, IDS_SIDASCIILATIN,  1252, 0,      IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_USER},  // 3
    {sidLatin,      IDS_SIDLATIN,       1252, 0,      IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_HIDE},  // 4
    {sidGreek,      IDS_SIDGREEK,       1253, 0x03AC, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_USER},  // 5
    {sidCyrillic,   IDS_SIDCYRILLIC,    1251, 0x0401, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP2, SCRIPTCONTF_SCRIPT_USER},  // 6
    {sidArmenian,   IDS_SIDARMENIAN,    0,    0x0531, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 7
/**/{sidHebrew,     IDS_SIDHEBREW,      1255, 0x05D4, IDS_FONT_HEBREW_FIXED,  IDS_FONT_HEBREW_PROP, SCRIPTCONTF_SCRIPT_USER},    // 8
    {sidArabic,     IDS_SIDARABIC,      1256, 0x0627, IDS_FONT_ARABIC_FIXED,  IDS_FONT_ARABIC_PROP, SCRIPTCONTF_SCRIPT_USER},    // 9
    {sidDevanagari, IDS_SIDDEVANAGARI,  0,    0x0905, IDS_FONT_DEVANAGARI_FIXED,IDS_FONT_DEVANAGARI_PROP, SCRIPTCONTF_SCRIPT_USER}, // 10
    {sidBengali,    IDS_SIDBENGALI,     0,    0x0985, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 11
    {sidGurmukhi,   IDS_SIDGURMUKHI,    0,    0x0A05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 12
    {sidGujarati,   IDS_SIDGUJARATI,    0,    0x0A85, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 13
    {sidOriya,      IDS_SIDORIYA,       0,    0x0B05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 14
    {sidTamil,      IDS_SIDTAMIL,       0,    0x0B85, IDS_FONT_TAMIL_FIXED, IDS_FONT_TAMIL_PROP, SCRIPTCONTF_SCRIPT_USER},       // 15
    {sidTelugu,     IDS_SIDTELUGU,      0,    0x0C05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 16
    {sidKannada,    IDS_SIDKANNADA,     0,    0x0C85, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 17
    {sidMalayalam,  IDS_SIDMALAYALAM,   0,    0x0D05, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 18
    {sidThai,       IDS_SIDTHAI,        874,  0x0E01, IDS_FONT_THAI_FIXED2, IDS_FONT_THAI_PROP2, SCRIPTCONTF_SCRIPT_USER},       // 19
    {sidLao,        IDS_SIDLAO,         0,    0x0E81, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 20
    {sidTibetan,    IDS_SIDTIBETAN,     0,    0x0F40, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 21
    {sidGeorgian,   IDS_SIDGEORGIAN,    0,    0x10D0, 0, 0, SCRIPTCONTF_SCRIPT_USER},                                            // 22
    {sidHangul,     IDS_SIDHANGUL,      949,  0,      IDS_FONT_KOREAN_FIXED,   IDS_FONT_KOREAN_PROP, SCRIPTCONTF_SCRIPT_USER},   // 23
    {sidKana,       IDS_SIDKANA,        932,  0,      IDS_FONT_JAPANESE_FIXED, IDS_FONT_JAPANESE_PROP, SCRIPTCONTF_SCRIPT_USER}, // 24
    {sidBopomofo,   IDS_SIDBOPOMOFO,    950,  0,      IDS_FONT_TAIWAN_FIXED,   IDS_FONT_TAIWAN_PROP, SCRIPTCONTF_SCRIPT_USER},   // 25
    {sidHan,        IDS_SIDHAN,         936,  0,      IDS_FONT_CHINESE_FIXED,  IDS_FONT_CHINESE_PROP, SCRIPTCONTF_SCRIPT_USER},  // 26
    {sidEthiopic,   IDS_SIDETHIOPIC,    0,    0x1300, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 27
    {sidCanSyllabic,IDS_SIDCANSYLLABIC, 0,    0x1401, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 28
    {sidCherokee,   IDS_SIDCHEROKEE,    0,    0x13A0, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 29
    {sidYi,         IDS_SIDYI,          0,    0xA000, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 30
    {sidBraille,    IDS_SIDBRAILLE,     0,    0x2800, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 31
    {sidRunic,      IDS_SIDRUNIC,       0,    0x16A0, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 32
    {sidOgham,      IDS_SIDOGHAM,       0,    0x1680, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 33
    {sidSinhala,    IDS_SIDSINHALA,     0,    0x0D85, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 34
    {sidSyriac,     IDS_SIDSYRIAC,      0,    0x0710, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 35
    {sidBurmese,    IDS_SIDBURMESE,     0,    0x1700, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 36
    {sidKhmer,      IDS_SIDKHMER,       0,    0x1780, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 37
    {sidThaana,     IDS_SIDTHAANA,      0,    0x0780, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 38
    {sidMongolian,  IDS_SIDMONGOLIAN,   0,    0,      0, 0, SCRIPTCONTF_SCRIPT_USER},      // 39
    {sidUserDefined,IDS_SIDUSERDEFINED, 0,    0x0020, 0, 0, SCRIPTCONTF_SCRIPT_USER},      // 40
};



UINT g_cScript = ARRAYSIZE(ScriptTable);

/////////////////////////////////////////////////////////////////////////////
// CMLFLink Free Global Objects

void CMLangFontLink_FreeGlobalObjects()
{
    if (g_pMLFLink)
        g_pMLFLink->Release();
    if (CMLFLink::m_pCodePagesCache)
        delete CMLFLink::m_pCodePagesCache;
    if (CMLFLink::m_pFontMappingCache)
        delete CMLFLink::m_pFontMappingCache;
    if (CMLFLink2::m_pFontMappingCache2)
        delete CMLFLink2::m_pFontMappingCache2;
}

/////////////////////////////////////////////////////////////////////////////
// CMLFLink

CMLFLink::CMLFLink()
{
    DllAddRef();
    EnterCriticalSection(&g_cs);
    if (!m_pCodePagesCache)
        m_pCodePagesCache = new CCodePagesCache;
    if (!m_pFontMappingCache)
        m_pFontMappingCache = new CFontMappingCache;
    LeaveCriticalSection(&g_cs);
    m_pFlinkTable = NULL;
}

STDMETHODIMP CMLFLink::GetCharCodePages(WCHAR chSrc, DWORD* pdwCodePages)
{
    return ::GetCharCodePagesEx(chSrc, pdwCodePages, CPBITS_WINDOWS);
}


/////////////////////////////////////////////////////////////////////////////
// CMLFLink : IMLangCodePages

HRESULT GetCharCodePagesEx(WCHAR chSrc, DWORD* pdwCodePages, DWORD dwFlags)
{
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    HRESULT hr = S_OK;
    int nLen;
    int iCmd = 0;
    int nPickOffset;
    int nBitOffset = 0;
    int nBitCount = 32;
    DWORD dwDiff = 0xffffffff;
    DWORD dwOr = 0;
    DWORD dwCodePages;
    DWORD adwBitsMap[32];
    const CCodePagesHeader* pHeader;
    const WORD* pwTable;
    int nBlock;
    int nEndLen;
    const BYTE* pbBlock;
    BYTE *pBuffer = NULL;

    if (!CMLFLink::m_pCodePagesCache)
        CMLFLink::m_pCodePagesCache = new CMLFLink::CCodePagesCache;

    if (CMLFLink::m_pCodePagesCache)
        hr = CMLFLink::m_pCodePagesCache->Load();
    else
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        pBuffer = CMLFLink::m_pCodePagesCache->GetCodePageBits(dwFlags & CPBITS_WINDOWS? FALSE:TRUE);
        pHeader = (CCodePagesHeader*) pBuffer;
        pwTable = (WORD*)(pBuffer + READWINTELDWORD(pHeader->m_dwTableOffset));
        nBlock = chSrc / READWINTELDWORD(pHeader->m_dwBlockSize);
        nEndLen = chSrc % READWINTELDWORD(pHeader->m_dwBlockSize);
        pbBlock = pBuffer + READWINTELWORD(pwTable[nBlock]);
    }

    for (int nDoneLen = 0; SUCCEEDED(hr) && nDoneLen < (int)READWINTELDWORD(pHeader->m_dwBlockSize); nDoneLen += nLen)
    {
        BYTE bCmd = pbBlock[--iCmd];
        if (bCmd < pHeader->m_abCmdCode[1])
        {
            // Flat
            nLen = bCmd + 1;
            nPickOffset = nBitOffset + nBitCount * (nEndLen - nDoneLen);
            nBitOffset += nBitCount * nLen;
        }
        else if (bCmd < pHeader->m_abCmdCode[2])
        {
            // Pack
            nLen = bCmd - pHeader->m_abCmdCode[1] + 2;
            nPickOffset = nBitOffset;
            nBitOffset += nBitCount;
        }
        else if (bCmd < pHeader->m_abCmdCode[4])
        {
            // Diff & Or
            nLen = 0;

            DWORD dw = pbBlock[--iCmd];
            dw <<= 8;
            dw |= pbBlock[--iCmd];
            dw <<= 8;
            dw |= pbBlock[--iCmd];
            dw <<= 8;
            dw |= pbBlock[--iCmd];

            if (bCmd < pHeader->m_abCmdCode[3])
            {
                // Diff
                dwDiff = dw;
                DWORD dwShift = 1;
                nBitCount = 0;
                for (int nBit = 0; nBit < 32; nBit++)
                {
                    if (dwDiff & (1 << nBit))
                    {
                        adwBitsMap[nBit] = dwShift;
                        dwShift <<= 1;
                        nBitCount++;
                    }
                    else
                    {
                        adwBitsMap[nBit] = 0;
                    }
                }
            }
            else
            {
                // Or
                dwOr = dw;
            }
        }
        else
        {
            // Big Pack
            nLen = (bCmd - pHeader->m_abCmdCode[4]) * 0x100 + pbBlock[--iCmd] + pHeader->m_abCmdCode[2] - pHeader->m_abCmdCode[1] + 1 + 1;
            nPickOffset = nBitOffset;
            nBitOffset += nBitCount;
        }

        if (nEndLen < nDoneLen + nLen)
            break;
    }

    if (SUCCEEDED(hr) &&
        nDoneLen < (int)READWINTELDWORD(pHeader->m_dwBlockSize))
    {
        const BYTE* const pbBuf = &pbBlock[nPickOffset / 8];
        DWORD dwCompBits = pbBuf[0] | (DWORD(pbBuf[1]) << 8) | (DWORD(pbBuf[2]) << 16) | (DWORD(pbBuf[3]) << 24);
        dwCompBits >>= nPickOffset % 8;
        if (nBitOffset % 8)
            dwCompBits |= pbBuf[4] << (32 - nBitOffset % 8);

        if (nBitCount < 32)
        {
            dwCompBits &= (1 << nBitCount) - 1;

            dwCodePages = 0;
            for (int nBit = 0; nBit < 32; nBit++)
            {
                if (dwCompBits & adwBitsMap[nBit])
                    dwCodePages |= (1 << nBit);
            }
        }
        else
        {
            dwCodePages = dwCompBits;
        }

        dwCodePages |= dwOr;
    }
    else
    {
        hr = E_FAIL; // Probably Code Pages data is broken.
    }

    if (pdwCodePages)
    {
        if (SUCCEEDED(hr))
        {
            if (dwFlags & CPBITS_WINDOWS)
            {
                // 04/07/00 WEIWU
                // Need to match latest NLS file (Currently W2K RTM) if we're in strict mode for outbound encoding detection
                // For backward compatibilities reasons, we don't want to change our raw Windows CP data.
                // We patch up major differences between Win95/NT4 NLS files and current NLS files here
                // For non-Windows CP data, we'll modify them directly since it doesn't affect text rendering
                if (dwFlags & CPBITS_STRICT)
                {
                    // Add Euro support for 936,950, 949 if we're in strict mode
                    if (chSrc == 0x20AC)
                    {
                        dwCodePages |=  FS_WANSUNG|FS_CHINESESIMP|FS_CHINESETRAD;
                    }
                    else if (chSrc == 0x00AE)
                    {
                        dwCodePages |= FS_WANSUNG;
                    }
                    // Clear K1_HANJA bits if we're in strict mode
                    dwCodePages &= ~FS_MLANG_K1HANJA;
                }
                else
                {
                    // We introduce this new internal charset bit, FS_MLANG_K1HANJA, to support Korean K1 Hanja
                    // K1 Hanja is defined in KSC 5657-1991, it contains non-cp949 DBCS characters
                    // Currenly, Korean fonts shipped with NT5 and Win98 support K1 Hanja glyphs 
                    // and we don't want to switch font to other DBCS fonts in this case.
                    if (dwCodePages & FS_MLANG_K1HANJA)
                    {
                        // Assume Korean font supports K1_HANJA on Win98 and NT5 
                        if (g_bIsNT5 || (g_bIsWin98 && CP_KOR_5601 == g_uACP))
                            dwCodePages |= FS_WANSUNG;
                        dwCodePages &= ~FS_MLANG_K1HANJA;
                    }            

                }
            }
            *pdwCodePages = dwCodePages;
        }
        else
        {
            *pdwCodePages = 0;
        }
    }

    return hr;
}   



HRESULT GetStrCodePagesEx(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages, DWORD dwFlags)
{
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);
    ASSERT_WRITE_PTR_OR_NULL(pcchCodePages);

    HRESULT hr = S_OK;
    long cchCodePages = 0;
    DWORD dwStrCodePages = (DWORD)~0;
    BOOL fInit = FALSE;
    BOOL fNoPri = FALSE;

    if (!pszSrc || cchSrc <= 0) // We can't make dwStrCodePages when cchSrc is zero
        hr = E_INVALIDARG;

    while (SUCCEEDED(hr) && cchSrc > 0)
    {
        DWORD dwCharCodePages;

        if (SUCCEEDED(hr = GetCharCodePagesEx(*pszSrc, &dwCharCodePages, dwFlags)))
        {
            if (!fInit)
            {
                fInit = TRUE;
                fNoPri = !(dwPriorityCodePages & dwCharCodePages);
            }
            else if (fNoPri != !(dwPriorityCodePages & dwCharCodePages))
            {
                break;
            }
            if (!fNoPri)
                dwPriorityCodePages &= dwCharCodePages;

            if (dwCharCodePages & dwStrCodePages)
                dwStrCodePages &= dwCharCodePages;
            // Don't break if dwCharCodePages is zero and we're not in strict mode
            else if (dwCharCodePages || dwFlags & CPBITS_STRICT) 
                     break;

            pszSrc++;
            cchSrc--;
            cchCodePages++;
        }
    }

    // Codepage bits defines don't take full 32 bits. 
    // If no bits are flipped, we don't have any candidate code pages, we should clear the bits
    if (dwStrCodePages == (DWORD)~0)
        dwStrCodePages = 0;


    if (SUCCEEDED(hr))
    {
        if (pcchCodePages)
            *pcchCodePages = cchCodePages;
        if (pdwCodePages)
            *pdwCodePages = dwStrCodePages;
    }
    else
    {
        if (pcchCodePages)
            *pcchCodePages = 0;
        if (pdwCodePages)
            *pdwCodePages = 0;
    }

    return hr;
}

STDMETHODIMP CMLFLink::GetStrCodePages(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages)
{
    return ::GetStrCodePagesEx(pszSrc, cchSrc, dwPriorityCodePages, pdwCodePages, pcchCodePages, CPBITS_WINDOWS);
}

HRESULT CodePageToCodePagesEx(UINT uCodePage, DWORD* pdwCodePages, DWORD* pdwCodePagesExt)
{
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    int iCharSet;

    if (pdwCodePages)
        *pdwCodePages = 0;

    if (pdwCodePagesExt)
        *pdwCodePagesExt = 0;


    for (iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
    {
        if (uCodePage == g_CharSetTransTable[iCharSet].uCodePage)
        {
            if (pdwCodePages)
                *pdwCodePages = g_CharSetTransTable[iCharSet].dwCodePages;
            return S_OK;
        }
    }

    for (iCharSet = 0; g_CharSetTransTableExt[iCharSet].uCodePage; iCharSet++)
    {
        if (uCodePage == g_CharSetTransTableExt[iCharSet].uCodePage)
        {
            if (pdwCodePages)
                *pdwCodePagesExt = g_CharSetTransTableExt[iCharSet].dwCodePages;
            return S_OK;
        }
    }

    return E_FAIL; // Unknown code page
}

STDMETHODIMP CMLFLink::CodePageToCodePages(UINT uCodePage, DWORD* pdwCodePages)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
    {
        if (uCodePage == g_CharSetTransTable[iCharSet].uCodePage)
        {
            if (pdwCodePages)
                *pdwCodePages = g_CharSetTransTable[iCharSet].dwCodePages;
            return S_OK;
        }
    }

    if (pdwCodePages)
        *pdwCodePages = 0;

    return E_FAIL; // Unknown code page
}

STDMETHODIMP CMLFLink::CodePagesToCodePage(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage)
{
    return ::CodePagesToCodePageEx(dwCodePages, uDefaultCodePage, puCodePage, 0);
}

HRESULT CodePagesToCodePageEx(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage, BOOL bCodePagesExt)
{
    ASSERT_WRITE_PTR_OR_NULL(puCodePage);

    HRESULT hr = E_FAIL; // Unknown code pages
    DWORD dwDefaultCodePages;

    if (uDefaultCodePage &&
        SUCCEEDED(hr = CodePageToCodePagesEx(uDefaultCodePage, &dwDefaultCodePages, NULL)) &&
        (dwDefaultCodePages & dwCodePages))
    {
        hr = S_OK;
    }
    else
    {
        if (bCodePagesExt)
        {
            for (int iCharSet = 0; g_CharSetTransTableExt[iCharSet].dwCodePages; iCharSet++)
            {
                if (dwCodePages & g_CharSetTransTableExt[iCharSet].dwCodePages)
                {
                    uDefaultCodePage = g_CharSetTransTableExt[iCharSet].uCodePage;
                    hr = S_OK;
                    break;
                }
            }

        }
        else
        {

            for (int iCharSet = 0; g_CharSetTransTable[iCharSet].dwCodePages; iCharSet++)
            {
                if (dwCodePages & g_CharSetTransTable[iCharSet].dwCodePages)
                {
                    uDefaultCodePage = g_CharSetTransTable[iCharSet].uCodePage;
                    hr = S_OK;
                    break;
                }
            }
        }
    }

    if (puCodePage)
    {
        if (SUCCEEDED(hr))
            *puCodePage = uDefaultCodePage;
        else
            *puCodePage = 0;
    }

    return hr;
}


#define REGSTR_PATH_FONTLINK TSZMICROSOFTPATH TEXT("\\Windows NT\\CurrentVersion\\FontLink\\SystemLink")

void CMLFLink::FreeFlinkTable(void)
{
    if (m_pFlinkTable)
    {
        for (UINT i=0; i<m_uiFLinkFontNum; i++)
            if (m_pFlinkTable[i].pmszFaceName)
                LocalFree(m_pFlinkTable[i].pmszFaceName);
        LocalFree(m_pFlinkTable);
        m_pFlinkTable = NULL;
        m_uiFLinkFontNum = 0;
    }
}

#define MAX_FONTLINK_BUFFER_SIZE    1024

HRESULT CMLFLink::CreateNT5FontLinkTable(void)
{
    HKEY    hKey = NULL;
    HKEY    hKeyFont = NULL;
    ULONG   ulFonts = 0;
    ULONG   ulFLinkFonts = 0;
    DWORD   dwIndex = 0;
    WCHAR   szFaceName[MAX_PATH];
    LPWSTR  pNewFaceName = NULL;
    DWORD   dwOffset = 0;
    DWORD   dwOffset2 = 0;
    DWORD   dwValue;
    DWORD   dwData;
    WCHAR   szFontFile[LF_FACESIZE];
    DWORD   dwType;
    WCHAR   szFlinkFont[MAX_FONTLINK_BUFFER_SIZE];
    

    // Internal temperate data
    struct tagFontTable
    {
        WCHAR szFontFile[LF_FACESIZE];
        WCHAR szFaceName[LF_FACESIZE];
    }* tmpFontTable = NULL;

    HRESULT hr;

    // Open system font and fontlink key
    if ((ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_FONTLINK, 0, KEY_READ, &hKey)) ||
        (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGFONTKEYNT, 0, KEY_READ, &hKeyFont)))
    {
        hr = E_FAIL;
        goto TABLE_DONE;
    }


    // Get number of items
    if ((ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, 0, NULL, 
         NULL, NULL, &ulFLinkFonts, NULL, NULL, NULL, NULL) || 0 == ulFLinkFonts) ||            
        (ERROR_SUCCESS != RegQueryInfoKey(hKeyFont, NULL, NULL, 0, NULL, 
            NULL, NULL, &ulFonts, NULL, NULL, NULL, NULL) || 0 == ulFonts))
    {
        hr = E_FAIL;
        goto TABLE_DONE;
    }

    tmpFontTable = (struct tagFontTable *)LocalAlloc(LPTR, sizeof(struct tagFontTable)*ulFonts);

    if (NULL == tmpFontTable)
    {
        hr = E_OUTOFMEMORY;
        goto TABLE_DONE;
    }

    dwValue = dwData = LF_FACESIZE;
    dwType = REG_SZ;
    dwIndex = 0;
    ulFonts = 0;    

    while (ERROR_NO_MORE_ITEMS != RegEnumValueW(
                      hKeyFont,
                      dwIndex++,
                      szFaceName,
                      &dwValue,
                      NULL,
                      &dwType,
                      (LPBYTE)szFontFile,
                      &dwData ))
    {
        //  TTF fonts only, TTC fonts already have face name under fontlink
        if (pNewFaceName = wcsstr(szFaceName, L" & "))
            break;
        pNewFaceName = wcsstr(szFaceName, L" (TrueType)");
        if(pNewFaceName)
        {
           *pNewFaceName = 0;
           MLStrCpyNW(tmpFontTable[ulFonts].szFaceName, szFaceName, LF_FACESIZE);
           MLStrCpyNW(tmpFontTable[ulFonts++].szFontFile, szFontFile, LF_FACESIZE);
        }

        dwValue = dwData = LF_FACESIZE;
        dwType = REG_SZ;
    }

    
    m_pFlinkTable = (PFLINKFONT) LocalAlloc(LPTR, sizeof(FLINKFONT)*ulFLinkFonts);
    if (NULL == m_pFlinkTable)
    {
        hr = E_OUTOFMEMORY;
        goto TABLE_DONE;
    }

    dwValue = LF_FACESIZE;
    dwData = MAX_FONTLINK_BUFFER_SIZE;
    dwType = REG_MULTI_SZ;

    dwIndex = 0;

    while (ERROR_NO_MORE_ITEMS != RegEnumValueW(
                      hKey,
                      dwIndex,
                      m_pFlinkTable[dwIndex].szFaceName,
                      &dwValue,
                      NULL,
                      &dwType,
                      (LPBYTE)szFlinkFont,
                      &dwData ))
    {
        m_pFlinkTable[dwIndex].pmszFaceName = (LPWSTR) LocalAlloc(LPTR, MAX_FONTLINK_BUFFER_SIZE); 
        if (!m_pFlinkTable[dwIndex].pmszFaceName)
        {
            hr = E_OUTOFMEMORY;
            goto TABLE_DONE;
        }
        while (TRUE)
        {
            pNewFaceName = wcsstr(&szFlinkFont[dwOffset], L",");
            
            if (pNewFaceName)   // TTC font, get face name from registry
            {
                MLStrCpyNW(&(m_pFlinkTable[dwIndex].pmszFaceName[dwOffset2]), ++pNewFaceName, LF_FACESIZE);
                dwOffset2 += lstrlenW(pNewFaceName)+1;
            }
            else                // TTF font, search font table for face name            
            {
                if (szFlinkFont[dwOffset])
                    for (UINT i=0; i<ulFonts; i++)
                    {
                        if (!MLStrCmpNIW(&szFlinkFont[dwOffset], tmpFontTable[i].szFontFile, LF_FACESIZE))
                        {
                            MLStrCpyNW(&(m_pFlinkTable[dwIndex].pmszFaceName[dwOffset2]), tmpFontTable[i].szFaceName, LF_FACESIZE);
                            dwOffset2 += lstrlenW(tmpFontTable[i].szFaceName)+1;
                            break;
                        }
                    }
                else            // End of multiple string, break out                    
                    break;
            }

            dwOffset += lstrlenW(&szFlinkFont[dwOffset])+1;

            // Prevent infinitive loop, shouldn't happen
            if (dwOffset >= MAX_FONTLINK_BUFFER_SIZE) 
            {
                break;
            }
        }

        dwValue = LF_FACESIZE;
        dwData = MAX_FONTLINK_BUFFER_SIZE;
        dwType = REG_MULTI_SZ;
        dwOffset = dwOffset2 = 0;
        dwIndex++;
    }

    m_uiFLinkFontNum = ulFLinkFonts;

    hr = S_OK;

TABLE_DONE:
    if (hKey)
        RegCloseKey(hKey);
    if (hKeyFont)
        RegCloseKey(hKeyFont);
    if (tmpFontTable)
        LocalFree(tmpFontTable);
    if ((hr != S_OK) && m_pFlinkTable)
        FreeFlinkTable();

    return hr;
}


HRESULT CMLFLink::GetNT5FLinkFontCodePages(HDC hDC, LOGFONTW* plfEnum, DWORD * lpdwCodePages)
{
    HRESULT hr = S_OK;
    UINT    i;

    if (!EnumFontFamiliesExW(hDC, plfEnum, GetFontCodePagesEnumFontProcW, (LPARAM)lpdwCodePages, 0))
        return E_FAIL;

    if (NULL == m_pFlinkTable)
        CreateNT5FontLinkTable();

    if (m_pFlinkTable)
    {
        for (i=0; i<m_uiFLinkFontNum;i++)
        {
            if (!MLStrCmpNIW(plfEnum->lfFaceName, m_pFlinkTable[i].szFaceName, LF_FACESIZE))
            {
                DWORD dwOffset=0;
                // Internal buffer, we're sure it'll end
                while(TRUE)
                {
                    MLStrCpyNW(plfEnum->lfFaceName, &m_pFlinkTable[i].pmszFaceName[dwOffset], LF_FACESIZE);
                    EnumFontFamiliesExW(hDC, plfEnum, GetFontCodePagesEnumFontProcW, (LPARAM)lpdwCodePages, 0);
                    dwOffset += lstrlenW(&m_pFlinkTable[i].pmszFaceName[dwOffset])+1;
                    // End of multiple string ?
                    if (m_pFlinkTable[i].pmszFaceName[dwOffset] == 0)
                        break;                        
                }
                break;
            }
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMLFLink : IMLangFontLink
// 1/29/99 - Change HR return
//        Now, we always return S_OK unless system error, caller will
//        check code pages bits in dwCodePages for font code page coverage
STDMETHODIMP CMLFLink::GetFontCodePages(HDC hDC, HFONT hFont, DWORD* pdwCodePages)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);

    HRESULT hr = S_OK;
    LOGFONT lfFont;
    DWORD dwCodePages = 0;


    if (!::GetObject(hFont, sizeof(lfFont), &lfFont))
        hr = E_FAIL; // Invalid hFont

    if (SUCCEEDED(hr))
    {
        LOGFONT lfEnum;

        // Enumerates all character sets of given font's facename
        // Then, combines them in dwCodePages

        ::memset(&lfEnum, 0, sizeof(lfEnum));
        lfEnum.lfCharSet = DEFAULT_CHARSET;
        _tcsncpy(lfEnum.lfFaceName, lfFont.lfFaceName, ARRAYSIZE(lfEnum.lfFaceName));


        if (g_bIsNT5)
        {
            LOGFONTW lfEnumW = {0};
            lfEnumW.lfCharSet = DEFAULT_CHARSET;

            if (MultiByteToWideChar(g_uACP, 0, lfFont.lfFaceName, LF_FACESIZE, lfEnumW.lfFaceName, LF_FACESIZE))
                hr = GetNT5FLinkFontCodePages(hDC, &lfEnumW, &dwCodePages);
            else
                if (!::EnumFontFamiliesEx(hDC, &lfEnum, GetFontCodePagesEnumFontProc, (LPARAM)&dwCodePages, 0))
                    hr = E_FAIL; // Invalid hDC

        }
        else
        {
            if (!::EnumFontFamiliesEx(hDC, &lfEnum, GetFontCodePagesEnumFontProc, (LPARAM)&dwCodePages, 0))
                hr = E_FAIL; // Invalid hDC
        }

    }

//############################
//######  MingLiU HACK  ######
//## Fix the bogus font !!! ##
//############################
    if (SUCCEEDED(hr) && ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lfFont.lfFaceName, -1, _T("MingLiU"), -1) == 2)
    {
        dwCodePages &= ~FS_LATIN1; // Actually it doesn't have the characters of ANSI_CHARSET.
    }
//############################

// We should use following logic to replace above hack code 
// But, there is another DBCS<->Western font size mapping issue, we should disable this code until that issue is resolved,
#if 0

    // If font claims FE and 1252 and 1250, believe it can do 1252.
    // If font claims FE and 1252 and not 1250, don't believe it can do 1252.
    // This lets full Unicode fonts pass but blocks bad FE fonts.
    if (SUCCEEDED(hr) && (dwCodePages & (FS_JISJAPAN|FS_CHINESESIMP|FS_WANSUNG|FS_CHINESETRAD)) && (dwCodePages & FS_LATIN1) && !(dwCodePages & FS_LATIN2))
    {
        dwCodePages &= ~FS_LATIN1;
    }
#endif

#ifdef UNICODE
#define PRC_DEFAULT_GUI_FONT L"\x5b8b\x4f53"
#else
#define PRC_DEFAULT_GUI_FONT "\xcb\xce\xcc\xe5"
#endif

    // PRC Win95 DEFAULT_GUI_FONT HACK !!!
    if (SUCCEEDED(hr) && lfFont.lfCharSet == ANSI_CHARSET && ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lfFont.lfFaceName, -1, PRC_DEFAULT_GUI_FONT, -1) == 2)
    {
        dwCodePages &= ~FS_CHINESESIMP; // Actually it doesn't have the characters of GB2321_CHARSET.
    }

    if (pdwCodePages)
    {
        if (SUCCEEDED(hr))
            *pdwCodePages = dwCodePages;
        else
            *pdwCodePages = 0;
    }

    return hr;
}

int CALLBACK CMLFLink::GetFontCodePagesEnumFontProc(const LOGFONT* plf, const TEXTMETRIC*, DWORD FontType, LPARAM lParam)
{
    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].nCharSet != DEFAULT_CHARSET; iCharSet++)
    {
        if (plf->lfCharSet == g_CharSetTransTable[iCharSet].nCharSet)
        {
            if ((FontType == TRUETYPE_FONTTYPE) || 
                (g_CharSetTransTable[iCharSet].uCodePage == g_uACP))
            {
                *((DWORD*)lParam) |= g_CharSetTransTable[iCharSet].dwCodePages;
                break;
            }
        }
    }

    return TRUE;
}

int CALLBACK CMLFLink::GetFontCodePagesEnumFontProcW(const LOGFONTW* plf, const TEXTMETRICW*, DWORD FontType, LPARAM lParam)
{
    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].nCharSet != DEFAULT_CHARSET; iCharSet++)
    {
        if (plf->lfCharSet == g_CharSetTransTable[iCharSet].nCharSet)
        {
            if ((FontType == TRUETYPE_FONTTYPE) || 
                (g_CharSetTransTable[iCharSet].uCodePage == g_uACP))
            {
                *((DWORD*)lParam) |= g_CharSetTransTable[iCharSet].dwCodePages;
                break;
            }
        }
    }

    return TRUE;
}


STDMETHODIMP CMLFLink::MapFont(HDC hDC, DWORD dwCodePages, HFONT hSrcFont, HFONT* phDestFont)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(phDestFont);

    HRESULT hr = S_OK;

    CFontMappingInfo fm; // To accelerate internal subroutine calls

    fm.hDC = hDC;

    // Font mapping cache works only for Display
    BOOL fDisplay = (::GetDeviceCaps(hDC, TECHNOLOGY) == DT_RASDISPLAY);

    dwCodePages &= ~FS_SYMBOL; // We don't map symbol font.

    if (!::GetObject(hSrcFont, sizeof(fm.lfSrcFont), &fm.lfSrcFont))
        hr = E_FAIL; // Invalid hSrcFont

    // Do two things at same time
    // (1) Find given font in the font mapping cache
    // (2) Build m_auCodePage[] and m_adwCodePages[]
    if (SUCCEEDED(hr))
    {
        if (fDisplay)
        {
            BYTE nCharSet = fm.lfSrcFont.lfCharSet;
            fm.lfSrcFont.lfCharSet = DEFAULT_CHARSET;
            EnumFontFamiliesEx(hDC, &fm.lfSrcFont, (FONTENUMPROC)VerifyFontSizeEnumFontProc, (LPARAM)&fm.lfSrcFont, 0);
            fm.lfSrcFont.lfCharSet = nCharSet;
        }

        hr = S_FALSE; // hr == S_FALSE means that we didn't find the font in the cache
        for (int n = 0; n < 32 && dwCodePages; n++)
        {
            hr = CodePagesToCodePage(dwCodePages, 0, &fm.auCodePage[n]); // Pick one of CodePages

            if (SUCCEEDED(hr))
                hr = CodePageToCodePages(fm.auCodePage[n], &fm.adwCodePages[n]);

            if (SUCCEEDED(hr))
            {
                if (fDisplay && m_pFontMappingCache)
                    hr = m_pFontMappingCache->FindEntry(fm.auCodePage[n], fm.lfSrcFont, &fm.hDestFont);
                else
                    hr = S_FALSE;
            }

            if (hr != S_FALSE)
                break;

            dwCodePages &= ~fm.adwCodePages[n];
        }
        fm.auCodePage[n] = NULL; // End mark
        fm.adwCodePages[n] = 0;
    }

    if (hr == S_FALSE) // Not exist in cache
    {

        hr = MapFontCodePages(fm, GetFaceNameRegistry);

        if (hr == MLSTR_E_FACEMAPPINGFAILURE)
            hr = MapFontCodePages(fm, GetFaceNameGDI);

        // Handle font link failure case for NT5
        if (hr == MLSTR_E_FACEMAPPINGFAILURE && g_bIsNT5)
            hr = MapFontCodePages(fm, GetFaceNameMIME);

        if (SUCCEEDED(hr) && fDisplay && m_pFontMappingCache)
            hr = m_pFontMappingCache->AddEntry(fm.auCodePage[fm.iCP], fm.lfSrcFont, fm.hDestFont);
    }

    if (phDestFont)
    {
        if (SUCCEEDED(hr))
        {            
            *phDestFont = fm.hDestFont;
            fm.hDestFont = NULL; // Avoid being deleted it in destructor
        }
        else
        {
            *phDestFont = NULL;
        }
    }

    return hr;
}

STDMETHODIMP CMLFLink::ReleaseFont(HFONT hFont)
{
    ASSERT_THIS;

    HRESULT hr = S_OK;

    if (!m_pFontMappingCache || FAILED(hr = m_pFontMappingCache->UnlockEntry(hFont)))
    {
        // For non display DC
        if (::DeleteObject(hFont))
            hr = S_OK;
        else
            hr = E_FAIL; // Invalid hFont
    }
    return hr;
}

STDMETHODIMP CMLFLink::ResetFontMapping(void)
{
    ASSERT_THIS;
    HRESULT hr = S_OK;

    if (m_pFontMappingCache)
        hr =  m_pFontMappingCache->FlushEntries();

    return hr;
}

STDMETHODIMP CMLFLink2::ResetFontMapping(void)
{
    ASSERT_THIS;
    HRESULT hr = S_OK;

    if (m_pIMLFLnk)
        hr =  m_pIMLFLnk->ResetFontMapping();

    if (m_pFontMappingCache2)
        hr = (S_OK == m_pFontMappingCache2->EnsureFontTable(FALSE)? hr : E_FAIL);

    return hr;
}

HRESULT CMLFLink::MapFontCodePages(CFontMappingInfo& fm, PFNGETFACENAME pfnGetFaceName)
{
    HRESULT hr = MLSTR_E_FACEMAPPINGFAILURE;    

    for (fm.iCP = 0; fm.auCodePage[fm.iCP]; fm.iCP++)
    {
        fm.lfDestFont.lfCharSet = DEFAULT_CHARSET;

        hr = (this->*pfnGetFaceName)(fm);

        if (SUCCEEDED(hr))
        {
            LOGFONT lf = {0};

            // If face name is from registry or MIMEDB, we set charset to codepage charset.
            if (fm.lfDestFont.lfCharSet == DEFAULT_CHARSET)
            {
                for (int iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
                {
                    if (fm.auCodePage[fm.iCP] == g_CharSetTransTable[iCharSet].uCodePage)
                    {
                        fm.lfDestFont.lfCharSet = (BYTE)g_CharSetTransTable[iCharSet].nCharSet;
                        break;
                    }
                }
            }

            lf.lfCharSet = DEFAULT_CHARSET;
            MLStrCpyN(lf.lfFaceName, fm.szFaceName, LF_FACESIZE);

            // Retrieve LOGFONT from gotten facename
            fm.lfDestFont.lfFaceName[0] = _T('\0');

            if (!::EnumFontFamiliesEx(fm.hDC, &lf, MapFontEnumFontProc, (LPARAM)&fm.lfDestFont, 0))
                hr = E_FAIL; // Invalid hDC
            else if (fm.lfDestFont.lfFaceName[0] == _T('\0'))
                hr = MLSTR_E_FACEMAPPINGFAILURE;
        }

        if (SUCCEEDED(hr))
        {
            fm.lfDestFont.lfHeight      = fm.lfSrcFont.lfHeight;
            fm.lfDestFont.lfWidth       = fm.lfSrcFont.lfWidth;
            fm.lfDestFont.lfEscapement  = fm.lfSrcFont.lfEscapement;
            fm.lfDestFont.lfOrientation = fm.lfSrcFont.lfOrientation;
            fm.lfDestFont.lfWeight      = fm.lfSrcFont.lfWeight;
            fm.lfDestFont.lfItalic      = fm.lfSrcFont.lfItalic;
            fm.lfDestFont.lfUnderline   = fm.lfSrcFont.lfUnderline;
            fm.lfDestFont.lfStrikeOut   = fm.lfSrcFont.lfStrikeOut;


            HRESULT hrTemp = VerifyFaceMap(fm);
            if (hrTemp == MLSTR_E_FACEMAPPINGFAILURE && fm.lfDestFont.lfWidth)
            {
                fm.lfDestFont.lfWidth = 0; // To recover non-scalable font
                hr = VerifyFaceMap(fm);
            }
            else
            {
                hr = hrTemp;
            }
        }

        if (hr != MLSTR_E_FACEMAPPINGFAILURE)
            break;
    }

    return hr;
}
    
int CALLBACK CMLFLink::MapFontEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC*, DWORD, LPARAM lParam)
{
    LOGFONT* plfDestFont = (LOGFONT*)lParam;
    
    if (!plfDestFont->lfFaceName[0] )
    {
        if (plfDestFont->lfCharSet != DEFAULT_CHARSET)
        {
            if (plfDestFont->lfCharSet == plfFont->lfCharSet)
                *plfDestFont = *plfFont;
        }
        else
              *plfDestFont = *plfFont;
    }

    return TRUE;
}

HRESULT CMLFLink::GetFaceNameRegistry(CFontMappingInfo& fm)
{
    static const TCHAR szRootKey[]       = _T("Software\\Microsoft\\Internet Explorer");
    static const TCHAR szIntlKey[]       = _T("International\\%d");
    static const TCHAR szPropFontName[]  = _T("IEPropFontName");
    static const TCHAR szFixedFontName[] = _T("IEFixedFontName");

    HRESULT hr = S_OK;
    HKEY hKeyRoot;

    if (::RegOpenKeyEx(HKEY_CURRENT_USER, szRootKey, 0, KEY_READ, &hKeyRoot) == ERROR_SUCCESS)
    {
        TCHAR szCodePageKey[ARRAYSIZE(szIntlKey) + 10];
        HKEY hKeySub;

        ::wsprintf(szCodePageKey, szIntlKey, fm.auCodePage[fm.iCP]);
        if (::RegOpenKeyEx(hKeyRoot, szCodePageKey, 0, KEY_READ, &hKeySub) == ERROR_SUCCESS)
        {
            const TCHAR* pszFontNameValue;
            DWORD dwType;
            DWORD dwSize = sizeof(fm.szFaceName);

            if ((fm.lfSrcFont.lfPitchAndFamily & 0x03) == FIXED_PITCH)
                pszFontNameValue = szFixedFontName;
            else
                pszFontNameValue = szPropFontName;

            if (::RegQueryValueEx(hKeySub, pszFontNameValue, 0, &dwType, (LPBYTE)fm.szFaceName, &dwSize) != ERROR_SUCCESS)
                hr = MLSTR_E_FACEMAPPINGFAILURE;

            if (::RegCloseKey(hKeySub) != ERROR_SUCCESS && SUCCEEDED(hr))
                hr = MLSTR_E_FACEMAPPINGFAILURE;
        }
        else
        {
            hr = MLSTR_E_FACEMAPPINGFAILURE;
        }

        if (::RegCloseKey(hKeyRoot) != ERROR_SUCCESS && SUCCEEDED(hr))
            hr = MLSTR_E_FACEMAPPINGFAILURE;
    }
    else
    {
        hr = MLSTR_E_FACEMAPPINGFAILURE;
    }
    return hr;
}

HRESULT CMLFLink::GetFaceNameGDI(CFontMappingInfo& fm)
{
    HRESULT hr = S_OK;

    for (int iCharSet = 0; g_CharSetTransTable[iCharSet].uCodePage; iCharSet++)
    {
        if (fm.auCodePage[fm.iCP] == g_CharSetTransTable[iCharSet].uCodePage)
            break;
    }

    if (g_CharSetTransTable[iCharSet].uCodePage)
    {
        ::memset(&fm.lfDestFont, 0, sizeof(fm.lfDestFont));

        // Specify font weight as NORMAL to avoid NT GDI font mapping bugs
        fm.lfDestFont.lfWeight = FW_NORMAL;
        fm.lfDestFont.lfCharSet = (BYTE)g_CharSetTransTable[iCharSet].nCharSet;
        hr = GetFaceNameRealizeFont(fm);
    }
    else
    {
        hr = E_FAIL; // Unknown code page
    }

    if (SUCCEEDED(hr))
    {
        // Height, CharSet, Pitch and Family
        fm.lfDestFont.lfHeight = fm.lfSrcFont.lfHeight;
        fm.lfDestFont.lfPitchAndFamily = fm.lfSrcFont.lfPitchAndFamily;
        hr = GetFaceNameRealizeFont(fm);

        if (FAILED(hr))
        {
            // CharSet, Pitch and Family
            fm.lfDestFont.lfHeight = 0;
            hr = GetFaceNameRealizeFont(fm);
        }

        if (FAILED(hr))
        {
            // CharSet and Pitch
            fm.lfDestFont.lfPitchAndFamily &= 0x03; // Pitch Mask
            hr = GetFaceNameRealizeFont(fm);
        }

        if (FAILED(hr))
        {
            // CharSet only
            fm.lfDestFont.lfPitchAndFamily = 0;
            hr = GetFaceNameRealizeFont(fm);
        }
    }

    return hr;
}

HRESULT CMLFLink::GetFaceNameMIME(CFontMappingInfo& fm)
{
    HRESULT hr = E_FAIL;
    MIMECPINFO cpInfo;    

    if (fm.auCodePage[fm.iCP] == 936)
    {
        MLStrCpyN(fm.szFaceName, TEXT("SimSun"), LF_FACESIZE);
        return S_OK;
    }

    if (!g_pMimeDatabase)
        BuildGlobalObjects();


    if (NULL != g_pMimeDatabase)
    {
        if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(fm.auCodePage[fm.iCP], 0x409, &cpInfo)))
        {
            TCHAR szFontFaceName[LF_FACESIZE];
            szFontFaceName[0] = 0;

            if ((fm.lfSrcFont.lfPitchAndFamily & 0x03) == FIXED_PITCH && cpInfo.wszFixedWidthFont[0])
            {
#ifdef UNICODE
                MLStrCpyNW(szFontFaceName, cpInfo.wszFixedWidthFont, LF_FACESIZE);
#else
                WideCharToMultiByte(CP_ACP, 0, cpInfo.wszFixedWidthFont, -1, szFontFaceName, LF_FACESIZE, NULL, NULL);
#endif
            }
            else
                if (cpInfo.wszProportionalFont[0])
                {
#ifdef UNICODE
                    MLStrCpyNW(szFontFaceName, cpInfo.wszProportionalFont, LF_FACESIZE);
#else
                    WideCharToMultiByte(CP_ACP, 0, cpInfo.wszProportionalFont, -1, szFontFaceName, LF_FACESIZE, NULL, NULL);
#endif
                }

            if (szFontFaceName[0])
            {
                MLStrCpyN(fm.szFaceName, szFontFaceName, LF_FACESIZE);
                hr = S_OK;
            }
        }
        else
            hr = MLSTR_E_FACEMAPPINGFAILURE;
    }

    return hr;
}

HRESULT CMLFLink::GetFaceNameRealizeFont(CFontMappingInfo& fm)
{
    HRESULT hr = S_OK;
    HFONT hFont = NULL;
    HFONT hOldFont;
    DWORD dwFontCodePages;

    // First let's get a facename based on the given lfDestFont
    // Then verify if the font of the found facename has the code pages we want.

    hFont = ::CreateFontIndirect(&fm.lfDestFont);
    if (!hFont)
        hr = E_FAIL; // Out of memory or GDI resource

    if (SUCCEEDED(hr))
    {
        hOldFont = (HFONT)::SelectObject(fm.hDC, hFont);
        if (!hOldFont)
            hr = E_FAIL; // Out of memory or GDI resource
    }

    if (SUCCEEDED(hr))
    {
        if (!::GetTextFace(fm.hDC, ARRAYSIZE(fm.szFaceName), fm.szFaceName))
            hr = E_FAIL; // Out of memory or GDI resource

        if (!::SelectObject(fm.hDC, hOldFont) && SUCCEEDED(hr))
            hr = E_FAIL; // Out of memory or GDI resource
    }

    if (hFont)
        ::DeleteObject(hFont);

    if (SUCCEEDED(hr))
    {
        LOGFONT lfTemp;

        lfTemp = fm.lfDestFont;
        _tcsncpy(lfTemp.lfFaceName, fm.szFaceName, ARRAYSIZE(lfTemp.lfFaceName));

        hFont = ::CreateFontIndirect(&lfTemp);
        if (!hFont)
            hr = E_FAIL; // Out of memory or GDI resource

        if (SUCCEEDED(hr = GetFontCodePages(fm.hDC, hFont, &dwFontCodePages)) && !(dwFontCodePages & fm.adwCodePages[fm.iCP]))
                hr = MLSTR_E_FACEMAPPINGFAILURE;

        if (hFont)
            ::DeleteObject(hFont);
    }

    return hr;
}

HRESULT CMLFLink::VerifyFaceMap(CFontMappingInfo& fm)
{
    HRESULT hr = S_OK;
    HFONT hOldFont;

    if (fm.hDestFont)
        ::DeleteObject(fm.hDestFont);

    fm.hDestFont = ::CreateFontIndirect(&fm.lfDestFont);
    if (!fm.hDestFont)
        hr = E_FAIL; // Out of memory or GDI resource

    if (SUCCEEDED(hr))
    {
        hOldFont = (HFONT)::SelectObject(fm.hDC, fm.hDestFont);
        if (!hOldFont)
            hr = E_FAIL; // Out of memory or GDI resource
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szFaceName[LF_FACESIZE];

        if (!::GetTextFace(fm.hDC, ARRAYSIZE(szFaceName), szFaceName))
            hr = E_FAIL; // Out of memory or GDI resource

        if (SUCCEEDED(hr))
        {
            int nRet = ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, fm.lfDestFont.lfFaceName, -1, szFaceName, -1);
            if (!nRet)
                hr = E_FAIL; // Unexpected error
            else if (nRet != 2) // Not Equal
                hr = MLSTR_E_FACEMAPPINGFAILURE;
        }

        if (!::SelectObject(fm.hDC, hOldFont) && SUCCEEDED(hr))
            hr = E_FAIL; // Out of memory or GDI resource
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLFLink::CFontMappingCache

CMLFLink::CFontMappingCache::CFontMappingCache(void) :
    m_pEntries(NULL),
    m_pFree(NULL),
    m_cEntries(0)
{
    ::InitializeCriticalSection(&m_cs);
}

CMLFLink::CFontMappingCache::~CFontMappingCache(void)
{
    FlushEntries();
    DeleteCriticalSection(&m_cs);
}

HRESULT CMLFLink::CFontMappingCache::FindEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT* phDestFont)
{
    HRESULT hr = S_FALSE;

    ::EnterCriticalSection(&m_cs);

    if (m_pEntries)
    {
        CFontMappingCacheEntry* pEntry = m_pEntries;

        while ((pEntry = pEntry->m_pPrev) != m_pEntries)
        {
            if (uCodePage == pEntry->m_uSrcCodePage &&
                lfSrcFont.lfPitchAndFamily == pEntry->m_bSrcPitchAndFamily &&
                lfSrcFont.lfHeight == pEntry->m_lSrcHeight &&
                lfSrcFont.lfWidth == pEntry->m_lSrcWidth &&
                lfSrcFont.lfEscapement == pEntry->m_lSrcEscapement &&
                lfSrcFont.lfOrientation == pEntry->m_lSrcOrientation &&
                lfSrcFont.lfWeight == pEntry->m_lSrcWeight &&
                lfSrcFont.lfItalic == pEntry->m_bSrcItalic &&
                lfSrcFont.lfUnderline == pEntry->m_bSrcUnderline &&
                lfSrcFont.lfStrikeOut == pEntry->m_bSrcStrikeOut)
            {
                int nRet = ::CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lfSrcFont.lfFaceName, -1, pEntry->m_szSrcFaceName, -1);
                if (!nRet)
                {
                    hr = E_FAIL; // Unexpected error
                    break;
                }
                else if (nRet == 2) // Equal
                {
                    if (phDestFont)
                        *phDestFont = pEntry->m_hDestFont;
                    pEntry->m_nLockCount++;
                    hr = S_OK;
                    break;
                }
            }
        }
    }

    ::LeaveCriticalSection(&m_cs);

    if (phDestFont && hr != S_OK)
        *phDestFont = NULL;

    return hr;
}

HRESULT CMLFLink::CFontMappingCache::UnlockEntry(HFONT hDestFont)
{
    HRESULT hr = E_FAIL; // hDestFont is not found in the cache

    ::EnterCriticalSection(&m_cs);

    if (m_pEntries)
    {
        CFontMappingCacheEntry* pEntry = m_pEntries;

        while ((pEntry = pEntry->m_pPrev) != m_pEntries)
        {
            if (hDestFont == pEntry->m_hDestFont)
            {
                if (pEntry->m_nLockCount - 1 >= 0)
                {
                    pEntry->m_nLockCount--;
                    hr = S_OK;
                }
                break;
            }
        }
    }

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLFLink::CFontMappingCache::AddEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT hDestFont)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pEntries) // Need to allocate all the entries
    {
        CFontMappingCacheEntry* pEntries;

        pEntries = new CFontMappingCacheEntry[NUMFONTMAPENTRIES + 1]; // +1 for sentinel

        if (pEntries)
        {
            // Init sentinel
            pEntries[0].m_pPrev = &pEntries[0];
            pEntries[0].m_pNext = &pEntries[0];

            // Init free entries
            for (int n = 0; n < NUMFONTMAPENTRIES; n++)
            {
                const nEnt = n + 1; // + 1 for sentinel

                if (n < NUMFONTMAPENTRIES - 1)
                    pEntries[nEnt].m_pNext = &pEntries[nEnt + 1];
                else
                    pEntries[nEnt].m_pNext = NULL;
            }

            m_pEntries = &pEntries[0];
            m_pFree = &pEntries[1];
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) && !m_pFree) // Need to delete oldest entry
    {
        CFontMappingCacheEntry* pOldestEntry = m_pEntries->m_pPrev;

        while (pOldestEntry->m_nLockCount > 0 && pOldestEntry != m_pEntries) // Entry is locked
            pOldestEntry = pOldestEntry->m_pPrev;

        if (pOldestEntry != m_pEntries)
        {
            if (pOldestEntry->m_hDestFont)
                ::DeleteObject(pOldestEntry->m_hDestFont);

            // Delete it from m_pEntries list
            pOldestEntry->m_pPrev->m_pNext = pOldestEntry->m_pNext;
            pOldestEntry->m_pNext->m_pPrev = pOldestEntry->m_pPrev;

            // Insert it into m_pFree list
            pOldestEntry->m_pNext = m_pFree;
            m_pFree = pOldestEntry;
        }
        else // No entry available
        {
            hr = E_FAIL; // Out of cache entries
        }
    }

    if (SUCCEEDED(hr)) // Create new entry and fill it
    {
        CFontMappingCacheEntry* pNewEntry;

        // Delete it from m_pFree list
        pNewEntry = m_pFree; // shouldn't be NULL
        m_pFree = pNewEntry->m_pNext;

        // Insert it into m_pEntries list
        pNewEntry->m_pNext = m_pEntries->m_pNext;
        pNewEntry->m_pPrev = m_pEntries;
        m_pEntries->m_pNext->m_pPrev = pNewEntry;
        m_pEntries->m_pNext = pNewEntry;

        // Fill it
        pNewEntry->m_nLockCount = 1;
        pNewEntry->m_uSrcCodePage = uCodePage;
        pNewEntry->m_lSrcHeight = lfSrcFont.lfHeight;
        pNewEntry->m_lSrcWidth = lfSrcFont.lfWidth;
        pNewEntry->m_lSrcEscapement = lfSrcFont.lfEscapement;
        pNewEntry->m_lSrcOrientation = lfSrcFont.lfOrientation;
        pNewEntry->m_lSrcWeight = lfSrcFont.lfWeight;
        pNewEntry->m_bSrcItalic = lfSrcFont.lfItalic;
        pNewEntry->m_bSrcUnderline = lfSrcFont.lfUnderline;
        pNewEntry->m_bSrcStrikeOut = lfSrcFont.lfStrikeOut;
        pNewEntry->m_bSrcPitchAndFamily = lfSrcFont.lfPitchAndFamily;
        _tcsncpy(pNewEntry->m_szSrcFaceName, lfSrcFont.lfFaceName, ARRAYSIZE(pNewEntry->m_szSrcFaceName));
        pNewEntry->m_hDestFont = hDestFont;
    }

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLFLink::CFontMappingCache::FlushEntries(void)
{
    ::EnterCriticalSection(&m_cs);

    if (m_pEntries)
    {
        CFontMappingCacheEntry* pEntry = m_pEntries;

        while ((pEntry = pEntry->m_pPrev) != m_pEntries)
        {
            if (pEntry->m_hDestFont)
                ::DeleteObject(pEntry->m_hDestFont);
        }

        delete[] m_pEntries;

        m_pEntries = NULL;
        m_cEntries = 0;
    }

    ::LeaveCriticalSection(&m_cs);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLFLink::CCodePagesCache

CMLFLink::CCodePagesCache::CCodePagesCache(void) :
    m_pbBuf(NULL),m_pbBufExt(NULL)
{
    ::InitializeCriticalSection(&m_cs);
}

CMLFLink::CCodePagesCache::~CCodePagesCache(void)
{
    DeleteCriticalSection(&m_cs);
}

HRESULT CMLFLink::CCodePagesCache::RealLoad(void)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pbBuf && !m_pbBufExt)
    {
        HRSRC hrCodePages;
        HGLOBAL hgCodePages;
        HRSRC hrCodePagesExt;
        HGLOBAL hgCodePagesExt;


        if (SUCCEEDED(hr))
        {
            hrCodePages = ::FindResource(g_hInst, MAKEINTRESOURCE(IDR_CODEPAGES), _T("CODEPAGES"));
            hrCodePagesExt = ::FindResource(g_hInst, MAKEINTRESOURCE(IDR_CODEPAGESEXT), _T("CODEPAGESEXT"));
            if (!hrCodePages || !hrCodePagesExt)
                hr = E_FAIL; // Build error?
        }
        if (SUCCEEDED(hr))
        {
            hgCodePages = ::LoadResource(g_hInst, hrCodePages);
            hgCodePagesExt = ::LoadResource(g_hInst, hrCodePagesExt);
            if (!hgCodePages && !hgCodePagesExt)
                hr = E_FAIL; // Unexpected error
        }
        if (SUCCEEDED(hr))
        {
            m_pbBuf = (BYTE*)::LockResource(hgCodePages);
            m_pbBufExt = (BYTE*)::LockResource(hgCodePagesExt);
            if (!m_pbBuf || !m_pbBufExt)
                hr = E_FAIL; // Unexpected error
        }
    }

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

extern "C" HRESULT GetGlobalFontLinkObject(IMLangFontLink **ppMLFontLink)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppMLFontLink)
    {
        if (NULL == g_pMLFLink)
        {
            EnterCriticalSection(&g_cs);
            if (NULL == g_pMLFLink)
                CComCreator< CComPolyObject< CMLFLink > >::CreateInstance(NULL, IID_IMLangFontLink, (void **)&g_pMLFLink);
            LeaveCriticalSection(&g_cs);
        }
        *ppMLFontLink = g_pMLFLink;
        if (g_pMLFLink)
        {
            g_pMLFLink->AddRef();
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

HRESULT CMLFLink2::CFontMappingCache2::MapFontFromCMAP(HDC hDC, WCHAR wchar, HFONT hSrcFont, HFONT *phDestFont)
{
    BOOL    bFont = FALSE;
    HRESULT hr = E_FAIL;
    int     i,j,k;
    LOGFONT LogFont;

    if (!phDestFont)
        return E_INVALIDARG;

    if (!GetObject(hSrcFont, sizeof(LOGFONT), &LogFont))
        return hr;

    if (!g_pfont_table || !g_pfont_table[0].szFaceName[0])
    {        
        if (FAILED(LoadFontDataFile()))
        {
            return hr;
        }
    }

    i=0;
    j=ARRAYSIZE(g_urange_table);
    k = j/2;

    while (i<=j)
    {

        if (wchar >= g_urange_table[k].wcFrom && wchar <= g_urange_table[k].wcTo)
           break;
        else
           if (wchar < g_urange_table[k].wcFrom)
           {
               j = k -1;
           }
           else
           {
               i = k + 1;
           }
           k = (i+j)/2;
    }

    if (i<=j && g_urange_table[k].nFonts)
    {
        TCHAR szFaceName[LF_FACESIZE];
        GetTextFace(hDC, LF_FACESIZE, szFaceName);

        // Check if it supports the character
        for (i=0; i<g_urange_table[k].nFonts; i++)
        {
            if (!MLStrCmpI(szFaceName,g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfFaceName))
                break;
        }

        // Current font doesn't support this character
        if (i == g_urange_table[k].nFonts)
        {
            for (i=0; i<g_urange_table[k].nFonts; i++)
            {
                if (LogFont.lfCharSet == g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfCharSet)
                    break;
            }

            // No font available for current CharSet, then return the first one in the list            
            if (i >= g_urange_table[k].nFonts)
            {
                i = fetchCharSet((BYTE *) &(LogFont.lfCharSet), k);
            }

            MLStrCpyN(LogFont.lfFaceName, g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfFaceName, LF_FACESIZE);
        }

        if (i < g_urange_table[k].nFonts)
        {
            MLStrCpyN(LogFont.lfFaceName, g_pfont_table[*(g_urange_table[k].pFontIndex+i)].lf.lfFaceName, LF_FACESIZE);
        }
        
        bFont = TRUE;
    } 

    if (bFont && (*phDestFont = CreateFontIndirect(&LogFont)))
    {
        hr = S_OK;       
    }
    else
    {
        *phDestFont = NULL;
    }


    return hr;
}


HRESULT CMLFLink2::CFontMappingCache2::UnicodeRanges(
    LPTSTR  szFont,
    UINT    *puiRanges, 
    UNICODERANGE* pURanges
    )

{
    HRESULT hr = E_FAIL;
    UINT    nURange = 0;
    DWORD   cmap    = 0;
    DWORD   name    = 0;
    HANDLE  hTTF;    
    TCHAR   szFontPath[MAX_PATH];
    static TCHAR s_szFontDir[MAX_PATH] = {0};


    HANDLE  hTTFMap;
    DWORD   dwFileSize;
    LPVOID  lpvFile = NULL;
    LPBYTE  lp, lp1, lp2, lpMax = NULL;
    DWORD   Num;
    WORD    i, j, Len;

    if (!szFont[0])
        return hr;

    if (!s_szFontDir[0])
    {
        MLGetWindowsDirectory(s_szFontDir, MAX_PATH);
        MLPathCombine(s_szFontDir, s_szFontDir, FONT_FOLDER);
    }

    MLPathCombine(szFontPath, s_szFontDir, szFont);

    hTTF = CreateFile(  szFontPath,             // pointer to name of the file
                        GENERIC_READ,           // access (read-write) mode
                        FILE_SHARE_READ,        // share mode
                        NULL,                   // pointer to security attributes
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // handle to file with attributes to copy;

    if (INVALID_HANDLE_VALUE == hTTF)
        return hr;

    dwFileSize = GetFileSize(hTTF, NULL);


    hTTFMap = CreateFileMapping(
                  hTTF,
                  NULL,
                  PAGE_READONLY,
                  0,
                  dwFileSize,
                  NULL
              );

    if(hTTFMap == NULL)
    {
        goto CloseHandle0;
    }

    lpvFile = MapViewOfFile(
                  hTTFMap,
                  FILE_MAP_READ,
                  0,
                  0,
                  0
              );

    if(lpvFile == NULL)
    {
        goto CloseHandle;
    }

    lp = (LPBYTE)lpvFile;
    // The maximum boundary we can go
    lpMax = (LPBYTE)lpvFile + dwFileSize;

    // Font table name uses ASCII
    if(strncmp(((TTC_HEAD*)lp)->TTCTag, "ttcf", 4) == 0)   // TTC format
    {
        lp += FOUR_BYTE_NUM(((TTC_HEAD*)lp)->OffsetTTF1);  // points to first TTF
    }

    Num = TWO_BYTE_NUM(((TTF_HEAD*)lp)->NumTables);        // Number of Tables
    lp += sizeof(TTF_HEAD);

    if (lp+Num*sizeof(TABLE_DIR) >= lpMax) // Not a valid TrueType file if table size >= TTF file size
        goto CloseHandle;

    for(i = 0; i < Num ; i++)   // go thru all tables to find cmap and name
    {
        if(strncmp( ((TABLE_DIR*)lp)->Tag, "cmap", 4) == 0)
        {
            cmap = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (name) break;
        }
        else if(strncmp( ((TABLE_DIR*)lp)->Tag, "name", 4) == 0)
        {
            name = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (cmap) break;
        }
        lp += sizeof(TABLE_DIR);

     }

    if((!cmap) || (!name))    // Can't find cmap or name
    {
        goto CloseHandle;
    }

    // Read thru all name records
    // to see if font subfamily name is "Regular"

    lp  = (LPBYTE)lpvFile + name;                   // point to name table
    Num = TWO_BYTE_NUM(((NAME_TABLE*)lp)->NumRec);  // # of name record

    if (lp + sizeof(NAME_TABLE)*Num >= lpMax)
        goto CloseHandle;

    lp1 = lp  + sizeof(NAME_TABLE);                 // point to name record


    for(i = 0; i < Num; i++)
    {
        if(FONT_SUBFAMILY_NAME == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->NameID))
        {
            lp2 = lp +                              // point to string store
                  TWO_BYTE_NUM(((NAME_TABLE* )lp )->Offset) +
                  TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Offset);

            // Invalid TTF file
            if (lp2 >= lpMax)
                break;

            Len = TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Length);

            if(((MICROSOFT_PLATFORM == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Platform)) && 
                (UNICODE_INDEXING == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Encoding)))  ||
               ((APPLE_UNICODE_PLATFORM == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Platform)) && 
                (APPLE_UNICODE_INDEXING == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Encoding))))  
            {
                Len >>= 1;
                const char *pStr = szRegular;

                if (Len == sizeof(szNormal) -1)
                    pStr = szNormal;
                else 
                    if (Len != sizeof(szRegular)-1)
                    {
                        lp1 += sizeof(NAME_RECORD);
                        continue;
                    }

                while(--Len > 0)
                {
                    if(*(lp2+(Len<<1)+1) != pStr[Len])
                    break;
                }

                if (!Len)
                    break;
                else
                {
                    lp1 += sizeof(NAME_RECORD);
                    continue;
                }
            }
            else
            {
                if(strncmp((char*)lp2, szRegular, sizeof(szRegular)-1) != 0 && 
                   strncmp((char*)lp2, szNormal, sizeof(szNormal)-1) != 0)
                {
                    lp1 += sizeof(NAME_RECORD);
                    continue;
                }
                else
                    break;
            }
        }
        lp1 += sizeof(NAME_RECORD);
    }

    // If no regular font, exit
    if (i == Num)
        goto CloseHandle;

    // all non-regular fonts have already been eliminated
    lp1  = (LPBYTE)lpvFile + cmap;                     // point to cmap table

    if (lp1 + sizeof(CMAP_TABLE)*Num >= lpMax)
        goto CloseHandle;

    Num  = TWO_BYTE_NUM(((CMAP_HEAD*)lp1)->NumTables);

    lp1 += sizeof(CMAP_HEAD);


    while(Num >0)
    {

        if(TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Platform) == MICROSOFT_PLATFORM && 
           (TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_INDEXING ||
           TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_SYMBOL_INDEXING))
        {
            lp = (LPBYTE)lpvFile
                 + cmap
                 + FOUR_BYTE_NUM(((CMAP_TABLE*)lp1)->Offset);

            if(TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->Format) == CMAP_FORMAT_FOUR)
            {
                break;
            }
        }
        Num--;
        lp1 += sizeof(CMAP_TABLE);
    }

    if(Num == 0)                            // can't find Platform:3/Encoding:1 (Unicode)
        goto CloseHandle;

    Num  = TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->SegCountX2);
    lp2  = lp  + sizeof(CMAP_FORMAT);       // lp2 -> first WCHAR of wcTo
    lp1  = lp2 + Num + 2;                   // lp1 -> first WCHAR of wcFrom

    if (lp1 + Num >= lpMax)
        goto CloseHandle;

    Num /= 2;

    

    if (pURanges == NULL)
    {
        *puiRanges = Num;
    }
    else
    {
        if (Num > *puiRanges)
            Num = *puiRanges;
        else
            *puiRanges = Num;

        for(i=0, j=0; i < Num; i++, j++, j++)
        {
            pURanges[i].wcFrom = TWO_BYTE_NUM((lp1+j));
            pURanges[i].wcTo   = TWO_BYTE_NUM((lp2+j));
        }
    }

    hr = S_OK;

CloseHandle:
    UnmapViewOfFile(lpvFile);
CloseHandle0:
    CloseHandle(hTTFMap);
    CloseHandle(hTTF);

    return hr;
}

int CMLFLink2::CFontMappingCache2::fetchCharSet(BYTE *pCharset, int iURange)
{
    int i,j;

    //Check if current charset valid for the font
    for (i=0; i<g_urange_table[iURange].nFonts; i++)
    {
        for (j=0;(j<32) && g_CharSetTransTable[j].uCodePage;j++)
        {
            if (g_pfont_table[*(g_urange_table[iURange].pFontIndex+i)].dwCodePages[0] & g_CharSetTransTable[j].dwCodePages)
                if (*pCharset == g_CharSetTransTable[j].nCharSet)
                    return i;
        }
    }

    //If invalid, fetch first valid one.
    for (i=0;(i<32) && g_CharSetTransTable[i].uCodePage;i++)
    {
        if (g_pfont_table[*(g_urange_table[iURange].pFontIndex)].dwCodePages[0] & g_CharSetTransTable[i].dwCodePages)
        {
           *pCharset = (BYTE)g_CharSetTransTable[i].nCharSet;
           break;
        }
    }

    return 0;
}


BOOL CMLFLink2::CFontMappingCache2::GetNonCpFontUnicodeRanges(TCHAR *szFontName, int iFontIndex)
{
    LONG    nURange = 0;
    DWORD   cmap    = 0;
    DWORD   name    = 0;
    DWORD   os2     = 0;

    HANDLE  hTTFMap;
    DWORD   dwFileSize;
    LPVOID  lpvFile;
    LPBYTE  lp, lp1, lp2;
    DWORD   Num;
    int     i, j, k, m;
    WORD    Len;
    HANDLE  hTTF;
    BOOL    bRet = FALSE;


    hTTF = CreateFile(  szFontName,             // pointer to name of the file
                        GENERIC_READ,           // access (read-write) mode
                        FILE_SHARE_READ,        // share mode
                        NULL,                   // pointer to security attributes
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // handle to file with attributes to copy;

    if (hTTF == INVALID_HANDLE_VALUE)
        return FALSE;

    dwFileSize = GetFileSize(hTTF, NULL);

    hTTFMap = CreateFileMapping(
                  hTTF,
                  NULL,
                  PAGE_READONLY,
                  0,
                  dwFileSize,
                  NULL
              );

    if(hTTFMap == NULL)
    {
        goto CloseHandle01;
    }

    lpvFile = MapViewOfFile(
                  hTTFMap,
                  FILE_MAP_READ,
                  0,
                  0,
                  0
              );

    if(lpvFile == NULL)
    {
        goto CloseHandle00;
    }

    lp = (LPBYTE)lpvFile;

    if(strncmp(((TTC_HEAD*)lp)->TTCTag, "ttcf", 4) == 0)   // TTC format
    {
        lp += FOUR_BYTE_NUM(((TTC_HEAD*)lp)->OffsetTTF1);  // points to first TTF
    }

    Num = TWO_BYTE_NUM(((TTF_HEAD*)lp)->NumTables);        // Number of Tables
    {
      // if SearchRange != (Maximum power of 2 <= Num)*16,
      // then this is not a TTF file
      DWORD  wTmp = 1;

      while(wTmp <= Num)
      {
        wTmp <<= 1;
      }
      wTmp <<= 3;          // (wTmp/2)*16

      if(wTmp != (DWORD)TWO_BYTE_NUM(((TTF_HEAD*)lp)->SearchRange))
      {
        goto CloseHandle00;
      }

      // if RangeShift != (Num*16) - SearchRange,
      // then this is not a TTF file
      wTmp = (Num<<4) - wTmp;
      if(wTmp != (DWORD)TWO_BYTE_NUM(((TTF_HEAD*)lp)->RangeShift))
      {
        goto CloseHandle00;
      }
    }

    lp += sizeof(TTF_HEAD);

    for(i = 0; i < (int)Num; i++)   // go thru all tables to find cmap and name
    {
        if(strncmp( ((TABLE_DIR*)lp)->Tag, "cmap", 4) == 0)
        {
            cmap = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (name && os2) break;
        }
        else if(strncmp( ((TABLE_DIR*)lp)->Tag, "name", 4) == 0)
        {
            name = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (cmap && os2) break;
        }
        else if(strncmp( ((TABLE_DIR*)lp)->Tag, "OS/2", 4) == 0)
        {
            os2 = FOUR_BYTE_NUM(((TABLE_DIR*)lp)->Offset);
            if (cmap && name) break;
        }

        lp += sizeof(TABLE_DIR);
     }

    if((!cmap) || (!name) || (!os2))    // Can't find cmap or name
    {
        goto CloseHandle00;
    }

    // Read thru all name records
    // to see if font subfamily name is "Regular"

    lp  = (LPBYTE)lpvFile + name;                   // point to name table
    Num = TWO_BYTE_NUM(((NAME_TABLE*)lp)->NumRec);  // # of name record
    lp1 = lp  + sizeof(NAME_TABLE);                 // point to name record

    for(i = 0; i < (int)Num; i++)
    {
        if(FONT_SUBFAMILY_NAME == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->NameID))
        {
            lp2 = lp +                              // point to string store
                  TWO_BYTE_NUM(((NAME_TABLE* )lp )->Offset) +
                  TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Offset);

            Len = TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Length);

            if(UNICODE_INDEXING == TWO_BYTE_NUM(((NAME_RECORD*)lp1)->Encoding))
            {
                Len >>= 1;
                while(--Len > 0)
                {
                    if(*(lp2+(Len<<1)+1) != szRegular[Len])
                    goto CloseHandle00;
                }
                break;
            }
            else
            {
                if(strncmp((char*)lp2, szRegular, Len) != 0)
                    goto CloseHandle00;
                else
                    break;
            }
        } 

        lp1 += sizeof(NAME_RECORD);
    }

    // all non-regular fonts have already been eliminated

    lp1  = (LPBYTE)lpvFile + cmap;                     // point to cmap table
    Num  = TWO_BYTE_NUM(((CMAP_HEAD*)lp)->NumTables);
    lp1 += sizeof(CMAP_HEAD);

    while(Num >0)
    {
        if(TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Platform) == MICROSOFT_PLATFORM && 
           TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_INDEXING)
        {
            lp = (LPBYTE)lpvFile
                 + cmap
                 + FOUR_BYTE_NUM(((CMAP_TABLE*)lp1)->Offset);

            if(TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->Format) == CMAP_FORMAT_FOUR)
            {
                break;
            }
        }
        Num--;
        lp1 += sizeof(CMAP_TABLE);
    }

    if(Num == 0)                   // can't find Platform:3/Encoding:1 (Unicode)
        goto CloseHandle00;


    Num  = TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->SegCountX2) ;

    m = ARRAYSIZE(g_urange_table);

    lp2  = lp  + sizeof(CMAP_FORMAT);     // lp2 -> first WCHAR of wcTo
    lp1  = lp2 + Num + 2;                 // lp1 -> first WCHAR of wcFrom


    // Fast parse !!!
    while (--m)
    {
        // URANGE binary search
        i=0;
        j= (int) Num - 2;
        k=j/2;
        while (i<=j)
        {
            if (k % 2) 
                k++;

            if (g_urange_table[m].wcFrom >= TWO_BYTE_NUM((lp1+k)) && g_urange_table[m].wcTo <= TWO_BYTE_NUM((lp2+k)))
            {
                EnterCriticalSection(&g_cs);
                if (!g_urange_table[m].pFontIndex)
                    g_urange_table[m].pFontIndex = (int *)LocalAlloc(LPTR, sizeof(int)* MAX_FONT_INDEX);
                if (!g_urange_table[m].pFontIndex)
                {
                    goto CloseHandle00;
                }

                if (g_urange_table[m].nFonts >= MAX_FONT_INDEX)
                {
                    break;
                }

                g_urange_table[m].pFontIndex[g_urange_table[m].nFonts] = iFontIndex;
                g_urange_table[m].nFonts++;

                // Fill in font code page signature
                g_pfont_table[iFontIndex].dwCodePages[0] = FOUR_BYTE_NUM(((BYTE *)lpvFile+os2+OFFSET_OS2CPRANGE));
                g_pfont_table[iFontIndex].dwCodePages[1] = FOUR_BYTE_NUM(((BYTE *)lpvFile+os2+OFFSET_OS2CPRANGE+1));                
                LeaveCriticalSection(&g_cs);
                break;
            }
            else
            {
                if (g_urange_table[m].wcFrom < TWO_BYTE_NUM((lp1+k)))
                {
                    j = k-2;
                }
                else
                {
                    i = k+2;
                }
                k = (i+j)/2;
            }
        }
    }
    
    bRet = TRUE;

CloseHandle00:
    UnmapViewOfFile(lpvFile);
CloseHandle01:
    CloseHandle(hTTF);
    CloseHandle(hTTFMap);

    return bRet;
}

HRESULT GetRegFontKey(HKEY *phKey, DWORD *pdwValues)
{
    HRESULT hr = E_FAIL;

    if (ERROR_SUCCESS == (g_bIsNT? 
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGFONTKEYNT, 0, KEY_READ, phKey):
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGFONTKEY95, 0, KEY_READ, phKey)))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(*phKey, NULL, NULL, 0, NULL, 
            NULL, NULL, pdwValues, NULL, NULL, NULL, NULL))
        {
            hr = S_OK;
        }        
    }

    return hr;
}

BOOL CMLFLink2::CFontMappingCache2::GetFontURangeBits(TCHAR *szFontFile, DWORD * pdwURange)
{
    // We can make use of font Unicode range signature if needed.
    return TRUE;    
}

BOOL CMLFLink2::CFontMappingCache2::SetFontScripts(void)
{

    LOGFONT lf;
    int     i,j;
    HWND    hWnd = GetTopWindow(GetDesktopWindow());
    HDC     hDC = GetDC(hWnd);


    if (!g_pfont_table)
        return FALSE;

    // Process code page based scripts (g_CharSetTransTable.sid)
    for (i = 0; g_CharSetTransTable[i].nCharSet != DEFAULT_CHARSET; i++)
    {
        j = 0;
        ZeroMemory(&lf, sizeof(lf));
        lf.lfCharSet = (BYTE)g_CharSetTransTable[i].nCharSet;

        while (g_CharSetTransTable[i].sid[j] != sidDefault)
        {
            EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)SetFontScriptsEnumFontProc, (LPARAM)g_CharSetTransTable[i].sid[j], 0);
            j++;
        }
    }


    if (hDC)
        ReleaseDC(hWnd, hDC);

    // Process Unicode subrange based scripts (not implemented)
    // Skip this part since we need to access font CMAP anyway

    // Process char based scripts (g_wCharToScript)

    for (i=1; i<= (int)g_pfont_table[0].dwCodePages[0]; i++)
    {
        UINT uiRanges = 0;
        UNICODERANGE* pURanges = NULL;
        SCRIPT_IDS  scripts;

        if (SUCCEEDED(m_pFontMappingCache2->UnicodeRanges(g_pfont_table[i].szFileName, &uiRanges, pURanges)))
        {
            if (uiRanges)
            {
                int         l, m, n;                

                pURanges = (UNICODERANGE *)LocalAlloc(LPTR, sizeof(UNICODERANGE) * uiRanges);

                if (!pURanges)
                    return FALSE;

                m_pFontMappingCache2->UnicodeRanges(g_pfont_table[i].szFileName, &uiRanges, pURanges);
                for (j=0; j< ARRAYSIZE(g_wCharToScript); j++)
                {

                    l = 0;
                    m = uiRanges;
                    n = m/2;
                    while (l <= m)
                    {
                        if ((g_wCharToScript[j].wch >= pURanges[n].wcFrom) && (g_wCharToScript[j].wch <= pURanges[n].wcTo))
                        {
                            scripts = 1;
                            scripts <<= g_wCharToScript[j].sid;
                            g_pfont_table[i].scripts |= scripts;
                            break;
                        }
                        else
                        {
                            if (g_wCharToScript[j].wch < pURanges[n].wcFrom)
                                m = n-1;
                            else
                                l = n+1;
                            n = (m+l)/2;
                        }
                    }
                }

                LocalFree(pURanges);
                pURanges = NULL;
            }
        }

        // sidUserDefined should contain all valid regular TrueType fonts
        if (!MLStrStr(g_pfont_table[i].szFaceName, TEXT("Bold")) && !MLStrStr(g_pfont_table[i].szFaceName, TEXT("Italic")))
        {
            scripts = 1;
            scripts <<= sidUserDefined;
            g_pfont_table[i].scripts |= scripts;
        }
    }

    //GetFontScriptFromCMAP(szFont, &(g_pfont_table[i].scripts));

    return TRUE;
}

BOOL CMLFLink2::CFontMappingCache2::IsFontUpdated(void)
{
    HKEY    hkey;
    DWORD   dwFonts = 0;
    BOOL    bRet = FALSE;


    if (g_pfont_table)
    {
        if (S_OK == GetRegFontKey(&hkey, &dwFonts))
        {
            if (g_pfont_table[0].dwCodePages[1] != dwFonts)
                bRet = TRUE;
            RegCloseKey(hkey);
        }
    }
    else
    {
        // font table not created yet, need to update
        bRet = TRUE;
    }

    return bRet;
}
    
// Make sure we have font data table available and it is updated
HRESULT CMLFLink2::CFontMappingCache2::EnsureFontTable(BOOL bUpdateURangeTable)    
{
    BOOL bRet;
    
    if (IsFontUpdated())
    {
        // Need to guard the whole font creation procedure by critical sections
        EnterCriticalSection(&g_cs);

        if (IsFontUpdated())
        {
            if (g_pfont_table)
            {
                if (g_pfont_table[0].szFaceName[0])
                {
                    bUpdateURangeTable = TRUE;
                }
                if (g_pfont_table)
                {
                    LocalFree(g_pfont_table);
                    g_pfont_table = NULL;
                }
            }

            bRet = SetFontTable();

            if (!bRet)
                return E_OUTOFMEMORY;

        }
        LeaveCriticalSection(&g_cs);        
    }

    if (bUpdateURangeTable)
    {
        EnterCriticalSection(&g_cs);
        for (int i = 0; i < ARRAYSIZE(g_urange_table); i++)
        {
            if (g_urange_table[i].nFonts)
            {
                LocalFree(g_urange_table[i].pFontIndex);
                g_urange_table[i].pFontIndex = NULL;
                g_urange_table[i].nFonts = 0;
            }            
        }
        LeaveCriticalSection(&g_cs);        

        if (S_OK != SetFontUnicodeRanges())
            return E_OUTOFMEMORY;

        SaveFontDataFile();
    }

    // All tables created successfully
    return S_OK;
}


#ifdef UNIX
typedef struct tagTable_info{
    int count;
    int table_size;
    } Table_info;

int UnixGetAllFontsProc(ENUMLOGFONTEX* plfFont, NEWTEXTMETRICEX* lpntm, int iFontType, LPARAM lParam)
{
    LOGFONT *lplf;
    int *pcount = &((Table_info*)lParam)->count;
    int *ptable_size = &((Table_info*)lParam)->table_size;

    lplf = &(plfFont->elfLogFont);
    // We don't use non TrueType fonts
    if (iFontType == DEVICE_FONTTYPE || iFontType == RASTER_FONTTYPE)
        return 1;   // keep going but don't use this font

    // We don't use the SYMBOL, Mac Charset fonts
    if(lplf->lfCharSet == SYMBOL_CHARSET || lplf->lfCharSet == MAC_CHARSET)
        return 1;

    // We don't handle vertical fonts
    if (TEXT('@') == lplf->lfFaceName[0])
        return 1;

    // Now update the font-table
    // Does UNIX use TTF? // if (FontType == TRUETYPE_FONTTYPE)
    {
        CopyMemory(&g_pfont_table[*pcount].lf, lplf, sizeof(LOGFONT));
        MLStrCpyN(g_pfont_table[*pcount].szFaceName, lplf->lfFaceName, LF_FACESIZE);
        (*pcount)++;
    }

    if (*pcount >= *ptable_size)
    {
        FONTINFO * pfont_table = NULL;

        *ptable_size += FONT_TABLE_INIT_SIZE;
        pfont_table = (FONTINFO *) LocalReAlloc(g_pfont_table, 
                                        sizeof(FONTINFO) * *ptable_size,
                                        LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (NULL == pfont_table)
        {
            return 0; // Stop enum. 
        }
        else
        {
            g_pfont_table = pfont_table;
        }
    }
 
    return 1;       // Keep enum. 
}
#endif

BOOL CMLFLink2::CFontMappingCache2::SetFontTable(void)
{
    BOOL    bRet = TRUE;
    TCHAR   szFaceName[MAX_PATH];

    DWORD   dwValue;
    TCHAR   szFontFile[MAX_FONT_FILE_NAME];
    DWORD   dwData;
    DWORD   dwType = REG_SZ;
    DWORD   dwFonts;
    int     i, table_size = FONT_TABLE_INIT_SIZE;
    LPTSTR  pNewFaceName = NULL;
    HKEY    hkey = NULL;
    static int count;

    HDC     hDC = NULL;
    HWND    hWnd = NULL;

    count = 1;
    
    if (!g_pfont_table)
    {
        g_pfont_table = (FONTINFO *)LocalAlloc(LPTR, sizeof(FONTINFO) * FONT_TABLE_INIT_SIZE);
        if (!g_pfont_table)
        {
            bRet = FALSE;
            goto SETFONT_DONE;
        }        
    }
    else
    {
        goto SETFONT_DONE;
    }
    
#ifndef UNIX
    if (S_OK != GetRegFontKey(&hkey, &dwFonts))
    {
        bRet = FALSE;
        goto SETFONT_DONE;
    }    

    hWnd = GetTopWindow(GetDesktopWindow());
    hDC = GetDC(hWnd);

    for (i=0; ;i++)
    {
        dwValue = sizeof(szFaceName);
        dwData  = sizeof(szFontFile);

        if (ERROR_NO_MORE_ITEMS == RegEnumValue(
                      hkey,
                      i,
                      szFaceName,
                      &dwValue,
                      NULL,
                      &dwType,
                      (LPBYTE)szFontFile,
                      &dwData ))
        {
            break;
        }
        DWORD dwOffset = 0;
FIND_NEXT_FACENAME:        
        pNewFaceName = MLStrStr(&szFaceName[dwOffset], TEXT(" & "));
        if (pNewFaceName)
        {
           *pNewFaceName = 0;
           // Skip " & ", look for next font face name
           pNewFaceName+=3;
        }
        else
        {
            pNewFaceName = MLStrStr(&szFaceName[dwOffset], TEXT("(TrueType)"));
            if(pNewFaceName)
            {
                // Ignor the space between face name and "(TrueTye)" signature
                if ((pNewFaceName > szFaceName) && (*(pNewFaceName-1) == 0x20))
                    pNewFaceName--;
                *pNewFaceName = 0;
            }
        }

        if (pNewFaceName && !EnumFontFamilies(hDC, &szFaceName[dwOffset], MapFontExEnumFontProc, (LPARAM)&count))   //TrueType font
        {
            int nSize;
            LPTSTR pFontFile;

            if (count >= table_size)
            {
                FONTINFO * _pfont_table = NULL;

                table_size += FONT_TABLE_INIT_SIZE;
                _pfont_table = (FONTINFO *) LocalReAlloc(g_pfont_table, sizeof(FONTINFO) * table_size,
                                    LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (NULL == _pfont_table)
                {
                    bRet = FALSE;
                    goto SETFONT_DONE;
                }
                else
                {
                    g_pfont_table = _pfont_table;
                }
            }

            nSize = lstrlen(szFontFile);

            if (!MLStrCmpNI(&szFontFile[nSize-3], "fot", 3))
                MLStrCpyN(&szFontFile[nSize-3], "ttf", 3);

            //
            // Trim off path 
            //
            // #335900, some third party apps write font file names to registry directly
            // and the names they used could have redundant font path 
            //
            pFontFile = szFontFile;

            while (nSize)
            {
                // Font file name contains only ASCII characters,
                // So, we can safely trim the path by backward searching '\'
                if (szFontFile[nSize] == TEXT('\\'))
                {
                    pFontFile = &szFontFile[nSize];
                    pFontFile++;
                    break;
                }
                nSize--;
            }

            GetFontURangeBits(szFontFile, &(g_pfont_table[count-1].dwUniSubRanges[0]));
            MLStrCpyN(g_pfont_table[count-1].szFaceName, &szFaceName[dwOffset], LF_FACESIZE);
            MLStrCpyN(g_pfont_table[count-1].szFileName, pFontFile, LF_FACESIZE);

        }
        if (pNewFaceName && (*pNewFaceName))
        {
            dwOffset = (DWORD)(pNewFaceName - &szFaceName[0]);
            goto FIND_NEXT_FACENAME;
        }
    }
#else
    // For UNIX, we don't have registry font information,
    // Let's create font table through EnumFontFamiliesEx.
    Table_info table_info;
    table_info.count = 1;
    table_info.table_size = table_size;

    int iRet;
    LOGFONT lf;
    lf.lfCharSet = DEFAULT_CHARSET; // give me all fonts
    lf.lfFaceName[0] = _T('\0');
    lf.lfPitchAndFamily = 0;
        
    hWnd = GetTopWindow(GetDesktopWindow());
    hDC = GetDC(hWnd);

    iRet = EnumFontFamiliesEx(hDC, // Enum all fonts
                     &lf,
                     (FONTENUMPROC)UnixGetAllFontsProc,
                     (LPARAM)&table_info,
                     0);
    count = table_info.count;
    if (iRet == 0) // abort
    {
        bRet = FALSE;
        goto SETFONT_DONE;    
    }
#endif // UNIX

    // Release un-used memory
    g_pfont_table = (FONTINFO *)LocalReAlloc(g_pfont_table, (count)*sizeof(FONTINFO), LMEM_MOVEABLE);

    // Save TrueType font number
    g_pfont_table[0].dwCodePages[0] = count-1;

#ifndef UNIX
    // Unix doesn't have this number.
    // Save total font number for font change verification 
    g_pfont_table[0].dwCodePages[1] = dwFonts;

    RegCloseKey(hkey);
#endif

    if (count > 1)
        SetFontScripts();

SETFONT_DONE:    

    if (hDC)
        ReleaseDC(hWnd, hDC);

    if (count <= 1)
    {
        if (g_pfont_table)
        {
            LocalFree(g_pfont_table);
            g_pfont_table = NULL;
        }

        bRet = FALSE;
    }

    return bRet;

}


HRESULT CMLFLink2::CFontMappingCache2::SaveFontDataFile(void)
{
    FONTDATAHEADER fileHeader;
    HRESULT hr = E_FAIL;
    int     *pTmpBuf = NULL;
    HANDLE  hFile = NULL;
    int     i, j, Count = 0;
    DWORD   dwSize;
    FONTDATATABLE fontInfoTable, fontIndexTable;


    hFile = CreateFile( szFontDataFilePath,         
                        GENERIC_WRITE,          
                        0,                      
                        NULL,                   
                        CREATE_ALWAYS,          
                        FILE_ATTRIBUTE_HIDDEN,
                        NULL);                 

    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto SAVE_FONT_DATA_DONE;
    }


    for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
    {
        Count += (g_urange_table[i].nFonts+1);
    }


    // Create file header
    lstrcpyA(fileHeader.FileSig, FONT_DATA_SIGNATURE);
    fileHeader.dwVersion = 0x00010000;

    // Use file size as CheckSum
    fileHeader.dwCheckSum = sizeof(FONTINFO)*(g_pfont_table[0].dwCodePages[0]+1)+Count*sizeof(int)+
         + sizeof(FONTDATAHEADER) + sizeof(FONTDATATABLE)*FONTDATATABLENUM;
    fileHeader.nTable = FONTDATATABLENUM;


    pTmpBuf = (int *)LocalAlloc(LPTR, Count*sizeof(int));

    if (!pTmpBuf)
         goto SAVE_FONT_DATA_DONE;

    // Get font index data
    for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
    {
        *pTmpBuf++ = g_urange_table[i].nFonts;

        if (g_urange_table[i].nFonts)
        {
            for (j = 0; j< g_urange_table[i].nFonts; j++)
            {
                *pTmpBuf++ = *(g_urange_table[i].pFontIndex+j);
            }
        }
    }

    pTmpBuf -= Count;

    // Create Dir tables
    lstrcpyA(fontInfoTable.szName, "fnt");
    fontInfoTable.dwOffset = sizeof(FONTDATAHEADER) + sizeof(FONTDATATABLE)*FONTDATATABLENUM;
    fontInfoTable.dwSize = sizeof(FONTINFO)*(g_pfont_table[0].dwCodePages[0]+1);

    lstrcpyA(fontIndexTable.szName, "idx");
    fontIndexTable.dwOffset = fontInfoTable.dwSize+fontInfoTable.dwOffset;
    fontIndexTable.dwSize = Count*sizeof(int);

    if (WriteFile(hFile, &fileHeader, sizeof(FONTDATAHEADER), &dwSize, NULL) &&
        WriteFile(hFile, &fontInfoTable, sizeof(FONTDATATABLE), &dwSize, NULL) &&
        WriteFile(hFile, &fontIndexTable, sizeof(FONTDATATABLE), &dwSize, NULL) &&
        WriteFile(hFile, g_pfont_table, fontInfoTable.dwSize, &dwSize, NULL) &&
        WriteFile(hFile, pTmpBuf, fontIndexTable.dwSize, &dwSize, NULL))
    {
        hr = S_OK;
    }

SAVE_FONT_DATA_DONE:
    if (hFile)
        CloseHandle(hFile);
    if (pTmpBuf)
        LocalFree(pTmpBuf);

    return hr;
}

HRESULT CMLFLink2::CFontMappingCache2::LoadFontDataFile(void)
{
    HANDLE  hFontData = NULL;
    HANDLE  hFileMap = NULL;
    LPVOID  lpvFile = NULL;
    int *   lp;
    HRESULT hr = E_FAIL;
    DWORD   dwFileSize;

    int     i, j;
    HKEY    hKey = NULL;
    DWORD   nFonts;
    FONTDATAHEADER *pHeader;
    FONTDATATABLE *pfTable;


    hFontData = CreateFile(szFontDataFilePath,  
                        GENERIC_READ,           
                        FILE_SHARE_READ,        
                        NULL,                   
                        OPEN_EXISTING,          
                        FILE_ATTRIBUTE_NORMAL,  
                        NULL);                  

    if (hFontData == INVALID_HANDLE_VALUE)
        return EnsureFontTable(TRUE);

    dwFileSize = GetFileSize(hFontData, NULL);

    hFileMap = CreateFileMapping(
                  hFontData,
                  NULL,
                  PAGE_READONLY,
                  0,
                  dwFileSize,
                  NULL
              );

    if(hFileMap == NULL)
    {
        goto Load_File_Done;
    }

    lpvFile = MapViewOfFile(
                  hFileMap,
                  FILE_MAP_READ,
                  0,
                  0,
                  0
              );

    if (lpvFile == NULL)
    {        
        goto Load_File_Done;
    }

    pHeader = (FONTDATAHEADER *)lpvFile;

    // Check mlang font cache file by signature and checksum
    if (lstrcmpA(pHeader->FileSig, FONT_DATA_SIGNATURE) || pHeader->dwCheckSum != dwFileSize)
    {
        goto Load_File_Done;
    }


    if (S_OK != GetRegFontKey(&hKey, &nFonts))
    {
        goto Load_File_Done;
    }

    pfTable = (FONTDATATABLE *) ((LPBYTE)lpvFile + sizeof(FONTDATAHEADER));

    // Check if there is any font change (no guarantee, but works in most cases)
    if (nFonts != ((FONTINFO*)((LPBYTE)lpvFile + pfTable[0].dwOffset))->dwCodePages[1])
    {
        // If there is a change in system font number, we reload everything
        UnmapViewOfFile(lpvFile);
        CloseHandle(hFileMap);
        CloseHandle(hFontData);
        RegCloseKey(hKey);
        return EnsureFontTable(TRUE);
    }

    EnterCriticalSection(&g_cs);
    // Reset cache information
    if (g_pfont_table)
    {
        
        LocalFree(g_pfont_table);
        g_pfont_table = NULL;
        for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
        {
            if (g_urange_table[i].nFonts)
            {
                LocalFree(g_urange_table[i].pFontIndex);
                g_urange_table[i].pFontIndex = NULL;
                g_urange_table[i].nFonts = 0;
            }
        }        
    }


    if(!(g_pfont_table = (FONTINFO *) (LocalAlloc(LPTR, pfTable[0].dwSize))))
    {
        hr = E_OUTOFMEMORY;
        goto Load_File_Done;
    }

    CopyMemory(g_pfont_table, (LPBYTE)lpvFile + pfTable[0].dwOffset, pfTable[0].dwSize);

    lp = (int *)((LPBYTE)lpvFile + pfTable[1].dwOffset);

    for (i = 0; i < ARRAYSIZE(g_urange_table); i++)
    {
        if (g_urange_table[i].nFonts = *lp++)
        {
            //g_urange_table[i].nFonts = *lp++;
            g_urange_table[i].pFontIndex = (int *)LocalAlloc(LPTR, sizeof(int)*g_urange_table[i].nFonts);
            for (j = 0; j<  g_urange_table[i].nFonts; j++)
            {
                g_urange_table[i].pFontIndex[j] = *lp++;
            }
        }
    }

    LeaveCriticalSection(&g_cs);

    hr = S_OK;

Load_File_Done:
    if (lpvFile)
        UnmapViewOfFile(lpvFile);
    if (hFileMap)
        CloseHandle(hFileMap);
    if (hFontData)
        CloseHandle(hFontData);
    if (hKey)
        RegCloseKey(hKey);

    return hr;

}


HRESULT CMLFLink2::CFontMappingCache2::SetFontUnicodeRanges(void)
{
    TCHAR   szFontPath[MAX_PATH];
    TCHAR   szFont[MAX_PATH];
    HRESULT hr = S_OK;
    int     i;
    

    EnterCriticalSection(&g_cs);
    g_pfont_table[0].szFaceName[0] = 1;
    LeaveCriticalSection(&g_cs);
    
    MLGetWindowsDirectory(szFontPath, MAX_PATH);
    MLPathCombine(szFontPath, szFontPath, FONT_FOLDER);

    for (i=1; i<= (int)g_pfont_table[0].dwCodePages[0]; i++)
    {
        MLPathCombine(szFont, szFontPath, g_pfont_table[i].szFileName);
        GetNonCpFontUnicodeRanges(szFont, i);
    }

    // Release un-used memory
    for (i=0; i< ARRAYSIZE(g_urange_table); i++)
    {
        if (g_urange_table[i].nFonts)
            g_urange_table[i].pFontIndex = (int *)LocalReAlloc(g_urange_table[i].pFontIndex, g_urange_table[i].nFonts*sizeof(int), LMEM_MOVEABLE);
    }

    return hr;
}

STDMETHODIMP CMLFLink2::GetStrCodePages(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pdwCodePages);
    ASSERT_WRITE_PTR_OR_NULL(pcchCodePages);

    HRESULT hr = S_OK;
    long cchCodePages = 0;
    DWORD dwStrCodePages = (DWORD)~0;
    BOOL fInit = FALSE;
    BOOL fNoPri = FALSE;

    if (!pszSrc || cchSrc <= 0) // We can't make dwStrCodePages when cchSrc is zero
        hr = E_INVALIDARG;

    if (!m_pIMLFLnk)
        return E_OUTOFMEMORY;

    while (SUCCEEDED(hr) && cchSrc > 0)
    {
        DWORD dwCharCodePages;

        if (SUCCEEDED(hr = m_pIMLFLnk->GetCharCodePages(*pszSrc, &dwCharCodePages)))
        {
            if (!fInit)
            {
                fInit = TRUE;
                fNoPri = !(dwPriorityCodePages & dwCharCodePages);
            }
            else if (fNoPri != !(dwPriorityCodePages & dwCharCodePages))
            {
                break;
            }
            if (!fNoPri)
                dwPriorityCodePages &= dwCharCodePages;

            if (dwCharCodePages && (dwCharCodePages & dwStrCodePages))
                dwStrCodePages &= dwCharCodePages;
            else
                break;

            pszSrc++;
            cchSrc--;
            cchCodePages++;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!cchCodePages)
        {
            dwStrCodePages = 0;
            cchCodePages++;
        }
        if (pcchCodePages)
            *pcchCodePages = cchCodePages;
        if (pdwCodePages)
            *pdwCodePages = dwStrCodePages;
    }
    else
    {
        if (pcchCodePages)
            *pcchCodePages = 0;
        if (pdwCodePages)
            *pdwCodePages = 0;
    }

    return hr;
}

STDMETHODIMP CMLFLink2::MapFont(HDC hDC, DWORD dwCodePages, WCHAR wchar, HFONT* phDestFont)
{
    HFONT hSrcFont = NULL;

    if (NULL == (hSrcFont = (HFONT) GetCurrentObject(hDC, OBJ_FONT)))
        return E_FAIL;

    if (dwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->MapFont(hDC, dwCodePages, hSrcFont, phDestFont);
        return E_OUTOFMEMORY;
    }
    else
    {
        if (!m_pFontMappingCache2)
            m_pFontMappingCache2 = new CFontMappingCache2;
        if (m_pFontMappingCache2)
            return m_pFontMappingCache2->MapFontFromCMAP(hDC, wchar, hSrcFont, phDestFont);
        else
            return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CMLFLink2::GetFontUnicodeRanges(HDC hDC, UINT *puiRanges, UNICODERANGE* pURanges)
{
    int     i;
    LOGFONT lf;
    HRESULT hr = E_FAIL;
    HFONT   hFont = NULL;

    if (!puiRanges)
        return E_INVALIDARG;

    if (!m_pFontMappingCache2)
        m_pFontMappingCache2 = new CFontMappingCache2;
    if (!m_pFontMappingCache2)
        return E_OUTOFMEMORY;

    if (!(hFont = (HFONT)GetCurrentObject(hDC, OBJ_FONT)))
        return hr;

    if (FAILED(m_pFontMappingCache2->EnsureFontTable(FALSE)))
        return hr;

    if (!GetObject(hFont, sizeof(LOGFONT), &lf))
        return hr;

    for (i=1; i<= (int) g_pfont_table[0].dwCodePages[0]; i++)
    {
        if (!lstrcmp(lf.lfFaceName, g_pfont_table[i].szFaceName))
            break;
    }

    if (i > (int) g_pfont_table[0].dwCodePages[0])
        return hr;

    return m_pFontMappingCache2->UnicodeRanges(g_pfont_table[i].szFileName, puiRanges, pURanges);

}

STDMETHODIMP CMLFLink2::GetScriptFontInfo(SCRIPT_ID sid, DWORD dwFlags, UINT *puiFonts, SCRIPTFONTINFO* pScriptFont)
{
    HRESULT hr = E_FAIL;
    UINT    uiNum;
    BYTE    bPitch = dwFlags & SCRIPTCONTF_FIXED_FONT? FIXED_PITCH:VARIABLE_PITCH;


    if (!m_pFontMappingCache2)
        m_pFontMappingCache2 = new CFontMappingCache2;

    if (m_pFontMappingCache2)
        m_pFontMappingCache2->EnsureFontTable(FALSE);

    if (!g_pfont_table)
        return hr;


    if (!pScriptFont)
    {
        uiNum = g_pfont_table[0].dwCodePages[0];
    }
    else
    {
        uiNum = *puiFonts;    
    }

    *puiFonts = 0;

    // Binary search font table to match script id.
    for (UINT i=1; i<= g_pfont_table[0].dwCodePages[0]; i++)
    {
        // Check font pitch
        if (!(g_pfont_table[i].lf.lfPitchAndFamily & bPitch))
            continue;

        // Get sid bit mask
        SCRIPT_IDS sids = 1;
        sids <<= sid;

        if (sids & g_pfont_table[i].scripts)
        {
            // Bail out is required number reached
            if (*puiFonts >= uiNum)
            {
                break;
            }
            if (pScriptFont)
            {
                MultiByteToWideChar(CP_ACP, 0, g_pfont_table[i].szFaceName, -1, (pScriptFont + *puiFonts)->wszFont, MAX_MIMEFACE_NAME);
                (pScriptFont + *puiFonts)->scripts = g_pfont_table[i].scripts;
            }
            (*puiFonts)++;
        }
    }

    return S_OK;

}

// Map Windows code page to script id 
// if multiple script id exist, we'll return the default one
STDMETHODIMP CMLFLink2::CodePageToScriptID(UINT uiCodePage, SCRIPT_ID *pSid)
{
    MIMECPINFO  cpInfo;
    HRESULT     hr = E_FAIL;

    if (!pSid)
        return E_INVALIDARG;

    if (NULL != g_pMimeDatabase)
    {
        if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo)))
        {
            if (cpInfo.uiFamilyCodePage == CP_USER_DEFINED)
            {
                *pSid = sidUserDefined;
                hr = S_OK; 
            }
            else
                for (int i = 0; g_CharSetTransTable[i].uCodePage; i++)
                {
                    if (cpInfo.uiFamilyCodePage == g_CharSetTransTable[i].uCodePage)
                    {
                        *pSid = g_CharSetTransTable[i].sid[0];
                        hr = S_OK;
                        break;
                    }
                }            
        }
    }

    return hr;
}
        
CMLFLink2::CFontMappingCache2::CFontMappingCache2(void)
{
    GetSystemDirectory(szFontDataFilePath, MAX_PATH);
    MLPathCombine(szFontDataFilePath, szFontDataFilePath, FONT_DATA_FILE_NAME);
}

CMLFLink2::CFontMappingCache2::~CFontMappingCache2(void)
{
    EnterCriticalSection(&g_cs);

    if (g_pfont_table)
    {
        LocalFree(g_pfont_table); 
        g_pfont_table = NULL;
    }

    for (int i=0; i< ARRAYSIZE(g_urange_table); i++)
    {
        if (g_urange_table[i].nFonts)
        {
            LocalFree(g_urange_table[i].pFontIndex);
            g_urange_table[i].nFonts = 0;
        }
    }

    LeaveCriticalSection(&g_cs);
}

int CALLBACK CMLFLink2::CFontMappingCache2::MapFontExEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC*, DWORD FontType, LPARAM lParam)
{  
    if (FontType == TRUETYPE_FONTTYPE && plfFont->lfFaceName[0] != TEXT('@') )
    {
        CopyMemory(&g_pfont_table[*(int *)lParam].lf, plfFont, sizeof(LOGFONT));
        (*(int *)lParam)++;
        return 0;
    }
    return 1;
}

int CALLBACK CMLFLink2::CFontMappingCache2::SetFontScriptsEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC*, DWORD FontType, LPARAM lParam)
{      
    if (FontType == TRUETYPE_FONTTYPE)
    {
        if (g_pfont_table)
        {
            for (int i=1; i<= (int)g_pfont_table[0].dwCodePages[0]; i++)
                if (!MLStrCmpNI(plfFont->lfFaceName, g_pfont_table[i].szFaceName, LF_FACESIZE))
                {
                    SCRIPT_IDS scripts = 1;
                    scripts <<= lParam;
                    g_pfont_table[i].scripts |= scripts;
                    break;
                }

            if (i > (int)g_pfont_table[0].dwCodePages[0] && plfFont->lfFaceName[0] != TEXT('@'))        // GDI font not in current font table?
            {
                FONTINFO * pfont_table = NULL;

                pfont_table = (FONTINFO *) LocalReAlloc(g_pfont_table, 
                                        sizeof(FONTINFO) * (g_pfont_table[0].dwCodePages[0]+2),
                                        LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (NULL != pfont_table)
                {
                    g_pfont_table = pfont_table;
                    g_pfont_table[0].dwCodePages[0]++;
                    MLStrCpyN(g_pfont_table[i].szFaceName, (char *)plfFont->lfFaceName, LF_FACESIZE);
                    CopyMemory(&g_pfont_table[i].lf, plfFont, sizeof(LOGFONT));

                    SCRIPT_IDS scripts = 1;
                    scripts <<= lParam;
                    g_pfont_table[i].scripts |= scripts;                    
                }
            }
        }
    }
    return 1;
}

int CALLBACK CMLFLink::VerifyFontSizeEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC* ptm, DWORD FontType, LPARAM lParam)
{
    LOGFONT* plfSrcFont = (LOGFONT*)lParam;

    if (FontType != TRUETYPE_FONTTYPE)
    {
        LONG lHeight = ptm->tmInternalLeading - ptm->tmHeight;
        // Match source font's lfHeight to physical bitmap font's lfHeight
        if (lHeight < 0 && plfSrcFont->lfHeight < 0 && lHeight < plfSrcFont->lfHeight)
        {
            plfSrcFont->lfHeight = lHeight ;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mllbcons.h ===
// MLLBCons.h : Declaration of the CMLLBCons

#ifndef __MLLBCONS_H_
#define __MLLBCONS_H_

#include "mlatl.h"

class CMultiLanguage;

/////////////////////////////////////////////////////////////////////////////
// CMLLBCons
class ATL_NO_VTABLE CMLLBCons :
    public CComTearOffObjectBase<CMultiLanguage>,
    public IMLangLineBreakConsole
{
public:
    CMLLBCons(void) 
    {
        DllAddRef();
        m_pMLStrClass = NULL;
    }
    ~CMLLBCons(void) 
    {
        if (m_pMLStrClass) 
            m_pMLStrClass->Release();
        DllRelease();    
    }

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLLBCons)
        COM_INTERFACE_ENTRY(IMLangLineBreakConsole)
    END_COM_MAP()

public:
// IMLangLineBreakConsole
    STDMETHOD(BreakLineML)(/*[in]*/ IMLangString* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long cMinColumns, /*[in]*/ long cMaxColumns, /*[out]*/ long* plLineLen, /*[out]*/ long* plSkipLen);
    STDMETHOD(BreakLineW)(/*[in]*/ LCID locale, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ long cMaxColumns, /*[out]*/ long* pcchLine, /*[out]*/ long* pcchSkip);
    STDMETHOD(BreakLineA)(/*[in]*/ LCID locale, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ long cMaxColumns, /*[out]*/ long* pcchLine, /*[out]*/ long* pcchSkip);

protected:
    template <DWORD INFOTYPE, int CACHESIZE>
    class CCharType
    {
    public:
#ifdef ASTRIMPL
        inline CCharType(void);
#else
        inline CCharType(LCID locale);
#endif
        inline ~CCharType(void);
        inline void Flush(void);
#ifdef ASTRIMPL
        WORD GetCharType(IMLangString* pMLStr, long lPos, long lLen, HRESULT* phr = NULL);
#else
        WORD GetCharType(LPCWSTR psz, int cch);
#endif

    protected:
        LPWORD m_pwBuf;
#ifdef ASTRIMPL
        IMLangStringAStr* m_pMLStrAStr;
        long m_lPos;
        long m_lLen;
#else
        LPSTR m_pszConv;
        LPCWSTR m_psz;
        int m_cch;
        LCID m_locale;
        UINT m_uCodePage;
#endif
        WORD m_wHalfWidth;
    };

    HRESULT PrepareMLStrClass(void)
    {
        if (m_pMLStrClass)
            return S_OK;
        else
            return ::_Module.GetClassObject(CLSID_CMLangString, IID_IClassFactory, (void**)&m_pMLStrClass);
    }

    IClassFactory* m_pMLStrClass;
};

template <DWORD INFOTYPE, int CACHESIZE>
#ifdef ASTRIMPL
CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::CCharType(void)
#else
CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::CCharType(LCID locale)
#endif
{
#ifndef ASTRIMPL
    TCHAR szCodePage[8];
#endif

    m_pwBuf = NULL;
#ifdef ASTRIMPL
    m_pMLStrAStr = NULL;

    // TODO: Set m_wHaldWidth here.
    m_wHalfWidth = 0;
#else
    m_pszConv = NULL;
    m_locale = locale;
    ::GetLocaleInfo(m_locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage));
    m_uCodePage = _ttoi(szCodePage);

    CPINFO cpi;
    ::GetCPInfo(m_uCodePage, &cpi);
    m_wHalfWidth = (cpi.LeadByte[0]) ? 0 : C3_HALFWIDTH;
#endif
}

template <DWORD INFOTYPE, int CACHESIZE>
CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::~CCharType(void)
{
    if (m_pwBuf)
        delete[] m_pwBuf;
#ifdef ASTRIMPL
    if (m_pMLStrAStr)
        m_pMLStrAStr->Release();
#else
    if (m_pszConv)
        delete[] m_pszConv;
#endif
}

template <DWORD INFOTYPE, int CACHESIZE>
void CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::Flush(void)
{
#ifdef ASTRIMPL
    m_lPos = 0;
    m_lLen = 0;
#else
    m_psz = NULL;
    m_cch = 0;
#endif
}

template <DWORD INFOTYPE, int CACHESIZE>
#ifdef ASTRIMPL
WORD CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::GetCharType(IMLangString* pMLStr, long lPos, long lLen, HRESULT* phr)
#else
WORD CMLLBCons::CCharType<INFOTYPE, CACHESIZE>::GetCharType(LPCWSTR psz, int cch)
#endif
{
#ifdef ASTRIMPL
    if (lPos >= m_lPos + m_lLen || lPos + lLen <= m_lPos)
#else
    if (psz < m_psz || psz >= m_psz + m_cch)
#endif
    {
#ifdef ASTRIMPL
        HRESULT hr;
#endif
        LPWORD pwCharType;
#ifdef ASTRIMPL
        WORD wCharType;
        CHAR* psz;
        long cch;
        LCID locale;
        UINT uCodePage;

        if (m_pMLStrAStr)
        {
            m_pMLStrAStr->Release();
            m_pMLStrAStr = NULL;
        }

        if (SUCCEEDED(hr = pMLStr->QueryInterface(IID_IMLangStringAStr, (void**)&m_pMLStrAStr)))
        {
            if (!m_pwBuf)
                m_pwBuf = new WORD[CACHESIZE];

            if (m_pwBuf)
            {
                pwCharType = m_pwBuf;
                cch = CACHESIZE;
            }
            else
            {
                pwCharType = &wCharType;
                cch = 1;
            }

            lLen = min(lLen, cch);

            if (SUCCEEDED(hr = m_pMLStrAStr->GetLocale(lPos, lLen, &locale, NULL, &lLen)) &&
                SUCCEEDED(hr = ::LocaleToCodePage(locale, &uCodePage)) &&
                SUCCEEDED(hr = m_pMLStrAStr->LockAStr(lPos, lLen, MLSTR_READ, uCodePage, 0, NULL, &psz, &cch, NULL)))
            {
                if (!::GetStringTypeExA(locale, INFOTYPE, psz, cch, pwCharType))
                    hr = E_FAIL; // NLS failed

                ASSIGN_IF_FAILED(hr, m_pMLStrAStr->UnlockAStr(psz, 0, NULL, NULL));
            }
        }

        if (phr)
            *phr = hr;

        if (SUCCEEDED(hr))
        {
            m_lPos = lPos;
            m_lLen = lLen;
            return pwCharType[0] | m_wHalfWidth;
        }
        else
        {
            m_lPos = 0;
            m_lLen = 0;
            return 0 | m_wHalfWidth;
        }
#else
        LPSTR pszConv;
        WORD wCharType = 0;
        CHAR szTemp[2];

        if (!m_pwBuf)
            m_pwBuf = new WORD[CACHESIZE];

        if (m_pwBuf)
        {
            pwCharType = m_pwBuf;
            cch = min(cch, CACHESIZE);
        }
        else
        {
            pwCharType = &wCharType;
            cch = 1;
        }

        if (!m_pszConv)
            m_pszConv = new CHAR[CACHESIZE * 2];

        if (m_pszConv)
        {
            pszConv = m_pszConv;
        }
        else
        {
            pszConv = szTemp;
            cch = 1;
        }

        if (m_pwBuf && m_pszConv)
        {
            m_psz = psz;
            m_cch = cch;
        }

        int cchTemp = ::WideCharToMultiByte(m_uCodePage, 0, psz, cch, pszConv, CACHESIZE * 2, NULL, NULL);
        ::GetStringTypeExA(m_locale, INFOTYPE, pszConv, cchTemp, pwCharType);

        return pwCharType[0] | m_wHalfWidth;
#endif
    }
    else
    {
#ifdef ASTRIMPL
        return m_pwBuf[lPos - m_lPos] | m_wHalfWidth;
#else
        return m_pwBuf[psz - m_psz] | m_wHalfWidth;
#endif
    }
}

#endif //__MLLBCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlmain.h ===
// MLMain.h : Declaration of the CMultiLanguage

#ifndef __MLMAIN_H_
#define __MLMAIN_H_

#include "mlflink.h"
#include "mllbcons.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiLanguage


class ATL_NO_VTABLE CMultiLanguage : 
    public CComObjectRoot,
    public CComCoClass<CMultiLanguage, &CLSID_CMultiLanguage>,
    public IMultiLanguage
{
    MIMECONTF       dwMimeSource;
    CMimeDatabase   *m_pMimeDatabase;

public:
    CMultiLanguage(void) 
    {
        DllAddRef();
        m_pMimeDatabase = new CMimeDatabase;
        dwMimeSource = MIMECONTF_MIME_IE4;
        if (m_pMimeDatabase)
            m_pMimeDatabase->SetMimeDBSource(MIMECONTF_MIME_IE4);
    }
    ~CMultiLanguage(void)
    {    
        if (m_pMimeDatabase)
            delete m_pMimeDatabase;
        DllRelease();
    }

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMultiLanguage)
        COM_INTERFACE_ENTRY(IMultiLanguage)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangCodePages, CMLFLink)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangFontLink, CMLFLink)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangFontLink2, CMLFLink2)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMultiLanguage2, CMultiLanguage2)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangLineBreakConsole, CMLLBCons)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMultiLanguage3, CMultiLanguage2)
    END_COM_MAP()

public:
// IMultiLanguage
    virtual STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    virtual STDMETHODIMP GetCodePageInfo(UINT uiCodePage, PMIMECPINFO pcpInfo);
    virtual STDMETHODIMP GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage);
    virtual STDMETHODIMP EnumCodePages(DWORD grfFlags, IEnumCodePage **ppEnumCodePage);
    virtual STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    virtual STDMETHODIMP IsConvertible(DWORD dwSrcEncoding, DWORD dwDstEncoding);
    virtual STDMETHODIMP ConvertString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize);
    virtual STDMETHODIMP ConvertStringToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize);
    virtual STDMETHODIMP ConvertStringFromUnicode(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize);
    virtual STDMETHODIMP ConvertStringReset(void);
    virtual STDMETHODIMP GetRfc1766FromLcid(LCID Locale, BSTR *pbstrRfc1766);
    virtual STDMETHODIMP GetLcidFromRfc1766(PLCID pLocale, BSTR bstrRfc1766);
    virtual STDMETHODIMP EnumRfc1766(IEnumRfc1766 **ppEnumRfc1766);
    virtual STDMETHODIMP GetRfc1766Info(LCID Locale, PRFC1766INFO pRfc1766Info);
    virtual STDMETHODIMP CreateConvertCharset(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty, IMLangConvertCharset **ppMLangConvertCharset);

};

class ATL_NO_VTABLE CMultiLanguage2 : 
    public CComTearOffObjectBase<CMultiLanguage>,
    public IMultiLanguage3
{        
    IMultiLanguage  * m_pIML;
    MIMECONTF       dwMimeSource;
    CMimeDatabase   * m_pMimeDatabase;


public:

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMultiLanguage2)
        COM_INTERFACE_ENTRY(IMultiLanguage2)
        COM_INTERFACE_ENTRY(IMultiLanguage3)
    END_COM_MAP()

    CMultiLanguage2(void);    
    ~CMultiLanguage2(void);

    virtual STDMETHODIMP GetNumberOfCodePageInfo(UINT *pcCodePage);
    virtual STDMETHODIMP GetCodePageInfo(UINT uiCodePage, LANGID LangId, PMIMECPINFO pcpInfo);
    virtual STDMETHODIMP GetFamilyCodePage(UINT uiCodePage, UINT *puiFamilyCodePage);
    virtual STDMETHODIMP EnumCodePages(DWORD grfFlags, LANGID LangId, IEnumCodePage **ppEnumCodePage);
    virtual STDMETHODIMP GetCharsetInfo(BSTR Charset, PMIMECSETINFO pcsetInfo);
    virtual STDMETHODIMP IsConvertible(DWORD dwSrcEncoding, DWORD dwDstEncoding)
    {
        if (m_pIML)
            return m_pIML->IsConvertible(dwSrcEncoding, dwDstEncoding);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize)
    {
        if (m_pIML)
            return m_pIML->ConvertString(lpdwMode, dwSrcEncoding, dwDstEncoding, pSrcStr, pcSrcSize, pDstStr, pcDstSize);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertStringToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize)
    {
        if (m_pIML)
            return m_pIML->ConvertStringToUnicode(lpdwMode, dwEncoding, pSrcStr, pcSrcSize, pDstStr, pcDstSize);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertStringFromUnicode(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize)
    {
        if (m_pIML)
            return m_pIML->ConvertStringFromUnicode(lpdwMode, dwEncoding, pSrcStr, pcSrcSize, pDstStr, pcDstSize);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP ConvertStringReset(void)
    {
        if (m_pIML)
            return m_pIML->ConvertStringReset();
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP GetRfc1766FromLcid(LCID Locale, BSTR *pbstrRfc1766)
    {
        if (m_pIML)
            return m_pIML->GetRfc1766FromLcid(Locale, pbstrRfc1766);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP GetLcidFromRfc1766(PLCID pLocale, BSTR bstrRfc1766)
    {
        if (m_pIML)
            return m_pIML->GetLcidFromRfc1766(pLocale, bstrRfc1766);
        else
            return E_FAIL;
    }
    virtual STDMETHODIMP EnumRfc1766(LANGID LangId, IEnumRfc1766 **ppEnumRfc1766);
    virtual STDMETHODIMP GetRfc1766Info(LCID Locale, LANGID LangId, PRFC1766INFO pRfc1766Info);
    virtual STDMETHODIMP CreateConvertCharset(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty, IMLangConvertCharset **ppMLangConvertCharset)
    {
        if (m_pIML)
            return m_pIML->CreateConvertCharset(uiSrcCodePage, uiDstCodePage, dwProperty, ppMLangConvertCharset);
        else
            return E_FAIL;
    }

    virtual STDMETHODIMP ConvertStringInIStream(LPDWORD lpdwMode, DWORD dwFlag, WCHAR *lpFallBack, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut);
    virtual STDMETHODIMP ConvertStringToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag=0, WCHAR *lpFallBack = NULL);
    virtual STDMETHODIMP ConvertStringFromUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize, DWORD dwFlag=0, WCHAR *lpFallBack = NULL);
    virtual STDMETHODIMP DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScores);
    virtual STDMETHODIMP DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScores);

    virtual STDMETHODIMP ValidateCodePage(UINT uiCodePage, HWND hwnd);
    virtual STDMETHODIMP GetCodePageDescription(UINT uiCodePage, LCID lcid, LPWSTR lpWideCharStr,  int cchWideChar);
    virtual STDMETHODIMP IsCodePageInstallable(UINT uiCodePage);
    virtual STDMETHODIMP SetMimeDBSource(MIMECONTF dwSource);
    virtual STDMETHODIMP GetNumberOfScripts(UINT *pnScripts);
    virtual STDMETHODIMP EnumScripts(DWORD dwFlags, LANGID LangId, IEnumScript **ppEnumScript);
    
    virtual STDMETHODIMP ValidateCodePageEx(UINT uiCodePage, HWND hwnd, DWORD dwfIODControl);
    virtual STDMETHODIMP DetectOutboundCodePage(DWORD dwFlags, LPCWSTR lpWideCharStr, UINT cchWideChar, UINT* puiPreferredCodePages, UINT nPreferredCodePages, UINT* puiDetectedCodePages, UINT* pnDetectedCodePages, WCHAR* lpSpecialChar);
    virtual STDMETHODIMP DetectOutboundCodePageInIStream(DWORD dwFlags, IStream* pStrIn, UINT* puiPreferredCodePages, UINT nPreferredCodePages, UINT* puiDetectedCodePages, UINT* pnDetectedCodePages, WCHAR* lpSpecialChar);
protected:
    HRESULT EnsureIEStatus(void);
    class CIEStatus
    {
    public:
        CIEStatus(void) { _IEFlags.fJITDisabled = FALSE;}
        HRESULT Init(void);
        BOOL IsJITEnabled(void) 
        { 
            return !_IEFlags.fJITDisabled;
        }
    protected:
        struct {
            BOOL fJITDisabled:1;
        } _IEFlags;
    };
    CIEStatus *m_pIEStat;
};

#endif //__MLMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlflink.h ===
// MLFLink.h : Declaration of the CMLFLink

#ifndef __MLFLINK_H_
#define __MLFLINK_H_

#include "mlatl.h"
#include "font.h"

#define NUMFONTMAPENTRIES 15

// Error Code
#define FACILITY_MLSTR                  0x0A15
#define MLSTR_E_FACEMAPPINGFAILURE      MAKE_HRESULT(1, FACILITY_MLSTR, 1001)


extern FONTINFO *g_pfont_table;


class CMultiLanguage;
class CMultiLanguage2;

// Code Page Table Cache
struct CCodePagesHeader
{
        DWORD m_dwID;
        DWORD m_dwVersion;
        DWORD m_dwFileSize;
        DWORD m_dwBlockSize;
        DWORD m_dwTableOffset;
        DWORD m_dwReserved;
        BYTE m_abCmdCode[8];
};

/////////////////////////////////////////////////////////////////////////////
// CMLFLink
class ATL_NO_VTABLE CMLFLink : 
    public CComTearOffObjectBase<CMultiLanguage>,
    public IMLangFontLink
{
    friend void CMLangFontLink_FreeGlobalObjects(void);
    friend HRESULT GetCharCodePagesEx(WCHAR chSrc, DWORD* pdwCodePages, DWORD dwFlags);
    friend HRESULT GetStrCodePagesEx(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages, DWORD dwFlags);
    friend HRESULT CodePageToCodePagesEx(UINT uCodePage, DWORD* pdwCodePages, DWORD* pdwCodePagesExt);
    friend HRESULT CodePagesToCodePageEx(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage, BOOL bCodePagesExt);

public:
    CMLFLink(void);
    ~CMLFLink(void)
    {
        if (m_pFlinkTable)
            FreeFlinkTable();
        DllRelease();    
    }

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLFLink)
        COM_INTERFACE_ENTRY(IMLangCodePages)
        COM_INTERFACE_ENTRY(IMLangFontLink)
    END_COM_MAP()

public:
// IMLangCodePages
    STDMETHOD(GetCharCodePages)(/*[in]*/ WCHAR chSrc, /*[out]*/ DWORD* pdwCodePages);
    STDMETHOD(GetStrCodePages)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ DWORD dwPriorityCodePages, /*[out]*/ DWORD* pdwCodePages, /*[out]*/ long* pcchCodePages);
    STDMETHOD(CodePageToCodePages)(/*[in]*/ UINT uCodePage, /*[out]*/ DWORD* pdwCodePages);
    STDMETHOD(CodePagesToCodePage)(/*[in]*/ DWORD dwCodePages, /*[in]*/ UINT uDefaultCodePage, /*[out]*/ UINT* puCodePage);
// IMLangFontLink
    STDMETHOD(GetFontCodePages)(/*[in]*/ HDC hDC, /*[in]*/ HFONT hFont, /*[out]*/ DWORD* pdwCodePages);
    STDMETHOD(MapFont)(/*[in]*/ HDC hDC, /*[in]*/ DWORD dwCodePages, /*[in]*/ HFONT hSrcFont, /*[out]*/ HFONT* phDestFont);
    STDMETHOD(ReleaseFont)(/*[in]*/ HFONT hFont);
    STDMETHOD(ResetFontMapping)(void);

protected:
    static int CALLBACK GetFontCodePagesEnumFontProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD dwFontType, LPARAM lParam);

// MapFont() support functions
    class CFontMappingInfo
    {
    public:
        CFontMappingInfo(void) : hDestFont(NULL) {}
        ~CFontMappingInfo(void) {if (hDestFont) ::DeleteObject(hDestFont);}

        HDC hDC;
        int iCP;
        HFONT hDestFont;
        TCHAR szFaceName[LF_FACESIZE];
        LOGFONT lfSrcFont;
        LOGFONT lfDestFont;
        UINT auCodePage[32 + 1]; // +1 for end mark
        DWORD adwCodePages[32 + 1];
    };

    typedef HRESULT (CMLFLink::*PFNGETFACENAME)(CFontMappingInfo& fmi);

    HRESULT MapFontCodePages(CFontMappingInfo& fmi, PFNGETFACENAME pfnGetFaceName);
    static int CALLBACK MapFontEnumFontProc(const LOGFONT* lplf, const TEXTMETRIC*, DWORD, LPARAM lParam);
    HRESULT GetFaceNameRegistry(CFontMappingInfo& fmi);
    HRESULT GetFaceNameGDI(CFontMappingInfo& fmi);
    HRESULT GetFaceNameMIME(CFontMappingInfo& fmi);
    HRESULT GetFaceNameRealizeFont(CFontMappingInfo& fmi);
    HRESULT VerifyFaceMap(CFontMappingInfo& fmi);

// Font Mapping Cache
    class CFontMappingCache
    {
        class CFontMappingCacheEntry
        {
            friend class CFontMappingCache;

        protected:
            CFontMappingCacheEntry* m_pPrev;
            CFontMappingCacheEntry* m_pNext;

            int m_nLockCount;

            UINT m_uSrcCodePage;
            LONG m_lSrcHeight; 
            LONG m_lSrcWidth; 
            LONG m_lSrcEscapement; 
            LONG m_lSrcOrientation; 
            LONG m_lSrcWeight; 
            BYTE m_bSrcItalic; 
            BYTE m_bSrcUnderline; 
            BYTE m_bSrcStrikeOut; 
            BYTE m_bSrcPitchAndFamily; 
            TCHAR m_szSrcFaceName[LF_FACESIZE]; 

            HFONT m_hDestFont;
        };

    public:
        CFontMappingCache(void);
        ~CFontMappingCache(void);
        HRESULT FindEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT* phDestFont);
        HRESULT UnlockEntry(HFONT hDestFont);
        HRESULT AddEntry(UINT uCodePage, const LOGFONT& lfSrcFont, HFONT hDestFont);
        HRESULT FlushEntries(void);

    protected:
        CRITICAL_SECTION m_cs;
        CFontMappingCacheEntry* m_pEntries;
        CFontMappingCacheEntry* m_pFree;
        int m_cEntries;
    };

// Code Page Table Cache
    class CCodePagesCache
    {
    public:
        CCodePagesCache(void);
        ~CCodePagesCache(void);
        inline HRESULT Load(void);
        inline operator PBYTE(void) const;
        inline BYTE* GetCodePageBits(BOOL bCodePagesExt);

    protected:
        HRESULT RealLoad(void);

    protected:
        CRITICAL_SECTION m_cs;
        BYTE* m_pbBuf;
        BYTE* m_pbBufExt;
    };

    static CFontMappingCache* m_pFontMappingCache;
    static CCodePagesCache* m_pCodePagesCache;

    // For NT5 system font link
    typedef struct tagFLinkFont {    
        WCHAR   szFaceName[LF_FACESIZE];
        LPWSTR  pmszFaceName;
    } FLINKFONT, *PFLINKFONT;
    
    UINT m_uiFLinkFontNum;
    PFLINKFONT m_pFlinkTable;

    void FreeFlinkTable(void);
    HRESULT CreateNT5FontLinkTable(void);
    HRESULT GetNT5FLinkFontCodePages(HDC hDC, LOGFONTW* plfEnum, DWORD * lpdwCodePages);
    static int CALLBACK GetFontCodePagesEnumFontProcW(const LOGFONTW *lplf, const TEXTMETRICW *lptm, DWORD dwFontType, LPARAM lParam);
    static int CALLBACK VerifyFontSizeEnumFontProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD dwFontType, LPARAM lParam);
};

class CMultiLanguage2;

class ATL_NO_VTABLE CMLFLink2 :
#ifdef UNIX // Unix VTable isn't portable, we need to use CMultiLanguage 
    public CComTearOffObjectBase<CMultiLanguage>,
#else 
    public CComTearOffObjectBase<CMultiLanguage2>,
#endif
    public IMLangFontLink2
{
    IMLangFontLink * m_pIMLFLnk;

public:
    BEGIN_COM_MAP(CMLFLink2)
        COM_INTERFACE_ENTRY(IMLangFontLink2)
    END_COM_MAP()

    CMLFLink2(void)
    {
        DllAddRef();
        CComCreator< CComPolyObject< CMLFLink > >::CreateInstance( NULL, IID_IMLangFontLink, (void **)&m_pIMLFLnk );
    }

    ~CMLFLink2(void)
    {
        if (m_pIMLFLnk)
        {
            m_pIMLFLnk->Release();
            m_pIMLFLnk = NULL;
        }
        DllRelease();
    }

// IMLangCodePages
    STDMETHOD(GetCharCodePages)(/*[in]*/ WCHAR chSrc, /*[out]*/ DWORD* pdwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->GetCharCodePages(chSrc, pdwCodePages);
        else
            return E_FAIL;
    }
    STDMETHOD(CodePageToCodePages)(/*[in]*/ UINT uCodePage, /*[out]*/ DWORD* pdwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->CodePageToCodePages(uCodePage, pdwCodePages);
        else
            return E_FAIL;
    }
    STDMETHOD(CodePagesToCodePage)(/*[in]*/ DWORD dwCodePages, /*[in]*/ UINT uDefaultCodePage, /*[out]*/ UINT* puCodePage)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->CodePagesToCodePage(dwCodePages, uDefaultCodePage, puCodePage);
        else
            return E_FAIL;
    }
// IMLangFontLink
    STDMETHOD(GetFontCodePages)(/*[in]*/ HDC hDC, /*[in]*/ HFONT hFont, /*[out]*/ DWORD* pdwCodePages)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->GetFontCodePages(hDC, hFont, pdwCodePages);
        else
            return E_FAIL;
    }

    STDMETHOD(ReleaseFont)(/*[in]*/ HFONT hFont)
    {
        if (m_pIMLFLnk)
            return m_pIMLFLnk->ReleaseFont(hFont);
        else
            return E_FAIL;
    }

// IMLangFontLink2
    STDMETHOD(ResetFontMapping)(void);
    STDMETHOD(GetStrCodePages)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[in]*/ DWORD dwPriorityCodePages, /*[out]*/ DWORD* pdwCodePages, /*[out]*/ long* pcchCodePages);
    STDMETHOD(MapFont)(/*[in]*/ HDC hDC, /*[in]*/ DWORD dwCodePages, /*[in]*/ WCHAR chSrc, /*[out]*/ HFONT* pFont);
    STDMETHOD(GetFontUnicodeRanges)(/*[in]*/ HDC hDC, /*[in,out]*/ UINT *puiRanges, /*[out]*/ UNICODERANGE* pUranges);
    STDMETHOD(GetScriptFontInfo)(SCRIPT_ID sid, DWORD dwFlags, UINT *puiFonts, SCRIPTFONTINFO* pScriptFont);
    STDMETHOD(CodePageToScriptID)(UINT uiCodePage, SCRIPT_ID *pSid);

// Font Mapping Cache2 for MapFont
    class CFontMappingCache2
    {
    protected:
        TCHAR   szFontDataFilePath[MAX_PATH];
    public:
        CFontMappingCache2(void);
        ~CFontMappingCache2(void);
        int fetchCharSet(BYTE *pCharset, int iURange);
        BOOL GetNonCpFontUnicodeRanges(TCHAR *szFontName, int iFontIndex);
        BOOL SetFontScripts(void);
        BOOL SetFontTable(void);
        BOOL GetFontURangeBits(TCHAR *szFontName, DWORD *pdwURange);
        BOOL IsFontUpdated(void);
        HRESULT UnicodeRanges(LPTSTR pszFont, UINT *puiRanges, UNICODERANGE* pURanges);
        HRESULT SetFontUnicodeRanges(void);
        HRESULT MapFontFromCMAP(HDC hDC, WCHAR wchar, HFONT hSrcFont, HFONT *phDestFont);
        HRESULT LoadFontDataFile(void);
        HRESULT SaveFontDataFile(void);
        HRESULT EnsureFontTable(BOOL bUpdateURangeTable);
        static int CALLBACK MapFontExEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam);
        static int CALLBACK SetFontScriptsEnumFontProc(const LOGFONT* plfFont, const TEXTMETRIC* lptm, DWORD FontType, LPARAM lParam);
    };

    static CFontMappingCache2* m_pFontMappingCache2;
};

/////////////////////////////////////////////////////////////////////////////
// CMLFLink inline functions

HRESULT CMLFLink::CCodePagesCache::Load(void)
{
    if (m_pbBuf && m_pbBufExt)
        return S_OK;
    else
        return RealLoad();
}

BYTE * CMLFLink::CCodePagesCache::GetCodePageBits(BOOL bCodePagesExt)
{
    if (bCodePagesExt)
        return m_pbBufExt;
    else
        return m_pbBuf;
}

CMLFLink::CCodePagesCache::operator PBYTE(void) const
{
    return m_pbBuf;
}

#endif //__MLFLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlsbwalk.h ===
// MLSBWalk.h : Declaration of the CMLStrBufWalk

#ifndef __MLSBWALK_H_
#define __MLSBWALK_H_

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufWalk
template <class IMLSTRBUF, class CHTYPE>
class CMLStrBufWalk
{
public:
    inline CMLStrBufWalk(IMLSTRBUF* pMLStrBuf, long cchOffset, long cchLen, BOOL fCanStopAtMiddle = FALSE);
    BOOL Lock(HRESULT& rhr);
    void Unlock(HRESULT& rhr, long cchActual = 0);
    inline CHTYPE* GetStr(void);
    inline long GetCCh(void) const;
    inline long GetDoneCCh(void) const;
    inline long GetRestCCh(void) const;

protected:
    IMLSTRBUF* m_pMLStrBuf;
    BOOL m_fCanStopAtMiddle;
    long m_cchOffset;
    long m_cchLen;
    long m_cchDone;
    CHTYPE* m_pszBuf;
    long m_cchBuf;
};

template <class IMLSTRBUF, class CHTYPE>
CMLStrBufWalk<IMLSTRBUF, CHTYPE>::CMLStrBufWalk(IMLSTRBUF* pMLStrBuf, long cchOffset, long cchLen, BOOL fCanStopAtMiddle) :
    m_pMLStrBuf(pMLStrBuf),
    m_fCanStopAtMiddle(fCanStopAtMiddle)
{
    m_cchOffset = cchOffset;
    m_cchLen = cchLen;
    m_cchDone = 0;

    m_pszBuf = NULL; // Mark as it's not locked
}

template <class IMLSTRBUF, class CHTYPE>
BOOL CMLStrBufWalk<IMLSTRBUF, CHTYPE>::Lock(HRESULT& rhr)
{
    if (m_pszBuf)
        rhr = E_FAIL; // Already locked

    if (SUCCEEDED(rhr) &&
        m_cchLen > 0 &&
        FAILED(rhr = m_pMLStrBuf->LockBuf(m_cchOffset, m_cchLen, &m_pszBuf, &m_cchBuf)))
    {
        m_pszBuf = NULL; // Mark as it's not locked
    }

    if (m_fCanStopAtMiddle && FAILED(rhr) && m_cchDone > 0)
    {
        rhr = S_OK;
        return FALSE; // Stop it, but not fail
    }
    else
    {
        return (SUCCEEDED(rhr) && m_cchLen > 0);
    }
}

template <class IMLSTRBUF, class CHTYPE>
void CMLStrBufWalk<IMLSTRBUF, CHTYPE>::Unlock(HRESULT& rhr, long cchActual)
{
    HRESULT hr = S_OK;

    if (!m_pszBuf)
        hr = E_FAIL; // Not locked yet

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = m_pMLStrBuf->UnlockBuf(m_pszBuf, 0, 0))) // Unlock even if rhr is already failed
    {
        if (!cchActual)
            cchActual = m_cchBuf;
        else
            ASSERT(cchActual > 0 && cchActual <= m_cchBuf);

        m_cchOffset += cchActual;
        m_cchLen -= cchActual;
        m_cchDone += cchActual;
    }

    m_pszBuf = NULL; // Unlock anyway

    if (SUCCEEDED(rhr))
        rhr = hr; // if rhr is failed before UnlockBuf, use it
}

template <class IMLSTRBUF, class CHTYPE>
CHTYPE* CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetStr(void)
{
    ASSERT(m_pszBuf); // Not locked
    return m_pszBuf;
}

template <class IMLSTRBUF, class CHTYPE>
long CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetCCh(void) const
{
    ASSERT(m_pszBuf); // Not locked
    if (m_pszBuf)
        return m_cchBuf;
    else
        return 0;
}

template <class IMLSTRBUF, class CHTYPE>
long CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetDoneCCh(void) const
{
    return m_cchDone;
}

template <class IMLSTRBUF, class CHTYPE>
long CMLStrBufWalk<IMLSTRBUF, CHTYPE>::GetRestCCh(void) const
{
    return m_cchLen - m_cchDone;
}

typedef CMLStrBufWalk<IMLangStringBufW, WCHAR> CMLStrBufWalkW;
typedef CMLStrBufWalk<IMLangStringBufA, CHAR>  CMLStrBufWalkA;

#endif //__MLSBWALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstr.cpp ===
// MLStr.cpp : Implementation of CMLStr
#include "private.h"

#ifndef NEWMLSTR

#include "mlstr.h"
#ifdef ASTRIMPL
#include "mlsbwalk.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLStr Helper functions

HRESULT RegularizePosLen(long lStrLen, long* plPos, long* plLen)
{
    ASSERT_WRITE_PTR(plPos);
    ASSERT_WRITE_PTR(plLen);

    long lPos = *plPos;
    long lLen = *plLen;

    if (lPos < 0)
        lPos = lStrLen;
    else
        lPos = min(lPos, lStrLen);

    if (lLen < 0)
        lLen = lStrLen - lPos;
    else
        lLen = min(lLen, lStrLen - lPos);

    *plPos = lPos;
    *plLen = lLen;

    return S_OK;
}

#ifdef ASTRIMPL
HRESULT LocaleToCodePage(LCID locale, UINT* puCodePage)
{
    HRESULT hr = S_OK;

    if (puCodePage)
    {
        TCHAR szCodePage[8];

        if (::GetLocaleInfo(locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage)) > 0)
            *puCodePage = _ttoi(szCodePage);
        else
            hr = E_FAIL; // NLS failed
    }

    return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLStr

CMLStr::CMLStr(void) :
    m_pMLStrBufW(NULL),
    m_pMLStrBufA(NULL),
    m_lBufFlags(0),
    m_cchBuf(0),
    m_locale(0),
#ifdef ASTRIMPL
    m_LockInfo(this)
#else
    m_lLockFlags(0)
#endif
{
    DllAddRef();
    m_dwThreadID = ::GetCurrentThreadId();
}

CMLStr::~CMLStr(void)
{
    if (m_pMLStrBufW)
        m_pMLStrBufW->Release();
    if (m_pMLStrBufA)
        m_pMLStrBufA->Release();
    DllRelease();
}

STDMETHODIMP CMLStr::Sync(BOOL)
{
    ASSERT_THIS;
    return S_OK; // No multithread supported; Always synchronized
}

STDMETHODIMP CMLStr::GetLength(long* plLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plLen);

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(FALSE, this, hr);
#endif
    long lLen;

    if (SUCCEEDED(hr))
        hr = GetLen(0, GetBufCCh(), &lLen);

    if (plLen)
    {
        if (SUCCEEDED(hr))
            *plLen = lLen;
        else
            *plLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStr::SetMLStr(long, long, IUnknown*, long, long)
{
    return E_NOTIMPL; // IMLangString::SetMLStr()
}

STDMETHODIMP CMLStr::GetMLStr(long, long, IUnknown*, DWORD, const IID*, IUnknown**, long*, long*)
{
    return E_NOTIMPL; // IMLangString::GetMLStr()
}

#ifndef ASTRIMPL
STDMETHODIMP CMLStr::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    return E_NOTIMPL; // !ASTRIMPL
}

STDMETHODIMP CMLStr::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    return SetStrBufCommon(NULL, lDestPos, lDestLen, 0, pSrcBuf, NULL, pcchActual, plActualLen);
}
#endif

HRESULT CMLStr::SetStrBufCommon(void* pMLStrX, long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufW* pSrcBufW, IMLangStringBufA* pSrcBufA, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_PTR_OR_NULL(pSrcBufW);
    ASSERT_READ_PTR_OR_NULL(pSrcBufA);
    ASSERT(!pSrcBufW || !pSrcBufA); // Either one or both should be NULL
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(TRUE, this, hr);
#endif
    long lBufFlags = 0; // '= 0' for in case of both of pSrcBufW and pSrcBufA are NULL
    long cchBuf = 0;
    long cchDestPos;
    long cchDestLen;
    long lActualLen = 0;

#ifndef ASTRIMPL
    if (SUCCEEDED(hr) && IsLocked())
        hr = E_INVALIDARG; // This MLStr is locked
#endif

    if (SUCCEEDED(hr) &&
        (!pSrcBufW || SUCCEEDED(hr = pSrcBufW->GetStatus(&lBufFlags, &cchBuf))) &&
        (!pSrcBufA || SUCCEEDED(hr = pSrcBufA->GetStatus(&lBufFlags, &cchBuf))) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        if (!cchDestPos && cchDestLen == GetBufCCh()) // Replacing entire string
        {
            IMLangStringBufW* const pOldBufW = GetMLStrBufW();
            IMLangStringBufA* const pOldBufA = GetMLStrBufA();

            if (pOldBufW)
                pOldBufW->Release();
            else if (pOldBufA)
                pOldBufA->Release();

            if (pSrcBufW)
                pSrcBufW->AddRef();
            else if (pSrcBufA)
                pSrcBufA->AddRef();

            SetMLStrBufW(pSrcBufW);
            SetMLStrBufA(pSrcBufA);
            SetCodePage(uCodePage);
            SetBufFlags(lBufFlags);
            SetBufCCh(cchBuf);

            if (plActualLen)
                hr = GetLen(0, GetBufCCh(), &lActualLen);
        }
        else
        {
#ifdef ASTRIMPL
            if (pSrcBufW)
            {
                CMLStrBufWalkW BufWalk(pSrcBufW, 0, cchBuf, (pcchActual || plActualLen));

                while (BufWalk.Lock(hr))
                {
                    long cchSet;
                    long lSetLen;

                    hr = ((IMLangStringWStr*)pMLStrX)->SetWStr(lDestPos, lDestLen, BufWalk.GetStr(), BufWalk.GetCCh(), &cchSet, (plActualLen) ? &lSetLen : NULL);
                    lActualLen += lSetLen;
                    BufWalk.Unlock(hr, cchSet);
                }

                cchBuf = BufWalk.GetDoneCCh();

                pSrcBufW->Release();
            }
            else if (pSrcBufA && pMLStrX)
            {
                CMLStrBufWalkA BufWalk(pSrcBufA, 0, cchBuf, (pcchActual || plActualLen));

                while (BufWalk.Lock(hr))
                {
                    long cchSet;
                    long lSetLen;

                    hr = ((IMLangStringAStr*)pMLStrX)->SetAStr(lDestPos, lDestLen, uCodePage, BufWalk.GetStr(), BufWalk.GetCCh(), &cchSet, (plActualLen) ? &lSetLen : NULL);
                    lActualLen += lSetLen;
                    BufWalk.Unlock(hr, cchSet);
                }

                cchBuf = BufWalk.GetDoneCCh();

                pSrcBufA->Release();
            }
            else
            {
                hr = SetMLStr(lDestPos, lDestLen, NULL, 0, 0);
            }
#else
            hr = E_INVALIDARG; // !ASTRIMPL
#endif
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchBuf;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

#ifndef ASTRIMPL
STDMETHODIMP CMLStr::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && IsLocked())
        hr = E_INVALIDARG; // This MLStr is locked

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        if (pszDest)
        {
            long cchActualTemp = min(cchSrcLen, cchDest);
            cchActual = cchActualTemp;

            while (SUCCEEDED(hr) && cchActualTemp > 0)
            {
                WCHAR* pszBuf;
                long cchBuf;

                if (m_pMLStrBufW)
                {
                    if (SUCCEEDED(hr = m_pMLStrBufW->LockBuf(cchSrcPos, cchActualTemp, &pszBuf, &cchBuf)))
                    {
                        ::memcpy(pszDest, pszBuf, sizeof(WCHAR) * cchBuf);
                        hr = m_pMLStrBufW->UnlockBuf(pszBuf, 0, 0);

                        cchSrcPos += cchBuf;
                        cchActualTemp -= cchBuf;
                        pszDest += cchBuf;
                    }
                }
                else // m_pMLStrBufW
                {
                    hr = E_FAIL;  // !ASTRIMPL
                }
            }

            if (FAILED(hr) && cchActualTemp < cchActual && (pcchActual || plActualLen))
            {
                cchActual -= cchActualTemp;
                hr = S_OK;
            }
        }
        else
        {
            cchActual = cchSrcLen;
        }
    }

    if (SUCCEEDED(hr) && plActualLen)
        hr = CalcLenW(0, cchActual, &lActualLen);

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStr::GetStrBufW(long, long, IMLangStringBufW**, long*)
{
    return E_NOTIMPL; // !ASTRIMPL
}

STDMETHODIMP CMLStr::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    HRESULT hr = CheckThread();
    long cchSrcPos;
    long cchSrcLen;
    WCHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;

    if (SUCCEEDED(hr) && (IsLocked() || !lFlags || (lFlags & ~GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // This MLStr is locked, no flags specified or not writable

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = PrepareMLStrBuf()) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
        SetDirectLockFlag(pMLStrBufW != 0);

        if (IsDirectLock())
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufW->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                SetBufCCh(GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufW->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

        }
        else if (m_pMLStrBufA)
        {
            long cchSize;

            if (SUCCEEDED(hr = CalcBufSizeW(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && (lFlags & MLSTR_READ))
                hr = ConvertMLStrBufAToWStr(m_uCodePage, m_pMLStrBufA, cchSrcPos, cchSrcLen, pszBuf, cchBuf, (pcchDest) ? &cchBuf : NULL);
        }
        else
        {
            hr = E_FAIL; // !ASTRIMPL
        }
    }

    if (plDestLen && SUCCEEDED(hr))
        hr = CalcLenW(pszBuf, cchBuf, &lLockLen);

    if (SUCCEEDED(hr))
    {
        SetLockFlags(lFlags);
        m_pszLockBuf = pszBuf;
        m_cchLockPos = cchSrcPos;
        m_cchLockLen = cchBuf;
        m_lLockPos = lSrcPos;
        m_lLockLen = lSrcLen;

        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (IsDirectLock())
                GetMLStrBufW()->UnlockBuf(pszBuf, 0, 0);
            else
                MemFree(pszBuf);
        }

        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}
#endif

#ifdef ASTRIMPL
HRESULT CMLStr::UnlockWStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr;
    IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
    const long cchLockLen = GetLockInfo()->GetCChLen(pKey);

    if (SUCCEEDED(hr = pMLStrBufW->UnlockBuf((WCHAR*)pszSrc, 0, cchSrc)) &&
        (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE))
    {
        if (cchSrc < cchLockLen)
        {
            if (SUCCEEDED(hr = pMLStrBufW->Delete(GetLockInfo()->GetCChPos(pKey) + cchSrc, cchLockLen - cchSrc)))
                SetBufCCh(GetBufCCh() - (cchLockLen - cchSrc));
        }

        if (SUCCEEDED(hr) && plActualLen)
            hr = CalcLenW((WCHAR*)pszSrc, cchSrc, plActualLen);

        if (pcchActual)
            *pcchActual = cchSrc;
    }

    return hr;
}

HRESULT CMLStr::UnlockWStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = S_OK;

    if (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE)
    {
        CComQIPtr<IMLangStringWStr, &IID_IMLangStringWStr> pMLStrW(this);
        ASSERT(pMLStrW);
        hr = pMLStrW->SetWStr(GetLockInfo()->GetPos(pKey), GetLockInfo()->GetLen(pKey), (WCHAR*)pszSrc, cchSrc, pcchActual, plActualLen);
    }

    ASSIGN_IF_FAILED(hr, MemFree((void*)pszSrc));

    return hr;
}

HRESULT CMLStr::UnlockAStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr;
    IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();
    const long cchLockLen = GetLockInfo()->GetCChLen(pKey);

    if (SUCCEEDED(hr = pMLStrBufA->UnlockBuf((CHAR*)pszSrc, 0, cchSrc)) &&
        (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE))
    {
        if (cchSrc < cchLockLen)
        {
            if (SUCCEEDED(hr = pMLStrBufA->Delete(GetLockInfo()->GetCChPos(pKey) + cchSrc, cchLockLen - cchSrc)))
                SetBufCCh(GetBufCCh() - (cchLockLen - cchSrc));
        }

        if (SUCCEEDED(hr) && plActualLen)
            hr = CalcLenA(GetCodePage(), (CHAR*)pszSrc, cchSrc, plActualLen);

        if (pcchActual)
            *pcchActual = cchSrc;
    }

    return hr;
}

HRESULT CMLStr::UnlockAStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = S_OK;

    if (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE)
    {
        CComQIPtr<IMLangStringAStr, &IID_IMLangStringAStr> pMLStrA(this);
        ASSERT(pMLStrA);
        hr = pMLStrA->SetAStr(GetLockInfo()->GetPos(pKey), GetLockInfo()->GetLen(pKey), GetLockInfo()->GetCodePage(pKey), (CHAR*)pszSrc, cchSrc, pcchActual, plActualLen);
    }

    ASSIGN_IF_FAILED(hr, MemFree((void*)pszSrc));

    return hr;
}
#endif

#ifndef ASTRIMPL
STDMETHODIMP CMLStr::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    long lSrcLen = 0;
    const long lLockFlags = GetLockFlags();

    if (SUCCEEDED(hr) && (!IsLocked() || pszSrc != m_pszLockBuf))
        hr = E_INVALIDARG; // This MLStr is not locked

    if (!(lLockFlags & MLSTR_WRITE))
    {
        cchSrc = 0;
        lSrcLen = 0;
    }

    if (SUCCEEDED(hr))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();

        if (IsDirectLock())
        {
            if (SUCCEEDED(hr = pMLStrBufW->UnlockBuf(pszSrc, 0, cchSrc)) &&
                (lLockFlags & MLSTR_WRITE))
            {
                if (cchSrc < m_cchLockLen)
                {
                    if (SUCCEEDED(hr = pMLStrBufW->Delete(m_cchLockPos + cchSrc, m_cchLockLen - cchSrc)))
                        SetBufCCh(GetBufCCh() - (m_cchLockLen - cchSrc));
                }

                if (SUCCEEDED(hr) && plActualLen)
                    hr = CalcLenW(pszSrc, cchSrc, &lSrcLen);
            }
        }
        else
        {
            if (lLockFlags & MLSTR_WRITE)
                hr = SetWStr(m_lLockPos, m_lLockLen, pszSrc, cchSrc, (pcchActual) ? &cchSrc : NULL, (plActualLen) ? &lSrcLen : NULL);

            HRESULT hrTemp = MemFree((void*)pszSrc);
            if (FAILED(hrTemp) && SUCCEEDED(hr))
                hr = hrTemp;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchSrc;
        if (plActualLen)
            *plActualLen = lSrcLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    SetLockFlags(0); // Unlock it anyway

    return hr;
}
#endif

#ifdef ASTRIMPL
HRESULT CMLStr::UnlockStrCommon(const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = CheckThread();
    void* pLockKey;
    long lSrcLen;

    if (SUCCEEDED(hr))
        hr = GetLockInfo()->Find(pszSrc, cchSrc, &pLockKey);

    if (SUCCEEDED(hr))
        hr = GetLockInfo()->Unlock(pLockKey, pszSrc, cchSrc, (pcchActual) ? &cchSrc : NULL, (plActualLen) ? &lSrcLen : NULL);

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchSrc;
        if (plActualLen)
            *plActualLen = lSrcLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}
#endif

STDMETHODIMP CMLStr::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(TRUE, this, hr);
#endif
    long cchDestPos;
    long cchDestLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        //if (!cchDestPos && cchDestLen == GetBufCCh())
            SetLocale(locale);
        //else
        //    hr = E_NOTIMPL; // Cannot set the locale to a part of string in this version.
    }

    return hr;
}

STDMETHODIMP CMLStr::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plocale);
    ASSERT_WRITE_PTR_OR_NULL(plLocalePos);
    ASSERT_WRITE_PTR_OR_NULL(plLocaleLen);

    HRESULT hr = CheckThread();
#ifdef ASTRIMPL
    CLock Lock(FALSE, this, hr);
#endif
    long lStrLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = GetLen(0, GetBufCCh(), &lStrLen)) &&
        SUCCEEDED(hr = ::RegularizePosLen(lStrLen, &lSrcPos, &lSrcMaxLen)))
    {
        if (plocale)
            *plocale = GetLocale();
        if (plLocalePos)
            *plLocalePos = 0;
        if (plLocaleLen)
        {
            if (plLocalePos)
                *plLocaleLen = lStrLen;
            else
                *plLocaleLen = lSrcMaxLen;
        }
    }
    else
    {
        if (plocale)
            *plocale = 0;
        if (plLocalePos)
            *plLocalePos = 0;
        if (plLocaleLen)
            *plLocaleLen = 0;
    }

    return hr;
}

HRESULT CMLStr::PrepareMLStrBuf(void)
{
    if (GetMLStrBufW() || GetMLStrBufA())
        return S_OK;
#ifdef ASTRIMPL

    IMLangStringBufW* pBuf = new CMLStr::CMLStrBufStandardW;
    if (pBuf)
    {
        SetMLStrBufW(pBuf);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
#else
    else
        return E_NOTIMPL; //!ASTRIMPL
#endif
}

HRESULT CMLStr::RegularizePosLen(long* plPos, long* plLen)
{
    HRESULT hr;
    long lStrLen;

    if (SUCCEEDED(hr = GetLen(0, GetBufCCh(), &lStrLen)))
        hr = ::RegularizePosLen(lStrLen, plPos, plLen);

    return hr;
}

HRESULT CMLStr::GetCCh(long cchOffset, long lLen, long* pcchLen)
{
    if (GetMLStrBufW())
    {
        if (pcchLen)
            *pcchLen = lLen; // The number of characters is equal to the length
        return S_OK;
    }
    else if (GetMLStrBufA())
    {
        HRESULT hr = S_OK;
#ifdef ASTRIMPL
        CMLStrBufWalkA BufWalk(GetMLStrBufA(), cchOffset, GetBufCCh() - cchOffset);

        while (lLen > 0 && BufWalk.Lock(hr))
        {
            for (LPCSTR pszTemp = BufWalk.GetStr(); lLen > 0 && *pszTemp; lLen--)
                pszTemp = ::CharNextExA((WORD)GetCodePage(), pszTemp, 0);

            if (!*pszTemp)
                lLen = 0; // String terminated

            BufWalk.Unlock(hr);
        }
#else
        long cchDone = 0;
        long cchRest = GetBufCCh() - cchOffset;

        while (SUCCEEDED(hr) && lLen > 0)
        {
            CHAR* pszBuf;
            long cchBuf;

            if (SUCCEEDED(hr = m_pMLStrBufA->LockBuf(cchOffset, cchRest, &pszBuf, &cchBuf)))
            {
                for (LPCSTR pszTemp = pszBuf; lLen > 0 && *pszTemp; lLen--)
                    pszTemp = ::CharNextExA((WORD)m_uCodePage, pszTemp, 0);

                if (!*pszBuf)
                    lLen = 0; // String terminated

                hr = m_pMLStrBufA->UnlockBuf(pszBuf, 0, 0);

                cchOffset += cchBuf;
                cchRest -= cchBuf;
                cchDone += (int)(pszTemp - pszBuf);
            }
        }
#endif

        if (pcchLen)
        {
            if (SUCCEEDED(hr))
#ifdef ASTRIMPL
                *pcchLen = BufWalk.GetDoneCCh();
#else
                *pcchLen = cchDone;
#endif
            else
                *pcchLen = 0;
        }

        return hr;
    }
    else
    {
        if (pcchLen)
            *pcchLen = 0; // No string
        return S_OK;
    }
}

HRESULT CMLStr::GetLen(long cchOffset, long cchLen, long* plLen)
{
    if (GetMLStrBufW())
    {
        if (plLen)
            *plLen = cchLen; // The length is equal to the number of characters
        return S_OK;
    }
    else if (GetMLStrBufA())
    {
        HRESULT hr = S_OK;
        long lDoneLen = 0;
#ifdef ASTRIMPL
        CMLStrBufWalkA BufWalk(GetMLStrBufA(), cchOffset, cchLen);

        while (BufWalk.Lock(hr))
        {
            long lTempLen;

            hr = CalcLenA(GetCodePage(), BufWalk.GetStr(), BufWalk.GetCCh(), &lTempLen);
            if (hr == S_FALSE)
                cchLen = 0; // String terminated
            lDoneLen += lTempLen;

            BufWalk.Unlock(hr);
        }
#else

        while (SUCCEEDED(hr) && cchLen > 0)
        {
            CHAR* pszBuf;
            long cchBuf;

            if (SUCCEEDED(hr = m_pMLStrBufA->LockBuf(cchOffset, cchLen, &pszBuf, &cchBuf)))
            {
                long lTempLen;

                hr = CalcLenA(GetCodePage(), pszBuf, cchBuf, &lTempLen);
                if (hr == S_FALSE)
                    cchLen = 0; // String terminated
                lDoneLen += lTempLen;

                hr = m_pMLStrBufA->UnlockBuf(pszBuf, 0, 0);

                cchOffset += cchBuf;
                cchLen -= cchBuf;
            }
        }
#endif

        if (plLen)
        {
            if (SUCCEEDED(hr))
                *plLen = lDoneLen;
            else
                *plLen = 0;
        }

        return hr;
    }
    else
    {
        if (plLen)
            *plLen = 0; // No string
        return S_OK;
    }
}

HRESULT CMLStr::CalcLenA(UINT uCodePage, const CHAR* psz, long cchLen, long* plLen)
{
    long lLen = 0;
    const CHAR* const pszEnd = psz + cchLen;

    for (; psz < pszEnd && *psz; lLen++)
    {
        const CHAR* const pszNew = ::CharNextExA((WORD)uCodePage, psz, 0);

        if (pszNew > pszEnd) // Overrun out of buffer
            break;

        psz = pszNew;
    }

    if (plLen)
        *plLen = lLen;

    if (*psz)
        return S_OK;
    else
        return S_FALSE;
}

#ifdef ASTRIMPL
HRESULT CMLStr::CalcCChA(UINT uCodePage, const CHAR* psz, long lLen, long* pcchLen)
{
    const CHAR* const pszStart = psz;

    for (; lLen > 0 && *psz; lLen--)
        psz = ::CharNextExA((WORD)uCodePage, psz, 0);

    if (pcchLen)
        *pcchLen = psz - pszStart;

    if (*psz)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CMLStr::ConvAStrToWStr(UINT uCodePage, const CHAR* pszSrc, long cchSrc, WCHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen)
{
    HRESULT hr = S_OK;
    long lWrittenLen;
    long cchWrittenA;

    long cchWrittenW = ::MultiByteToWideChar(uCodePage, 0, pszSrc, cchSrc, pszDest, (pszDest) ? cchDest : 0);
    if (!cchWrittenW)
        hr = E_FAIL; // NLS failed

    if ((pcchActualA || plActualLen) && SUCCEEDED(hr))
        hr = CalcLenW(pszDest, cchWrittenW, &lWrittenLen); // BOGUS: pszDest may be NULL

    if (pcchActualA && SUCCEEDED(hr))
        hr = CalcCChA(uCodePage, pszSrc, lWrittenLen, &cchWrittenA);

    if (SUCCEEDED(hr))
    {
        if (pcchActualA)
            *pcchActualA = cchWrittenA;
        if (pcchActualW)
            *pcchActualW = cchWrittenW;
        if (plActualLen)
            *plActualLen = lWrittenLen;
    }
    else
    {
        if (pcchActualA)
            *pcchActualA = 0;
        if (pcchActualW)
            *pcchActualW = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

HRESULT CMLStr::ConvWStrToAStr(BOOL fCanStopAtMiddle, UINT uCodePage, const WCHAR* pszSrc, long cchSrc, CHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen)
{
    HRESULT hr = S_OK;
    long lWrittenLen;
    long cchWrittenW;

    long cchWrittenA = ::WideCharToMultiByte(uCodePage, (fCanStopAtMiddle) ? 0 : WC_DEFAULTCHAR, pszSrc, cchSrc, pszDest, (pszDest) ? cchDest : 0, NULL, NULL);
    if (!cchWrittenA)
        hr = E_FAIL; // NLS failed

    if ((pcchActualW || plActualLen) && SUCCEEDED(hr))
    {
        if (pszDest)
            hr = CalcLenA(uCodePage, pszDest, cchWrittenA, &lWrittenLen);
        else
            hr = E_NOTIMPL; // Can't retrieve pcchActualW and plActualLen
    }

    if (pcchActualW && SUCCEEDED(hr))
        hr = CalcCChW(pszSrc, lWrittenLen, &cchWrittenW);

    if (SUCCEEDED(hr))
    {
        if (pcchActualA)
            *pcchActualA = cchWrittenA;
        if (pcchActualW)
            *pcchActualW = cchWrittenW;
        if (plActualLen)
            *plActualLen = lWrittenLen;
    }
    else
    {
        if (pcchActualA)
            *pcchActualA = 0;
        if (pcchActualW)
            *pcchActualW = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}
#endif

#ifndef ASTRIMPL
HRESULT CMLStr::ConvertMLStrBufAToWStr(UINT uCodePage, IMLangStringBufA* pMLStrBufA, long cchSrcPos, long cchSrcLen, WCHAR* pszBuf, long cchBuf, long* pcchActual)
{
    HRESULT hr = S_OK;
    long cchDone = 0;

    while (SUCCEEDED(hr) && cchSrcLen > 0)
    {
        CHAR* pszBufA;
        long cchBufA;

        if (SUCCEEDED(hr = pMLStrBufA->LockBuf(cchSrcPos, cchSrcLen, &pszBufA, &cchBufA)))
        {
            long cchWritten = ::MultiByteToWideChar(uCodePage, 0, pszBufA, cchBufA, pszBuf, cchBuf);
            if (!cchWritten)
                hr = E_FAIL; // NLS failed

            HRESULT hrTemp = pMLStrBufA->UnlockBuf(pszBufA, 0, 0);
            if (FAILED(hrTemp) && SUCCEEDED(hr))
                hr = hrTemp;

            cchSrcPos += cchBufA;
            cchSrcLen -= cchBufA;
            pszBuf += cchWritten;
            cchBuf -= cchWritten;
            cchDone += cchWritten;
            ASSERT(cchBuf >= 0);
        }
    }

    if (pcchActual)
    {
        *pcchActual = cchDone;

        if (FAILED(hr) && cchDone > 0)
            hr = S_OK;
    }

    return hr;
}

HRESULT CMLStr::ConvertWStrToMLStrBufA(const WCHAR*, long, UINT, IMLangStringBufA*, long, long)
{
    return E_NOTIMPL; // !ASTRIMPL
}
#endif

#ifdef ASTRIMPL
/////////////////////////////////////////////////////////////////////////////
// CMLStr::CLockInfo

HRESULT CMLStr::CLockInfo::UnlockAll(void)
{
    if (m_pLockArray)
    {
        for (int n = 0; n < MAX_LOCK_COUNT; n++)
        {
            if (m_pLockArray[n].m_psz)
                Unlock(&m_pLockArray[n], m_pLockArray[n].m_psz, m_pLockArray[n].m_cchLen, NULL, NULL);
        }
    }

    return S_OK;
}

HRESULT CMLStr::CLockInfo::Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (!m_pLockArray)
    {
        m_pLockArray = new CLockInfoEntry[MAX_LOCK_COUNT];

        if (m_pLockArray)
        {
            for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
                m_pLockArray[nIndex].m_psz = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (!m_pLockArray[nIndex].m_psz)
                break;
        }
        if (nIndex >= MAX_LOCK_COUNT)
            hr = MLSTR_E_TOOMANYNESTOFLOCK;
    }

    if (SUCCEEDED(hr))
    {
        m_pLockArray[nIndex].m_psz = psz;
        m_pLockArray[nIndex].m_pfnUnlockProc = pfnUnlockProc;
        m_pLockArray[nIndex].m_lFlags = lFlags;
        m_pLockArray[nIndex].m_uCodePage = uCodePage;
        m_pLockArray[nIndex].m_lPos = lPos;
        m_pLockArray[nIndex].m_lLen = lLen;
        m_pLockArray[nIndex].m_cchPos = cchPos;
        m_pLockArray[nIndex].m_cchLen = cchLen;
    }

    return hr;
}

HRESULT CMLStr::CLockInfo::Find(const void* psz, long, void** ppKey)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (m_pLockArray)
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (psz == m_pLockArray[nIndex].m_psz)
                break;
        }
    }
    if (!m_pLockArray || nIndex >= MAX_LOCK_COUNT)
        hr = E_INVALIDARG;

    if (ppKey)
    {
        if (SUCCEEDED(hr))
            *ppKey = &m_pLockArray[nIndex];
        else
            *ppKey = NULL;
    }

    return hr;
}

HRESULT CMLStr::CLockInfo::Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen)
{
    CLockInfoEntry* const pEntry = (CLockInfoEntry*)pKey;
    HRESULT hr;

    if (!(pEntry->m_lFlags & MLSTR_WRITE))
    {
        cch = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    hr = (m_pMLStr->*(pEntry->m_pfnUnlockProc))(pKey, psz, cch, pcchActual, plActualLen);

    if (SUCCEEDED(hr))
        hr = EndLock(pEntry->m_lFlags & MLSTR_WRITE);

    pEntry->m_psz = NULL; // Remove from lock array anyway

    if (FAILED(hr))
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStr::CMLStrBufStandardW

long CMLStr::CMLStrBufStandardW::RoundBufSize(long cchStr)
{
    for (int n = 8; n < 12; n++)
    {
        if (cchStr < (1L << n))
            break;
    }
    const long cchTick = (1L << (n - 4));
    return (cchStr + cchTick - 1) / cchTick * cchTick;
}

#endif

#else // NEWMLSTR

#include "mlstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStr

CMLStr::CMLStr(void) :
    m_lLen(0),
    m_hUnlockEvent(NULL),
    m_hZeroEvent(NULL)
{
    DllAddRef();
}

CMLStr::~CMLStr(void)
{
    void* pv;

    if (m_hZeroEvent)
        ::CloseHandle(m_hZeroEvent);
    if (m_hUnlockEvent)
        ::CloseHandle(m_hUnlockEvent);

    // m_lock should be empty
    ASSERT(SUCCEEDED(m_lock.Top(&pv)));
    ASSERT(!pv);

    // Release all attributes in m_attr
    VERIFY(SUCCEEDED(m_attr.Top(&pv)));
    while (pv)
    {
        IMLStrAttr* const pAttr = m_attr.GetAttr(pv);
        ASSERT(pAttr);
        VERIFY(SUCCEEDED(pAttr->SetClient(NULL))); // Reset
        VERIFY(SUCCEEDED(StartEndConnectionAttr(pAttr, NULL, m_attr.GetCookie(pv)))); // Disconnect
        pAttr->Release();
        VERIFY(SUCCEEDED(m_attr.Next(pv, &pv)));
    }
    DllRelease();
}

STDMETHODIMP CMLStr::LockMLStr(long lPos, long lLen, DWORD dwFlags, DWORD* pdwCookie, long* plActualPos, long* plActualLen)
{
    ASSERT_WRITE_PTR_OR_NULL(pdwCookie);
    ASSERT_WRITE_PTR_OR_NULL(plActualPos);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr;
    void* pv;

    Lock();

    if (SUCCEEDED(hr = ::RegularizePosLen(m_lLen, &lPos, &lLen)))
    {
        const DWORD dwThrd = ::GetCurrentThreadId();

        if (SUCCEEDED(hr = CheckAccessValidation(lPos, lLen, dwFlags, dwThrd, plActualPos, plActualLen)) &&
            SUCCEEDED(hr = m_lock.Add(&pv)))
        {
            if (plActualPos && !plActualLen)
                lLen -= *plActualPos - lPos;
            else if (plActualLen)
                lLen = *plActualLen;
            if (plActualPos)
                lPos = *plActualPos;

            hr = m_lock.SetLock(pv, lPos, lLen, dwFlags, dwThrd);

            if (FAILED(hr))
                VERIFY(SUCCEEDED(m_lock.Remove(pv)));
        }
    }
    else
    {
        if (plActualPos)
            *plActualPos = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    Unlock();

    if (pdwCookie)
    {
        if (SUCCEEDED(hr))
            *pdwCookie = (DWORD)pv;
        else
            *pdwCookie = 0;
    }

    return hr;
}

HRESULT CMLStr::CheckAccessValidation(long lPos, long lLen, DWORD dwFlags, DWORD dwThrd, long* plActualPos, long* plActualLen)
{
    HRESULT hr;
    DWORD dwStartTime = 0;
    long lActualPos;
    long lActualLen;

    for (;;) // Waiting unlock loop
    {
        void* pv;
        HRESULT hrValidation = S_OK;

        lActualPos = lPos;
        lActualLen = lLen;

        hr = m_lock.Top(&pv);
        while (SUCCEEDED(hr) && pv) // Enumerate all locks
        {
            LOCKINFO* plinfo;

            if (SUCCEEDED(hr = m_lock.GetLockInfo(pv, &plinfo))) // Retrieve info of a lock
            {
                if ((dwFlags & MLSTR_MOVE) && // Moving this lock
                    lPos < plinfo->lPos + plinfo->lLen && // Overwrap or left of this lock
                    (dwThrd != plinfo->dwThrd || // Another thread
                     (plinfo->dwFlags & (MLSTR_READ | MLSTR_WRITE)))) // Same thread and has read or write access
                {
                    if (dwThrd == plinfo->dwThrd)
                        hr = MLSTR_E_ACCESSDENIED;
                    else
                        hr = MLSTR_E_BUSY;
                }

                if (SUCCEEDED(hr) &&
                    lActualPos < plinfo->lPos + plinfo->lLen &&
                    lActualPos + lActualLen >= plinfo->lPos) // Overwraping with this lock
                {
                    DWORD dwShareMask = 0;
                    if (dwThrd == plinfo->dwThrd) // Same thread
                        dwShareMask = ~(MLSTR_SHARE_DENYREAD | MLSTR_SHARE_DENYWRITE); // Ignore share flags

                    if (((dwFlags & MLSTR_WRITE) && (plinfo->dwFlags & (MLSTR_READ | MLSTR_WRITE | MLSTR_SHARE_DENYWRITE) & dwShareMask)) || // Write on read/write
                        ((dwFlags & MLSTR_READ)  && (plinfo->dwFlags & (             MLSTR_WRITE | MLSTR_SHARE_DENYREAD ) & dwShareMask)) || // Read on write
                        ((dwFlags & MLSTR_SHARE_DENYWRITE & dwShareMask) && (plinfo->dwFlags & MLSTR_WRITE)) || // Share deny on write
                        ((dwFlags & MLSTR_SHARE_DENYREAD  & dwShareMask) && (plinfo->dwFlags & MLSTR_READ)))    // Share deny on read
                    {
                        // Conflicting access
                        if ((plinfo->lPos <= lActualPos && plinfo->lPos + plinfo->lLen >= lActualPos + lActualLen) || // No valid range left
                            (!plActualPos && !plActualLen)) // Needs to lock entire range
                        {
                            lActualPos = 0;
                            lActualLen = 0;
                            if (dwThrd == plinfo->dwThrd)
                                hr = MLSTR_E_ACCESSDENIED;
                            else
                                hr = MLSTR_E_BUSY;
                        }
                        else if ((!plActualPos && plinfo->lPos <= lActualPos) || // Forward processing, Starting from invalid range
                                 (!plActualLen && plinfo->lPos + plinfo->lLen < lActualPos + lActualLen) || // Backward processing, Trancate valid range
                                 (plActualPos && plActualLen && plinfo->lPos - lActualPos >= (lActualPos + lActualLen) - (plinfo->lPos + plinfo->lLen))) // Maximum valid range, Right valid range is bigger
                        {
                            lActualLen += lActualPos;
                            lActualPos = plinfo->lPos + plinfo->lLen;
                            lActualLen -= lActualPos;
                            if (!plActualPos) // Forward processing
                            {
                                if (dwThrd == plinfo->dwThrd)
                                    hrValidation = MLSTR_E_ACCESSDENIED;
                                else
                                    hrValidation = MLSTR_E_BUSY;
                            }
                        }
                        else
                        {
                            lActualLen = plinfo->lPos - lActualPos;
                            if (!plActualLen) // Backward processing
                            {
                                if (dwThrd == plinfo->dwThrd)
                                    hrValidation = MLSTR_E_ACCESSDENIED;
                                else
                                    hrValidation = MLSTR_E_BUSY;
                            }
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
                hr = m_lock.Next(pv, &pv);
        }

        if (SUCCEEDED(hr) && FAILED(hrValidation))
        {
            hr = hrValidation;
            if (plActualLen && lPos < lActualPos) // Forward processing
            {
                lActualLen = lActualPos - lPos;
                lActualPos = lPos;
            }
            else if (plActualPos && lPos + lLen != lActualPos + lActualLen) // Backward processing
            {
                lActualPos += lActualLen;
                lActualLen = lPos + lLen - lActualPos;
            }
        }

        if (hr != MLSTR_E_BUSY || (dwFlags | MLSTR_NOWAIT)) // No busy state, or don't want to wait even if busy
            break;

        // Now, let's wait another thread run UnlockMLStr. Then, try validation again.

        if (!dwStartTime) // Not initialized yet
            dwStartTime = ::GetTickCount(); // Remember starting time

        const DWORD dwElapsedTime = ::GetTickCount() - dwStartTime;
        if (dwElapsedTime >= MLSTR_LOCK_TIMELIMIT) // Already elapsed long time
            break;

        if (!m_hUnlockEvent) // We don't have event object yet
        {
            m_hUnlockEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL); // Manual reset, initial reset
            if (!m_hUnlockEvent)
                break;

            m_cWaitUnlock = -1; // Initialize
        }
        else // After second time
        {
            ASSERT(m_cWaitUnlock == 0 || m_cWaitUnlock == -1 || m_cWaitUnlock >= 1);
            if (m_cWaitUnlock == 0) // Don't reset if m_cWaitUnlock is not zero
            {
                ::ResetEvent(m_hUnlockEvent);
                m_cWaitUnlock = -1;
            }
            else
            {
                if (!m_hZeroEvent)
                {
                    m_hZeroEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL); // Auto-reset, initial reset
                    if (!m_hZeroEvent)
                        break;
                }
                if (m_cWaitUnlock == -1)
                    m_cWaitUnlock = 2;
                else
                    m_cWaitUnlock++;
            }
        }
        ASSERT(m_cWaitUnlock == -1 || m_cWaitUnlock >= 2);

        // CAUTION: Don't leave here until we make sure m_cWaitUnlock gets zero.

        Unlock();

        // === The story of m_cWaitUnlock ===
        // If we don't have m_cWaitUnlock, the following scenario can be considered.
        // (1) Thread A: ResetEvent(m_hUnlockEvent)
        // (2) Thread A: Unlock()
        // (3) Thread B: SetEvent(m_hUnlockEvent) // UnlockMLStr!!!
        // (4) Thread C: Lock()
        // (5) Thread C: ResetEvent(m_hUnlockEvent) // Problem!!!
        // (6) Thread C: Unlock()
        // (7) Thread A: WaitForSingleObject(m_hUnlockEvent)
        // In this scenario, thread A is missing a event of (3). This situation should not happen.
        // m_cWaitUnlock solves the problem.

        const DWORD dwWaitResult = ::WaitForSingleObject(m_hUnlockEvent, MLSTR_LOCK_TIMELIMIT - dwElapsedTime); // Now wait unlock

        Lock();

        ASSERT(m_cWaitUnlock == -1 || m_cWaitUnlock >= 1);
        if (m_cWaitUnlock == -1)
        {
            m_cWaitUnlock = 0;
        }
        else // m_cWaitUnlock >= 1
        {
            m_cWaitUnlock--;

            // Here, let's wait until m_cWaitUnlock gets zero.
            // Unless this, it may not good for performance.
            // In worst case, it makes thousands of loops in this function because it never reset m_hUnlockEvent.
            // m_hUnlockEvent will be signaled even though UnlockMLStr is called yet.
            if (m_cWaitUnlock > 0)
            {
                Unlock();
                ::WaitForSingleObject(m_hZeroEvent, INFINITE); // Wait until m_cWaitUnlock gets zero, auto-reset
                Lock();
            }
            else // Now it's zero! Yeah!
            {
                ::SetEvent(m_hZeroEvent); // Release other threads
            }
        }
        // ASSERT(m_cWaitUnlock == 0); This is not true. Maybe non-zero for next time.
        // Now we may leave here.

        if (dwWaitResult != WAIT_OBJECT_0) // Time expired or an error occurred
            break;
    }

    if (plActualPos)
        *plActualPos = lActualPos;
    if (plActualLen)
        *plActualLen = lActualLen;

    return hr;
}

STDMETHODIMP CMLStr::UnlockMLStr(DWORD dwCookie)
{
    Lock();

    void* const pv = (void*)dwCookie;

    const HRESULT hr = m_lock.Remove(pv);

    if (m_hUnlockEvent)
        ::SetEvent(m_hUnlockEvent);

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::GetLength(long* plLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plLen);

    if (plLen)
        *plLen = m_lLen;

    return S_OK;
}

STDMETHODIMP CMLStr::SetMLStr(long, long, IUnknown*, long, long)
{
    return E_NOTIMPL; // IMLangString::SetMLStr()
}

STDMETHODIMP CMLStr::RegisterAttr(IUnknown* pUnk, DWORD* pdwCookie)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(pUnk);
    ASSERT_WRITE_PTR_OR_NULL(pdwCookie);

    HRESULT hr;
    void* pv;
    IMLStrAttr* pAttr = NULL;
    BOOL fConnStarted = FALSE;
    DWORD dwConnCookie;

    Lock();

    if (SUCCEEDED(hr = m_attr.Add(&pv)) &&
        SUCCEEDED(hr = pUnk->QueryInterface(IID_IMLStrAttr, (void**)&pAttr)))
    {
        ASSERT_READ_PTR(pAttr);
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = StartEndConnectionAttr(pAttr, &dwConnCookie, 0))) // Connect
    {
        fConnStarted = TRUE;
        if (SUCCEEDED(hr = pAttr->SetClient((IMLangString*)this)))
        {
            CFire fire(hr, this);
            while (fire.Next())
                hr = fire.Sink()->OnRegisterAttr(pAttr);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pAttr->SetMLStr(0, -1, (IMLangString*)this, 0, m_lLen)))
    {
        m_attr.SetAttr(pv, pAttr);
        m_attr.SetCookie(pv, dwConnCookie);

        if (pdwCookie)
            *pdwCookie = (DWORD)pv;
    }
    else
    {
        if (pAttr)
        {
            pAttr->SetClient(NULL);
            if (fConnStarted)
                VERIFY(SUCCEEDED(StartEndConnectionAttr(pAttr, NULL, dwConnCookie))); // Disconnect
            pAttr->Release();
        }

        if (pv)
            m_attr.Remove(pv);

        if (pdwCookie)
            *pdwCookie = NULL;
    }

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::UnregisterAttr(DWORD dwCookie)
{
    ASSERT_THIS;

    void* const pv = (void*)dwCookie;

    Lock();

    IMLStrAttr* const pAttr = m_attr.GetAttr(pv);
    ASSERT(pAttr);

    // Fire OnUnregisterAttr
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnUnregisterAttr(pAttr);

    // Release attribute
    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pAttr->SetClient(NULL))) // Reset
    {
        VERIFY(SUCCEEDED(hr = StartEndConnectionAttr(pAttr, NULL, m_attr.GetCookie(pv)))); // Disconnect
        pAttr->Release();

        // Remove entry from attr table
        m_attr.Remove(pv);
    }

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::EnumAttr(IEnumUnknown** ppEnumUnk)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppEnumUnk);

    if (!ppEnumUnk)
        return S_OK;

    CEnumAttr* const pEnum = new CComObject<CEnumAttr>;

    *ppEnumUnk = pEnum;

    if (pEnum)
    {
        pEnum->Init(this);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CMLStr::FindAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppUnk);

    HRESULT hr;
    void* pv;
    IUnknown* pMaxUnk = NULL;
    long lMaxConf = 0;

    Lock();

    for (hr = m_attr.Top(&pv); SUCCEEDED(hr) && pv; hr = m_attr.Next(pv, &pv))
    {
        IMLStrAttr* const pIMLStrAttr = m_attr.GetAttr(pv);
        IUnknown* pUnk;
        long lConf;

        hr = pIMLStrAttr->QueryAttr(riid, lParam, &pUnk, &lConf);
        if (SUCCEEDED(hr))
        {
            if (lConf > lMaxConf)
            {
                lMaxConf = lConf;
                if (pMaxUnk)
                    pMaxUnk->Release();
                pMaxUnk = pUnk;
            }
            else
            {
                if (pUnk)
                    pUnk->Release();
            }

            if (lMaxConf == MLSTR_CONF_MAX)
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (ppUnk)
            *ppUnk = pMaxUnk;
        else if (pMaxUnk)
            pMaxUnk->Release();
    }
    else
    {
        if (pMaxUnk)
            pMaxUnk->Release();
        if (ppUnk)
            *ppUnk = NULL;
    }

    Unlock();

    return hr;
}

STDMETHODIMP CMLStr::OnRequestEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnRequestEdit(lDestPos, lDestLen, lNewLen, riid, lParam, pUnk);
    return hr;
}

STDMETHODIMP CMLStr::OnCanceledEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnCanceledEdit(lDestPos, lDestLen, lNewLen, riid, lParam, pUnk);
    return hr;
}

STDMETHODIMP CMLStr::OnChanged(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    HRESULT hr;
    CFire fire(hr, this);
    while (fire.Next())
        hr = fire.Sink()->OnChanged(lDestPos, lDestLen, lNewLen, riid, lParam, pUnk);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStr::CEnumAttr

CMLStr::CEnumAttr::CEnumAttr(void) :
    m_pMLStr(NULL),
    m_pv(NULL)
{
}

CMLStr::CEnumAttr::~CEnumAttr(void)
{
    if (m_pMLStr)
        m_pMLStr->Unlock();
}

void CMLStr::CEnumAttr::Init(CMLStr* pMLStr)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(pMLStr);

    if (m_pMLStr)
        m_pMLStr->Unlock();

    m_pMLStr = pMLStr;
    m_pMLStr->Lock();

    VERIFY(SUCCEEDED(Reset()));
}

HRESULT CMLStr::CEnumAttr::Next(ULONG celt, IUnknown** rgelt, ULONG* pceltFetched)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(rgelt, celt);
    ASSERT_WRITE_PTR_OR_NULL(pceltFetched);

    ULONG c = 0;

    if (rgelt && m_pMLStr)
    {
        for (; m_pv && c < celt; c++)
        {
            *rgelt = m_pMLStr->m_attr.GetAttr(m_pv);
            ASSERT(*rgelt);
            (*rgelt)->AddRef();

            VERIFY(SUCCEEDED(m_pMLStr->m_attr.Next(m_pv, &m_pv)));
            rgelt++;
        }
    }

    if (pceltFetched)
        *pceltFetched = c;

    return S_OK;
}

HRESULT CMLStr::CEnumAttr::Skip(ULONG celt)
{
    ASSERT_THIS;

    for (ULONG c = 0; m_pv && c < celt; c++)
        VERIFY(SUCCEEDED(m_pMLStr->m_attr.Next(m_pv, &m_pv)));

    return S_OK;
}

HRESULT CMLStr::CEnumAttr::Reset(void)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(m_pMLStr);

    VERIFY(SUCCEEDED(m_pMLStr->m_attr.Top(&m_pv)));
    return S_OK;
}

HRESULT CMLStr::CEnumAttr::Clone(IEnumUnknown** ppEnum)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppEnum);
    ASSERT_READ_PTR(m_pMLStr);

    return m_pMLStr->EnumAttr(ppEnum);
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstr.h ===
#ifndef NEWMLSTR

// MLStr.h : Declaration of the CMLStr

#ifndef __MLSTR_H_
#define __MLSTR_H_

#ifdef ASTRIMPL
#include "mlstrw.h"
#endif
#include "mlstra.h"
#ifdef ASTRIMPL
#include "mlstrbuf.h"
#endif

#define MAX_LOCK_COUNT                  4

// Error Code
#define FACILITY_MLSTR                  0x0A15
#define MLSTR_E_ACCESSDENIED            MAKE_HRESULT(1, FACILITY_MLSTR, 1002)
#define MLSTR_E_TOOMANYNESTOFLOCK       MAKE_HRESULT(1, FACILITY_MLSTR, 1003)
#define MLSTR_E_STRBUFNOTAVAILABLE      MAKE_HRESULT(1, FACILITY_MLSTR, 1004)

/////////////////////////////////////////////////////////////////////////////
// CMLStr
class ATL_NO_VTABLE CMLStr :
    public CComObjectRoot,
    public CComCoClass<CMLStr, &CLSID_CMLangString>,
#ifdef ASTRIMPL
    public IMLangString
#else
    public IMLangStringWStr
#endif
{
    typedef HRESULT (CMLStr::*PFNUNLOCKPROC)(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);

public:
    CMLStr(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStr)
        COM_INTERFACE_ENTRY(IMLangString)
#ifdef ASTRIMPL
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringWStr, CMLStrW)
#else
        COM_INTERFACE_ENTRY(IMLangStringWStr)
#endif
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringAStr, CMLStrA)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(Sync)(/*[in]*/ BOOL fNoAccess);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(GetMLStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ IUnknown* pUnkOuter, /*[in]*/ DWORD dwClsContext, /*[in]*/ const IID* piid, /*[out]*/ IUnknown** ppDestMLStr, /*[out]*/ long* plDestPos, /*[out]*/ long* plDestLen);
#ifndef ASTRIMPL
// IMLangStringWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
#endif
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

#ifdef ASTRIMPL
protected:
    class CLockInfo
    {
    protected:
        class CLockInfoEntry
        {
        public:
            void* m_psz;
            PFNUNLOCKPROC m_pfnUnlockProc;
            long m_lFlags;
            UINT m_uCodePage;
            long m_lPos;
            long m_lLen;
            long m_cchPos;
            long m_cchLen;
        };

    public:
        CLockInfo(CMLStr* pMLStr) : m_pMLStr(pMLStr)
        {
            m_nLockCount = 0;
            m_pLockArray = NULL;
        }
        ~CLockInfo(void)
        {
            UnlockAll();
        }
        HRESULT UnlockAll(void);
        HRESULT StartLock(BOOL fWrite)
        {
            if (fWrite && !m_nLockCount)
                m_nLockCount = -1; // Negative means write lock
            else if (!fWrite && m_nLockCount >= 0)
                m_nLockCount++;
            else
                return MLSTR_E_ACCESSDENIED;
            return S_OK;
        }
        HRESULT EndLock(BOOL fWrite)
        {
            ASSERT(m_nLockCount);
            if (fWrite)
                m_nLockCount = 0;
            else
                m_nLockCount--;
            return S_OK;
        }
        HRESULT Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen);
        HRESULT Find(const void* psz, long cch, void** ppKey);
        HRESULT Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen);
        long GetFlags(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lFlags;}
        UINT GetCodePage(void* pKey) {return ((CLockInfoEntry*)pKey)->m_uCodePage;}
        long GetPos(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lPos;}
        long GetLen(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lLen;}
        long GetCChPos(void* pKey) {return ((CLockInfoEntry*)pKey)->m_cchPos;}
        long GetCChLen(void* pKey) {return ((CLockInfoEntry*)pKey)->m_cchLen;}

    protected:
        CMLStr* const m_pMLStr;
        int m_nLockCount;
        CLockInfoEntry* m_pLockArray;
    };

    class CMLStrBufStandardW : public CMLStrBufW
    {
    protected:
        LPVOID MemAlloc(ULONG cb) {return ::CoTaskMemAlloc(cb);}
        LPVOID MemRealloc(LPVOID pv, ULONG cb) {return ::CoTaskMemRealloc(pv, cb);}
        void MemFree(LPVOID pv) {::CoTaskMemFree(pv);}
        long RoundBufSize(long cchStr);
    };
#endif

public:
// Called from CMLStrW and CMLStrA
#ifdef ASTRIMPL
    class CLock
    {
    public:
        CLock(BOOL fWrite, CMLStr* pMLStr, HRESULT& hr) : m_fWrite(fWrite), m_pMLStr(pMLStr) {m_fLocked = (SUCCEEDED(hr) && SUCCEEDED(hr = m_pMLStr->GetLockInfo()->StartLock(m_fWrite)));}
        ~CLock(void) {if (m_fLocked) m_pMLStr->GetLockInfo()->EndLock(m_fWrite);}
        HRESULT FallThrough(void) {m_fLocked = FALSE; return S_OK;} // Don't call EndLock in destructor
    protected:
        const BOOL m_fWrite;
        CMLStr* const m_pMLStr;
        BOOL m_fLocked;
    };
#endif

    HRESULT PrepareMLStrBuf(void);
    HRESULT SetStrBufCommon(void* pMLStrX, long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufW* pSrcBufW, IMLangStringBufA* pSrcBufA, long* pcchActual, long* plActualLen);
#ifdef ASTRIMPL
    HRESULT UnlockStrCommon(const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
#endif
    HRESULT CheckThread(void) {return (m_dwThreadID == ::GetCurrentThreadId()) ? S_OK : E_FAIL;}
    HRESULT RegularizePosLen(long* plPos, long* plLen);
    HRESULT GetLen(long cchOffset, long cchLen, long* plLen);
    HRESULT GetCCh(long cchOffset, long lLen, long* pcchLen);
    static HRESULT CalcLenW(const WCHAR*, long cchLen, long* plLen) {if (plLen) *plLen = cchLen; return S_OK;}
    static HRESULT CalcLenA(UINT uCodePage, const CHAR*,  long cchLen, long* plLen);
    static HRESULT CalcCChW(const WCHAR*, long lLen, long* pcchLen) {if (pcchLen) *pcchLen = lLen; return S_OK;}
    static HRESULT CalcCChA(UINT uCodePage, const CHAR*,  long lLen, long* pcchLen);
    static HRESULT CalcBufSizeW(long lLen, long* pcchSize) {if (pcchSize) *pcchSize = lLen; return S_OK;}
    static HRESULT CalcBufSizeA(long lLen, long* pcchSize) {if (pcchSize) *pcchSize = lLen * 2; return S_OK;}
    static HRESULT ConvAStrToWStr(UINT uCodePage, const CHAR* pszSrc, long cchSrc, WCHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen);
    static HRESULT ConvWStrToAStr(BOOL fCanStopAtMiddle, UINT uCodePage, const WCHAR* pszSrc, long cchSrc, CHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen);
    IMLangStringBufW* GetMLStrBufW(void) const {return m_pMLStrBufW;}
    void SetMLStrBufW(IMLangStringBufW* pBuf) {m_pMLStrBufW = pBuf;}
    IMLangStringBufA* GetMLStrBufA(void) const {return m_pMLStrBufA;}
    void SetMLStrBufA(IMLangStringBufA* pBuf) {m_pMLStrBufA = pBuf;}
    UINT GetCodePage(void) const {return m_uCodePage;}
    void SetCodePage(UINT uCodePage) {m_uCodePage = uCodePage;}
    long GetBufFlags(void) const {return m_lBufFlags;}
    void SetBufFlags(long lBufFlags) {m_lBufFlags = lBufFlags;}
    long GetBufCCh(void) const {return m_cchBuf;}
    void SetBufCCh(long cchBuf) {m_cchBuf = cchBuf;}
    LCID GetLocale(void) const {return m_locale;}
    void SetLocale(LCID locale) {m_locale = locale;}
#ifdef ASTRIMPL
    CLockInfo* GetLockInfo(void) {return &m_LockInfo;}
#else
    BOOL IsLocked(void) const {return (m_lLockFlags != 0);}
    BOOL IsDirectLock(void) const {return m_fDirectLock;}
    void SetDirectLockFlag(BOOL fDirectLock) {m_fDirectLock = fDirectLock;}
    long GetLockFlags(void) const {return m_lLockFlags;}
    void SetLockFlags(long lFlags) {m_lLockFlags = lFlags;}
#endif
    HRESULT MemAlloc(ULONG cb, void** ppv) {void* pv = ::CoTaskMemAlloc(cb); if (ppv) *ppv = pv; return (pv) ? S_OK : E_OUTOFMEMORY;}
    HRESULT MemFree(void* pv) {::CoTaskMemFree(pv); return S_OK;}
#ifdef ASTRIMPL
    HRESULT UnlockWStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockWStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockAStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockAStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
#endif

protected:
    ~CMLStr(void);
#ifndef ASTRIMPL
    static HRESULT ConvertMLStrBufAToWStr(UINT uCodePage, IMLangStringBufA* pMLStrBufA, long cchSrcPos, long cchSrcLen, WCHAR* pszBuf, long cchBuf, long* pcchActual);
    static HRESULT ConvertWStrToMLStrBufA(const WCHAR* pszSrc, long cchSrc, UINT uCodePage, IMLangStringBufA* pMLStrBufA, long cchDestPos, long cchDestLen);
#endif

    DWORD m_dwThreadID;

    IMLangStringBufW* m_pMLStrBufW;
    IMLangStringBufA* m_pMLStrBufA;
    UINT m_uCodePage;
    long m_lBufFlags;
    long m_cchBuf;

    LCID m_locale;

#ifdef ASTRIMPL
    CLockInfo m_LockInfo;
#else
    BOOL m_fDirectLock;
    long m_lLockFlags;

    WCHAR* m_pszLockBuf;
    long m_cchLockPos;
    long m_cchLockLen;
    long m_lLockPos;
    long m_lLockLen;
#endif
};

#endif //__MLSTR_H_

#else // NEWMLSTR

// MLStr.h : Declaration of the CMLStr

#ifndef __MLSTR_H_
#define __MLSTR_H_

#include "mlstrw.h" // IMLangStringWStrImpl
#include "mlstra.h" // IMLangStringAStrImpl
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStr
class ATL_NO_VTABLE CMLStr :
    public CComObjectRoot,
    public CComCoClass<CMLStr, &CLSID_CMLangString>,
    public IMLangString,
    public IMLStrAttrNotifySink,
    public IConnectionPointContainerImpl<CMLStr>,
    public IConnectionPointImpl<CMLStr, &IID_IMLangStringNotifySink>
{
public:
    CMLStr();

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStr)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringWStr, CMLStrW)
        COM_INTERFACE_ENTRY_TEAR_OFF(IID_IMLangStringAStr, CMLStrA)
        COM_INTERFACE_ENTRY(IMLStrAttrNotifySink)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMLStr)
        CONNECTION_POINT_ENTRY(IID_IMLangStringNotifySink)
    END_CONNECTION_POINT_MAP()

public:
// IMLangString
    STDMETHOD(LockMLStr)(/*[in]*/ long lPos, /*[in]*/ long lLen, /*[in]*/ DWORD dwFlags, /*[out]*/ DWORD* pdwCookie, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
    STDMETHOD(UnlockMLStr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(RegisterAttr)(/*[in]*/ IUnknown* pUnk, /*[out]*/ DWORD* pdwCookie);
    STDMETHOD(UnregisterAttr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(EnumAttr)(/*[out]*/ IEnumUnknown** ppEnumUnk);
    STDMETHOD(FindAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk);
// IMLStrAttrNotifySink
    STDMETHOD(OnRequestEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnCanceledEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnChanged)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);

//---------------------------------------------------------------------------
protected:
    struct LOCKINFO
    {
        long lPos;
        long lLen;
        DWORD dwFlags;
        DWORD dwThrd;
    };
//---------------------------------------------------------------------------
protected:
    class CLockList : public CMLListFast
    {
    protected:
        struct CCell : public CMLListFast::CCell
        {
            LOCKINFO m_linfo;
        };

    public:
        inline CLockList(void) : CMLListFast(sizeof(CCell), sizeof(CCell) * 8) {}
        inline HRESULT SetLock(void* pv, long lPos, long lLen, DWORD dwFlags, DWORD dwThrd)
        {
            ((CCell*)pv)->m_linfo.lPos = lPos;
            ((CCell*)pv)->m_linfo.lLen = lLen;
            ((CCell*)pv)->m_linfo.dwFlags = dwFlags;
            ((CCell*)pv)->m_linfo.dwThrd = dwThrd;
            return S_OK;
        }
        inline HRESULT GetLockInfo(void* pv, LOCKINFO** pplinfo)
        {
            *pplinfo = &((CCell*)pv)->m_linfo;
            return S_OK;
        }
    };
//---------------------------------------------------------------------------
protected:
    class CAttrList : public CMLListLru
    {
    protected:
        struct CCell : public CMLListLru::CCell
        {
            IMLStrAttr* m_pAttr;
            DWORD m_dwCookie;
        };

    public:
        inline CAttrList(void) : CMLListLru(sizeof(CCell), sizeof(CCell) * 8) {}
        inline IMLStrAttr* GetAttr(void* pv) {return ((CCell*)pv)->m_pAttr;}
        inline void SetAttr(void* pv, IMLStrAttr* pAttr) {((CCell*)pv)->m_pAttr = pAttr;}
        inline DWORD GetCookie(void* pv) const {return ((CCell*)pv)->m_dwCookie;}
        inline void SetCookie(void* pv, DWORD dwCookie) {((CCell*)pv)->m_dwCookie = dwCookie;}
    };
//---------------------------------------------------------------------------
// IEnumUnknown object for IMLangString::EnumAttr()
protected:
    class ATL_NO_VTABLE CEnumAttr :
        public CComObjectRoot,
        public IEnumUnknown
    {
    public:
        CEnumAttr(void);
        ~CEnumAttr(void);
        void Init(CMLStr* pMLStr);

        BEGIN_COM_MAP(CEnumAttr)
            COM_INTERFACE_ENTRY(IEnumUnknown)
        END_COM_MAP()

        STDMETHOD(Next)(ULONG celt, IUnknown** rgelt, ULONG* pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumUnknown** ppEnum);

    protected:
        CMLStr* m_pMLStr;
        void* m_pv;
    };
    friend class CEnumAttr;
//---------------------------------------------------------------------------
// Fire notification to all of IMLangStringNotifySink advised.
protected:
    class CFire : public CFireConnection<IMLangStringNotifySink, &IID_IMLangStringNotifySink>
    {
    public:
        inline CFire(HRESULT& rhr, CMLStr* const pMLStr) :
            CFireConnection<IMLangStringNotifySink, &IID_IMLangStringNotifySink>(rhr)
        {
            if (SUCCEEDED(*m_phr) &&
                FAILED(*m_phr = pMLStr->EnumConnections(&m_pEnumConn)))
            {
                m_pEnumConn = NULL;
            }
        }
    };
//---------------------------------------------------------------------------

protected:
    ~CMLStr(void);
    HRESULT CheckAccessValidation(long lPos, long lLen, DWORD dwFlags, DWORD dwThrd, long* plActualPos, long* plActualLen);

    inline HRESULT StartEndConnectionAttr(IUnknown* const pUnk, DWORD* const pdwCookie, DWORD dwCookie)
    {
        return ::StartEndConnection(pUnk, &IID_IMLStrAttrNotifySink, (IMLStrAttrNotifySink*)this, pdwCookie, dwCookie);
    }

protected:
    long m_lLen;
    CLockList m_lock;
    CAttrList m_attr;
    HANDLE m_hUnlockEvent;
    int m_cWaitUnlock;
    HANDLE m_hZeroEvent;
};

#endif //__MLSTR_H_

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlswalk.cpp ===
// MLSWalk.cpp : Implementation of CMLStrWalkW
#include "private.h"
#include "mlswalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrWalkW

BOOL CMLStrWalkW::Lock(HRESULT& rhr)
{
    if (m_pszBuf)
        rhr = E_FAIL; // Already locked

    if (SUCCEEDED(rhr) &&
        m_lLen > 0 &&
        FAILED(rhr = m_pMLStr->LockWStr(m_lPos, m_lLen, m_lFlags, 0, &m_pszBuf, &m_cchBuf, &m_lLockLen)))
    {
        m_pszBuf = NULL; // Mark as it's not locked
    }

    if (m_fCanStopAtMiddle && FAILED(rhr) && m_lDoneLen > 0)
    {
        rhr = S_OK;
        return FALSE; // Stop it, but not fail
    }
    else
    {
        return (SUCCEEDED(rhr) && m_lLen > 0);
    }
}

void CMLStrWalkW::Unlock(HRESULT& rhr, long lActualLen)
{
    HRESULT hr = S_OK;

    if (!m_pszBuf)
        hr = E_FAIL; // Not locked yet

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = m_pMLStr->UnlockWStr(m_pszBuf, 0, NULL, NULL))) // Unlock even if rhr is already failed
    {
        if (!lActualLen)
            lActualLen = m_lLockLen;
        else
            ASSERT(lActualLen > 0 && lActualLen <= m_lLockLen);

        m_lPos += lActualLen;
        m_lLen -= lActualLen;
        m_lDoneLen += lActualLen;
    }

    m_pszBuf = NULL; // Unlock anyway

    if (SUCCEEDED(rhr))
        rhr = hr; // if rhr is failed before UnlockBuf, use it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstra.cpp ===
// MLStrA.cpp : Implementation of CMLStrA
#include "private.h"

#ifndef NEWMLSTR

#include "mlstr.h"
#ifdef ASTRIMPL
#include "mlswalk.h"
#include "mlsbwalk.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CMLStrA

#ifdef ASTRIMPL
CMLStrA::CMLStrA(void) :
    m_pMLCPs(NULL)
{
    DllAddRef();
}

CMLStrA::~CMLStrA(void)
{
    if (m_pMLCPs)
        m_pMLCPs->Release();
    DllRelease();
}
#endif

STDMETHODIMP CMLStrA::Sync(BOOL fNoAccess)
{
    ASSERT_THIS;
    return GetOwner()->Sync(fNoAccess);
}

STDMETHODIMP CMLStrA::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrA::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrA::GetMLStr(long lSrcPos, long lSrcLen, IUnknown* pUnkOuter, DWORD dwClsContext, const IID* piid, IUnknown** ppDestMLStr, long* plDestPos, long* plDestLen)
{
    ASSERT_THIS;
    return GetOwner()->GetMLStr(lSrcPos, lSrcLen, pUnkOuter, dwClsContext, piid, ppDestMLStr, plDestPos, plDestLen);
}

STDMETHODIMP CMLStrA::SetAStr(long lDestPos, long lDestLen, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(TRUE, pOwner, hr);
    long cchDestPos;
    long cchDestLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && (pOwner->GetBufFlags() & MLSTR_WRITE))
        hr = E_INVALIDARG; // Not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();

        if (uCodePage == CP_ACP)
            uCodePage = g_uACP;

        if (pMLStrBufA && uCodePage == pOwner->GetCodePage())
        {
            if (cchSrc > cchDestLen)
            {
                hr = pMLStrBufA->Insert(cchDestPos, cchSrc - cchDestLen, (pcchActual || plActualLen) ? &cchSrc : NULL);
                cchSrc += cchDestLen;
            }
            else if  (cchSrc < cchDestLen)
            {
                hr = pMLStrBufA->Delete(cchDestPos, cchDestLen - cchSrc);
            }

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchDestPos, cchSrc, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenA(uCodePage, pszSrc, BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;
                    ::memcpy(BufWalk.GetStr(), pszSrc, sizeof(CHAR) * BufWalk.GetCCh());
                    pszSrc += BufWalk.GetCCh();
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringWStr* pMLStrW;

            if (SUCCEEDED(hr = pOwner->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrW)))
            {
                CMLStrWalkW StrWalk(pMLStrW, lDestPos, lDestLen, MLSTR_WRITE, (pcchActual || plActualLen));

                cchActual = 0;
                lActualLen = 0;
                while (StrWalk.Lock(hr))
                {
                    long cchWrittenA;
                    long lWrittenLen;

                    if (SUCCEEDED(hr = pOwner->ConvAStrToWStr(uCodePage, pszSrc, cchSrc, StrWalk.GetStr(), StrWalk.GetCCh(), &cchWrittenA, NULL, &lWrittenLen)))
                    {
                        pszSrc += cchWrittenA;
                        cchSrc -= cchWrittenA;
                        cchActual += cchWrittenA;
                        lActualLen += lWrittenLen;
                    }

                    StrWalk.Unlock(hr, lWrittenLen);
                }

                pMLStrW->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::SetStrBufA(long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufA* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->SetStrBufCommon(this, lDestPos, lDestLen, uCodePage, NULL, pSrcBuf, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrA::GetAStr(long lSrcPos, long lSrcLen, UINT uCodePageIn, UINT* puCodePageOut, CHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puCodePageOut);
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
#ifdef ASTRIMPL
    CMLStr::CLock Lock(FALSE, pOwner, hr);
#endif
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

#ifndef ASTRIMPL
    if (SUCCEEDED(hr = m_pOwner->CheckThread()) &&
        (m_pOwner->IsLocked() || puCodePageOut || uCodePageIn != m_pOwner->GetCodePage())) // !ASTRIMPL
    {
        hr = E_INVALIDARG;
    }
#endif

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
#ifdef ASTRIMPL
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();

        if (pszDest)
            cchActual = min(cchSrcLen, cchDest);
        else
            cchActual = cchSrcLen;

        if (uCodePageIn == CP_ACP)
            uCodePageIn = g_uACP;

        if (pMLStrBufA && (puCodePageOut || uCodePageIn == pOwner->GetCodePage()))
        {
            uCodePageIn = pOwner->GetCodePage();

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchSrcPos, cchActual, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenA(uCodePageIn, BufWalk.GetStr(), BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;

                    if (pszDest)
                    {
                        ::memcpy(pszDest, BufWalk.GetStr(), sizeof(CHAR) * BufWalk.GetCCh());
                        pszDest += BufWalk.GetCCh();
                    }
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringWStr* pMLStrW;

            if (SUCCEEDED(hr = pOwner->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrW)))
            {
                BOOL fDontHaveCodePageIn = (puCodePageOut != 0);
                CMLStrWalkW StrWalk(pMLStrW, lSrcPos, lSrcLen, (pcchActual || plActualLen));

                cchActual = 0;
                while (StrWalk.Lock(hr))
                {
                    LCID locale;
                    UINT uLocaleCodePage;
                    DWORD dwLocaleCodePages;
                    DWORD dwStrCodePages;
                    long cchWritten;
                    long lWrittenLen;

                    if (fDontHaveCodePageIn &&
                        SUCCEEDED(hr = pOwner->GetLocale(lSrcPos, lSrcLen, &locale, NULL, NULL)) &&
                        SUCCEEDED(hr = ::LocaleToCodePage(locale, &uLocaleCodePage)) &&
                        SUCCEEDED(hr = PrepareMLangCodePages()) &&
                        SUCCEEDED(hr = GetMLangCodePages()->CodePageToCodePages(uLocaleCodePage, &dwLocaleCodePages)) &&
                        SUCCEEDED(hr = GetMLangCodePages()->GetStrCodePages(StrWalk.GetStr(), StrWalk.GetCCh(), dwLocaleCodePages, &dwStrCodePages, NULL)))
                    {
                        fDontHaveCodePageIn = FALSE;
                        hr = GetMLangCodePages()->CodePagesToCodePage(dwStrCodePages, uLocaleCodePage, &uCodePageIn);
                    }

                    if (SUCCEEDED(hr) &&
                        SUCCEEDED(hr = pOwner->ConvWStrToAStr(pcchActual || plActualLen, uCodePageIn, StrWalk.GetStr(), StrWalk.GetCCh(), pszDest, cchDest, &cchWritten, NULL, &lWrittenLen)))
                    {
                        pszDest += cchWritten;
                        cchDest -= cchWritten;
                        cchActual += cchWritten;
                    }

                    StrWalk.Unlock(hr, lWrittenLen);
                }

                lActualLen = StrWalk.GetDoneLen();

                pMLStrW->Release();
            }
        }
    }
#else
        if (pszDest)
        {
            hr = E_FAIL; // TODO: Not implemented in this version
        }
        else
        {
            cchActual = cchSrcLen;
        }
    }

    if (SUCCEEDED(hr) && plActualLen)
        hr = m_pOwner->CalcLenA(m_pOwner->GetCodePage(), 0, cchActual, &lActualLen);
#endif

    if (SUCCEEDED(hr))
    {
#ifdef ASTRIMPL
        if (puCodePageOut)
            *puCodePageOut = uCodePageIn;
#endif
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (puCodePageOut)
            *puCodePageOut = 0;
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrA::GetStrBufA(long lSrcPos, long lSrcMaxLen, UINT* puDestCodePage, IMLangStringBufA** ppDestBuf, long* plDestLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puDestCodePage);
    ASSERT_WRITE_PTR_OR_NULL(ppDestBuf);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(FALSE, pOwner, hr);
    IMLangStringBufA* pMLStrBufA;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcMaxLen)) &&
        lSrcMaxLen <= 0)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        pMLStrBufA = pOwner->GetMLStrBufA();
        if (!pMLStrBufA)
            hr = MLSTR_E_STRBUFNOTAVAILABLE;
    }

    if (SUCCEEDED(hr))
    {
        if (puDestCodePage)
            *puDestCodePage = pOwner->GetCodePage();
        if (ppDestBuf)
        {
            pMLStrBufA->AddRef();
            *ppDestBuf = pMLStrBufA;
        }
        if (plDestLen)
            *plDestLen = lSrcMaxLen;
    }
    else
    {
        if (puDestCodePage)
            *puDestCodePage = 0;
        if (ppDestBuf)
            *ppDestBuf = NULL;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::LockAStr(long lSrcPos, long lSrcLen, long lFlags, UINT uCodePageIn, long cchRequest, UINT* puCodePageOut, CHAR** ppszDest, long* pcchDest, long* plDestLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puCodePageOut);
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(lFlags & MLSTR_WRITE, pOwner, hr);
    long cchSrcPos;
    long cchSrcLen;
    CHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;
    BOOL fDirectLock;

    if (SUCCEEDED(hr) && (!lFlags || (lFlags & ~pOwner->GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // No flags specified, or not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();
        fDirectLock = (pMLStrBufA && (puCodePageOut || uCodePageIn == pOwner->GetCodePage()));

        if (fDirectLock)
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (puCodePageOut)
                hr = GetAStr(lSrcPos, lSrcLen, 0, &uCodePageIn, NULL, 0, NULL, NULL);

            if (SUCCEEDED(hr) &&
                cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufA->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                pOwner->SetBufCCh(pOwner->GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufA->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

            if (plDestLen && SUCCEEDED(hr))
                hr = pOwner->CalcLenA(uCodePageIn, pszBuf, cchBuf, &lLockLen);
        }
        else
        {
            long cchSize;

            if (SUCCEEDED(hr = pOwner->CalcBufSizeA(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = pOwner->MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && ((lFlags & MLSTR_READ) || puCodePageOut))
                hr = GetAStr(lSrcPos, lSrcLen,  uCodePageIn, (puCodePageOut) ? &uCodePageIn : NULL, (lFlags & MLSTR_READ) ? pszBuf : NULL, cchBuf, (pcchDest) ? &cchBuf : NULL, (plDestLen) ? &lLockLen : NULL);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = Lock.FallThrough()))
    {
        hr = pOwner->GetLockInfo()->Lock((fDirectLock) ? pOwner->UnlockAStrDirect : pOwner->UnlockAStrIndirect, lFlags, uCodePageIn, pszBuf, lSrcPos, lSrcLen, cchSrcPos, cchBuf);
    }

    if (SUCCEEDED(hr))
    {
        if (puCodePageOut)
            *puCodePageOut = uCodePageIn;
        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (fDirectLock)
                pOwner->GetMLStrBufA()->UnlockBuf(pszBuf, 0, 0);
            else
                pOwner->MemFree(pszBuf);
        }

        if (puCodePageOut)
            *puCodePageOut = 0;
        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::UnlockAStr(const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
#ifdef ASTRIMPL
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    return GetOwner()->UnlockStrCommon(pszSrc, cchSrc, pcchActual, plActualLen);
#else
    return E_NOTIMPL; // !ASTRIMPL
#endif
}

STDMETHODIMP CMLStrA::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;
    return GetOwner()->SetLocale(lDestPos, lDestLen, locale);
}

STDMETHODIMP CMLStrA::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLocale(lSrcPos, lSrcMaxLen, plocale, plLocalePos, plLocaleLen);
}

#else // NEWMLSTR

#include "mlstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrA

CMLStrA::CMLStrA(void) :
    m_pAttrAStr(NULL),
    m_pAttrLocale(NULL),
    m_dwAttrAStrCookie(NULL),
    m_dwAttrLocaleCookie(NULL)
{
    DllAddRef();
    ::InitializeCriticalSection(&m_cs);
}

CMLStrA::~CMLStrA(void)
{
    if (m_dwAttrLocaleCookie)
        GetOwner()->UnregisterAttr(m_dwAttrLocaleCookie);
    if (m_dwAttrAStrCookie)
        GetOwner()->UnregisterAttr(m_dwAttrAStrCookie);
    if (m_pAttrLocale)
        m_pAttrLocale->Release();
    if (m_pAttrAStr)
        m_pAttrAStr->Release();

    ::DeleteCriticalSection(&m_cs);
    DllRelease();
}

HRESULT CMLStrA::GetAttrAStrReal(IMLStrAttrAStr** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrAStr)
    {
        IMLStrAttrAStr* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrAStr, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrAStrCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrAStr, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrAStr = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrAStr;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLStrA::GetAttrLocaleReal(IMLStrAttrLocale** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrLocale)
    {
        IMLStrAttrLocale* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrLocale, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrLocaleCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrLocale, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrLocale = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrLocale;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

STDMETHODIMP CMLStrA::LockMLStr(long lPos, long lLen, DWORD dwFlags, DWORD* pdwCookie, long* plActualPos, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->LockMLStr(lPos, lLen, dwFlags, pdwCookie, plActualPos, plActualLen);
}

STDMETHODIMP CMLStrA::UnlockMLStr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnlockMLStr(dwCookie);
}

STDMETHODIMP CMLStrA::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrA::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrA::RegisterAttr(IUnknown* pUnk, DWORD* pdwCookie)
{
    ASSERT_THIS;
    return GetOwner()->RegisterAttr(pUnk, pdwCookie);
}

STDMETHODIMP CMLStrA::UnregisterAttr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnregisterAttr(dwCookie);
}

STDMETHODIMP CMLStrA::EnumAttr(IEnumUnknown** ppEnumUnk)
{
    ASSERT_THIS;
    return GetOwner()->EnumAttr(ppEnumUnk);
}

STDMETHODIMP CMLStrA::FindAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk)
{
    ASSERT_THIS;
    return GetOwner()->FindAttr(riid, lParam, ppUnk);
}

STDMETHODIMP CMLStrA::SetAStr(long lDestPos, long lDestLen, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetAStr(lDestPos, lDestLen, uCodePage, pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::SetStrBufA(long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufA* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetStrBufA(lDestPos, lDestLen, uCodePage, pSrcBuf, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::GetAStr(long lSrcPos, long lSrcLen, UINT uCodePageIn, UINT* puCodePageOut, CHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetAStr(lSrcPos, lSrcLen, uCodePageIn, puCodePageOut, pszDest, cchDest, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::GetStrBufA(long lSrcPos, long lSrcMaxLen, UINT* puDestCodePage, IMLangStringBufA** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetStrBufA(lSrcPos, lSrcMaxLen, puDestCodePage, ppDestBuf, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrA::LockAStr(long lSrcPos, long lSrcLen, long lFlags, UINT uCodePageIn, long cchRequest, UINT* puCodePageOut, CHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->LockAStr(lSrcPos, lSrcLen, lFlags, uCodePageIn, cchRequest, puCodePageOut, ppszDest, pcchDest, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrA::UnlockAStr(const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrAStr* pAttr;
    HRESULT hr = GetAttrAStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->UnlockAStr(pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrA::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetLong(lDestPos, lDestLen, (long)locale);

    return hr;
}

STDMETHODIMP CMLStrA::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetLong(lSrcPos, lSrcMaxLen, (long*)plocale, plLocalePos, plLocaleLen);

    return hr;
}

#endif NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstrbuf.h ===
// MLStrBuf.h : Declaration and implementation of the IMLangStringBufW/A classes

#ifndef __MLSTRBUF_H_
#define __MLSTRBUF_H_

#include <mlang.h>

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufTempl

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
class CMLStrBufTempl : public IMLSB, public MEM, public ACCESS
{
public:
    CMLStrBufTempl(CHTYPE* psz = NULL, long cch = 0, void* pv = NULL, long cb = 0) : ACCESS(psz, cch, pv, cb)
#ifdef DEBUG
        {m_nLockCount = 0;}
#else
        {}
#endif
    ~CMLStrBufTempl(void) {ASSERT(!m_nLockCount);}

// IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return AddRefI();}
    STDMETHOD_(ULONG, Release)(void) {return ReleaseI();}
// IMLangStringBufW/A
    STDMETHOD(GetStatus)(long* plFlags, long* pcchBuf);
    STDMETHOD(LockBuf)(long cchOffset, long cchMaxLock, CHTYPE** ppszBuf, long* pcchBuf);
    STDMETHOD(UnlockBuf)(const CHTYPE* pszBuf, long cchOffset, long cchWrite);
    STDMETHOD(Insert)(long cchOffset, long cchMaxInsert, long* pcchActual) {ASSERT(!m_nLockCount); return InsertI(cchOffset, cchMaxInsert, pcchActual);}
    STDMETHOD(Delete)(long cchOffset, long cchDelete) {ASSERT(!m_nLockCount); return DeleteI(cchOffset, cchDelete);}

protected:
#ifdef DEBUG
    int m_nLockCount;
#endif
};

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        (sizeof(CHTYPE) == sizeof(CHAR)  && IsEqualIID(riid, IID_IMLangStringBufA)) ||
        (sizeof(CHTYPE) == sizeof(WCHAR) && IsEqualIID(riid, IID_IMLangStringBufW)))
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::GetStatus(long* plFlags, long* pcchBuf)
{
    if (plFlags)
        *plFlags = GetFlags();

    if (pcchBuf)
        *pcchBuf = m_cchStr;

    return S_OK;
}

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::LockBuf(long cchOffset, long cchMaxLock, CHTYPE** ppszBuf, long* pcchBuf)
{
    ASSERT(cchOffset >= 0 && cchOffset < m_cchStr);
    ASSERT(cchMaxLock >= 1 && cchMaxLock <= m_cchStr - cchOffset);
#ifdef DEBUG
    m_nLockCount++;
#endif

    if (ppszBuf)
        *ppszBuf = m_pszBuf + cchOffset;

    if (pcchBuf)
        *pcchBuf = cchMaxLock;

    return S_OK;
}

template <class CHTYPE, class IMLSB, class MEM, class ACCESS>
HRESULT CMLStrBufTempl<CHTYPE, IMLSB, MEM, ACCESS>::UnlockBuf(const CHTYPE* pszBuf, long cchOffset, long cchWrite)
{
    ASSERT(m_nLockCount > 0);
    ASSERT(cchOffset >= 0  && pszBuf + cchOffset >= m_pszBuf && pszBuf + cchOffset < m_pszBuf + m_cchStr);
    ASSERT(cchWrite == 0);
#ifdef DEBUG
    m_nLockCount--;
#endif

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufConst

template <class CHTYPE>
class CMLStrBufConst
{
protected:
    CMLStrBufConst(CHTYPE* psz, long cch, void*, long) : m_pszBuf(psz), m_cchStr(cch) {}
    long GetFlags(void) const {return MLSTR_READ;}
    HRESULT InsertI(long cchOffset, long cchMaxInsert, long* pcchActual) {ASSERT(FALSE); if (pcchActual) *pcchActual = 0; return E_FAIL;}
    HRESULT DeleteI(long cchOffset, long cchDelete) {ASSERT(FALSE); return E_FAIL;}

    CHTYPE* const m_pszBuf;
    const long m_cchStr;
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufVariable

template <class CHTYPE>
class CMLStrBufVariable
{
protected:
    CMLStrBufVariable(CHTYPE* psz, long cch, void* pv, long cb) {m_pszBuf = (CHTYPE*)pv; m_cchBuf = cb / sizeof(CHTYPE); m_cchOffset = psz - m_pszBuf; m_cchStr = cch;}
    ~CMLStrBufVariable(void) {if (m_pszBuf) MemFree(m_pszBuf);}
    long GetFlags(void) const {return MLSTR_READ | MLSTR_WRITE;}
    HRESULT InsertI(long cchOffset, long cchMaxInsert, long* pcchActual);
    HRESULT DeleteI(long cchOffset, long cchDelete);

    virtual LPVOID MemAlloc(ULONG) {return NULL;}
    virtual LPVOID MemRealloc(LPVOID, ULONG) {return NULL;}
    virtual void MemFree(LPVOID) {}
    virtual long RoundBufSize(long cchStr) {return (cchStr + 15) / 16;}

    CHTYPE* m_pszBuf;
    long m_cchBuf;
    long m_cchOffset;
    long m_cchStr;
};

template <class CHTYPE>
HRESULT CMLStrBufVariable<CHTYPE>::InsertI(long cchOffset, long cchMaxInsert, long* pcchActual)
{
    ASSERT(cchOffset >= 0 && cchOffset < m_cchStr);
    ASSERT(cchMaxInsert >= 0);

    long lShiftLeft = 0;
    long lShiftRight = 0;

    if (cchOffset < m_cchStr - cchOffset &&
        cchMaxInsert <= m_cchOffset)
    {
        lShiftLeft = cchMaxInsert;
    }
    else if (cchMaxInsert <= m_cchBuf - m_cchOffset - m_cchStr)
    {
        lShiftRight = cchMaxInsert;
    }
    else if (cchMaxInsert <= m_cchOffset)
    {
        lShiftLeft = cchMaxInsert;
    }
    else if (cchMaxInsert <= m_cchBuf - m_cchStr)
    {
        lShiftLeft = m_cchOffset;
        lShiftRight = cchMaxInsert - m_cchOffset;
    }
    else
    {
        void* pBuf;
        const long cchNew = RoundBufSize(m_cchOffset + m_cchStr + cchMaxInsert);

        if (!m_pszBuf)
            pBuf = MemAlloc(sizeof(*m_pszBuf) * cchNew);
        else
            pBuf = MemRealloc(m_pszBuf, sizeof(*m_pszBuf) * cchNew);

        if (pBuf)
        {
            m_pszBuf = (WCHAR*)pBuf;
            m_cchBuf = cchNew;
            lShiftRight = cchMaxInsert;
        }
        else
        {
            lShiftRight = m_cchBuf - m_cchOffset - m_cchStr;
            lShiftLeft = cchMaxInsert - lShiftRight;

            if (!pcchActual)
                return E_OUTOFMEMORY;
        }
    }

    if (lShiftLeft > 0)
    {
        if (cchOffset)
            ::memmove(m_pszBuf + m_cchOffset - lShiftLeft, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * cchOffset);
        m_cchOffset -= lShiftLeft;
        m_cchStr += lShiftLeft;
    }

    if (lShiftRight > 0)
    {
        if (m_cchStr - cchOffset)
            ::memmove(m_pszBuf + m_cchOffset + lShiftRight, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * (m_cchStr - cchOffset));
        m_cchStr += lShiftRight;
    }

    if (pcchActual)
        *pcchActual = lShiftLeft + lShiftRight;

    return S_OK;
}

template <class CHTYPE>
HRESULT CMLStrBufVariable<CHTYPE>::DeleteI(long cchOffset, long cchDelete)
{
    ASSERT(cchOffset >= 0 && cchOffset < m_cchStr);
    ASSERT(cchDelete >= 0 && cchDelete < m_cchStr - cchOffset);

    long cchShrink = m_cchBuf - RoundBufSize(RoundBufSize(m_cchStr - cchDelete) + 1);
    cchShrink = max(cchShrink, 0);

    const long cchRight = m_cchStr - cchOffset - cchDelete;
    if (cchOffset < cchRight && m_cchBuf - m_cchOffset - m_cchStr >= cchShrink)
    {
        if (cchOffset)
            ::memmove(m_pszBuf + m_cchOffset + cchDelete, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * cchOffset);
        m_cchOffset += cchDelete;
        m_cchStr -= cchDelete;
    }
    else if (m_cchBuf - m_cchOffset - m_cchStr + cchDelete >= cchShrink)
    {
        if (cchRight)
            ::memmove(m_pszBuf + m_cchOffset + cchOffset, m_pszBuf + m_cchOffset + cchDelete, sizeof(*m_pszBuf) * cchRight);
        m_cchStr -= cchDelete;
    }
    else
    {
        if (cchOffset)
            ::memmove(m_pszBuf, m_pszBuf + m_cchOffset, sizeof(*m_pszBuf) * cchOffset);
        if (cchRight)
            ::memmove(m_pszBuf + cchOffset, m_pszBuf + m_cchOffset + cchDelete, sizeof(*m_pszBuf) * cchRight);

        m_cchOffset = 0;
        m_cchStr -= cchDelete;
    }

    if (cchShrink)
    {
        void* pBuf = MemRealloc(m_pszBuf, sizeof(*m_pszBuf) * (m_cchBuf - cchShrink));

        if (pBuf)
        {
            m_pszBuf = (WCHAR*)pBuf;
            m_cchBuf -= cchShrink;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufStack

class CMLStrBufStack
{
protected:
#ifdef DEBUG
    inline CMLStrBufStack(void) {m_cRef = 0;}
#else
    inline CMLStrBufStack(void) {}
#endif
    inline ~CMLStrBufStack(void) {ASSERT(!m_cRef);}

    ULONG AddRefI(void)
    {
#ifdef DEBUG
        m_cRef++;
        return m_cRef;
#else
        ASSERT(FALSE);
        return 0;
#endif
    }

    ULONG ReleaseI(void)
    {
#ifdef DEBUG
        m_cRef--;
        ASSERT(m_cRef >= 0);
        return m_cRef;
#else
        ASSERT(FALSE);
        return 0;
#endif
    }

#ifdef DEBUG
    int m_cRef;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrBufHeap

class CMLStrBufHeap
{
protected:
    inline CMLStrBufHeap(void) {m_cRef = 0;}
    inline ~CMLStrBufHeap(void) {ASSERT(!m_cRef);}
    ULONG AddRefI(void) {m_cRef++; return m_cRef;}
    ULONG ReleaseI(void) {m_cRef--; const int cRef = m_cRef; if (!cRef) delete this; return cRef;}

    int m_cRef;
};

typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufStack, CMLStrBufConst<WCHAR> > CMLStrBufConstStackW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufStack, CMLStrBufConst<CHAR>  > CMLStrBufConstStackA;
typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufStack, CMLStrBufVariable<WCHAR> > CMLStrBufStackW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufStack, CMLStrBufVariable<CHAR>  > CMLStrBufStackA;
typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufHeap,  CMLStrBufConst<WCHAR> > CMLStrBufConstW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufHeap,  CMLStrBufConst<CHAR>  > CMLStrBufConstA;
typedef CMLStrBufTempl<WCHAR, IMLangStringBufW, CMLStrBufHeap,  CMLStrBufVariable<WCHAR> > CMLStrBufW;
typedef CMLStrBufTempl<CHAR,  IMLangStringBufA, CMLStrBufHeap,  CMLStrBufVariable<CHAR>  > CMLStrBufA;

#ifdef UNICODE
typedef CMLStrBufConstStackW CMLStrBufConstStackT;
typedef CMLStrBufStackW CMLStrBufStackT;
typedef CMLStrBufConstW CMLStrBufConstT;
typedef CMLStrBufW CMLStrBufT;
#else
typedef CMLStrBufConstStackA CMLStrBufConstStackT;
typedef CMLStrBufStackA CMLStrBufStackT;
typedef CMLStrBufConstA CMLStrBufConstT;
typedef CMLStrBufA CMLStrBufT;
#endif

#endif //__MLSTRBUF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstrw.cpp ===
// MLStrW.cpp : Implementation of CMLStrW
#include "private.h"

#ifndef NEWMLSTR

#ifdef ASTRIMPL
#include "mlstr.h"
#include "mlsbwalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrW

STDMETHODIMP CMLStrW::Sync(BOOL fNoAccess)
{
    ASSERT_THIS;
    return GetOwner()->Sync(fNoAccess);
}

STDMETHODIMP CMLStrW::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrW::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrW::GetMLStr(long lSrcPos, long lSrcLen, IUnknown* pUnkOuter, DWORD dwClsContext, const IID* piid, IUnknown** ppDestMLStr, long* plDestPos, long* plDestLen)
{
    ASSERT_THIS;
    return GetOwner()->GetMLStr(lSrcPos, lSrcLen, pUnkOuter, dwClsContext, piid, ppDestMLStr, plDestPos, plDestLen);
}

STDMETHODIMP CMLStrW::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(TRUE, pOwner, hr);
    long cchDestPos;
    long cchDestLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && (pOwner->GetBufFlags() & MLSTR_WRITE))
        hr = E_INVALIDARG; // Not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        IMLangStringBufW* const pMLStrBufW = pOwner->GetMLStrBufW();

        if (pMLStrBufW)
        {
            if (cchSrc > cchDestLen)
            {
                hr = pMLStrBufW->Insert(cchDestPos, cchSrc - cchDestLen, (pcchActual || plActualLen) ? &cchSrc : NULL);
                cchSrc += cchDestLen;
            }
            else if  (cchSrc < cchDestLen)
            {
                hr = pMLStrBufW->Delete(cchDestPos, cchDestLen - cchSrc);
            }

            CMLStrBufWalkW BufWalk(pMLStrBufW, cchDestPos, cchSrc, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenW(pszSrc, BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;
                    ::memcpy(BufWalk.GetStr(), pszSrc, sizeof(WCHAR) * BufWalk.GetCCh());
                    pszSrc += BufWalk.GetCCh();
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA(); // Should succeed because PrepareMLStrBuf() above was succeeded
            const UINT uCodePage = pOwner->GetCodePage();
            long cchSrcA;

            if (SUCCEEDED(hr = pOwner->ConvWStrToAStr(pcchActual || plActualLen, uCodePage, pszSrc, cchSrc, NULL, 0, &cchSrcA, NULL, NULL)))
            {
                if (cchSrcA > cchDestLen)
                {
                    hr = pMLStrBufA->Insert(cchDestPos, cchSrcA - cchDestLen, (pcchActual || plActualLen) ? &cchSrcA : NULL);
                    cchSrcA += cchDestLen;
                }
                else if  (cchSrcA < cchDestLen)
                {
                    hr = pMLStrBufA->Delete(cchDestPos, cchDestLen - cchSrcA);
                }
            }

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchDestPos, cchSrcA, (pcchActual || plActualLen));

            cchActual = 0;
            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long cchWrittenA;
                long cchWrittenW;
                long lWrittenLen;

                if (SUCCEEDED(hr = pOwner->ConvWStrToAStr(pcchActual || plActualLen, uCodePage, pszSrc, cchSrc, BufWalk.GetStr(), BufWalk.GetCCh(), &cchWrittenA, &cchWrittenW, &lWrittenLen)))
                {
                    pszSrc += cchWrittenW;
                    cchSrc -= cchWrittenW;
                    cchActual += cchWrittenW;
                    lActualLen += lWrittenLen;
                }

                BufWalk.Unlock(hr, cchWrittenA);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrW::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->SetStrBufCommon(this, lDestPos, lDestLen, 0, pSrcBuf, NULL, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrW::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(FALSE, pOwner, hr);
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = pOwner->GetMLStrBufW();
        IMLangStringBufA* const pMLStrBufA = pOwner->GetMLStrBufA();

        if (pszDest)
            cchActual = min(cchSrcLen, cchDest);
        else
            cchActual = cchSrcLen;

        if (pMLStrBufW)
        {
            CMLStrBufWalkW BufWalk(pMLStrBufW, cchSrcPos, cchActual, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = pOwner->CalcLenW(BufWalk.GetStr(), BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;

                    if (pszDest)
                    {
                        ::memcpy(pszDest, BufWalk.GetStr(), sizeof(WCHAR) * BufWalk.GetCCh());
                        pszDest += BufWalk.GetCCh();
                    }
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else if (pMLStrBufA)
        {
            CMLStrBufWalkA BufWalk(pMLStrBufA, cchSrcPos, cchActual, (pcchActual || plActualLen));

            cchActual = 0;
            lActualLen = 0;
            while ((!pszDest || cchDest > 0) && BufWalk.Lock(hr))
            {
                CHAR* const pszBuf = BufWalk.GetStr();
                long cchWrittenA;
                long cchWrittenW;
                long lWrittenLen;

                if (SUCCEEDED(hr = pOwner->ConvAStrToWStr(pOwner->GetCodePage(), pszBuf, BufWalk.GetCCh(), pszDest, cchDest, &cchWrittenA, &cchWrittenW, &lWrittenLen)))
                {
                    lActualLen += lWrittenLen;
                    cchActual += cchWrittenW;

                    if (pszDest)
                    {
                        pszDest += cchWrittenW;
                        cchDest -= cchWrittenW;
                    }
                }

                BufWalk.Unlock(hr, cchWrittenA);
            }
        }
        else
        {
            ASSERT(cchActual == 0); // MLStrBuf is not available
            lActualLen = 0;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrW::GetStrBufW(long lSrcPos, long lSrcMaxLen, IMLangStringBufW** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppDestBuf);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(FALSE, pOwner, hr);
    IMLangStringBufW* pMLStrBufW;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcMaxLen)) &&
        lSrcMaxLen <= 0)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        pMLStrBufW = pOwner->GetMLStrBufW();
        if (!pMLStrBufW)
            hr = MLSTR_E_STRBUFNOTAVAILABLE;
    }

    if (SUCCEEDED(hr))
    {
        if (ppDestBuf)
        {
            pMLStrBufW->AddRef();
            *ppDestBuf = pMLStrBufW;
        }
        if (plDestLen)
            *plDestLen = lSrcMaxLen;
    }
    else
    {
        if (ppDestBuf)
            *ppDestBuf = NULL;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrW::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    POWNER const pOwner = GetOwner();
    HRESULT hr = pOwner->CheckThread();
    CMLStr::CLock Lock(lFlags & MLSTR_WRITE, pOwner, hr);
    long cchSrcPos;
    long cchSrcLen;
    WCHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;
    BOOL fDirectLock;

    if (SUCCEEDED(hr) && (!lFlags || (lFlags & ~pOwner->GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // No flags specified, or not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = pOwner->PrepareMLStrBuf()) &&
        SUCCEEDED(hr = pOwner->RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = pOwner->GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = pOwner->GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = pOwner->GetMLStrBufW();
        fDirectLock = (pMLStrBufW != 0);

        if (fDirectLock)
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufW->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                pOwner->SetBufCCh(pOwner->GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufW->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

            if (plDestLen && SUCCEEDED(hr))
                hr = pOwner->CalcLenW(pszBuf, cchBuf, &lLockLen);
        }
        else
        {
            long cchSize;

            if (SUCCEEDED(hr = pOwner->CalcBufSizeW(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = pOwner->MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && (lFlags & MLSTR_READ))
                hr = GetWStr(lSrcPos, lSrcLen,  pszBuf, cchBuf, (pcchDest) ? &cchBuf : NULL, (plDestLen) ? &lLockLen : NULL);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = Lock.FallThrough()))
    {
        hr = pOwner->GetLockInfo()->Lock((fDirectLock) ? pOwner->UnlockWStrDirect : pOwner->UnlockWStrIndirect, lFlags, 0, pszBuf, lSrcPos, lSrcLen, cchSrcPos, cchBuf);
    }

    if (SUCCEEDED(hr))
    {
        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (fDirectLock)
                pOwner->GetMLStrBufW()->UnlockBuf(pszBuf, 0, 0);
            else
                pOwner->MemFree(pszBuf);
        }

        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrW::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    return GetOwner()->UnlockStrCommon(pszSrc, cchSrc, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrW::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;
    return GetOwner()->SetLocale(lDestPos, lDestLen, locale);
}

STDMETHODIMP CMLStrW::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLocale(lSrcPos, lSrcMaxLen, plocale, plLocalePos, plLocaleLen);
}
#endif

#else // NEWMLSTR

#include "mlstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrW

CMLStrW::CMLStrW(void) :
    m_pAttrWStr(NULL),
    m_pAttrLocale(NULL),
    m_dwAttrWStrCookie(NULL),
    m_dwAttrLocaleCookie(NULL)
{
    DllAddRef();
    ::InitializeCriticalSection(&m_cs);
}

CMLStrW::~CMLStrW(void)
{
    if (m_dwAttrLocaleCookie)
        GetOwner()->UnregisterAttr(m_dwAttrLocaleCookie);
    if (m_dwAttrWStrCookie)
        GetOwner()->UnregisterAttr(m_dwAttrWStrCookie);
    if (m_pAttrLocale)
        m_pAttrLocale->Release();
    if (m_pAttrWStr)
        m_pAttrWStr->Release();

    ::DeleteCriticalSection(&m_cs);
    DllRelease();
}

HRESULT CMLStrW::GetAttrWStrReal(IMLStrAttrWStr** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrWStr)
    {
        IMLStrAttrWStr* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrWStr, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrWStrCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrWStr, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrWStr = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrWStr;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

HRESULT CMLStrW::GetAttrLocaleReal(IMLStrAttrLocale** ppAttr)
{
    HRESULT hr = S_OK;

    ::EnterCriticalSection(&m_cs);

    if (!m_pAttrLocale)
    {
        IMLStrAttrLocale* pAttr;

        hr = ::CoCreateInstance(CLSID_CMLStrAttrLocale, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&pAttr);

        if (SUCCEEDED(hr))
            hr = GetOwner()->RegisterAttr(pAttr, &m_dwAttrLocaleCookie);

        if (SUCCEEDED(hr))
        {
            pAttr->Release();

            hr = GetOwner()->FindAttr(IID_IMLStrAttrLocale, 0, (IUnknown**)&pAttr);
        }

        if (SUCCEEDED(hr))
            m_pAttrLocale = pAttr;
    }

    if (ppAttr)
        *ppAttr = m_pAttrLocale;

    ::LeaveCriticalSection(&m_cs);

    return hr;
}

STDMETHODIMP CMLStrW::LockMLStr(long lPos, long lLen, DWORD dwFlags, DWORD* pdwCookie, long* plActualPos, long* plActualLen)
{
    ASSERT_THIS;
    return GetOwner()->LockMLStr(lPos, lLen, dwFlags, pdwCookie, plActualPos, plActualLen);
}

STDMETHODIMP CMLStrW::UnlockMLStr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnlockMLStr(dwCookie);
}

STDMETHODIMP CMLStrW::GetLength(long* plLen)
{
    ASSERT_THIS;
    return GetOwner()->GetLength(plLen);
}

STDMETHODIMP CMLStrW::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    ASSERT_THIS;
    return GetOwner()->SetMLStr(lDestPos, lDestLen, pSrcMLStr, lSrcPos, lSrcLen);
}

STDMETHODIMP CMLStrW::RegisterAttr(IUnknown* pUnk, DWORD* pdwCookie)
{
    ASSERT_THIS;
    return GetOwner()->RegisterAttr(pUnk, pdwCookie);
}

STDMETHODIMP CMLStrW::UnregisterAttr(DWORD dwCookie)
{
    ASSERT_THIS;
    return GetOwner()->UnregisterAttr(dwCookie);
}

STDMETHODIMP CMLStrW::EnumAttr(IEnumUnknown** ppEnumUnk)
{
    ASSERT_THIS;
    return GetOwner()->EnumAttr(ppEnumUnk);
}

STDMETHODIMP CMLStrW::FindAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk)
{
    ASSERT_THIS;
    return GetOwner()->FindAttr(riid, lParam, ppUnk);
}

STDMETHODIMP CMLStrW::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetWStr(lDestPos, lDestLen, pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetStrBufW(lDestPos, lDestLen, pSrcBuf, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetWStr(lSrcPos, lSrcLen, pszDest, cchDest, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::GetStrBufW(long lSrcPos, long lSrcMaxLen, IMLangStringBufW** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetStrBufW(lSrcPos, lSrcMaxLen, ppDestBuf, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrW::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->LockWStr(lSrcPos, lSrcLen, lFlags, cchRequest, ppszDest, pcchDest, plDestLen);

    return hr;
}

STDMETHODIMP CMLStrW::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;

    IMLStrAttrWStr* pAttr;
    HRESULT hr = GetAttrWStr(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->UnlockWStr(pszSrc, cchSrc, pcchActual, plActualLen);

    return hr;
}

STDMETHODIMP CMLStrW::SetLocale(long lDestPos, long lDestLen, LCID locale)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->SetLong(lDestPos, lDestLen, (long)locale);

    return hr;
}

STDMETHODIMP CMLStrW::GetLocale(long lSrcPos, long lSrcMaxLen, LCID* plocale, long* plLocalePos, long* plLocaleLen)
{
    ASSERT_THIS;

    IMLStrAttrLocale* pAttr;
    HRESULT hr = GetAttrLocale(&pAttr);

    if (SUCCEEDED(hr))
        hr = pAttr->GetLong(lSrcPos, lSrcMaxLen, (long*)plocale, plLocalePos, plLocaleLen);

    return hr;
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlswalk.h ===
// MLSWalk.h : Declaration of the CMLStrWalkW and CMLStrWalkA

#ifndef __MLSWALK_H_
#define __MLSWALK_H_

/////////////////////////////////////////////////////////////////////////////
// CMLStrWalkW

class CMLStrWalkW
{
public:
    inline CMLStrWalkW(IMLangStringWStr* pMLStrW, long lPos, long lLen, long lFlags = MLSTR_READ, BOOL fCanStopAtMiddle = FALSE);
    BOOL Lock(HRESULT& rhr);
    void Unlock(HRESULT& rhr, long lActualLen = 0);
    inline WCHAR* GetStr(void);
    inline long GetCCh(void) const;
    long GetPos(void) const {return m_lPos + m_lDoneLen;}
    long GetLen(void) const {return m_lLen - m_lDoneLen;}
    long GetDoneLen(void) const {return m_lDoneLen;}

protected:
    IMLangStringWStr* m_pMLStr;
    BOOL m_fCanStopAtMiddle;
    long m_lPos;
    long m_lLen;
    long m_lFlags;
    long m_lDoneLen;
    WCHAR* m_pszBuf;
    long m_cchBuf;
    long m_lLockLen;
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrWalkW inline functions

CMLStrWalkW::CMLStrWalkW(IMLangStringWStr* pMLStr, long lPos, long lLen, long lFlags, BOOL fCanStopAtMiddle) :
    m_pMLStr(pMLStr),
    m_fCanStopAtMiddle(fCanStopAtMiddle)
{
    m_lPos = lPos;
    m_lLen = lLen;
    m_lFlags = lFlags;
    m_lDoneLen = 0;

    m_pszBuf = NULL; // Mark as it's not locked
}

WCHAR* CMLStrWalkW::GetStr(void)
{
    ASSERT(m_pszBuf); // Not locked
    return m_pszBuf;
}

long CMLStrWalkW::GetCCh(void) const
{
    ASSERT(m_pszBuf); // Not locked
    if (m_pszBuf)
        return m_cchBuf;
    else
        return 0;
}

#endif //__MLSWALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstra.h ===
#ifndef NEWMLSTR

// MLStrA.h : Declaration of the CMLStrA

#ifndef __MLSTRA_H_
#define __MLSTRA_H_

#include "mlatl.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrA
class ATL_NO_VTABLE CMLStrA :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringAStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
#ifdef ASTRIMPL
    CMLStrA(void);
#endif

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrA)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringAStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(Sync)(/*[in]*/ BOOL fNoAccess);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(GetMLStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ IUnknown* pUnkOuter, /*[in]*/ DWORD dwClsContext, /*[in]*/ const IID* piid, /*[out]*/ IUnknown** ppDestMLStr, /*[out]*/ long* plDestPos, /*[out]*/ long* plDestLen);
// IMLangStringAStr
    STDMETHOD(SetAStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufA)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in]*/ IMLangStringBufA* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ UINT uCodePageIn, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(cchDest)]*/ CHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufA)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ UINT* puDestCodePage, /*[out]*/ IMLangStringBufA** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ UINT uCodePageIn, /*[in]*/ long cchRequest, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(,*pcchDest)]*/ CHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockAStr)(/*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
#ifdef ASTRIMPL
    ~CMLStrA(void);
#endif
    POWNER GetOwner(void) const {return m_pOwner;}
#ifdef ASTRIMPL
    HRESULT PrepareMLangCodePages(void)
    {
        HRESULT hr = S_OK;
        if (!m_pMLCPs)
            hr = ::CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMLangCodePages, (void**)&m_pMLCPs);
        return hr;
    }
    IMLangCodePages* GetMLangCodePages(void) const {return m_pMLCPs;}

    IMLangCodePages* m_pMLCPs;
#endif
};

#endif //__MLSTRA_H_

#else // NEWMLSTR

// MLStrA.h : Declaration of the CMLStrA

#ifndef __MLSTRA_H_
#define __MLSTRA_H_

#include "mlatl.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrA
class ATL_NO_VTABLE CMLStrA :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringAStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
    CMLStrA(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrA)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringAStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(LockMLStr)(/*[in]*/ long lPos, /*[in]*/ long lLen, /*[in]*/ DWORD dwFlags, /*[out]*/ DWORD* pdwCookie, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
    STDMETHOD(UnlockMLStr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(RegisterAttr)(/*[in]*/ IUnknown* pUnk, /*[out]*/ DWORD* pdwCookie);
    STDMETHOD(UnregisterAttr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(EnumAttr)(/*[out]*/ IEnumUnknown** ppEnumUnk);
    STDMETHOD(FindAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk);
// IMLangStringAStr
    STDMETHOD(SetAStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufA)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in]*/ IMLangStringBufA* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ UINT uCodePageIn, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(cchDest)]*/ CHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufA)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ UINT* puDestCodePage, /*[out]*/ IMLangStringBufA** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ UINT uCodePageIn, /*[in]*/ long cchRequest, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(,*pcchDest)]*/ CHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockAStr)(/*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
    ~CMLStrA(void);
    POWNER GetOwner(void) const {return m_pOwner;}
    inline HRESULT GetAttrAStr(IMLStrAttrAStr** ppAttr);
    inline HRESULT GetAttrLocale(IMLStrAttrLocale** ppAttr);
    HRESULT GetAttrAStrReal(IMLStrAttrAStr** ppAttr);
    HRESULT GetAttrLocaleReal(IMLStrAttrLocale** ppAttr);

    CRITICAL_SECTION m_cs;
    IMLStrAttrAStr* m_pAttrAStr;
    IMLStrAttrLocale* m_pAttrLocale;
    DWORD m_dwAttrAStrCookie; // Returned by RegisterAttr
    DWORD m_dwAttrLocaleCookie; // Returned by RegisterAttr
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrA inline-line functions
HRESULT CMLStrA::GetAttrAStr(IMLStrAttrAStr** ppAttr)
{
    if (m_pAttrAStr)
    {
        if (ppAttr)
            *ppAttr = m_pAttrAStr;

        return S_OK;
    }
    else
    {
        return GetAttrAStrReal(ppAttr);
    }
}

HRESULT CMLStrA::GetAttrLocale(IMLStrAttrLocale** ppAttr)
{
    if (m_pAttrLocale)
    {
        if (ppAttr)
            *ppAttr = m_pAttrLocale;

        return S_OK;
    }
    else
    {
        return GetAttrLocaleReal(ppAttr);
    }
}

#endif //__MLSTRA_H_

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\mlstrw.h ===
#ifndef NEWMLSTR

// MLStrW.h : Declaration of the CMLStrW

#ifndef __MLSTRW_H_
#define __MLSTRW_H_

#include "mlatl.h"
#include "mlstrbuf.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrW
class ATL_NO_VTABLE CMLStrW :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringWStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrW)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringWStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(Sync)(/*[in]*/ BOOL fNoAccess);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(GetMLStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ IUnknown* pUnkOuter, /*[in]*/ DWORD dwClsContext, /*[in]*/ const IID* piid, /*[out]*/ IUnknown** ppDestMLStr, /*[out]*/ long* plDestPos, /*[out]*/ long* plDestLen);
// IMLangStringWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
    POWNER GetOwner(void) const {return m_pOwner;}
};

#endif //__MLSTRW_H_

#else // NEWMLSTR

// MLStrW.h : Declaration of the CMLStrW

#ifndef __MLSTRW_H_
#define __MLSTRW_H_

#include "mlatl.h"

class CMLStr;

/////////////////////////////////////////////////////////////////////////////
// CMLStrW
class ATL_NO_VTABLE CMLStrW :
    public CComTearOffObjectBase<CMLStr>,
    public IMLangStringWStr
{
    typedef CComObject<CMLStr>* POWNER;

public:
    CMLStrW(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrW)
        COM_INTERFACE_ENTRY(IMLangString)
        COM_INTERFACE_ENTRY(IMLangStringWStr)
    END_COM_MAP()

public:
// IMLangString
    STDMETHOD(LockMLStr)(/*[in]*/ long lPos, /*[in]*/ long lLen, /*[in]*/ DWORD dwFlags, /*[out]*/ DWORD* pdwCookie, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
    STDMETHOD(UnlockMLStr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(GetLength)(/*[out, retval]*/ long* plLen);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
    STDMETHOD(RegisterAttr)(/*[in]*/ IUnknown* pUnk, /*[out]*/  DWORD* pdwCookie);
    STDMETHOD(UnregisterAttr)(/*[in]*/ DWORD dwCookie);
    STDMETHOD(EnumAttr)(/*[out]*/ IEnumUnknown** ppEnumUnk);
    STDMETHOD(FindAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk);
// IMLangStringWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetLocale)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ LCID locale);
    STDMETHOD(GetLocale)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ LCID* plocale, /*[out]*/ long* plLocalePos, /*[out]*/ long* plLocaleLen);

protected:
    ~CMLStrW(void);
    POWNER GetOwner(void) const {return m_pOwner;}
    inline HRESULT GetAttrWStr(IMLStrAttrWStr** ppAttr);
    inline HRESULT GetAttrLocale(IMLStrAttrLocale** ppAttr);
    HRESULT GetAttrWStrReal(IMLStrAttrWStr** ppAttr);
    HRESULT GetAttrLocaleReal(IMLStrAttrLocale** ppAttr);

    CRITICAL_SECTION m_cs;
    IMLStrAttrWStr* m_pAttrWStr;
    IMLStrAttrLocale* m_pAttrLocale;
    DWORD m_dwAttrWStrCookie; // Returned by RegisterAttr
    DWORD m_dwAttrLocaleCookie; // Returned by RegisterAttr
};

/////////////////////////////////////////////////////////////////////////////
// CMLStrW inline-line functions
HRESULT CMLStrW::GetAttrWStr(IMLStrAttrWStr** ppAttr)
{
    if (m_pAttrWStr)
    {
        if (ppAttr)
            *ppAttr = m_pAttrWStr;

        return S_OK;
    }
    else
    {
        return GetAttrWStrReal(ppAttr);
    }
}

HRESULT CMLStrW::GetAttrLocale(IMLStrAttrLocale** ppAttr)
{
    if (m_pAttrLocale)
    {
        if (ppAttr)
            *ppAttr = m_pAttrLocale;

        return S_OK;
    }
    else
    {
        return GetAttrLocaleReal(ppAttr);
    }
}

#endif //__MLSTRW_H_

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\reg.cpp ===
#include "private.h"

//
//  CLSID for MLANG objects
//
typedef struct tagCLSIDOBJ
{
    LPCTSTR szCLSID;
    LPCTSTR szDesc;
}   CLSIDOBJ, *LPCLSIDOBJ;

const CLSIDOBJ clsidObj[] =
{
    { TEXT("CLSID\\{275C23E2-3747-11D0-9FEA-00AA003F8646}"), TEXT("Multi Language Support") },          // CLSID_MLANG
    { TEXT("CLSID\\{C04D65CF-B70D-11D0-B188-00AA0038C969}"), TEXT("Multi Language String") },           // CLSID_MLANG
    { TEXT("CLSID\\{D66D6F99-CDAA-11D0-B822-00C04FC9B31F}"), TEXT("Multi Language ConvertCharset") },   // CLSID_MLANG
    { NULL, NULL }
};

LPCTSTR szInProcServer = TEXT("InProcServer32");
LPCTSTR szThreadingModel = TEXT("ThreadingModel");
LPCTSTR szThreadingModelValue = TEXT("Both");


HRESULT RegisterServerInfo(void)
{
    HKEY hKey = NULL, hKeySub = NULL;
    DWORD dwAction = 0;
    int i = 0;
    TCHAR szModule[MAX_PATH];
    HRESULT hr = S_OK;

    if (!GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule)))
        hr = E_FAIL;

    while (SUCCEEDED(hr) && clsidObj[i].szCLSID)
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, clsidObj[i].szCLSID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
        {
            ASSERT(NULL != hKey);
            if (ERROR_SUCCESS != RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)clsidObj[i].szDesc, (lstrlen(clsidObj[i].szDesc) + 1) * sizeof(TCHAR)))
                hr = E_FAIL;

            if (ERROR_SUCCESS == RegCreateKeyEx(hKey, szInProcServer, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, &dwAction))
            {
                ASSERT(NULL != hKeySub);
                if (ERROR_SUCCESS != RegSetValueEx(hKeySub, NULL, 0, REG_SZ, (LPBYTE)szModule, (lstrlen(szModule) + 1) * sizeof(TCHAR)))
                    hr = E_FAIL;
                if (ERROR_SUCCESS != RegSetValueEx(hKeySub, szThreadingModel, 0, REG_SZ, (LPBYTE)szThreadingModelValue, (lstrlen(szThreadingModelValue) + 1) * sizeof(TCHAR)))
                    hr = E_FAIL;

                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }
            else
                hr = E_FAIL;

            RegCloseKey(hKey);
            hKey = NULL;
        }
        else
            hr = E_FAIL;
        i++;
    }
    return hr;
}

HRESULT UnregisterServerInfo(void)
{
    HKEY hKey = NULL;
    int i = 0;
    HRESULT hr = S_OK;

    while (clsidObj[i].szCLSID)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, clsidObj[i].szCLSID, 0, KEY_ALL_ACCESS, &hKey))
        {
            ASSERT(NULL != hKey);
            if (ERROR_SUCCESS != RegDeleteKey(hKey, szInProcServer))
                hr = E_FAIL;

            RegCloseKey(hKey);
            hKey = NULL;

            if (ERROR_SUCCESS != RegDeleteKey(HKEY_CLASSES_ROOT, clsidObj[i].szCLSID))
                hr = E_FAIL;
        }
        else
            hr = S_FALSE;
        i++;
    }
    return hr;
}



// Legacy code for Outlook Express and other clients who depend on MLang created MIME DB in registry
// Those client should switch to MLang interface for MIME data

long PrivRegSetValueEx(HKEY hKey, LPCTSTR lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData, BOOL bOverWrite)
{
    long lRet = ERROR_SUCCESS;

    if (bOverWrite || ERROR_SUCCESS != RegQueryValueEx(hKey, lpValueName, 0, NULL, NULL, NULL))
        lRet = RegSetValueEx(hKey, lpValueName, 0, dwType, lpData, cbData);
    return lRet;
}

//
//  MIME database Key or Value name
//
LPCTSTR szMIMEDatabase = TEXT("MIME\\Database");
LPCTSTR szCharset = TEXT("Charset");
LPCTSTR szRfc1766 = TEXT("Rfc1766");
LPCTSTR szCodepage = TEXT("Codepage");
LPCTSTR szInternetEncoding = TEXT("InternetEncoding");
LPCTSTR szAliasForCharset = TEXT("AliasForCharset");
LPCTSTR szHeaderCharset = TEXT("HeaderCharset");
LPCTSTR szBodyCharset = TEXT("BodyCharset");
LPCTSTR szWebCharset = TEXT("WebCharset");
LPCTSTR szFixedWidthFont = TEXT("FixedWidthFont");
LPCTSTR szProportionalFont = TEXT("ProportionalFont");
LPCTSTR szDescription = TEXT("Description");
LPCTSTR szFamily = TEXT("Family");
LPCTSTR szLevel = TEXT("Level");
LPCTSTR szEncoding = TEXT("Encoding");

//
//  RFC1766 registry data at MIME\Database
//
typedef struct tagREGRFC1766
{
    LPCTSTR szLCID;
    LPCTSTR szAcceptLang;
    UINT    uidLCID;
}   REGRFC1766, *LPREGRFC1766;

const REGRFC1766 regRfc1766[] =
{
    { TEXT("0436"), TEXT("af"),    IDS_RFC1766_LCID0436 },
    { TEXT("041C"), TEXT("sq"),    IDS_RFC1766_LCID041C },
    { TEXT("0001"), TEXT("ar"),    IDS_RFC1766_LCID0001 },
    { TEXT("0401"), TEXT("ar-sa"), IDS_RFC1766_LCID0401 },
    { TEXT("0801"), TEXT("ar-iq"), IDS_RFC1766_LCID0801 },
    { TEXT("0C01"), TEXT("ar-eg"), IDS_RFC1766_LCID0C01 },
    { TEXT("1001"), TEXT("ar-ly"), IDS_RFC1766_LCID1001 },
    { TEXT("1401"), TEXT("ar-dz"), IDS_RFC1766_LCID1401 },
    { TEXT("1801"), TEXT("ar-ma"), IDS_RFC1766_LCID1801 },
    { TEXT("1C01"), TEXT("ar-tn"), IDS_RFC1766_LCID1C01 },
    { TEXT("2001"), TEXT("ar-om"), IDS_RFC1766_LCID2001 },
    { TEXT("2401"), TEXT("ar-ye"), IDS_RFC1766_LCID2401 },
    { TEXT("2801"), TEXT("ar-sy"), IDS_RFC1766_LCID2801 },
    { TEXT("2C01"), TEXT("ar-jo"), IDS_RFC1766_LCID2C01 },
    { TEXT("3001"), TEXT("ar-lb"), IDS_RFC1766_LCID3001 },
    { TEXT("3401"), TEXT("ar-kw"), IDS_RFC1766_LCID3401 },
    { TEXT("3801"), TEXT("ar-ae"), IDS_RFC1766_LCID3801 },
    { TEXT("3C01"), TEXT("ar-bh"), IDS_RFC1766_LCID3C01 },
    { TEXT("4001"), TEXT("ar-qa"), IDS_RFC1766_LCID4001 },
    { TEXT("042D"), TEXT("eu"),    IDS_RFC1766_LCID042D },
    { TEXT("0402"), TEXT("bg"),    IDS_RFC1766_LCID0402 },
    { TEXT("0423"), TEXT("be"),    IDS_RFC1766_LCID0423 },
    { TEXT("0403"), TEXT("ca"),    IDS_RFC1766_LCID0403 },
    { TEXT("0004"), TEXT("zh"),    IDS_RFC1766_LCID0004 },
    { TEXT("0404"), TEXT("zh-tw"), IDS_RFC1766_LCID0404 },
    { TEXT("0804"), TEXT("zh-cn"), IDS_RFC1766_LCID0804 },
    { TEXT("0C04"), TEXT("zh-hk"), IDS_RFC1766_LCID0C04 },
    { TEXT("1004"), TEXT("zh-sg"), IDS_RFC1766_LCID1004 },
    { TEXT("041A"), TEXT("hr"),    IDS_RFC1766_LCID041A },
    { TEXT("0405"), TEXT("cs"),    IDS_RFC1766_LCID0405 },
    { TEXT("0406"), TEXT("da"),    IDS_RFC1766_LCID0406 },
    { TEXT("0413"), TEXT("nl"),    IDS_RFC1766_LCID0413 },
    { TEXT("0813"), TEXT("nl-be"), IDS_RFC1766_LCID0813 },
    { TEXT("0009"), TEXT("en"),    IDS_RFC1766_LCID0009 },
    { TEXT("0409"), TEXT("en-us"), IDS_RFC1766_LCID0409 },
    { TEXT("0809"), TEXT("en-gb"), IDS_RFC1766_LCID0809 },
    { TEXT("0C09"), TEXT("en-au"), IDS_RFC1766_LCID0C09 },
    { TEXT("1009"), TEXT("en-ca"), IDS_RFC1766_LCID1009 },
    { TEXT("1409"), TEXT("en-nz"), IDS_RFC1766_LCID1409 },
    { TEXT("1809"), TEXT("en-ie"), IDS_RFC1766_LCID1809 },
    { TEXT("1C09"), TEXT("en-za"), IDS_RFC1766_LCID1C09 },
    { TEXT("2009"), TEXT("en-jm"), IDS_RFC1766_LCID2009 },
    { TEXT("2809"), TEXT("en-bz"), IDS_RFC1766_LCID2809 },
    { TEXT("2C09"), TEXT("en-tt"), IDS_RFC1766_LCID2C09 },
    { TEXT("0425"), TEXT("et"),    IDS_RFC1766_LCID0425 },
    { TEXT("0438"), TEXT("fo"),    IDS_RFC1766_LCID0438 },
    { TEXT("0429"), TEXT("fa"),    IDS_RFC1766_LCID0429 },
    { TEXT("040B"), TEXT("fi"),    IDS_RFC1766_LCID040B },
    { TEXT("040C"), TEXT("fr"),    IDS_RFC1766_LCID040C },
    { TEXT("080C"), TEXT("fr-be"), IDS_RFC1766_LCID080C },
    { TEXT("0C0C"), TEXT("fr-ca"), IDS_RFC1766_LCID0C0C },
    { TEXT("100C"), TEXT("fr-ch"), IDS_RFC1766_LCID100C },
    { TEXT("140C"), TEXT("fr-lu"), IDS_RFC1766_LCID140C },
    { TEXT("043C"), TEXT("gd"),    IDS_RFC1766_LCID043C },
    { TEXT("0407"), TEXT("de"),    IDS_RFC1766_LCID0407 },
    { TEXT("0807"), TEXT("de-ch"), IDS_RFC1766_LCID0807 },
    { TEXT("0C07"), TEXT("de-at"), IDS_RFC1766_LCID0C07 },
    { TEXT("1007"), TEXT("de-lu"), IDS_RFC1766_LCID1007 },
    { TEXT("1407"), TEXT("de-li"), IDS_RFC1766_LCID1407 },
    { TEXT("0408"), TEXT("el"),    IDS_RFC1766_LCID0408 },
    { TEXT("040D"), TEXT("he"),    IDS_RFC1766_LCID040D },
    { TEXT("0439"), TEXT("hi"),    IDS_RFC1766_LCID0439 },
    { TEXT("040E"), TEXT("hu"),    IDS_RFC1766_LCID040E },
    { TEXT("040F"), TEXT("is"),    IDS_RFC1766_LCID040F },
    { TEXT("0421"), TEXT("in"),    IDS_RFC1766_LCID0421 },
    { TEXT("0410"), TEXT("it"),    IDS_RFC1766_LCID0410 },
    { TEXT("0810"), TEXT("it-ch"), IDS_RFC1766_LCID0810 },
    { TEXT("0411"), TEXT("ja"),    IDS_RFC1766_LCID0411 },
    { TEXT("0412"), TEXT("ko"),    IDS_RFC1766_LCID0412 },
    { TEXT("0426"), TEXT("lv"),    IDS_RFC1766_LCID0426 },
    { TEXT("0427"), TEXT("lt"),    IDS_RFC1766_LCID0427 },
    { TEXT("042F"), TEXT("mk"),    IDS_RFC1766_LCID042F },
    { TEXT("043E"), TEXT("ms"),    IDS_RFC1766_LCID043E },
    { TEXT("043A"), TEXT("mt"),    IDS_RFC1766_LCID043A },
    { TEXT("0414"), TEXT("no"),    IDS_RFC1766_LCID0414 },
    { TEXT("0814"), TEXT("no"),    IDS_RFC1766_LCID0814 },
    { TEXT("0415"), TEXT("pl"),    IDS_RFC1766_LCID0415 },
    { TEXT("0416"), TEXT("pt-br"), IDS_RFC1766_LCID0416 },
    { TEXT("0816"), TEXT("pt"),    IDS_RFC1766_LCID0816 },
    { TEXT("0417"), TEXT("rm"),    IDS_RFC1766_LCID0417 },
    { TEXT("0418"), TEXT("ro"),    IDS_RFC1766_LCID0418 },
    { TEXT("0818"), TEXT("ro-mo"), IDS_RFC1766_LCID0818 },
    { TEXT("0419"), TEXT("ru"),    IDS_RFC1766_LCID0419 },
    { TEXT("0819"), TEXT("ru-mo"), IDS_RFC1766_LCID0819 },
    { TEXT("0C1A"), TEXT("sr"),    IDS_RFC1766_LCID0C1A },
    { TEXT("081A"), TEXT("sr"),    IDS_RFC1766_LCID081A },
    { TEXT("041B"), TEXT("sk"),    IDS_RFC1766_LCID041B },
    { TEXT("0424"), TEXT("sl"),    IDS_RFC1766_LCID0424 },
    { TEXT("042E"), TEXT("sb"),    IDS_RFC1766_LCID042E },
    { TEXT("040A"), TEXT("es"),    IDS_RFC1766_LCID040A },
    { TEXT("080A"), TEXT("es-mx"), IDS_RFC1766_LCID080A },
    { TEXT("0C0A"), TEXT("es"),    IDS_RFC1766_LCID0C0A },
    { TEXT("100A"), TEXT("es-gt"), IDS_RFC1766_LCID100A },
    { TEXT("140A"), TEXT("es-cr"), IDS_RFC1766_LCID140A },
    { TEXT("180A"), TEXT("es-pa"), IDS_RFC1766_LCID180A },
    { TEXT("1C0A"), TEXT("es-do"), IDS_RFC1766_LCID1C0A },
    { TEXT("200A"), TEXT("es-ve"), IDS_RFC1766_LCID200A },
    { TEXT("240A"), TEXT("es-co"), IDS_RFC1766_LCID240A },
    { TEXT("280A"), TEXT("es-pe"), IDS_RFC1766_LCID280A },
    { TEXT("2C0A"), TEXT("es-ar"), IDS_RFC1766_LCID2C0A },
    { TEXT("300A"), TEXT("es-ec"), IDS_RFC1766_LCID300A },
    { TEXT("340A"), TEXT("es-cl"), IDS_RFC1766_LCID340A },
    { TEXT("380A"), TEXT("es-uy"), IDS_RFC1766_LCID380A },
    { TEXT("3C0A"), TEXT("es-py"), IDS_RFC1766_LCID3C0A },
    { TEXT("400A"), TEXT("es-bo"), IDS_RFC1766_LCID400A },
    { TEXT("440A"), TEXT("es-sv"), IDS_RFC1766_LCID440A },
    { TEXT("480A"), TEXT("es-hn"), IDS_RFC1766_LCID480A },
    { TEXT("4C0A"), TEXT("es-ni"), IDS_RFC1766_LCID4C0A },
    { TEXT("500A"), TEXT("es-pr"), IDS_RFC1766_LCID500A },
    { TEXT("0430"), TEXT("sx"),    IDS_RFC1766_LCID0430 },
    { TEXT("041D"), TEXT("sv"),    IDS_RFC1766_LCID041D },
    { TEXT("081D"), TEXT("sv-fi"), IDS_RFC1766_LCID081D },
    { TEXT("041E"), TEXT("th"),    IDS_RFC1766_LCID041E },
    { TEXT("0431"), TEXT("ts"),    IDS_RFC1766_LCID0431 },
    { TEXT("0432"), TEXT("tn"),    IDS_RFC1766_LCID0432 },
    { TEXT("041F"), TEXT("tr"),    IDS_RFC1766_LCID041F },
    { TEXT("0422"), TEXT("uk"),    IDS_RFC1766_LCID0422 },
    { TEXT("0420"), TEXT("ur"),    IDS_RFC1766_LCID0420 },
    { TEXT("042A"), TEXT("vi"),    IDS_RFC1766_LCID042A },
    { TEXT("0434"), TEXT("xh"),    IDS_RFC1766_LCID0434 },
    { TEXT("043D"), TEXT("ji"),    IDS_RFC1766_LCID043D },
    { TEXT("0435"), TEXT("zu"),    IDS_RFC1766_LCID0435 },
    { NULL,         NULL,          0                    }
};

//
//  Charset registry data at MIME\Database
//
typedef struct tagREGCHARSET
{
    LPCTSTR szCharset;
    DWORD dwCodePage;
    DWORD dwInternetEncoding;
    LPCTSTR szAliasForCharset;
    DWORD dwCharsetMask;
}   REGCHARSET, *LPREGCHARSET;

const REGCHARSET regCharset[] =
{
    { TEXT("_autodetect_all"), 50001, 50001, NULL, 0x0 },
    { TEXT("_autodetect"), 50932, 50932, NULL, 0x0 },
    { TEXT("_autodetect_kr"), 50949, 50949, NULL, 0x0 },
    { TEXT("_iso-2022-jp$ESC"), 932, 50221, NULL, 0x0 },
    { TEXT("_iso-2022-jp$SIO"), 932, 50222, NULL, 0x3 },
    { TEXT("Big5"), 950, 950, NULL, 0x0 },
    { TEXT("ks_c_5601-1987"), 949, 949, NULL, 0x3 },
    { TEXT("euc-kr"), 949, 949, NULL, 0x3 },
    { TEXT("GB2312"), 936, 936, NULL, 0x0 },
    { TEXT("hz-gb-2312"), 936, 52936, NULL, 0x0 },
    { TEXT("ibm852"), 852, 852, NULL, 0x3 },
    { TEXT("ibm866"), 866, 866, NULL, 0x3 },
    { TEXT("iso-2022-jp"), 932, 50220, NULL,0x3 },
    { TEXT("iso-2022-kr"), 949, 50225, NULL, 0x3 },
    { TEXT("iso-8859-1"), 1252, 1252, NULL, 0x0 },
    { TEXT("iso-8859-2"), 1250, 28592, NULL, 0x0 },
    { TEXT("iso-8859-3"), 1254, 28593, NULL, 0x0 },
    { TEXT("iso-8859-4"), 1257, 28594, NULL, 0x0 },
    { TEXT("iso-8859-5"), 1251, 28595, NULL, 0x0 },
    { TEXT("iso-8859-6"), 1256, 28596, NULL, 0x0 },
    { TEXT("iso-8859-7"), 1253, 28597, NULL, 0x0 },
    { TEXT("iso-8859-8"), 1255, 28598, NULL, 0x2 },
    { TEXT("iso-8859-8-i"), 1255, 38598, NULL, 0x0 },
    { TEXT("iso-8859-9"), 1254, 1254, NULL, 0x0 },
    { TEXT("iso-8859-11"), 0, 0, TEXT("windows-874"), 0x0 },
    { TEXT("koi8-r"), 1251, 20866, NULL, 0x0 },
    { TEXT("koi8-ru"), 1251, 21866, NULL, 0x2 },
    { TEXT("shift_jis"), 932, 932, NULL, 0x0 },
    { TEXT("unicode-1-1-utf-7"), 0, 0, TEXT("utf-7"), 0x4 },
    { TEXT("unicode-1-1-utf-8"), 0, 0, TEXT("utf-8"), 0x0 },
    { TEXT("x-unicode-2-0-utf-7"), 0, 0, TEXT("utf-7"), 0x4 },
    { TEXT("x-unicode-2-0-utf-8"), 0, 0, TEXT("utf-8"), 0x4 },
    { TEXT("utf-7"), 1200, 65000, NULL, 0x1 },
    { TEXT("utf-8"), 1200, 65001, NULL, 0x1 },
    { TEXT("unicode"), 1200, 1200, NULL, 0x0 },
    { TEXT("unicodeFFFE"), 1200, 1201, NULL, 0x0 },
    { TEXT("windows-1250"), 1250, 1250, NULL, 0x0 },
    { TEXT("windows-1251"), 1251, 1251, NULL, 0x0 },
    { TEXT("windows-1252"), 1252, 1252, NULL, 0x0 },
    { TEXT("windows-1253"), 1253, 1253, NULL, 0x0 },
    { TEXT("windows-1255"), 1255, 1255, NULL, 0x0 },
    { TEXT("windows-1256"), 1256, 1256, NULL, 0x0 },
    { TEXT("windows-1257"), 1257, 1257, NULL, 0x0 },
    { TEXT("windows-1258"), 1258, 1258, NULL, 0x0 },
    { TEXT("windows-874"), 874, 874, NULL, 0x0 },
    { TEXT("x-user-defined"), 50000, 50000, NULL, 0x0 },
    { TEXT("x-ansi"), 0, 0, TEXT("windows-1252"), 0x0 },
    { TEXT("euc-jp"), 932, 51932, NULL, 0x0 },
    { TEXT("x-euc-jp"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("x-euc"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("x-ms-cp932"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("x-sjis"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("ANSI_X3.4-1968"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("ANSI_X3.4-1986"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("ascii"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("chinese"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("CN-GB"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("cp866"), 0, 0, TEXT("ibm866"), 0x0 },
    { TEXT("cp852"), 0, 0, TEXT("ibm852"), 0x0 },
    { TEXT("cp367"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("cp819"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("csASCII"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("csbig5"), 0, 0, TEXT("big5"), 0x0 },
    { TEXT("csEUCPkdFmtJapanese"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("csGB2312"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("csISO2022KR"), 0, 0, TEXT("iso-2022-kr"), 0x0 },
    { TEXT("csISO58GB231280"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("csISOLatin2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("csISOLatin4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("csISOLatin5"), 0, 0, TEXT("iso-8859-9"), 0x4 },
    { TEXT("csISOLatinCyrillic"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("csISOLatinGreek"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("csISOLatinHebrew"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("csKSC56011987"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("csShiftJIS"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("csUnicode11UTF7"), 0, 0, TEXT("utf-7"), 0x0 },
    { TEXT("csWindows31J"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("cyrillic"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("ECMA-118"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("ELOT_928"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("greek"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("greek8"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("hebrew"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("IBM367"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("ibm819"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("ISO_646.irv:1991"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso_8859-1"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso_8859-1:1987"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso_8859-2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("iso_8859-2:1987"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("ISO_8859-4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("ISO_8859-5"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("ISO_8859-7"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("ISO_8859-8"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO_8859-9"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("ISO646-US"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso8859-1"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso-ir-100"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("iso-ir-101"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("iso-ir-110"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("iso-ir-126"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("iso-ir-138"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("iso-ir-144"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("iso-ir-148"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("iso-ir-58"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("iso-ir-6"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("korean"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("ks_c_5601"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("l2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("l4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("l5"), 0, 0, TEXT("iso-8859-9"), 0x4 },
    { TEXT("latin1"), 0, 0, TEXT("iso-8859-1"), 0x4 },
    { TEXT("latin2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("latin4"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("latin5"), 0, 0, TEXT("iso-8859-9"), 0x4 },
    { TEXT("ms_Kanji"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("shift-jis"), 0, 0, TEXT("shift_jis"), 0x0 },
    { TEXT("unicode-2-0-utf-8"), 0, 0, TEXT("utf-8"), 0x0 },
    { TEXT("us-ascii"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("us"), 0, 0, TEXT("iso-8859-1"), 0x0 },
    { TEXT("x-cp1250"), 0, 0, TEXT("Windows-1250"), 0x0 },
    { TEXT("x-cp1251"), 0, 0, TEXT("Windows-1251"), 0x0 },
    { TEXT("x-x-big5"), 0, 0, TEXT("big5"), 0x0 },
    { TEXT("csISO2022JP"), 0, 0, TEXT("_iso-2022-jp$ESC"), 0x4 },
    { TEXT("csKOI8R"), 0, 0, TEXT("koi8-r"), 0x0 },
    { TEXT("Extended_UNIX_Code_Packed_Format_for_Japanese"), 0, 0, TEXT("euc-jp"), 0x0 },
    { TEXT("GB_2312-80"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("GBK"), 0, 0, TEXT("gb2312"), 0x0 },
    { TEXT("ISO_8859-4:1988"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("ISO_8859-5:1988"), 0, 0, TEXT("iso-8859-5"), 0x0 },
    { TEXT("ISO_8859-7:1987"), 0, 0, TEXT("iso-8859-7"), 0x0 },
    { TEXT("ISO_8859-8:1988"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO_8859-9:1989"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("iso8859-2"), 0, 0, TEXT("iso-8859-2"), 0x0 },
    { TEXT("koi"), 0, 0, TEXT("koi8-r"), 0x0 },
    { TEXT("Windows-1254"), 0, 0, TEXT("iso-8859-9"), 0x0 },
    { TEXT("DOS-720"), 1256, 720, NULL, 0x0 },
    { TEXT("DOS-862"), 1255, 862, NULL, 0x0 },
    { TEXT("DOS-874"), 874, 874, NULL, 0x0 },
    { TEXT("ASMO-708"), 1256, 708, NULL, 0x0 },
    { TEXT("csEUCKR"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("csISOLatin1"), 0, 0, TEXT("windows-1252"), 0x0 },
    { TEXT("iso-ir-111"), 0, 0, TEXT("iso-8859-4"), 0x0 },
    { TEXT("iso-ir-149"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("KSC_5601"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("KSC5601"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("ks_c_5601-1989"), 0, 0, TEXT("ks_c_5601-1987"), 0x0 },
    { TEXT("l1"), 0, 0, TEXT("windows-1252"), 0x0 },
    { TEXT("cp1256"), 0, 0, TEXT("windows-1256"), 0x0 },
    { TEXT("logical"), 0, 0, TEXT("windows-1255"), 0x0 },
    { TEXT("csISOLatinArabic"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("ECMA-114"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("visual"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO-8859-8 Visual"), 0, 0, TEXT("iso-8859-8"), 0x0 },
    { TEXT("ISO_8859-6"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("iso-ir-127"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("ISO_8859-6:1987"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { TEXT("arabic"), 0, 0, TEXT("iso-8859-6"), 0x0 },
    { NULL, 0, 0, NULL, 0 }    
};

//
//  Codepage registry data at MIME\Database
//
typedef struct tagREGCODEPAGE
{
    LPCTSTR szCodePage;
    LPCTSTR szHeaderCharset;
    LPCTSTR szBodyCharset;
    LPCTSTR szWebCharset;
    UINT uidFixedWidthFont;
    UINT uidProportionalFont;
    UINT uidDescription;
    DWORD dwFamily;
    DWORD dwLevel;
    DWORD dwEncoding;
    DWORD dwCodePageMask;
}   REGCODEPAGE, *LPREGCODEPAGE;

const REGCODEPAGE regCodePage[] =
{
    { TEXT("1200"), NULL, TEXT("unicode"), NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1200, 0, 0x00000204, 0x00000101, 0xA0 },
    { TEXT("1201"), NULL, TEXT("unicodeFFFE"), NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1201, 1200, 0x00000000, 0x00000101,0xE0 },
    { TEXT("1250"), NULL, TEXT("iso-8859-2"), TEXT("windows-1250"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1250, 0, 0x00000303, 0x00000202, 0xA0 },
    { TEXT("1251"), NULL, TEXT("koi8-r"), TEXT("windows-1251"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1251, 0, 0x00000303, 0x00000202, 0xA0 },
    { TEXT("1252"), NULL, TEXT("iso-8859-1"), TEXT("iso-8859-1"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1252, 0, 0x00000707, 0x00000000, 0xA4 },
    { TEXT("1253"), NULL, TEXT("iso-8859-7"), TEXT("windows-1253"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1253, 0, 0x00000303, 0x00000101, 0x100A6 },
    { TEXT("1254"), NULL, TEXT("iso-8859-9"), TEXT("iso-8859-9"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1254, 0, 0x00000707, 0x00000202, 0xA0 },
    { TEXT("1255"), NULL, TEXT("iso-8859-8-i"), TEXT("windows-1255"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1255, 0, 0x00000303, 0x00000101, 0xA2 },
    { TEXT("1256"), NULL, TEXT("iso-8859-6"), TEXT("windows-1256"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1256, 0, 0x00000303, 0x00000101, 0xA0 },
    { TEXT("1257"), NULL, TEXT("iso-8859-4"), TEXT("windows-1257"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1257, 0, 0x00000707, 0x00000202, 0xA0 },
    { TEXT("1258"), NULL, TEXT("windows-1258"), TEXT("windows-1258"), IDS_FONT_WESTERN_FIXED, IDS_FONT_WESTERN_PROP, IDS_DESC_1258, 0, 0x00000101, 0x00000000, 0xA0 },
    { TEXT("20866"), NULL, TEXT("koi8-r"), NULL, 0, 0, IDS_DESC_20866, 1251, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("21866"), NULL, TEXT("koi8-ru"), NULL, 0, 0, IDS_DESC_21866, 1251, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("28592"), NULL, TEXT("iso-8859-2"), NULL, 0, 0, IDS_DESC_28592, 1250, 0x00000707, 0x00000000, 0xA0 },
    { TEXT("28593"), NULL, TEXT("iso-8859-3"), NULL, 0, 0, IDS_DESC_28593, 1254, 0x00000701, 0x00000000, 0xA0 },
    { TEXT("28594"), NULL, TEXT("iso-8859-4"), NULL, 0, 0, IDS_DESC_28594, 1257, 0x00000301, 0x00000000, 0xA0 },
    { TEXT("28595"), NULL, TEXT("iso-8859-5"), NULL, 0, 0, IDS_DESC_28595, 1251, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("28596"), NULL, TEXT("iso-8859-6"), NULL, 0, 0, IDS_DESC_28596, 1256, 0x00000707, 0x00000000, 0xA0 },
    { TEXT("28597"), NULL, TEXT("iso-8859-7"), NULL, 0, 0, IDS_DESC_28597, 1253, 0x00000707, 0x00000101, 0xA2 },
    { TEXT("50000"), NULL, TEXT("x-user-defined"), NULL, IDS_FONT_WESTERN_FIXED, IDS_FONT_UNICODE_PROP, IDS_DESC_50000, 0, 0x00000303, 0x00000000, 0xA0 },
    { TEXT("50220"), NULL, TEXT("iso-2022-jp"), NULL, 0, 0, IDS_DESC_50220, 932, 0x00000101, 0x00000000, 0xE2 },
    { TEXT("50221"), NULL, TEXT("_iso-2022-jp$ESC"), TEXT("csISO2022JP"), 0, 0, IDS_DESC_50221, 932, 0x00000301, 0x00000000, 0xE6 },
    { TEXT("50222"), NULL, TEXT("_iso-2022-jp$SIO"), TEXT("iso-2022-jp"), 0, 0, IDS_DESC_50222, 932, 0x00000101, 0x00000000, 0xE6 },
    { TEXT("50225"), NULL, TEXT("iso-2022-kr"), TEXT("iso-2022-kr"), 0, 0, IDS_DESC_50225, 949, 0x00000101, 0x00000000, 0xA0 },
    { TEXT("50001"), NULL, TEXT("_autodetect_all"), NULL, 0, 0, IDS_DESC_50001, 0, 0x00000007, 0x00000101, 0xA2 },
    { TEXT("50932"), NULL, TEXT("_autodetect"), NULL, 0, 0, IDS_DESC_50932, 932, 0x00000007, 0x00000101, 0xA2 },
    { TEXT("50949"), NULL, TEXT("_autodetect_kr"), NULL, 0, 0, IDS_DESC_50949, 949, 0x00000001, 0x00000101, 0xA0 },
    { TEXT("51932"), NULL, TEXT("euc-jp"), NULL, 0, 0, IDS_DESC_51932, 932, 0x00000707, 0x00000101, 0xA2 },
    { TEXT("51949"), NULL, TEXT("euc-kr"), NULL, 0, 0, IDS_DESC_51949, 949, 0x00000000, 0x00000101, 0xE2 },
    { TEXT("52936"), NULL, TEXT("hz-gb-2312"), NULL, 0, 0, IDS_DESC_52936, 936, 0x00000303, 0x00000000, 0xA2 },
    { TEXT("65000"), NULL, TEXT("utf-7"), NULL, 0, 0, IDS_DESC_65000, 1200, 0x00000101, 0x00000000, 0xA0 },
    { TEXT("65001"), NULL, TEXT("utf-8"), NULL, 0, 0, IDS_DESC_65001, 1200, 0x00000303, 0x00000000, 0xA0 },
    { TEXT("852"), NULL, TEXT("ibm852"), NULL, 0, 0, IDS_DESC_852, 1250, 0x00000202, 0x00000000, 0xE0 },
    { TEXT("866"), NULL, TEXT("cp866"), NULL, 0, 0, IDS_DESC_866, 1251, 0x00000202, 0x00000000, 0xA0 },
    { TEXT("874"), NULL, TEXT("windows-874"), TEXT("windows-874"), IDS_FONT_THAI_FIXED, IDS_FONT_THAI_PROP, IDS_DESC_874, 0, 0x00000707, 0x00000101, 0x1B8 },
    { TEXT("932"), NULL, TEXT("iso-2022-jp"), TEXT("shift_jis"), IDS_FONT_JAPANESE_FIXED, IDS_FONT_JAPANESE_PROP, IDS_DESC_932, 0, 0x00000707, 0x00000101, 0xA2 },
    { TEXT("936"), NULL, TEXT("gb2312"), NULL, IDS_FONT_CHINESE_FIXED, IDS_FONT_CHINESE_PROP, IDS_DESC_936, 0, 0x00000707, 0x00000000, 0xA0 },
    { TEXT("949"), TEXT("euc-kr"), TEXT("euc-kr"), TEXT("ks_c_5601-1987"), IDS_FONT_KOREAN_FIXED, IDS_FONT_KOREAN_PROP, IDS_DESC_949, 0, 0x00000707, 0x00000101, 0xA7 },
    { TEXT("950"), NULL, TEXT("big5"), NULL, IDS_FONT_TAIWAN_FIXED, IDS_FONT_TAIWAN_PROP, IDS_DESC_950, 0, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("28598"), NULL, TEXT("iso-8859-8"), NULL, 0, 0, IDS_DESC_28598, 1255, 0x00000707, 0x00000101, 0xA0 },
    { TEXT("38598"), NULL, TEXT("iso-8859-8-i"), NULL, IDS_FONT_HEBREW_FIXED, IDS_FONT_HEBREW_PROP, IDS_DESC_38598, 1255, 0x00000707, 0x00000101, 0xB8 },
    { TEXT("708"), NULL, TEXT("ASMO-708"), NULL, 0, 0, IDS_DESC_708, 1256, 0x00000707, 0, 0xA0 },
    { TEXT("720"), NULL, TEXT("DOS-720"), NULL, 0, 0, IDS_DESC_720, 1256, 0x00000707, 0, 0xA0 },
    { TEXT("862"), NULL, TEXT("DOS-862"), NULL, 0, 0, IDS_DESC_862, 1255, 0x00000707, 0, 0xA0 },
    { NULL, NULL, NULL, NULL, 0, 0, 0, 0, 0x00000000, 0x00000000, 0x0  }        
};


BOOL MimeDatabaseInfo(void)
{
    HKEY hKey = NULL, hKeySub = NULL;
    TCHAR szKey[32], szValue[256];
    int i;
    BOOL bNewKey, bOverWrite;
    DWORD dwAction;
    BOOL bRet = TRUE;

    // MIME\Database\CodePage
    wsprintf(szKey, TEXT("%s\\%s"), szMIMEDatabase, szCodepage);
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
    {
        ASSERT(NULL != hKey);
        i = 0;
        bNewKey = (dwAction == REG_CREATED_NEW_KEY);
        while (regCodePage[i].szCodePage)
        {
            if (ERROR_SUCCESS == RegCreateKeyEx(hKey, regCodePage[i].szCodePage, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, &dwAction))
            {
                ASSERT(NULL != hKeySub);
                bOverWrite = (bNewKey || dwAction == REG_CREATED_NEW_KEY);
                if (regCodePage[i].szHeaderCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szHeaderCharset, REG_SZ, (LPBYTE)regCodePage[i].szHeaderCharset, (lstrlen(regCodePage[i].szHeaderCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_HEADER_CHARSET)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_HEADER_CHARSET)
                    {
                        RegDeleteValue(hKeySub, szHeaderCharset);
                    }
                }
                if (regCodePage[i].szBodyCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szBodyCharset, REG_SZ, (LPBYTE)regCodePage[i].szBodyCharset, (lstrlen(regCodePage[i].szBodyCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_BODY_CHARSET)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_BODY_CHARSET)
                    {
                        RegDeleteValue(hKeySub, szBodyCharset);
                    }
                }
                if (regCodePage[i].szWebCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szWebCharset, REG_SZ, (LPBYTE)regCodePage[i].szWebCharset, (lstrlen(regCodePage[i].szWebCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_WEB_CHARSET)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_WEB_CHARSET)
                    {
                        RegDeleteValue(hKeySub, szWebCharset);
                    }
                }
                if (regCodePage[i].uidFixedWidthFont)
                {
                    LoadString(g_hInst, regCodePage[i].uidFixedWidthFont, szValue, sizeof(szValue));
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szFixedWidthFont, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_WEB_FIXED_WIDTH_FONT)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_WEB_FIXED_WIDTH_FONT)
                    {
                        RegDeleteValue(hKeySub, szFixedWidthFont);
                    }
                }
                if (regCodePage[i].uidProportionalFont)
                {
                    LoadString(g_hInst, regCodePage[i].uidProportionalFont, szValue, sizeof(szValue));
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szProportionalFont, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_PROPORTIONAL_FONT)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_PROPORTIONAL_FONT)
                    {
                        RegDeleteValue(hKeySub, szProportionalFont);
                    }
                }
                if (regCodePage[i].uidDescription)
                {
                    LANGID lid = GetSystemDefaultLangID();

                    // Unsupported language resource?
                    if (!_LoadStringExA(g_hInst, regCodePage[i].uidDescription, szValue, sizeof(szValue), lid))
                    {
                        // First try, primary language
                        lid = MAKELANGID(PRIMARYLANGID(lid), SUBLANG_NEUTRAL);                         
                        if (!_LoadStringExA(g_hInst, regCodePage[i].uidDescription, szValue, sizeof(szValue), lid))
                        {
                            // Last try, switch to English, US
                            _LoadStringExA(g_hInst, regCodePage[i].uidDescription, szValue, sizeof(szValue), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
                        }
                    }

                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szDescription, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_DESCRIPTION)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_DESCRIPTION)
                    {
                        RegDeleteValue(hKeySub, szDescription);
                    }
                }
                if (regCodePage[i].dwFamily)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szFamily, REG_DWORD, (LPBYTE)&regCodePage[i].dwFamily, sizeof(DWORD), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_FAMILY)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_FAMILY)
                    {
                        RegDeleteValue(hKeySub, szFamily);
                    }
                }
                if (regCodePage[i].dwLevel)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szLevel, REG_BINARY, (LPBYTE)&regCodePage[i].dwLevel, sizeof(DWORD), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_LEVEL)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_LEVEL)
                    {
                        RegDeleteValue(hKeySub, szLevel);
                    }
                }
                if (regCodePage[i].dwEncoding)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szEncoding, REG_BINARY, (LPBYTE)&regCodePage[i].dwEncoding, sizeof(DWORD), bOverWrite || (regCodePage[i].dwCodePageMask & BIT_ENCODING)))
                        bRet = FALSE;
                }
                else 
                {
                    if (regCodePage[i].dwCodePageMask & BIT_DEL_ENCODING)
                    {
                        RegDeleteValue(hKeySub, szEncoding);
                    }
                }
                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }
            else
                bRet = FALSE;
            i++;
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
        bRet = FALSE;

    // MIME\Database\Charset
    wsprintf(szKey, TEXT("%s\\%s"), szMIMEDatabase, szCharset);
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
    {
        ASSERT(NULL != hKey);
        i = 0;
        bNewKey = (dwAction == REG_CREATED_NEW_KEY);
        while (regCharset[i].szCharset)
        {
            if (ERROR_SUCCESS == RegCreateKeyEx(hKey, regCharset[i].szCharset, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, &dwAction))
            {
                ASSERT(NULL != hKeySub);
                bOverWrite = (bNewKey || dwAction == REG_CREATED_NEW_KEY);
                if (regCharset[i].szAliasForCharset)
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szAliasForCharset, REG_SZ, (LPBYTE)regCharset[i].szAliasForCharset, (lstrlen(regCharset[i].szAliasForCharset) + 1) * sizeof(TCHAR), bOverWrite || (regCharset[i].dwCharsetMask & BIT_ALIAS_FOR_CHARSET)))
                        bRet = FALSE;
                }
                else
                {
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szCodepage, REG_DWORD, (LPBYTE)&regCharset[i].dwCodePage, sizeof(DWORD), bOverWrite || (regCharset[i].dwCharsetMask & BIT_CODEPAGE)))
                        bRet = FALSE;
                    if (ERROR_SUCCESS != PrivRegSetValueEx(hKeySub, szInternetEncoding, REG_DWORD, (LPBYTE)&regCharset[i].dwInternetEncoding, sizeof(DWORD), bOverWrite || (regCharset[i].dwCharsetMask & BIT_INTERNET_ENCODING)))
                        bRet = FALSE;
                }
                RegCloseKey(hKeySub);
                hKeySub = NULL;
            }
            else
                bRet = FALSE;
            i++;
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
        bRet = FALSE;

    // MIME\Database\Rfc1766
    wsprintf(szKey, TEXT("%s\\%s"), szMIMEDatabase, szRfc1766);
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwAction))
    {
        ASSERT(NULL != hKey);
        i = 0;
        while (regRfc1766[i].szLCID)
        {
            TCHAR szBuf[256];
            LANGID lid = GetSystemDefaultLangID();

            if (!_LoadStringExA(g_hInst, regRfc1766[i].uidLCID, szBuf, sizeof(szBuf), lid))
            {
                // First try, primary language
                lid = MAKELANGID(PRIMARYLANGID(lid), SUBLANG_NEUTRAL);
                if (!_LoadStringExA(g_hInst, regRfc1766[i].uidLCID, szBuf, sizeof(szBuf), lid))
                {
                    // Last try, switch to English, US
                    _LoadStringExA(g_hInst, regRfc1766[i].uidLCID, szBuf, sizeof(szBuf), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
                }
            }

            wsprintf(szValue, TEXT("%s;%s"), regRfc1766[i].szAcceptLang, szBuf);
            if (ERROR_SUCCESS != PrivRegSetValueEx(hKey, regRfc1766[i].szLCID, REG_SZ, (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR), bOverWrite))
                bRet = FALSE;
            i++;
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
        bRet = FALSE;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\msencode.h ===
/*----------------------------------------------------------------------------
	%%File: msencode.h
	%%Unit: fechmap
	%%Contact: jpick

	External header file for MsEncode character conversion module.
----------------------------------------------------------------------------*/

#ifndef MSENCODE_H
#define MSENCODE_H
	
	
// ----------------------------------------------------------------------------
//
// Error Returns
// 
// ----------------------------------------------------------------------------

//
// Return Type for API Functions
//
typedef int CCE;
	
//
// Error:       cceSuccess
// Explanation: Function succeeded (no error).
//
#define cceSuccess						 0

//
// Error:       cceRequestedStop
// Explanation: Function succeeded (no error).  Caller 
//				requested function to be run in iterator mode 
//				(stop on each character or stop on ASCII) and 
//				function is making requested stop.  (Stream 
//				conversion functions only).
//
#define cceRequestedStop				(-1)

//
// Error:       cceInsufficientBuffer
// Explanation: Buffer provided to function is too small.
//
#define cceInsufficientBuffer			(-2)

//
// Error:       cceInvalidFlags
// Explanation: An invalid flag or combination of flags was 
//				given to function.
//
#define cceInvalidFlags					(-3)

//
// Error:       cceInvalidParameter
// Explanation: Invalid parameter passed to function (null 
//				pointer, invalid encoding specified, etc.).
//
#define cceInvalidParameter				(-4)

//
// Error:       cceRead
// Explanation: User read-callback function failed.
//
#define cceRead							(-5)

//
// Error:       cceWrite
// Explanation: User write-callback function failed.
//
#define cceWrite						(-6)

//
// Error:       cceUnget
// Explanation: User unget-callback function failed.
//
#define cceUnget						(-7)

//
// Error:       cceNoCodePage
// Explanation: Requested encoding requires an installed
//				code page (NLS file) for conversion.  That
//				file is not installed.
//
#define cceNoCodePage					(-8)

//
// Error:       cceEndOfInput
// Explanation: Unexpected end-of-input occurred within a 
//				multi-byte character in conversion function.
//              (Returned only if user requested errors for
//              invalid characters).
//
#define cceEndOfInput					(-9)

//
// Error:       cceNoTranslation
// Explanation: Character in input stream or string has no 
//				equivalent Unicode (multi-byte to Unicode) or
//              multi-byte (Unicode to multi-byte) character.
//              (Returned only if user requested errors for
//              invalid characters).
//
#define cceNoTranslation				(-10)

//
// Error:       cceInvalidChar
// Explanation: Converter found a single or multi-byte character
//				that is outside the legal range for the given
//				encoding.  (Returned only if user requested 
//				errors for invalid characters).
//
#define cceInvalidChar					(-11)

//
// Error:       cceAmbiguousInput
// Explanation: CceDetectInputCode(), only.  Data matches more
//				than one of the supported encodings types.
//              (Returned only if function told to not resolve
//              ambiguity).
//
#define cceAmbiguousInput				(-12)

//
// Error:       cceUnknownInput
// Explanation:	CceDetectInputCode(), only.  Data matches none
//				of the supported encoding types.
//
#define cceUnknownInput					(-13)

//
// Error:       cceMayBeAscii
// Explanation:	CceDetectInputCode(), only.  Technically, data
//              matches at least one of the supported encoding
//              types, but may not be a true match.  (For example,
//              an ASCII file with only a few scattered extended
//              characters).  (Returned only if function told to
//              resolve ambiguity).
//
//              This is not an error, only a flag to the calling
//              application.  CceDetectInputCode() will still set
//              the encoding type if it returns this value.
//
#define cceMayBeAscii					(-14)

//
// Error:       cceInternal
// Explanation: Unrecoverable internal error.
//
#define cceInternal						(-15)

//
// Error:       cceConvert
// Explanation: Unexpected DBCS function conversion error.
//
#define cceConvert						(-16)

//
// Error:       cceEncodingNotImplemented
// Explanation: Temporary integration error.  Requested encoding
//				is not implemented.
//
#define cceEncodingNotImplemented		(-100)

//
// Error:       cceFunctionNotImplemented
// Explanation: Temporary integration error.  Function
//				is not implemented.
//
#define cceFunctionNotImplemented		(-101)



// ----------------------------------------------------------------------------
//
// General Definitions for Modules Using these Routines
// 
// ----------------------------------------------------------------------------

#define MSENAPI					PASCAL
#define MSENCBACK				PASCAL
#define EXPIMPL(type)			type MSENAPI
#define EXPDECL(type)			extern type MSENAPI

// In case these are not already defined
//
#ifndef FAR
#ifdef _WIN32
#define FAR		__far
#else
#define FAR
#endif
#endif

typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef UCHAR FAR *LPUSTR;
typedef const UCHAR FAR *LPCUSTR;

#ifndef UNIX // IEUNIX uses 4 bytes WCHAR, these are already defined in winnt.h
typedef unsigned short WCHAR;
typedef WCHAR *PWCHAR;
typedef WCHAR FAR *LPWSTR;
typedef const WCHAR FAR *LPCWSTR;
#endif

//
// Character encoding types supported by this module.
//
typedef enum _cenc
	{
	ceNil = -1,
	ceEucCn = 0,
	ceEucJp,
	ceEucKr,
	ceIso2022Jp,
	ceIso2022Kr,
	ceBig5,
	ceGbk,
	ceHz,
	ceShiftJis,
	ceWansung,
	ceUtf7,
	ceUtf8,
	ceCount,
	};

typedef short CEnc;
	
//
// Encoding "families" (for CceDetectInputCode() preferences).
//
typedef enum _efam
	{
	efNone = 0,
	efDbcs,
	efEuc,
	efIso2022,
	efUtf8,
	} EFam;

//
// API private/reserved structure.  For most API functions,
// this structure must be zero-filled by calling application.
// See converter function documentation, below, for more
// information.
//
#define cdwReserved		4
typedef struct _ars
	{
	DWORD rgdw[cdwReserved];
	} ARS;

// For GetProcAddress()
typedef void (MSENAPI *PFNMSENCODEVER)(WORD FAR *, WORD FAR *);

// ----------------------------------------------------------------------------
//
// Input Code Auto-Detection Routine
// 
// ----------------------------------------------------------------------------

//
// Configuration Flags for Auto Detection Routine
// 
//   grfDetectResolveAmbiguity
//       The default is to return cceAmbiguousInput if the auto
//       detection code cannot definitely determine the encoding
//       of the input stream.  If this flag is set, the function
//       will use optional user preferences and the system code 
//       page to pick an encoding (note that in this case, the
//       "lpfGuess" flag will be set to fTrue upon return).
// 
//   grfDetectUseCharMapping
//       The default action of the auto-detection code is to 
//       parse the input against the known encoding types.  Legal 
//       character sequences are not analyzed for anything 
//       beyond syntactic correctness.  If this flag is set, 
//       auto-detect will map recognized sequences to flush out
//       invalid characters.
//
//       This option will cause auto-detection to run more 
//       slowly, but also yield more accurate results.
// 
//   grfDetectIgnoreEof
//       Because auto-detect parses byte sequences against the
//       the known encoding types, end-of-input in the middle of a 
//       sequence is obviously an error.  If the calling application
//       will artificially limit the sample size, set this flag
//       to ignore such end-of-input errors.
//
#define	grfDetectResolveAmbiguity		0x1
#define grfDetectUseCharMapping			0x2
#define grfDetectIgnoreEof				0x4

//
// Entry Point -- Attempt to Detect the Encoding
//
//    Return cceAmbiguousInput if input is ambiguous or cceUnknownInput
//    if encoding type matches none of the known types.
//
//    Detected encoding is returned in lpCe.  lpfGuess used to return
//    a flag indicating whether or not the function "guessed" at an
//    encoding (chose default from ambiguous state).
//
//    User preferences for encoding family (efPref) and code page
//    (nPrefCp) are optional, even if caller chooses to have
//    this function attempt to resolve ambiguity.  If either has
//    the value 0, they will be ignored.
//
EXPDECL(CCE)
CceDetectInputCode(
    IStream   *pstmIn,           // input stream
	DWORD     dwFlags,			// configuration flags
	EFam      efPref,			// optional: preferred encoding family
	int       nPrefCp,			// optional: preferred code page
	UINT      *lpCe,				// set to detected encoding
	BOOL      *lpfGuess			// set to fTrue if function "guessed"
);

#endif			// #ifndef MSENCODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\private.h ===
#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right for oleaut32.h, we are defing these

#ifdef STRICT
#undef STRICT
#endif

#define STRICT
#pragma warning(disable:4514) // unreferenced inline function has been removed

#include <windows.h>
#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <port32.h>
#include <debug.h>
#include <inetreg.h>
#include <mlang.h>
#include <urlmon.h> // for JIT stuff

#include "mimedb.h"
#include "enumcp.h"
#include "resource.h"
#include "shfusion.h"

#include "detect.h"     // LCDETECT
#include "font.h"

//
//  Function prototypes
//
#if defined(__cplusplus)
extern "C" HRESULT WINAPI ConvertINetReset(void);
#else
HRESULT WINAPI ConvertINetReset(void);
#endif
HRESULT WINAPI ConvertINetStringInIStream(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD dwFlag, WCHAR *lpFallBack);
HRESULT WINAPI ConvertINetUnicodeToMultiByteEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount, DWORD dwFlag, WCHAR *lpFallBack);
HRESULT WINAPI ConvertINetMultiByteToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount, DWORD dwFlag, WCHAR *lpFallBack);
HRESULT WINAPI _DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScoores);
HRESULT WINAPI _DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScoores);

void CMLangFontLink_FreeGlobalObjects(void);
int _LoadStringExW(HMODULE, UINT, LPWSTR, int, WORD);
int _LoadStringExA(HMODULE, UINT, LPSTR, int, WORD);

HRESULT RegularizePosLen(long lStrLen, long* plPos, long* plLen);
HRESULT LocaleToCodePage(LCID locale, UINT* puCodePage);
HRESULT StartEndConnection(IUnknown* const pUnkCPC, const IID* const piid, IUnknown* const pUnkSink, DWORD* const pdwCookie, DWORD dwCookie);

HRESULT RegisterServerInfo(void);
HRESULT UnregisterServerInfo(void);

// Legacy registry MIME DB code, keep it for backward compatiblility
BOOL MimeDatabaseInfo(void);

void DllAddRef(void);
void DllRelease(void);

// JIT langpack stuff
HRESULT InstallIEFeature(HWND hWnd, CLSID *clsid, DWORD dwfIODControl);
HRESULT _GetJITClsIDForCodePage(UINT uiCodePage, CLSID *clsid );
HRESULT _AddFontForCP(UINT uiCP);
HRESULT _ValidateCPInfo(UINT uiCP);
HRESULT _InstallNT5Langpack(HWND hwnd, UINT uiCP);
LANGID GetNT5UILanguage(void);
BOOL    _IsValidCodePage(UINT uiCodePage);
BOOL    _IsKOI8RU(unsigned char *pStr, int nSize);
HRESULT  IsNTLangpackAvailable(UINT uiCodePage);
HRESULT _IsCodePageInstallable(UINT uiCodePage);

// String functions
WCHAR *MLStrCpyNW(WCHAR *strDest, const WCHAR *strSource, int nCount);
WCHAR *MLStrCpyW(WCHAR *strDest, const WCHAR *strSource);
int MLStrCmpIW( const wchar_t *string1, const wchar_t *string2 );
int MLStrCmpI(LPCTSTR pwsz1, LPCTSTR pwsz2);
LPTSTR MLPathCombine(LPTSTR szPath, LPTSTR szPath1, LPTSTR szPath2);
LPTSTR MLStrCpyN(LPTSTR pstrDest, const LPTSTR pstrSource, UINT nCount);
LPTSTR MLStrStr(const LPTSTR Str, const LPTSTR subStr);
DWORD HexToNum(LPTSTR lpsz);
LPTSTR MLStrChr( const TCHAR *string, int c );
BOOL AnsiFromUnicode(LPSTR * ppszAnsi, LPCWSTR pwszWide, LPSTR pszBuf, int cchBuf);
int WINAPI MLStrToIntW(LPCWSTR lpSrc);
int WINAPI MLStrToIntA(LPCSTR lpSrc);
int MLStrCmpNI(LPCTSTR pstr1, LPCTSTR pstr2, int nChar);
int MLStrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
int MLStrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
UINT MLGetWindowsDirectory(LPTSTR lpBuffer, UINT uSize);
int LowAsciiStrCmpNIA(LPCSTR  lpstr1, LPCSTR lpstr2, int count);

int CALLBACK EnumFontFamExProc(ENUMLOGFONTEX *lpelf, NEWTEXTMETRICEX *lpntm, int iFontType, LPARAM lParam);
INT_PTR CALLBACK LangpackDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD OutBoundDetectPreScan(LPWSTR lpWideCharStr, UINT cchWideChar, WCHAR *pwszCopy, WCHAR *lpBestFit);
void BuildGlobalObjects(void);
HRESULT GetCharCodePagesEx(WCHAR chSrc, DWORD* pdwCodePages, DWORD dwFlags);
HRESULT GetStrCodePagesEx(const WCHAR* pszSrc, long cchSrc, DWORD dwPriorityCodePages, DWORD* pdwCodePages, long* pcchCodePages, DWORD dwFlags);
HRESULT CodePageToCodePagesEx(UINT uCodePage, DWORD* pdwCodePages, DWORD* pdwCodePagesExt);
HRESULT CodePagesToCodePageEx(DWORD dwCodePages, UINT uDefaultCodePage, UINT* puCodePage, BOOL bCodePagesExt);
BOOL NeedToLoadMLangForOutlook(void);
BOOL MLIsOS(DWORD dwOS);


#ifdef UNICODE
#define MLStrToInt MLStrToIntW
#else
#define MLStrToInt MLStrToIntA
#endif

//
//  Globals
//
extern HINSTANCE    g_hInst;
extern HINSTANCE    g_hUrlMon;
extern UINT         g_cRfc1766;
extern PRFC1766INFOA g_pRfc1766Reg;

extern CRITICAL_SECTION g_cs;

extern BOOL g_bIsNT5;
extern BOOL g_bIsNT;
extern BOOL g_bIsWin98;
extern UINT g_uACP;

#ifdef  __cplusplus

extern LCDetect * g_pLCDetect; // LCDETECT

#endif  // __cplusplus

//
//  Macros
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

#define VERIFY(f) AssertE(f)


#define ASSIGN_IF_FAILED(hr, exp) {HRESULT hrTemp = (exp); if (FAILED(hrTemp) && SUCCEEDED(hr)) (hr) = hrTemp;}

#define ASSERT_READ_PTR(p) ASSERT(!::IsBadReadPtr((p), sizeof(*p)))
#define ASSERT_READ_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadReadPtr((p), sizeof(*p)))
#define ASSERT_WRITE_PTR(p) ASSERT(!::IsBadWritePtr((p), sizeof(*p)))
#define ASSERT_WRITE_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadWritePtr((p), sizeof(*p)))
#define ASSERT_READ_BLOCK(p,s) ASSERT(!::IsBadReadPtr((p), sizeof(*p) * (s)))
#define ASSERT_READ_BLOCK_OR_NULL(p,s) ASSERT(!(p) || !::IsBadReadPtr((p), sizeof(*p) * (s)))
#define ASSERT_WRITE_BLOCK(p,s) ASSERT(!::IsBadWritePtr((p), sizeof(*p) * (s)))
#define ASSERT_WRITE_BLOCK_OR_NULL(p,s) ASSERT(!(p) || !::IsBadWritePtr((p), sizeof(*p) * (s)))
#define ASSERT_TSTR_PTR(p) ASSERT(!::IsBadStringPtr((p), (UINT)-1))
#define ASSERT_TSTR_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadStringPtr((p), (UINT)-1))
#define ASSERT_WSTR_PTR(p) ASSERT(!::IsBadStringPtrW((p), (UINT)-1))
#define ASSERT_WSTR_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadStringPtrW((p), (UINT)-1))
#define ASSERT_STR_PTR(p) ASSERT(!::IsBadStringPtrA((p), (UINT)-1))
#define ASSERT_STR_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadStringPtrA((p), (UINT)-1))
#define ASSERT_CODE_PTR(p) ASSERT(!::IsBadCodePtr((FARPROC)(p)))
#define ASSERT_CODE_PTR_OR_NULL(p) ASSERT(!(p) || !::IsBadCodePtr((FARPROC)(p)))
#define ASSERT_THIS ASSERT_WRITE_PTR(this)

#ifdef NEWMLSTR
// Error Code
#define FACILITY_MLSTR                  0x0A15
#define MLSTR_E_ACCESSDENIED            MAKE_HRESULT(1, FACILITY_MLSTR, 2001)
#define MLSTR_E_BUSY                    MAKE_HRESULT(1, FACILITY_MLSTR, 2002)
#define MLSTR_E_TOOMANYNESTOFLOCK       MAKE_HRESULT(1, FACILITY_MLSTR, 1003)
#define MLSTR_E_STRBUFNOTAVAILABLE      MAKE_HRESULT(1, FACILITY_MLSTR, 1004)

#define MLSTR_LOCK_TIMELIMIT            100
#define MLSTR_CONF_MAX                  0x40000000
#define MAX_LOCK_COUNT                  4
#endif

#define BIT_HEADER_CHARSET              0x1
#define BIT_BODY_CHARSET                0x2
#define BIT_WEB_CHARSET                 0x4
#define BIT_WEB_FIXED_WIDTH_FONT        0x8 
#define BIT_PROPORTIONAL_FONT           0x10
#define BIT_DESCRIPTION                 0x20
#define BIT_FAMILY                      0x40
#define BIT_LEVEL                       0x80
#define BIT_ENCODING                    0x100

#define BIT_DEL_HEADER_CHARSET          0x10000
#define BIT_DEL_BODY_CHARSET            0x20000
#define BIT_DEL_WEB_CHARSET             0x40000
#define BIT_DEL_WEB_FIXED_WIDTH_FONT    0x80000 
#define BIT_DEL_PROPORTIONAL_FONT       0x100000
#define BIT_DEL_DESCRIPTION             0x200000
#define BIT_DEL_FAMILY                  0x400000
#define BIT_DEL_LEVEL                   0x800000
#define BIT_DEL_ENCODING                0x1000000

#define BIT_CODEPAGE                    0x1
#define BIT_INTERNET_ENCODING           0x2
#define BIT_ALIAS_FOR_CHARSET           0x4

#define CPBITS_WINDOWS                     0x1
#define CPBITS_EXTENDED                    0x2
#define CPBITS_STRICT                      0x4

#define DETECTION_MAX_LEN               20*1024     // Limit max auto-detect length to 20k
#define IS_DIGITA(ch)    InRange(ch, '0', '9')
#define IS_DIGITW(ch)    InRange(ch, L'0', L'9')
#define IS_CHARA(ch)     (InRange(ch, 'a', 'z') && InRange(ch, 'A', 'Z'))
#define IS_NLS_DLL_CP(x) (InRange(x, 57002, 57011) || ((x) == CP_18030))
#define IS_HINDI_CHAR(x) (InRange(x, 0x0900, 0x0DFF) || InRange(x, 0x0F00, 0x10FF))
#define IS_PUA_CHAR(x)   (InRange(x, 0xE000, 0xF8FF))
#define IS_CJK_CHAR(x)   (InRange(x, 0x3000, 0x9FFF) || InRange(x, 0xAC00, 0xD7A3) || InRange(x, 0xF900, 0xFAFF) || InRange(x, 0xFF00, 0xFFEF))
#define IS_CHS_LEADBYTE(x) (InRange(x, 0x81, 0xFE))
#define IS_KOR_LEADBYTE(x) (InRange(x, 0x81, 0xFE))


// Internal define for K1 Hanja support
// In future version of MLang, we might need to update this bit define if there is a conflict with system define
#define FS_MLANG_K1HANJA 0x10000000L

//
// We support following code pages for outbound encoding detection
//      Windows  : 1252, 1250, 1251, 1253, 1254, 1257, 1258, 1256, 1255, 874, 932, 949, 950, 936
//      Unicode  : 65001, 65000, 1200
//      ISO      : 28591, 28592, 20866, 28595, 28597, 28593, 28594, 28596, 28598, 28605, 28599
//      Others   : 20127, 50220, 51932, 51949, 50225, 52936
//
// Default priorities
//       20127 > Windows > ISO > Others > Unicode
//

// Internal define of extented code pages
#define FS_MLANG_28591               0x00000001L
#define FS_MLANG_28592               0x00000002L
#define FS_MLANG_28595               0x00000004L
#define FS_MLANG_28597               0x00000008L
#define FS_MLANG_28593               0x00000010L
#define FS_MLANG_28598               0x00000020L
#define FS_MLANG_28596               0x00000040L
#define FS_MLANG_28594               0x00000080L
#define FS_MLANG_28599               0x00000200L
#define FS_MLANG_28605               0x00000400L
#define FS_MLANG_20127               0x00000800L
#define FS_MLANG_50220               0x00001000L
#define FS_MLANG_51932               0x00002000L
#define FS_MLANG_51949               0x00004000L
#define FS_MLANG_50225               0x00008000L
#define FS_MLANG_52936               0x00010000L
#define FS_MLANG_65000               0x00020000L
#define FS_MLANG_65001               0x00040000L
#define FS_MLANG_1200                0x00080000L
#define FS_MLANG_20866               0x00100000L
#define FS_MLANG_21866               0x00200000L
#define FS_MLANG_38598               0x00400000L
#define FS_MLANG_50221               0x00800000L
#define FS_MLANG_50222               0x01000000L

#define FS_CJK                       0x00000001L
#define FS_HINDI                     0x00000002L
#define FS_PUA                       0x00000004L

// Returns TRUE/FALSE depending on question
#define OS_WINDOWS                  0           // windows vs. NT
#define OS_NT                       1           // windows vs. NT
#define OS_WIN95ORGREATER           2           // Win95 or greater
#define OS_NT4ORGREATER             3           // NT4 or greater
// don't use (used to be OS_NT5)    4           // this flag is redundant w/ OS_WIN2000ORGREATER, use that instead  ;internal
#define OS_WIN98ORGREATER           5           // Win98 or greater
#define OS_WIN98_GOLD               6           // Win98 Gold (Version 4.10 build 1998)
#define OS_WIN2000ORGREATER         7           // Some derivative of Win2000

// NOTE: these flags are bogus, they check explicitly for (dwMajorVersion == 5) so they will fail when majorversion is bumped to 6
// !!! DO NOT USE THESE FLAGS !!!
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server in "Application Server" mode (now simply called "Terminal Server")
// END bogus flags

#define OS_EMBEDDED                 13          // Embedded Windows Edition
#define OS_TERMINALCLIENT           14          // Windows Terminal Client (eg user is comming in via tsclient)
#define OS_TERMINALREMOTEADMIN      15          // Terminal Server in "Remote Administration" mode
#define OS_WIN95_GOLD               16          // Windows 95 Gold (Version 4.0 Build 1995)
#define OS_MILLENNIUMORGREATER      17          // Windows Millennium (Version 5.0)

#define OS_WHISTLERORGREATER        18          // Whistler or greater
#define OS_PERSONAL                 19          // Personal (eg NOT Professional, Server, Advanced Server, or Datacenter)


#ifdef UNIX // Add some type that's not defined in UNIX SDK
typedef WORD UWORD;
#endif

#define REG_KEY_NT5LPK                    TEXT("W2KLpk")
#define REGSTR_PATH_NT5LPK_INSTALL        TEXT("System\\CurrentControlSet\\Control\\NLS\\Language Groups")
#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\resource.h ===
#include "windows.h"
// For NT5 langpack dialog
#define IDD_DIALOG_LPK                  101
#define IDC_CHECK_LPK                   1000
#define IDC_STATIC_LANG                 201
#define IDC_STATIC                      -1

//
//  IDs for Mime Language Name (0x1000 - 0x10FF)
//
#define IDS_MIME_LANG_DEFAULT           0x1000
#define IDS_LANGPACK_INSTALL            0x1001
#define IDS_NO_ADMIN                    0x1002
#define IDS_NT5_LANGPACK                0x1003
//
//  IDs for Mime RFC1766 Name (0x1100 - 0x11FF)
//
#define IDS_RFC1766_LCID0436            0x1100            
#define IDS_RFC1766_LCID041C            0x1101
#define IDS_RFC1766_LCID0001            0x1102
#define IDS_RFC1766_LCID0401            0x1103
#define IDS_RFC1766_LCID0801            0x1104
#define IDS_RFC1766_LCID0C01            0x1105
#define IDS_RFC1766_LCID1001            0x1106
#define IDS_RFC1766_LCID1401            0x1107
#define IDS_RFC1766_LCID1801            0x1108
#define IDS_RFC1766_LCID1C01            0x1109
#define IDS_RFC1766_LCID2001            0x110A
#define IDS_RFC1766_LCID2401            0x110B
#define IDS_RFC1766_LCID2801            0x110C
#define IDS_RFC1766_LCID2C01            0x110D
#define IDS_RFC1766_LCID3001            0x110E
#define IDS_RFC1766_LCID3401            0x110F
#define IDS_RFC1766_LCID3801            0x1110
#define IDS_RFC1766_LCID3C01            0x1111
#define IDS_RFC1766_LCID4001            0x1112
#define IDS_RFC1766_LCID042D            0x1113
#define IDS_RFC1766_LCID0402            0x1114
#define IDS_RFC1766_LCID0423            0x1115
#define IDS_RFC1766_LCID0403            0x1116
#define IDS_RFC1766_LCID0004            0x1117
#define IDS_RFC1766_LCID0404            0x1118
#define IDS_RFC1766_LCID0804            0x1119
#define IDS_RFC1766_LCID0C04            0x111A
#define IDS_RFC1766_LCID1004            0x111B
#define IDS_RFC1766_LCID041A            0x111C
#define IDS_RFC1766_LCID0405            0x111D
#define IDS_RFC1766_LCID0406            0x111E
#define IDS_RFC1766_LCID0413            0x111F
#define IDS_RFC1766_LCID0813            0x1120
#define IDS_RFC1766_LCID0009            0x1121
#define IDS_RFC1766_LCID0409            0x1122
#define IDS_RFC1766_LCID0809            0x1123
#define IDS_RFC1766_LCID0C09            0x1124
#define IDS_RFC1766_LCID1009            0x1125
#define IDS_RFC1766_LCID1409            0x1126
#define IDS_RFC1766_LCID1809            0x1127
#define IDS_RFC1766_LCID1C09            0x1128
#define IDS_RFC1766_LCID2009            0x1129
#define IDS_RFC1766_LCID2809            0x112A
#define IDS_RFC1766_LCID2C09            0x112B
#define IDS_RFC1766_LCID0425            0x112C
#define IDS_RFC1766_LCID0438            0x112D
#define IDS_RFC1766_LCID0429            0x112E
#define IDS_RFC1766_LCID040B            0x112F
#define IDS_RFC1766_LCID040C            0x1130
#define IDS_RFC1766_LCID080C            0x1131
#define IDS_RFC1766_LCID0C0C            0x1132
#define IDS_RFC1766_LCID100C            0x1133
#define IDS_RFC1766_LCID140C            0x1134
#define IDS_RFC1766_LCID043C            0x1135
#define IDS_RFC1766_LCID0407            0x1136
#define IDS_RFC1766_LCID0807            0x1137
#define IDS_RFC1766_LCID0C07            0x1138
#define IDS_RFC1766_LCID1007            0x1139
#define IDS_RFC1766_LCID1407            0x113A
#define IDS_RFC1766_LCID0408            0x113B
#define IDS_RFC1766_LCID040D            0x113C
#define IDS_RFC1766_LCID0439            0x113D
#define IDS_RFC1766_LCID040E            0x113E
#define IDS_RFC1766_LCID040F            0x113F
#define IDS_RFC1766_LCID0421            0x1140
#define IDS_RFC1766_LCID0410            0x1141
#define IDS_RFC1766_LCID0810            0x1142
#define IDS_RFC1766_LCID0411            0x1143
#define IDS_RFC1766_LCID0412            0x1144
#define IDS_RFC1766_LCID0426            0x1145
#define IDS_RFC1766_LCID0427            0x1146
#define IDS_RFC1766_LCID042F            0x1147
#define IDS_RFC1766_LCID043E            0x1148
#define IDS_RFC1766_LCID043A            0x1149
#define IDS_RFC1766_LCID0414            0x114A
#define IDS_RFC1766_LCID0814            0x114B
#define IDS_RFC1766_LCID0415            0x114C
#define IDS_RFC1766_LCID0416            0x114D
#define IDS_RFC1766_LCID0816            0x114E
#define IDS_RFC1766_LCID0417            0x114F
#define IDS_RFC1766_LCID0418            0x1150
#define IDS_RFC1766_LCID0818            0x1151
#define IDS_RFC1766_LCID0419            0x1152
#define IDS_RFC1766_LCID0819            0x1153
#define IDS_RFC1766_LCID0C1A            0x1154
#define IDS_RFC1766_LCID081A            0x1155
#define IDS_RFC1766_LCID041B            0x1156
#define IDS_RFC1766_LCID0424            0x1157
#define IDS_RFC1766_LCID042E            0x1158
#define IDS_RFC1766_LCID040A            0x1159
#define IDS_RFC1766_LCID080A            0x115A
#define IDS_RFC1766_LCID0C0A            0x115B
#define IDS_RFC1766_LCID100A            0x115C
#define IDS_RFC1766_LCID140A            0x115D
#define IDS_RFC1766_LCID180A            0x115E
#define IDS_RFC1766_LCID1C0A            0x115F
#define IDS_RFC1766_LCID200A            0x1160
#define IDS_RFC1766_LCID240A            0x1161
#define IDS_RFC1766_LCID280A            0x1162
#define IDS_RFC1766_LCID2C0A            0x1163
#define IDS_RFC1766_LCID300A            0x1164
#define IDS_RFC1766_LCID340A            0x1165
#define IDS_RFC1766_LCID380A            0x1166
#define IDS_RFC1766_LCID3C0A            0x1167
#define IDS_RFC1766_LCID400A            0x1168
#define IDS_RFC1766_LCID440A            0x1169
#define IDS_RFC1766_LCID480A            0x116A
#define IDS_RFC1766_LCID4C0A            0x116B
#define IDS_RFC1766_LCID500A            0x116C
#define IDS_RFC1766_LCID0430            0x116D
#define IDS_RFC1766_LCID041D            0x116E
#define IDS_RFC1766_LCID081D            0x116F
#define IDS_RFC1766_LCID041E            0x1170
#define IDS_RFC1766_LCID0431            0x1171
#define IDS_RFC1766_LCID0432            0x1172
#define IDS_RFC1766_LCID041F            0x1173
#define IDS_RFC1766_LCID0422            0x1174
#define IDS_RFC1766_LCID0420            0x1175
#define IDS_RFC1766_LCID042A            0x1176
#define IDS_RFC1766_LCID0434            0x1177
#define IDS_RFC1766_LCID043D            0x1178
#define IDS_RFC1766_LCID0435            0x1179
#define IDS_RFC1766_LCID1404            0x117A
#define IDS_RFC1766_LCID2409            0x117B
#define IDS_RFC1766_LCID3009            0x117C
#define IDS_RFC1766_LCID3409            0x117D
#define IDS_RFC1766_LCID180C            0x117E
#define IDS_RFC1766_LCID042C            0x117F
#define IDS_RFC1766_LCID0843            0x1180
#define IDS_RFC1766_LCID0443            0x1181
#define IDS_RFC1766_LCID042B            0x1182
#define IDS_RFC1766_LCID0437            0x1183
#define IDS_RFC1766_LCID043F            0x1184
#define IDS_RFC1766_LCID0441            0x1185
#define IDS_RFC1766_LCID0444            0x1186
#define IDS_RFC1766_LCID0445            0x1187
#define IDS_RFC1766_LCID0446            0x1188
#define IDS_RFC1766_LCID0447            0x1189
#define IDS_RFC1766_LCID0448            0x118A
#define IDS_RFC1766_LCID0449            0x118B
#define IDS_RFC1766_LCID044A            0x118C
#define IDS_RFC1766_LCID044B            0x118D
#define IDS_RFC1766_LCID044C            0x118E
#define IDS_RFC1766_LCID044D            0x118F
#define IDS_RFC1766_LCID044E            0x1191
#define IDS_RFC1766_LCID083E            0x1192
#define IDS_RFC1766_LCID0861            0x1193
#define IDS_RFC1766_LCID044F            0x1194
// #define IDS_RFC1766_LCID0827            0x1195
#define IDS_RFC1766_LCID0457            0x1196
#define IDS_RFC1766_LCID082C            0x1197
#define IDS_RFC1766_LCID0440            0x1198
#define IDS_RFC1766_LCID0450            0x1199
#define IDS_RFC1766_LCID0456            0x119A
#define IDS_RFC1766_LCID045A            0x119B
#define IDS_RFC1766_LCID0465            0x119C
#define IDS_RFC1766_LCID540A            0x119D


//
//  IDs for Mime Codepage Name (0x1200 - 0x12FF)
//
#define IDS_DESC_1200                   0x1200
#define IDS_DESC_1201                   0x1201
#define IDS_DESC_1250                   0x1202
#define IDS_DESC_1251                   0x1203
#define IDS_DESC_1252                   0x1204
#define IDS_DESC_1253                   0x1205
#define IDS_DESC_1254                   0x1206
#define IDS_DESC_1255                   0x1207
#define IDS_DESC_1256                   0x1208
#define IDS_DESC_1257                   0x1209
#define IDS_DESC_1258                   0x120A
#define IDS_DESC_20105                  0x120B
#define IDS_DESC_20106                  0x120C
#define IDS_DESC_20107                  0x120D
#define IDS_DESC_20108                  0x120E
#define IDS_DESC_20866                  0x120F
#define IDS_DESC_21866                  0x1210
#define IDS_DESC_28592                  0x1211
#define IDS_DESC_28593                  0x1212
#define IDS_DESC_28594                  0x1213
#define IDS_DESC_28595                  0x1214
#define IDS_DESC_28596                  0x1215
#define IDS_DESC_28597                  0x1216
#define IDS_DESC_28598                  0x1217
#define IDS_DESC_50000                  0x1218
#define IDS_DESC_50220                  0x1219
#define IDS_DESC_50221                  0x121A
#define IDS_DESC_50222                  0x121B
#define IDS_DESC_50225                  0x121C
#define IDS_DESC_50932                  0x121D
#define IDS_DESC_50949                  0x121E
#define IDS_DESC_51932                  0x121F
#define IDS_DESC_51949                  0x1220
#define IDS_DESC_52936                  0x1221
#define IDS_DESC_65000                  0x1222
#define IDS_DESC_65001                  0x1223
#define IDS_DESC_852                    0x1224
#define IDS_DESC_866                    0x1225
#define IDS_DESC_874                    0x1226
#define IDS_DESC_932                    0x1227
#define IDS_DESC_936                    0x1228
#define IDS_DESC_949                    0x1229
#define IDS_DESC_950                    0x122A
#define IDS_DESC_38598                  0x122B
#define IDS_DESC_50001                  0x122C
#define IDS_DESC_708                    0x122D
#define IDS_DESC_720                    0x122E
#define IDS_DESC_862                    0x122F
#define IDS_DESC_28591                  0x1230
#define IDS_DESC_50936                  0x1231
#define IDS_DESC_50950                  0x1232   
#define IDS_DESC_51251                  0x1233
#define IDS_DESC_51253                  0x1234    
#define IDS_DESC_51256                  0x1235    
#define IDS_DESC_28599                  0x1236    
#define IDS_DESC_28605                  0x1237    
#define IDS_DESC_20127                  0x1238
#define IDS_DESC_51936                  0x1239
#define IDS_DESC_1361                   0x123A
#define IDS_DESC_437                    0x123B
#define IDS_DESC_1252_IE4               0x123C
#define IDS_DESC_29001                  0x123D
#define IDS_DESC_20000                  0x123E
#define IDS_DESC_20002                  0x123F
#define IDS_DESC_28603                  0x1240
#define IDS_DESC_850                    0x1241
#define IDS_DESC_737                    0x1242
#define IDS_DESC_869                    0x1243
#define IDS_DESC_775                    0x1244
#define IDS_DESC_857                    0x1245
#define IDS_DESC_861                    0x1246
#define IDS_DESC_10000                  0x1247
#define IDS_DESC_10001                  0x1248
#define IDS_DESC_10002                  0x1249
#define IDS_DESC_10003                  0x124A
#define IDS_DESC_10004                  0x124B
#define IDS_DESC_10005                  0x125C
#define IDS_DESC_10006                  0x125D
#define IDS_DESC_10007                  0x125E
#define IDS_DESC_10008                  0x125F
#define IDS_DESC_10029                  0x1260
#define IDS_DESC_10079                  0x1261
#define IDS_DESC_10081                  0x1262
#define IDS_DESC_37                     0x1263
#define IDS_DESC_500                    0x1264
#define IDS_DESC_870                    0x1265
#define IDS_DESC_875                    0x1266
#define IDS_DESC_1026                   0x1267
#define IDS_DESC_20273                  0x1268
#define IDS_DESC_20277                  0x1269
#define IDS_DESC_20278                  0x126A
#define IDS_DESC_20280                  0x126B
#define IDS_DESC_20284                  0x126C
#define IDS_DESC_20285                  0x126D
#define IDS_DESC_20290                  0x126E
#define IDS_DESC_20297                  0x126F
#define IDS_DESC_20420                  0x1270
#define IDS_DESC_20423                  0x1271
#define IDS_DESC_20424                  0x1272
#define IDS_DESC_20833                  0x1273
#define IDS_DESC_20838                  0x1274
#define IDS_DESC_20871                  0x1275
#define IDS_DESC_20880                  0x1276
#define IDS_DESC_20905                  0x1277
#define IDS_DESC_21025                  0x1278
#define IDS_DESC_50930                  0x1279
#define IDS_DESC_50931                  0x127A
#define IDS_DESC_50939                  0x127B
#define IDS_DESC_50933                  0x127C
#define IDS_DESC_50935                  0x127D
#define IDS_DESC_50937                  0x127E

#define IDS_DESC_1140                   0x127F
#define IDS_DESC_1141                   0x1280
#define IDS_DESC_1142                   0x1281
#define IDS_DESC_1143                   0x1282
#define IDS_DESC_1144                   0x1283
#define IDS_DESC_1145                   0x1284
#define IDS_DESC_1146                   0x1285
#define IDS_DESC_1147                   0x1286
#define IDS_DESC_1148                   0x1287
#define IDS_DESC_1149                   0x1288
#define IDS_DESC_57006                  0x1289
#define IDS_DESC_57003                  0x128A
#define IDS_DESC_57002                  0x128B
#define IDS_DESC_57010                  0x128C
#define IDS_DESC_57008                  0x128D
#define IDS_DESC_57009                  0x128E
#define IDS_DESC_57007                  0x128F
#define IDS_DESC_57011                  0x1290
#define IDS_DESC_57005                  0x1291
#define IDS_DESC_57004                  0x1292
#define IDS_DESC_10021                  0x1293
#define IDS_DESC_10010                  0x1294
#define IDS_DESC_10017                  0x1295
#define IDS_DESC_10082                  0x1296    
#define IDS_DESC_860                    0x1297    
#define IDS_DESC_863                    0x1298    
#define IDS_DESC_864                    0x1299    
#define IDS_DESC_865                    0x129A
#define IDS_DESC_54936                  0x129B
#define IDS_DESC_855                    0x129C
#define IDS_DESC_858                    0x129D
#define IDS_DESC_20924                  0x129E
#define IDS_DESC_1047                   0x129F
#define IDS_DESC_20001                  0x12a0
#define IDS_DESC_20003                  0x12a1
#define IDS_DESC_20004                  0x12a2
#define IDS_DESC_20005                  0x12a3
#define IDS_DESC_20261                  0x12a4
#define IDS_DESC_20269                  0x12a5
#define IDS_DESC_20936                  0x12a6
#define IDS_DESC_20949                  0x12a7
#define IDS_DESC_21027                  0x12a8
#define IDS_DESC_50227                  0x12a9
#define IDS_DESC_50229                  0x12aA
#define IDS_DESC_20932                  0x12AB

//
//  IDs for Mime Fontface Name (0x1300 - 0x13FF)
//
#define IDS_FONT_JAPANESE_FIXED         0x1300
#define IDS_FONT_JAPANESE_PROP          0x1301
#define IDS_FONT_CHINESE_FIXED          0x1302
#define IDS_FONT_CHINESE_PROP           0x1303
// a-ehuang: mail-Hyo Kyoung Kim-Kevin Gjerstad-9/14/98
#define IDS_FONT_KOREAN_FIXED           0x1304
#define IDS_FONT_KOREAN_PROP            0x1305
#define IDS_FONT_KOREAN_FIXED4          0x1306
#define IDS_FONT_KOREAN_PROP4           0x1307
// end-of-change
#define IDS_FONT_TAIWAN_FIXED           0x1308
#define IDS_FONT_TAIWAN_PROP            0x1309
#define IDS_FONT_WESTERN_FIXED          0x130A
#define IDS_FONT_WESTERN_PROP           0x130B
#define IDS_FONT_UNICODE_PROP           0x130C
#define IDS_FONT_HEBREW_FIXED           0x130D
#define IDS_FONT_HEBREW_PROP            0x130E
#define IDS_FONT_THAI_FIXED             0x130F
#define IDS_FONT_THAI_PROP              0x1310

#define IDS_FONT_ARABIC_FIXED           0x1311
#define IDS_FONT_ARABIC_PROP            0x1312
#define IDS_FONT_DEVANAGARI_FIXED       0x1313
#define IDS_FONT_DEVANAGARI_PROP        0x1314
#define IDS_FONT_TAMIL_FIXED            0x1315
#define IDS_FONT_TAMIL_PROP             0x1316
#define IDS_FONT_WESTERN_PROP2          0x1317
#define IDS_FONT_THAI_FIXED2            0x1318
#define IDS_FONT_THAI_PROP2             0x1319


//
// IDs for script descriptions (0x1400 - -x14FF)
//
#define IDS_SIDASCIILATIN               0x1400
#define IDS_SIDLATIN                    0x1401
#define IDS_SIDGREEK                    0x1402
#define IDS_SIDCYRILLIC                 0x1403
#define IDS_SIDARMENIAN                 0x1404
#define IDS_SIDHEBREW                   0x1405
#define IDS_SIDARABIC                   0x1406
#define IDS_SIDDEVANAGARI               0x1407
#define IDS_SIDBENGALI                  0x1408
#define IDS_SIDGURMUKHI                 0x1409
#define IDS_SIDGUJARATI                 0x140A
#define IDS_SIDORIYA                    0x140B
#define IDS_SIDTAMIL                    0x140C
#define IDS_SIDTELUGU                   0x140D
#define IDS_SIDKANNADA                  0x140E
#define IDS_SIDMALAYALAM                0x140F
#define IDS_SIDTHAI                     0x1410
#define IDS_SIDLAO                      0x1411
#define IDS_SIDTIBETAN                  0x1412
#define IDS_SIDGEORGIAN                 0x1413
#define IDS_SIDHANGUL                   0x1414
#define IDS_SIDKANA                     0x1415
#define IDS_SIDBOPOMOFO                 0x1416
#define IDS_SIDHAN                      0x1417
#define IDS_SIDETHIOPIC                 0x1418
#define IDS_SIDCANSYLLABIC              0x1419
#define IDS_SIDCHEROKEE                 0x141A
#define IDS_SIDYI                       0x141B
#define IDS_SIDBRAILLE                  0x141C
#define IDS_SIDRUNIC                    0x141D
#define IDS_SIDOGHAM                    0x141E
#define IDS_SIDSINHALA                  0x141F
#define IDS_SIDSYRIAC                   0x1420
#define IDS_SIDBURMESE                  0x1421
#define IDS_SIDKHMER                    0x1422
#define IDS_SIDTHAANA                   0x1423
#define IDS_SIDMONGOLIAN                0x1424
#define IDS_SIDDEFAULT                  0x1426
#define IDS_SIDMERGE                    0x1427
#define IDS_SIDASCIISYM                 0x1428
#define IDS_SIDUSERDEFINED              0x1429

//                                      
//  Other Resource IDs                  
//                                      
#define IDR_CODEPAGES                   0x2000
#define IDR_CODEPAGESEXT                0x2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\rfc1766.cpp ===
#include "private.h"

//
//  Globals
//


#if 0
STDAPI EnumRfc1766Info(DWORD dwIndex, PRFC1766INFOA pRfc1766Info)
{
    EnsureRfc1766Table();

    if (NULL != pRfc1766Info)
    {
        if (dwIndex < g_cRfc1766)
        {
            *pRfc1766Info = g_pRfc1766[dwIndex];
            return S_OK;    
        }
        else
            return S_FALSE;
    }
    return E_INVALIDARG;
}    
#endif

STDAPI LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    if (0 < iMaxLength)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            if (WideCharToMultiByte(1252, 0, MimeRfc1766[i].szRfc1766, -1, pszRfc1766, iMaxLength, NULL, NULL))
                hr = S_OK;
        }
        else
        {
            CHAR sz[MAX_RFC1766_NAME];

            int nISO639 = GetLocaleInfoA(Locale, LOCALE_SISO639LANGNAME, sz, ARRAYSIZE(sz));

            if (nISO639)
            {
                // Two letter language name
                if (nISO639 == 3)
                {
                    sz[2] = '-';
                    if (3 != GetLocaleInfoA(Locale, LOCALE_SISO3166CTRYNAME, &sz[3], ARRAYSIZE(sz)-3))
                    {
                        sz[2] = 0;
                    }
                }
                // Three letter language name
                else if (nISO639 == 4)
                {
                    sz[3] = 0;
                }

                if (nISO639 <= 4)
                {
                    CharLowerA(sz);

                    if (lstrcpynA(pszRfc1766, sz, iMaxLength))
                    {
                        hr = S_OK;
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}    



STDAPI LcidToRfc1766W(LCID Locale, LPWSTR pwszRfc1766, int nChar)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;

    if (0 < nChar)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (MimeRfc1766[i].LcId == Locale)
                break;
        }
        if (i < g_cRfc1766)
        {
            MLStrCpyNW(pwszRfc1766, MimeRfc1766[i].szRfc1766, nChar);
            hr = S_OK;
        }
        else
        {
            CHAR sz[MAX_RFC1766_NAME];
            int nISO639 = GetLocaleInfoA(Locale, LOCALE_SISO639LANGNAME, sz, ARRAYSIZE(sz));

            if (nISO639)
            {
                // Two letter language name
                if (nISO639 == 3)
                {
                    sz[2] = '-';
                    if (3 != GetLocaleInfoA(Locale, LOCALE_SISO3166CTRYNAME, &sz[3], ARRAYSIZE(sz)))
                    {
                        sz[2] = 0;
                    }
                }
                // Three letter language name
                else if (nISO639 == 4)
                {
                    sz[3] = 0;
                }

                if (nISO639 <= 4)
                {
                    CharLowerA(sz);

                    if (MultiByteToWideChar(1252, 0, sz, lstrlen(sz)+1, pwszRfc1766, nChar))
                    {
                        hr = S_OK;
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}    

STDAPI Rfc1766ToLcidW(PLCID pLocale, LPCWSTR pwszRfc1766)
{
    UINT i;
    HRESULT hr = E_INVALIDARG;
    
    if (NULL != pLocale && NULL != pwszRfc1766)
    {
        for (i = 0; i < g_cRfc1766; i++)
        {
            if (!MLStrCmpIW(MimeRfc1766[i].szRfc1766, pwszRfc1766))
                break;
        }
        if (i < g_cRfc1766)
        {
            *pLocale = MimeRfc1766[i].LcId;
            hr = S_OK;
        }
        else
        {
            if (InRange(lstrlenW(pwszRfc1766), 2, MAX_RFC1766_NAME-1))
            {
                WCHAR sz[MAX_RFC1766_NAME];
                LPWSTR pDash;

                MLStrCpyNW(sz, pwszRfc1766, MAX_RFC1766_NAME);

                pDash = wcschr(sz, L'-');

                if (pDash && (pDash - sz >= 2))
                {
                    *pDash = 0;
                }

                for (i = 0; i < g_cRfc1766; i++)
                {
                    if (!MLStrCmpIW(MimeRfc1766[i].szRfc1766, sz))
                        break;                
                }
                if (i < g_cRfc1766)
                {
                    *pLocale = MimeRfc1766[i].LcId;
                    hr = S_FALSE;
                }
                else
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
    }
    return hr;
}

STDAPI Rfc1766ToLcidA(PLCID pLocale, LPCSTR pszRfc1766)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != pLocale && NULL != pszRfc1766)
    {
        int i;
        WCHAR sz[MAX_RFC1766_NAME];


        for (i = 0; i < MAX_RFC1766_NAME - 1; i++)
        {
            sz[i] = (WCHAR)pszRfc1766[i];
            if (0 == sz[i])
                break;
        }
        if (i == MAX_RFC1766_NAME -1)
            sz[i] = 0;

        hr = Rfc1766ToLcidW(pLocale, (LPCWSTR)sz);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\sources.inc ===
CCSHELL_DIR         = $(PROJECT_ROOT)

TARGET_BOTH         = 1
NOT_UNICODE         = 1
PRECOMPILED_CXX     = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED        = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETTYPE          = DYNLINK
TARGETNAME          = mlang
TARGETPATH          = obj

UMTYPE              = windows

DLLENTRY            = _DllMainCRTStartup
DLLDEF              = ..\mlang.def

PRECOMPILED_INCLUDE = ..\private.h

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS          = $(SDK_LIB_PATH)\kernel32.lib      \
                      $(SDK_LIB_PATH)\user32.lib        \
                      $(SDK_LIB_PATH)\gdi32.lib         \
                      $(SDK_LIB_PATH)\advapi32.lib      \
                      $(SDK_LIB_PATH)\uuid.lib          \
                      $(SDK_LIB_PATH)\ole32.lib         \
                      $(SDK_LIB_PATH)\shlwapi.lib       \
                      $(SDK_LIB_PATH)\version.lib       \
                      $(CCSHELL_DIR)\lib\$O\stock4.lib  \
                      $(CCSHELL_DIR)\lib\$(O)\shfusion.lib 


USE_MSVCRT          = 1

INCLUDES            = $(INCLUDES); \
                      $(BASEDIR)\public\sdk\inc\atl21

# Multi Language part
SOURCES_ML          = ..\mlang.rc      \
                      ..\init.cpp      \
                      ..\mimedb.cpp    \
                      ..\mimereg.cpp   \
                      ..\rfc1766.cpp   \
                      ..\enumcp.cpp    \
                      ..\mlang.cpp     \
                      ..\dllload.cpp   \
                      ..\reg.cpp       \
                      ..\debug.c

# IMLConvertCharset part
SOURCES_CC          = ..\utf8obj.cpp   \
                      ..\utf7obj.cpp   \
                      ..\ichrcnv.cpp   \
                      ..\convbase.cpp  \
                      ..\convinet.cpp  \
                      ..\detcbase.cpp  \
                      ..\kscobj.cpp    \
                      ..\eucjobj.cpp   \
                      ..\hzgbobj.cpp   \
                      ..\jisobj.cpp    \
                      ..\convobj.cpp

# IMLangX part
SOURCES_MLX         = ..\mlflink.cpp   \
                      ..\mlstr.cpp     \
                      ..\mlstrw.cpp    \
                      ..\mlstra.cpp    \
                      ..\mlswalk.cpp   \
                      ..\mllbcons.cpp  \
                      ..\attrstr.cpp   \
                      ..\attrstrw.cpp  \
                      ..\attrstra.cpp  \
                      ..\attrloc.cpp   \
                      ..\util.cpp

# Multi Language detection
SOURCES_AUTO        = ..\fechauto.cpp   \
                      ..\fechmap.cpp    \
                      ..\jislex.cpp     \
                      ..\lcinit.cpp     \
                      ..\detcjpn.cpp    \
                      ..\detckrn.cpp    \
                      ..\cpdetect.cpp   \
                      ..\lcdetect.cpp   \
                      ..\validate.cpp   

SOURCES             = $(SOURCES_ML) $(SOURCES_CC) $(SOURCES_MLX) $(SOURCES_AUTO)


# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=123 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\utf7obj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from UTF-7
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "utf7obj.h"

//+-----------------------------------------------------------------------
//
//  Function:   IsBase64
//
//  Synopsis:   We use the following table to quickly determine if we have
//              a valid base64 character.
//
//------------------------------------------------------------------------

static UCHAR g_aBase64[256] =
{
  /*            0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   A,   B,   C,   D,   E,   F, */

  /* 00-0f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 10-1f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 20-2f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,  62, 255, 255, 255,  63,
  /* 30-3f */  52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 255, 255, 255, 255, 255, 255,
  /* 40-4f */ 255,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
  /* 50-5f */  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,
  /* 60-6f */ 255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
  /* 70-7f */  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51, 255, 255, 255, 255, 255,
  /* 80-8f */  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 90-9f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* a0-af */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* b0-bf */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* c0-cf */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* d0-df */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* e0-ef */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* f0-ff */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
};


// Direct encoded ASCII table
static UCHAR g_aDirectChar[128] =
{
  /*            0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   A,   B,   C,   D,   E,   F, */

  /* 00-0f */ 255, 255, 255, 255, 255, 255, 255, 255, 255,  72,  73, 255, 255,  74, 255, 255,
  /* 10-1f */ 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
  /* 20-2f */  71, 255, 255, 255, 255, 255, 255,  62,  63,  64, 255, 255,  65,  66,  67,  68,
  /* 30-3f */  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  69, 255, 255, 255, 255,  70,
  /* 40-4f */ 255,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
  /* 50-5f */  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,
  /* 60-6f */ 255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
  /* 70-7f */  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51, 255, 255, 255, 255, 255,
};

// Base64 byte value table
static UCHAR g_aInvBase64[] = { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };

static inline BOOL
IsBase64(UCHAR t )
{
    return g_aBase64[t] < 64;
}

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF7In::CInccUTF7In(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF7In::Reset()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_fUTF7Mode = FALSE ;
    m_nBitCount = 0 ;
    m_tcUnicode = 0 ;
    m_nOutCount = 0 ;
    return ;
}


/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccUTF7In::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF7In::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccUTF7In::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;

    // are we in UTF-7 mode ?
    if (m_fUTF7Mode )
    {
        if ( IsBase64(tc) )
        {
            UCHAR t64, outc ;
            LONG tcUnicode ;

            // save the Base64 value and update bit count
            t64 = g_aBase64[tc] ;
            m_tcUnicode = m_tcUnicode << 6 | t64 ;
            m_nBitCount += 6 ;

            // see if we accumulate enough bits
            if ( m_nBitCount >= 16 )
            {
                // get higher 16 bits data from buffer
                tcUnicode = m_tcUnicode >> ( m_nBitCount - 16 ) ;
                // output one Unicode char
                outc = (UCHAR) tcUnicode ;
                Output( outc );
                outc = (UCHAR) ( tcUnicode >> 8 ) ;
                fDone = Output( outc );

                // update output char count
                m_nOutCount ++ ;
                m_nBitCount -= 16 ;
            }
        }
        // not a Base64 char, reset UTF-7 mode
        else
        {
            // special case +- decodes to +
            if ( tc == '-' && m_nOutCount == 0 && m_nBitCount == 0 )
            {
                Output('+');
                fDone=Output(0);
            }
            // absorb shiht-out char '-', otherwise output char
            else if ( tc != '-')
            {
                Output(tc);
                fDone=Output(0);
            }
            // reset variables and UTF7Mode
            m_fUTF7Mode = FALSE ;
            m_nBitCount = 0 ;
            m_tcUnicode = 0 ;
            m_nOutCount = 0 ;
        }
    }
    // is it a UTF-7 shift-in char ?
    else if ( tc == '+' )
    {
        m_fUTF7Mode = TRUE ;
        m_nBitCount = 0 ;
        m_tcUnicode = 0 ;
        m_nOutCount = 0 ;
    }
    else
    // convert ASCII directly to Unicode if it is not in UFT-7 mode
    {
        Output(tc);
        fDone = Output(0);
    }

    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccUTF7In::CleanUpMain()
{
    return TRUE;
}

int CInccUTF7In::GetUnconvertBytes()
{
    return  0 ;
}

DWORD CInccUTF7In::GetConvertMode()
{
    DWORD dwMode ;

    if ( m_fUTF7Mode )
    {
        dwMode = ( m_tcUnicode & 0xffff ) | ( m_nBitCount << 16 ) ;
        if ( dwMode == 0 )
            dwMode = 1L ; // it is ok, since bitcount is 0
    }
    else
        dwMode = 0 ;

    return dwMode;
}

void CInccUTF7In::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    if (mode)
    {
        m_fUTF7Mode = TRUE ;
        m_tcUnicode = ( mode & 0x7fff );
        m_nBitCount = ( mode >> 16 ) & 0xffff ;
    }
    else
        m_fUTF7Mode = FALSE ;
}

// ============================================================================
// Internet Character Set Conversion: Output to UTF-7
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF7Out::CInccUTF7Out(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)

{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF7Out::Reset()
{
    m_fDoubleByte = FALSE;
    m_fUTF7Mode = FALSE ;
    m_nBitCount = 0 ;
    m_tcUnicode = 0 ;
    return;
}

HRESULT CInccUTF7Out::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    WORD uc ;

    // 2nd byte of Unicode
    if (m_fDoubleByte )
    {
        BOOL bNeedShift ;

        // compose the 16 bits char
        uc = ( (WORD) tc << 8 | m_tcFirstByte  ) ;

        // check whether the char can be direct encoded ?
        bNeedShift = uc > 0x7f ? TRUE : g_aDirectChar[(UCHAR)uc] == 255 ;

        if ( bNeedShift && m_fUTF7Mode == FALSE)
        {
            // output Shift-in char to change to UTF-7 Mode
            fDone = Output('+');

            // handle special case '+-'
            if ( uc == '+' ) // single byte "+"
            {
                fDone=Output('-');
            }
            else
                m_fUTF7Mode = TRUE ;
        }

        if (m_fUTF7Mode)
        {
            LONG tcUnicode ;
            UCHAR t64 ;
            int pad_bits ;

            // either write the char to the bit buffer 
            // or pad bit buffer out to a full base64 char
            if (bNeedShift)
            {
                m_tcUnicode = m_tcUnicode << 16 | uc ;
                m_nBitCount += 16 ;
            }
            // pad bit buffer out to a full base64 char
            else if (m_nBitCount % 6 )  
            {
                pad_bits = 6 - (m_nBitCount % 6 ) ;
                // get to next 6 multiple, pad these bits with 0
                m_tcUnicode = m_tcUnicode << pad_bits ;
                m_nBitCount += pad_bits ;
            }

            // flush out as many full base64 char as possible
            while ( m_nBitCount >= 6 && fDone )
            {
                tcUnicode = ( m_tcUnicode >> ( m_nBitCount - 6 ) );
                t64 = (UCHAR) ( tcUnicode & 0x3f ) ;
                fDone = Output(g_aInvBase64[t64]);
                m_nBitCount -= 6 ;
            }

            if (!bNeedShift)
            {
                // output Shift-out char
                fDone = Output('-');

                m_fUTF7Mode = FALSE ;
                m_nBitCount = 0 ;
                m_tcUnicode = 0 ;
            }
        }

        // the character can be directly encoded as ASCII
        if (!bNeedShift)
        {
            fDone = Output(m_tcFirstByte);
        }

        m_fDoubleByte = FALSE ;
    }
    // 1st byte of Unicode
    else
    {
        m_tcFirstByte = tc ;
        m_fDoubleByte = TRUE ;
    }
    
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF7Out::CleanUp()
{
    BOOL fDone = TRUE;

    if (m_fUTF7Mode)
    {
        UCHAR t64 ;
        LONG tcUnicode ;
        int pad_bits ;

        // pad bit buffer out to a full base64 char
        if (m_nBitCount % 6 )  
        {
            pad_bits = 6 - (m_nBitCount % 6 ) ;
            // get to next 6 multiple, pad these bits with 0
            m_tcUnicode = m_tcUnicode << pad_bits ;
            m_nBitCount += pad_bits ;
        }

        // flush out as many full base64 char as possible
        while ( m_nBitCount >= 6 && fDone )
        {
            tcUnicode = ( m_tcUnicode >> ( m_nBitCount - 6 ) );
            t64 = (UCHAR) ( tcUnicode & 0x3f ) ;
            fDone = Output(g_aInvBase64[t64]);
            m_nBitCount -= 6 ;
        }

        {
            // output Shift-out char
            fDone = Output('-');

            m_fUTF7Mode = FALSE ;
            m_nBitCount = 0 ;
            m_tcUnicode = 0 ;
        }
    }
    return fDone;
}

int CInccUTF7Out::GetUnconvertBytes()
{
    return  m_fDoubleByte ? 1 : 0 ;
}

DWORD CInccUTF7Out::GetConvertMode()
{
    return 0 ;
}

void CInccUTF7Out::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\utf7obj.h ===
#include "convbase.h"

class CInccUTF7In : public CINetCodeConverter
{
private:
    BOOL (CInccUTF7In::*m_pfnConv)(UCHAR tc);
    BOOL (CInccUTF7In::*m_pfnCleanUp)();

    LONG m_tcUnicode ;
    BOOL m_fUTF7Mode;
    int  m_nBitCount;
    int  m_nOutCount;

public:
    CInccUTF7In(UINT uCodePage, int nCodeSet);
    ~CInccUTF7In() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset();    // initialization
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();
};

class CInccUTF7Out : public CINetCodeConverter
{
private:
    BOOL m_fUTF7Mode;
    BOOL m_fDoubleByte;
    BYTE m_tcFirstByte;
    int  m_nBitCount;
    LONG m_tcUnicode ;

public:
    CInccUTF7Out(UINT uCodePage, int nCodeSet);
    ~CInccUTF7Out() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset();    // initialization
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\util.cpp ===
// Util.cpp : Helper functions and classes
#include "private.h"
#include "mlmain.h"
#include <setupapi.h>
#include <tchar.h>

const CLSID CLSID_Japanese =  {0x76C19B30,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Korean   =  {0x76C19B31,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_PanEuro  =  {0x76C19B32,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_TradChinese =	{0x76C19B33,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_SimpChinese =	{0x76C19B34,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Thai        =	{0x76C19B35,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Hebrew      = {0x76C19B36,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Vietnamese  = {0x76C19B37,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Arabic      = {0x76C19B38,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};
const CLSID CLSID_Auto        = {0x76C19B50,0xF0C8,0x11cf,{0x87,0xCC,0x00,0x20,0xAF,0xEE,0xCF,0x20}};

TCHAR szFonts[]=TEXT("fonts");

static TCHAR s_szJaFont[] = TEXT("msgothic.ttf,msgothic.ttc");
// a-ehuang: mail-Hyo Kyoung Kim-Kevin Gjerstad-9/14/98
// OLD: static TCHAR s_szKorFont[] = TEXT("gulimche.ttf, gulim.ttf,gulim.ttc");
static TCHAR s_szKorFont[] = TEXT("gulim.ttf,gulim.ttc,gulimche.ttf");
// end-of-change
static TCHAR s_szZhtFont[] = TEXT("mingliu.ttf,mingliu.ttc");
static TCHAR s_szZhcFont[] = TEXT("mssong.ttf,simsun.ttc,mshei.ttf");
static TCHAR s_szThaiFont[] = TEXT("angsa.ttf,angsa.ttf,angsab.ttf,angsai.ttf,angsaz.ttf,upcil.ttf,upcib.ttf,upcibi.ttf, cordia.ttf, cordiab.ttf, cordiai.ttf, coradiaz.ttf");
static TCHAR s_szPeFont[] = TEXT("larial.ttf,larialbd.ttf,larialbi.ttf,lariali.ttf,lcour.ttf,lcourbd.ttf,lcourbi.ttf,lcouri.ttf,ltimes.ttf,ltimesbd.ttf,ltimesbi.ttf,ltimesi.ttf,symbol.ttf");
static TCHAR s_szArFont[] = TEXT("andlso.ttf, artrbdo.ttf, artro.ttf, simpbdo.ttf, simpfxo.ttf, tradbdo.ttf, trado.ttf");
static TCHAR s_szViFont[] = TEXT("VARIAL.TTF, VARIALBD.TTF, VARIALBI.TTF, VARIALI.TTF, VCOUR.TTF, VCOURBD.TTF, VCOURBI.TTF, VCOURI.TTF, VTIMES.TTF, VTIMESBD.TTF, VTIMESBI.TTF, VTIMESI.TTF");
static TCHAR s_szIwFont[] = TEXT("DAVID.TTF, DAVIDBD.TTF, DAVIDTR.TTF, MRIAM.TTF, MRIAMC.TTF, MRIAMFX.TTF, MRIAMTR.TTF, ROD.TTF");

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950))   

#define IS_COMPLEXSCRIPT_CODEPAGE(j) \
    (((j) == 874)   || \
    ((j) == 1255)   || \
    ((j) == 1256)   || \
    ((j) == 1258))   

#ifdef NEWMLSTR


#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// Helper functions

HRESULT RegularizePosLen(long lStrLen, long* plPos, long* plLen)
{
    ASSERT_WRITE_PTR(plPos);
    ASSERT_WRITE_PTR(plLen);

    long lPos = *plPos;
    long lLen = *plLen;

    if (lPos < 0)
        lPos = lStrLen;
    else
        lPos = min(lPos, lStrLen);

    if (lLen < 0)
        lLen = lStrLen - lPos;
    else
        lLen = min(lLen, lStrLen - lPos);

    *plPos = lPos;
    *plLen = lLen;

    return S_OK;
}

HRESULT LocaleToCodePage(LCID locale, UINT* puCodePage)
{
    HRESULT hr = S_OK;

    if (puCodePage)
    {
        TCHAR szCodePage[8];

        if (::GetLocaleInfo(locale, LOCALE_IDEFAULTANSICODEPAGE, szCodePage, ARRAYSIZE(szCodePage)) > 0)
            *puCodePage = _ttoi(szCodePage);
        else
            hr = E_FAIL; // NLS failed
    }

    return hr;
}

HRESULT StartEndConnection(IUnknown* const pUnkCPC, const IID* const piid, IUnknown* const pUnkSink, DWORD* const pdwCookie, DWORD dwCookie)
{
    ASSERT_READ_PTR(pUnkCPC);
    ASSERT_READ_PTR(piid);
    if (pdwCookie)
        ASSERT_WRITE_PTR(pUnkSink);
    ASSERT_READ_PTR_OR_NULL(pdwCookie);

    HRESULT hr;
    IConnectionPointContainer* pcpc;

    if (SUCCEEDED(hr = pUnkCPC->QueryInterface(IID_IConnectionPointContainer, (void**)&pcpc)))
    {
        ASSERT_READ_PTR(pcpc);

        IConnectionPoint* pcp;

        if (SUCCEEDED(hr = pcpc->FindConnectionPoint(*piid, &pcp)))
        {
            ASSERT_READ_PTR(pcp);

            if (pdwCookie)
                hr = pcp->Advise(pUnkSink, pdwCookie);
            else
                hr = pcp->Unadvise(dwCookie);

            pcp->Release();
        }

        pcpc->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLAlloc

CMLAlloc::CMLAlloc(void)
{
    if (FAILED(::CoGetMalloc(1, &m_pIMalloc)))
        m_pIMalloc = NULL;
}

CMLAlloc::~CMLAlloc(void)
{
    if (m_pIMalloc)
        m_pIMalloc->Release();
}

void* CMLAlloc::Alloc(ULONG cb)
{
    if (m_pIMalloc)
        return m_pIMalloc->Alloc(cb);
    else
        return ::malloc(cb);
}

void* CMLAlloc::Realloc(void* pv, ULONG cb)
{
    if (m_pIMalloc)
        return m_pIMalloc->Realloc(pv, cb);
    else
        return ::realloc(pv, cb);
}

void CMLAlloc::Free(void* pv)
{
    if (m_pIMalloc)
        m_pIMalloc->Free(pv);
    else
        ::free(pv);
}

/////////////////////////////////////////////////////////////////////////////
// CMLList

HRESULT CMLList::Add(void** ppv)
{
    if (!m_pFree) // No free cell
    {
        // Determine new size of the buffer
        const int cNewCell = (m_cbCell * m_cCell + m_cbIncrement + m_cbCell - 1) / m_cbCell;
        ASSERT(cNewCell > m_cCell);
        const long lNewSize = cNewCell * m_cbCell;

        // Allocate the buffer
        void *pNewBuf;
        if (!m_pBuf)
        {
            pNewBuf = MemAlloc(lNewSize);
        }
        else
        {
            pNewBuf = MemRealloc((void*)m_pBuf, lNewSize);
            ASSERT(m_pBuf == pNewBuf);
        }
        ASSERT_WRITE_BLOCK_OR_NULL((BYTE*)pNewBuf, lNewSize);

        if (pNewBuf)
        {
            // Add new cells to free link
            m_pFree = m_pBuf[m_cCell].m_pNext;
            for (int iCell = m_cCell; iCell + 1 < cNewCell; iCell++)
                m_pBuf[iCell].m_pNext = &m_pBuf[iCell + 1];
            m_pBuf[iCell].m_pNext = NULL;

            m_pBuf = (CCell*)pNewBuf;
            m_cCell = cNewCell;
        }
    }

    if (m_pFree)
    {
        // Get a new element from free link
        CCell* const pNewCell = m_pFree;
        m_pFree = pNewCell->m_pNext;
        *ppv = pNewCell;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }
}

HRESULT CMLList::Remove(void* pv)
{
    AssertPV(pv);
#ifdef DEBUG
    for (CCell* pWalk = m_pFree; pWalk && pWalk != pv; pWalk = pWalk->m_pNext)
        ;
    ASSERT(!pWalk); // pv is already in free link
#endif

    CCell* const pCell = (CCell* const)pv;
    pCell->m_pNext = m_pFree;
    m_pFree = pCell;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLListLru

HRESULT CMLListLru::Add(void** ppv)
{
    HRESULT hr;
    CCell* pCell;
    
    if (SUCCEEDED(hr = CMLList::Add((void**)&pCell)))
    {
        // Add the cell at the bottom of LRU link
        for (CCell** ppCell = &m_pTop; *ppCell; ppCell = &(*ppCell)->m_pNext)
            ;
        *ppCell = pCell;
        pCell->m_pNext = NULL;
    }

    *ppv = (void*)pCell;
    return hr;
}

HRESULT CMLListLru::Remove(void* pv)
{
    AssertPV(pv);

    // Look for previous cell of given
    for (CCell** ppWalk = &m_pTop; *ppWalk != pv && *ppWalk; ppWalk = &(*ppWalk)->m_pNext)
        ;
    ASSERT(!*ppWalk); // Not found in LRU link

    if (*ppWalk)
    {
        // Remove from LRU link
        CCell* const pCell = *ppWalk;
        *ppWalk = pCell->m_pNext;
    }

    // Add to free link
    return CMLList::Remove(pv);
}

/////////////////////////////////////////////////////////////////////////////
// CMLListFast

HRESULT CMLListFast::Add(void** ppv)
{
    HRESULT hr;
    CCell* pCell;
    
    if (SUCCEEDED(hr = CMLList::Add((void**)&pCell)))
    {
        // Add to top of double link
        pCell->m_pNext = m_pTop;
        CCell* const pPrev = m_pTop->m_pPrev;
        pCell->m_pPrev = pPrev;
        m_pTop = pCell;
        pPrev->m_pNext = pCell;
    }

    *ppv = (void*)pCell;
    return hr;
}

HRESULT CMLListFast::Remove(void* pv)
{
    AssertPV(pv);

    // Remove from double link
    CCell* const pCell = (CCell*)pv;
    CCell* const pPrev = pCell->m_pPrev;
    CCell* const pNext = (CCell*)pCell->m_pNext;
    pPrev->m_pNext = pNext;
    pNext->m_pPrev = pPrev;

    // Add to free link
    return CMLList::Remove(pv);
}

#endif // NEWMLSTR

HRESULT 
_FaultInIEFeature(HWND hwnd, uCLSSPEC *pclsspec, QUERYCONTEXT *pQ, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    typedef HRESULT (WINAPI *PFNJIT)(
        HWND hwnd, 
        uCLSSPEC *pclsspec, 
        QUERYCONTEXT *pQ, 
        DWORD dwFlags);
    static PFNJIT  pfnJIT = NULL;

    if (!pfnJIT && !g_hUrlMon)
    {
        g_hUrlMon = LoadLibrary(TEXT("urlmon.DLL"));
        if (g_hUrlMon)
            pfnJIT = (PFNJIT)GetProcAddress(g_hUrlMon, "FaultInIEFeature");
    }
    
    if (pfnJIT)
       hr = pfnJIT(hwnd, pclsspec, pQ, dwFlags);
       
    return hr;
}


HRESULT InstallIEFeature(HWND hWnd, CLSID *clsid, DWORD dwfIODControl)
{
   
    HRESULT     hr  = REGDB_E_CLASSNOTREG;
    uCLSSPEC    classpec;
    DWORD       dwfIEF = 0;
    
    classpec.tyspec=TYSPEC_CLSID;
    classpec.tagged_union.clsid=*clsid;

    if (dwfIODControl & CPIOD_PEEK)
        dwfIEF |= FIEF_FLAG_PEEK;

    if (dwfIODControl & CPIOD_FORCE_PROMPT)
        dwfIEF |= FIEF_FLAG_FORCE_JITUI;

    hr = _FaultInIEFeature(hWnd, &classpec, NULL, dwfIEF);

    if (hr != S_OK) {
        hr = REGDB_E_CLASSNOTREG;
    }
    return hr;
}

HRESULT _GetJITClsIDForCodePage(UINT uiCP, CLSID *clsid)
{
    switch(uiCP)
    {
        case 932: // JA
            *clsid = CLSID_Japanese;
            break;
        case 949: // KOR
            *clsid = CLSID_Korean;
            break;
        case 950: // ZHT
            *clsid = CLSID_TradChinese;
            break;
        case 936: // ZHC
            *clsid = CLSID_SimpChinese;
            break;
        case 874:
            *clsid = CLSID_Thai;
            break;
        case 1255:
            *clsid = CLSID_Hebrew;
            break;
        case 1256:
            *clsid = CLSID_Arabic;
            break;
        case 1258:
            *clsid = CLSID_Vietnamese;
            break;            
        case 1250:    // PANEURO
        case 1251: 
        case 1253:
        case 1254:
        case 1257:
            *clsid = CLSID_PanEuro;
            break;
        case 50001:
            *clsid = CLSID_Auto;
            break;
        default:
            return E_INVALIDARG;
    }
    
    return S_OK;
}

// Only good for family code pages.
HRESULT _ValidateCPInfo(UINT uiCP)
{
    HRESULT hr = E_FAIL;
    if (g_pMimeDatabase) // just a paranoid
    {
        switch(uiCP)
        {
            case 932: // JA
            case 949: // KOR
            case 874: // Thai
            case 950: // ZHT
            case 936: // ZHC
            case 1255: // Hebrew
            case 1256: // Arabic
            case 1258: // Vietnamese
            case 50001: // CP_AUTO
                // just validate what's given
                hr = g_pMimeDatabase->ValidateCP(uiCP);
                break;
            case 1250:    // PANEURO
            case 1251:
            case 1253:
            case 1254:
            case 1257:
                // have to validate
                // all of these
                hr = g_pMimeDatabase->ValidateCP(1250);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1251);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1253);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1254);
                if (SUCCEEDED(hr))
                    hr = g_pMimeDatabase->ValidateCP(1257);
                break;
            default:
                return E_INVALIDARG;
        }
    }
    return hr;
}

// assumes the corresponding fontfile name for now
HRESULT _AddFontForCP(UINT uiCP)
{
   TCHAR szFontsPath[MAX_PATH];
   LPTSTR szFontFile;
   HRESULT hr = S_OK;
   BOOL bAtLeastOneFontAdded = FALSE;
   
   switch(uiCP)
   {
        case 932: // JA
            szFontFile = s_szJaFont;
            break;
        case 949: // KOR
            szFontFile = s_szKorFont;
            break;
        case 950: // ZHT
            szFontFile = s_szZhtFont;
            break;
        case 936: // ZHC
            szFontFile = s_szZhcFont;
            break;
        case 874:
            szFontFile = s_szThaiFont;
            break; 
        case 1255:
            szFontFile = s_szIwFont;
            break; 
        case 1256:
            szFontFile = s_szArFont;
            break; 
        case 1258:
            szFontFile = s_szViFont;
            break; 
        case 1251:    // PANEURO
        case 1253:
        case 1254:
        case 1257:
            szFontFile = s_szPeFont;
            break;
        default:
            hr = E_INVALIDARG;
    } 
   
   // addfontresource, then broadcast WM_FONTCHANGE
   if (SUCCEEDED(hr))
   {      
       if (MLGetWindowsDirectory(szFontsPath, ARRAYSIZE(szFontsPath)))
       {
           TCHAR  szFontFilePath[MAX_PATH];
           LPTSTR psz, pszT;

           MLPathCombine(szFontsPath, szFontsPath, szFonts);

           for (psz = szFontFile; *psz; psz = pszT + 1)
           {
               pszT = MLStrChr(psz, TEXT(','));
               if (pszT)
               {
                   *pszT=TEXT('\0');
               }

               MLPathCombine(szFontFilePath, szFontsPath, psz);
               if (AddFontResource(szFontFilePath))
               {
                   bAtLeastOneFontAdded = TRUE;
               }

               if (!pszT)
                  break;
           }
           if (!bAtLeastOneFontAdded)
               hr = E_FAIL;
       }
       else
           hr = E_FAIL;
   }

   // Clients will take care of WM_FONTCHANGE notification
   return hr;
}

int _LoadStringExA(
    HMODULE    hModule,
    UINT      wID,
    LPSTR     lpBuffer,            
    int       cchBufferMax,        
    WORD      wLangId)
{
    int iRet = 0;

    LPWSTR lpwStr = (LPWSTR) LocalAlloc(LPTR, cchBufferMax*sizeof(WCHAR));

    if (lpwStr)
    {
        iRet = _LoadStringExW(hModule, wID, lpwStr, cchBufferMax, wLangId);

        if (iRet)
            iRet = WideCharToMultiByte(CP_ACP, 0, lpwStr, iRet, lpBuffer, cchBufferMax, NULL, NULL);

        if(iRet >= cchBufferMax)
            iRet = cchBufferMax-1;

        lpBuffer[iRet] = 0;

        LocalFree(lpwStr);
    }

    return iRet;
}

// Extend LoadString() to to _LoadStringExW() to take LangId parameter
int _LoadStringExW(
    HMODULE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return 0;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hModule, (LPCWSTR)RT_STRING,
                                   (LPWSTR)IntToPtr(((USHORT)wID >> 4) + 1), wLangId)) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hModule, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            wID &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            
                            
            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax-1;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;

        }
    }

    return cch;
}


typedef struct tagCPLGID
{
    UINT    uiCodepage;
    TCHAR   szLgId[3];
    TCHAR   szLgIdHex[3]; // Darn it! NT should be persistent on presenting language group numbers
                          // It uses decimal string in INF and hex string in registry. 
                          // We have to add this field to save conversion, this is fine for a small array of data.  
} CPLGID;

const CPLGID CpLgId[] =
{
    {1252,  TEXT("1"),  TEXT("1")},  // WESTERN EUROPE
    {1250,  TEXT("2"),  TEXT("2")},  // CENTRAL EUROPE
    {1257,  TEXT("3"),  TEXT("3")},  // BALTIC
    {1253,  TEXT("4"),  TEXT("4")},  // GREEK
    {1251,  TEXT("5"),  TEXT("5")},  // CYRILLIC
    {1254,  TEXT("6"),  TEXT("6")},  // TURKISH
    {932,   TEXT("7"),  TEXT("7")},  // JAPANESE
    {949,   TEXT("8"),  TEXT("8")},  // KOREAN
    {950,   TEXT("9"),  TEXT("9")},  // TRADITIONAL CHINESE
    {936,  TEXT("10"),  TEXT("a")},  // SIMPLIFIED CHINESE
    {874,  TEXT("11"),  TEXT("b")},  // THAI
    {1255, TEXT("12"),  TEXT("c")},  // HEBREW
    {1256, TEXT("13"),  TEXT("d")},  // ARABIC
    {1258, TEXT("14"),  TEXT("e")},  // VIETNAMESE
    // ISCII encodings don't really have code pages or family code page
    // Code pages number are made up in W2K for conveniences, 
    // So, we have to list them all to install the same Indian language group
    {57002,TEXT("15"),  TEXT("f")},  // INDIAN 
    {57003,TEXT("15"),  TEXT("f")},  // INDIAN
    {57004,TEXT("15"),  TEXT("f")},  // INDIAN
    {57005,TEXT("15"),  TEXT("f")},  // INDIAN
    {57006,TEXT("15"),  TEXT("f")},  // INDIAN
    {57007,TEXT("15"),  TEXT("f")},  // INDIAN
    {57008,TEXT("15"),  TEXT("f")},  // INDIAN
    {57009,TEXT("15"),  TEXT("f")},  // INDIAN
    {57010,TEXT("15"),  TEXT("f")},  // INDIAN
    {57011,TEXT("15"),  TEXT("f")},  // INDIAN
};

typedef BOOL (WINAPI *PFNISNTADMIN) ( DWORD dwReserved, DWORD *lpdwReserved );

typedef INT (WINAPI *PFNSETUPPROMPTREBOOT) (
        HSPFILEQ FileQueue,  // optional, handle to a file queue
        HWND Owner,          // parent window of this dialog box
        BOOL ScanOnly        // optional, do not prompt user
        );

typedef PSP_FILE_CALLBACK PFNSETUPDEFAULTQUEUECALLBACK;

typedef VOID (WINAPI *PFNSETUPCLOSEINFFILE) (
    HINF InfHandle
    );

typedef BOOL (WINAPI *PFNSETUPINSTALLFROMINFSECTION) (
    HWND                Owner,
    HINF                InfHandle,
    LPCTSTR             SectionName,
    UINT                Flags,
    HKEY                RelativeKeyRoot,   OPTIONAL
    LPCTSTR             SourceRootPath,    OPTIONAL
    UINT                CopyFlags,
    PSP_FILE_CALLBACK   MsgHandler,
    PVOID               Context,
    HDEVINFO            DeviceInfoSet,     OPTIONAL
    PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    );

typedef HINF (WINAPI *PFNSETUPOPENINFFILE) (
    LPCTSTR FileName,
    LPCTSTR InfClass,    OPTIONAL
    DWORD   InfStyle,
    PUINT   ErrorLine    OPTIONAL
    );

typedef PVOID (WINAPI *PFNSETUPINITDEFAULTQUEUECALLBACK) (
    IN HWND OwnerWindow
    );

typedef BOOL (WINAPI *PFNSETUPOPENAPPENDINFFILE) (
  PCTSTR FileName, // optional, name of the file to append
  HINF InfHandle,  // handle of the file to append to
  PUINT ErrorLine  // optional, receives error information
);
 


HRESULT IsNTLangpackAvailable(UINT uiCP)
{
    HRESULT hr = S_FALSE;

    // check if there is a valid W2K language group
    for (int i=0; i < ARRAYSIZE(CpLgId); i++)
    {
        if (uiCP == CpLgId[i].uiCodepage)
        {
            hr = S_OK;
            break;
        }
    }

    // check if it is already installed, if so, we don't install it again
    if (S_OK == hr)
    {
        HKEY hkey;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         REGSTR_PATH_NT5LPK_INSTALL,
                         0, KEY_READ, &hkey)) 
        {
            DWORD dwType = REG_SZ;
            TCHAR szLpkInstall[16] = {0};
            DWORD dwSize = sizeof(szLpkInstall);

            if (ERROR_SUCCESS == RegQueryValueEx(hkey, CpLgId[i].szLgIdHex, 0, 
                                                 &dwType, (LPBYTE)&szLpkInstall, &dwSize))
            {
                if (!lstrcmp(szLpkInstall, TEXT("1")))
                    hr = S_FALSE;
            }
            RegCloseKey(hkey);
        }
    }

    return hr;
}

HRESULT _InstallNT5Langpack(HWND hwnd, UINT uiCP)
{
    HRESULT             hr = E_FAIL;
    HINF                hIntlInf = NULL;
    TCHAR               szIntlInf[MAX_PATH];
    TCHAR               szIntlInfSection[MAX_PATH];
    PVOID               QueueContext = NULL;   

    HINSTANCE           hDllAdvPack = NULL;
    HINSTANCE           hDllSetupApi = NULL;

    PFNSETUPINSTALLFROMINFSECTION       lpfnSetupInstallFromInfSection = NULL;
    PFNSETUPCLOSEINFFILE                lpfnSetupCloseInfFile = NULL;
    PFNSETUPDEFAULTQUEUECALLBACK        lpfnSetupDefaultQueueCallback = NULL;
    PFNSETUPOPENINFFILE                 lpfnSetupOpenInfFile = NULL;
    PFNISNTADMIN                        lpfnIsNTAdmin = NULL;
    PFNSETUPINITDEFAULTQUEUECALLBACK    lpfnSetupInitDefaultQueueCallback = NULL;
    PFNSETUPOPENAPPENDINFFILE           lpfnSetupOpenAppendInfFile = NULL;

    for (int i=0; i < ARRAYSIZE(CpLgId); i++)
    {
        if (uiCP == CpLgId[i].uiCodepage)
        {
            _tcscpy(szIntlInfSection, TEXT("LG_INSTALL_"));
            _tcscat(szIntlInfSection, CpLgId[i].szLgId);
            break;
        }
    }

    if (i >= ARRAYSIZE(CpLgId))
    {
        goto LANGPACK_EXIT;
    }

    hDllAdvPack = LoadLibrary(TEXT("advpack.dll"));
    hDllSetupApi = LoadLibrary(TEXT("setupapi.dll"));

    if (!hDllAdvPack || !hDllSetupApi)
    {
        goto LANGPACK_EXIT;
    }

    lpfnIsNTAdmin = (PFNISNTADMIN) GetProcAddress( hDllAdvPack, "IsNTAdmin");
    lpfnSetupCloseInfFile = (PFNSETUPCLOSEINFFILE) GetProcAddress( hDllSetupApi, "SetupCloseInfFile");
    lpfnSetupInitDefaultQueueCallback = (PFNSETUPINITDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupInitDefaultQueueCallback");
#ifdef UNICODE
    lpfnSetupOpenInfFile = (PFNSETUPOPENINFFILE) GetProcAddress( hDllSetupApi, "SetupOpenInfFileW"));
    lpfnSetupInstallFromInfSection = (PFNSETUPINSTALLFROMINFSECTION) GetProcAddress( hDllSetupApi, "SetupInstallFromInfSectionW");
    lpfnSetupDefaultQueueCallback = (PFNSETUPDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupDefaultQueueCallbackW");
    lpfnSetupOpenAppendInfFile = (PFNSETUPDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupOpenAppendInfFileW");
#else
    lpfnSetupOpenInfFile = (PFNSETUPOPENINFFILE) GetProcAddress( hDllSetupApi, "SetupOpenInfFileA");
    lpfnSetupInstallFromInfSection = (PFNSETUPINSTALLFROMINFSECTION) GetProcAddress( hDllSetupApi, "SetupInstallFromInfSectionA");
    lpfnSetupDefaultQueueCallback = (PFNSETUPDEFAULTQUEUECALLBACK) GetProcAddress(hDllSetupApi, "SetupDefaultQueueCallbackA");
    lpfnSetupOpenAppendInfFile = (PFNSETUPOPENAPPENDINFFILE) GetProcAddress(hDllSetupApi, "SetupOpenAppendInfFileA");
#endif

    if (!lpfnIsNTAdmin || !lpfnSetupOpenInfFile || !lpfnSetupCloseInfFile || !lpfnSetupDefaultQueueCallback 
        || !lpfnSetupInstallFromInfSection || !lpfnSetupInitDefaultQueueCallback || !lpfnSetupOpenAppendInfFile)
    {
        goto LANGPACK_EXIT;
    }

    if (!lpfnIsNTAdmin(0, NULL))
    {
        WCHAR wszLangInstall[MAX_PATH];
        WCHAR wszNoAdmin[1024];
        LANGID LangId = GetNT5UILanguage();

        // Fall back to English (US) if we don't have a specific language resource
        if (!_LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId) ||
            !_LoadStringExW(g_hInst, IDS_NO_ADMIN, wszNoAdmin, ARRAYSIZE(wszNoAdmin), LangId))
        {
            LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            _LoadStringExW(g_hInst, IDS_LANGPACK_INSTALL, wszLangInstall, ARRAYSIZE(wszLangInstall), LangId);
            _LoadStringExW(g_hInst, IDS_NO_ADMIN, wszNoAdmin, ARRAYSIZE(wszNoAdmin), LangId);
        }
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        MessageBoxW(hwnd, wszNoAdmin, wszLangInstall, MB_OK);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        goto LANGPACK_EXIT;
    }

    QueueContext = lpfnSetupInitDefaultQueueCallback(hwnd);

    MLGetWindowsDirectory(szIntlInf, MAX_PATH);
    MLPathCombine(szIntlInf, szIntlInf, TEXT("inf\\intl.inf"));

    hIntlInf = lpfnSetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);

    if (!lpfnSetupOpenAppendInfFile(NULL, hIntlInf, NULL))
    {
        lpfnSetupCloseInfFile(hIntlInf);
        goto LANGPACK_EXIT;
    }

    if (INVALID_HANDLE_VALUE != hIntlInf)
    {
        if (lpfnSetupInstallFromInfSection( hwnd,
                                    hIntlInf,
                                    szIntlInfSection,
                                    SPINST_FILES,
                                    NULL,
                                    NULL,
                                    SP_COPY_NEWER,
                                    lpfnSetupDefaultQueueCallback,
                                    QueueContext,
                                    NULL,
                                    NULL ))
        {
            if (lpfnSetupInstallFromInfSection( hwnd,
                                    hIntlInf,
                                    szIntlInfSection,
                                    SPINST_ALL & ~SPINST_FILES,
                                    NULL,
                                    NULL,
                                    0,
                                    lpfnSetupDefaultQueueCallback,
                                    QueueContext,
                                    NULL,
                                    NULL ))
            {
                hr = S_OK;
            }
        }
    
        lpfnSetupCloseInfFile(hIntlInf);
    }

LANGPACK_EXIT:

    if(hDllSetupApi)
        FreeLibrary(hDllSetupApi);
    if(hDllAdvPack)
        FreeLibrary(hDllAdvPack);
    
    //
    // Bug #289905, On Whistler, language pack will be installed with a groups of languages,
    // So, MLang need to validate codepage and fonts for all languages in the same group
    // After intl.cpl is modified for font validation, we'll remove this hardcoded language group.
    //
    if (hr == S_OK)
    {
        // This has to match Whistler language group
        UINT uiDBCSCps[] = {932, 936, 949, 950, 0};
        UINT uiCompCps[] = {874, 1255, 1256, 1258, 0};
        UINT uiOtherCps[] = {uiCP, 0};
            
        UINT *pCps = uiOtherCps;
        
        if (MLIsOS(OS_WHISTLERORGREATER))
        {
            if (IS_DBCSCODEPAGE(uiCP))
                pCps = uiDBCSCps;
            else if (IS_COMPLEXSCRIPT_CODEPAGE(uiCP))
                pCps = uiCompCps;
        }               
            
        while (*pCps)
        {
            hr = _ValidateCPInfo(*pCps);
            if (SUCCEEDED(hr))
            {                
                _AddFontForCP(*pCps);
            }
            pCps++;
        }
    }    

    return hr;
}

BOOL _IsValidCodePage(UINT uiCodePage)
{
    BOOL bRet;

    if (50001 == uiCodePage)
    {
        HANDLE hFile = NULL;
        CHAR szFileName[MAX_PATH];
        LPSTR psz;
        
        if (GetModuleFileNameA(g_hInst, szFileName, ARRAYSIZE(szFileName)) == 0)
            return GetLastError();
        
        if ( (psz = strrchr (szFileName, '\\')) != NULL ||
            (psz = strrchr (szFileName, ':')) != NULL )
        {
            *++psz = 0;
        }
        else
            *szFileName = 0;
        
        strcat (szFileName, DETECTION_DATA_FILENAME);        

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileA(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
        {
            bRet = FALSE;
        }
        else
        {
            bRet = TRUE;
            CloseHandle(hFile);
        }
    }
    else
    {
        bRet = IsValidCodePage(uiCodePage);
    }
    return bRet;
}

WCHAR *MLStrCpyNW(WCHAR *strDest, const WCHAR *strSource, int nCount)
{
    return wcsncpy(strDest, strSource, nCount);
}

WCHAR *MLStrCpyW(WCHAR *strDest, const WCHAR *strSource)
{
    return wcscpy(strDest, strSource);
}

LPTSTR MLStrChr( const TCHAR *string, int c )
{
    return _tcschr(string, c);
}

LPTSTR MLStrCpyN(LPTSTR strDest, const LPTSTR strSource, UINT nCount)
{
    return _tcsncpy(strDest, strSource, nCount);
}

LPTSTR MLStrStr(const LPTSTR Str, const LPTSTR subStr)
{
    return _tcsstr(Str, subStr);
}

LPTSTR MLPathCombine(LPTSTR szPath, LPTSTR szPath1, LPTSTR szPath2)
{
    int len;

    if (!szPath) 
        return NULL;

    if (szPath != szPath1)
    {
        _tcscpy(szPath, szPath1);
    }

    len = _tcslen(szPath1);

    if (szPath[len-1] != TEXT('\\'))
    {
        szPath[len++] = TEXT('\\');
        szPath[len] = 0;
    }

    return _tcscat(szPath, szPath2);
}

DWORD HexToNum(LPTSTR lpsz)
{
    DWORD   dw = 0L;
    TCHAR   c;

    while(*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return(dw);
}


// Following code is borrowed from shlwapi
BOOL AnsiFromUnicode(
     LPSTR * ppszAnsi,
     LPCWSTR pwszWide,        // NULL to clean up
     LPSTR pszBuf,
     int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
    {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
        }
        else
        {
            // No; use the provided buffer
            ASSERT(pszBuf);
            psz = pszBuf;
        }

        if (psz)
        {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppszAnsi = psz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}

int MLStrCmpI(IN LPCTSTR pwsz1, IN LPCTSTR pwsz2)
{
#ifdef UNICODE
    return MLStrCmpIW(pwsz1, pwsz2);
#else
    return lstrcmpiA(pwsz1, pwsz2);
#endif
}

int MLStrCmpNI(IN LPCTSTR pstr1, IN LPCTSTR pstr2, IN int count)
{
#ifdef UNICODE
    return MLStrCmpNIW(pstr1, pstr2, count);
#else
    return MLStrCmpNIA(pstr1, pstr2, count);
#endif
}

int MLStrCmpIW(
    IN LPCWSTR pwsz1,
    IN LPCWSTR pwsz2)
{
    int iRet;
    
    ASSERT(IS_VALID_STRING_PTRW(pwsz1, -1));
    ASSERT(IS_VALID_STRING_PTRW(pwsz2, -1));
    
    if (g_bIsNT)
    {        
        iRet = CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, pwsz1, -1, pwsz2, -1) - CSTR_EQUAL;
    }
    else
    {
        CHAR sz1[512];
        CHAR sz2[512];
        LPSTR psz1;
        LPSTR psz2;

        iRet = -1;      // arbitrary on failure

        if (pwsz1 && pwsz2)
        {
            if (AnsiFromUnicode(&psz1, pwsz1, sz1, SIZECHARS(sz1)))
            {
                if (AnsiFromUnicode(&psz2, pwsz2, sz2, SIZECHARS(sz2)))
                {
                    iRet = CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, psz1, -1, psz2, -1) - CSTR_EQUAL;
                    AnsiFromUnicode(&psz2, NULL, sz2, 0);       // Free
                }
                AnsiFromUnicode(&psz1, NULL, sz1, 0);       // Free
            }
        }
    }

    return iRet;
}

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

int WINAPI MLStrToIntA(
    LPCSTR lpSrc)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == '-') {
        bNeg = TRUE;
        lpSrc++;
    }

    while (IS_DIGITA(*lpSrc)) {
        n *= 10;
        n += *lpSrc - '0';
        lpSrc++;
    }
    return bNeg ? -n : n;
}


int WINAPI MLStrToIntW(
    LPCWSTR lpSrc)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == L'-') {
        bNeg = TRUE;
        lpSrc++;
    }

    while (IS_DIGITW(*lpSrc)) {
        n *= 10;
        n += *lpSrc - L'0';
        lpSrc++;
    }
    return bNeg ? -n : n;
}

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

#if defined(MWBIG_ENDIAN)
    sz2[0] = LOBYTE(wMatch);
    sz2[1] = HIBYTE(wMatch);
#else
    *(WORD *)sz2 = wMatch;
#endif
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return lstrcmpiW(sz1, sz2);
}


/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int MLStrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? READNATIVEWORD(lpStr1) : 0;
        w2 = (UINT)(IsDBCSLeadByte(*lpStr2)) ? (UINT)READNATIVEWORD(lpStr2) : (WORD)(BYTE)(*lpStr2);

        i = ChrCmpIA(w1, w2);
        if (i)
            return i;
    }
    return 0;
}

int MLStrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpIW(*lpStr1, *lpStr2);
        if (i) {
            return i;
        }
    }
    return 0;
}


HRESULT _IsCodePageInstallable(UINT uiCodePage)
{
    MIMECPINFO cpInfo;
    UINT       uiFamCp;
    HRESULT    hr;

    if (NULL != g_pMimeDatabase)
        hr = g_pMimeDatabase->GetCodePageInfo(uiCodePage, 0x409, &cpInfo);
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        return E_INVALIDARG;

    uiFamCp = cpInfo.uiFamilyCodePage;
    if (g_bIsNT5)
    {
        hr = IsNTLangpackAvailable(uiFamCp);
    }
    else
    {
        CLSID      clsid;
        // clsid is just used for place holder
        hr = _GetJITClsIDForCodePage(uiFamCp, &clsid);
    }
    return hr;
}

//
// CML2 specific utilities
//

//
// CMultiLanguage2::EnsureIEStatus()
//
// ensures CML2::m_pIEStat
//
HRESULT CMultiLanguage2::EnsureIEStatus(void)
{
    HRESULT hr = S_OK;
    // initialize IE status cache
    if (!m_pIEStat)
    {
        m_pIEStat = new CIEStatus();

        if (m_pIEStat)
        {
            hr = m_pIEStat->Init();
        }
    }

    return hr;
}

//
// CIEStatus::Init()
//
// initializes the IE status;
//
HRESULT CMultiLanguage2::CIEStatus::Init(void)
{
    HRESULT hr = S_OK;
    HKEY hkey;
    // Get JIT satus
    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                      REGSTR_PATH_MAIN,
                     0, KEY_READ, &hkey) == ERROR_SUCCESS) 
    {
        DWORD dwVal, dwType;
        DWORD dwSize = sizeof(dwVal);
        RegQueryValueEx(hkey, TEXT("nojitsetup"), 0, &dwType, (LPBYTE)&dwVal, &dwSize);
        RegCloseKey(hkey);

        if (dwType == REG_DWORD && dwSize == sizeof(dwVal))
        {
            if (dwVal > 0 ) 
                _IEFlags.fJITDisabled = TRUE;
            else
                _IEFlags.fJITDisabled = FALSE;
        }
    }
    else
        hr = E_FAIL;
    // any other status to get initialized
    // ...
    
    return hr;
}

#define NT5LPK_DLG_STRING "MLang.NT5LpkDlg"

//
// LangpackDlgProc()
//
// Message handler for the NT5 langpack dialog.
//
INT_PTR CALLBACK LangpackDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    ASSERT(g_bIsNT5);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            HWND hwndCheckBox;            
            RECT rc1, rc2;
            MIMECPINFO cpInfo;

            SetProp(hDlg, NT5LPK_DLG_STRING, (HANDLE)lParam);
    
            if ((NULL != g_pMimeDatabase) &&
                SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(HIWORD(lParam), GetNT5UILanguage(), &cpInfo)))
            {
                for (int i=0; i<MAX_MIMECP_NAME && cpInfo.wszDescription[i]; i++)
                {
                    if (cpInfo.wszDescription[i] == L'(')
                    {
                        cpInfo.wszDescription[i] = 0;
                        break;
                    }
                }
                // Use W version regardlessly since we're only running this on NT5             
                SetDlgItemTextW(hDlg, IDC_STATIC_LANG, cpInfo.wszDescription);
            }
            
            // Center the dialog in the area of parent window
            if (GetWindowRect(GetParent(hDlg), &rc1) && GetWindowRect(hDlg, &rc2))
            {
                MoveWindow(hDlg, (rc1.right+rc2.left+rc1.left-rc2.right)/2, (rc1.bottom+rc2.top+rc1.top-rc2.bottom)/2, rc2.right-rc2.left, rc2.bottom-rc2.top, FALSE);
            }            

            hwndCheckBox = GetDlgItem(hDlg, IDC_CHECK_LPK);

            // Set CheckBox state according to current registry setting
            PostMessage(hwndCheckBox, BM_SETCHECK, LOWORD(lParam)? BST_UNCHECKED:BST_CHECKED, 0);
            break;

        case WM_COMMAND:
            if (LOWORD(wParam) != IDC_CHECK_LPK)
            {
                HKEY hkey;
                DWORD dwInstallOut = (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_CHECK_LPK), BM_GETCHECK, 0, 0)? 0:1);
                DWORD dwInstallIn = LOWORD(GetProp(hDlg, NT5LPK_DLG_STRING));
                
                if ((dwInstallOut != dwInstallIn) &&
                    ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, 
                         REGSTR_PATH_INTERNATIONAL,
                         NULL, KEY_READ|KEY_SET_VALUE, &hkey)) 
                {
                    DWORD dwType = REG_DWORD;
                    DWORD dwSize = sizeof(DWORD);
                    RegSetValueEx(hkey, REG_KEY_NT5LPK, 0, REG_DWORD, (LPBYTE)&dwInstallOut, sizeof(dwInstallOut));
                    RegCloseKey(hkey);
                }                
                EndDialog(hDlg, LOWORD(wParam) == IDOK? 1: 0);
            }
            break;

        case WM_HELP:
            // Do we need help file for this simply dialog?
            // If needed, we can always add it at later time.
            break;


        default:
            return FALSE;
    }
    return TRUE;
}

// To get real Windows directory on Terminal Server, 
// Instead of using internal Kernel32 API GetSystemWindowsDirectory with LoadLibrary/GetProcAddress,
// We cast GetSystemDirectory return to Windows directory
UINT MLGetWindowsDirectory(
    LPTSTR lpBuffer,    // address of buffer for Windows directory
    UINT uSize          // size of directory buffer
    )
{
    UINT uLen;

    if (g_bIsNT)
    {        
        if (uLen = GetSystemDirectory(lpBuffer, uSize))
        {        
            if (lpBuffer[uLen-1] == TEXT('\\'))
                uLen--;

            while (uLen-- > 0)
            {
                if (lpBuffer[uLen] == TEXT('\\'))
                {
                    lpBuffer[uLen] = NULL;                
                    break;
                }
            }
        }
    }
    else    
        uLen = GetWindowsDirectory(lpBuffer, uSize);

    return uLen;
}

// To speed up basic ANSI string compare,
// We avoid using lstrcmpi in LOW-ASCII case
int LowAsciiStrCmpNIA(LPCSTR  lpstr1, LPCSTR lpstr2, int count)
{
    int delta;

    while (count-- > 0)
    {        
        delta = *lpstr1 - *lpstr2;
        if (delta && 
            !(IS_CHARA(*lpstr1) && IS_CHARA(*lpstr2) && (delta == 0x20 || delta == -0x20)))
            return delta;
        lpstr1++;
        lpstr2++;
    }

    return 0;
}

//
//  GetNT5UILanguage(void)
//
LANGID GetNT5UILanguage(void)
{
    if (g_bIsNT5)
    {
        static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

        if (pfnGetUserDefaultUILanguage == NULL)
        {
            HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

            if (hmod)
                pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
        }
        if (pfnGetUserDefaultUILanguage)
            return pfnGetUserDefaultUILanguage();
    }

    return 0;
}

// Special characters that we should filter out
WCHAR wszBestFit[] = {0x00A6, 0x00A9, 0x00AB, 0x00AD, 0x00AE, 0x00B7, 0x00BB, 0x02C6, 0x02DC, 0x2013, 
                      0x2014, 0x2018, 0x2019, 0x201A, 0x201C,0x201D, 0x201E, 0x2022, 0x2026, 0x2039, 0x203A,0x2122, 0x0000};

DWORD OutBoundDetectPreScan(LPWSTR lpWideCharStr, UINT cchWideChar, WCHAR *pwszCopy, WCHAR *lpBestFitChar)
{
    DWORD dwRet = 0;
    WCHAR *lpStart;

    if (!lpBestFitChar)
        lpBestFitChar = wszBestFit;

    lpStart = lpBestFitChar;

    if (pwszCopy)
    {
        MLStrCpyNW(pwszCopy, lpWideCharStr, cchWideChar);
        lpWideCharStr = pwszCopy;
    }     

    if (lpWideCharStr)
    {
        for (UINT ui=0; ui<cchWideChar; ui++)
        {
            if (IS_CJK_CHAR(*lpWideCharStr))
                dwRet |= FS_CJK;
            else if (IS_HINDI_CHAR(*lpWideCharStr))
                dwRet |= FS_HINDI;     
            else if (IS_PUA_CHAR(*lpWideCharStr))
                dwRet |= FS_PUA;
            else if (pwszCopy)
            {
                while (*lpBestFitChar)
                {
                    if (*lpWideCharStr == *lpBestFitChar)
                        *lpWideCharStr = 0x20;
                    lpBestFitChar++;
                }
                lpBestFitChar = lpStart;
            }
            lpWideCharStr++;
        }
    }
    
    return dwRet;
}

//
// Whistler bug #90433 WEIWU 07/06/00
//
// Outlook has a bug its RTFHTML, this component doesn't CoInitialize/
// CoUninitialize COM, but, it uses MLang COM services, it depends on 
// other threads (components) to deal with COM, when COM is unloaded by those threads. 
// Invoking the interface pointer causes AV. RTFHTML should CoInit/CoUnInit by 
// itself.
//
// The reason for this to be working before is - MLang was depending on ATL 
// for objects management, ATL create heap for MLang object allocations, MLang 
// notifies ATL to destroy the heap at DLL detach time and RTFHTML's IsBadReadPtr
// () caught the invalid pointer. Now in Whistler, MLang includes crtfree.h 
// which overwrites ATL memory management functions (same as other shell 
// components), so, nothing is allocated from the process heap, this is fine for 
// MLang since it assumes that clients use COM correctly. 
//
// Now, we add this function to check Outlook version, if it is the buggy Outlook,
// We'll load mlang.dll itself DllGetClassObject() to increase the Dll ref count
//
BOOL NeedToLoadMLangForOutlook(void)
{
    TCHAR szModulePath[MAX_PATH];
    CHAR chBuffer[4096];
    DWORD dwHandle;
    VS_FIXEDFILEINFO * pszVersion;
    static BOOL bMLangLoaded = FALSE;

    if (!bMLangLoaded)
    {
        if (GetModuleFileName(GetModuleHandle(NULL), szModulePath, ARRAYSIZE(szModulePath)))
        {
            if (MLStrStr(szModulePath, TEXT("OUTLOOK.EXE")))
            {
                UINT cb = GetFileVersionInfoSize(szModulePath, &dwHandle);

                if (cb <= sizeof(chBuffer) &&
                    GetFileVersionInfo(szModulePath, dwHandle, sizeof(chBuffer), (void *)chBuffer) &&
                    VerQueryValue((void *)chBuffer, TEXT("\\"), (void **) &pszVersion, &cb) &&
                    (HIWORD(pszVersion->dwProductVersionMS) <= 0x09))
                {
                    bMLangLoaded = TRUE;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

//
// staticIsOS() doesn't support newer Whistler OS flags.
// Borrow code from shlwapi - IsOS()
//
BOOL MLIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOEXA s_osvi = {0};
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;
        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if (!GetVersionExA((OSVERSIONINFOA*)&s_osvi))
        {
            // If it failed, it must be a down level platform
            s_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA((OSVERSIONINFOA*)&s_osvi);
        }
    }

    switch (dwOS)
    {
    case OS_TERMINALREMOTEADMIN:
        // this checks to see if TS has been installed in the "Remote Administration" mode. This is
        // the default for server installs on win2k and whistler
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                (VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
        break;

    case 4: // used to be OS_NT5, is the same as OS_WIN2000ORGREATER so use that instead
    case OS_WIN2000ORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    // NOTE: The flags in this section are bogus and SHOULD NOT BE USED (but downlevel shell32 uses them, so don't RIP there)
    case OS_WIN2000PRO:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_PROFESSIONAL instead of OS_WIN2000PRO !");
        bRet = (VER_NT_WORKSTATION == s_osvi.wProductType &&
                s_osvi.dwMajorVersion == 5);
        break;
    case OS_WIN2000ADVSERVER:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_ADVSERVER instead of OS_WIN2000ADVSERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000DATACENTER:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_DATACENTER instead of OS_WIN2000DATACENTER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000SERVER:
        RIPMSG(!MLIsOS(OS_WHISTLERORGREATER), "IsOS: use OS_SERVER instead of OS_WIN2000SERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask)  && 
                s_osvi.dwMajorVersion == 5);
        break;
    // END bogus Flags

    case OS_EMBEDDED:
        bRet = (VER_SUITE_EMBEDDEDNT & s_osvi.wSuiteMask);
        break;

    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;


    case OS_WIN98ORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_WIN98_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;


    case OS_MILLENNIUMORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 90) ||
                s_osvi.dwMajorVersion > 4));
        break;


    case OS_WHISTLERORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion > 5) ||
                (s_osvi.dwMajorVersion == 5 && (s_osvi.dwMinorVersion > 0 ||
                (s_osvi.dwMinorVersion == 0 && LOWORD(s_osvi.dwBuildNumber) > 2195)))));
        break;

    case OS_PERSONAL:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (VER_SUITE_PERSONAL & s_osvi.wSuiteMask));
        break;


    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\utf8obj.h ===
#include "convbase.h"

#define HIGHT_SURROGATE_START   0xD800
#define HIGHT_SURROGATE_END     0xDBFF
#define LOW_SURROGATE_START     0xDC00
#define LOW_SURROGATE_END       0xDFFF

class CInccUTF8In : public CINetCodeConverter
{
private:
	BOOL (CInccUTF8In::*m_pfnConv)(UCHAR tc);
	BOOL (CInccUTF8In::*m_pfnCleanUp)();

	WORD    m_tcUnicode ;
	DWORD   m_tcSurrogateUnicode ;
	int     m_nByteFollow;
	int     m_nBytesUsed;
    BOOL    m_fSurrogatesPairs;
public:
	CInccUTF8In(UINT uCodePage, int nCodeSet);
	~CInccUTF8In() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);

private:
    void Reset(); 
	BOOL ConvMain(UCHAR tc);
	BOOL CleanUpMain();

};

class CInccUTF8Out : public CINetCodeConverter
{
private:
	BOOL    m_fDoubleByte;
	BYTE    m_tcLeadByte;
    WCHAR   m_wchSurrogateHigh;

public:
	CInccUTF8Out(UINT uCodePage, int nCodeSet);
	~CInccUTF8Out() {}
	virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
	virtual BOOL CleanUp();
	virtual int GetUnconvertBytes();
	virtual DWORD GetConvertMode();
	virtual void SetConvertMode(DWORD mode);
private:
    void Reset(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\util.h ===
// Util.h : Helper functions and classes

#ifndef __UTIL_H_
#define __UTIL_H_

#include "mlatl.h"

extern class CMLAlloc* g_pMalloc;

/////////////////////////////////////////////////////////////////////////////
// CMLAlloc
class CMLAlloc
{
public:
    CMLAlloc(void);
    ~CMLAlloc(void);
    void* Alloc(ULONG cb);
    void* Realloc(void* pv, ULONG cb);
    void Free(void* pv);

private:
    IMalloc* m_pIMalloc;
};

/////////////////////////////////////////////////////////////////////////////
// CMLList
class CMLList
{
public:
    inline CMLList(int cbCell, int cbIncrement);
    inline ~CMLList(void);

    HRESULT Add(void** ppv);
    HRESULT Remove(void* pv);

    struct CCell
    {
        CCell* m_pNext;
    };

protected:
    inline void AssertPV(void*pv) const;

    inline void* MemAlloc(ULONG cb) {return ::g_pMalloc->Alloc(cb);}
    inline void* MemRealloc(void* pv, ULONG cb) {return ::g_pMalloc->Realloc(pv, cb);}
    inline void MemFree(void* pv) {::g_pMalloc->Free(pv);}

private:
    const int m_cbCell; // The size, in bytes, of a cell
    const int m_cbIncrement; // The size, in bytes, to increase the buffer at a time
    CCell* m_pBuf; // Pointer to the buffer
    int m_cCell; // The number of cells allocated
    CCell* m_pFree; // Pointer to a cell the top of free link
};

CMLList::CMLList(int cbCell, int cbIncrement) :
    m_cbCell(cbCell),
    m_cbIncrement(cbIncrement),
    m_pBuf(NULL),
    m_cCell(0),
    m_pFree(NULL)
{
    ASSERT(cbCell >= sizeof(CCell));
    ASSERT(cbIncrement >= cbCell);
}

CMLList::~CMLList(void)
{
    if (m_pBuf)
    {
#ifdef DEBUG
        int cCell = 0;
        for (CCell* pCell = m_pFree; pCell; pCell = pCell->m_pNext)
        {
            if (++cCell > m_cCell)
            {
                ASSERT(FALSE); // Free link is broken
                break;
            }
        }
        ASSERT(cCell < m_cCell); // Memory leak!?
#endif
        MemFree(m_pBuf);
    }
}

void CMLList::AssertPV(void*pv) const
{
    ASSERT(pv >= m_pBuf);
    ASSERT(pv < m_pBuf + m_cbCell * m_cCell);
    ASSERT(((CCell*)pv - m_pBuf) % m_cbCell == 0);
}

/////////////////////////////////////////////////////////////////////////////
// CMLListLru
class CMLListLru : public CMLList
{
public:
    inline CMLListLru(int cbCell, int cbIncrement);
    inline ~CMLListLru(void);

    HRESULT Add(void** ppv);
    HRESULT Remove(void* pv);
    inline HRESULT Top(void** ppv) const;
    inline HRESULT Next(void* pv, void** ppv) const;

    typedef CMLList::CCell CCell;

private:
    CCell* m_pTop;
};

CMLListLru::CMLListLru(int cbCell, int cbIncrement) :
    CMLList(cbCell, cbIncrement),
    m_pTop(NULL)
{
}

CMLListLru::~CMLListLru(void)
{
#ifdef DEBUG
    ASSERT(!m_pTop); // Memory Leak?
    while (m_pTop)
        Remove(m_pTop);
#endif
}

HRESULT CMLListLru::Top(void** ppv) const
{
    *ppv = (void*)m_pTop;
    return S_OK;
}

HRESULT CMLListLru::Next(void* pv, void** ppv) const
{
    AssertPV(pv);

    const CCell* const pCell = (const CCell* const)pv;

    if (pCell->m_pNext)
        AssertPV(pCell->m_pNext);

    *ppv = (void*)pCell->m_pNext;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMLListFast - double linked list
class CMLListFast : public CMLList
{
public:
    inline CMLListFast(int cbCell, int cbIncrement);
    inline ~CMLListFast(void);

    HRESULT Add(void** ppv);
    HRESULT Remove(void* pv);
    inline HRESULT Top(void** ppv) const;
    inline HRESULT Bottom(void** ppv) const;
    inline HRESULT Next(void* pv, void** ppv) const;
    inline HRESULT Prev(void* pv, void** ppv) const;

    struct CCell : public CMLList::CCell
    {
        CCell* m_pPrev;
    };

private:
    CCell* m_pTop;
};

CMLListFast::CMLListFast(int cbCell, int cbIncrement) :
    CMLList(cbCell, cbIncrement),
    m_pTop(NULL)
{
    ASSERT(cbCell >= sizeof(CCell));
}

CMLListFast::~CMLListFast(void)
{
#ifdef DEBUG
    ASSERT(!m_pTop); // Memory Leak?
    while (m_pTop)
        Remove(m_pTop);
#endif
}

HRESULT CMLListFast::Top(void** ppv) const
{
    *ppv = (void*)m_pTop;
    return S_OK;
}

HRESULT CMLListFast::Bottom(void** ppv) const
{
    if (m_pTop)
    {
        return Prev(m_pTop, ppv);
    }
    else
    {
        *ppv = NULL;
        return S_OK;
    }
}

HRESULT CMLListFast::Next(void* pv, void** ppv) const
{
    AssertPV(pv);

    const CCell* const pCell = (const CCell* const)pv;

    if (pCell->m_pNext)
        AssertPV(pCell->m_pNext);

    *ppv = (void*)pCell->m_pNext;
    return S_OK;
}

HRESULT CMLListFast::Prev(void* pv, void** ppv) const
{
    AssertPV(pv);

    const CCell* const pCell = (const CCell* const)pv;

    if (pCell->m_pPrev)
        AssertPV(pCell->m_pPrev);

    *ppv = (void*)pCell->m_pPrev;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CFireConnection
template <class T, const IID* piid>
class CFireConnection
{
public:
    inline CFireConnection(HRESULT& rhr);
    inline CFireConnection(HRESULT& rhr, IUnknown* const pUnk);
    inline ~CFireConnection(void);
    inline BOOL Next(void);
    inline T* Sink(void);

protected:
    HRESULT* const m_phr;
    IEnumConnections* m_pEnumConn;
    CONNECTDATA m_cd;
    T* m_pSink;
};

template <class T, const IID* piid>
CFireConnection<T, piid>::CFireConnection(HRESULT& rhr) :
    m_phr(&rhr),
    m_pEnumConn(NULL),
    m_pSink(NULL)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(piid);
    ASSERT_WRITE_PTR(m_phr);

    *m_phr = S_OK;
}

template <class T, const IID* piid>
CFireConnection<T, piid>::CFireConnection(HRESULT& rhr, IUnknown* const pUnk) :
    m_phr(&rhr),
    m_pEnumConn(NULL),
    m_pSink(NULL)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(piid);
    ASSERT_WRITE_PTR(m_phr);
    ASSERT_READ_PTR(pUnk);

    IConnectionPointContainer* pcpc;

    if (SUCCEEDED(*m_phr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void**)&pcpc)))
    {
        ASSERT_READ_PTR(pcpc);

        IConnectionPoint* pcp;

        if (SUCCEEDED(*m_phr = pcpc->FindConnectionPoint(*piid, &pcp)))
        {
            ASSERT_READ_PTR(pcp);

            if (SUCCEEDED(*m_phr = pcp->EnumConnections(&m_pEnumConn)))
            {
                ASSERT_READ_PTR(m_pEnumConn);
            }
            else
            {
                m_pEnumConn = NULL;
            }

            pcp->Release();
        }

        pcpc->Release();
    }
}

template <class T, const IID* piid>
CFireConnection<T, piid>::~CFireConnection(void)
{
    if (m_pSink)
        m_pSink->Release();
    if (m_pEnumConn)
        m_pEnumConn->Release();
}

template <class T, const IID* piid>
BOOL CFireConnection<T, piid>::Next(void)
{
    if (SUCCEEDED(*m_phr))
        ASSERT_READ_PTR(m_pEnumConn);

    if (SUCCEEDED(*m_phr) &&
        (*m_phr = m_pEnumConn->Next(1, &m_cd, NULL)) == S_OK)
    {
        if (m_pSink)
        {
            m_pSink->Release();
            m_pSink = NULL;
        }

        if (SUCCEEDED(*m_phr = m_cd.pUnk->QueryInterface(*piid, (void**)&m_pSink)))
            ASSERT_READ_PTR(m_pSink);
    }

    return SUCCEEDED(*m_phr);
}

template <class T, const IID* piid>
T* CFireConnection<T, piid>::Sink(void)
{
    return m_pSink;
}

#endif //__UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\utf8obj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from UTF-8
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "utf8obj.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF8In::CInccUTF8In(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF8In::Reset()
{
	m_pfnConv = ConvMain;
	m_pfnCleanUp = CleanUpMain;
	m_nByteFollow = 0 ;
	m_tcUnicode = 0 ;
	m_tcSurrogateUnicode = 0 ;
	m_nBytesUsed = 0 ;
	m_fSurrogatesPairs = FALSE;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccUTF8In::ConvertChar(UCHAR tc, int cchSrc)
{
	BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF8In::CleanUp()
{
	return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccUTF8In::ConvMain(UCHAR tc)
{
	BOOL fDone = TRUE;

    if( ( 0x80 & tc ) == 0 )                    // BIT7 == 0 ASCII
    {
        Output(tc);
        fDone = Output(0);
        m_nBytesUsed = 0 ; 
    }
    else if( (0x40 & tc) == 0 )                 // BIT6 == 0 a trail byte
    {
        if( m_nByteFollow )                
        {
            if (m_fSurrogatesPairs)
            {
                m_nByteFollow--;
                m_tcSurrogateUnicode <<= 6;             // Make room for trail byte
                m_tcSurrogateUnicode |= ( 0x3F & tc );  // LOWER_6BIT add trail byte value

                if( m_nByteFollow == 0)                 // End of sequence, advance output ptr
                {
                    m_tcUnicode = (WCHAR)(((m_tcSurrogateUnicode - 0x10000) >> 10) + HIGHT_SURROGATE_START);
                    tc = (UCHAR)m_tcUnicode ;
                    if ( fDone = Output(tc) )
                    {
                        tc = (UCHAR) ( m_tcUnicode >> 8 ) ; 
                        fDone = Output(tc);
                    }
                    m_tcUnicode = (WCHAR)((m_tcSurrogateUnicode - 0x10000)%0x400 + LOW_SURROGATE_START);
                    tc = (UCHAR)m_tcUnicode ;
                    if ( fDone = Output(tc) )
                    {
                        tc = (UCHAR) ( m_tcUnicode >> 8 ) ; 
                        fDone = Output(tc);
                    }
                    m_fSurrogatesPairs = 0;
                    m_nBytesUsed = 0 ; 
                }	
                else
                    m_nBytesUsed++ ; 
            }
            else
            {
                m_nByteFollow--;
                m_tcUnicode <<= 6;                  // make room for trail byte
                m_tcUnicode |= ( 0x3F & tc );       // LOWER_6BIT add trail byte value

                if( m_nByteFollow == 0)             // end of sequence, advance output ptr
                {
                    tc = (UCHAR)m_tcUnicode ;
                    if ( fDone = Output(tc) )
                    {
                        tc = (UCHAR) ( m_tcUnicode >> 8 ) ; 
                        fDone = Output(tc);
                    }
                    m_nBytesUsed = 0 ; 
                }	
                else
                    m_nBytesUsed++ ; 
            }
        }
        else                                    // error - ignor and rest
        {
            m_nBytesUsed = 0 ; 
            m_nByteFollow = 0 ;
        }
    }
    else                                        // a lead byte
    {
        if( m_nByteFollow > 0 )                 // error, previous sequence not finished
        {
            m_nByteFollow = 0;
            Output(' ');
            fDone = Output(0);
            m_nBytesUsed = 0 ; 
        }
        else                                    // calculate # bytes to follow
        {
            while( (0x80 & tc) != 0)            // BIT7 until first 0 encountered from left to right
            {
                tc <<= 1;
                m_nByteFollow++;
            }

            if (m_nByteFollow == 4)
            {
                m_fSurrogatesPairs = TRUE;
                m_tcSurrogateUnicode = tc >> m_nByteFollow;

            }
            else
            {
                m_tcUnicode = ( tc >> m_nByteFollow ) ;
                m_nBytesUsed = 1 ;               // # bytes used
            }
            m_nByteFollow--;                     // # bytes to follow
        }
    }

	return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccUTF8In::CleanUpMain()
{
	return TRUE;
}

int CInccUTF8In::GetUnconvertBytes()
{
    return  m_nBytesUsed < 4 ? m_nBytesUsed : 3 ; 
}

DWORD CInccUTF8In::GetConvertMode()
{
    // UTF8 does not use mode esc sequence
 	return 0 ;
}

void CInccUTF8In::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    // UTF8 does not use mode esc sequence
 	return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to UTF-8
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccUTF8Out::CInccUTF8Out(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccUTF8Out::Reset()
{
    m_fDoubleByte = FALSE;
    m_wchSurrogateHigh = 0;
    return ;
}

HRESULT CInccUTF8Out::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    WORD uc ;
    UCHAR UTF8[4] ;

    if (m_fDoubleByte )
    {
        uc = (	(WORD) tc << 8 | m_tcLeadByte  ) ;

        if (uc >= HIGHT_SURROGATE_START && uc <= HIGHT_SURROGATE_END && cchSrc >= sizeof(WCHAR))
        {
            if (m_wchSurrogateHigh)
            {
                UTF8[0] = 0xe0 | ( m_wchSurrogateHigh >> 12 );              // 4 bits in first byte
                UTF8[1] = 0x80 | ( ( m_wchSurrogateHigh >> 6 ) & 0x3f );    // 6 bits in second
                UTF8[2] = 0x80 | ( 0x3f & m_wchSurrogateHigh);              // 6 bits in third
                Output(UTF8[0]);
                Output(UTF8[1]);
                fDone = Output(UTF8[2]);
            }
            m_wchSurrogateHigh = uc;
            m_fDoubleByte = FALSE ;
            goto CONVERT_DONE;
        }

        if (m_wchSurrogateHigh)
        {
            if (uc >= LOW_SURROGATE_START && uc <= LOW_SURROGATE_END)       // We find a surrogate pairs
            {

                DWORD dwSurrogateChar = ((m_wchSurrogateHigh-0xD800) << 10) + uc - 0xDC00 + 0x10000;
                UTF8[0] = 0xF0 | (unsigned char)( dwSurrogateChar >> 18 );                 // 3 bits in first byte
                UTF8[1] = 0x80 | (unsigned char)( ( dwSurrogateChar >> 12 ) & 0x3f );      // 6 bits in second
                UTF8[2] = 0x80 | (unsigned char)( ( dwSurrogateChar >> 6 ) & 0x3f );       // 6 bits in third
                UTF8[3] = 0x80 | (unsigned char)( 0x3f & dwSurrogateChar);                 // 6 bits in forth
                Output(UTF8[0]);
                Output(UTF8[1]);
                Output(UTF8[2]);
                fDone = Output(UTF8[3]);                
                m_fDoubleByte = FALSE ;
                m_wchSurrogateHigh = 0;
                goto CONVERT_DONE;
            }
            else                                                            // Not a surrogate pairs, error
            {
                UTF8[0] = 0xe0 | ( m_wchSurrogateHigh >> 12 );              // 4 bits in first byte
                UTF8[1] = 0x80 | ( ( m_wchSurrogateHigh >> 6 ) & 0x3f );    // 6 bits in second
                UTF8[2] = 0x80 | ( 0x3f & m_wchSurrogateHigh);              // 6 bits in third
                Output(UTF8[0]);
                Output(UTF8[1]);
                fDone = Output(UTF8[2]);
                m_wchSurrogateHigh = 0;
            }
        }


        if( ( uc & 0xff80 ) == 0 ) // ASCII
        {
            UTF8[0] = (UCHAR) uc;
            fDone = Output(UTF8[0]);
        }
        else if( ( uc & 0xf800 ) == 0 ) 			// UTF8_2_MAX 2-byte sequence if < 07ff (11 bits)
        {
            UTF8[0] = 0xC0 | (uc >> 6);             // 5 bits in first byte
            UTF8[1] = 0x80 | ( 0x3f & uc);       // 6 bits in second
            Output(UTF8[0]);
            fDone = Output(UTF8[1]);
        }
        else                                             // 3-byte sequence
        {
            UTF8[0] = 0xe0 | ( uc >> 12 );                // 4 bits in first byte
            UTF8[1] = 0x80 | ( ( uc >> 6 ) & 0x3f );      // 6 bits in second
            UTF8[2] = 0x80 | ( 0x3f & uc);                // 6 bits in third
            Output(UTF8[0]);
            Output(UTF8[1]);
            fDone = Output(UTF8[2]);
        }
        m_fDoubleByte = FALSE ;
    }
    else
    {
        m_tcLeadByte = tc ;
        m_fDoubleByte = TRUE ;
    }

CONVERT_DONE:
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccUTF8Out::CleanUp()
{
	BOOL fDone = TRUE;

	return fDone;
}

int CInccUTF8Out::GetUnconvertBytes()
{
    return  m_fDoubleByte ? 1 : 0 ;
}

DWORD CInccUTF8Out::GetConvertMode()
{
    // UTF8 does not use mode esc sequence
 	return 0 ;
}

void CInccUTF8Out::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    // UTF8 does not use mode esc sequence
 	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mlang\validate.cpp ===
/*----------------------------------------------------------------------------
	%%File: validate.c
	%%Unit: fechmap
	%%Contact: jpick

	"Rolling" state machines that allow interactive verification of
    DBCS and EUC files.  Currently, separate tables are stored for
    each encoding so that the state machines can be run in parallel
    (i.e., multiple parse streams).

	These routines are used by auto-detection and if caller wants
    conversion routines to return errors on invalid characters.

    Following is a description of the structure of the DBCS and EUC 
    encodings handled by this module.  This information is taken from
    CJK.INF (maintained by Ken Lunde, author of _Understanding Japanese
    Information Processing_).  This information governs the structure
    of the class and validation state tables used in this module.

    Big5
      Two-byte Standard Characters         Encoding Ranges
          first byte range                     0xA1-0xFE
          second byte ranges                   0x40-0x7E, 0xA1-0xFE
      One-byte Characters                  Encoding Range
          ASCII                                0x21-0x7E
    
    GBK
      Two-byte Standard Characters         Encoding Ranges
          first byte range                     0x81-0xFE
          second byte ranges                   0x40-0x7E and 0x80-0xFE
      One-byte Characters                  Encoding Range
          ASCII                                0x21-0x7E

    HZ (information from HZ spec Fung F. Lee (lee@umunhum.stanford.edu))
	  One-byte characters					Encoding Ranges						   
      	first GB byte range						0x21-0x77
      	second GB byte range					0x21-0x7E
      	ASCII									0x21-0x7E
      Mode switching						Encoding sequence
		escape sequence from GB to ASCII		0x7E followed by 0x7B ("~{")
		escape sequence from ASCII to GB		0x7E followed by 0x7D ("~}")
		line continuation marker 				0x7E followed by 0x0A 
        (Note: ASCII mode is the default mode) 
    
    Shift-Jis
      Two-byte Standard Characters         Encoding Ranges
          first byte ranges                    0x81-0x9F, 0xE0-0xEF
          second byte ranges                   0x40-0x7E, 0x80-0xFC
      Two-byte User-defined Dharacters     Encoding Ranges
          first byte range                     0xF0-0xFC
          second byte ranges                   0x40-0x7E, 0x80-0xFC
      One-byte Characters                  Encoding Range
          Half-width katakana                  0xA1-0xDF
          ASCII/JIS-Roman                      0x21-0x7E
    
    Wansung
      Two-byte Standard Characters         Encoding Ranges
          first byte range                     0x81-0xFE
          second byte ranges                   0x40-0x7E and 0x80-0xFE
      One-byte Characters                  Encoding Range
          ASCII                                0x21-0x7E

    EUC-Cn
      Code set 0 (ASCII or GB 1988-89):        0x21-0x7E
      Code set 1 (GB 2312-80):                 0xA1A1-0xFEFE
      Code set 2:                              unused
      Code set 3:                              unused

    EUC-Jp
      Code set 0 (ASCII or JIS X 0201-1976 Roman):  0x21-0x7E
      Code set 1 (JIS X 0208):                 0xA1A1-0xFEFE
      Code set 2 (half-width katakana):        0x8EA1-0x8EDF
      Code set 3 (JIS X 0212-1990):            0x8FA1A1-0x8FFEFE

    EUC-Kr
      Code set 0 (ASCII or KS C 5636-1993):    0x21-0x7E
      Code set 1 (KS C 5601-1992):             0xA1A1-0xFEFE
      Code set 2:                              unused
      Code set 3:                              unused

    EUC-Tw
      Code set 0 (ASCII):                      0x21-0x7E
      Code set 1 (CNS 11643-1992 Plane 1):     0xA1A1-0xFEFE
      Code set 2 (CNS 11643-1992 Planes 1-16): 0x8EA1A1A1-0x8EB0FEFE
      Code set 3:                              unused

	UTF-7 (information from the RFC2152 by D.Goldsmith)
	  One-byte characters					Encoding Ranges						   
      	Direct and Optionally direct			0x21-0x2A, 0x2C-0x5B, 
      											0x5D-0x60, 0x7B-0x7D
      											0x09, 0x0A, 0x0D, 0x20
      	Modified Base64							0x2B, 0x2F-39, 0x41-0x5A, 0x61-0x7A
      Mode switching
      	escape sequence from D/O to M. Base64 	0x2B
      	escape sequence from M. Base64 to D/O 	0x2D (or any control character)
		
 ----------------------------------------------------------------------------*/
 
#include <stdio.h>
#include <stddef.h>

#include "private.h"
#include "fechmap_.h"
#include "lexint_.h"


/*----------------------------------------------------------------------------
	Common Defs for all Sequence Validation
----------------------------------------------------------------------------*/

// Characters are broken down into ranges -- the smallest ranges that
// are treated as important by either EUC or DBCS (all flavors).  In
// some cases, the smallest range is a single character.  It saves
// some space to avoid having two class tables (even though more states
// are added to the state machines), so both encodings share these
// tokens.

// Common Tokens
//
#define ollow       0		// "other" legal low ascii character
#define x000a       1		// 0x0a ("\n")
#define x212a       2		// characters in range 0x21-0x2a
#define x002b       3		// 0x2b	("+")
#define x002c       4		// 0x2c	(",")
#define x002d       5		// 0x2d	("-")
#define x002e       6       // 0x2e ("\")
#define x2f39       7		// characters in range 0x2f-0x39
#define x3a3f       8		// characters in range 0x3a-0x3f
#define x0040       9       // 0x40
#define x415a       10		// characters in range 0x41-0x5a
#define x005b       11		// 0x5b ("[")	
#define x005c       12		// 0x5c ("\")
#define x5d60       13		// characters in range 0x5d-0x60
#define x6177       14      // characters in range 0x61-0x77
#define	x787a       15		// characters in range 0x78-0x7a
#define x007b       16		// 0x7b ("{")
#define x007c       17		// 0x7c ("|")
#define x007d       18		// 0x7d ("}")
#define x007e       19		// 0x7e ("~")
#define x007f       20		// 0x7f (DEL)
#define x0080       21		// 0x80		
#define x818d       22		// characters in range 0x81-0x8d
#define x008e       23		// 0x8e
#define x008f       24		// 0x8f
#define x909f       25		// characters in range 0x90-0x9f
#define x00a0       26		// 0xa0
#define xa1b0       27		// characters in range 0xa1-0xb0
#define xb1df       28		// characters in range 0xb1-0xdf
#define xe0ef       29		// characters in range 0xe0-0xef
#define xf0fc       30		// characters in range 0xf0-0xfc
#define xfdfe       31		// characters in range 0xfd-0xfe

#define ateof       32		// end-of-file
#define other       33		// character not covered by above tokens

#define nTokens     34      //

// Class table
//
static char _rgchCharClass[256] =
//         0      1      2      3      4      5      6      7      8      9      a      b      c      d      e      f
    {
//  0      nul    soh    stx    etx    eot    enq    ack    bel    bs     tab    lf     vt     np     cr     so     si		0   
           other, other, other, other, other, other, other, other, other, ollow, x000a, other, other, ollow, other, other,

//  1      dle    dc1    dc2    dc3    dc4    nak    syn    etb    can    em     eof    esc    fs     gs     rs     us		1   
           other, other, other, other, other, other, other, other, other, other, ollow, other, other, other, other, other, 

//  2      sp     !      "      #      $      %      &      '      (      )      *      +      ,      -      .      /		2  
           ollow, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x212a, x002b, x002c, x002d, x002e, x2f39, 

//  3      0      1      2      3      4      5      6      7      8      9      :      ;      <      =      >      ?		3  
           x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x2f39, x3a3f, x3a3f, x3a3f, x3a3f, x3a3f, x3a3f, 

//  4      @      A      B      C      D      E      F      G      H      I      J      K      L      M      N      O		4  
           x0040, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, 

//  5      P      Q      R      S      T      U      V      W      X      Y      Z      [      \      ]      ^      _		5  
           x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x415a, x005b, x005c, x5d60, x5d60, x5d60, 

//  6      `      a      b      c      d      e      f      g      h      i      j      k      l      m      n      o		6  
           x5d60, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, 

//  7      p      q      r      s      t      u      v      w      x      y      z      {      |      }      ~      del		7  
           x6177, x6177, x6177, x6177, x6177, x6177, x6177, x6177, x787a, x787a, x787a, x007b, x007c, x007d, x007e, x007f, 

//	8                                                                                                                       8  
           x0080, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x818d, x008e, x008f, 

//	9                                                                                                                       9  
           x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, x909f, 

//	a                                                                                                                       a  
           x00a0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, xa1b0, 

//	b                                                                                                                       b  
           xa1b0, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, 

//	c                                                                                                                       c  
           xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, 

//	d                                                                                                                       d  
           xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, xb1df, 

//	e                                                                                                                       e  
           xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, xe0ef, 

//	f                                                                                                                       f  
           xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xf0fc, xfdfe, xfdfe, other, 

//         0      1      2      3      4      5      6      7      8      9      a      b      c      d      e      f
};


// Common States -- All SM's use these
//
#define ACC         0x4e
#define ERR         0x7f

// Other States -- All SM's use some of these, not all use all
//
#define ST0         0x00
#define ST0c        0x40
#define ST1         0x01
#define ST1c        0x41
#define ST2         0x02
#define ST2c        0x42
#define ST3         0x03
#define ST3c        0x43
#define ST4         0x04
#define ST4c        0x44

// Each state can have a corresponding counting stata i.e. stata with
// with the same transitions but during which we look for special sequences.
//
#define FTstCounting(tst)                   (((tst) & 0x40) != 0)   // If the state is counting (including ACC)
#define TstNotCountingFromTst(tst)          ((tst) & 0x3f)          // Obtain the real state from the counting

/*----------------------------------------------------------------------------
	DBCS character sequence validation
----------------------------------------------------------------------------*/

#define nSJisStates		2
static signed char _rgchSJisNextState[nSJisStates][nTokens] =
{
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     e     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
                                                                                                                                        

// DBCS State 0 -- start (look for legal single byte or lead byte)
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ERR,  ACC,  ACC,  ST1,  ST1,  ERR,  ACC,  ERR,
	 
// DBCS State 1 -- saw lead byte, need legal trail byte
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,
	 
};

#define nBig5States		2
static signed char _rgchBig5NextState[nBig5States][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// DBCS State 0 -- start (look for legal single byte or lead byte)
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
	 
// DBCS State 1 -- saw lead byte, need legal trail byte
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
	 
};

#define nGbkWanStates		2
static signed char _rgchGbkWanNextState[nGbkWanStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// DBCS State 0 -- start (look for legal single byte or lead byte)
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
	 
// DBCS State 1 -- saw lead byte, need legal trail byte
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
     
	 
};
		

/*----------------------------------------------------------------------------
	EUC character sequence validation
----------------------------------------------------------------------------*/

#define nEucJpStates		4
static signed char _rgchEucJpNextState[nEucJpStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// EUC State 0 -- start
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ST2,  ST3,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
	 
// EUC State 1 -- saw a1fe, need one more a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
	 
// EUC State 2 -- saw 8e, need a1df
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,
	 
// EUC State 3 -- saw 8f, need 2 a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ERR,  ERR,
	 
};

#define nEucKrCnStates		2
static signed char _rgchEucKrCnNextState[nEucKrCnStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// EUC State 0 -- start
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
	 
// EUC State 1 -- saw a1fe, need one more a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
	 
};

#define nEucTwStates		4
static signed char _rgchEucTwNextState[nEucTwStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// EUC State 0 -- start
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ST2,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ACC,  ERR,
	 
// EUC State 1 -- saw a1fe, need one more a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,
	 
// EUC State 2 -- saw 8e, need a1b0
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST3,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
	
// EUC State 3 -- saw 8e, a1b0; need 2 a1fe
    ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST1,  ST1,  ST1,  ST1,  ST1,  ERR,  ERR,
	 
};

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	HZ character sequence validation
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// Currently some of the rules for HZ encoding outlined above are a bit loosened up.
// (e.g. the range for the first GB byte is expanded) The rules were adjusted based on real data. 

#define nHzStates		5
static signed char _rgchHzNextState[nHzStates][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// HZ State 0 -- ASCII
    ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ST1c, ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,
	 
// HZ State 1 -- saw "~," looking for "{" to make transition to GB mode
    ERR,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ST2c, ERR,  ERR,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
	 
// HZ State 2 -- just saw "{," expecting GB byte
    ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ERR,  ERR,  ERR,  ST4c, ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
	
// HZ State 3 -- expecting GB byte
    ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST4c, ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,

// HZ State 4 -- saw "~," looking for "}" to make transition to ASCII mode
    ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ST3,  ACC,  ST3,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,

};

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	UTF-7 character sequence validation
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#define nUtf7States		3
static signed char _rgchUtf7NextState[nUtf7States][nTokens] =
{
//
//   o     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     x     a     o
//   l     0     2     0     0     0     0     2     3     0     4     0     0     5     6     7     0     0     0     0     0     0     8     0     0     9     0     a     b     e     f     f     t     t
//   l     0     1     0     0     0     0     f     a     0     1     0     0     d     1     8     0     0     0     0     0     0     1     0     0     0     0     1     1     0     0     d     e     h
//   o     0     2     2     2     2     2     3     3     4     5     5     5     6     7     7     7     7     7     7     7     8     8     8     8     9     a     b     d     e     f     f     o     e
//   w     a     a     b     c     d     e     9     f     0     a     b     c     0     7     a     b     c     d     e     f     0     d     e     f     f     0     0     f     f     c     e     f     r
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//

// UTF7 State 0 -- Direct/optionally direct ACSII mode, state transition can happen on "+"
    ACC,  ACC,  ACC,  ST1c, ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ACC,  ACC,  ACC,  ACC,  ACC,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,
	 
// UTF7 State 1 -- Expecting first character from Modified Base64 alphabet
    ERR,  ERR,  ERR,  ST2,  ERR,  ACC,  ERR,  ST2,  ERR,  ERR,  ST2,  ERR,  ERR,  ERR,  ST2,  ST2,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
	 
// UTF7 State 2 -- Modified Base64 alphabet mode, can be exited with "-" or any control character.
    ACC,  ACC,  ERR,  ST2,  ERR,  ACC,  ERR,  ST2,  ERR,  ERR,  ST2,  ERR,  ERR,  ERR,  ST2,  ST2,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ACC,  ERR,
};

/*----------------------------------------------------------------------------
	UTF-8 character sequence validation
----------------------------------------------------------------------------*/

static int _nUtf8Tb = 0;

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

/* N  U T F  8 */
/*----------------------------------------------------------------------------
	%%Function: _NUtf8
	%%Contact: jpick

	UTF-8 doesn't require a state table for validation, just a count
	of the number of expected trail bytes.  See utf8lex.c for an 
	explanation of this code.
----------------------------------------------------------------------------*/
static int __inline NUtf8(UCHAR uch, BOOL fEoi)
{
	// BIT7(uch) == 0 implies single ASCII byte.
	// BIT6(uch) == 0 implies one of n trail bytes.
	// Otherwise, lead byte, with number of bits set
	//   up to first 0 equal to the total number bytes
	//   in the sequence.
	//
	// REVIEW: _nUtf8Tb *is* really the state of this
	//   validator -- use nState in structure?
	//
	if (fEoi && (_nUtf8Tb != 0))
		{
		return 0;				// unexpected end-of-input
		}
    else if (BIT7(uch) == 0)
        {
		if (_nUtf8Tb != 0)		// unexpected single byte
			return 0;
		return 1;
        }
    else if (BIT6(uch) == 0)
        {
		if (_nUtf8Tb == 0)		// unexpected trail byte
			return 0;
		if ((--_nUtf8Tb) == 0)
			return 1;
        }
    else
        {
		if (_nUtf8Tb != 0)		// unexpected lead byte
			return 0;
        while (BIT7(uch) != 0)
            {
            uch <<= 1;
            _nUtf8Tb++;
            }
        _nUtf8Tb--;				// don't count lead byte
        }
	return -1;
}


/*----------------------------------------------------------------------------
	Character Mapping Defs
----------------------------------------------------------------------------*/

// If caller wants us to check characters as part of validation
//
typedef BOOL (*PFNCHECKCHAR)(ICET icetIn);

#define cchMaxBuff		5
typedef struct _cc
{
	int nCp;						// code page
	int cchBuff;					// fill count of character buffer
	PFNCHECKCHAR pfnCheckChar;		// character check routine
	char rgchBuff[cchMaxBuff];		// character buffer
} CC;
	
// Character validation prototypes
//
static BOOL _FDbcsCheckChar(ICET icetIn);

	
// DBCS character checker structures
//

// Big5
static CC _ccBig5 =
{
	nCpTaiwan,
	0,
	_FDbcsCheckChar,
};

// Gbk
static CC _ccGbk =
{
	nCpChina,
	0,
	_FDbcsCheckChar,
};

// ShiftJis
static CC _ccSJis =
{
	nCpJapan,
	0,
	_FDbcsCheckChar,
};

// Wansung
static CC _ccWan =
{
	nCpKorea,
	0,
	_FDbcsCheckChar,
};


// Character checker structures just used as buffers.
//

// Euc-Jp
static CC _ccEucJp =
{
	0,
	0,
	0,
};

// Hz
static CC _ccHz =
{
	0,
	0,
	0,
};

// Utf7
static CC _ccUtf7 =
{
	0,
	0,
	0,
};

/*----------------------------------------------------------------------------
	Character Occurrence Counters
----------------------------------------------------------------------------*/

// If calling app wants us to track occurrences of common character
// sequences during validation (used only by auto-detection, so far).
//

typedef struct _coce
{
	int   cHits;
	short cwch;
	WCHAR rgwch[2];
} COCE;

typedef struct _coc
{
	BOOL  fMatching;
	short nCoceCurr;
	short nCoceIndex;
	int   ccoce;
	COCE *rgcoce;
} COC;
	
// Big5
//
static COCE _rgcoceBig5[] =
{
	{0, 2, {(WCHAR)0xa7da, (WCHAR)0xadcc},},			// "wo men"
	{0, 2, {(WCHAR)0xa8e4, (WCHAR)0xb9ea},},			// "qi shi"
	{0, 2, {(WCHAR)0xa65d, (WCHAR)0xacb0},},			// "yin wei"
	{0, 2, {(WCHAR)0xb8ea, (WCHAR)0xb054},},			// "zi xun"
	{0, 2, {(WCHAR)0xb971, (WCHAR)0xb8a3},},			// "diam nao"
	{0, 2, {(WCHAR)0xbaf4, (WCHAR)0xb8f4},},			// "wang lu"
	{0, 2, {(WCHAR)0xbd75, (WCHAR)0xa457},},			// "xian shang"
	{0, 2, {(WCHAR)0xc577, (WCHAR)0xaaef},},			// "huan ying"
	{0, 2, {(WCHAR)0xa477, (WCHAR)0xb867},},			// "yi jing"
};
		
static COC _cocBig5 =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceBig5) / sizeof(_rgcoceBig5[0]), 		// ccoce
	_rgcoceBig5,										// rgcoce
};

// Euc-Cn
//
static COCE _rgcoceEucCn[] =
{
	{0, 2, {(WCHAR)0xcbfb, (WCHAR)0xc3c7},},			// "ta men"
	{0, 2, {(WCHAR)0xced2, (WCHAR)0xc3c7},},			// "wo men"
	{0, 2, {(WCHAR)0xd2f2, (WCHAR)0xb4cb},},			// "yin ci"
	{0, 2, {(WCHAR)0xcab2, (WCHAR)0xc3b4},},			// "shen mo"
	{0, 2, {(WCHAR)0xc8e7, (WCHAR)0xb9fb},},			// "ru guo"
	{0, 2, {(WCHAR)0xd2f2, (WCHAR)0xceaa},},			// "yin wei"
	{0, 2, {(WCHAR)0xcbf9, (WCHAR)0xd2d4},},			// "suo yi"
	{0, 2, {(WCHAR)0xbbb6, (WCHAR)0xd3ad},},			// "huan ying"
	{0, 2, {(WCHAR)0xcdf8, (WCHAR)0xc2e7},},			// "wang luo"
	{0, 2, {(WCHAR)0xd0c5, (WCHAR)0xcfa2},},			// "xin xi"
	{0, 2, {(WCHAR)0xbcc6, (WCHAR)0xcbe3},},			// "ji guan"
};
		
static COC _cocEucCn =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceEucCn) / sizeof(_rgcoceEucCn[0]), 	// ccoce
	_rgcoceEucCn,										// rgcoce
};
	
// Euc-Kr
//
static COCE _rgcoceEucKr[] =
{
	{0, 2, {(WCHAR)0xb0a1, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xb0a1, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xb4c2, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xb4c2, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xb4d9, (WCHAR)0x002e},},
	{0, 2, {(WCHAR)0xb4d9, (WCHAR)0xa3ae},},
	{0, 2, {(WCHAR)0xb8a6, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xb8a6, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xc0ba, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xc0ba, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xc0bb, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xc0bb, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xc0cc, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xc0cc, (WCHAR)0xa1a1},},
};
		
static COC _cocEucKr =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceEucKr) / sizeof(_rgcoceEucKr[0]), 	// ccoce
	_rgcoceEucKr,										// rgcoce
};
	
// EUC-Jp
//
static COCE _rgcoceEucJp[] =
{
	{0, 2, {(WCHAR)0xa4c7, (WCHAR)0xa4b9},},			// "de su"
	{0, 2, {(WCHAR)0xa4c0, (WCHAR)0xa1a3},},			// "da ."
	{0, 2, {(WCHAR)0xa4a4, (WCHAR)0xa4eb},},			// "i ru"
	{0, 2, {(WCHAR)0xa4de, (WCHAR)0xa4b9},},			// "ma su"
	{0, 2, {(WCHAR)0xa4b7, (WCHAR)0xa4bf},},			// "shi ta"
	{0, 2, {(WCHAR)0xa4b9, (WCHAR)0xa4eb},},			// "su ru"
	{0, 2, {(WCHAR)0xa4bf, (WCHAR)0xa1a3},},			// "ta ."
	{0, 2, {(WCHAR)0xa4eb, (WCHAR)0xa1a3},},			// "ru ."
};
		
static COC _cocEucJp =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceEucJp) / sizeof(_rgcoceEucJp[0]), 	// ccoce
	_rgcoceEucJp,										// rgcoce
};

// GBK
//
static COCE _rgcoceGbk[] =
{
	{0, 2, {(WCHAR)0xcbfb, (WCHAR)0xc3c7},},			// "ta men"
	{0, 2, {(WCHAR)0xced2, (WCHAR)0xc3c7},},			// "wo men"
	{0, 2, {(WCHAR)0xd2f2, (WCHAR)0xb4cb},},			// "yin ci"
	{0, 2, {(WCHAR)0xcab2, (WCHAR)0xc3b4},},			// "shen mo"
	{0, 2, {(WCHAR)0xc8e7, (WCHAR)0xb9fb},},			// "ru guo"
	{0, 2, {(WCHAR)0xd2f2, (WCHAR)0xceaa},},			// "yin wei"
	{0, 2, {(WCHAR)0xcbf9, (WCHAR)0xd2d4},},			// "suo yi"
	{0, 2, {(WCHAR)0xbbb6, (WCHAR)0xd3ad},},			// "huan ying"
	{0, 2, {(WCHAR)0xcdf8, (WCHAR)0xc2e7},},			// "wang luo"
	{0, 2, {(WCHAR)0xd0c5, (WCHAR)0xcfa2},},			// "xin xi"
	{0, 2, {(WCHAR)0xbcc6, (WCHAR)0xcbe3},},			// "ji guan"
};
		
static COC _cocGbk =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceGbk) / sizeof(_rgcoceGbk[0]), 		// ccoce
	_rgcoceGbk,											// rgcoce
};
	
// Shift-JIS
//
static COCE _rgcoceSJis[] =
{
	{0, 2, {(WCHAR)0x82c5, (WCHAR)0x82b7},},			// "de su"
	{0, 2, {(WCHAR)0x82be, (WCHAR)0x8142},},			// "da ."
	{0, 2, {(WCHAR)0x82a2, (WCHAR)0x82e9},},			// "i ru"
	{0, 2, {(WCHAR)0x82dc, (WCHAR)0x82b7},},			// "ma su"
	{0, 2, {(WCHAR)0x82b5, (WCHAR)0x82bd},},			// "shi ta"
	{0, 2, {(WCHAR)0x82b7, (WCHAR)0x82e9},},			// "su ru"
	{0, 2, {(WCHAR)0x82bd, (WCHAR)0x8142},},			// "ta ."
	{0, 2, {(WCHAR)0x82e9, (WCHAR)0x8142},},			// "ru ."
};

static COC _cocSJis =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceSJis) / sizeof(_rgcoceSJis[0]), 		// ccoce
	_rgcoceSJis,										// rgcoce
};
	
// Wansung
//
// REVIEW: bug (1/2 this table is being ignored)
//
static COCE _rgcoceWan[] =
{
	{0, 2, {(WCHAR)0xb0a1, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xb0a1, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xb4c2, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xb4c2, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xb4d9, (WCHAR)0x002e},},
	{0, 2, {(WCHAR)0xb4d9, (WCHAR)0xa3ae},},
	{0, 2, {(WCHAR)0xb8a6, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xb8a6, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xc0ba, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xc0ba, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xc0bb, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xc0bb, (WCHAR)0xa1a1},},
	{0, 2, {(WCHAR)0xc0cc, (WCHAR)0x0020},},
	{0, 2, {(WCHAR)0xc0cc, (WCHAR)0xa1a1},},
};

static COC _cocWan =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceWan) / sizeof(_rgcoceWan[0]), 		// ccoce
	_rgcoceWan,											// rgcoce
};

// Hz
//
static COCE _rgcoceHz[] =
{
	{0, 2, {(WCHAR)0x007e, (WCHAR)0x007b},},			// ~{
	{0, 2, {(WCHAR)0x007e, (WCHAR)0x007d},},            //  ~}
};

static COC _cocHz =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceHz) / sizeof(_rgcoceHz[0]), 		    // ccoce
	_rgcoceHz,											// rgcoce
};

// Utf7
//
static COCE _rgcoceUtf7[] =
{
	{0, 2, {(WCHAR)0x002b, (WCHAR)0x002d},},			// +-
};

static COC _cocUtf7 =
{
	fFalse,												// fMatching
	0,													// nCoceCurr
	0,													// nCoceIndex
	sizeof(_rgcoceUtf7) / sizeof(_rgcoceUtf7[0]), 		// ccoce
	_rgcoceUtf7,										// rgcoce
};
	
// Character counter prototype.
//
static void _CountChars(ICET icetIn);


/*----------------------------------------------------------------------------
	Main Definitions
----------------------------------------------------------------------------*/

// Structure to keep state, state machine and other associated
// information for a given character set "parse stream."
//
typedef struct _vr
{
	BOOL  fInUse;
	DWORD dwFlags;
	int   nState;
	CC   *ccCheck;
	signed char (*rgchNextState)[nTokens];
} VR;

// Array of validation records.  We allow multiple, active parse
// streams for auto-detect -- this way, it can concurrently keep
// a parse stream for each encoding type, without needing to read
// its input multiple times.
//
static VR _mpicetvr[icetCount] =
{
	{fTrue,  0, ST0, 0,         _rgchEucKrCnNextState,},		// icetEucCn
	{fTrue,  0, ST0, &_ccEucJp, _rgchEucJpNextState,},			// icetEucJp
	{fTrue,  0, ST0, 0,         _rgchEucKrCnNextState,},		// icetEucKr
	{fTrue,  0, ST0, 0,         _rgchEucTwNextState,},			// icetEucTw
	{fFalse, 0, ST0, 0,         0,},							// icetIso2022Cn
	{fFalse, 0, ST0, 0,         0,},							// icetIso2022Jp
	{fFalse, 0, ST0, 0,         0,},							// icetIso2022Kr
	{fFalse, 0, ST0, 0,         0,},							// icetIso2022Tw
	{fTrue,  0, ST0, &_ccBig5,  _rgchBig5NextState,},			// icetBig5
	{fTrue,  0, ST0, &_ccGbk,   _rgchGbkWanNextState,},			// icetGbk
	{fTrue,  0, ST0, &_ccHz,    _rgchHzNextState,},             // icetHz
	{fTrue,  0, ST0, &_ccSJis,  _rgchSJisNextState,},			// icetShiftJis
	{fTrue,  0, ST0, &_ccWan,   _rgchGbkWanNextState,},			// icetWansung
	{fTrue,  0, ST0, &_ccUtf7,  _rgchUtf7NextState,},           // icetUtf7
	{fTrue,  0, ST0, 0,        0,},								// icetUtf8
};

// Array of character sequence counters, one per encoding type.
//
static COC *_mpicetlpcoc[icetCount] =
{
	&_cocEucCn,			// icetEucCn
	&_cocEucJp,			// icetEucJp
	&_cocEucKr,			// icetEucKr
	0,					// icetEucTw
	0,					// icetIso2022Cn
	0,					// icetIso2022Jp
	0,					// icetIso2022Kr
	0,					// icetIso2022Tw
	&_cocBig5,			// icetBig5
	&_cocGbk,			// icetGbk
	&_cocHz,            // icetHz
	&_cocSJis,			// icetShiftJis
	&_cocWan,			// icetWansung
	&_cocUtf7,          // icetUtf7
	0,					// icetUtf8
};


/* V A L I D A T E  I N I T */
/*----------------------------------------------------------------------------
	%%Function: ValidateInit
	%%Contact: jpick

	Initialize the state machine for the given character set (set its
	state to ST0 (the start state) and store its parsing options).
----------------------------------------------------------------------------*/
void ValidateInit(ICET icetIn, DWORD dwFlags)
{
	// Initialize the character occurrence counter, if caller wants
	// us to count common character sequences (auto-detect, only,
	// for now).  Turn off the count-common-chars flag if we're not
	// set up to count sequences (meaning we don't have a set of
	// common characters for this encoding type or have no place
	// to buffer them).
	//	
	if (dwFlags & grfCountCommonChars)
		{
		if ((_mpicetlpcoc[icetIn]) && (_mpicetvr[icetIn].ccCheck))
			{
			int i;
			for (i = 0; i < _mpicetlpcoc[icetIn]->ccoce; i++)
				_mpicetlpcoc[icetIn]->rgcoce[i].cHits = 0;
			_mpicetlpcoc[icetIn]->fMatching = fFalse;
			}
		else
			{
			dwFlags &= ~grfCountCommonChars;
			}
		}
		
	// If validation not supported for the encoding type, there's
	// nothing else for us to do here.
	//
	if (!_mpicetvr[icetIn].fInUse)
		return;
		
	_mpicetvr[icetIn].nState = ST0;
	
	// Can't do character mapping validation without character 
	// checker information.  (If we do have the character checker,
	// initialize its buffer length to 0).
	//
	if (_mpicetvr[icetIn].ccCheck)
		_mpicetvr[icetIn].ccCheck->cchBuff = 0;
	else
		dwFlags &= ~grfValidateCharMapping;
		
	// It's also impossible without a valid code page.
	//
	if ((dwFlags & grfValidateCharMapping) && !IsValidCodePage(_mpicetvr[icetIn].ccCheck->nCp))
		dwFlags &= ~grfValidateCharMapping;
	
	_mpicetvr[icetIn].dwFlags = dwFlags;
	
	if (icetIn == icetUtf8)
		_nUtf8Tb = 0;
}


/* V A L I D A T E  R E S E T  A L L*/
/*----------------------------------------------------------------------------
	%%Function: ValidateInitAll
	%%Contact: jpick

	Initialize the state machines for all character sets (set their
	states to ST0 (the start state) and store their parsing options).
----------------------------------------------------------------------------*/
void ValidateInitAll(DWORD dwFlags)
{
	int i;
	for (i = 0 ; i < icetCount; i++)
		{
		if (!_mpicetvr[i].fInUse)
			continue;
		ValidateInit((ICET)i, dwFlags);	
		}
}


/* V A L I D A T E  R E S E T */
/*----------------------------------------------------------------------------
	%%Function: ValidateReset
	%%Contact: jpick

	Reset the state machine for the given character set (set its state
	to ST0 (the start state)).
----------------------------------------------------------------------------*/
void ValidateReset(ICET icetIn)
{
	// Initialize the character occurrence counter, if caller wants
	// us to count common character sequences (auto-detect, only,
	// for now).  We're guaranteed to have the structures if the
	// flag is set by ValidateInit(), above.
	//	
	if (_mpicetvr[icetIn].dwFlags & grfCountCommonChars)
		{
		int i;
		for (i = 0; i < _mpicetlpcoc[icetIn]->ccoce; i++)
			_mpicetlpcoc[icetIn]->rgcoce[i].cHits = 0;
		_mpicetlpcoc[icetIn]->fMatching = fFalse;
		}
		
	// If validation not supported for the encoding type, there's
	// nothing else for us to do here.
	//
	if (!_mpicetvr[icetIn].fInUse)
		return;
		
	_mpicetvr[icetIn].nState = ST0;
	
	if (_mpicetvr[icetIn].ccCheck)
		_mpicetvr[icetIn].ccCheck->cchBuff = 0;
		
	if (icetIn == icetUtf8)
		_nUtf8Tb = 0;
}


/* V A L I D A T E  R E S E T  A L L */
/*----------------------------------------------------------------------------
	%%Function: ValidateResetAll
	%%Contact: jpick

	Reset the state machines for all character sets (set their states to
	ST0 (the start state)).
----------------------------------------------------------------------------*/
void ValidateResetAll(void)
{
	int i;
	
	for (i=0 ; i < icetCount; i++)
		{
		if (!_mpicetvr[i].fInUse)
			continue;
		ValidateReset((ICET)i);
		}
}


/* N  V A L I D A T E  U C H */
/*----------------------------------------------------------------------------
	%%Function: NValidateUch
	%%Contact: jpick

	Single step parser, takes one transition through the state table
	for the given character set.  Current state is kept for each
	character set's parse stream.
	
	Routine returns -1 if it does not reach a final state on this
	transition; 0 if transitioned to ERR(or) and 1 if transtioned
	to ACC(ept).
	
	If final state is ACC(ept), machine reset to ST0 (start state).
	(i.e., there's no need to manually reset on ACC(ept)).
	
	Routine is also a convenient collection point for certain
	statistics (currently only the counting of occurrences of common
	character sequences (defined for character sets, above)).
----------------------------------------------------------------------------*/
int NValidateUch(ICET icetIn, UCHAR uch, BOOL fEoi)
{
	int nToken;
	int nPrevState;
	int rc = -1;
	
	// If not validating this icet, nothing to do (so say 
	// we accept the character).
	//
	if (!_mpicetvr[icetIn].fInUse)
		return 1;
	if (_mpicetvr[icetIn].nState == ERR)
		return 0;

	// Ignore all zeros in the detection file.
	if (!uch && !fEoi)
    	{
            goto _LRet;
        }

	// Hack -- want to validate UTF-8, but don't need a state
	// table to do so.  Treat as special case here and return.
	//
	if (icetIn == icetUtf8)
		{
		if ((rc = NUtf8(uch, fEoi)) == 0)
			_mpicetvr[icetIn].nState = ERR;
		return rc;
		}
		
	// Classify the character...
	//
	nPrevState = _mpicetvr[icetIn].nState;
	nToken = fEoi ? ateof : _rgchCharClass[uch];
	
	// First obtain a real number for a state based on the counting state...
	// Then do the transition...
	//
	_mpicetvr[icetIn].nState = (_mpicetvr[icetIn].rgchNextState)[TstNotCountingFromTst(_mpicetvr[icetIn].nState)][nToken];

#if 0
	if (_mpicetvr[icetIn].nState == ERR) 
		printf("Character 0x%.2x; Going from state %.2x to state %.2x\n", uch, nPrevState, _mpicetvr[icetIn].nState);
#endif

	// If we're in an error state or have seen end-of-input, return.
	//
	if ((_mpicetvr[icetIn].nState == ERR) || (nToken == ateof))
		goto _LRet;
	
	// Are we to do character mapping validation?  (If this flag
	// is set, we're guaranteed to have a character checker 
	// structure).  How about character occurrence counting?
	// (This also guarantees us a character checker structure).
	//
	if (!(_mpicetvr[icetIn].dwFlags & grfValidateCharMapping) &&
			!(_mpicetvr[icetIn].dwFlags & grfCountCommonChars))
		{
		goto _LRet;
		}
			
	// Buffer the current character (trusting that we'll never get
	// more than the max amount -- present tables enforce this)
	// (if it's Utf7 or Hz, buffer only if we are in the counting state
	//
	if (FTstCounting(_mpicetvr[icetIn].nState) || (icetIn != icetHz && icetIn != icetUtf7)) 
		_mpicetvr[icetIn].ccCheck->rgchBuff[_mpicetvr[icetIn].ccCheck->cchBuff++] = uch;

	// Return if we are not in the counting state
	//
	if (!(FTstCounting(_mpicetvr[icetIn].nState)))
		goto _LRet;
		
	// Call the character checker, if we have one.
	//
	if (_mpicetvr[icetIn].dwFlags & grfValidateCharMapping)
		{
		if (_mpicetvr[icetIn].ccCheck->pfnCheckChar && !(_mpicetvr[icetIn].ccCheck->pfnCheckChar)(icetIn))
			{
			_mpicetvr[icetIn].nState = ERR;
			goto _LRet;
			}
		}
		
	// If we're counting common characters, do so now.
	//
	if (_mpicetvr[icetIn].dwFlags & grfCountCommonChars)
		_CountChars(icetIn);
	
	// Reset the character checker/counter buffer.
	//
	_mpicetvr[icetIn].ccCheck->cchBuff = 0;
	
_LRet:

	// Return the appropriate code.
	//
	switch (_mpicetvr[icetIn].nState)
		{
		case ERR:
			return 0;
		case ACC:
			_mpicetvr[icetIn].nState = ST0;			// Reset
			return 1;
		default:
			return -1;								// need more data
		}
}


/* F  V A L I D A T E  C H A R  C O U N T */
/*----------------------------------------------------------------------------
	%%Function: FValidateCharCount
	%%Contact: jpick

	Return the number of matched special character sequences for the
	given character set.  If we're not keeping track of these sequences
	for the character set, either because we don't have the necessary
	static data or because the flag wasn't set by the calling routine,
	return fFalse.  Otherwise, return the count in *lpcMatch and return
	fTrue;
	
	(We track the counts separately for each sequence, just in case
	we want to weight them differently in the future.  Return the
	total, here).
----------------------------------------------------------------------------*/
BOOL FValidateCharCount(ICET icetIn, int *lpcMatch)
{
	int i;
	COC *lpcoc = _mpicetlpcoc[icetIn];
	VR *lpvr = &_mpicetvr[icetIn];
		
	if (!lpcoc || !lpvr->fInUse || !(lpvr->dwFlags & grfCountCommonChars))
		return fFalse;
		
	for (i = 0, *lpcMatch = 0; i < lpcoc->ccoce; i++)
		*lpcMatch += lpcoc->rgcoce[i].cHits;
		
	return fTrue;
}


/* _  C O U N T  C H A R S */
/*----------------------------------------------------------------------------
	%%Function: _CountChars
	%%Contact: jpick

	We've just completed a legal character for the given character
	set.  Match it against the set of special character sequences for
	the character set, if we have them.  Update match counts and
	current match indices (since sequences can span multiple legal
	characters) as needed.
----------------------------------------------------------------------------*/
static void _CountChars(ICET icetIn)
{
	WCHAR wch;
	int i;
	BOOL fFound;
	
	// Anything to do?
	//
	if (!_mpicetlpcoc[icetIn] || !_mpicetvr[icetIn].ccCheck)
		return;
		
	// Build the WCHAR.
	//
	switch (_mpicetvr[icetIn].ccCheck->cchBuff)
		{
		case 1:
			wch = WchFromUchUch(0, _mpicetvr[icetIn].ccCheck->rgchBuff[0]);
			break;
		case 2:
			wch = WchFromUchUch(_mpicetvr[icetIn].ccCheck->rgchBuff[0],
								_mpicetvr[icetIn].ccCheck->rgchBuff[1]);
			break;
		case 3:
			wch = WchFromUchUch(_mpicetvr[icetIn].ccCheck->rgchBuff[1],
								_mpicetvr[icetIn].ccCheck->rgchBuff[2]);
			break;
		case 4:
			wch = WchFromUchUch(_mpicetvr[icetIn].ccCheck->rgchBuff[2],
								_mpicetvr[icetIn].ccCheck->rgchBuff[3]);
			break;
		default:
			return;
		}
		
	// Are we currently working on matching a sequence?
	//
	if ((_mpicetlpcoc[icetIn]->fMatching) && 
		(wch == _mpicetlpcoc[icetIn]->rgcoce[_mpicetlpcoc[icetIn]->nCoceCurr].rgwch[_mpicetlpcoc[icetIn]->nCoceIndex]))
		{
		// Did we just match the entire sequence?  If so, increment the
		// hit count and reset.
		//
		if (++_mpicetlpcoc[icetIn]->nCoceIndex >= _mpicetlpcoc[icetIn]->rgcoce[_mpicetlpcoc[icetIn]->nCoceCurr].cwch)
			{
			++_mpicetlpcoc[icetIn]->rgcoce[_mpicetlpcoc[icetIn]->nCoceCurr].cHits;
			_mpicetlpcoc[icetIn]->fMatching = fFalse;
			}
			
		// All done.
		//
		return;
		}
		
	// If we need to start matching again (either because we're not
	// currently in a sequence or because a 2nd or later character
	// didn't match), try the current character as a lead character.
	//
	// REVIEW: wrong for sequences longer than 2 wchars.
	//
	for (i = 0, fFound = fFalse; (!fFound && (i < _mpicetlpcoc[icetIn]->ccoce)); i++)
		{
		if (wch == _mpicetlpcoc[icetIn]->rgcoce[i].rgwch[0])
			fFound = fTrue;
		}
		
	// Any luck?
	//
	if (!fFound)
		{
		_mpicetlpcoc[icetIn]->fMatching = fFalse;
		return;
		}
		
	// Store the matching state.
	//
	_mpicetlpcoc[icetIn]->fMatching = fTrue;
	_mpicetlpcoc[icetIn]->nCoceCurr = i - 1;
	_mpicetlpcoc[icetIn]->nCoceIndex = 1;			// where to look next
}


/* _  D B C S  C H E C K  C H A R */
/*----------------------------------------------------------------------------
	%%Function: _DbcsCheckChar
	%%Contact: jpick

	Character validator for DBCS formats.  Attempts to round-trip a
	legal multi-byte sequence to ensure that its valid for the given
	character set.
	
	REVIEW:  Slow, slow, slow -- do we really gain anything from the
    round-trip check, or is conversion *to* Unicode a sufficient test?
----------------------------------------------------------------------------*/
static WCHAR _rgwBuff[10];
static UCHAR _rgchBuff[30];

static BOOL _FDbcsCheckChar(ICET icetIn)
{
	int cCvt;
	
	// skip 1 byte characters, mostly uninteresting (Shift-Jis ??).
	//
	if (_mpicetvr[icetIn].ccCheck->cchBuff == 1)
		return fTrue;
	
	if (!(cCvt = MultiByteToWideChar(_mpicetvr[icetIn].ccCheck->nCp,
									 MB_ERR_INVALID_CHARS,
									 _mpicetvr[icetIn].ccCheck->rgchBuff,
									 _mpicetvr[icetIn].ccCheck->cchBuff,
									 _rgwBuff, 10)))
		{
		if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
			return fFalse;
		}
		
	return fTrue;  // probably not always right
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
#include <winsock.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? TRUE : NULL!=(_hinst = LoadLibrary(TEXT(#_dll))))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        ASSERT_MSGA(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- PSTOREC.DLL ---------------
HINSTANCE g_hinstPSTOREC = NULL;

DELAY_LOAD_ERR(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreCreateInstance,
    (IPStore ** ppProvider, PST_PROVIDERID *pProviderID, void *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL);

void UnloadPStore()
{
    if (g_hinstPSTOREC)
        FreeLibrary(g_hinstPSTOREC);
    g_hinstPSTOREC = NULL;
}

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\factory.cpp ===
#include "private.h"
#include "factory.h"

CClassFactory::CClassFactory(const CFactoryData *pFactoryData) :
    m_pFactoryData(pFactoryData)
{
    m_cRef = 1;

    DllAddRef();
}

CClassFactory::~CClassFactory()
{
    DllRelease();
}

// IUnknown members
STDMETHODIMP CClassFactory::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if( IID_IUnknown == riid || IID_IClassFactory == riid )
        *ppv=this;

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

// IClassFactory members
STDMETHODIMP CClassFactory::CreateInstance(
    LPUNKNOWN punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    if ((NULL == ppv) ||
        (punkOuter && (IID_IUnknown != riid)))
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if ((NULL != punkOuter) && 
        !(m_pFactoryData->m_dwFlags & FD_ALLOWAGGREGATION))
    {
        return CLASS_E_NOAGGREGATION;
    }

    IUnknown *punk;
    hr = m_pFactoryData->m_pCreateProc(punkOuter, &punk);

    if (SUCCEEDED(hr))
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    }

    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllLock();
    }
    else
    {
        DllUnlock();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\factory.h ===
#ifndef _factory_h
#define _factory_h

typedef HRESULT (* CREATEPROC)(IUnknown *, IUnknown **);

#define FD_ALLOWAGGREGATION     0x00000001

struct CFactoryData
{
    CLSID const *m_pClsid;
    CREATEPROC  m_pCreateProc;
    DWORD       m_dwFlags;
};

class CClassFactory : public IClassFactory
{
public:
    CClassFactory(const CFactoryData *pFactoryData);
    ~CClassFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP         LockServer(BOOL fLock);

private:
    ULONG               m_cRef;
    const CFactoryData  *m_pFactoryData;
};

#endif // _factory_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\ident.cpp ===
//
// ident.cpp - implementation of CUserIdentity class
//
#include "private.h"
#include "shlwapi.h"
#include "multiusr.h"
#include "strconst.h"
#include "multiutl.h"
#include <shfolder.h>

//
// Constructor / destructor
//
CUserIdentity::CUserIdentity()
    : m_cRef(1),
      m_fSaved(FALSE),
      m_fUsePassword(0)
{
    m_szUsername[0] = 0;
    m_szPassword[0] = 0;
    ZeroMemory(&m_uidCookie, sizeof(GUID));

    DllAddRef();
}


CUserIdentity::~CUserIdentity()
{
    DllRelease();
}


//
// IUnknown members
//
STDMETHODIMP CUserIdentity::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if(IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if ((IID_IUserIdentity == riid)
             || (IID_IUserIdentity2 == riid))
    {
        *ppv = (IUserIdentity2 *)this;
    }

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CUserIdentity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CUserIdentity::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}


// 
// IUserIdentity members
//
STDMETHODIMP CUserIdentity::GetCookie(GUID *puidCookie)
{
    if (!m_fSaved)
        return E_INVALIDARG;

    *puidCookie = m_uidCookie;
    return S_OK;

}

STDMETHODIMP CUserIdentity::OpenIdentityRegKey(DWORD dwDesiredAccess, HKEY *phKey)
{
    TCHAR    szRootPath[MAX_PATH];
    HRESULT  hr = S_OK;

    if (!m_fSaved)
        return E_IDENTITY_NOT_FOUND;

    MU_GetRegRootForUserID(&m_uidCookie, szRootPath);

    hr = RegCreateKey(HKEY_CURRENT_USER, szRootPath, phKey);
    RegCloseKey(*phKey);

    hr = RegOpenKeyEx(HKEY_CURRENT_USER, szRootPath, 0, dwDesiredAccess, phKey);
    return (hr == ERROR_SUCCESS ? S_OK : E_FAIL);
}


STDMETHODIMP CUserIdentity::GetIdentityFolder(DWORD dwFlags, WCHAR *pszPath, ULONG ulBuffSize)
{
    WCHAR    szwRootPath[MAX_PATH];
    HRESULT hr;

    if (!m_fSaved)
        return E_IDENTITY_NOT_FOUND;

    hr = MU_GetUserDirectoryRoot(&m_uidCookie, dwFlags, szwRootPath, MAX_PATH);
    
    if (SUCCEEDED(hr))
    {
        StrCpyW(pszPath, szwRootPath);
    }

    return hr;
}



STDMETHODIMP CUserIdentity::GetName(WCHAR *pszName, ULONG ulBuffSize)
{
    if (!m_fSaved || ulBuffSize == 0)
        return E_IDENTITY_NOT_FOUND;

    if (MultiByteToWideChar(CP_ACP, 0, m_szUsername, -1, pszName, ulBuffSize) == 0)
        return GetLastError();
    
    return S_OK;
}

STDMETHODIMP CUserIdentity::SetName(WCHAR *pszName)
{
    TCHAR       szRegPath[MAX_PATH];
    HRESULT     hr = S_OK;
    HKEY        hKey;
    USERINFO    uiCurrent;
    LPARAM      lpNotify = IIC_CURRENT_IDENTITY_CHANGED;
    TCHAR       szUsername[CCH_USERNAME_MAX_LENGTH];
    
    if (WideCharToMultiByte(CP_ACP, 0, pszName, -1, szUsername, CCH_USERNAME_MAX_LENGTH, NULL, NULL) == 0)
    {
        return GetLastError();
    }

    //
    // Only perform change if the username doesn't already exist.
    //
    if (!MU_UsernameExists(szUsername) && strcmp(szUsername, m_szUsername) != 0)
    {
        strcpy( m_szUsername, szUsername );

        hr = _SaveUser();
    
        // if its not the current identity, then just broadcast that an identity changed
        if (MU_GetUserInfo(NULL, &uiCurrent) && (m_uidCookie != uiCurrent.uidUserID))
        {
            lpNotify = IIC_IDENTITY_CHANGED;
        }

        // tell apps that the user's name changed
        if (SUCCEEDED(hr))
        {
            PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, lpNotify);
        }
    }
    else
    {
        hr = E_IDENTITY_EXISTS;
    }

    return hr;
}

STDMETHODIMP CUserIdentity::SetPassword(WCHAR *pszPassword)
{
#ifdef IDENTITY_PASSWORDS
    TCHAR       szRegPath[MAX_PATH];
    HRESULT     hr = S_OK;
    HKEY        hKey;
    
    if (!m_fSaved)
        return E_IDENTITY_NOT_FOUND;

    if (WideCharToMultiByte(CP_ACP, 0, pszPassword, -1, m_szPassword, CCH_USERPASSWORD_MAX_LENGTH, NULL, NULL) == 0)
        return GetLastError();
    
    m_fUsePassword = (*m_szPassword != 0);

    hr = _SaveUser();

    return hr;
#else
    return E_NOTIMPL;
#endif
}


STDMETHODIMP CUserIdentity::_SaveUser()
{
    DWORD   dwType, dwSize, dwValue, dwStatus;
    HKEY    hkCurrUser;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szUid[255];
    HRESULT hr;

    if (*m_szUsername == 0)
        return E_INVALIDARG;

    if (!m_fUsePassword)
        m_szPassword[0] = 0;

    if (!m_fSaved)
        hr = _ClaimNextUserId(&m_uidCookie);

    Assert(m_uidCookie != GUID_NULL);
    Assert(SUCCEEDED(hr));

    //
    // Save our settings
    //
    USERINFO UserInfo;

    UserInfo.uidUserID= m_uidCookie;
    lstrcpy( UserInfo.szUsername, m_szUsername);
    UserInfo.fUsePassword= m_fUsePassword;
    UserInfo.fPasswordValid= m_fUsePassword;
    lstrcpy( UserInfo.szPassword, m_szPassword );
    
    BOOL bSuccess= MU_SetUserInfo(&UserInfo);

    if (bSuccess)
    {
        m_fSaved = TRUE;
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}


STDMETHODIMP CUserIdentity::InitFromUsername(TCHAR *pszUsername)
{
    GUID   uidCookie;
    HRESULT hr;

    if(FAILED(hr = MU_UsernameToUserId(pszUsername, &uidCookie)))
        return hr;

    return InitFromCookie(&uidCookie);
}


STDMETHODIMP CUserIdentity::InitFromCookie(GUID *puidCookie)
{
    BOOL bSuccess;
    USERINFO UserInfo;
    HRESULT hrRet = E_FAIL;

    bSuccess = MU_GetUserInfo( puidCookie, &UserInfo );

    if (bSuccess)
    {
        m_fUsePassword = UserInfo.fUsePassword;
        lstrcpy( m_szUsername, UserInfo.szUsername );
        lstrcpy( m_szPassword, UserInfo.szPassword );
        m_uidCookie = UserInfo.uidUserID;
        m_fSaved = TRUE;
        hrRet = S_OK;
    }

    return hrRet;
}


STDMETHODIMP CUserIdentity::GetOrdinal(DWORD* pdwOrdinal)
{
    if (!pdwOrdinal)
    {
        return E_INVALIDARG;
    }

    HKEY    hSourceSubKey, hkUserKey;
    DWORD   dwSize, dwType;
    DWORD   dwIdentityOrdinal = 1, dwOrdinal = 0;
    TCHAR   szUid[MAX_PATH];
    HRESULT hr = E_FAIL;
    
    AStringFromGUID(&m_uidCookie,  szUid, MAX_PATH);
        
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwIdentityOrdinal);
        RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

        if (RegOpenKey(hSourceSubKey, szUid, &hkUserKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize)!=ERROR_SUCCESS)
            {
                if (RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)==ERROR_SUCCESS)
                {
                    dwOrdinal = dwIdentityOrdinal++;
                    RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                    hr = S_OK;
                }
                else
                {
                    AssertSz(FALSE, "Couldn't set the identity ordinal");
                }
            }
            else
            {
                hr = S_OK;
            }
            
            RegCloseKey(hkUserKey); 
        }
        else
        {
            AssertSz(FALSE, "Couldn't open user's Key");
        }
        
        RegCloseKey(hSourceSubKey);
    }
    else
    {
        AssertSz(FALSE, "Couldn't open user profiles root Key");
    }

    *pdwOrdinal = dwOrdinal;
    return hr;
}

//----------------------------------------------------------------------------
//  Changes password to newPass if oldPass matches the current password
//----------------------------------------------------------------------------
STDMETHODIMP CUserIdentity::ChangePassword(WCHAR *szOldPass, WCHAR *szNewPass)
{
    HRESULT     hr = E_FAIL;
    TCHAR       szOldPwd[CCH_USERPASSWORD_MAX_LENGTH+1];
    
    if (!m_fSaved)
    {
        return E_IDENTITY_NOT_FOUND;
    }

    if (WideCharToMultiByte(CP_ACP, 0, szOldPass, -1, szOldPwd, CCH_USERPASSWORD_MAX_LENGTH, NULL, NULL) == 0)
    {
        return E_FAIL;
    }

    if (!m_fUsePassword || lstrcmp(szOldPwd, m_szPassword) == 0)
    {
        hr = SetPassword(szNewPass);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\identmgr.cpp ===
//
// ident.cpp - implementation of CIdentity class
//
#include "private.h"
#include "multiusr.h"
#include "multiui.h"
#include "strconst.h"
#include "resource.h"
#include "mluisup.h"

extern HINSTANCE g_hInst;
BOOL        g_fReleasedMutex = true;


//
// Constructor / destructor
//
CUserIdentityManager::CUserIdentityManager()
{
    m_cRef = 1;
    m_fWndRegistered = FALSE;
    m_hwnd = NULL;
    m_pAdviseRegistry = NULL;
    InitializeCriticalSection(&m_rCritSect);
    DllAddRef();
}

CUserIdentityManager::~CUserIdentityManager()
{
    if (m_pAdviseRegistry)
        m_pAdviseRegistry->Release();
    DeleteCriticalSection(&m_rCritSect);
    DllRelease();
}


//
// IUnknown members
//
STDMETHODIMP CUserIdentityManager::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if (IID_IUnknown == riid)
    {
        *ppv = (IUserIdentityManager *)this;
    }
    else if (IID_IUserIdentityManager == riid)
    {
        *ppv = (IUserIdentityManager *)this;
    }
    else if (IID_IConnectionPoint == riid)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else if (IID_IPrivateIdentityManager == riid)
    {
        *ppv = (IPrivateIdentityManager *)this;
    }
    else if (IID_IPrivateIdentityManager2 == riid)
    {
        *ppv = (IPrivateIdentityManager2 *)this;
    }

    // Addref through the interface
    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CUserIdentityManager::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CUserIdentityManager::Release()
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


STDMETHODIMP CUserIdentityManager::CreateIdentity(WCHAR *pszName, IUserIdentity **ppIdentity)
{
    return CreateIdentity2(pszName, NULL, ppIdentity);
}

STDMETHODIMP CUserIdentityManager::CreateIdentity2(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT  hr;
    TCHAR   szName[CCH_IDENTITY_NAME_MAX_LENGTH+1];

    *ppIdentity = NULL;

    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;

    if (WideCharToMultiByte(CP_ACP, 0, pszName, -1, szName, CCH_IDENTITY_NAME_MAX_LENGTH, NULL, NULL) == 0)
        return GetLastError();

    if (MU_UsernameExists(szName))
        return E_IDENTITY_EXISTS;

    pIdentity = new CUserIdentity;
    
    Assert(pIdentity);

    if (!pIdentity)
        return E_OUTOFMEMORY;

    hr = pIdentity->SetName(pszName);
    
    if (SUCCEEDED(hr))
    {
        if (pszPassword)
        {
            hr = pIdentity->SetPassword(pszPassword);
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppIdentity = pIdentity;
    }
    else
    {
        pIdentity->Release();
    }

    PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, IIC_IDENTITY_ADDED);

    return hr;
}

STDMETHODIMP CUserIdentityManager::ConfirmPassword(GUID *uidCookie, WCHAR *pszPassword)
{
    TCHAR           szPwd[CCH_USERPASSWORD_MAX_LENGTH+1];
    HRESULT         hr = E_FAIL;
    USERINFO        userInfo;

    if (WideCharToMultiByte(CP_ACP, 0, pszPassword, -1, szPwd, CCH_USERPASSWORD_MAX_LENGTH, NULL, NULL) == 0)
        return E_FAIL;

    if (MU_GetUserInfo(uidCookie, &userInfo))
    {
        if (userInfo.fPasswordValid)
        {
            if (!userInfo.fUsePassword)
                userInfo.szPassword[0] = 0;

            if (lstrcmp(szPwd, userInfo.szPassword) == 0)
                hr = S_OK;
            else
                hr = E_FAIL;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CUserIdentityManager::DestroyIdentity(GUID *uidCookie)
{
    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;
    
    return MU_DeleteUser(uidCookie);
}

STDMETHODIMP CUserIdentityManager::EnumIdentities(IEnumUserIdentity **ppEnumIdentity)
{
    CEnumUserIdentity   *pEnumIdentity;

    *ppEnumIdentity = NULL;

    pEnumIdentity = new CEnumUserIdentity;

    if (!pEnumIdentity)
        return E_OUTOFMEMORY;

    *ppEnumIdentity = pEnumIdentity;

    return S_OK;
}

STDMETHODIMP CUserIdentityManager::SetDefaultIdentity(GUID *puidCookie)
{
    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;

    return MU_MakeDefaultUser(puidCookie);
}

STDMETHODIMP CUserIdentityManager::GetDefaultIdentity(GUID *puidCookie)
{
    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;

    return MU_GetDefaultUserID(puidCookie) ? S_OK : S_FALSE;
}

STDMETHODIMP CUserIdentityManager::ManageIdentities(HWND hwndParent, DWORD dwFlags)
{
    TCHAR    szUsername[CCH_USERNAME_MAX_LENGTH+1];

    if (MU_IdentitiesDisabled())
        return E_IDENTITIES_DISABLED;
    
    *szUsername = 0;

    MU_ManageUsers(hwndParent, szUsername, dwFlags);
    
    // if the user created a new user and said they want to switch to them now,
    // we should do so.
    if (*szUsername)
    {
        BOOL        fGotUser;
        USERINFO    rUser;
        GUID        uidUserID;
        HRESULT     hr;

        fGotUser = MU_GetUserInfo(NULL, &rUser);
        if (!fGotUser)
        {
            *rUser.szUsername = 0;
            ZeroMemory(&rUser.uidUserID, sizeof(GUID));
        }
        MU_UsernameToUserId(szUsername, &uidUserID);

        if (FAILED(hr = _SwitchToUser(&rUser.uidUserID, &uidUserID)))
        {
            SetForegroundWindow(hwndParent);
            
            if (hr != E_USER_CANCELLED)
                MU_ShowErrorMessage(hwndParent, idsSwitchCancelled, idsSwitchCancelCaption);
        }
    }
    return S_OK;
}

STDMETHODIMP CUserIdentityManager::_PersistChangingIdentities()
{
    HRESULT hr = E_FAIL;
    HKEY hKeyIdentities = NULL;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hKeyIdentities))
    {
        goto exit;
    }

    if (ERROR_SUCCESS != RegSetValueEx(hKeyIdentities, c_szOutgoingID, 0, REG_BINARY, (LPBYTE)&g_uidOldUserId, sizeof(GUID)))
    {
        goto exit;
    }
    
    if (ERROR_SUCCESS != RegSetValueEx(hKeyIdentities, c_szIncomingID, 0, REG_BINARY, (LPBYTE)&g_uidNewUserId, sizeof(GUID)))
    {
        goto exit;
    }
    
    if (ERROR_SUCCESS != RegSetValueEx(hKeyIdentities, c_szChanging, 0, REG_BINARY, (LPBYTE)&g_fNotifyComplete, sizeof(g_fNotifyComplete)))
    {
        goto exit;
    }
    

    hr = S_OK;
exit:
    if (hKeyIdentities)
    {
        RegCloseKey(hKeyIdentities);
    }
    
    return hr;
}

STDMETHODIMP CUserIdentityManager::_LoadChangingIdentities()
{
    HRESULT hr = E_FAIL;
    HKEY hKeyIdentities = NULL;
    DWORD dwType, dwSize;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hKeyIdentities))
    {
        goto exit;
    }

    dwType = REG_BINARY;
    dwSize = sizeof(GUID);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyIdentities, c_szOutgoingID, 0, &dwType, (LPBYTE)&g_uidOldUserId, &dwSize))
    {
        goto exit;
    }
    
    dwSize = sizeof(GUID);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyIdentities, c_szIncomingID, 0, &dwType, (LPBYTE)&g_uidNewUserId, &dwSize))
    {
        goto exit;
    }

    dwSize = sizeof(g_fNotifyComplete);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyIdentities, c_szChanging, 0, &dwType, (LPBYTE)&g_fNotifyComplete, &dwSize))
    {
        goto exit;
    }


    hr = S_OK;
exit:
    if (FAILED(hr))
    {
        g_uidOldUserId = GUID_NULL;
        g_uidNewUserId = GUID_NULL;
        g_fNotifyComplete = TRUE;
    }
    
    if (hKeyIdentities)
    {
        RegCloseKey(hKeyIdentities);
    }
    
    return hr;
}

STDMETHODIMP CUserIdentityManager::ClearChangingIdentities()
{
    HRESULT hr = E_FAIL;
    HKEY hKeyIdentities = NULL;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hKeyIdentities))
    {
        goto exit;
    }

    RegDeleteValue(hKeyIdentities, c_szChanging);
    RegDeleteValue(hKeyIdentities, c_szIncomingID);
    RegDeleteValue(hKeyIdentities, c_szOutgoingID);    

    hr = S_OK;
    
exit:
    if (hKeyIdentities)
    {
        RegCloseKey(hKeyIdentities);
    }
    
    return hr;

}

STDMETHODIMP CUserIdentityManager::Logon(HWND hwndParent, DWORD dwFlags, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT     hr = E_FAIL;
    USERINFO    rUser;
    GUID        uidUserID, uidNewUserID;
    BOOL        fGotUser;
    TCHAR       szOldUsername[CCH_USERNAME_MAX_LENGTH+1], szLogoffName[CCH_USERNAME_MAX_LENGTH+1];
    TCHAR       szRes[MAX_PATH];

    // if identities are disabled, always return the default identity.
    // if they are forcing the UI, return an error, otherwise succeed and 
    // send the message back that identities are disabled.
    if (MU_IdentitiesDisabled())
    {
        if (!!(dwFlags & UIL_FORCE_UI))
            return E_IDENTITIES_DISABLED;

        hr = GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, ppIdentity);
        
        return (SUCCEEDED(hr) ? S_IDENTITIES_DISABLED : hr);
    }

    if (!g_hMutex)
        return E_UNEXPECTED;

    _LoadChangingIdentities();

    if (g_uidOldUserId != GUID_NULL || g_uidNewUserId != GUID_NULL)
    {
        // we are in the middle of a switch
        if (!g_fNotifyComplete)
        {
            // and we are not done checking to see if a switch is ok.
            if (!!(dwFlags & UIL_FORCE_UI))    //if its a force ui, then just fail.
                return E_IDENTITY_CHANGING;    

            //otherwise, we need to do something here, but since they could be
            //calling Login from the notifier proc, this could create a deadlock,
            //but returning either the old or the new could be wrong.  Return the
            //same error here unless we can come up with a better solution.
            return E_IDENTITY_CHANGING;
        }
    }

    DWORD dwWaitResult;
    dwWaitResult = WaitForSingleObject(g_hMutex, 5000); 
    g_fReleasedMutex = false;
    if (dwWaitResult == WAIT_TIMEOUT)
    {
        char    szMsg[255], szTitle[63];

        // someone else seems to have a login dialog up.  Notify the user
        // about this problem and bail.
        if (!!(dwFlags & UIL_FORCE_UI))
        {
            MLLoadStringA(idsSwitchInProgressSwitch, szMsg, ARRAYSIZE(szMsg));
            MLLoadStringA(idsSwitchIdentities, szTitle, ARRAYSIZE(szTitle));
        }
        else
        {
            MLLoadStringA(idsSwitchInProgressLaunch, szMsg, ARRAYSIZE(szMsg));
            MLLoadStringA(idsIdentityLogin, szTitle, ARRAYSIZE(szTitle));
        }

        MessageBox(hwndParent, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

        return E_UNEXPECTED;
    }

    *ppIdentity = NULL;
    fGotUser = MU_GetUserInfo(NULL, &rUser);
    if (!fGotUser)
    {
        *rUser.szUsername = 0;
        ZeroMemory(&rUser.uidUserID, sizeof(GUID));
    }
    lstrcpy(szOldUsername, rUser.szUsername);

    // if we don't have to do the UI and there is a current 
    // user, then just return that identity
    if (!(dwFlags & UIL_FORCE_UI) && fGotUser)
    {
        pIdentity = new CUserIdentity;
        
        if (!pIdentity)
            hr = E_OUTOFMEMORY;

        if (pIdentity && SUCCEEDED(hr = pIdentity->InitFromUsername(rUser.szUsername)))
            *ppIdentity = pIdentity;
    }
    else
    {
        if (0 == *rUser.szUsername)
        {
            GUID    uidStart;

            MU_GetLoginOption(&uidStart);
            if (GUID_NULL != uidStart)
            {
                MU_GetUserInfo(&uidStart, &rUser);
                rUser.uidUserID = GUID_NULL;
        
            }
        }

        if (MU_Login(hwndParent, dwFlags, rUser.szUsername))
        {
            MLLoadStringA(idsLogoff, szLogoffName, sizeof(szLogoffName));
            if (lstrcmp(szLogoffName, rUser.szUsername) == 0)
            {
                MLLoadStringA(idsConfirmLogoff, szRes, sizeof(szRes));

                if (MessageBox(hwndParent, szRes, szLogoffName, MB_YESNO) == IDYES)
                {
                    ReleaseMutex(g_hMutex);
                    g_fReleasedMutex = true;
                    Logoff(hwndParent);
                }
            }
            else
            {
                pIdentity = new CUserIdentity;
                if (pIdentity)
                {
                    hr = pIdentity->InitFromUsername(rUser.szUsername);

                    if (SUCCEEDED(hr))
                    {
                        pIdentity->GetCookie(&uidNewUserID);

                        hr = _SwitchToUser(&rUser.uidUserID, &uidNewUserID);
                        *ppIdentity = pIdentity;
                    }

                    if (FAILED(hr))
                    {
                        UINT    iMsgId = idsSwitchCancelled;

                        pIdentity->Release();
                        *ppIdentity = NULL;

                        SetForegroundWindow(hwndParent);
                    
                        // could switch on some error codes to set iMsgId to 
                        // other error messages.  For now, skip showing the
                        // message if a user did the cancelling
                        if (hr != E_USER_CANCELLED)
                            MU_ShowErrorMessage(hwndParent, iMsgId, idsSwitchCancelCaption);
                    }
                }
            }
        }
        else
            hr = E_USER_CANCELLED;
    }

    if (!g_fReleasedMutex)
        ReleaseMutex(g_hMutex);

    return hr;
}


STDMETHODIMP CUserIdentityManager::Logoff(HWND hwndParent)
{
    GUID        uidToID = GUID_NULL;
    HRESULT     hr;
    USERINFO    rUser;
    BOOL        fGotUser;

    if (!g_hMutex)
        return E_UNEXPECTED;

    DWORD dwWaitResult;
    dwWaitResult = WaitForSingleObject(g_hMutex, INFINITE);  
    
    if (dwWaitResult != WAIT_OBJECT_0)
        return E_UNEXPECTED;

    fGotUser = MU_GetUserInfo(NULL, &rUser);
    if (!fGotUser)
        rUser.uidUserID = GUID_NULL;

    // switch to the null user
    hr = _SwitchToUser(&rUser.uidUserID, &uidToID);

    if (FAILED(hr))
    {
        UINT    iMsgId = idsLogoutCancelled;

        SetForegroundWindow(hwndParent);
        
        // could switch on some error codes to set iMsgId to 
        // other error messages.  For now, skip showing the
        // message if a user did the cancelling
        if (hr != E_USER_CANCELLED)
            MU_ShowErrorMessage(hwndParent, iMsgId, idsSwitchCancelCaption);
    }

    ReleaseMutex(g_hMutex);

    return hr;
}

STDMETHODIMP CUserIdentityManager::_SwitchToUser(GUID *puidFromUser, GUID *puidToUser)
{
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1] = "";
    HRESULT hr;

    // switching to the same user is automatically OK.
    if (*puidFromUser == *puidToUser)
        return S_OK;

    // Set up the from and to users
    g_uidOldUserId = *puidFromUser;
    g_uidNewUserId = *puidToUser;
    g_fNotifyComplete = FALSE;
    _PersistChangingIdentities();
    if (*puidToUser != GUID_NULL)
        MU_UserIdToUsername(puidToUser, szUsername, CCH_USERNAME_MAX_LENGTH);
        
    // Notify window's that a switch is coming
    if (SUCCEEDED(hr = _QueryProcessesCanSwitch()))
    {
        if (SUCCEEDED(hr = MU_SwitchToUser(szUsername)))
        {
            if (!g_fReleasedMutex)
            {
                g_fReleasedMutex = true;
                g_fNotifyComplete = true;
                ReleaseMutex(g_hMutex);
            }
            _NotifyIdentitiesSwitched();
        }
    }
    g_fNotifyComplete = TRUE;

    // clear these back out again
    g_uidOldUserId = GUID_NULL;
    g_uidNewUserId = GUID_NULL;
    ClearChangingIdentities();

    return hr;
}

STDMETHODIMP CUserIdentityManager::GetIdentityByCookie(GUID *uidCookie, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT hr = E_IDENTITY_NOT_FOUND;
    GUID        uidUserCookie = *uidCookie;

    *ppIdentity = NULL;

    if (MU_IdentitiesDisabled())
    {
        // if disabled, they can only get the default identity. 
        // if asking for the current, they will get the defalt.
        // if asking for default by the constant or the default's guid, then succeed.
        // otherwise return an error.
        if (!MU_GetDefaultUserID(&uidUserCookie))
            return E_IDENTITY_NOT_FOUND;
        
        if (UID_GIBC_CURRENT_USER == uidUserCookie)
            uidUserCookie = UID_GIBC_DEFAULT_USER;

        if (!(uidUserCookie == uidUserCookie || UID_GIBC_DEFAULT_USER == uidUserCookie))
            return E_IDENTITIES_DISABLED;
    }


    if (uidUserCookie  == UID_GIBC_DEFAULT_USER)
    {
        if (!MU_GetDefaultUserID(&uidUserCookie))
            return E_IDENTITY_NOT_FOUND;
    }
    else if (uidUserCookie  == UID_GIBC_CURRENT_USER)
    {
        if (!MU_GetCurrentUserID(&uidUserCookie))
            return E_NO_CURRENT_IDENTITY;
    }
    else if (uidUserCookie  == UID_GIBC_OUTGOING_USER)
    {
        _LoadChangingIdentities();
        if (g_uidOldUserId == GUID_NULL)
            return E_IDENTITY_NOT_FOUND;
        else
            uidUserCookie = g_uidOldUserId;
    }
    else if (uidUserCookie  == UID_GIBC_INCOMING_USER)
    {
        _LoadChangingIdentities();
        if (g_uidNewUserId == GUID_NULL)
            return E_IDENTITY_NOT_FOUND;
        else
            uidUserCookie = g_uidNewUserId;
    }

    pIdentity = new CUserIdentity;
    if (pIdentity)
    {
        hr = pIdentity->InitFromCookie(&uidUserCookie);

        if (SUCCEEDED(hr))
            *ppIdentity = pIdentity;
        else
        {
            // Cleanup
            delete pIdentity;
        }
    }

    return hr;
}

STDMETHODIMP CUserIdentityManager::GetConnectionInterface(IID *pIID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUserIdentityManager::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    *ppCPC = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CUserIdentityManager::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    HRESULT hr;
    EnterCriticalSection(&m_rCritSect);

    AddRef();

    if (!m_pAdviseRegistry)
        m_pAdviseRegistry = new CNotifierList;
    Assert(m_pAdviseRegistry);

    if (m_pAdviseRegistry)
    {
        if (!m_fWndRegistered)
            _CreateWindowClass();

        hr = m_pAdviseRegistry->Add(pUnkSink, pdwCookie);
    }
    else
        hr = E_OUTOFMEMORY;

    LeaveCriticalSection(&m_rCritSect);    
    return hr;
}

STDMETHODIMP CUserIdentityManager::Unadvise(DWORD dwCookie)
{
    HRESULT hr;

    EnterCriticalSection(&m_rCritSect);
    if (m_pAdviseRegistry)
    {
        hr = m_pAdviseRegistry->RemoveCookie(dwCookie);
    }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_rCritSect);    

    Release();
    
    return hr;
}
        
STDMETHODIMP CUserIdentityManager::EnumConnections(IEnumConnections **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CUserIdentityManager::QuerySwitchIdentities()
{
    HRESULT    hr = S_OK;
    DWORD    dwLength, dwIndex;

    if (!m_pAdviseRegistry)
        return S_OK;

    TraceCall("Identity - CUserIdentityManager::QuerySwitchIdentities");

    dwLength = m_pAdviseRegistry->GetLength();

    for (dwIndex = 0; dwIndex < dwLength; dwIndex++)
    {
        IUnknown    *punk;
        IIdentityChangeNotify    *pICNotify;
        if (SUCCEEDED(m_pAdviseRegistry->GetAtIndex(dwIndex, &punk)) && punk)
        {
            if (SUCCEEDED(punk->QueryInterface(IID_IIdentityChangeNotify, (void **)&pICNotify)) && pICNotify)
            {
                if (FAILED(hr = pICNotify->QuerySwitchIdentities()))
                {
                    punk->Release();
                    pICNotify->Release();
                    goto exit;
                }
                pICNotify->Release();
            }
            punk->Release();
        }
    }
exit:
    return hr;
}

STDMETHODIMP CUserIdentityManager::NotifySwitchIdentities()
{
    HRESULT    hr = S_OK;
    DWORD    dwLength, dwIndex;

    if (!m_pAdviseRegistry)
        return S_OK;

    TraceCall("Identity - CUserIdentityManager::NotifySwitchIdentities");

    dwLength = m_pAdviseRegistry->GetLength();

    for (dwIndex = 0; dwIndex < dwLength; dwIndex++)
    {
        IUnknown    *punk;
        IIdentityChangeNotify    *pICNotify;
        if (SUCCEEDED(m_pAdviseRegistry->GetAtIndex(dwIndex, &punk)) && punk)
        {
            if (SUCCEEDED(punk->QueryInterface(IID_IIdentityChangeNotify, (void **)&pICNotify)) && pICNotify)
            {
                if (FAILED(hr = pICNotify->SwitchIdentities()))
                {
                    punk->Release();
                    pICNotify->Release();
                    goto exit;
                }
                pICNotify->Release();
            }
            punk->Release();
        }
    }
exit:
    return hr;
}

STDMETHODIMP CUserIdentityManager::_QueryProcessesCanSwitch()
{
    HWND    hWnd, hNextWnd = NULL;
    LRESULT lResult;
    HWND   *prghwnd = NULL;
    DWORD   chwnd = 0, cAllocHwnd = 0, dw;
    HRESULT hr;

    TraceCall("Identity - CUserIdentityManager::_QueryProcessesCanSwitch");

    cAllocHwnd = 10;
    if (!MemAlloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
        return E_OUTOFMEMORY;

    hWnd = GetTopWindow(NULL);
    while (hWnd)
    {
        hNextWnd = GetNextWindow(hWnd, GW_HWNDNEXT);
        
        if (!IsWindowVisible(hWnd))
        {
            TCHAR   szWndClassName[255];

            GetClassName(hWnd,  szWndClassName, sizeof(szWndClassName));
            
            if (lstrcmp(szWndClassName, c_szNotifyWindowClass) == 0)
            {
                if (chwnd == cAllocHwnd)
                {
                    cAllocHwnd += 10;
                    if (!MemRealloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                }
                prghwnd[chwnd++] = hWnd;
            }
        }

        hWnd = hNextWnd;
    }
    
    hr = S_OK;
    for (dw = 0; dw < chwnd; dw++)
    {
        if (IsWindow(prghwnd[dw]))
        {
            lResult = SendMessage(prghwnd[dw], WM_QUERY_IDENTITY_CHANGE, 0, 0);
            if (FAILED((HRESULT)lResult))
            {
                hr = (HRESULT)lResult;
                goto exit;
            }
        }
    }
exit:
    MemFree(prghwnd);
    prghwnd = NULL;
    return hr;
}

STDMETHODIMP CUserIdentityManager::_NotifyIdentitiesSwitched()
{
    HWND    hWnd, hNextWnd = NULL;
    LRESULT lResult;
    HWND   *prghwnd = NULL;
    DWORD   chwnd = 0, cAllocHwnd = 0, dw;

    TraceCall("Identity - CUserIdentityManager::_NotifyIdentitiesSwitched");

    cAllocHwnd = 10;
    if (!MemAlloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
        return E_OUTOFMEMORY;

    hWnd = GetTopWindow(NULL);
    while (hWnd)
    {
        hNextWnd = GetNextWindow(hWnd, GW_HWNDNEXT);
        
        if (!IsWindowVisible(hWnd))
        {
            TCHAR   szWndClassName[255];

            GetClassName(hWnd,  szWndClassName, sizeof(szWndClassName));
            
            if (lstrcmp(szWndClassName, c_szNotifyWindowClass) == 0)
            {
                if (chwnd == cAllocHwnd)
                {
                    cAllocHwnd += 10;
                    if (!MemRealloc((LPVOID*)(&prghwnd), cAllocHwnd * sizeof(HWND)))
                        goto exit;
                }
                prghwnd[chwnd++] = hWnd;
            }
        }

        hWnd = hNextWnd;
    }
    
    for (dw = 0; dw < chwnd; dw++)
    {
        DWORD_PTR dwResult;
        if (IsWindow(prghwnd[dw]))
//            lResult = PostMessage(prghwnd[dw], WM_IDENTITY_CHANGED, 0, 0);    //Raid 48054
            SendMessageTimeout(prghwnd[dw], WM_IDENTITY_CHANGED, 0, 0, SMTO_ABORTIFHUNG | SMTO_NORMAL, 1500, &dwResult);
    }
exit:
    MemFree(prghwnd);
    prghwnd = NULL;
    return S_OK;
}

STDMETHODIMP CUserIdentityManager::_CreateWindowClass()
{
    WNDCLASS wc;    
        
    if (!m_fWndRegistered)            /*set up window class and register it */
    {
        wc.lpszClassName    = c_szNotifyWindowClass;
        wc.hInstance        = g_hInst;
        wc.lpfnWndProc      = CUserIdentityManager::WndProc;
        wc.hCursor          = NULL;
        wc.hIcon            = NULL;
        wc.lpszMenuName     = NULL;
        wc.hbrBackground    = NULL;
        wc.style            = CS_DBLCLKS;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;

        if (!RegisterClassA(&wc))
            return E_FAIL;

        m_fWndRegistered = TRUE;
    }

    return S_OK;
}


LRESULT CALLBACK CUserIdentityManager::WndProc(HWND hWnd, UINT messg, WPARAM wParam, LPARAM lParam)
{
    CNotifierList *pList = NULL;
    HRESULT  hr;

    if (messg == WM_QUERY_IDENTITY_CHANGE ||
        messg == WM_IDENTITY_CHANGED ||
        messg == WM_IDENTITY_INFO_CHANGED)
    {
#if defined(DEBUG)
        DebugStrf("Identity - CUserIdentityManager::WndProc() called for notification.\r\n");
#endif
        pList = (CNotifierList *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        if (pList)
        {
            hr = pList->SendNotification(messg, (DWORD)lParam);
            return hr;
        }
    }
    else
    {
        switch(messg)
        {
            case WM_CREATE:
                LPCREATESTRUCT  pcs;

                pcs = (LPCREATESTRUCT)lParam;
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LRESULT)pcs->lpCreateParams);
                return(DefWindowProc(hWnd, messg, wParam, lParam));
                break;
/*
            case WM_QUERY_IDENTITY_CHANGE:
            case WM_IDENTITY_CHANGED:
            case WM_IDENTITY_INFO_CHANGED:
                DebugStrf("Identity - CUserIdentityManager::WndProc() called for notification.\r\n");
                pList = (CNotifierList *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
                if (pList)
                {
                    hr = pList->SendNotification(messg, (DWORD)lParam);
                    return hr;
                }
                break;
*/
            case WM_CLOSE:
                SetWindowLongPtr(hWnd, GWLP_USERDATA, 0);
                return(DefWindowProc(hWnd, messg, wParam, lParam));
                break;

            default:
                return(DefWindowProc(hWnd, messg, wParam, lParam));
 
        }
    }
    return 0;
}

//----------------------------------------------------------------------------
//  Logon the specified user.
//  - Checks password
//----------------------------------------------------------------------------
STDMETHODIMP CUserIdentityManager::LogonAs(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity)
{
    CUserIdentity *pIdentity;
    HRESULT     hr = E_FAIL;
    USERINFO    rUser;
    GUID        uidNewUserID;
    BOOL        fGotUser;
    TCHAR       szName[CCH_USERNAME_MAX_LENGTH+1];

    if (WideCharToMultiByte(CP_ACP, 0, pszName, -1, szName, CCH_USERNAME_MAX_LENGTH, NULL, NULL) == 0)
    {
        return E_FAIL;
    }

    // if identities are disabled, always return the default identity.
    if (MU_IdentitiesDisabled())
    {
        hr = GetIdentityByCookie((GUID *)&UID_GIBC_DEFAULT_USER, ppIdentity);
        
        return (SUCCEEDED(hr) ? S_IDENTITIES_DISABLED : hr);
    }

    if (!g_hMutex)
        return E_UNEXPECTED;

    if (g_uidOldUserId != GUID_NULL || g_uidOldUserId != GUID_NULL)
    {
        // we are in the middle of a switch
        if (!g_fNotifyComplete)
        {
            return E_IDENTITY_CHANGING;
        }
    }

    *ppIdentity = NULL;

    //
    // Grab info on the current user
    //
    fGotUser = MU_GetUserInfo(NULL, &rUser);
    if (!fGotUser)
    {
        *rUser.szUsername = 0;
        ZeroMemory(&rUser.uidUserID, sizeof(GUID));
    }

    if (0 == *rUser.szUsername)
    {
        GUID uidStart;

        MU_GetLoginOption(&uidStart);
        if (GUID_NULL != uidStart)
        {
            MU_GetUserInfo(&uidStart, &rUser);
            rUser.uidUserID = GUID_NULL;
    
        }
    }

    pIdentity = new CUserIdentity;
    if (pIdentity)
    {
        hr = pIdentity->InitFromUsername(szName);
        if (SUCCEEDED(hr))
        {
            pIdentity->GetCookie(&uidNewUserID);
            hr= ConfirmPassword(&uidNewUserID, pszPassword);
            if (SUCCEEDED(hr))
            {
                hr = _SwitchToUser(&rUser.uidUserID, &uidNewUserID);

                if (SUCCEEDED(hr))
                {
                    *ppIdentity = pIdentity;
                }
                else
                {
                    UINT iMsgId = idsSwitchCancelled;

                    pIdentity->Release();
                    *ppIdentity = NULL;

                    // could switch on some error codes to set iMsgId to 
                    // other error messages.  For now, skip showing the
                    // message if a user did the cancelling
                    if (hr != E_USER_CANCELLED)
                        MU_ShowErrorMessage(NULL, iMsgId, idsSwitchCancelCaption);
                }
            } // ConfirmPassword()
        } // InitFromUsername()
    }

    if (!g_fReleasedMutex)
        ReleaseMutex(g_hMutex);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\idenum.cpp ===
//
// ident.cpp - implementation of CIdentity class
//
#include "private.h"
#include "strconst.h"
#include "multiusr.h"
//
// Constructor / destructor
//
CEnumUserIdentity::CEnumUserIdentity()
{
    m_cRef = 1;
    m_dwCurrentUser = 0;
    m_cCountUsers = 0;
    m_rguidUsers = NULL;
    m_fInited = FALSE;

    DllAddRef();
}


CEnumUserIdentity::~CEnumUserIdentity()
{   
    _Cleanup();

    DllRelease();
}


//
// IUnknown members
//
STDMETHODIMP CEnumUserIdentity::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if(IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if(IID_IEnumUserIdentity == riid)
    {
        *ppv = (IEnumUserIdentity *)this;
    }

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumUserIdentity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumUserIdentity::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}


// 
// IEnumUserIdentity members
//
STDMETHODIMP CEnumUserIdentity::Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched)
{
	ULONG celtFetched = 0;
	HRESULT hr = ResultFromScode(S_OK);
    CUserIdentity   *pIdentity;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

    while (celt) 
    {
        if (m_dwCurrentUser == m_cCountUsers) {
            hr = ResultFromScode(S_FALSE);
            break;
        }

        pIdentity = new CUserIdentity;
        if (pIdentity)
        {
            if (SUCCEEDED(pIdentity->InitFromCookie(&m_rguidUsers[m_dwCurrentUser])))
            {
                rgelt[celtFetched++] = pIdentity;
                m_dwCurrentUser++;
            }
            else
            {
                pIdentity->Release();
                hr = ResultFromScode(E_OUTOFMEMORY);
                break;
            }
        }
        else
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            break;
        }
        celt--;
    }

    if (FAILED(hr))
    {
        for (ULONG i = 0; i < celtFetched; i++)
            rgelt[i]->Release();
        celtFetched = 0;
    }

	if (pceltFetched != NULL)
		*pceltFetched = celtFetched;

	return hr;
}

STDMETHODIMP CEnumUserIdentity::Skip(ULONG celt)
{
    SCODE sc;
    HRESULT hr = S_OK;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

	if (m_dwCurrentUser + celt > m_cCountUsers) {
		m_dwCurrentUser = m_cCountUsers;
		sc = S_FALSE;
	}
	else {
		m_dwCurrentUser += celt;
		sc = S_OK;
	}

	return ResultFromScode(sc);
}

STDMETHODIMP CEnumUserIdentity::Reset(void)
{
    m_dwCurrentUser = 0;
    _Cleanup();
    return S_OK;
}

STDMETHODIMP CEnumUserIdentity::Clone(IEnumUserIdentity **ppenum)
{
    CEnumUserIdentity   *pEnum;
    HRESULT             hr = S_OK;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

    pEnum = new CEnumUserIdentity;

    if (pEnum)
    {
        hr = pEnum->_Init(m_dwCurrentUser, m_cCountUsers, m_rguidUsers);

        if (SUCCEEDED(hr))
            *ppenum = pEnum;
    }

    return hr;
}

STDMETHODIMP CEnumUserIdentity::GetCount(ULONG *pnCount)
{
    HRESULT hr = S_OK;

    if (!m_fInited)
        hr = _Init();

    if (FAILED(hr))
        return hr;

    *pnCount = m_cCountUsers;

    return S_OK;
}

STDMETHODIMP CEnumUserIdentity::_Cleanup()
{
    MemFree(m_rguidUsers);
    m_rguidUsers = NULL;
    m_cCountUsers = 0;
    m_fInited = FALSE;

    return S_OK;
}

STDMETHODIMP CEnumUserIdentity::_Init()
{
    HRESULT hr=S_OK;
    HKEY    hReg = NULL;
    DWORD   cUsers = 0;
    DWORD   cbMaxSubKeyLen;
    DWORD   cb;
    DWORD   dwEnumIndex = 0;
    BOOL    fDisabled = MU_IdentitiesDisabled();

    m_cCountUsers = 0;

    // Open or Create root server key
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, NULL, &hReg, NULL) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Enumerate keys
    if (RegQueryInfoKey(hReg, NULL, NULL, 0, &cUsers, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL,
                        NULL, NULL) != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto exit;
    }


    // No users ?
    if (cUsers == 0)
        goto done;

    if (fDisabled)
        cUsers = 1;

    // Allocate the users array
    MemAlloc((LPVOID *)&m_rguidUsers, sizeof(GUID) * cUsers);
    
    if (!m_rguidUsers)
    {
        cUsers = 0;
        goto done;
    }

    // Zero init
    ZeroMemory(m_rguidUsers, sizeof(GUID) * cUsers);

    if (fDisabled)
    {
        MU_GetDefaultUserID(&m_rguidUsers[0]);
        goto done;
    }

    while (TRUE) 
    {
        HKEY    hkUserKey;
        DWORD   dwStatus, dwSize, dwType;
        TCHAR   szKeyNameBuffer[MAX_PATH];
        TCHAR   szUid[255];

        if (RegEnumKey(hReg, dwEnumIndex++, szKeyNameBuffer,MAX_PATH)
            !=  ERROR_SUCCESS)
            break;
        
        if (RegOpenKey(hReg, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szUid);
            dwStatus = RegQueryValueEx(hkUserKey, c_szUserID, NULL, &dwType, (LPBYTE)szUid, &dwSize);
            Assert(ERROR_SUCCESS == dwStatus);

            if (ERROR_SUCCESS == dwStatus)
                GUIDFromAString(szUid, &m_rguidUsers[dwEnumIndex - 1]);

            RegCloseKey(hkUserKey); 
        }
        else
            AssertSz(FALSE, "Couldn't open user's key");
    }

done:
    m_cCountUsers = cUsers;
    m_fInited = TRUE;

exit:
    if (hReg)
        RegCloseKey(hReg);

    return hr;
}


STDMETHODIMP CEnumUserIdentity::_Init(DWORD dwCurrentUser, DWORD dwCountUsers, GUID *prgUserCookies)
{
    m_dwCurrentUser = dwCurrentUser;
    m_cCountUsers = dwCountUsers;

    // Allocate the users array
    MemAlloc((LPVOID *)&m_rguidUsers, sizeof(GUID) * dwCountUsers);
    
    if (!m_rguidUsers)
        return E_OUTOFMEMORY;

    CopyMemory(m_rguidUsers, prgUserCookies, sizeof(GUID) * dwCountUsers);

    m_fInited = TRUE;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\mluisup.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString        MLLoadStringW
#define MLBuildResURLWrap   MLBuildResURLWrapW
#else
#define MLLoadString        MLLoadStringA
#define MLBuildResURLWrap   MLBuildResURLWrapA
#endif

#undef ML_ID_DIALOGCALLS
BOOL        _PathRemoveFileSpec(LPTSTR pFile);

void        MLLoadResources(HINSTANCE hinstParent, LPTSTR pszLocResDll);
void        MLFreeResources(HINSTANCE hinstParent);
int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);
HINSTANCE   MLGetHinst();
INT_PTR     MLDialogBoxWrap(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc);
INT_PTR     MLDialogBoxParamWrap(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
HWND        MLCreateDialogParamWrap(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hwndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
BOOL        MLEndDialogWrap(HWND hDlg, INT_PTR nResult);
HWND        MLHtmlHelpWrap(HWND hwndCaller, LPCTSTR pszFile, UINT uCommand, DWORD dwData, DWORD dwCrossCodePage);
BOOL        MLWinHelpWrap(HWND hwndCaller, LPCTSTR lpszHelp, UINT uCommand, DWORD dwData);
HRESULT     MLBuildResURLWrapA(LPSTR    pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPSTR    pszResName,
                               LPSTR    pszResURL,
                               int      nBufSize,
                               LPSTR    pszParentDll);
HRESULT     MLBuildResURLWrapW(LPWSTR   pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPWSTR   pszResName,
                               LPWSTR   pszResURL,
                               int      nBufSize,
                               LPWSTR   pszParentDll);

HWND        SHHtmlHelpOnDemandWrap(HWND hwndCaller, LPCTSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
BOOL        SHWinHelpOnDemandWrap(HWND hwndCaller, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
// MLLoadLibrary is used for loading the various localized resource libraries
// Note: MLLoadLibrary is exported without a name, only an ordinal #
#ifndef UNICODE
#define szMLLoadLibrary 377  //TEXT("MLLoadLibraryA"); 
#else
#define szMLLoadLibrary 378  //TEXT("MLLoadLibraryW"); // for Unicode
#endif

#ifdef MLUI_INIT

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const char c_szShlwapiDll[] = "shlwapi.dll";


struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    ULONG       ulRefs;
    BOOL        fMLEnabled;
} g_mluiInfo = { NULL, 0 , FALSE };

static HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DWORD dwVerInfoSize, dwVerHnd;
    int iEnd;
    LPSTR lpInfo;
    HINSTANCE hInst = NULL;
    UINT uLen;
    VS_FIXEDFILEINFO *pinfo;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        if (GetModuleFileName(hinstShlwapi, szPath, ARRAYSIZE(szPath)))
        {
            if (dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwVerHnd))
            {
                if (MemAlloc((void **)&lpInfo, dwVerInfoSize))
                {
                    if (GetFileVersionInfo(szPath, dwVerHnd, dwVerInfoSize, lpInfo))
                    {
                        if (VerQueryValue(lpInfo, "\\", (LPVOID *)&pinfo, &uLen) && 
                            uLen == sizeof(VS_FIXEDFILEINFO))
                        {
                            if (pinfo->dwProductVersionMS >= 0x00050000)
                            {
                                pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(377));
                                if (pfn != NULL)
                                    hInst = pfn(szDllName, hInstCaller, 0);
                            }
                        }
                    }
                
                    MemFree(lpInfo);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileName(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        _PathRemoveFileSpec(szPath);
        iEnd = lstrlen(szPath);
        szPath[iEnd++] = '\\';
        lstrcpyn(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibrary(szPath);
    }

    AssertSz(hInst, "Failed to LoadLibrary Lang Dll");

    return(hInst);
}

void
MLLoadResources(HINSTANCE hinstParent, LPTSTR pszLocResDll)
{
    if (g_mluiInfo.hinstLocRes == NULL)
    {
        // find out whether ML is enabled or not
#ifdef MLUI_SUPPORT
        g_mluiInfo.fMLEnabled = TRUE;
#else
        g_mluiInfo.fMLEnabled = FALSE;
#endif

        if (g_mluiInfo.fMLEnabled)
        {
            g_mluiInfo.ulRefs++;
//            g_mluiInfo.hinstLocRes = lpfnMLLoadLibrary(pszLocResDll, hinstParent, ML_CROSSCODEPAGE);
            g_mluiInfo.hinstLocRes = LoadLangDll(hinstParent, pszLocResDll);
        }
        else
        {
            g_mluiInfo.hinstLocRes = hinstParent;
        }
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    g_mluiInfo.ulRefs--;

    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent &&
        g_mluiInfo.ulRefs == 0 )
    {
        FreeLibrary(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    return LoadStringW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
//    return LoadStringWrapW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

HINSTANCE
MLGetHinst()
{
    return g_mluiInfo.hinstLocRes;
}


INT_PTR
MLDialogBoxParamWrap(HINSTANCE hInstance,
                     LPCWSTR lpTemplateName,
                     HWND hwndParent,
                     DLGPROC lpDialogFunc,
                     LPARAM dwInitParam)
{
    INT_PTR nRet;

#ifdef ML_ID_DIALOGCALLS
    {
        nRet = MLDialogBoxParam(hInstance,
                               (LPWSTR)lpTemplateName,
                               hwndParent,
                               lpDialogFunc,
                               dwInitParam);
    }
#else
    {
        nRet = DialogBoxParamWrapW(hInstance,
                              lpTemplateName,
                              hwndParent,
                              lpDialogFunc,
                              dwInitParam);
    }
#endif
    return nRet;
}


BOOL
MLEndDialogWrap(HWND hDlg, INT_PTR nResult)
{
    BOOL    fRet;

#ifdef ML_ID_DIALOGCALLS
    {
        fRet = MLEndDialog(hDlg, nResult);
    }
#else
    {
        fRet = EndDialog(hDlg, nResult);
    }
#endif
    return fRet;
}

#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\multiui.cpp ===
/*******************************************************
    MultiUI.cpp

    Code for handling multiple user interface in IE
    and friends

    Initially by Christopher Evans (cevans) 4/28/98
********************************************************/

#include "private.h"
#include "resource.h"
#include "multiui.h"
#include "multiutl.h"
#include "multiusr.h"
#include "mluisup.h"
#include "strconst.h"
#include "commctrl.h"
extern HINSTANCE g_hInst;

static const GUID GUID_NULL = { /* 00000000-0000-0000-0000-000000000000 */ 
    0x0,
    0x0,
    0x0,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
  };

static const HELPMAP g_rgCtxMapMultiUserGeneral[] = {
    {IDC_NO_HELP_1, NO_HELP},
    {IDC_NO_HELP_2, NO_HELP},
    {IDC_NO_HELP_3, NO_HELP},
    {IDC_NO_HELP_4, NO_HELP},
    {idcWarningIcon, NO_HELP},
    {idcConfirmMsg, NO_HELP},
    {idcErrorMsg, NO_HELP},
    {idcLoginInstr, NO_HELP},
    {idcWelcomeMsg, NO_HELP},
    {idcAdd, IDH_IDENTITY_ADD},
    {idcNewPwd, IDH_IDENTITY_PWORD_NEW},
    {idcPwdCaption,IDH_IDENTITY_ENTER_PWORD}, 
    {idcPwd, IDH_IDENTITY_ENTER_PWORD},
    {idcProperties, IDH_IDENTITY_PROPERTIES},
    {idcConfPwd, IDH_IDENTITY_CONFIRM_PWORD},
    {idcUserName, IDH_IDENTITY_NAME},
    {idcDefault, IDH_IDENTITY_DEFAULT},
    {idcOldPwd, IDH_IDENTITY_PWORD_OLD},
    {idcStartupCombo, IDH_IDENTITY_STARTAS},
    {idcDelete, IDH_IDENTITY_DELETE},
    {idcStaticName, IDH_IDENTITY_LIST},
    {idcUserNameList, IDH_IDENTITY_LIST},
    {idcTellMeMore, /*IDH_IDENTITY_TELLMEMORE_CONTENT */IDH_IDENTITY_TELLMEMORE},
    {idcStaticNames, IDH_IDENTITY_LIST},
    {idcStaticStartUp, IDH_IDENTITY_STARTAS},
    {idcUsePwd, IDH_IDENTITY_PROMPT_PWORD},
    {idcChgPwd, IDH_IDENTITY_CHANGE_PWORD},
    {idcConfirmPwd, IDH_MULTI_DELETE_PWORD},
    {idcManage, IDH_IDENTITY_MANAGE},
    {idcLogoff, IDH_MULTI_LOG_OFF},
    {idcCheckDefault, IDH_MULTI_MNG_IDENT_DEFAULT},
    {idcDefaultCombo, IDH_MULTI_MNG_DEFAULT_LIST},
    {0,0}};


/*
    MU_ShowErrorMessage

    Simple wrapper around resource string table based call to MessageBox
*/
void MU_ShowErrorMessage(HWND hwnd, UINT iMsgID, UINT iTitleID)
{
    TCHAR    szMsg[255], szTitle[63];

    MLLoadStringA(iMsgID, szMsg, ARRAYSIZE(szMsg));
    MLLoadStringA(iTitleID, szTitle, ARRAYSIZE(szTitle));
    MessageBox(hwnd, szMsg, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

/*
    _StripDefault

    Remove the (Default) string from the user's name, if it
    appears.  Should be called after getting a username from
    the listbox since the default user has the string (Default) 
    appended to it
*/
void _StripDefault(LPSTR psz)
{
    TCHAR   szResString[CCH_USERNAME_MAX_LENGTH], *pszStr;
    MLLoadStringA(idsDefault, szResString, CCH_USERNAME_MAX_LENGTH);
    
    pszStr = strstr(psz, szResString);
    if(pszStr)
    {
        *pszStr = 0;
    }
}

#ifdef IDENTITY_PASSWORDS

// ****************************************************************************************************
//  C   H   A   N   G   E       U   S   E   R       P   A   S   S   W   O   R   D
/*
    _ValidateChangePasswordValues

    Validate the data entered by the user.  Return true only if everything is
    legitimate, 
*/

static BOOL _ValidateChangePasswordValues(HWND   hDlg, 
                                         TCHAR*  lpszOldNewPassword)
{
    TCHAR    szOldPW[255], szPW1[255], szPW2[255];

    GetDlgItemText(hDlg,idcOldPwd,  szOldPW, ARRAYSIZE(szOldPW));
    GetDlgItemText(hDlg,idcNewPwd,  szPW1,   ARRAYSIZE(szPW1));
    GetDlgItemText(hDlg,idcConfPwd, szPW2,   ARRAYSIZE(szPW2));

    if (strcmp(lpszOldNewPassword, szOldPW) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsPwdDoesntMatch, idsPwdError);
        SetFocus(GetDlgItem(hDlg,idcOldPwd));
        SendDlgItemMessage(hDlg,idcOldPwd,EM_SETSEL,0,-1);
        return false;
    }

    if (strcmp(szPW1, szPW2) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsPwdChgNotMatch, idsPwdError);
        SetFocus(GetDlgItem(hDlg,idcNewPwd));
        SendDlgItemMessage(hDlg,idcNewPwd,EM_SETSEL,0,-1);
        return false;
    }

    strcpy(lpszOldNewPassword, szPW1);

    return true;
}


/*
    _ChangeUserPwdDlgProc

    Description: Dialog proc for handling the change user password dialog.
*/

INT_PTR CALLBACK _ChangeUserPwdDlgProc(HWND     hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static TCHAR *sOldNewPassword;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        SendMessage(GetDlgItem(hDlg, idcNewPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        SendMessage(GetDlgItem(hDlg, idcOldPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        SendMessage(GetDlgItem(hDlg,idcConfPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        sOldNewPassword = (TCHAR *)lParam;
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if (_ValidateChangePasswordValues(hDlg, sOldNewPassword))
                MLEndDialogWrap(hDlg, IDOK);
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        }
        break;

    }
    return false;
}

/*
    ChangeUserPassword

    Wrapper routine for changing the user password.  Pass in the current
    password in lpszOldNewPassword which is used to confirm the current 
    password with what the user entered.  If the user enters the old 
    password correctly and enters the new password twice correctly, 
    and clicks OK, then the new password is returned in lpszOldNewPassword
    and this function returns TRUE.  Otherwise, the value in lpszOldNewPassword
    is unchanged and it returns false.

    lpszOldNewPassword must point to a TCHAR buffer large enough to hold a password 
    (CCH_USERPASSWORD_MAX_LENGTH characters)
*/

BOOL        ChangeUserPassword(HWND hwnd, TCHAR *lpszOldNewPassword) 
{
    INT_PTR bResult;
    
    Assert(hwnd);
    Assert(lpszOldNewPassword);
    
    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddChgPwd), hwnd, _ChangeUserPwdDlgProc, (LPARAM)lpszOldNewPassword);

    //Don't actually change it here, the caller will do the right thing
    //since this may be (and is) called from another dialog with a cancel 
    //button on it

    return (bResult == IDOK);   
}


// ****************************************************************************************************
//  C   O   N   F   I   R   M       U   S   E   R       P   A   S   S   W   O   R   D

/*
    _ConfirmUserPwdDlgProc

    Description: Dialog proc for handling the confirming user password dialog.
*/  
INT_PTR CALLBACK _ConfirmUserPwdDlgProc(HWND    hDlg,
                                    UINT    iMsg, 
                                    WPARAM  wParam, 
                                    LPARAM  lParam)
{
    static LPCONFIRMPWDDIALOGINFO sConfirmPwdInfo;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);

        SendMessage(GetDlgItem(hDlg, idcConfirmPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        sConfirmPwdInfo = (LPCONFIRMPWDDIALOGINFO)lParam;
        SetDlgItemText(hDlg, idcConfirmMsg, sConfirmPwdInfo->szMsg);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            TCHAR    szPW[255];
            
            //if the password matches the provided password, then
            //everything is OK and the dialog can complete, otherwise,
            //barf an error message and keep waiting for a good password
            //or Cancel.
            GetDlgItemText(hDlg,idcConfirmPwd,  szPW, ARRAYSIZE(szPW));
            if (strcmp(szPW, sConfirmPwdInfo->szPassword) == 0)
                MLEndDialogWrap(hDlg, IDOK);
            else
            {
                MU_ShowErrorMessage(hDlg, idsPwdDoesntMatch, idsPwdError);
                SetFocus(GetDlgItem(hDlg,idcConfirmPwd));
                SendDlgItemMessage(hDlg,idcConfirmPwd,EM_SETSEL,0,-1);
            }
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        }
        break;

    }
    return false;
}

/*
    MU_ConfirmUserPassword

    Confirm that the user knows the password before it is disabled 
    in the registry.  If they enter the correct password, simply return
    true since the calling dialog box will do the right thing if the 
    user clicks cancel there.
*/

BOOL        MU_ConfirmUserPassword(HWND hwnd, TCHAR *lpszMsg, TCHAR *lpszPassword) 
{
    INT_PTR bResult;
    CONFIRMPWDDIALOGINFO    vConfirmInfo;

    Assert(hwnd);
    Assert(lpszPassword);
    Assert(lpszMsg);
    Assert(lstrlen(lpszMsg) < ARRAYSIZE(vConfirmInfo.szMsg));
    Assert(lstrlen(lpszPassword) < ARRAYSIZE(vConfirmInfo.szPassword));

    strcpy(vConfirmInfo.szMsg, lpszMsg);
    strcpy(vConfirmInfo.szPassword, lpszPassword);

    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddPasswordOff), hwnd, _ConfirmUserPwdDlgProc, (LPARAM)&vConfirmInfo);

    return (bResult == IDOK);   
}

// ****************************************************************************************************
//  E   N   T   E   R       U   S   E   R       P   A   S   S   W   O   R   D

/*
    _ValidateNewPasswordValues

    Description: Make sure that the entered values in the new password
    dialog are legit and consistant.
*/  
static BOOL _ValidateNewPasswordValues(HWND  hDlg, 
                                         TCHAR*  lpszNewPassword)
{
    TCHAR    szPW1[255], szPW2[255];

    GetDlgItemText(hDlg,idcNewPwd,  szPW1,   ARRAYSIZE(szPW1));
    GetDlgItemText(hDlg,idcConfPwd, szPW2,   ARRAYSIZE(szPW2));

    if (strcmp(szPW1, szPW2) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsPwdChgNotMatch, idsPwdError);
        SetFocus(GetDlgItem(hDlg,idcNewPwd));
        SendDlgItemMessage(hDlg,idcNewPwd,EM_SETSEL,0,-1);
        return false;
    }

    strcpy(lpszNewPassword, szPW1);

    return true;
}


/*
    _EnterUserPwdDlgProc

    Description: Dialog proc for handling the enter user password dialog.
*/
INT_PTR CALLBACK _EnterUserPwdDlgProc(HWND      hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static TCHAR *sNewPassword;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        SendMessage(GetDlgItem(hDlg, idcNewPwd),     EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        SendMessage(GetDlgItem(hDlg, idcConfPwd), EM_LIMITTEXT, CCH_USERPASSWORD_MAX_LENGTH-1, 0);
        sNewPassword = (TCHAR *)lParam;
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if (_ValidateNewPasswordValues(hDlg, sNewPassword))
                MLEndDialogWrap(hDlg, IDOK);
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        }
        break;

    }
    return false;
}

/*
    EnterUserPassword

    Wrapper routine for getting a new user password.  If the user enters the 
    password and confirms it correctly, and clicks OK, then the new password is 
    returned in lpszNewPassword and this function returns TRUE.  
    Otherwise, the value in lpszNewPassword is unchanged and it returns false.

    lpszNewPassword must point to a TCHAR buffer large enough to hold a password 
    (CCH_USERPASSWORD_MAX_LENGTH characters)
*/
BOOL        EnterUserPassword(HWND hwnd, TCHAR *lpszNewPassword) 
{
    INT_PTR bResult;
    
    Assert(hwnd);
    Assert(lpszNewPassword);
    
    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddNewPwd), hwnd, _EnterUserPwdDlgProc, (LPARAM)lpszNewPassword);

    return (bResult == IDOK);   
}

#endif //IDENTITY_PASSWORDS

// ****************************************************************************************************
//  C   O   N   F   I   R   M       D   E   L   E   T   E       U   S   E   R       D   I   A   L   O   G


/*
    ConfirmDeleteUserDlgProc

    Description: Dialog proc for handling the confirm delete user dialog.

*/

INT_PTR CALLBACK _ConfirmDeleteUserDlgProc(HWND hDlg,
                                    UINT    iMsg, 
                                    WPARAM  wParam, 
                                    LPARAM  lParam)
{

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);

        SendDlgItemMessage(hDlg, idcWarningIcon, STM_SETICON, (WPARAM)::LoadIcon(NULL, IDI_EXCLAMATION), 0);
        SetDlgItemText(hDlg, idcErrorMsg, (TCHAR *)lParam);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            MLEndDialogWrap(hDlg, LOWORD(wParam));
            return true;
        }
        break;

    }
    return false;
}

BOOL        MU_ConfirmDeleteUser(HWND hwnd, TCHAR *lpszUsername)
{
    TCHAR   szBuffer[255];    // really ought to be big enough
    TCHAR   szDisplay[255+CCH_USERNAME_MAX_LENGTH];
    TCHAR   szPassword[CCH_USERPASSWORD_MAX_LENGTH];

    // format the message with the username scattered throughout.
    MLLoadStringA(idsConfirmDeleteMsg, szBuffer, ARRAYSIZE(szBuffer));

    if (szBuffer[0])
    {
        INT_PTR bResult;

        wsprintf(szDisplay, szBuffer, lpszUsername);
        
        // Show the Confirm Delete dialog box to make sure they really want to delete the user
        bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddConfirmUserDelete), hwnd, _ConfirmDeleteUserDlgProc, (LPARAM)szDisplay);
        
#ifdef IDENTITY_PASSWORDS

        if (IDOK == bResult)
        {
            BOOL    fUsePassword;
            // check to see if this user has a password, if so, then make sure that
            // they know the password before blowing it all away.
            if (MU_GetPasswordForUsername(lpszUsername, szPassword, &fUsePassword))
            {
                if (fUsePassword)
                {
                    MLLoadStringA(idsConfirmDelPwd, szBuffer, ARRAYSIZE(szBuffer));

                    wsprintf(szDisplay, szBuffer, lpszUsername);
                    
                    if (!MU_ConfirmUserPassword(hwnd, szDisplay, szPassword))
                        bResult = IDCANCEL;
                }
            }
            else    //couldn't load the password, can't delete them either
            {
                MU_ShowErrorMessage(hwnd, idsPwdNotFound, idsPwdError);
                bResult = IDCANCEL;
            }
            
            return (IDOK == bResult);
        }
#else
        return (IDOK == bResult);
#endif //IDENTITY_PASSWORDS
    }
    
    return false;
}

// ****************************************************************************************************
//  C   H   A   N   G   E       U   S   E   R       S   E   T   T   I   N   G   S   
/*
    _ValidateChangeUserValues

    Validate the data entered by the user.  Return true only if everything is
    legit, 
*/
static BOOL _ValidateChangeUserValues(HWND          hDlg, 
                                     LPUSERINFO     lpUserInfo)
{
    TCHAR   szResString[CCH_USERNAME_MAX_LENGTH], *pszStr;
    TCHAR   szUsername[255];
    ULONG   cb;
    
    GetDlgItemText(hDlg,idcUserName, szUsername, ARRAYSIZE(szUsername));
    
    cb = lstrlen(szUsername);
    UlStripWhitespace(szUsername, false, true, &cb);    //remove trailing whitespace

    // Make sure the username wasn't all spaces
    if (!cb)
    {
        MU_ShowErrorMessage(hDlg, idsUserNameTooShort, idsNameTooShort);
        SetFocus(GetDlgItem(hDlg,idcUserName));
        SendDlgItemMessage(hDlg,idcUserName,EM_SETSEL,0,-1);
        return false;
    }

    // if the username exists, and its not the same as the account currently, then
    // it is not allowed.
    if (MU_UsernameExists(szUsername) && strcmp(szUsername, lpUserInfo->szUsername) != 0)
    {
        MU_ShowErrorMessage(hDlg, idsUserNameExists, idsUserNameInUse);
        SetFocus(GetDlgItem(hDlg,idcUserName));
        SendDlgItemMessage(hDlg,idcUserName,EM_SETSEL,0,-1);
        return false;
    }
    
    lstrcpy(lpUserInfo->szUsername, szUsername);
    lpUserInfo->fUsePassword = IsDlgButtonChecked(hDlg, idcUsePwd);
    if (!lpUserInfo->fUsePassword)
        lpUserInfo->szPassword[0] = 0;

    return true;
}


/*
    ChangeUserSettingsDlgProc

    Description: Dialog proc for handling the Change user settings dialog.
*/
INT_PTR CALLBACK _ChangeUserSettingsDlgProc(HWND        hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static LPUSERINFO sUserInfo;
    TCHAR    szMsg[255];
    TCHAR    szPassword[CCH_USERPASSWORD_MAX_LENGTH];

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        
        sUserInfo = (LPUSERINFO)lParam;
        
        MLLoadStringA((*sUserInfo->szUsername) ? idsIdentityProperties : idsNewIdentity, szMsg, ARRAYSIZE(szMsg));
        SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM)szMsg);

        SetDlgItemText(hDlg, idcUserName, sUserInfo->szUsername);
        SendMessage(GetDlgItem(hDlg, idcUserName), EM_LIMITTEXT, CCH_IDENTITY_NAME_MAX_LENGTH/2, 0);
        CheckDlgButton(hDlg, idcUsePwd, sUserInfo->fUsePassword ? BST_CHECKED : BST_UNCHECKED);
        EnableWindow(GetDlgItem(hDlg, idcChgPwd), sUserInfo->fUsePassword);

        // Don't allow zero length names by disabling OK
        if (!lstrlen(sUserInfo->szUsername))
            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            if (_ValidateChangeUserValues(hDlg, sUserInfo))
                MLEndDialogWrap(hDlg, IDOK);
            return true;

        case IDCANCEL:
            MLEndDialogWrap(hDlg, IDCANCEL);
            return true;

        case idcUserName:
            if (EN_CHANGE == HIWORD(wParam))
            {
                EnableWindow(GetDlgItem(hDlg, IDOK), SendMessage((HWND)lParam, WM_GETTEXTLENGTH, 0, 0) != 0);
                return TRUE;
            }
            break;
        
#ifdef IDENTITY_PASSWORDS
        case idcTellMeMore:
//            WinHelp ((HWND)GetDlgItem(hDlg, idcTellMeMore),
//                        c_szCtxHelpFile,
//                        HELP_WM_HELP,
//                        (DWORD_PTR)(LPVOID)g_rgCtxMapMultiUserGeneral);
            WinHelp(hDlg, c_szCtxHelpFile, HELP_CONTEXT, IDH_IDENTITY_TELLMEMORE_CONTENT);
            return true;

        case idcUsePwd:
            // if they are turning off the password, they need to confirm it first.
            if (!IsDlgButtonChecked(hDlg, idcUsePwd))
            {               
                strcpy(szPassword, sUserInfo->szPassword);
                MLLoadStringA(idsConfirmDisablePwd, szMsg, ARRAYSIZE(szMsg));
                if (!MU_ConfirmUserPassword(hDlg,szMsg, szPassword))
                    CheckDlgButton(hDlg, idcUsePwd, BST_CHECKED);
            }
            else
            {
                // if they are turning it on, they should set the password.
                if (EnterUserPassword(hDlg, szPassword))
                {
                    sUserInfo->fUsePassword = true;
                    strcpy(sUserInfo->szPassword, szPassword);
                }
                else
                {
                    CheckDlgButton(hDlg, idcUsePwd, BST_UNCHECKED);
                }
            }
            EnableWindow(GetDlgItem(hDlg, idcChgPwd), IsDlgButtonChecked(hDlg, idcUsePwd));
            return true;
        
        case idcChgPwd:
            if(sUserInfo->fUsePassword || (0 != *sUserInfo->szPassword))
            {
                strcpy(szPassword, sUserInfo->szPassword);
                
                if (ChangeUserPassword(hDlg, szPassword))
                    strcpy(sUserInfo->szPassword, szPassword);
            }
            return true;
#endif //IDENTITY_PASSWORDS
        }
        break;

    }
    return false;
}

/*
    MU_UserProperties

    Allow the user the change their username or password.
*/
BOOL        MU_UserProperties(HWND hwnd, LPUSERINFO lpUserInfo) 
{
    INT_PTR                 fResult;
    USERINFO                nuInfo;
    TCHAR                   szOldUsername[CCH_IDENTITY_NAME_MAX_LENGTH+1];
    USERINFO                uiCurrent;
    LPARAM                  lpNotify = IIC_CURRENT_IDENTITY_CHANGED;
    INITCOMMONCONTROLSEX    icex;

    Assert(hwnd);
    Assert(lpUserInfo);
    
    // get the current info so we know who to change later.
    MU_GetUserInfo(NULL, &nuInfo);    

    lstrcpy(szOldUsername, lpUserInfo->szUsername);

    // make sure ICC_NATIVEFNTCTL_CLASS is inited
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    fResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddUserProperties), hwnd, _ChangeUserSettingsDlgProc, (LPARAM)lpUserInfo);

    if (IDOK == fResult)
    {
        if (GUID_NULL == lpUserInfo->uidUserID)
            _ClaimNextUserId(&lpUserInfo->uidUserID);

        MU_SetUserInfo(lpUserInfo);

        // if its not the current identity, then just broadcast that an identity changed
        if (MU_GetUserInfo(NULL, &uiCurrent) && (lpUserInfo->uidUserID != uiCurrent.uidUserID))
            lpNotify = IIC_IDENTITY_CHANGED;

        // if the name changd, tell other apps 
        // Unless we're doing an add (szOldUsername == "")
        // which already has its own notification
        if (*szOldUsername != 0 && lstrcmp(szOldUsername, lpUserInfo->szUsername) != 0)
            PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, lpNotify);

    }
    
    return (IDOK == fResult);   
}



// ****************************************************************************************************
//  L   O   G   I   N       S   C   R   E   E   N
/*
    _ValidateLoginValues

    Validate the data entered by the user.  Return true only if everything is
    legit, 
*/
static BOOL _ValidateLoginValues(HWND  hDlg, 
                                    TCHAR*   lpszOldNewPassword)
{
    TCHAR    szUsername[255];
    TCHAR    szPW[255], szRealPW[CCH_USERPASSWORD_MAX_LENGTH];
    LRESULT dSelItem;
    BOOL    rResult = false;

    dSelItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
    if (LB_ERR != dSelItem)
    {
        if (SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXTLEN, dSelItem, 0) < ARRAYSIZE(szUsername))
        {
            SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dSelItem, (LPARAM)szUsername);

#ifdef IDENTITY_PASSWORDS
            BOOL fUsePassword;
            if (MU_GetPasswordForUsername(szUsername, szRealPW, &fUsePassword))
            {
                if (fUsePassword)
                {
                    GetDlgItemText(hDlg,idcPwd,szPW, ARRAYSIZE(szPW));

                    if (strcmp(szPW, szRealPW) == 0)
                    {
                        strcpy(lpszOldNewPassword, szUsername);
                        rResult = true;
                    }
                    else
                    {
                        MU_ShowErrorMessage(hDlg, idsPwdDoesntMatch, idsPwdError);
                        SetFocus(GetDlgItem(hDlg,idcPwd));
                        SendDlgItemMessage(hDlg,idcPwd,EM_SETSEL,0,-1);
                        return false;
                    }
                }
                else    // if there is no password, then it does match up.
                {
                    strcpy(lpszOldNewPassword, szUsername);
                    rResult = true;
                }
            }
            else    //can't load identity password, do not allow access
            {
                MU_ShowErrorMessage(hDlg, idsPwdNotFound, idsPwdError);
                return false;
            }
#else  //IDENTITY_PASSWORDS
            strcpy(lpszOldNewPassword, szUsername);
            rResult = true;
#endif //IDENTITY_PASSWORDS
        }
    }
    return rResult;
}

static void _LoginEnableDisablePwdField(HWND hDlg)
{
#ifdef IDENTITY_PASSWORDS
    TCHAR    szUsername[255], szRealPW[255];
    BOOL    bEnabled = false;
#endif //IDENTITY_PASSWORDS
    LRESULT dSelItem;

    dSelItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
#ifdef IDENTITY_PASSWORDS
    if (LB_ERR != dSelItem)
    {
        if (SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXTLEN, dSelItem, 0) < ARRAYSIZE(szUsername))
        {
            SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dSelItem, (LPARAM)szUsername);

            BOOL fUsePassword;
            if (MU_GetPasswordForUsername(szUsername, szRealPW, &fUsePassword) && fUsePassword)
            {
                bEnabled = true;
            }
        } 
    }
    EnableWindow(GetDlgItem(hDlg,idcPwd),bEnabled);
    EnableWindow(GetDlgItem(hDlg,idcPwdCaption),bEnabled);
#endif //IDENTITY_PASSWORDS

    EnableWindow(GetDlgItem(hDlg,IDOK),(dSelItem != -1));
}

typedef struct 
{
    TCHAR   *pszUsername;
    DWORD    dwFlags;
} LOGIN_PARAMS;

/*
    _LoginDlgProc

    Description: Dialog proc for handling the OE Login dialog.
*/
INT_PTR CALLBACK _LoginDlgProc(HWND       hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    static TCHAR        *sResultUsername;
    static LOGIN_PARAMS *plpParams;
    TCHAR                szMsg[1024], szRes[1024];
    USERINFO            nuInfo;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        
        plpParams = (LOGIN_PARAMS *)lParam;
        sResultUsername = plpParams->pszUsername;

        MLLoadStringA(!!(plpParams->dwFlags & UIL_FORCE_UI) ? idsSwitchIdentities : idsIdentityLogin, szMsg, ARRAYSIZE(szMsg));
        SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM)szMsg);
        _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
        
        if (MU_GetUserInfo(NULL, &nuInfo))
        {
            MLLoadStringA(idsLoginWithCurrent, szRes, ARRAYSIZE(szRes));
            wsprintf(szMsg, szRes, nuInfo.szUsername);
            SetDlgItemText(hDlg, idcWelcomeMsg, szMsg);

            MLLoadStringA(idsCurrIdentityInstr, szMsg, ARRAYSIZE(szMsg));
            SetDlgItemText(hDlg, idcLoginInstr, szMsg);
        }
        else
        {
            MLLoadStringA(idsLoginNoCurrent, szMsg, ARRAYSIZE(szMsg));
            SetDlgItemText(hDlg, idcWelcomeMsg, szMsg);
            MLLoadStringA(idsNoIdentityInstr, szMsg, ARRAYSIZE(szMsg));
            SetDlgItemText(hDlg, idcLoginInstr, szMsg);
        }


        if (sResultUsername[0] == 0)
            strcpy(sResultUsername, nuInfo.szUsername);

        if (sResultUsername[0])
        {
            LRESULT dFoundItem;
            
            dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)sResultUsername);
            if (LB_ERR != dFoundItem)
            {
                SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
            }
        }
        else
            SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, 0, 0);

        
        _LoginEnableDisablePwdField(hDlg);
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
            case LBN_DBLCLK:
                wParam = IDOK;
                break;
            case LBN_SELCHANGE:
                _LoginEnableDisablePwdField(hDlg);
                break;
        }

        switch(LOWORD(wParam))
        {
            case IDOK:
                if (_ValidateLoginValues(hDlg, sResultUsername))
                    MLEndDialogWrap(hDlg, IDOK);
                return true;

            case IDCANCEL:
                MLEndDialogWrap(hDlg, IDCANCEL);
                return true;

            case idcLogoff:
                MLLoadStringA(idsLogoff, sResultUsername, CCH_USERNAME_MAX_LENGTH);
                MLEndDialogWrap(hDlg, IDOK);
                return true;
                
            case idcManage:
                {
                    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1] = "";

                    MU_ManageUsers(hDlg, szUsername, 0);
                    _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                    SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, 0, 0);
                    _LoginEnableDisablePwdField(hDlg);

                    if (*szUsername)
                    {
                        lstrcpy(sResultUsername, szUsername);
                        MLEndDialogWrap(hDlg, IDOK);
                    }
                }
                return true;
        
        }
        break;

    }
    return false;
}


/*
    MU_Login

    Wrapper routine for logging in to OE.  Asks the user to choose a username
    and, if necessary, enter the password for that user.  The user can also
    create an account at this point.  

    lpszUsername should contain the name of the person who should be the default
    selection in the list.  If the name is empty ("") then it will look up the
    default from the registry.

    Returns the username that was selected in lpszUsername.  Returns true
    if that username is valid.
*/
BOOL        MU_Login(HWND hwnd, DWORD dwFlags, TCHAR *lpszUsername) 
{
    INT_PTR bResult;
    CStringList *csList;
    INITCOMMONCONTROLSEX    icex;

    Assert(hwnd);
    Assert(lpszUsername);
    
    // make sure ICC_NATIVEFNTCTL_CLASS is inited
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    csList = MU_GetUsernameList();

    // if there is only one username and they do not have a password, just return it.
    if (csList && csList->GetLength() == 1 && !(dwFlags & UIL_FORCE_UI))
    {
        TCHAR   *pszUsername;
        TCHAR   szPassword[255];
        BOOL    fUsePassword;
        pszUsername = csList->GetString(0);

        if(MU_GetPasswordForUsername(pszUsername, szPassword, &fUsePassword) && !fUsePassword)
        {
            lstrcpy(lpszUsername, pszUsername);
            delete csList;
            return TRUE;
        }
    }

    LOGIN_PARAMS lpParams;

    lpParams.dwFlags = dwFlags;
    lpParams.pszUsername = lpszUsername;
    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddLogin), hwnd, _LoginDlgProc, (LPARAM)&lpParams);

    if (csList)
        delete csList;

    return (IDOK == bResult);   
}

void _ManagerUpdateButtons(HWND hDlg)
{
    LRESULT     dFoundItem;
    USERINFO    rUserInfo;
    GUID        uidDefaultId;

    // make sure that the delete button is only available if the
    // current user is not selected.
    dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
    if (dFoundItem != -1)
    {
        SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
    
        MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
        MU_GetCurrentUserID(&uidDefaultId);

        // if there is no current user, don't allow deletion of the default user.
        if (GUID_NULL == uidDefaultId)
            MU_GetDefaultUserID(&uidDefaultId);
    }

    EnableWindow(GetDlgItem(hDlg, idcDelete), dFoundItem != -1 && uidDefaultId != rUserInfo.uidUserID);
}

typedef struct 
{
    TCHAR   *pszUsername;
    DWORD    dwFlags;
} MANAGE_PARAMS;

/*
    _ManagerDlgProc

    Description: Dialog proc for handling the identity manager dialog.
*/
INT_PTR CALLBACK _ManagerDlgProc(HWND       hDlg,
                                   UINT     iMsg, 
                                   WPARAM   wParam, 
                                   LPARAM   lParam)
{
    USERINFO        rUserInfo;
    static MANAGE_PARAMS  *pmpParams;
    static TCHAR    sResultUsername[MAX_PATH] = "";
    static DWORD    sdwFlags = 0;
    LRESULT         dFoundItem;
    ULONG           uidUserId;
    HRESULT         hr;
    TCHAR           szRes[256];
    USERINFO        nuInfo;
    DWORD           dwIndex;
    GUID            uidDefault;
    switch (iMsg)
    {
    case WM_INITDIALOG:
        Assert(lParam);
        _ResetRememberedLoginOption();
        
        pmpParams = (MANAGE_PARAMS*)lParam;
        sdwFlags = pmpParams->dwFlags;

        _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));

        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));

        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

        dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));

        CheckDlgButton(hDlg, idcCheckDefault, dwIndex != ASK_BEFORE_LOGIN);
        EnableWindow(GetDlgItem(hDlg, idcStartupCombo), dwIndex != ASK_BEFORE_LOGIN);
        if (dwIndex != ASK_BEFORE_LOGIN)
            SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL, dwIndex, 0);
        else
            SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL, 0, 0);
        
        MU_GetUserInfo(NULL, &nuInfo);
        strcpy(szRes, nuInfo.szUsername);

        if (szRes[0])
        {
            dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)szRes);
            if (LB_ERR != dFoundItem)
            {
                SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
            }
        }

        SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);
        
        _ManagerUpdateButtons(hDlg);
        if (!!(sdwFlags & UIMI_CREATE_NEW_IDENTITY))
        {
            ShowWindow(hDlg, SW_SHOW);
            PostMessage(hDlg, WM_COMMAND, idcAdd, 0);
        }
        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
            case LBN_DBLCLK:
                wParam = idcProperties;
                break;
            case LBN_SELCHANGE:
                _ManagerUpdateButtons(hDlg);
                break;
        }

        switch(LOWORD(wParam))
        {
            case IDCANCEL:
            case idcClose:
            case IDOK:
                dFoundItem = SendDlgItemMessage(hDlg, idcStartupCombo, CB_GETCURSEL, 0, 0);
                if (CB_ERR == dFoundItem)
                    dFoundItem = 0;

                if (IsDlgButtonChecked(hDlg, idcCheckDefault))
                    MU_SetLoginOption(GetDlgItem(hDlg,idcStartupCombo), dFoundItem);
                else
                    MU_SetLoginOption(GetDlgItem(hDlg,idcStartupCombo), ASK_BEFORE_LOGIN);

                dFoundItem = SendDlgItemMessage(hDlg, idcDefaultCombo, CB_GETCURSEL, 0, 0);
                if (CB_ERR == dFoundItem)
                    dFoundItem = 0;

                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                MU_MakeDefaultUser(&rUserInfo.uidUserID);
                MLEndDialogWrap(hDlg, IDOK);
                return true;

            case idcAdd:
                ZeroMemory(&rUserInfo, sizeof(USERINFO));

                if (MU_UserProperties(hDlg,&rUserInfo))
                {
                    TCHAR   szMsg[ARRAYSIZE(szRes) + CCH_IDENTITY_NAME_MAX_LENGTH];
                    
                    // rebuild the username list and select the newly added one
                    _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                    strcpy(sResultUsername, rUserInfo.szUsername);
                    _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

                    dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));
                    SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL,(dwIndex == ASK_BEFORE_LOGIN ? 0 : dwIndex) , 0);
                    SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);

                    dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)sResultUsername);
                    if (LB_ERR != dFoundItem)
                    {
                        SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
                    }
                    PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, IIC_IDENTITY_ADDED);

                    if (pmpParams->pszUsername)
                    {
                        MLLoadStringA(idsLoginAsUser, szRes, ARRAYSIZE(szRes));
                        wsprintf(szMsg, szRes, rUserInfo.szUsername);

                        MLLoadStringA(idsUserAdded, szRes, ARRAYSIZE(szRes));
                        if (IDYES == MessageBox(hDlg, szMsg, szRes, MB_YESNO))
                        {
                            lstrcpy(pmpParams->pszUsername, rUserInfo.szUsername);
                            PostMessage(hDlg, WM_COMMAND, idcClose, 0);
                        }
                    }
                }
                _ManagerUpdateButtons(hDlg);
                return true;

            case idcDefaultCombo:
                dFoundItem = SendDlgItemMessage(hDlg, idcDefaultCombo, CB_GETCURSEL, 0, 0);
                if (CB_ERR == dFoundItem)
                    dFoundItem = 0;

                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                MU_MakeDefaultUser(&rUserInfo.uidUserID);
                _ManagerUpdateButtons(hDlg);
                break;

            case idcCheckDefault:
                EnableWindow(GetDlgItem(hDlg, idcStartupCombo), IsDlgButtonChecked(hDlg, idcCheckDefault));
                return true;

            case idcDelete:
                dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 

                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                if (MU_ConfirmDeleteUser(hDlg, rUserInfo.szUsername))
                {
                    MU_DeleteUser(&rUserInfo.uidUserID);
                    _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                    _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));
                    _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

                    dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));
                    SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL,(dwIndex == ASK_BEFORE_LOGIN ? 0 : dwIndex) , 0);
                    SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);
                    _ManagerUpdateButtons(hDlg);
                }
                return true;

            case idcProperties:
                dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 

                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

#ifdef IDENTITY_PASSWORDS
                if (SUCCEEDED(hr) && MU_GetUserInfo(&rUserInfo.uidUserID, &rUserInfo) && MU_CanEditIdentity(hDlg, &rUserInfo.uidUserID))
#else
                if (SUCCEEDED(hr) && MU_GetUserInfo(&rUserInfo.uidUserID, &rUserInfo))
#endif //IDENTITY_PASSWORDS

                {
                    if (MU_UserProperties(hDlg,&rUserInfo))
                    {
                        // rebuild the username list and select the newly added one
                        _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                        strcpy(sResultUsername, rUserInfo.szUsername);
                        _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));
                        _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcDefaultCombo), GetDlgItem(hDlg,idcUserNameList));

                        dwIndex = MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo));
                        SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL,(dwIndex == ASK_BEFORE_LOGIN ? 0 : dwIndex) , 0);
                        SendDlgItemMessage(hDlg, idcDefaultCombo, CB_SETCURSEL, MU_GetDefaultOptionIndex(GetDlgItem(hDlg, idcDefaultCombo)), 0);

                        dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_FINDSTRING, 0, (LPARAM)sResultUsername);
                        if (LB_ERR != dFoundItem)
                        {
                            SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
                        }
                    }
                }
                _ManagerUpdateButtons(hDlg);
                break;
/*          
            case idcDefault:
                dFoundItem = SendDlgItemMessage(hDlg, idcUserNameList, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_GETTEXT, dFoundItem, (LPARAM)rUserInfo.szUsername); 
//                _StripDefault(rUserInfo.szUsername);

                hr = MU_UsernameToUserId(rUserInfo.szUsername, &rUserInfo.uidUserID);
                Assert(SUCCEEDED(hr));

                MU_MakeDefaultUser(&rUserInfo.uidUserID);
                _RememberLoginOption(GetDlgItem(hDlg,idcStartupCombo));
                _FillListBoxWithUsernames(GetDlgItem(hDlg,idcUserNameList));
                _FillComboBoxWithUsernames(GetDlgItem(hDlg,idcStartupCombo), GetDlgItem(hDlg,idcUserNameList));

                SendDlgItemMessage(hDlg, idcStartupCombo, CB_SETCURSEL, MU_GetLoginOptionIndex(GetDlgItem(hDlg,idcStartupCombo)), 0);
                SendDlgItemMessage(hDlg, idcUserNameList, LB_SETCURSEL, dFoundItem, 0);
                _ManagerUpdateButtons(hDlg);
                break;
*/
        }
        break;

    }
    return false;
}

/*
    MU_ManageUsers
*/
BOOL        MU_ManageUsers(HWND hwnd, TCHAR *lpszSwitchtoUsername, DWORD dwFlags) 
{
    INT_PTR         bResult;
    MANAGE_PARAMS   rParams;
    INITCOMMONCONTROLSEX    icex;

    Assert(hwnd);
    Assert(lpszUsername);
    
    // make sure ICC_NATIVEFNTCTL_CLASS is inited
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    rParams.dwFlags = dwFlags;
    rParams.pszUsername = lpszSwitchtoUsername;

    bResult = MLDialogBoxParamWrap(MLGetHinst(), MAKEINTRESOURCEW(iddManager), hwnd, _ManagerDlgProc, (LPARAM)&rParams);

    return (IDOK == bResult);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\multiusr.cpp ===
/*******************************************************
    MultiUsr.cpp

    Code for handling multiple user functionality in IE
    and friends

    Initially by Christopher Evans (cevans) 4/28/98
********************************************************/

#define DONT_WANT_SHELLDEBUG
#include "private.h"
#include "resource.h"
#include "multiusr.h"
#include <assert.h>
#include "multiutl.h"
#include "strconst.h"
#include "Shlwapi.h"
#include "multiui.h"
#include <shlobj.h>
#include "mluisup.h"
#include <lmwksta.h>

TCHAR g_szRegRoot[MAX_PATH] = "";
extern HINSTANCE g_hInst;
static void _CreateIdentitiesFolder();


// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path 

// this is here to avoid a dependancy on shlwapi.dll
#define CH_WHACK TEXT('\\')

STDAPI_(LPTSTR)
_PathAddBackslash(
    LPTSTR lpszPath)
{
    LPTSTR lpszEnd;

    // perf: avoid lstrlen call for guys who pass in ptr to end
    // of buffer (or rather, EOB - 1).
    // note that such callers need to check for overflow themselves.
    int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

    // try to keep us from tromping over MAX_PATH in size.
    // if we find these cases, return NULL.  Note: We need to
    // check those places that call us to handle their GP fault
    // if they try to use the NULL!
    if (ichPath >= (MAX_PATH - 1))
    {
        Assert(FALSE);      // Let the caller know!        
        return(NULL);
    }

    lpszEnd = lpszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*lpszPath)
        return lpszEnd;

    /* Get the end of the source directory
    */
    switch(*CharPrev(lpszPath, lpszEnd)) {
    case CH_WHACK:
        break;

    default:
        *lpszEnd++ = CH_WHACK;
        *lpszEnd = TEXT('\0');
    }
    return lpszEnd;
}


STDAPI_(DWORD)
_SHGetValueA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey,          OPTIONAL
    IN  LPCSTR  pszValue,           OPTIONAL
    OUT LPDWORD pdwType,            OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData)            OPTIONAL
{
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_QUERY_VALUE, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        dwRet = RegQueryValueEx(hkeyNew, pszValue, NULL, pdwType, (LPBYTE)pvData, pcbData);
        RegCloseKey(hkeyNew);
    }
    else if (pcbData)
        *pcbData = 0;

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
_DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                _DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}

// ****************************************************************************************************
//  C   S   T   R   I   N   G   L   I   S   T       C   L   A   S   S
//
//  A really basic string list class.  Actually, its a string array class, but you don't need to know
//  that.  It could do so much more, but for now, it only maintains an array of C strings.
//


CStringList::CStringList()
{
    m_count = 0;
    m_ptrCount = 0;
    m_strings = NULL;
}

/*
    CStringList::~CStringList

    Clean up any memory that was allocated in the CStringList object
*/
CStringList::~CStringList()
{
    if (m_strings)
    {
        for (int i = 0; i < m_count; i++)
        {
            if (m_strings[i])
            {
                MemFree(m_strings[i]);
                m_strings[i] = NULL;
            }
        }
        MemFree(m_strings);
        m_strings = NULL;
        m_count = 0;
    }
}


/*
    CStringList::AddString

    Add a string to the end of the string list.
*/
void    CStringList::AddString(TCHAR* lpszInString)
{
    // make more room for pointers, if necessary
    if (m_ptrCount == m_count)
    {
        m_ptrCount += 5;
        if (!MemRealloc((void **)&m_strings, sizeof(TCHAR *) * m_ptrCount))
        {
            m_ptrCount -= 5;
            Assert(false);
            return;
        }

        // initialize the new strings to nil
        for (int i = m_count; i < m_ptrCount; i++)
            m_strings[i] = NULL;

    }
    
    //now put the string in the next location
    int iNewIndex = m_count++;

    if(MemAlloc((void **)&m_strings[iNewIndex], sizeof(TCHAR) * lstrlen(lpszInString)+1))
    {
        lstrcpy(m_strings[iNewIndex], lpszInString);
    }
    else
    {
        // couldn't allocate space for the string.  Don't count that spot as filled
        m_count--;
    }
}

/*
    CStringList::RemoveString
    
    Remove a string at zero based index iIndex 
*/

void    CStringList::RemoveString(int   iIndex)
{
    int     iCopySize;

    iCopySize = ((m_count - iIndex) - 1) * 4;

    // free the memory for the string
    if (m_strings[iIndex])
    {
        MemFree(m_strings[iIndex]);
        m_strings[iIndex] = NULL;
    }

    // move the other strings down
    if (iCopySize)
    {
        memmove(&(m_strings[iIndex]), &(m_strings[iIndex+1]), iCopySize);
    }

    // null out the last item in the list and decrement the counter.
    m_strings[--m_count] = NULL;
}

/*
    CStringList::GetString
    
    Return the pointer to the string at zero based index iIndex.

    Return the string at the given index.  Note that the TCHAR pointer
    is still owned by the string list and should not be deleted.
*/

TCHAR    *CStringList::GetString(int iIndex)
{
    if (iIndex < m_count && iIndex >= 0)
        return m_strings[iIndex];
    else
        return NULL;
}


int __cdecl _CSL_Compare(const void *p1, const void *p2)
{
    TCHAR *psz1, *psz2;

    psz1 = *((TCHAR **)p1);
    psz2 = *((TCHAR **)p2);

    return lstrcmpi(psz1, psz2);
}


/*
    CStringList::Sort
    
    Sort the strings in the list
*/

void    CStringList::Sort()
{
    qsort(m_strings, m_count, sizeof(TCHAR *), _CSL_Compare);
}


/*
    MU_Init

    Initialize the memory allocator and make sure that there is
    at least one user in the registry.
*/
static BOOL g_inited = FALSE;
EXTERN_C void    MU_Init()
{
    CStringList* pList;

    if (!g_inited)
    {
        pList = MU_GetUsernameList();

        if (!pList || pList->GetLength() == 0)
        {
            _MakeDefaultFirstUser();
        }
        if (pList)
            delete pList;
        g_inited = TRUE;
    }
}


/*
    MU_GetUsernameList
    
    Build a CStringList with all of the names of the users 
    stored in HKLM
*/
#define MAXKEYNAME          256

CStringList*    MU_GetUsernameList(void)
{
    CStringList*    vList = NULL;
    HKEY    hSourceSubKey;
    DWORD   dwEnumIndex = 0, dwStatus, dwSize, dwType;
    int     cb;
    TCHAR    szKeyNameBuffer[MAXKEYNAME];
    DWORD dwIdentityOrdinal = 1;

    vList = new CStringList;
    Assert(vList);
    
    if (!vList)
        goto exit;
        
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) != ERROR_SUCCESS)
    {
        AssertSz(FALSE, "Couldn't open user profiles root Key");
        goto exit;
    }

    dwSize = sizeof(dwIdentityOrdinal);
    RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

    while (TRUE) 
    {
        DWORD   dwOrdinal;
        HKEY    hkUserKey;
        if (RegEnumKey(hSourceSubKey, dwEnumIndex++, szKeyNameBuffer,MAXKEYNAME)!=  ERROR_SUCCESS)
            break;

        cb = lstrlen(szKeyNameBuffer);
            
        if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szKeyNameBuffer);
            dwStatus = RegQueryValueEx(hkUserKey, c_szUsername, NULL, &dwType, (LPBYTE)&szKeyNameBuffer, &dwSize);
                
            Assert(ERROR_SUCCESS == dwStatus);
            Assert(*szKeyNameBuffer != 0);
            //filter names that begin with _ to hide things like "_Outlook News"
            if (ERROR_SUCCESS == dwStatus && *szKeyNameBuffer != '_')
                vList->AddString(szKeyNameBuffer);

            dwSize = sizeof(dwOrdinal);
            dwStatus = RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize);
            if (dwStatus==ERROR_SUCCESS)
            {
                if (dwOrdinal>=dwIdentityOrdinal)
                {
                    dwIdentityOrdinal = dwOrdinal+1;
                    AssertSz(FALSE, "MaxOrdinal is smaller than this identity. Why?");
                }
            }
            else
            {
                dwStatus = RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                dwIdentityOrdinal++;
            }
            Assert(ERROR_SUCCESS == dwStatus);
            
            RegCloseKey(hkUserKey); 
        }
        else
            AssertSz(FALSE, "Couldn't open user's Key");
    }

    dwSize = sizeof(dwIdentityOrdinal);
    if (RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)!=ERROR_SUCCESS)
    {
        AssertSz(FALSE, "Couldn't set the identity ordinal");
    }

    RegCloseKey(hSourceSubKey);

exit:
    return vList;
}


/*
    MU_UsernameToUserId

    Given a username, find its user id and return it.  Returns E_FAIL if it can't 
    find the given username.
*/

HRESULT   MU_UsernameToUserId(TCHAR *lpszUsername, GUID *puidID)
{
    HKEY    hSourceSubKey;
    ULONG   ulEnumIndex = 0;
    DWORD   dwStatus, dwSize, dwType;
    TCHAR    szKeyNameBuffer[MAXKEYNAME];
    BOOL    fFound = FALSE;
    TCHAR    szUid[255];

    ZeroMemory(puidID, sizeof(GUID));

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        while (!fFound) 
        {
            HKEY    hkUserKey;

            if (RegEnumKey(hSourceSubKey, ulEnumIndex++, szKeyNameBuffer,MAXKEYNAME)
                !=  ERROR_SUCCESS)
                break;
            
            if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(szKeyNameBuffer);
                dwStatus = RegQueryValueEx(hkUserKey, c_szUsername, NULL, &dwType, (LPBYTE)&szKeyNameBuffer, &dwSize);
                
                if (ERROR_SUCCESS == dwStatus && lstrcmpi(lpszUsername, szKeyNameBuffer) == 0)
                {
                    dwSize = sizeof(szUid);
                    dwStatus = RegQueryValueEx(hkUserKey, c_szUserID, NULL, &dwType, (LPBYTE)&szUid, &dwSize);
                    fFound = (dwStatus == ERROR_SUCCESS);

                    if (fFound)
                        fFound = SUCCEEDED(GUIDFromAString(szUid, puidID));
                }
                RegCloseKey(hkUserKey); 
            }
        }
        RegCloseKey(hSourceSubKey);
    }
    

    return (fFound ? S_OK : E_FAIL);
}

/*
    MU_GetPasswordForUsername

    Get the password for the provided user and return it in szOutPassword.  Return in 
    pfUsePassword if password is enabled and false if it is disabled.

    Function returns true if the password data could be found, false otherwise
*/

BOOL  MU_GetPasswordForUsername(TCHAR *lpszInUsername, TCHAR *szOutPassword, BOOL *pfUsePassword)
{
#ifdef IDENTITY_PASSWORDS
    TCHAR           szPath[MAX_PATH];
    TCHAR           szPassword[255] = "";
    HKEY            hDestinationSubKey;
    DWORD           dwSize, dwStatus, dwType;
    DWORD           dwPWEnabled = 0;
    GUID            uidUserID;
    HRESULT         hr;
    PASSWORD_STORE  pwStore;

    hr = MU_UsernameToUserId(lpszInUsername, &uidUserID);
    Assert(SUCCEEDED(hr));
    
    if (uidUserID == GUID_NULL)
    {
        *pfUsePassword = FALSE;
        return TRUE;
    }
    
    if (SUCCEEDED(hr = ReadIdentityPassword(&uidUserID, &pwStore)))
    {
        lstrcpy(szOutPassword, pwStore.szPassword);
        *pfUsePassword = pwStore.fUsePassword;
        return TRUE;
    }
    else
    {
        BOOL fFoundPassword = FALSE;
        
        //build the user level key. 
        MU_GetRegRootForUserID(&uidUserID, szPath);
    
        if (RegCreateKey(HKEY_CURRENT_USER, szPath, &hDestinationSubKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwPWEnabled);
            dwStatus = RegQueryValueEx(hDestinationSubKey, c_szUsePassword, NULL, &dwType, (LPBYTE)&dwPWEnabled, &dwSize);
        
            if (ERROR_SUCCESS == dwStatus && 0 != dwPWEnabled)
            {
                dwSize = sizeof(szPassword);
                dwStatus = RegQueryValueEx(hDestinationSubKey, c_szPassword, NULL, &dwType, (LPBYTE)&szPassword, &dwSize);
        
                if (ERROR_SUCCESS == dwStatus)
                {
                    ULONG   cbSize;

                    fFoundPassword = TRUE;
                    cbSize = dwSize;
                    if (cbSize > 1)
                    {
                        DecodeUserPassword(szPassword, &cbSize);
                        strcpy(szOutPassword, szPassword);  
                    }
                    else
                    {
                        *szOutPassword = 0;
                    }
                }
            }
        
            RegCloseKey(hDestinationSubKey);
        }

        // Herein lies the pull.  We can't count on being able to access any
        // given pstore from any given profile on Win9x.  If you log on with
        // a blank password, or hit escape (not much difference to a user)
        // you will have a different pstore.  If we store our passwords in the
        // registry, they can be whacked pretty simply.  If we can't find the 
        // password, we will disable it for now and say there is none.  It 
        // seems that most people don't put passwords on identities now 
        // anyway, though this will change. 
        if (!fFoundPassword)
        {
            fFoundPassword = TRUE;
            dwPWEnabled = 0;
        }
        // Here ends the pull
        
        *pfUsePassword = (dwPWEnabled != 0);
        return fFoundPassword;
    }
#else
    *pfUsePassword = FALSE;
    return TRUE;
#endif //IDENTITY_PASSWORDS

}

/*
    _FillListBoxWithUsernames

    Fill a listbox with the names of the users,  Adds (Default) 
    to the default user.
*/
BOOL _FillListBoxWithUsernames(HWND hListbox)
{
    CStringList *lpCStringList;
    GUID        uidDefault;
    GUID        uidUser;

    lpCStringList = MU_GetUsernameList();

    if (lpCStringList)
    {    
        MU_GetDefaultUserID(&uidDefault);

        SendMessage(hListbox, LB_RESETCONTENT, 0, 0);
        lpCStringList->Sort();

        if (lpCStringList)
        {
            for(int i = 0; i < lpCStringList->GetLength(); i++)
            {
                if (lpCStringList->GetString(i))
                {
                    SendMessage(hListbox, LB_ADDSTRING, 0, (LPARAM)lpCStringList->GetString(i));
                }
            }
            delete lpCStringList;
            return true;
        }
    }
    return false;
}

BOOL _FillComboBoxWithUsernames(HWND hCombobox, HWND hListbox)
{
    TCHAR szRes[128];
    DWORD_PTR cIndex, dwCount = SendMessage(hListbox, LB_GETCOUNT, 0, 0);

    SendMessage(hCombobox, CB_RESETCONTENT, 0, 0);

    for (cIndex = 0; cIndex < dwCount; cIndex++)
    {
        SendMessage(hListbox, LB_GETTEXT, cIndex, (LPARAM)szRes);
        SendMessage(hCombobox, CB_ADDSTRING, 0, (LPARAM)szRes);
    }
    return true;
}

/*
    MU_UsernameExists
    
    Does the given name already exist as a username?
*/

BOOL        MU_UsernameExists(TCHAR*    lpszUsername)
{
    GUID uidID;
    
    return SUCCEEDED(MU_UsernameToUserId(lpszUsername, &uidID));

}

/*
    MU_GetUserInfo
    
    Fill in the user info structure with current values
*/

BOOL    MU_GetUserInfo(GUID *puidUserID, LPUSERINFO lpUserInfo)
{
    TCHAR           szPWBuffer[255];
    TCHAR           szRegPath[MAX_PATH];
    HKEY            hKey;
    BOOL            bResult = false;
    LONG            lValue;
    DWORD           dwStatus, dwType, dwSize;
    GUID            uidUser;
    TCHAR           szUid[255];
    HRESULT         hr;
    PASSWORD_STORE  pwStore;

    lpUserInfo->fPasswordValid = FALSE;
    
    if( puidUserID == NULL)
    {
        MU_GetCurrentUserID(&uidUser);
        if (uidUser == GUID_NULL)
            return FALSE;
    }
    else
        uidUser = *puidUserID;

    MU_GetRegRootForUserID(&uidUser, szRegPath);
    
    if (RegOpenKey(HKEY_CURRENT_USER, szRegPath, &hKey) == ERROR_SUCCESS)
    {
        *lpUserInfo->szPassword = 0;
        lpUserInfo->fUsePassword = false;
        ZeroMemory(&lpUserInfo->uidUserID, sizeof(GUID));

        dwSize = sizeof(lpUserInfo->szUsername);
        if ((dwStatus = RegQueryValueEx(hKey, c_szUsername, NULL, &dwType, (LPBYTE)lpUserInfo->szUsername, &dwSize)) == ERROR_SUCCESS &&
                (0 != *lpUserInfo->szUsername))
        {
            //we have the username, that is the only required part.  The others are optional.
            bResult = true;
            
#ifdef IDENTITY_PASSWORDS
            lpUserInfo->fPasswordValid = FALSE;
            if (SUCCEEDED(hr = ReadIdentityPassword(&uidUser, &pwStore)))
            {
                lstrcpy(lpUserInfo->szPassword, pwStore.szPassword);
                lpUserInfo->fUsePassword = pwStore.fUsePassword;
                lpUserInfo->fPasswordValid = TRUE;
            }
            else
            {
                dwSize = sizeof(lValue);
                if ((dwStatus = RegQueryValueEx(hKey, c_szUsePassword, NULL, &dwType, (LPBYTE)&lValue, &dwSize)) == ERROR_SUCCESS)
                {
                    lpUserInfo->fUsePassword = (lValue != 0);
                }

                dwSize = sizeof(szPWBuffer);
                dwStatus = RegQueryValueEx(hKey, c_szPassword, NULL, &dwType, (LPBYTE)szPWBuffer, &dwSize);

                ULONG   cbSize;

                lpUserInfo->fPasswordValid = (ERROR_SUCCESS == dwStatus);

                // Herein lies the pull (Volume 2).  We can't count on being able to access any
                // given pstore from any given profile on Win9x.  If you log on with
                // a blank password, or hit escape (not much difference to a user)
                // you will have a different pstore.  If we store our passwords in the
                // registry, they can be whacked pretty simply.  If we can't find the 
                // password, we will disable it for now and say there is none.  It 
                // seems that most people don't put passwords on identities now 
                // anyway, though this will change.  
                if (!lpUserInfo->fPasswordValid)
                {
                    lpUserInfo->fPasswordValid = TRUE;
                    lpUserInfo->fUsePassword = FALSE;
                }
                // Here ends the pull

                cbSize = dwSize;
                if (ERROR_SUCCESS == dwStatus && cbSize > 1)
                {
                    DecodeUserPassword(szPWBuffer, &cbSize);
                    strcpy(lpUserInfo->szPassword, szPWBuffer);
                }
                else
                    *lpUserInfo->szPassword = 0;
            }
#endif 
            dwSize = sizeof(szUid);
            if ((dwStatus = RegQueryValueEx(hKey, c_szUserID, NULL, &dwType, (LPBYTE)&szUid, &dwSize)) == ERROR_SUCCESS)
            {
                hr = GUIDFromAString(szUid, &lpUserInfo->uidUserID);
                Assert(hr);
            }

        }
        RegCloseKey(hKey);
    }
        
    return bResult;
}


/*
    MU_SetUserInfo
    
    Save the user info structure with the user values
*/
BOOL        MU_SetUserInfo(LPUSERINFO lpUserInfo)
{
    DWORD           dwType, dwSize, dwValue, dwStatus;
    HKEY            hkCurrUser;
    TCHAR           szPath[MAX_PATH];
    WCHAR           szwPath[MAX_PATH];
    TCHAR           szUid[255];
    BOOL            fNewIdentity = FALSE;
    PASSWORD_STORE  pwStore;
    HRESULT         hr;

    MU_GetRegRootForUserID(&lpUserInfo->uidUserID, szPath);
    
    Assert(pszRegPath && *pszRegPath);
    Assert(lpUserInfo->uidUserID != GUID_NULL);
    
    if ((dwStatus = RegCreateKey(HKEY_CURRENT_USER, szPath, &hkCurrUser)) == ERROR_SUCCESS)
    {
        ULONG   cbSize;
        TCHAR   szBuffer[255];

        // write out the correct values
        dwType = REG_SZ;
        dwSize = lstrlen(lpUserInfo->szUsername) + 1;
        RegSetValueEx(hkCurrUser, c_szUsername, 0, dwType, (LPBYTE)lpUserInfo->szUsername, dwSize);

        dwSize = sizeof(DWORD);
        if ((dwStatus = RegQueryValueEx(hkCurrUser, c_szDirName, NULL, &dwType, (LPBYTE)&dwValue, &dwSize)) != ERROR_SUCCESS)
        {
            dwValue = MU_GenerateDirectoryNameForIdentity(&lpUserInfo->uidUserID);
        
            dwType = REG_DWORD;
            dwSize = sizeof(dwValue);
            RegSetValueEx(hkCurrUser, c_szDirName, 0, dwType, (LPBYTE)&dwValue, dwSize);
            fNewIdentity = TRUE;
        }

#ifdef IDENTITY_PASSWORDS
        lstrcpy(pwStore.szPassword, lpUserInfo->szPassword);
        pwStore.fUsePassword = lpUserInfo->fUsePassword;

        if (FAILED(hr = WriteIdentityPassword(&lpUserInfo->uidUserID, &pwStore)))
        {
            dwType = REG_BINARY ;
            cbSize = strlen(lpUserInfo->szPassword) + 1;
            lstrcpy(szBuffer, lpUserInfo->szPassword);
            EncodeUserPassword(szBuffer, &cbSize);
            dwSize = cbSize;
            RegSetValueEx(hkCurrUser, c_szPassword, 0, dwType, (LPBYTE)szBuffer, dwSize);
        
            dwType = REG_DWORD;
            dwValue = (lpUserInfo->fUsePassword ? 1 : 0);
            dwSize = sizeof(dwValue);
            RegSetValueEx(hkCurrUser, c_szUsePassword, 0, dwType, (LPBYTE)&dwValue, dwSize);
        }
        else
        {
            //don't keep the registry values if we could save it to the pstore.
            RegDeleteValue(hkCurrUser, c_szPassword);
            RegDeleteValue(hkCurrUser, c_szUsePassword);
        }
#endif //IDENTITY_PASSWORDS

        Assert(lpUserInfo->uidUserID != GUID_NULL);
        AStringFromGUID(&lpUserInfo->uidUserID,  szUid, ARRAYSIZE(szUid));

        dwType = REG_SZ;
        dwSize = lstrlen(szUid) + 1;
        RegSetValueEx(hkCurrUser, c_szUserID, 0, dwType, (LPBYTE)&szUid, dwSize);

        RegCloseKey(hkCurrUser);

        if (fNewIdentity)
        {
            if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_ROAMING_FOLDER, szwPath, MAX_PATH)))
            {
                if (!CreateDirectoryWrapW(szwPath,NULL))
                {
                    _CreateIdentitiesFolder();
                    CreateDirectoryWrapW(szwPath,NULL);
                }
            }
            
            if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_NON_ROAMING_FOLDER, szwPath, MAX_PATH)))
            {
                if (!CreateDirectoryWrapW(szwPath,NULL))
                {
                    _CreateIdentitiesFolder();
                    CreateDirectoryWrapW(szwPath,NULL);
                }
            }
        }
        return TRUE;
    }
    return FALSE;
}

/*
    MU_SwitchToUser

    Currently, this just saves the last user's info.
*/
HRESULT  MU_SwitchToUser(TCHAR *lpszUsername)
{
    GUID    uidUserID;
    TCHAR    szUid[255];
    HRESULT hr;

    Assert(lpszUsername);
    
    if (*lpszUsername == 0) //  null string means null guid
    {
        uidUserID = GUID_NULL;
    }
    else
    {
        hr = MU_UsernameToUserId(lpszUsername, &uidUserID);
        if (FAILED(hr))
            return hr;
    }


    AStringFromGUID(&uidUserID,  szUid, ARRAYSIZE(szUid));
    Assert(uidUserID != GUID_NULL || (*lpszUsername == 0));

    wsprintf(g_szRegRoot, "%.100s\\%.40s", c_szRegRoot, szUid);
    
    // remember who we last switched to
    HKEY    hkey;
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwType, dwSize;

        dwType = REG_SZ;
        dwSize = lstrlen(lpszUsername) + 1;
        RegSetValueEx(hkey, c_szLastUserName, 0, dwType, (LPBYTE)lpszUsername, dwSize);

        dwType = REG_SZ;
        dwSize = lstrlen(szUid) + 1;
        RegSetValueEx(hkey, c_szLastUserID, 0, dwType, (LPBYTE)szUid, dwSize);

        RegCloseKey(hkey);
    }

    return S_OK;
}

/*
    MU_SwitchToLastUser

    Makes the last user current, if there is no
    last user, it switches to the first user it can
    find. If there are no users, it creates a 
    user called "Main User"
*/
void MU_SwitchToLastUser()
{
    HKEY    hkey;
    TCHAR   szUserUid[255];
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH + 1];
    BOOL    fSwitched = FALSE;
    GUID    uidUserId;

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwType, dwStatus, dwSize;
        dwSize = sizeof(szUserUid);
        dwStatus = RegQueryValueEx(hkey, c_szLastUserID, NULL, &dwType, (LPBYTE)szUserUid, &dwSize);
        
        RegCloseKey(hkey);

        if (ERROR_SUCCESS == dwStatus && SUCCEEDED(GUIDFromAString(szUserUid, &uidUserId)) && 
                    SUCCEEDED(MU_UserIdToUsername(&uidUserId, szUsername, CCH_USERNAME_MAX_LENGTH)))
        {
            MU_SwitchToUser(szUsername);
            fSwitched = true;
        }
    }

    if (!fSwitched)
    {
        LPSTR   pszName;

        CStringList*    pList = MU_GetUsernameList();
        
        if (pList)
        {
            DWORD   dwIndex, dwLen = pList->GetLength();

            // find the first non hidden user and switch to them
            for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
            {
                pszName = pList->GetString(dwIndex);
                
                if (pszName && *pszName  && *pszName != '_')
                {
                    MU_SwitchToUser(pszName);
                    fSwitched = TRUE;
                    break;
                }
            }
            delete pList;
        }
    }

    if (!fSwitched)
    {
        _MakeDefaultFirstUser();
        CStringList*    pList = MU_GetUsernameList();
        
        if (pList && pList->GetLength() > 0)
            MU_SwitchToUser(pList->GetString(0));
        
        if (pList)
            delete pList; 
    }
}

/*
    _CreateIdentitiesFolder

    Create the parent folder of all of the identities folders.
*/

static void _CreateIdentitiesFolder()
{
    HRESULT     hr;
    TCHAR       szAppDir[MAX_PATH], szSubDir[MAX_PATH], *psz;
    DWORD       dw, type;

    hr = E_FAIL;

    dw = MAX_PATH;


    if (ERROR_SUCCESS == _SHGetValueA(HKEY_CURRENT_USER, c_szRegFolders, c_szValueAppData, &type, (LPBYTE)szAppDir, &dw))
    {
        lstrcpy(szSubDir, c_szIdentitiesFolderName);
        psz = _PathAddBackslash(szSubDir);
        if (psz)
        {
            psz = _PathAddBackslash(szAppDir);
            if (psz)
            {
                lstrcpy(psz, szSubDir);

                psz = _PathAddBackslash(szAppDir);
        
                CreateDirectory(szAppDir, NULL);
            }
        }
    }
}


/*
    MU_GetCurrentUserDirectoryRoot

    Return the path to the top of the current user's root directory.
    This is the directory where the mail store should be located.
    It is in a subfolder the App Data folder.

    lpszUserRoot is a pointer to a character buffer that is cch chars
    in size.
*/
HRESULT MU_GetUserDirectoryRoot(GUID *uidUserID, DWORD dwFlags, WCHAR   *lpszwUserRoot, int cch)
{
    HRESULT         hr;
    WCHAR           szwSubDir[MAX_PATH], *pszw, szwUid[255]; 
    int             cb;
    DWORD           type, dwDirId;
    LPITEMIDLIST    pidl = NULL;
    IShellFolder   *psf = NULL;
    STRRET          str;
    IMalloc         *pMalloc = NULL;
    BOOL            fNeedHelp = FALSE;

    Assert(lpszUserRoot != NULL);
    Assert(uidUserID);
    Assert(cch >= MAX_PATH);
    Assert((dwFlags & (GIF_NON_ROAMING_FOLDER | GIF_ROAMING_FOLDER)));

    hr = MU_GetDirectoryIdForIdentity(uidUserID, &dwDirId);
    StringFromGUID2(*uidUserID, szwUid, ARRAYSIZE(szwUid));

    if (FAILED(hr))
        return hr;

    hr = SHGetMalloc(&pMalloc);
    Assert(pMalloc);
    if (!pMalloc)
        return E_OUTOFMEMORY;

    hr = E_FAIL;

    if (!!(dwFlags & GIF_NON_ROAMING_FOLDER))
    {
        hr = SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_LOCAL_APPDATA, &pidl);
        
        if (FAILED(hr) || pidl == 0)
            hr = SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_APPDATA, &pidl);

        if (FAILED(hr))
            fNeedHelp = TRUE;

    }
    else if (!!(dwFlags & GIF_ROAMING_FOLDER))
    {
        hr = SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_APPDATA, &pidl);

        if (FAILED(hr))
            fNeedHelp = TRUE;
    }
    else
        hr = E_INVALIDARG;

    *lpszwUserRoot = 0;
    if (SUCCEEDED(hr) && pidl)
    {
        if (FAILED(hr = SHGetDesktopFolder(&psf)))
            goto exit;

        if (FAILED(hr = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
            goto exit;

        switch(str.uType)
        {
            case STRRET_WSTR:
                lstrcpyW(lpszwUserRoot, str.pOleStr);
                pMalloc->Free(str.pOleStr);
                break;

            case STRRET_OFFSET:
                MultiByteToWideChar(CP_ACP, 0, (LPSTR)pidl+str.uOffset, -1, lpszwUserRoot, cch-11);
                break;

            case STRRET_CSTR:
                MultiByteToWideChar(CP_ACP, 0, (LPSTR)str.cStr, -1, lpszwUserRoot, cch-11);
                break;

            default:
                Assert(FALSE);
                goto exit;
        }

        pszw = PathAddBackslashW(lpszwUserRoot);

        if (lstrlenW(lpszwUserRoot) < cch - 10)
        {
            StrCatW(pszw, L"Identities\\");
            StrCatW(pszw, szwUid);
            StrCatW(pszw, L"\\");
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *lpszwUserRoot = 0;
        }
    }
    else if (fNeedHelp)
    {
        // $$$Review: NEIL QFE
        // SHGetSpecialFolderLocation(GetDesktopWindow(), CSIDL_APPDATA, &pidl) fails on non-SI OSR2.
        HKEY hkeySrc;
        DWORD cb;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                                          0, KEY_QUERY_VALUE, &hkeySrc))
        {
            // -1 for the backslash we may add
            cb = cch - 1;
            if (ERROR_SUCCESS == RegQueryValueExWrapW(hkeySrc, L"AppData", 0, NULL, (LPBYTE)lpszwUserRoot, &cb))
            {
                pszw = PathAddBackslashW(lpszwUserRoot);

                if (lstrlenW(lpszwUserRoot) < cch - 10)
                {
                    StrCatW(pszw, L"Identities\\");
                    StrCatW(pszw, szwUid);
                    StrCatW(pszw, L"\\");
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    *lpszwUserRoot = 0;
                }
            }

            RegCloseKey(hkeySrc);
        }
    } 
exit:
    Assert(lstrlenW(lpszwUserRoot) > 0);
    SafeRelease(psf);
    pMalloc->Free(pidl);
    SafeRelease(pMalloc);

    return hr;
}


/*
    _ClaimNextUserId

    Get the next available user id.  Currently this means starting 
    with the CURRENT_USER GUID and changing the first DWORD of it
    until it is unique.  
*/
HRESULT   _ClaimNextUserId(GUID *puidId)
{
    ULONG   ulValue = 1;
    DWORD   dwType, dwSize, dwStatus;
    HKEY    hkeyProfiles;
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];
    GUID    uid;
    FILETIME    ft;

    if (FAILED(CoCreateGuid(&uid)))
    {
        uid = UID_GIBC_CURRENT_USER;
        GetSystemTimeAsFileTime(&ft);
        uid.Data1 = ft.dwLowDateTime;

        //make sure it hasn't been used
        while (MU_UserIdToUsername(&uid, szUsername, CCH_USERNAME_MAX_LENGTH))
            uid.Data1 ++;
    }
    
    *puidId = uid;

    return S_OK;
}



BOOL MU_GetCurrentUserID(GUID *puidUserID)
{
    BOOL    fFound = FALSE;
    HKEY    hkey;
    GUID    uidUserId;
    TCHAR   szUid[255];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwSize;

        dwSize = 255;
        fFound = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szLastUserID, 0, NULL, (LPBYTE)szUid, &dwSize));

        if (fFound)
            fFound = SUCCEEDED(GUIDFromAString(szUid, puidUserID));

        if (fFound && *puidUserID == GUID_NULL)
            fFound = false;

        RegCloseKey(hkey);
    }

#ifdef DEBUG
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];

    Assert(MU_UserIdToUsername(puidUserID, szUsername, CCH_USERNAME_MAX_LENGTH));
#endif

    return fFound;
}

/*
    MU_UserIdToUsername

    Return the user name for the user whose user id is passed in.  Returns
    whether or not the user was found.
*/
BOOL MU_UserIdToUsername(GUID *puidUserID, TCHAR *lpszUsername, ULONG cch)
{
    HKEY    hkey;
    TCHAR   szPath[MAX_PATH];
    BOOL    fFound = FALSE;

    Assert(lpszUsername);
    lpszUsername[0] = 0;

    MU_GetRegRootForUserID(puidUserID, szPath);    
    Assert(*szPath);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szPath, 0, KEY_QUERY_VALUE, &hkey))
    {
        fFound = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szUsername, 0, NULL, (LPBYTE)lpszUsername, &cch));
        RegCloseKey(hkey);
    }

    return fFound;
}

/*
    MU_CountUsers

    Returns the number of users currently configured.
*/
ULONG  MU_CountUsers(void)
{
    CStringList *psList;
    ULONG       ulCount = 0;

    psList = MU_GetUsernameList();

    if (psList)
    {
        ulCount = psList->GetLength();
        delete psList;
    }

    return ulCount;
}

/*
    MU_GetRegRootForUserid

    Get the reg root path for a given user id.
*/
HRESULT     MU_GetRegRootForUserID(GUID *puidUserID, LPSTR pszPath)
{
    TCHAR szUid[255];

    Assert(pszPath);
    Assert(puidUserID);

    AStringFromGUID(puidUserID,  szUid, ARRAYSIZE(szUid));
    wsprintf(pszPath, "%.100s\\%.40s", c_szRegRoot, szUid);

    return S_OK;
}

/*
    MU_GetDefaultUserID

    Get the user id for the user who is currently marked as the default user.
    Returns true if the proper user was found, false if not.
*/
BOOL MU_GetDefaultUserID(GUID *puidUserID)
{
    BOOL    fFound = FALSE;
    HKEY    hkey;
    TCHAR    szUid[255];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwSize;

        dwSize = sizeof(szUid);
        fFound = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDefaultUserID, 0, NULL, (LPBYTE)szUid, &dwSize));

        if (fFound)
            fFound = SUCCEEDED(GUIDFromAString(szUid, puidUserID));

        RegCloseKey(hkey);
    }

#ifdef DEBUG
    TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];

    Assert(MU_UserIdToUsername(ulUserID, szUsername, CCH_USERNAME_MAX_LENGTH));
#endif

    return fFound;
}

/*
    MU_MakeDefaultUser

    Set the user referenced by id ulUserID to be the default user.
    The default user is referenced by certain applications which
    can only deal with one user. MS Phone is a good example.

*/
HRESULT MU_MakeDefaultUser(GUID *puidUserID)
{
    HRESULT hr = E_FAIL;
    TCHAR   szUid[255];
    // make sure the user exists and get their name to put in the 
    // Default Username reg key
    
    if (*puidUserID==GUID_NULL)
    {
        // We don't have a current user. So we'll have to figure out a new default user.
        LPSTR   pszName;
        CStringList*    pList = MU_GetUsernameList();
        
        if (pList)
        {
            DWORD   dwIndex, dwLen = pList->GetLength();

            // find the first non hidden user and switch to them
            for (dwIndex = 0; dwIndex < dwLen; dwIndex++)
            {
                pszName = pList->GetString(dwIndex);
                
                if (pszName && *pszName  && *pszName != '_')
                {
                    break;
                }
            }
            if (dwIndex==dwLen)
            {
                // Or, just create one
                delete pList;
                _MakeDefaultFirstUser();
                return S_OK;
            }
            MU_SwitchToUser(pszName);
            GUID    guid;    
            hr = MU_UsernameToUserId(pszName, &guid);
            if (SUCCEEDED(hr))
            {
                AStringFromGUID(&guid,  szUid, ARRAYSIZE(szUid));
            }
            delete pList;
        }
    }
    else
    {
        TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH+1];
        AStringFromGUID(puidUserID,  szUid, ARRAYSIZE(szUid));
        if (MU_UserIdToUsername(puidUserID, szUsername, CCH_USERNAME_MAX_LENGTH))
            hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {        
        HKEY    hkey;
        if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
        {
            DWORD   dwType, dwSize;
            LONG    lError;

            dwType = REG_SZ;
            dwSize = lstrlen(szUid) + 1;
            lError = RegSetValueEx(hkey, c_szDefaultUserID, 0, dwType, (LPBYTE)szUid, dwSize);

            if (lError)
            {
                hr = E_FAIL;
                goto error;
            }

            hr = S_OK;

error:
            RegCloseKey(hkey);
            
        }
    }

    return hr;
}

/*
    MU_DeleteUser

    Remove a user from the registry.  This does not delete
    anything in the user's folder, but it does blow away
    their reg settings.
*/
HRESULT MU_DeleteUser(GUID *puidUserID)
{
    GUID   uidDefault, uidCurrent;
    TCHAR   szPath[MAX_PATH];

    MU_GetCurrentUserID(&uidCurrent);
    MU_GetDefaultUserID(&uidDefault);

    // Can't delete the current user
    if (*puidUserID == uidCurrent)
        return E_FAIL;
    
    // Delete the registry settings
    MU_GetRegRootForUserID(puidUserID, szPath);
    _DeleteKeyRecursively(HKEY_CURRENT_USER, szPath);

    // If we had a default user, we'll have to find a new one now
    if (*puidUserID == uidDefault)
        MU_MakeDefaultUser(&uidCurrent);

    // don't delete the directory since the user may need 
    // data out of it.
    PostMessage(HWND_BROADCAST, WM_IDENTITY_INFO_CHANGED, 0, IIC_IDENTITY_DELETED);

    return S_OK;
}


/*
    MU_CreateUser

    Create a user with the user info passed in.  This includes 
    creating their spot in the registry and their directory in the
    identities folder.
*/

HRESULT MU_CreateUser(LPUSERINFO   lpUserInfo)
{
    TCHAR           szPath[MAX_PATH], szBuffer[MAX_PATH], szUid[255];
    WCHAR           szwPath[MAX_PATH];
    HKEY            hkey;
    HRESULT         hr = S_OK;
    DWORD           dwType, dwSize, cbSize, dwValue;
    PASSWORD_STORE  pwStore;

    MU_GetRegRootForUserID(&lpUserInfo->uidUserID, szPath);
    
    Assert(*szPath && *szAcctPath);
 
    AStringFromGUID(&lpUserInfo->uidUserID,  szUid, ARRAYSIZE(szUid));
    Assert(lpUserInfo->uidUserID != GUID_NULL);

    if (RegCreateKey(HKEY_CURRENT_USER, szPath, &hkey) == ERROR_SUCCESS)
    {
        // write out the correct values
        dwType = REG_SZ;
        dwSize = lstrlen(lpUserInfo->szUsername) + 1;
        RegSetValueEx(hkey, c_szUsername, 0, dwType, (LPBYTE)lpUserInfo->szUsername, dwSize);

#ifdef IDENTITY_PASSWORDS
        lstrcpy(pwStore.szPassword, lpUserInfo->szPassword);
        pwStore.fUsePassword = lpUserInfo->fUsePassword;
        if (FAILED(hr = WriteIdentityPassword(&lpUserInfo->uidUserID, &pwStore)))
        {
            dwType = REG_BINARY ;
            cbSize = strlen(lpUserInfo->szPassword) + 1;
            lstrcpy(szBuffer, lpUserInfo->szPassword);
            EncodeUserPassword(szBuffer, &cbSize);
            dwSize = cbSize;
            RegSetValueEx(hkey, c_szPassword, 0, dwType, (LPBYTE)szBuffer, dwSize);
        
            dwType = REG_DWORD;
            dwValue = (lpUserInfo->fUsePassword ? 1 : 0);
            dwSize = sizeof(dwValue);
            RegSetValueEx(hkey, c_szUsePassword, 0, dwType, (LPBYTE)&dwValue, dwSize);
        }
#endif //IDENTITY_PASSWORDS
        dwType = REG_SZ;
        dwSize = lstrlen(szUid) + 1;
        RegSetValueEx(hkey, c_szUserID, 0, dwType, (LPBYTE)&szUid, dwSize);
    
        RegCloseKey(hkey);

        if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_ROAMING_FOLDER, szwPath, MAX_PATH)))
            if (!CreateDirectoryWrapW(szwPath,NULL))
            {
                _CreateIdentitiesFolder();
                CreateDirectoryWrapW(szwPath,NULL);
            }

        if (SUCCEEDED(MU_GetUserDirectoryRoot(&lpUserInfo->uidUserID, GIF_NON_ROAMING_FOLDER, szwPath, MAX_PATH)))
            if (!CreateDirectoryWrapW(szwPath,NULL))
            {
                _CreateIdentitiesFolder();
                CreateDirectoryWrapW(szwPath,NULL);
            }
    }
    else
        hr = E_FAIL;

    return hr;
}

/*
    MU_GetRegRoot

    Returns a pointer to a string containing the location 
    in HKEY_CURRENT_USER for the current user.
*/
LPCTSTR     MU_GetRegRoot()
{
    if (*g_szRegRoot)
        return g_szRegRoot;
    else
    {
        TCHAR   szUsername[CCH_USERNAME_MAX_LENGTH + 1];

        if (MU_Login(NULL, 0, szUsername))
        {
            GUID uidUserId;
            TCHAR szUid[255];
            
            MU_UsernameToUserId(szUsername, &uidUserId);

            AStringFromGUID(&uidUserId,  szUid, ARRAYSIZE(szUid));
            wsprintf(g_szRegRoot, "%.100s\\%.40s", c_szRegRoot, szUid);

            return g_szRegRoot;
        }
        else
        {
            Assert(FALSE);
        }
    }
    return NULL;
}


void _MakeDefaultFirstUser()
{
    USERINFO    nuInfo;
    TCHAR        szUid[255];

    MLLoadStringA(idsMainUser, nuInfo.szUsername, CCH_USERNAME_MAX_LENGTH);
    if (nuInfo.szUsername[0] == 0)
    {
        lstrcpy(nuInfo.szUsername, TEXT("Main Identity"));
    }
    *nuInfo.szPassword = 0;
    nuInfo.fUsePassword = false;
    nuInfo.fPasswordValid = true;
    _ClaimNextUserId(&nuInfo.uidUserID);

    MU_CreateUser(&nuInfo);
    MU_MakeDefaultUser(&nuInfo.uidUserID);
    MU_SwitchToUser(nuInfo.szUsername);

    AStringFromGUID(&nuInfo.uidUserID,  szUid, ARRAYSIZE(szUid));
    wsprintf(g_szRegRoot, "%.100s\\%.40s", c_szRegRoot, szUid);
}

void FixMissingIdentityNames()
{
    HKEY    hSourceSubKey;
    ULONG   ulEnumIndex = 0;
    DWORD   dwStatus, dwSize, dwType, dwValue;
    BOOL    fFound = FALSE;
    TCHAR   szKeyNameBuffer[MAX_PATH];
	TCHAR	szUsername[CCH_USERNAME_MAX_LENGTH];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        while (!fFound) 
        {
            HKEY    hkUserKey;

            if (RegEnumKey(hSourceSubKey, ulEnumIndex++, szKeyNameBuffer,MAXKEYNAME)
                !=  ERROR_SUCCESS)
                break;
            
            if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(szUsername);
                dwStatus = RegQueryValueEx(hkUserKey, c_szUsername, NULL, &dwType, (LPBYTE)szUsername, &dwSize);
                
                if (ERROR_SUCCESS != dwStatus || 0 == szUsername[0])
                {
					lstrcpy(szUsername, "Main Identity");
					dwStatus = RegSetValueEx(hkUserKey, c_szUsername, 0, REG_SZ, (LPBYTE)szUsername, lstrlen(szUsername)+1);
                }
                RegCloseKey(hkUserKey); 
            }
        }
        RegCloseKey(hSourceSubKey);
    }
}

typedef DWORD (STDAPICALLTYPE *PNetWkstaUserGetInfo)
    (LPWSTR reserved, DWORD level, LPBYTE *bufptr);


#if 0
/*
    _DomainControllerPresent

    Identities are disabled when the machine they are running on is part of a domain, unless 
    there is a policy to explicitly allow them.  This function checks to see if the machine
    is joined to a domain.
*/
BOOL _DomainControllerPresent()
{
    static BOOL fInDomain = FALSE;
    static BOOL fValid = FALSE;
    HINSTANCE  hInst;
    PNetWkstaUserGetInfo pNetWkstaUserGetInfo;
    _WKSTA_USER_INFO_1  *pwui1;

    if (!fValid)
    {
        fValid = TRUE;
        hInst = LoadLibrary(TEXT("NETAPI32.DLL"));

        if (hInst)
        {
            pNetWkstaUserGetInfo = (PNetWkstaUserGetInfo)GetProcAddress(hInst, TEXT("NetWkstaUserGetInfo"));

            if (pNetWkstaUserGetInfo && (pNetWkstaUserGetInfo(NULL, 1, (LPBYTE*)&pwui1) == NOERROR))
            {
                if (pwui1->wkui1_logon_domain && pwui1->wkui1_logon_server && lstrcmpW(pwui1->wkui1_logon_server, pwui1->wkui1_logon_domain) != 0)
                {
                    fInDomain = TRUE;
                }
            }
            FreeLibrary(hInst);
        }
    }
    return fInDomain;
}
#endif

/*
    MU_IdentitiesDisabled

    Returns if identities is disabled due to a policy 
    or whatever.
*/
BOOL MU_IdentitiesDisabled()
{
#ifndef _WIN64
    TCHAR   szPolicyPath[] = "Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Identities";
    HKEY    hkey;
    DWORD   dwValue, dwSize;
    BOOL    fLockedDown = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, szPolicyPath, &hkey) == ERROR_SUCCESS)
    { 
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
            fLockedDown = TRUE;

        RegCloseKey(hkey);
    }

    if (!fLockedDown && RegOpenKey(HKEY_CURRENT_USER, szPolicyPath, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
            fLockedDown = TRUE;

        RegCloseKey(hkey);
    }

#ifdef DISABIDENT
    if (!fLockedDown && RegOpenKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
            fLockedDown = TRUE;

        RegCloseKey(hkey);
    }
#endif //DISABIDENT
#if 0
    // turned off for now, pending determination of whether we even want to
    // have this policy
    if (!fLockedDown && _DomainControllerPresent())
    {
        fLockedDown = TRUE;

        if (RegOpenKey(HKEY_LOCAL_MACHINE, szPolicyPath, &hkey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szEnableDCPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
                fLockedDown = FALSE;

            RegCloseKey(hkey);
        }

        if (fLockedDown && RegOpenKey(HKEY_CURRENT_USER, szPolicyPath, &hkey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szEnableDCPolicyKey, 0, NULL, (LPBYTE)&dwValue, &dwSize) && 1 == dwValue)
                fLockedDown = FALSE;

            RegCloseKey(hkey);
        }
    }
#endif

    return fLockedDown;
#else // _WIN64
	return(TRUE);
#endif // _WIN64
}

static GUID    g_uidLoginOption;
static BOOLEAN g_uidLoginOptionSet;

void  _ResetRememberedLoginOption(void)
{
    g_uidLoginOption = GUID_NULL;
    g_uidLoginOptionSet = FALSE;
}

void  _RememberLoginOption(HWND hwndCombo)
{
    LRESULT dFoundItem;
    TCHAR   szUsername[CCH_IDENTITY_NAME_MAX_LENGTH * 2];
    GUID    uidUser;

    *szUsername = 0;

    g_uidLoginOptionSet = TRUE;

    dFoundItem = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);

    SendMessage(hwndCombo, CB_GETLBTEXT, dFoundItem, (LPARAM)szUsername);
    
    if (FAILED(MU_UsernameToUserId(szUsername, &uidUser)))
        g_uidLoginOption = GUID_NULL;
    else
        g_uidLoginOption = uidUser;
}

DWORD MU_GetDefaultOptionIndex(HWND hwndCombo)
{
    GUID        uidStart, uidDefault;
    USERINFO    uiDefault;
    DWORD       dwResult = 0;

    if (MU_GetDefaultUserID(&uidDefault))
    {
        MU_GetUserInfo(&uidDefault, &uiDefault);

        if (uiDefault.szUsername[0])
        {
            dwResult = (DWORD)SendMessage(hwndCombo, CB_FINDSTRING, 0, (LPARAM)uiDefault.szUsername);
        }
    }
    return dwResult;
}

DWORD MU_GetLoginOptionIndex(HWND hwndCombo)
{
    GUID        uidStart, uidDefault;
    USERINFO    uiLogin;
    DWORD       dwResult = ASK_BEFORE_LOGIN;

    if (GUID_NULL == g_uidLoginOption)
    {
        if (g_uidLoginOptionSet)
            goto exit;

        MU_GetLoginOption(&uidStart);
    }
    else
        uidStart = g_uidLoginOption;
    
    if (uidStart == GUID_NULL)
        goto exit;

    if(!MU_GetUserInfo(&uidStart, &uiLogin))
        goto exit;

    dwResult = (DWORD)SendMessage(hwndCombo, CB_FINDSTRING, 0, (LPARAM)uiLogin.szUsername);
exit:
    return dwResult;
}
/*
    MU_GetLoginOption

    return the user's choice for what should happen when there is no current 
    user
*/

void MU_GetLoginOption(GUID *puidStartAs)
{
    HKEY    hkey;
    DWORD   dwSize;
    TCHAR   szUid[255];
    GUID    uidUser;

    ZeroMemory(puidStartAs, sizeof(GUID));
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szUid);
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szLoginAs, 0, NULL, (LPBYTE)szUid, &dwSize))
            MU_GetDefaultUserID(puidStartAs);
        else
            GUIDFromAString(szUid, puidStartAs);

        RegCloseKey(hkey);
    }
}

/*
    MU_SetLoginOption

    return the user's choice for what should happen when there is no current 
    user
*/

BOOL MU_SetLoginOption(HWND hwndCombo,  LRESULT dOption)
{
    HKEY    hkey;
    BOOL    fResult = FALSE;
    TCHAR   szUsername[CCH_IDENTITY_NAME_MAX_LENGTH * 2];
    TCHAR   szUid[255];
    GUID    uidUser;


    SendMessage(hwndCombo, CB_GETLBTEXT, dOption, (LPARAM)szUsername);
    
    if (dOption == (LRESULT)ASK_BEFORE_LOGIN || FAILED(MU_UsernameToUserId(szUsername, &uidUser)))
    {
        ZeroMemory(&uidUser, sizeof(uidUser));
    }
    AStringFromGUID(&uidUser,  szUid, sizeof(szUid));
    
    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hkey) == ERROR_SUCCESS)
    {
        fResult = (ERROR_SUCCESS == RegSetValueEx(hkey, c_szLoginAs, 0, REG_SZ, (LPBYTE)szUid, lstrlen(szUid)+1));

        RegCloseKey(hkey);
    }

    return TRUE;
}


/*
    MU_CanEditIdentity

    Is the current identity allowed to edit the indicated identity's settings?
*/
BOOL MU_CanEditIdentity(HWND hwndParent, GUID *puidIdentityId)
{
#ifndef IDENTITY_PASSWORDS
    return TRUE;
#else
    USERINFO        uiCurrent, uiQuery;
    TCHAR           szBuffer[255];    // really ought to be big enough
    TCHAR           szString[255+CCH_USERNAME_MAX_LENGTH];
    BOOL            fResult = FALSE;
    PASSWORD_STORE  pwStore;

    ZeroMemory(&uiQuery, sizeof(USERINFO));

    if (MU_GetUserInfo(puidIdentityId, &uiQuery))
    {
        if (!uiQuery.fPasswordValid)
        {
            MU_ShowErrorMessage(hwndParent, idsPwdNotFound, idsPwdError);
            return FALSE;
        }

        if (uiQuery.szPassword[0] == 0)
        {
            return TRUE;    
        }
        
        if (MU_GetUserInfo(NULL, &uiCurrent))
        {
            if (uiCurrent.uidUserID == uiQuery.uidUserID)
                return TRUE;
        }
    }
    else
        return FALSE;

    MLLoadStringA(idsConfirmEdit, szBuffer, sizeof(szBuffer));

    wsprintf(szString, szBuffer, uiQuery.szUsername);

    fResult = MU_ConfirmUserPassword(hwndParent, szString, uiQuery.szPassword);

    return fResult;
#endif //IDENTITY_PASSWORDS
}

static BOOL _DirectoryIdInUse(DWORD dwId)
{
    HKEY    hSourceSubKey;
    ULONG   ulEnumIndex = 0;
    DWORD   dwStatus, dwSize, dwType, dwValue;
    BOOL    fFound = FALSE;
    TCHAR   szKeyNameBuffer[MAX_PATH];

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegRoot, &hSourceSubKey) == ERROR_SUCCESS)
    {
        while (!fFound) 
        {
            HKEY    hkUserKey;

            if (RegEnumKey(hSourceSubKey, ulEnumIndex++, szKeyNameBuffer,MAXKEYNAME)
                !=  ERROR_SUCCESS)
                break;
            
            if (RegOpenKey(hSourceSubKey, szKeyNameBuffer, &hkUserKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(dwValue);
                dwStatus = RegQueryValueEx(hkUserKey, c_szDirName, NULL, &dwType, (LPBYTE)&dwValue, &dwSize);
                
                if (ERROR_SUCCESS == dwStatus && dwValue == dwId)
                {
                    fFound = TRUE;
                    RegCloseKey(hkUserKey); 
                    break;
                }
                RegCloseKey(hkUserKey); 
            }
        }
        RegCloseKey(hSourceSubKey);
    }
    

    return fFound;
}


DWORD   MU_GenerateDirectoryNameForIdentity(GUID *puidIdentityId)
{   
    DWORD dwId, dwRegValue;

    dwId = puidIdentityId->Data1;

    while (_DirectoryIdInUse(dwId))
        dwId++;

    return dwId;
}

HRESULT MU_GetDirectoryIdForIdentity(GUID *puidIdentityId, DWORD *pdwDirId)
{
    TCHAR   szRegPath[MAX_PATH];
    HKEY    hkey;
    HRESULT hr = E_FAIL;
    DWORD   dwSize, dwStatus, dwValue, dwType;

    MU_GetRegRootForUserID(puidIdentityId, szRegPath);

    if (RegOpenKey(HKEY_CURRENT_USER, szRegPath, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        dwStatus = RegQueryValueEx(hkey, c_szDirName, NULL, &dwType, (LPBYTE)&dwValue, &dwSize);
    
        if (ERROR_SUCCESS == dwStatus)
        {
            *pdwDirId = dwValue;
            hr = S_OK;
        }
        else
        {
            // try to generate one
            dwValue = MU_GenerateDirectoryNameForIdentity(puidIdentityId);
        
            dwType = REG_DWORD;
            dwSize = sizeof(dwValue);
            dwStatus = RegSetValueEx(hkey, c_szDirName, 0, dwType, (LPBYTE)&dwValue, dwSize);

            if (ERROR_SUCCESS == dwStatus)
            {
                *pdwDirId = dwValue;
                hr = S_OK;
            }
        }
        RegCloseKey(hkey);
    }

    return hr;
}


void _MigratePasswords()
{
    CStringList *psList;
    int   i, iCount = 0;
	USERINFO uiUser;
	DWORD dwStatus, dwValue, dwType, dwSize;

	dwType = REG_DWORD;
	dwSize = sizeof(DWORD);
	dwStatus = SHGetValue(HKEY_CURRENT_USER, c_szRegRoot, c_szMigrated5, &dwType, &dwValue, &dwSize);	

	if (dwStatus == ERROR_SUCCESS && dwValue == 1)
		return;
		
    psList = MU_GetUsernameList();

    if (psList)
    {
        iCount = psList->GetLength();

		for (i = 0; i < iCount; i++)
		{
			GUID	uidUser;
			if (SUCCEEDED(MU_UsernameToUserId(psList->GetString(i), &uidUser)) 
				&& MU_GetUserInfo(&uidUser, &uiUser))
			{
				if (!uiUser.fPasswordValid)
				{
					uiUser.fUsePassword = false;
					*uiUser.szPassword = 0;
					MU_SetUserInfo(&uiUser);
				}
			}
		}
        delete psList;
    }

	dwValue = 1;
	SHSetValue(HKEY_CURRENT_USER, c_szRegRoot, c_szMigrated5, REG_DWORD, &dwValue, sizeof(DWORD));	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\multiui.h ===
/************************************************
    MultiUI.h

    Header for multiple user functionality.

    Initially by Christopher Evans (cevans) 7/16/98
*************************************************/
#ifndef _MULTIUI_H
#define _MULTIUI_H
#include "multiusr.h"


#define     IDH_IDENTITY_NAME                   50100
#define     IDH_IDENTITY_MANAGE                 50140
#define     IDH_IDENTITY_LIST                   50155
#define     IDH_IDENTITY_DELETE                 50165
#define     IDH_IDENTITY_ADD                    50175
#define     IDH_IDENTITY_PROPERTIES             50180
#define     IDH_IDENTITY_DEFAULT                50185
#define     IDH_IDENTITY_STARTAS                50190
#define     IDH_IDENTITY_PROMPT_PWORD           50105 //Add new identity; ask for password
#define     IDH_IDENTITY_ENTER_PWORD            50110 //Add new identity; password
#define     IDH_IDENTITY_CONFIRM_PWORD          50115 //Add new identity; confirm password
#define     IDH_IDENTITY_ASK_PWORD              50125 //Change user; ask for pword
#define     IDH_IDENTITY_CHANGE_PWORD           50130 //Change user; change pword button
#define     IDH_IDENTITY_PWORD_OLD              50145 //Change user; old pword
#define     IDH_IDENTITY_PWORD_NEW              50150 //Change user; new pword
#define     IDH_IDENTITY_DELETE_PWORD           50170
#define     IDH_IDENTITY_TELLMEMORE             50195  
#define     IDH_IDENTITY_TELLMEMORE_CONTENT     50200
#define     IDH_MULTI_LOG_OFF                   50120 
#define     IDH_MULTI_MNG_IDENT_DEFAULT	        50185
#define     IDH_MULTI_MNG_DEFAULT_LIST          50160
#define     IDH_MULTI_DELETE_PWORD	            50170

#define  ID_LOGIN_AS_LAST                       0
#define  ID_LOGIN_ASK_ME                        1

void            MU_ShowErrorMessage(HWND hwnd, UINT iMsgID, UINT iTitleID);

BOOL            MU_CreateNewUser(HWND  hwnd, LPUSERINFO  lpUserInfo);
BOOL CALLBACK   AddUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK   ChangeUserPwdDlgProc(HWND   hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_ChangeUserPassword(HWND hwnd, TCHAR *lpszOldNewPassword);
BOOL CALLBACK   EnterUserPwdDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_EnterUserPassword(HWND hwnd, TCHAR *lpszNewPassword);
BOOL CALLBACK   ConfirmUserPwdDlgProc(HWND hDlg, UINT iMsg, WPARAM  wParam, LPARAM  lParam);
BOOL            MU_ConfirmUserPassword(HWND hwnd, TCHAR *lpszMsg, TCHAR *lpszPassword);
BOOL CALLBACK   DeleteUserDlgProc(HWND  hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_GetUserToDelete(HWND hwnd, LPDELETEUSERDIALOGINFO lpszOutUserInfo);
BOOL CALLBACK   ConfirmDeleteUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL            MU_ConfirmDeleteUser(HWND hwnd, TCHAR *lpszUsername);
BOOL            MU_Login(HWND hwnd, DWORD dwFlags, TCHAR *lpszUsername); 
BOOL            MU_ChangeUserSettings(HWND hwnd, LPUSERINFO lpUserInfo);
BOOL            MU_ManageUsers(HWND hwnd, TCHAR *lpszUsername, DWORD dwFlags); 
BOOL            MU_ConfirmUserPassword(HWND hwnd, TCHAR *lpszMsg, TCHAR *lpszPassword);
void            _StripDefault(LPSTR psz);


#endif //_MULTIUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\msident.cpp ===
#include "private.h"
#include "multiusr.h"

UINT WM_IDENTITY_CHANGED;
UINT WM_QUERY_IDENTITY_CHANGE;
UINT WM_IDENTITY_INFO_CHANGED;

extern "C" int _fltused = 0;    // define this so that floats and doubles don't bring in the CRT

// Count number of objects and number of locks.
ULONG       g_cObj=0;
ULONG       g_cLock=0;

// DLL Instance handle
HINSTANCE   g_hInst=0;

// mutex for preventing logon re-entrancy
HANDLE      g_hMutex = NULL;

#define IDENTITY_LOGIN_VALUE    0x00098053
#define DEFINE_STRING_CONSTANTS
#include "StrConst.h"

#define MLUI_SUPPORT
#define MLUI_INIT
#include "mluisup.h"

BOOL    g_fNotifyComplete = TRUE;
GUID    g_uidOldUserId = {0x0};
GUID    g_uidNewUserId = {0x0};

TCHAR   szHKCUPolicyPath[] = "Software\\Microsoft\\Outlook Express\\Identities";

void FixMissingIdentityNames();
void UnloadPStore();
PSECURITY_DESCRIPTOR CreateSd(void);

// This is needed so we can link to libcmt.dll, because floating-point
// initialization code is required.
void __cdecl main()
{
}

#ifdef DISABIDENT
void DisableOnFirstRun(void)
{
    // disable identities in Whistler
  
    HKEY    hKey = NULL;
    DWORD   dwVal = 0;
    DWORD  dwType = 0;
    ULONG  cbData = sizeof(DWORD);
    OSVERSIONINFO OSInfo = {0};
    TCHAR   szPolicyPath[] = "Identities";
    TCHAR   szPolicyKey[] = "Locked Down";
    TCHAR   szFirstRun[] = "FirstRun";
    TCHAR   szRegisteredVersion[] = "RegisteredVersion";

    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSInfo);
    if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5))
    {
        if(!(((OSInfo.dwMajorVersion == 5) && (OSInfo.dwMinorVersion > 0)) || (OSInfo.dwMajorVersion > 5)))
            return;
    }
    else
        return; // No disabling on Win 9x and NT4

    // Check: first time run?
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szHKCUPolicyPath, 0, NULL, 0, 
                    KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey, szRegisteredVersion, NULL, &dwType, (LPBYTE) &dwVal, &cbData);
        RegCloseKey(hKey);

        if(dwVal != OSInfo.dwBuildNumber)
            return; // already checked.
    }
    else
        return;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, szPolicyPath, 0, NULL, 0, 
                    KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey, szFirstRun, NULL, &dwType, (LPBYTE) &dwVal, &cbData);
        if(dwVal != 1)

        {
            dwVal = 1;
            RegSetValueEx(hKey, szFirstRun, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        }
        else
        {
            RegCloseKey(hKey);
            return; // already checked.
        }
    }
    else 
        return;

    if(MU_CountUsers() < 2)
        RegSetValueEx(hKey, szPolicyKey, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);       

    RegCloseKey(hKey);
}
#endif // DISABIDENT

//////////////////////////////////////////////////////////////////////////
//
// DLL entry point
//
//////////////////////////////////////////////////////////////////////////
EXTERN_C BOOL WINAPI LibMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    WM_IDENTITY_CHANGED= RegisterWindowMessage("WM_IDENTITY_CHANGED");
    WM_QUERY_IDENTITY_CHANGE= RegisterWindowMessage("WM_QUERY_IDENTITY_CHANGE");
    WM_IDENTITY_INFO_CHANGED= RegisterWindowMessage("WM_IDENTITY_INFO_CHANGED");

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
            // MessageBox(NULL, "Debug", "Debug", MB_OK);
            SHFusionInitializeFromModule(hInstance);
            MLLoadResources(hInstance, TEXT("msidntld.dll"));
            if (MLGetHinst() == NULL)
                return FALSE;

            if (g_hMutex == NULL)
            {
                SECURITY_ATTRIBUTES  sa;
                PSECURITY_DESCRIPTOR psd;

                psd = CreateSd();
                if (psd)
                {
                    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                    sa.lpSecurityDescriptor = psd;
                    sa.bInheritHandle = TRUE;

                    g_hMutex = CreateMutex(&sa, FALSE, "MSIdent Logon");

                    LocalFree(psd);
                }
                else
                    // in the worst case drop down to unshared object
                    g_hMutex = CreateMutex(NULL, FALSE, "MSIdent Logon");

                if (g_hMutex == NULL)  // Try to open mutex, if we cannot create mutex IE6 32769 
                    g_hMutex = OpenMutex(MUTEX_MODIFY_STATE, FALSE, "MSIdent Logon");


                if (GetLastError() != ERROR_ALREADY_EXISTS)
                {
                    GUID        uidStart;
                    USERINFO    uiLogin;

#ifdef DISABIDENT
                    DisableOnFirstRun();
#endif // DISABIDENT
                    // in case something got stuck in a switch, wipe it out here.
                    CUserIdentityManager::ClearChangingIdentities();                         

                    FixMissingIdentityNames();
                    // we are the first instance to come up.
                    // may need to reset the last user.....
                    if (GetProp(GetDesktopWindow(),"IDENTITY_LOGIN") != (HANDLE)IDENTITY_LOGIN_VALUE)
                    {
                        _MigratePasswords();
                        MU_GetLoginOption(&uidStart);

                        // if there is a password on this identity, we can't auto start as them
                        if (uidStart != GUID_NULL && MU_GetUserInfo(&uidStart, &uiLogin) && (uiLogin.fUsePassword || !uiLogin.fPasswordValid))
                        {
                            uidStart = GUID_NULL;
                        }

                        if (uidStart == GUID_NULL)
                        {
                            MU_SwitchToUser("");
                            SetProp(GetDesktopWindow(),"IDENTITY_LOGIN", (HANDLE)IDENTITY_LOGIN_VALUE);
                        }
                        else
                        {
                            if(MU_GetUserInfo(&uidStart, &uiLogin))
                                MU_SwitchToUser(uiLogin.szUsername);
                            else
                                MU_SwitchToUser("");
                        }
                        SetProp(GetDesktopWindow(),"IDENTITY_LOGIN", (HANDLE)IDENTITY_LOGIN_VALUE);
                    }
                }
            }
            DisableThreadLibraryCalls(hInstance);
            g_hInst = hInstance;

            break;

        case DLL_PROCESS_DETACH:
            MLFreeResources(hInstance);
            UnloadPStore();
            CloseHandle(g_hMutex);
            g_hMutex = NULL;
            SHFusionUninitialize();
            break;
    }

    return TRUE;
} 

//////////////////////////////////////////////////////////////////////////
//
// Standard OLE entry points
//
//////////////////////////////////////////////////////////////////////////

//  Class factory -
//  For classes with no special needs these macros should take care of it.
//  If your class needs some special stuff just to get the ball rolling,
//  implement your own CreateInstance method.  (ala, CConnectionAgent)

#define DEFINE_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    *ppunk = (iface *)new cls; \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

#define DEFINE_AGGREGATED_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    *ppunk = (iface *)new cls(punkOuter); \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

DEFINE_CREATEINSTANCE(CUserIdentityManager, IUserIdentityManager)

const CFactoryData g_FactoryData[] = 
{
 {   &CLSID_UserIdentityManager,        CUserIdentityManager_CreateInstance,    0 }
};

HRESULT APIENTRY DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;

    *ppv = NULL;

    MU_Init();

    // Validate request
    for (int i = 0; i < ARRAYSIZE(g_FactoryData); i++)
    {
        if (rclsid == *g_FactoryData[i].m_pClsid)
        {
            punk = new CClassFactory(&g_FactoryData[i]);
            break;
        }
    }

    if (ARRAYSIZE(g_FactoryData) <= i)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }
    else if (NULL == punk)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    } 


    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    // check objects and locks
    return (0L == DllGetRef() && 0L == DllGetLock()) ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    char        szDll[MAX_PATH];
    int         cch;
    STRENTRY    seReg[2];
    STRTABLE    stReg;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            // Get our location
            GetModuleFileName(g_hInst, szDll, sizeof(szDll));

            // Setup special registration stuff
            // Do this instead of relying on _SYS_MOD_PATH which loses spaces under '95
            stReg.cEntries = 0;
            seReg[stReg.cEntries].pszName = "SYS_MOD_PATH";
            seReg[stReg.cEntries].pszValue = szDll;
            stReg.cEntries++;    
            stReg.pse = seReg;

            hr = pfnri(g_hInst, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

    STDAPI DllRegisterServer(void)
{
    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    HKEY    hKey = NULL;
    DWORD   dwVal = 1;
    ULONG  cbData = sizeof(DWORD);
    OSVERSIONINFO OSInfo = {0};
    TCHAR   szPolicyPath[] = "Identities";
    TCHAR   szRegisteredVersion[] = "RegisteredVersion";
    TCHAR   szPolPath[] = "Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Identities";
    TCHAR   szPolicyKey[] = "Locked Down";

    CallRegInstall("Reg");
    if (hinstAdvPack)
    {
        FreeLibrary(hinstAdvPack);
    }
#ifdef DISABIDENT
    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSInfo);

    if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5))
    {
        if(!(((OSInfo.dwMajorVersion == 5) && (OSInfo.dwMinorVersion > 0)) || (OSInfo.dwMajorVersion > 5)))
            return NOERROR;
    }
    else
        return NOERROR; // No disable for Win9x

    // Set registration value
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szHKCUPolicyPath, 0, NULL, 0, 
                    KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        dwVal = OSInfo.dwBuildNumber;
        RegSetValueEx(hKey, szRegisteredVersion, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        RegCloseKey(hKey);
    }
#endif // DISABIDENT

    // DISABLING identities in Win64
#ifdef _WIN64
    // Set registration value
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPolPath, 0, NULL, 0, 
                    KEY_WOW64_32KEY | KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        RegSetValueEx(hKey, szPolicyKey, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
    }
#endif // _WIN64
    return NOERROR;
}

STDAPI
DllUnregisterServer(void)
{
    return NOERROR;
}

PSECURITY_DESCRIPTOR CreateSd(void)
{
    PSID                     AuthenticatedUsers = NULL;
    PSID                     BuiltInAdministrators = NULL;
    PSID                     PowerUsers = NULL;
    PSECURITY_DESCRIPTOR     RetVal = NULL;
    PSECURITY_DESCRIPTOR     Sd = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG                    AclSize;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  &BuiltInAdministrators))
        goto ErrorExit;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_POWER_USERS,
                                  0,0,0,0,0,0,
                                  &PowerUsers))
        goto ErrorExit;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,            // 1 sub-authority
                                  SECURITY_AUTHENTICATED_USER_RID,
                                  0,0,0,0,0,0,0,
                                  &AuthenticatedUsers))
        goto ErrorExit;

    // 
    // Calculate the size of and allocate a buffer for the DACL, we need
    // this value independently of the total alloc size for ACL init.
    //
    // "- sizeof (ULONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.
    //

    AclSize = sizeof (ACL) +
        (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(AuthenticatedUsers) +
        GetLengthSid(BuiltInAdministrators) +
        GetLengthSid(PowerUsers);

    Sd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

    if (Sd)
    {
        ACL *Acl;

        Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (!InitializeAcl(Acl,
                           AclSize,
                           ACL_REVISION)) {

            // Error

        } else if (!AddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        SYNCHRONIZE | MUTEX_MODIFY_STATE,
                                        AuthenticatedUsers)) {

            // Failed to build the ACE granting "Authenticated users"
            // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.

        } else if (!AddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        SYNCHRONIZE | MUTEX_MODIFY_STATE,
                                        PowerUsers)) {

            // Failed to build the ACE granting "Power users"
            // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE) access.

        } else if (!AddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        MUTEX_ALL_ACCESS,
                                        BuiltInAdministrators)) {

            // Failed to build the ACE granting "Built-in Administrators"
            // GENERIC_ALL access.

        } else if (!InitializeSecurityDescriptor(Sd,
                                                 SECURITY_DESCRIPTOR_REVISION)) {

            // error

        } else if (!SetSecurityDescriptorDacl(Sd,
                                              TRUE,
                                              Acl,
                                              FALSE)) {

            // error

        } else {

            // success
            RetVal = Sd;
        }

        // only free Sd if we encountered a failure
        if (!RetVal)
            LocalFree(Sd);
    }

ErrorExit:

    if (AuthenticatedUsers)
        FreeSid(AuthenticatedUsers);

    if (BuiltInAdministrators)
        FreeSid(BuiltInAdministrators);

    if (PowerUsers)
        FreeSid(PowerUsers);

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\multiutl.cpp ===
#include "private.h"
#include "multiutl.h"
#include <wtypes.h>
#include "strconst.h"
#include <platform.h>

extern      HINSTANCE   g_hInst;

// Pstore related variables.
static PST_KEY s_Key = PST_KEY_CURRENT_USER;

// {89C39569-6841-11d2-9F59-0000F8085266}
static const GUID GUID_PStoreType = { 0x89c39569, 0x6841, 0x11d2, { 0x9f, 0x59, 0x0, 0x0, 0xf8, 0x8, 0x52, 0x66 } };
static WCHAR c_szIdentityMgr[] = L"IdentityMgr";
static WCHAR c_szIdentities[] = L"Identities";
static WCHAR c_szIdentityPass[] = L"IdentitiesPass";

//Need these private implementations
//OE has dependency on the particular allocator used

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return CoTaskMemAlloc(nSize);
}

void  __cdecl operator delete(void *pv)
{
    //If changed to GlobalFree or HeapFree - must check for NULL here
    CoTaskMemFree(pv);
}

extern "C" int __cdecl _purecall(void) 
{
    DebugBreak();
    return 0;
}


// --------------------------------------------------------------------------
// FIsSpaceA
// --------------------------------------------------------------------------
BOOL FIsSpaceA(LPSTR psz)
{
#ifdef MAC
    return (isspace(*psz));
#else	// !MAC
    WORD wType;

    if (IsDBCSLeadByte(*psz))
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType);
    else
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType);
    return (wType & C1_SPACE);
#endif	// MAC
}

// --------------------------------------------------------------------------
// FIsSpaceW
// --------------------------------------------------------------------------
BOOL FIsSpaceW(LPWSTR psz)
{
#ifdef MAC
    // Maybe we should convert to ANSI before checking??
    return (isspace(*( ( (TCHAR *) psz ) + 1 ) ));
#else	// !MAC
    WORD wType;
    GetStringTypeExW(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType);
    return (wType & C1_SPACE);
#endif	// !MAC
}


ULONG UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb)
{
    // Locals
    ULONG           cb;
    LPTSTR          psz;
    
    Assert(lpsz != NULL);
    Assert(fLeading || fTrailing);
    
    // Did the user pass in the length
    if (pcb)
        cb = *pcb;
    else
        cb = lstrlen (lpsz);
    
    if (cb == 0)
        return cb;
    
    if (fLeading)
    {
        psz = lpsz;
        
        while (FIsSpace(psz))
        {
            psz++;
            cb--;
        }
        
        if (psz != lpsz)
            // get the NULL at the end too
            MoveMemory(lpsz, psz, (cb + 1) * sizeof(TCHAR));
    }
    
    if (fTrailing)
    {
        psz = lpsz + cb;
        
        while (cb > 0)
        {
            if (!FIsSpace(psz-1))
                break;
            psz--;
            cb--;
        }    
        
        // NULL Term
        *psz = '\0';
    }
    
    // Set String Size
    if (pcb)
        *pcb = cb;
    
    // Done
    return cb;
}

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP)
    {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            WinHelp ((HWND)lphi->hItemHandle,
                        c_szCtxHelpFile,
                        HELP_WM_HELP,
                        (DWORD_PTR)(void*)rgCtxMap);
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU)
    {
        WinHelp ((HWND) wParam,
                    c_szCtxHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)(void*)rgCtxMap);
        return (TRUE);
    }

    Assert(0);

    return FALSE;
}



#define OBFUSCATOR              0x14151875;

#define PROT_SIZEOF_HEADER      0x02    // 2 bytes in the header
#define PROT_SIZEOF_XORHEADER   (PROT_SIZEOF_HEADER+sizeof(DWORD))

#define PROT_VERSION_1          0x01

#define PROT_PASS_XOR           0x01
#define PROT_PASS_PST           0x02

static BOOL FDataIsValidV1(BYTE *pb)
{ return pb && pb[0] == PROT_VERSION_1 && (pb[1] == PROT_PASS_XOR || pb[1] == PROT_PASS_PST); }

static BOOL FDataIsPST(BYTE *pb)
{ return pb && pb[1] == PROT_PASS_PST; }

///////////////////////////////////////////////////////////////////////////
// 
// NOTE - The functions for encoding the user passwords really should not 
//        be here.  Unfortunately, they are not anywhere else so for now,
//        this is where they will stay.  They are defined as static since
//        other code should not rely on them staying here, particularly the 
//        XOR stuff.
//
///////////////////////////////////////////////////////////////////////////
// 
// XOR functions
//
///////////////////////////////////////////////////////////////////////////

static HRESULT _XOREncodeProp(const BLOB *const pClear, BLOB *const pEncoded)
{
    DWORD       dwSize;
    DWORD       last, last2;
    DWORD       UNALIGNED *pdwCypher;
    DWORD       dex;

    pEncoded->cbSize = pClear->cbSize+PROT_SIZEOF_XORHEADER;
    if (!MemAlloc((void* *)&pEncoded->pBlobData, pEncoded->cbSize + 6))
        return E_OUTOFMEMORY;
    
    // set up header data
    Assert(2 == PROT_SIZEOF_HEADER);
    pEncoded->pBlobData[0] = PROT_VERSION_1;
    pEncoded->pBlobData[1] = PROT_PASS_XOR;
    *((DWORD UNALIGNED *)&(pEncoded->pBlobData[2])) = pClear->cbSize;

    // nevermind that the pointer is offset by the header size, this is
    // where we start to write out the modified password
    pdwCypher = (DWORD UNALIGNED *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;                              // 0' = 0 ^ ob
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            {
            last2 = ((DWORD UNALIGNED *)pClear->pBlobData)[dex];  // 1 
            pdwCypher[dex] = last2 ^ last;              // 1' = 1 ^ 0
            last = last2;                   // save 1 for the 2 round
            }
        }

    // if we have bits left over
    // note that dwSize is computed now in bits
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        pdwCypher[dex] &= ((DWORD)-1) << dwSize;
        pdwCypher[dex] |=
            ((((DWORD UNALIGNED *)pClear->pBlobData)[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

static HRESULT _XORDecodeProp(const BLOB *const pEncoded, BLOB *const pClear)
{
    DWORD       dwSize;
    DWORD       last;
    DWORD       UNALIGNED *pdwCypher;
    DWORD       dex;

    // we use CoTaskMemAlloc to be in line with the PST implementation
    pClear->cbSize = *(DWORD UNALIGNED *)(&pEncoded->pBlobData[2]);
    MemAlloc((void **)&pClear->pBlobData, pClear->cbSize);
    if (!pClear->pBlobData)
        return E_OUTOFMEMORY;
    
    // should have been tested by now
    Assert(FDataIsValidV1(pEncoded->pBlobData));
    Assert(!FDataIsPST(pEncoded->pBlobData));

    // nevermind that the pointer is offset by the header size, this is
    // where the password starts
    pdwCypher = (DWORD UNALIGNED *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            last = ((DWORD UNALIGNED *)pClear->pBlobData)[dex] = pdwCypher[dex] ^ last;
        }

    // if we have bits left over
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        ((DWORD UNALIGNED *)pClear->pBlobData)[dex] &= ((DWORD)-1) << dwSize;
        ((DWORD UNALIGNED *)pClear->pBlobData)[dex] |=
                ((pdwCypher[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

/*
    EncodeUserPassword

    Encrypt the passed in password.  This encryption seems to
    add an extra 6 bytes on to the beginning of the data
    that it passes back, so we need to make sure that the 
    lpszPwd is large enough to hold a few extra characters.
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, a c string containing the password.
    on exit, it is the encrypted data, plus some header info.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would enter with *cb == 4.
*/
void EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XOREncodeProp(&blobClient, &blobProp);
    
    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}

/*
    DecodeUserPassword

    Decrypt the passed in data and return a password.  This 
    encryption seems to add an extra 6 bytes on to the beginning 
    so decrupting will result in a using less of lpszPwd.
    .
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, the encrypted password plus some 
    header info. 
    on exit, a c string containing the password.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would leave with *cb == 4.
*/
void DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XORDecodeProp(&blobClient, &blobProp);

    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        lpszPwd[blobProp.cbSize] = 0;
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}


// --------------------------------------------------------------------------------
// MemInit
// --------------------------------------------------------------------------------
void MemInit()
{
}

// --------------------------------------------------------------------------------
// MemUnInit
// --------------------------------------------------------------------------------
void MemUnInit()
{
}


// --------------------------------------------------------------------------------
// MemFree
// --------------------------------------------------------------------------------
void MemFree(void* pv) 
{
    CoTaskMemFree(pv);
}

// --------------------------------------------------------------------------------
// MemAlloc
// --------------------------------------------------------------------------------
BOOL MemAlloc(void** ppv, ULONG cb) 
{
    assert(ppv && cb);
    *ppv = CoTaskMemAlloc(cb);
    if (NULL == *ppv)
        return FALSE;
    return TRUE;
}

// --------------------------------------------------------------------------------
// MemRealloc
// --------------------------------------------------------------------------------
BOOL MemRealloc(void* *ppv, ULONG cbNew) 
{
    assert(ppv && cbNew);
    void* pv = CoTaskMemRealloc(*ppv, cbNew);
    if (NULL == pv)
        return FALSE;
    *ppv = pv;
    return TRUE;
}

// --------------------------------------------------------------------------------
//  Functions to convert GUIDs to ascii strings
// --------------------------------------------------------------------------------

int AStringFromGUID(GUID *puid,  TCHAR *lpsz, int cch)
{
    WCHAR   wsz[255];
    int     i;

    i = StringFromGUID2(*puid, wsz, 255);

    if (WideCharToMultiByte(CP_ACP, 0, wsz, -1, lpsz, cch, NULL, NULL) == 0)
        return 0;
    
    return (lstrlen(lpsz) + 1);
}


HRESULT GUIDFromAString(TCHAR *lpsz, GUID *puid)
{
    WCHAR   wsz[255];
    HRESULT hr;

    if (MultiByteToWideChar(CP_ACP, 0, lpsz, -1, wsz, 255) == 0)
        return GetLastError();

    hr = CLSIDFromString(wsz, puid);
    
    return hr;
}



// ****************************************************************************************************
//  CNotifierList Class
//
//  A really basic IUnknown list class.  Actually, its a IUnknown array class, but you don't need to know
//  that.
//


CNotifierList::CNotifierList()
{
    m_count = 0;
    m_ptrCount = 0;
    m_entries = NULL;
    m_nextCookie = 1;
    m_cRef = 1;
    InitializeCriticalSection(&m_rCritSect);
}

/*
    CNotifierList::~CNotifierList

    Clean up any memory that was allocated in the CNotifierList object
*/
CNotifierList::~CNotifierList()
{
    if (m_entries)
    {
        for (int i = 0; i < m_count; i++)
        {
            if (m_entries[i].punk)
            {
                m_entries[i].punk->Release();
                m_entries[i].punk = NULL;
                m_entries[i].dwCookie = 0;
            }
        }
        MemFree(m_entries);
        m_entries = NULL;
        m_count = 0;
    }
    DeleteCriticalSection(&m_rCritSect);
}


STDMETHODIMP_(ULONG) CNotifierList::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CNotifierList::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

/*
    CNotifierList::Add

    Add a IUnknown to the end of the IUnknown list.
*/
HRESULT    CNotifierList::Add(IUnknown *punk, DWORD *pdwCookie)
{
    TraceCall("Identity - CNotifierList::Add");

    EnterCriticalSection(&m_rCritSect);
    // make more room for pointers, if necessary
    if (m_ptrCount == m_count)
    {
        m_ptrCount += 5;
        if (!MemRealloc((void **)&m_entries, sizeof(UNKLIST_ENTRY) * m_ptrCount))
        {
            m_ptrCount -= 5;
            Assert(false);
            LeaveCriticalSection(&m_rCritSect);    
            return E_OUTOFMEMORY;
        }

        // initialize the new IUnknowns to nil
        for (int i = m_count; i < m_ptrCount; i++)
        {
            ZeroMemory(&m_entries[i], sizeof(UNKLIST_ENTRY));
        }
    }
    
    //now put the IUnknown in the next location
    int iNewIndex = m_count++;
    
    punk->AddRef();
    m_entries[iNewIndex].punk = punk;
    m_entries[iNewIndex].bState = NS_NONE;
    m_entries[iNewIndex].dwCookie = ++m_nextCookie;
    m_entries[iNewIndex].dwThreadId = GetCurrentThreadId();
    *pdwCookie = m_entries[iNewIndex].dwCookie;
    LeaveCriticalSection(&m_rCritSect);  
    CreateNotifyWindow();
    return S_OK;
}

/*
    CNotifierList::Remove
    
    Remove a IUnknown at zero based index iIndex 
*/

HRESULT CNotifierList::Remove(int   iIndex)
{
    int     iCopySize;

    TraceCall("Identity - CNotifierList::Remove");

    EnterCriticalSection(&m_rCritSect);
    iCopySize = ((m_count - iIndex) - 1) * sizeof(UNKLIST_ENTRY);

    // free the memory for the IUnknown
    if (m_entries[iIndex].punk)
    {
        ReleaseWindow();
        m_entries[iIndex].punk->Release();
        ZeroMemory(&m_entries[iIndex], sizeof(UNKLIST_ENTRY));
    }

    // move the other IUnknowns down
    if (iCopySize)
    {
        memmove(&(m_entries[iIndex]), &(m_entries[iIndex+1]), iCopySize);
    }

    // null out the last item in the list and decrement the counter.
    m_entries[--m_count].punk = NULL;
    LeaveCriticalSection(&m_rCritSect); 
    return S_OK;
}

/*
    CNotifierList::RemoveCookie
    
    Remove an IUnknown by its cookie
*/

HRESULT    CNotifierList::RemoveCookie(DWORD dwCookie)
{
    int     iIndex;

    for (iIndex = 0; iIndex < m_count; iIndex++)
    {
        if (m_entries[iIndex].dwCookie == dwCookie)
        {
            return Remove(iIndex);
        }
    }
    return E_FAIL;
}

/*
    CNotifierList::GetAtIndex
    
    Return the pointer to the IUnknown at zero based index iIndex.

    Return the IUnknown at the given index.  Note that the object pointer
    is still owned by the IUnknown list and should not be deleted.
*/

HRESULT     CNotifierList::GetAtIndex(int iIndex, IUnknown **ppunk)
{
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&m_rCritSect);
    if (iIndex < m_count && iIndex >= 0 && m_entries[iIndex].punk)
    {
        *ppunk = m_entries[iIndex].punk;
        (*ppunk)->AddRef();
        hr = S_OK;
    }
    else
        *ppunk = NULL;

    LeaveCriticalSection(&m_rCritSect);    
    return hr;
}


HRESULT     CNotifierList::CreateNotifyWindow()
{
    DWORD   dwThreadCount = 0;
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    int     iFound = -1;
    HWND    hwnd = NULL;

    for (iIndex = 0; iIndex < m_count; iIndex++)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId)
        {
            iFound  = iIndex;
            if (!hwnd)
                hwnd = m_entries[iIndex].hwnd;
            else
            {
                Assert(NULL == m_entries[iIndex].hwnd || hwnd == m_entries[iIndex].hwnd);
                m_entries[iIndex].hwnd = hwnd;
            }
            dwThreadCount++;
        }
    }
    
    if (dwThreadCount == 1 && iFound >= 0)
    {
        hwnd = m_entries[iFound].hwnd = CreateWindowA(c_szNotifyWindowClass, c_szNotifyWindowClass, WS_POPUP, 
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, 
                    NULL, g_hInst, this);
        
        if (m_entries[iFound].hwnd)
            SetWindowLongPtr(m_entries[iFound].hwnd, GWLP_USERDATA, (LRESULT)this);
    }
    return (hwnd ? S_OK : E_FAIL);
}


HRESULT     CNotifierList::ReleaseWindow()
{
    DWORD   dwThreadCount = 0;
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    HWND    hwnd = NULL;

    for (iIndex = 0; iIndex < m_count; iIndex++)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId)
        {
            if (dwThreadCount == 0)
                hwnd = m_entries[iIndex].hwnd;
            dwThreadCount++;
        }
    }
    
    if (dwThreadCount == 1 && hwnd)
    {
        SendMessage(hwnd, WM_CLOSE, 0, 0);
    }
    return S_OK;
}

HRESULT     CNotifierList::PreNotify()
{
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;

    for (iIndex = m_count -1; iIndex >= 0; iIndex--)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId && NULL != m_entries[iIndex].punk)
            m_entries[iIndex].bState = NS_PRE_NOTIFY;
//        else          //BUG 47472, this could cause problems during re-entrant calls to SendNotification
//            m_entries[iIndex].bState = NS_NONE;
    }
    return S_OK;
}

int     CNotifierList::GetNextNotify()
{
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    for (iIndex = m_count -1; iIndex >= 0; iIndex--)
    {
        if (m_entries[iIndex].dwThreadId == dwThreadId && NULL != m_entries[iIndex].punk && NS_PRE_NOTIFY == m_entries[iIndex].bState)
            return iIndex;
    }
    return -1;
}

HRESULT     CNotifierList::SendNotification(UINT msg, DWORD dwType)
{
    DWORD   dwThreadCount = 0, dwOldCount;
    DWORD   dwThreadId = GetCurrentThreadId();
    int     iIndex;
    HWND    hwnd = NULL;
    HRESULT hr = S_OK;

#if defined(DEBUG)
    DebugStrf("Identity - CNotifierList::SendNotification %ld\r\n", msg);
#endif

    AddRef();

    PreNotify();

    while ((iIndex = GetNextNotify()) != -1)
    {
        IUnknown    *punk;
        IIdentityChangeNotify    *pICNotify;

        punk = m_entries[iIndex].punk;
        m_entries[iIndex].bState = NS_NOTIFIED;

        punk->AddRef();
        if (SUCCEEDED(punk->QueryInterface(IID_IIdentityChangeNotify, (void **)&pICNotify)) && pICNotify)
        {
            if( msg == WM_QUERY_IDENTITY_CHANGE )
            {
                if (FAILED(hr = pICNotify->QuerySwitchIdentities()))
                {
                    punk->Release();
                    pICNotify->Release();
                    goto exit;
                }
            }
            else if( msg == WM_IDENTITY_CHANGED )
            {
                pICNotify->SwitchIdentities();
            }
            else if( msg == WM_IDENTITY_INFO_CHANGED )
            {
                    pICNotify->IdentityInformationChanged(dwType);
            }

            pICNotify->Release();
        }
        punk->Release();
    }

exit:
    Release();
    return hr;
}

#ifdef DEBUG

// --------------------------------------------------------------------------------
// DebugStrf
// --------------------------------------------------------------------------------
void DebugStrf(LPTSTR lpszFormat, ...)
{
    static TCHAR szDebugBuff[500];
    va_list arglist;

    va_start(arglist, lpszFormat);
    wvsprintf(szDebugBuff, lpszFormat, arglist);
    va_end(arglist);

    OutputDebugString(szDebugBuff);
}
#endif



// ---------------------------------------------------------------------------------
// Pstore code for storing passwords
// ---------------------------------------------------------------------------------
// Functions related to saving and restoring user passwords from the pstore.


// We have wrappers around Create and Release to allow for future caching of the pstore
// instance within webcheck. 

STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;

    hr = PStoreCreateInstance ( ppIPStore,
                                NULL,
                                NULL,
                                0);
    return hr;
}


STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}


STDAPI  ReadIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore)
{
    GUID             itemType = GUID_NULL;
    GUID             itemSubtype = GUID_NULL;
    PST_PROMPTINFO   promptInfo = {0};
    IPStore*         pStore = NULL;
    HRESULT          hr ;
     
    if (pPwdStore == NULL)
        return E_POINTER;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.szPrompt = NULL;
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    
    hr = CreatePStore(&pStore);    

    if (SUCCEEDED(hr))
    {
        Assert(pStore != NULL);

        itemType = GUID_PStoreType;
        itemSubtype = *puidIdentity;

        if (SUCCEEDED(hr))
        {
            DWORD           cbData;
            BYTE           *pbData = NULL;
            

            hr = pStore->ReadItem(
                            s_Key,
                            &itemType,
                            &itemSubtype,
                            c_szIdentityPass,
                            &cbData,
                            &pbData,
                            &promptInfo,
                            0);

            if (SUCCEEDED(hr))
            {
                CopyMemory(pPwdStore, pbData, (cbData <= sizeof(PASSWORD_STORE) ? cbData : sizeof(PASSWORD_STORE)));
                MemFree(pbData);

                hr = S_OK;
            }
        }

        ReleasePStore(pStore);
    }

    return hr;
}

STDAPI WriteIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore)
{
    HRESULT         hr;
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo;
    IPStore *       pStore;

    typeInfo.cbSize = sizeof(typeInfo);

    typeInfo.szDisplayName = c_szIdentityMgr;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    promptInfo.szPrompt = NULL;

    hr = CreatePStore(&pStore);

    if (SUCCEEDED(hr))
    {
        GUID itemType = GUID_NULL;
        GUID itemSubtype = GUID_NULL;

        Assert(pStore != NULL);

        itemType = GUID_PStoreType;
        itemSubtype = *puidIdentity;
        
        if (SUCCEEDED(hr))
        {
            hr = pStore->CreateType(s_Key, &itemType, &typeInfo, 0);

            // PST_E_TYPE_EXISTS implies type already exists which is just fine
            // by us.
            if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
            {
                typeInfo.szDisplayName = c_szIdentities;

                hr = pStore->CreateSubtype(
                                        s_Key,
                                        &itemType,
                                        &itemSubtype,
                                        &typeInfo,
                                        NULL,
                                        0);

                if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
                {
                    if (pPwdStore != NULL)
                    {
                        hr = pStore->WriteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            c_szIdentityPass,
                                            (sizeof(PASSWORD_STORE)),
                                            (BYTE *)pPwdStore,
                                            &promptInfo,
                                            PST_CF_NONE,
                                            0);
                    }
                    else
                    {
                        hr = pStore->DeleteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            c_szIdentityPass,
                                            &promptInfo,
                                            0);
                    }
                }
            }
        }
        
        ReleasePStore(pStore);
    }
    
    return hr;
}              

#define CH_WHACK TEXT(FILENAME_SEPARATOR)
                                                         
// rips the last part of the path off including the backslash
//      C:\foo      -> C:\      ;
//      C:\foo\bar  -> C:\foo
//      C:\foo\     -> C:\foo
//      \\x\y\x     -> \\x\y
//      \\x\y       -> \\x
//      \\x         -> ?? (test this)
//      \foo        -> \  (Just the slash!)
//
// in/out:
//      pFile   fully qualified path name
// returns:
//      TRUE    we stripped something
//      FALSE   didn't strip anything (root directory case)
//
//      Stolen from shlwapi\path.c

STDAPI_(BOOL) _PathRemoveFileSpec(LPTSTR pFile)
{
    LPTSTR pT;
    LPTSTR pT2 = pFile;

    for (pT = pT2; *pT2; pT2 = CharNext(pT2)) {
        if (*pT2 == CH_WHACK)
            pT = pT2;             // last "\" found, (we will strip here)
        else if (*pT2 == TEXT(':')) {   // skip ":\" so we don't
            if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                pT2++;
            pT = pT2 + 1;
        }
    }
    if (*pT == 0)
        return FALSE;   // didn't strip anything

    //
    // handle the \foo case
    //
    else if ((pT == pFile) && (*pT == CH_WHACK)) {
        // Is it just a '\'?
        if (*(pT+1) != TEXT('\0')) {
            // Nope.
            *(pT+1) = TEXT('\0');
            return TRUE;        // stripped something
        }
        else        {
            // Yep.
            return FALSE;
        }
    }
    else {
        *pT = 0;
        return TRUE;    // stripped something
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msidle\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\multiutl.h ===
#ifndef __MULTIUTL_H
#define __MULTIUTL_H

#include <assert.h>
#include "objidl.h"
#include <pstore.h>
#include "multiusr.h"

#ifndef Assert
#ifdef DEBUG
#define Assert(a)		assert(a)
#define SideAssert(a)	Assert(a)
#define AssertSz(a, sz) Assert(a)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#else	// DEBUG
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define Assert(a)
#define SideAssert(a)	(a)
#define AssertSz(a, sz) 
#endif	// DEBUG, else

#endif

#ifdef UNICODE
#define FIsSpace            FIsSpaceW
#else
#define FIsSpace            FIsSpaceA
#endif


// Context-sensitive Help utility.
typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);


ULONG UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
void    EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb);
void    DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb);
STDAPI WriteIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore);
STDAPI  ReadIdentityPassword(GUID *puidIdentity, PASSWORD_STORE  *pPwdStore);
STDAPI  CreatePStore(IPStore **ppIPStore);
STDAPI  ReleasePStore(IPStore *pIPStore);



// --------------------------------------------------------------------------------
// SafeRelease - Releases an object and sets the object to NULL
// --------------------------------------------------------------------------------
#define SafeRelease(_object) \
    if (_object) { \
        (_object)->Release(); \
        (_object) = NULL; \
    } else

void       MemFree(void* pv);
BOOL       MemAlloc(void** ppv, ULONG cb);
BOOL       MemRealloc(void** ppv, ULONG cbNew);

// --------------------------------------------------------------------------------
// TraceCall(_pszFunc)
// -------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C void DebugStrf(LPTSTR lpszFormat, ...);
#endif

#if defined(DEBUG)
#define TraceCall(_pszFunc) DebugStrf("%s\r\n", _pszFunc)
#else
#define TraceCall(_pszFunc)
#endif

// --------------------------------------------------------------------------------
// GUID <-> Ascii string functions
// --------------------------------------------------------------------------------
HRESULT GUIDFromAString(TCHAR *lpsz, GUID *puid);
int     AStringFromGUID(GUID *rguid,  TCHAR *lpsz, int cch);

typedef enum 
{
    NS_NONE = 0,
    NS_PRE_NOTIFY,
    NS_NOTIFIED
} NOTIFICATION_STATE;

typedef struct tagUNKLIST_ENTRY
{
    HWND        hwnd;
    DWORD       dwThreadId;
    DWORD       dwCookie;
    BYTE        bState;
    IUnknown   *punk;
} UNKLIST_ENTRY;

class CNotifierList
{
public:
                            CNotifierList();
    virtual                 ~CNotifierList();

    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    inline  DWORD           GetLength(void)      {return m_count;}
            HRESULT         Add(IUnknown *punk, DWORD *pdwCookie);
            HRESULT         RemoveCookie(DWORD dwCookie);
            HRESULT         Remove(int iIndex);
            HRESULT         GetAtIndex(int iIndex, IUnknown **ppunk);  
            HRESULT         CreateNotifyWindow();
            HRESULT         ReleaseWindow();
            HRESULT         SendNotification(UINT msg, DWORD dwType);
            HRESULT         PreNotify();
            int             GetNextNotify();
private:
    ULONG               m_cRef;
    int                 m_count;
    int                 m_ptrCount;
    DWORD               m_nextCookie;
    UNKLIST_ENTRY      *m_entries;      
    CRITICAL_SECTION    m_rCritSect;
};



#endif  //__MULTIUTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\multiusr.h ===
/************************************************
    MultiUsr.h

    Header for multiple user functionality.

    Initially by Christopher Evans (cevans) 7/16/98
*************************************************/
#ifndef _MULTIUSR_H
#define _MULTIUSR_H


#define CCH_USERPASSWORD_MAX_LENGTH 16
#define CCH_USERNAME_MAX_LENGTH     CCH_IDENTITY_NAME_MAX_LENGTH
typedef struct 
{
    BOOL        fUsePassword;
    BOOL        fPasswordValid;
    GUID        uidUserID;
    TCHAR       szUsername[CCH_USERNAME_MAX_LENGTH];
    TCHAR       szPassword[CCH_USERPASSWORD_MAX_LENGTH];
}USERINFO, *LPUSERINFO;


typedef struct 
{
    TCHAR       szUsername[CCH_USERNAME_MAX_LENGTH];
    BOOL        fDeleteMessages;
}DELETEUSERDIALOGINFO, *LPDELETEUSERDIALOGINFO;


typedef struct 
{
    TCHAR        szPassword[CCH_USERPASSWORD_MAX_LENGTH];
    TCHAR        szMsg[255];
}CONFIRMPWDDIALOGINFO, *LPCONFIRMPWDDIALOGINFO;

typedef struct  
{
    BOOL        fUsePassword;
    TCHAR       szPassword[CCH_USERPASSWORD_MAX_LENGTH];
}PASSWORD_STORE;


#define  ID_LOGIN_AS_LAST                       0
#define  ID_LOGIN_ASK_ME                        1

#define ASK_BEFORE_LOGIN    (0xffffffff)

class CStringList
{
public:
                            CStringList();
    virtual                 ~CStringList();

    inline  int             GetLength       (void)      {return m_count;}
            void            AddString       (TCHAR*  lpszInString);
            void            RemoveString    (int    iIndex);
            TCHAR*          GetString       (int    iIndex);   
            void            Sort            ();
private:
    int         m_count;
    int         m_ptrCount;
    TCHAR**      m_strings;      
};

EXTERN_C void   MU_Init();
CStringList*    MU_GetUsernameList(void);
HRESULT         MU_UsernameToUserId(TCHAR *lpszUsername, GUID *puidUserId);
BOOL            MU_GetPasswordForUsername(TCHAR *lpszInUsername, TCHAR *szOutPassword, BOOL *pfUsePassword);
BOOL            MU_UsernameExists(TCHAR*    lpszUsername);
BOOL            MU_GetUserInfo(GUID *puidUserId, LPUSERINFO lpUserInfo);
BOOL            MU_SetUserInfo(LPUSERINFO lpUserInfo);
HRESULT         MU_SwitchToUser(TCHAR *lpszUsername);
void            MU_SwitchToLastUser();
HRESULT         MU_GetUserDirectoryRoot(GUID *uidUserID, DWORD dwFlags, WCHAR   *lpszUserRoot, int cch);
ULONG           MU_CountUsers(void);
HRESULT         MU_GetRegRootForUserID(GUID *puidUserId, LPSTR pszPath);
HRESULT         MU_CreateUser(LPUSERINFO   lpUserInfo);
HRESULT         MU_DeleteUser(GUID *puidUserId);
LPCTSTR         MU_GetRegRoot();
HRESULT         MU_MakeDefaultUser(GUID *puidUserId);
BOOL            MU_GetCurrentUserID(GUID *puidUserId);
BOOL            MU_GetDefaultUserID(GUID *puidUserId);
BOOL            MU_UserIdToUsername(GUID *puidUserId, TCHAR *lpszUsername, ULONG cch);
BOOL            MU_IdentitiesDisabled();
DWORD           MU_GetDefaultOptionIndex(HWND hwndCombo);
DWORD           MU_GetLoginOptionIndex(HWND hwndCombo);
void            MU_GetLoginOption(GUID *puidStartAs);
BOOL            MU_SetLoginOption(HWND hwndCombo,  LRESULT dOption);
BOOL            MU_CanEditIdentity(HWND hwndParent, GUID *puidIdentityId);
DWORD           MU_GenerateDirectoryNameForIdentity(GUID *puidIdentityId);
HRESULT         MU_GetDirectoryIdForIdentity(GUID *puidIdentityId, DWORD *pdwDirId);
HRESULT         MU_GetDirectoryIdForIdentity(GUID *puidIdentityId, DWORD *pdwDirId);
HRESULT         _ClaimNextUserId(GUID *puidUserId);
void            _MakeDefaultFirstUser();
BOOL            _FillListBoxWithUsernames(HWND hListbox);
BOOL            _FillComboBoxWithUsernames(HWND hCombobox, HWND hListbox);
void            _ResetRememberedLoginOption(void);
void            _RememberLoginOption(HWND hwndCombo);
void            _MigratePasswords();

#endif _MULTIUSR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\private.h ===
#include <windows.h>
#include <ole2.h>
#include <docobj.h>
#include <advpub.h>
#include <initguid.h>
#include "msident.h"
#include "factory.h"
#include "multiutl.h"
#include <ocidl.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shfusion.h>

#ifndef ASSERT
#ifdef DEBUG
#define ASSERT	Assert
#else
#define ASSERT(x)
#endif
#endif

#define IDENTITY_PASSWORDS
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

extern ULONG    g_cLock, g_cObj;
extern HANDLE   g_hMutex;
extern GUID     g_uidOldUserId;
extern GUID     g_uidNewUserId;
extern BOOL     g_fNotifyComplete;

inline ULONG DllLock()     { return ++g_cLock; }
inline ULONG DllUnlock()   { return --g_cLock; }
inline ULONG DllGetLock()  { return g_cLock; }

inline ULONG DllAddRef()   { return ++g_cObj; }
inline ULONG DllRelease()  { return --g_cObj; }
inline ULONG DllGetRef()   { return g_cObj; }

extern UINT WM_IDENTITY_CHANGED;
extern UINT WM_QUERY_IDENTITY_CHANGE;
extern UINT WM_IDENTITY_INFO_CHANGED;

#define CCH_USERPASSWORD_MAX_LENGTH         16
#define CCH_USERNAME_MAX_LENGTH             CCH_IDENTITY_NAME_MAX_LENGTH

//
// CUserIdentity object
//
class CUserIdentity : public IUserIdentity2
{
protected:
    ULONG           m_cRef;
    GUID            m_uidCookie;
    BOOL            m_fSaved;
    BOOL            m_fUsePassword;
    TCHAR           m_szUsername[CCH_USERNAME_MAX_LENGTH];
    TCHAR           m_szPassword[CCH_USERPASSWORD_MAX_LENGTH];


public:
    CUserIdentity();
    ~CUserIdentity();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IUserIdentity members
    STDMETHODIMP         GetCookie(GUID *puidCookie);
    STDMETHODIMP         OpenIdentityRegKey(DWORD dwDesiredAccess, HKEY *phKey);
    STDMETHODIMP         GetIdentityFolder(DWORD dwFlags, WCHAR *pszPath, ULONG ulBuffSize);
    STDMETHODIMP         GetName(WCHAR *pszName, ULONG ulBuffSize);

    // IUserIdentity2 members
    STDMETHODIMP         GetOrdinal(DWORD* pdwOrdinal);
    STDMETHODIMP         SetName(WCHAR *pszName);
    STDMETHODIMP         ChangePassword(WCHAR *szOldPass, WCHAR *szNewPass);

    // Other members
    STDMETHODIMP         SetPassword(WCHAR *pszPassword);
    STDMETHODIMP         InitFromUsername(TCHAR *pszUsername);
    STDMETHODIMP         InitFromCookie(GUID *uidCookie);
private:
    STDMETHODIMP         _SaveUser();
};

//
// CEnumUserIdentity object
//
class CEnumUserIdentity : public IEnumUserIdentity
{
protected:
    ULONG           m_cRef;
    DWORD           m_dwCurrentUser;     // Maintain current index into the reg list
    DWORD           m_cCountUsers;      // number of accounts in the registry
    GUID           *m_rguidUsers;
    BOOL            m_fInited;

public:
    CEnumUserIdentity();
    ~CEnumUserIdentity();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumUserIdentity members
    STDMETHODIMP         Next(ULONG celt, IUnknown **rgelt, ULONG *pceltFetched);
    STDMETHODIMP         Skip(ULONG celt);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumUserIdentity **ppenum);
    STDMETHODIMP         GetCount(ULONG *pnCount);

private:
    // Other methods
    STDMETHODIMP         _Init();
    STDMETHODIMP         _Init(DWORD dwCurrentUser, DWORD dwCountUsers, GUID *prguidUserCookies);
    STDMETHODIMP         _Cleanup();
};


//
// CUserIdentityManager object
//
class CUserIdentityManager :
    public IUserIdentityManager,
    public IConnectionPoint,
    public IPrivateIdentityManager,
    public IPrivateIdentityManager2
{
protected:
    ULONG               m_cRef;
    CRITICAL_SECTION    m_rCritSect;
    CNotifierList       *m_pAdviseRegistry;
	BOOL				m_fWndRegistered;
	HWND				m_hwnd;

public:
    CUserIdentityManager();
    ~CUserIdentityManager();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IUserIdentityManager members
    STDMETHODIMP        EnumIdentities(IEnumUserIdentity **ppEnumUserIdentity);
    STDMETHODIMP        ManageIdentities(HWND hwndParent, DWORD dwFlags);
    STDMETHODIMP        Logon(HWND hwndParent, DWORD dwFlags, IUserIdentity **ppUserIdentity);
    STDMETHODIMP        Logoff(HWND hwndParent);
    STDMETHODIMP        GetIdentityByCookie(GUID *uidCookie, IUserIdentity **ppUserIdentity);

    // IConnectionPoint functions
    STDMETHODIMP        GetConnectionInterface(IID *pIID);        
    STDMETHODIMP        GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
    STDMETHODIMP        Advise(IUnknown *pUnkSink, DWORD *pdwCookie);        
    STDMETHODIMP        Unadvise(DWORD dwCookie);        
    STDMETHODIMP        EnumConnections(IEnumConnections **ppEnum);

    // IPrivateIdentityManager functions
    STDMETHODIMP        CreateIdentity(WCHAR *pszName, IUserIdentity **ppIdentity);
    STDMETHODIMP        ConfirmPassword(GUID *uidCookie, WCHAR *pszPassword);

    // IPrivateIdentityManager2 functions
    STDMETHODIMP        CreateIdentity2(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity);
    STDMETHODIMP        DestroyIdentity(GUID *uidCookie);
    STDMETHODIMP        LogonAs(WCHAR *pszName, WCHAR *pszPassword, IUserIdentity **ppIdentity);
    STDMETHODIMP        SetDefaultIdentity(GUID *uidCookie);
    STDMETHODIMP        GetDefaultIdentity(GUID *uidCookie);

    // Other methods
    STDMETHODIMP        QuerySwitchIdentities();
    STDMETHODIMP        NotifySwitchIdentities();

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static STDMETHODIMP     ClearChangingIdentities();

private:
    STDMETHODIMP        _NotifyIdentitiesSwitched();
    STDMETHODIMP        _QueryProcessesCanSwitch();
    STDMETHODIMP        _CreateWindowClass();
    STDMETHODIMP        _SwitchToUser(GUID *puidFromUser, GUID *puidToUser);
    STDMETHODIMP        _PersistChangingIdentities();
    STDMETHODIMP        _LoadChangingIdentities();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msident.rc
//
#define idiUser                         50
#define idiPasswordKeys2                51
#define idiLogin                        52
#define iddUserProperties               101
#define idiYellow                       103
#define idiKeys                         106
#define iddManager                      107
#define iddPasswordOff                  183
#define iddChgPwd                       184
#define iddDeleteUser                   185
#define iddConfirmUserDelete            186
#define iddConfirmPwd                   187
#define iddLogin                        188
#define iddChgUser                      189
#define iddNewPwd                       190
#define iddNewUser                      191
#define idcAdd                          1001
#define idcNewPwd                       1002
#define idcChkUsePwd                    1003
#define idcPwd                          1004
#define idcProperties                   1005
#define idcConfPwd                      1006
#define idcClose                        1007
#define idcUserName                     1008
#define idcDefault                      1009
#define idcOldPwd                       1010
#define idcStartupCombo                 1011
#define idcDelete                       1012
#define idcStaticName                   1013
#define idcDefaultCombo                 1013
#define idcUserNameList                 1014
#define idcDeleteMsgs                   1015
#define idcStaticNames                  1016
#define idcErrorMsg                     1017
#define idcWarningIcon                  1018
#define idcConfirmMsg                   1019
#define idcStaticUserName               1020
#define idcWelcomeMsg                   1021
#define idcAddUser                      1022
#define idcPwdCaption                   1023
#define idcUsePwd                       1024
#define idcChgPwd                       1025
#define idcAddUsername                  1026
#define idcConfirmPwd                   1027
#define idcManage                       1028
#define idcTellMeMore                   1029
#define idcStaticStartUp                1030
#define idcNoteMsg                      1031
#define idcCheckDefault                 1032
#define idcLogoff                       1033
#define idcLoginInstr                   1034
#define STR_FIRST                       20000
#define idsPwdNotMatch                  20005
#define idsPwdError                     20007
#define idsPwdDoesntMatch               20010
#define idsPwdChgNotMatch               20011
#define idsConfirmDeleteMsg             20012
#define idsConfirmDelPwd                20013
#define idsConfirmDisablePwd            20014
#define idsUserNameExists               20015
#define idsUserNameInUse                20016
#define idsCantDeleteCurrUser           20017
#define idsCantDeleteUser               20018
#define idsLoginAsUser                  20019
#define idsUserAdded                    20020
#define idsSwitchUser                   20021
#define idsMaintainConnection           20022
#define idsUserNameTooShort             20023
#define idsNameTooShort                 20024
#define idsMainUser                     20025
#define idsRootDirName                  20026
#define idsDefault                      20027
#define idsLoginDefault                 20028
#define idsLoginLast                    20029
#define idsLoginAsk                     20030
#define idsSwitchCancelled              20031
#define idsSwitchCancelCaption          20032
#define idsLogoutCancelled              20033
#define idsConfirmEdit                  20034
#define idsIdentityLogin                20035
#define idsSwitchIdentities             20036
#define idsIdentityProperties           20037
#define idsNewIdentity                  20038
#define idsLoginWithCurrent             20039
#define idsLoginNoCurrent               20040
#define idsLogoff                       20041
#define idsConfirmLogoff                20042
#define idsNameCantBeDefault            20043
#define idsNameProblem                  20044
#define idsSwitchInProgressSwitch       20045
#define idsSwitchInProgressLaunch       20046
#define idsNoIdentityInstr              20047
#define idsCurrIdentityInstr            20048
#define idsPwdNotFound                  20049
#define IDC_STATIC                      -1
#define IDC_UNUSED                      -1
#define IDC_NO_HELP_1                   650
#define IDC_NO_HELP_2                   651
#define IDC_NO_HELP_3                   652
#define IDC_NO_HELP_4                   653
#define IDC_NO_HELP_5                   654
#define NO_HELP                         -1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msidle\sage\sage.inc ===
WM_USER equ 0400h

WM_SAGE_MSG equ WM_USER+5

VSageID equ Undefined_Device_ID

ERROR_NoT_SUPPORTED equ 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msidle\msidle.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       msidle.h
//
//  Contents:   Types and prototypes for idle detection callback dll
//
//  Classes:
//
//  Functions:
//
//  History:    05-26-1997  darrenmi (Darren Mitchell) Created
//
//----------------------------------------------------------------------------

//
// Idle callback type
//
typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

//
// BeginIdleDetection - start monitoring idleness
//
// pfnCallback - function to call back when idle state changes
// dwIdleMin - minutes of inactivity before idle callback
// dwReserved - must be 0
//
// Returns: 0 on success, error code on failure
//
// Note: Exported as ordinal 3
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved);

typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);

//
// EndIdleDetection - stop monitoring idleness
//
// Returns: TRUE on success, FALSE on failure
//
// Note: Exported as ordinal 4
//
BOOL EndIdleDetection(DWORD dwReserved);

typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD, DWORD);

//
// SetIdleTimeout - Set minutes for idle timeout and reset idle state
//
// dwMinutes - new minutes threshold for idleness
// fResetState - flag to return to non-idle state to retrigger idle callback
// dwReserved - must be 0
//
// Note: Exported as ordinal 5
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved);

typedef BOOL (WINAPI* _SETIDLETIMEOUT) (DWORD, DWORD);

//
// SetIdleNotify - Turns on or off notification when idle
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 6
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETIDLENOTIFY) (BOOL, DWORD);

//
// SetBusyNotify - Turns on or off notification when busy
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 7
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETBUSYNOTIFY) (BOOL, DWORD);

//
// GetIdleMinutes
//
// dwReserved - must be 0
//
// Returns number of minutes since user's last activity
//
// Note: Exported as ordinal 8
//
DWORD GetIdleMinutes(DWORD dwReserved);

typedef DWORD (WINAPI* _GETIDLEMINUTES) (DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msidle\sage\sage.asm ===
PAGE 58,132
;******************************************************************************
TITLE SAGE - SAGE VxD
;******************************************************************************
;
;   Title:      SAGE.ASM - SAGE VxD
;
;   Version:    0.060
;
;   Date:       04/18/95
;
;   Author:     Bob Eichenlaub    
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV                 DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;     04/18/95      Initial version - be
;     07/06/95      serial IRQ detection - be; credit to rjc for the basic approach
;     05/23/97      [darrenmi] major clean-up and support multiple clients
;                   for IE4
;
;==============================================================================

        .386p

;******************************************************************************
;                             I N C L U D E S
;******************************************************************************

        .XLIST
        INCLUDE VMM.Inc
        INCLUDE VWIN32.Inc
        INCLUDE VPICD.Inc
 WIN41SERVICES equ 1		; need _SHELL_Update_User_Activity_Ex service
        INCLUDE SHELL.Inc
        INCLUDE VXDLDR.Inc
        INCLUDE regdef.Inc
        INCLUDE Debug.Inc
        INCLUDE Sage.Inc
        .LIST

;public SAGE_Update_User_Activity

;******************************************************************************
;              V I R T U A L   D E V I C E   D E C L A R A T I O N
;------------------------------------------------------------------------------
; The VxD declaration statement defines the VxD name, version number,
; control proc entry point, VxD ID, initialization order, and VM API 
; entry points.
;
; - Defined VxD ID: See VXDID.TXT for more information
; - Init order: If serial port detection is enabled then this Vxd MUST loaded
;               before VCOMM.VxD and after VPICD.VxD,
;               See VMM.INC for the complete
;               definition of the init order of the standard devices.
;               
;******************************************************************************

Declare_Virtual_Device sage, 1, 0, SAGE_Control, VSageID, UNDEFINED_INIT_ORDER

;******************************************************************************
;                                D A T A
;******************************************************************************

;
; Locked data
;
VxD_LOCKED_DATA_SEG

Window_List             dd  0, 0, 0, 0, 0, 0, 0, 0
cClients                dd  0       ; number of valid windows in window list
Time_Out_Idle           dd  10000   ; the interval between message posts
Time_Out_Handle         dd  0       ; Handle to the global time out we create
PtrSHELL_SUUAE_INFO	dd  0	    ; pointer to the SHELL_SUUAE_INFO structure
PrevActiveDisplay	dd  0       ; last screen or user input activity
PrevActiveSystem        dd  0       ; last system activity
Hooked_Proc             dd  0       ; shell's user_activity entry that we hooked

; Fake user activity info structure in case on Win95.
FakeSUUAE_INFO	_SHELL_SUUAE_INFO <0,0,0,0,0>

VxD_LOCKED_DATA_ENDS

;******************************************************************************
;                               C O D E
;------------------------------------------------------------------------------
; The 'body' of the VxD is in the standard code segment.
;******************************************************************************

VxD_CODE_SEG

BeginProc SAGE_Start_Idle_Timer

        push    esi

        ; check to see if we've already got a timer
        mov     esi, [Time_Out_Handle]
        test    esi, esi
        jnz     start1

        ; get a timer
        mov     eax, [Time_Out_Idle]
        mov     esi, OFFSET32 SAGE_User_Idle_Check
        VMMCall Set_Global_Time_Out
        mov     [Time_Out_Handle], esi

start1:
        pop     esi
        ret

EndProc SAGE_Start_Idle_Timer

BeginProc SAGE_Stop_Idle_Timer

        push    esi

        ; check to see if we have a timer
        mov     esi, [Time_Out_Handle]
        test    esi, esi
        jz      stop1

        ; kill it
        VMMCall Cancel_Time_Out
        xor     esi, esi
        mov     [Time_Out_Handle], esi

stop1:
        pop     esi
        ret

EndProc SAGE_Stop_Idle_Timer


;******************************************************************************
;
;   SAGE_Device_IO
;
;   DESCRIPTION:
;       This is the routine that is called when the CreateFile or
;       DeviceIoControl is made
;
;   ENTRY:
;       ESI = Pointer to args (see VWIN32.INC for struct definition)
;
;   EXIT:
;       EAX = return value
;
;   USES:
;       flags
;
;==============================================================================

BeginProc SAGE_Device_IO

        mov     ecx, [esi.dwIOControlCode]
        test    ecx, ecx
        jnz     next1

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; DIOC_GETVERSION
        ;

        ; obtain a pointer to the shell vxd's activity timer info
        cmp	[PtrSHELL_SUUAE_INFO], 0
        jne	short getver1
        VxDCall	SHELL_Get_Version
        cmp	eax, 040Ah
        jae	short haveSUUAEX

	; Running on Win95 so we don't have SHELL_Update_User_Activty_Ex service,
	; hook the shell vxd's activity service to watch activity.
        mov     esi, offset32 SAGE_Update_User_Activity
        GetVxDServiceOrdinal eax, SHELL_Update_User_Activity
        VMMCall Hook_Device_Service
	mov	eax, offset32 FakeSUUAE_INFO
	jmp	short setSUUAE_INFO

haveSUUAEX:
	VxDCall _SHELL_Update_User_Activity_Ex, <SUUAE_CONTINUOUS OR SUUAE_CONTINUOUS_CHECK>
setSUUAE_INFO:
	mov     [PtrSHELL_SUUAE_INFO], eax	; (eax) = ptr to SHELL_SUAAE_INFO structure
        
getver1:
        xor     eax, eax                    ; success
        ret

next1:
        cmp     ecx,-1
        jne     next2

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; DIOC_CLOSE
        ;

        ; see if we have clients to close
        cmp     [cClients], 0
        jz      close1

        ; we do... see if it's the last one...
        dec     [cClients]
        cmp     [cClients], 0
        jnz     close1

        ; last client going away - clean up
        call    SAGE_Stop_Idle_Timer

        cmp     [PtrSHELL_SUUAE_INFO], offset32 FakeSUUAE_INFO
        jne     short close1

        ; unhook activity service
        GetVxDServiceOrdinal    eax,SHELL_Update_User_Activity
        mov     esi, offset32 SAGE_Update_User_Activity
        VMMCall Unhook_Device_Service
        xor	eax, eax
	mov     [PtrSHELL_SUUAE_INFO], eax	; clear pointer

close1:
        xor     eax,eax     ; success
        ret

next2:
        cmp     ecx,1
        jne     next3

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; Set handle and timeout
        ;
        mov     ebx, [esi.lpvInBuffer]

        ; Try to find window handle
        mov     eax, [ebx]
        mov     ecx, [cClients]
        test    ecx, ecx
        jz      addtolist

ioloop:
        cmp     eax, [Window_List + 4 * ecx - 4]
        je      timeout

        dec     ecx
        jnz     ioloop

        ; Can't find it - add it to window list
        mov     ecx, [cClients]
        cmp     ecx, 8
        jnl     timeout

addtolist:
        inc     [cClients]
        mov     [Window_List + 4 * ecx], eax

timeout:
        ; update timeout if specified
        mov     eax, [ebx+8]
        test    eax, eax
        jz      config1

        mov     [Time_Out_Idle], eax

config1:
        call    SAGE_Start_Idle_Timer

        xor     eax, eax    ; success
        ret
next3:
        cmp     ecx, 2
        jne     next4

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; Query last activity
        ;
        mov     ebx, [esi.lpvInBuffer]
        mov	edx, [PtrSHELL_SUUAE_INFO]
	.errnz ssiHoldSystem-ssiHoldDisplay-1
	cmp     word ptr [edx].ssiHoldDisplay, 0
	jne     short lact1		; system or display in "hold" state
	mov	eax, [edx].ssiTimeLastActiveDisplay
	cmp	eax, [edx].ssiTimeLastActiveSystem
	jae	short lact2
	mov	eax, [edx].ssiTimeLastActiveSystem
	jmp	short lact2

lact1:	VMMCall	Get_Last_Updated_System_Time
lact2:  mov     [ebx], eax
        xor     eax, eax
        ret

next4:

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;
        ; some unsupported value...
        ;
        mov     eax, ERROR_NOT_SUPPORTED
        ret

EndProc SAGE_Device_IO


VxD_CODE_ENDS



;******************************************************************************
;                      P A G E   L O C K E D   C O D E
;------------------------------------------------------------------------------
;       Memory is a scarce resource. Use this only where necessary.
;******************************************************************************
VxD_LOCKED_CODE_SEG

;******************************************************************************
;
;   SAGE_Control
;
;   DESCRIPTION:
;
;       This is a call-back routine to handle the messages that are sent
;       to VxD's to control system operation. Every VxD needs this function
;       regardless if messages are processed or not. The control proc must
;       be in the LOCKED code segment.
;
;       The Control_Dispatch macro used in this procedure simplifies
;       the handling of messages. To handle a particular message, add
;       a Control_Dispatch statement with the message name, followed
;       by the procedure that should handle the message. 
;
;   ENTRY:
;       EAX = Message number
;       EBX = VM Handle
;
;==============================================================================

BeginProc SAGE_Control

        Control_Dispatch W32_DEVICEIOCONTROL, SAGE_Device_IO
        clc
        ret

EndProc SAGE_Control


BeginDoc
;******************************************************************************
;
; SAGE_Update_User_Activity
;
; DESCRIPTION:
;
;   This service is called by VMD, VKD to tell us that user input occured
; ENTRY:    None
; EXIT:     None
; USES:     NONE
;==============================================================================
EndDoc
BeginProc SAGE_Update_User_Activity, HOOK_PROC, Hooked_Proc

    push    eax

    ; save off the time
    VMMCall Get_Last_Updated_System_Time
    mov     [FakeSUUAE_INFO.ssiTimeLastActiveDisplay], eax

    pop     eax
    jmp     Hooked_Proc

EndProc SAGE_Update_User_Activity


VxD_LOCKED_CODE_ENDS

VxD_PAGEABLE_CODE_SEG

;******************************************************************************
;
; SAGE_User_Idle_Check
;
; DESCRIPTION:
;
;   This checks if key/mouse or serial port (comm) event has occurred.
;
; Entry:
;   None
; Exit:
;   None
; Uses:
;   ALL
;******************************************************************************

BeginProc SAGE_User_Idle_Check,High_Freq,PUBLIC                                 
                                                                                
    ;                                                                           
    ; clear handle                                                              
    ;                                                                           
    xor     ecx, ecx                                                            
    mov     [Time_Out_Handle], ecx                                              
                                                                                
    ;                                                                           
    ; check for idleness                                                        
    ;                                                                           
    mov     eax, [PtrSHELL_SUUAE_INFO]	; (eax) = ptr to SHELL_SUAAE_INFO structure
    .errnz ssiHoldSystem-ssiHoldDisplay-1
    cmp     word ptr [eax].ssiHoldDisplay, 0
    jne     short holdActive		; system or display in "hold" state
    mov	    ecx, [eax].ssiTimeLastActiveDisplay
    mov	    edx, [eax].ssiTimeLastActiveSystem
    cmp	    ecx, [PrevActiveDisplay]
    jne	    notIdle			; display activity changed
    cmp     edx, [PrevActiveSystem]
    je      ResetTimer			; no display or system activity since last time

    ;                                                                           
    ; Not idle so post a message to all clients who want to know
    ;                     
notIdle:
    mov     [PrevActiveDisplay], ecx	; update idle times for next time
    mov     [PrevActiveSystem], edx
holdActive:
    
    xor     eax, eax                                                            
    mov     ecx, [cClients]
    test    ecx, ecx                                                            
    jz      ResetTimer                                                          

loop0:

    ; get next window
    mov     ebx, [4 * ecx + Window_List - 4]

    ; skip if it's -1
    cmp     ebx, -1
    je      loop1
                                                                                
    ; post message
    push    ecx
    VxDCall _SHELL_PostMessage, <ebx, WM_SAGE_MSG, eax, eax, eax, eax>          
    pop     ecx

loop1:
    dec     ecx
    jnz     loop0

    ;                                                                           
    ; reset the timer so we check again later                                   
    ;                                                                           
ResetTimer:                                                                     
    call    SAGE_Start_Idle_Timer
    ret                                                                         
                                                                                
EndProc SAGE_User_Idle_Check                                                    

VxD_PAGEABLE_CODE_ENDS


;******************************************************************************
;                       R E A L   M O D E   C O D E
;******************************************************************************

;******************************************************************************
;
;       Real mode initialization code
;
;   DESCRIPTION:
;       This code is called when the system is still in real mode, and
;       the VxDs are being loaded.
;
;       This routine as coded shows how a VxD (with a defined VxD ID)
;       could check to see if it was being loaded twice, and abort the 
;       second without an error message. Note that this would require
;       that the VxD have an ID other than Undefined_Device_ID. See
;       the file VXDID.TXT more details.
;
;   ENTRY:
;       AX = VMM Version
;       BX = Flags
;               Bit 0: duplicate device ID already loaded 
;               Bit 1: duplicate ID was from the INT 2F device list
;               Bit 2: this device is from the INT 2F device list
;       EDX = Reference data from INT 2F response, or 0
;       SI = Environment segment, passed from MS-DOS
;
;   EXIT:
;       BX = ptr to list of pages to exclude (0, if none)
;       SI = ptr to list of instance data items (0, if none)
;       EDX = DWORD of reference data to be passed to protect mode init
;
;==============================================================================

VxD_REAL_INIT_SEG

BeginProc SAGE_Real_Init_Proc

        test    bx, Duplicate_Device_ID ; check for already loaded
        jnz     short duplicate         ; jump if so

        xor     bx, bx                  ; no exclusion table
        xor     si, si                  ; no instance data table
        xor     edx, edx                ; no reference data

        mov     ax, Device_Load_Ok
        ret

duplicate:
        mov     ax, Abort_Device_Load + No_Fail_Message
        ret

EndProc SAGE_Real_Init_Proc


VxD_REAL_INIT_ENDS


        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msident\strconst.h ===
/*----------------------------------------------------------------------------
    strconst.h
        Non-localizable String constant definitions

 ----------------------------------------------------------------------------*/
#ifndef _STRCONST_H
#define _STRCONST_H


#ifndef WIN16
#ifdef DEFINE_STRING_CONSTANTS
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#else
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif
#else // !WIN16
#ifdef DEFINE_STRING_CONSTANTS
#ifdef __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y
#else  // __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#endif // __WATCOMC__
#else
#ifdef __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#else  // __WATCOMC__
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif // __WATCOMC__
#endif

#endif // !WIN16

#define STR_REG_PATH_ROOT           "Identities"

// --------------------------------------------------------------------------
// MultiUser
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegRoot,             STR_REG_PATH_ROOT);
STR_GLOBAL(c_szUserDirPath,         "Application Data\\Identities\\");
STR_GLOBAL(c_szUsername,            "Username");
STR_GLOBAL(c_szUserID,              "User ID");
STR_GLOBAL(c_szDirName,             "Directory Name");
STR_GLOBAL(c_szUsePassword,         "Use Password");
STR_GLOBAL(c_szPassword,            "Password");
STR_GLOBAL(c_szLastUserID,          "Last User ID");
STR_GLOBAL(c_szLastUserName,        "Last Username");
STR_GLOBAL(c_szDefaultUserID,       "Default User ID");
STR_GLOBAL(c_szDefaultUserName,     "Default Username");
STR_GLOBAL(c_szPolicyKey,           "Locked Down");
STR_GLOBAL(c_szLoginAs,             "Start As");
STR_GLOBAL(c_szRegFolders,          "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
STR_GLOBAL(c_szValueAppData,        "AppData");
STR_GLOBAL(c_szNotifyWindowClass,   "Identity Mgr Notify");
STR_GLOBAL(c_szCtxHelpFile,         "ident.hlp");
STR_GLOBAL(c_szIdentitiesFolderName,"Identities");
STR_GLOBAL(c_szEnableDCPolicyKey,   "DCPresent Enable");
STR_GLOBAL(c_szMigrated5,           "Migrated5");
STR_GLOBAL(c_szIdentityOrdinal,     "Identity Ordinal");
STR_GLOBAL(c_szOutgoingID,          "OutgoingID");
STR_GLOBAL(c_szIncomingID,          "IncomingID");
STR_GLOBAL(c_szChanging,            "Changing");

#endif  //_STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msidle\msidle.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       msidle.cpp
//
//  Contents:   user idle detection
//
//  Classes:
//
//  Functions:
//
//  History:    05-14-1997  darrenmi (Darren Mitchell) Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "msidle.h"
#include "resource.h"

// useful things...
#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

//
// Global unshared variables
//
DWORD   g_dwIdleMin = 0;                // inactivity minutes before idle
UINT_PTR g_uIdleTimer = 0;              // idle timer for this process
BOOL    g_fIdleNotify = FALSE;          // notify when idle
BOOL    g_fBusyNotify = FALSE;          // notify when busy
BOOL    g_fIsWinNT = FALSE;             // which platform?
BOOL    g_fIsWinNT5 = FALSE;            // are we running on NT5?
BOOL    g_fIsWhistler = FALSE;          // are we running on Whistler?
HANDLE  g_hSageVxd = INVALID_HANDLE_VALUE;
                                        // handle to sage.vxd
DWORD   g_dwIdleBeginTicks = 0;         // ticks when we became idle
HINSTANCE g_hInst = NULL;               // dll instance
_IDLECALLBACK g_pfnCallback = NULL;     // function to call back in client

#ifdef MSIDLE_DOWNLEVEL
//
// Global shared variables
//
#pragma data_seg(".shrdata")

HHOOK   sg_hKbdHook = NULL, sg_hMouseHook = NULL;
DWORD   sg_dwLastTickCount = 0;
POINT   sg_pt = {0,0};

#pragma data_seg()

//
// Prototypes
//
LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK KbdProc(int nCode, WPARAM wParam, LPARAM lParam);
#endif // MSIDLE_DOWNLEVEL

VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

//
// From winuser.h, but NT5 only
//
#if (_WIN32_WINNT < 0x0500)
typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;
#endif

//
// NT5 api we dynaload from user32
//
typedef WINUSERAPI BOOL (WINAPI* PFNGETLASTINPUTINFO)(PLASTINPUTINFO plii);

PFNGETLASTINPUTINFO pfnGetLastInputInfo = NULL;

///////////////////////////////////////////////////////////////////////////
//
//                     Internal functions
//
///////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue, 
                   void *pData, DWORD dwBytes)
{
    long    lResult;
    HKEY    hkey;
    DWORD   dwType;

    lResult = RegOpenKey(hkeyRoot, pszKey, &hkey);
    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    lResult = RegQueryValueEx(hkey, pszValue, NULL, &dwType, (BYTE *)pData, 
        &dwBytes);
    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS) 
        return FALSE;
    
    if(dwType == REG_SZ) {
        // null terminate string
        ((TCHAR *)pData)[dwBytes] = 0;
    }

    return TRUE;
}

TCHAR *g_pszLoggingFile;
BOOL  g_fCheckedForLog = FALSE;

DWORD LogEvent(LPTSTR pszFormat, ...)
{

    // check registry if necessary
    if(FALSE == g_fCheckedForLog) {

        TCHAR   pszFilePath[MAX_PATH];

        if(ReadRegValue(HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\msidle"),
                TEXT("LoggingFile"), pszFilePath, MAX_PATH)) {

            g_pszLoggingFile = (TCHAR *)LocalAlloc(LPTR, lstrlen(pszFilePath) + 1);
            if(g_pszLoggingFile) {
                lstrcpy(g_pszLoggingFile, pszFilePath);
            }
        }

        g_fCheckedForLog = TRUE;
    }

    if(g_pszLoggingFile) {

        TCHAR       pszString[1024];
        SYSTEMTIME  st;
        HANDLE      hLog;
        DWORD       dwWritten;
        va_list     va;

        hLog = CreateFile(g_pszLoggingFile, GENERIC_WRITE, 0, NULL,
                OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if(INVALID_HANDLE_VALUE == hLog)
            return GetLastError();

        // seek to end of file
        SetFilePointer(hLog, 0, 0, FILE_END);

        // dump time
        GetLocalTime(&st);
        wsprintf(pszString, "%02d:%02d:%02d [%x] - ", st.wHour, st.wMinute, st.wSecond, GetCurrentThreadId());
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);
        OutputDebugString(pszString);

        // dump passed in string
        va_start(va, pszFormat);
        wvsprintf(pszString, pszFormat, va);
        va_end(va);
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);
        OutputDebugString(pszString);

        // cr
        WriteFile(hLog, "\r\n", 2, &dwWritten, NULL);
        OutputDebugString("\r\n");

        // clean up
        CloseHandle(hLog);
    }

    return 0;
}

#endif // DEBUG

//
// SetIdleTimer - decide how often to poll and set the timer appropriately
//
void SetIdleTimer(void)
{
    UINT uInterval = 1000 * 60;

    //
    // If we're looking for loss of idle, check every 4 seconds
    //
    if(TRUE == g_fBusyNotify) {
        uInterval = 1000 * 4;
    }

    //
    // kill off the old timer
    //
    if(g_uIdleTimer) {
        KillTimer(NULL, g_uIdleTimer);
    }

    //
    // Set the timer
    //
    g_uIdleTimer = SetTimer(NULL, 0, uInterval, OnIdleTimer);
}
       
DWORD GetLastActivityTicks(void)
{
    DWORD dwLastActivityTicks = 0;

    if (g_fIsWhistler) {

        dwLastActivityTicks = USER_SHARED_DATA->LastSystemRITEventTickCount;

    } else if(g_fIsWinNT5 && pfnGetLastInputInfo) {
        // NT5: Use get last input time API
        LASTINPUTINFO lii;

        memset(&lii, 0, sizeof(lii));
        lii.cbSize = sizeof(lii);
        (*pfnGetLastInputInfo)(&lii);
        dwLastActivityTicks = lii.dwTime;
    } else {
        // NT4 or Win95: Use sage if it's loaded
        if(INVALID_HANDLE_VALUE != g_hSageVxd) {
            // query sage.vxd for tick count
            DeviceIoControl(g_hSageVxd, 2, &dwLastActivityTicks, sizeof(DWORD),
                NULL, 0, NULL, NULL);
        }
#ifdef MSIDLE_DOWNLEVEL
    else {
            // use hooks
            dwLastActivityTicks = sg_dwLastTickCount;
        }
#endif // MSIDLE_DOWNLEVEL
    }

    return dwLastActivityTicks;
}

//
// OnIdleTimer - idle timer has gone off
//
VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    DWORD   dwDiff, dwLastActivityTicks;
    BOOL    fTempBusyNotify = g_fBusyNotify;
    BOOL    fTempIdleNotify = g_fIdleNotify;

    //
    // get last activity ticks from sage or shared segment
    //
    dwLastActivityTicks = GetLastActivityTicks();

#ifdef DEBUG
    LogEvent("OnIdleTimer: dwLastActivity=%d, CurrentTicks=%d, dwIdleBegin=%d", dwLastActivityTicks, GetTickCount(), g_dwIdleBeginTicks);
#endif

    //
    // check to see if we've changed state
    //
    if(fTempBusyNotify) {
        //
        // Want to know if we become busy
        //
        if(dwLastActivityTicks != g_dwIdleBeginTicks) {
            // activity since we became idle - stop being idle!
            g_fBusyNotify = FALSE;
            g_fIdleNotify = TRUE;

            // set the timer
            SetIdleTimer();

            // call back client
#ifdef DEBUG
            LogEvent("OnIdleTimer: Idle Ends");
#endif
            if(g_pfnCallback)
                (g_pfnCallback)(STATE_USER_IDLE_END);
        }

    }

    if(fTempIdleNotify) {
        //
        // Want to know if we become idle
        //
        dwDiff = GetTickCount() - dwLastActivityTicks;

        if(dwDiff > 1000 * 60 * g_dwIdleMin) {
            // Nothing's happened for our threshold time.  We're now idle.
            g_fIdleNotify = FALSE;
            g_fBusyNotify = TRUE;

            // save time we became idle
            g_dwIdleBeginTicks = dwLastActivityTicks;

            // set the timer
            SetIdleTimer();

            // call back client
#ifdef DEBUG
            LogEvent("OnIdleTimer: Idle Begins");
#endif
            if(g_pfnCallback)
                (g_pfnCallback)(STATE_USER_IDLE_BEGIN);
        }
    }
}

BOOL LoadSageVxd(void)
{
    int inpVXD[3];

    if(INVALID_HANDLE_VALUE != g_hSageVxd)
        return TRUE;

    g_hSageVxd = CreateFile("\\\\.\\sage.vxd", 0, 0, NULL, 0,
            FILE_FLAG_DELETE_ON_CLOSE, NULL);

    // can't open it?  can't use it
    if(INVALID_HANDLE_VALUE == g_hSageVxd)
        return FALSE;

    // start it monitoring
    inpVXD[0] = -1;                         // no window - will query
    inpVXD[1] = 0;                          // unused
    inpVXD[2] = 0;                          // how long to wait between checks

    DeviceIoControl(g_hSageVxd, 1, &inpVXD, sizeof(inpVXD), NULL, 0, NULL, NULL);

    return TRUE;
}

BOOL UnloadSageVxd(void)
{
    if(INVALID_HANDLE_VALUE != g_hSageVxd) {
        CloseHandle(g_hSageVxd);
        g_hSageVxd = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//
//                   Externally callable functions
//
///////////////////////////////////////////////////////////////////////////

//
// LibMain - dll entry point
//
EXTERN_C BOOL WINAPI LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvRes)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        {
        OSVERSIONINFO vi;

        DisableThreadLibraryCalls(hInst);
        g_hInst = hInst;

        vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&vi);
        if(vi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            g_fIsWinNT = TRUE;
            if(vi.dwMajorVersion >= 5) {
                if (vi.dwMajorVersion > 5 || vi.dwMinorVersion > 0 || LOWORD(vi.dwBuildNumber) > 2410) {
                    g_fIsWhistler = TRUE;
                } else {
                    g_fIsWinNT5 = TRUE;
                }
            }

        }
        }
        break;
    }

    return TRUE;
}

//
// BeginIdleDetection
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved)
{
    DWORD dwValue = 0;

    // make sure reserved is 0
    if(dwReserved)
        return ERROR_INVALID_DATA;

#ifdef DEBUG
    LogEvent("BeginIdleDetection: IdleMin=%d", dwIdleMin);
#endif

    // save callback
    g_pfnCallback = pfnCallback;

    // save minutes
    g_dwIdleMin = dwIdleMin;

    // call back on idle
    g_fIdleNotify = TRUE;

    if(FALSE == g_fIsWinNT) {
        // try to load sage.vxd
        LoadSageVxd();
    }

    if(g_fIsWinNT5) {
        // we need to find our NT5 api in user
        HINSTANCE hUser = GetModuleHandle("user32.dll");
        if(hUser) {
            pfnGetLastInputInfo =
                (PFNGETLASTINPUTINFO)GetProcAddress(hUser, "GetLastInputInfo");
        }

        if(NULL == pfnGetLastInputInfo) {
            // not on NT5 - bizarre
            g_fIsWinNT5 = FALSE;
        }
    }

#ifdef MSIDLE_DOWNLEVEL
    if(INVALID_HANDLE_VALUE == g_hSageVxd && FALSE == g_fIsWinNT5 && FALSE == g_fIsWhistler) {

        // sage vxd not available - do it the hard way

        // hook kbd
        sg_hKbdHook = SetWindowsHookEx(WH_KEYBOARD, KbdProc, g_hInst, 0);
        if(NULL == sg_hKbdHook)
            return GetLastError();
        
        // hook mouse
        sg_hMouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, g_hInst, 0);
        if(NULL == sg_hMouseHook) {
            DWORD dwError = GetLastError();
            EndIdleDetection(0);
            return dwError;
        }
    }
#endif // MSIDLE_DOWNLEVEL

    // Fire up the timer
    SetIdleTimer();

    return 0;
}

//
// IdleEnd - stop idle monitoring
//
BOOL EndIdleDetection(DWORD dwReserved)
{
    // ensure reserved is 0
    if(dwReserved)
        return FALSE;

    // free up sage if we're using it
    UnloadSageVxd();

    // kill timer
    if(g_uIdleTimer) {
        KillTimer(NULL, g_uIdleTimer);
        g_uIdleTimer = 0;
    }

    // callback is no longer valid
    g_pfnCallback = NULL;

#ifdef MSIDLE_DOWNLEVEL
    // free up hooks
    if(sg_hKbdHook) {
        UnhookWindowsHookEx(sg_hKbdHook);
        sg_hKbdHook = NULL;
    }

    if(sg_hMouseHook) {
        UnhookWindowsHookEx(sg_hMouseHook);
        sg_hMouseHook = NULL;
    }
#endif // MSIDLE_DOWNLEVEL

    return TRUE;
}

//
// SetIdleMinutes - set the timout value and reset idle flag to false
//
// dwMinutes   - if non-0, set idle timeout to that many minutes
// fIdleNotify - call back when idle for at least idle minutes
// fBusyNotify - call back on activity since Idle begin
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved)
{
    if(dwReserved)
        return FALSE;

#ifdef DEBUG
    LogEvent("SetIdleTimeout: dwIdleMin=%d", dwMinutes);
#endif

    if(dwMinutes)
        g_dwIdleMin = dwMinutes;

    return TRUE;
}

//
// SetIdleNotify - set flag to turn on or off idle notifications
//
// fNotify - flag
// dwReserved - must be 0
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved)
{
#ifdef DEBUG
    LogEvent("SetIdleNotify: fNotify=%d", fNotify);
#endif

    g_fIdleNotify = fNotify;
}

//
// SetIdleNotify - set flag to turn on or off idle notifications
//
// fNotify - flag
// dwReserved - must be 0
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved)
{
#ifdef DEBUG
    LogEvent("SetBusyNotify: fNotify=%d", fNotify);
#endif

    g_fBusyNotify = fNotify;

    if(g_fBusyNotify)
        g_dwIdleBeginTicks = GetLastActivityTicks();

    // set the timer
    SetIdleTimer();
}

//
// GetIdleMinutes - return how many minutes since last user activity
//
DWORD GetIdleMinutes(DWORD dwReserved)
{
    if(dwReserved)
        return 0;

    return (GetTickCount() - GetLastActivityTicks()) / 60000;
}

#ifdef MSIDLE_DOWNLEVEL
///////////////////////////////////////////////////////////////////////////
//
//                           Hook functions
//
///////////////////////////////////////////////////////////////////////////

//
// Note: These functions can be called back in any process!
//
LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    MOUSEHOOKSTRUCT * pmsh = (MOUSEHOOKSTRUCT *)lParam;

    if(nCode >= 0) {
        // ignore mouse move messages to the same point as all window
        // creations cause these - it doesn't mean the user moved the mouse
        if(WM_MOUSEMOVE != wParam || pmsh->pt.x != sg_pt.x || pmsh->pt.y != sg_pt.y) {
            sg_dwLastTickCount = GetTickCount();
            sg_pt = pmsh->pt;
        }
    }

    return(CallNextHookEx(sg_hMouseHook, nCode, wParam, lParam));
}

LRESULT CALLBACK KbdProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    if(nCode >= 0) {
        sg_dwLastTickCount = GetTickCount();
    }

    return(CallNextHookEx(sg_hKbdHook, nCode, wParam, lParam));
}
#endif // MSIDLE_DOWNLEVEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msidle\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msidle.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        169
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         1085
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msnspa\msnspa.c ===
/*****************************************************************************
 *
 *  MSNSPA.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      MSN SPA Proxy.
 *
 *      Proxies POP and NNTP for clients that don't speak them natively.
 *
 *      Runs as app that minimizes to nowhere.  Get it back by Alt+Tab'ing
 *      to it.
 *
 *****************************************************************************/

#include "msnspa.h"

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

HINSTANCE g_hinst;
HINSTANCE g_hinstSecur;
PSecurityFunctionTable g_psft;

#ifdef DBG
/*****************************************************************************
 *
 *  Squirt - Print a message
 *
 *****************************************************************************/

void __cdecl
Squirt(LPCTSTR ptszMsg, ...)
{
    TCHAR tsz[1024 + PLENTY_BIG];
    va_list ap;
    va_start(ap, ptszMsg);
    wvsprintf(tsz, ptszMsg, ap);

    OutputDebugString(tsz);
}
#endif

/*****************************************************************************
 *
 *  Die - Death
 *
 *****************************************************************************/

void __cdecl
Die(LPCTSTR ptszMsg, ...)
{
    TCHAR tsz[1024];
    va_list ap;
    va_start(ap, ptszMsg);
    wvsprintf(tsz, ptszMsg, ap);

    OutputDebugString(tsz);
    OutputDebugString(TEXT("\r\n"));
    ExitProcess(1);
}

/*****************************************************************************
 *
 *  IsNT
 *
 *****************************************************************************/

BOOL
IsNT(void)
{
    return (int)GetVersion() >= 0;
}

/*****************************************************************************
 *
 *  RFC1113 translation tables
 *
 *****************************************************************************/

const char RFC1113_From[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

const char RFC1113_To[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

#define chPad   '='

/*****************************************************************************
 *
 *  RFC1113_Encode
 *
 *  Convert a binary blob into an ASCII string using RFC1113 encoding.
 *  (I think it's RFC1113.  Boy would it be embarrassing if it weren't.)
 *
 *  szBuf - output buffer, will be null-terminated
 *  rgbIn - source buffer to be encoded
 *  cbIn  - number of bytes in source buffer
 *
 *****************************************************************************/

void
RFC1113_Encode(LPSTR szBuf, const BYTE *rgbIn, UINT cbIn)
{
   LPSTR psz = szBuf;
   UINT ib;

   unsigned char *outptr;
   unsigned int   i;

   for (ib = 0; ib < cbIn; ib += 3) {
      *psz++ = RFC1113_To[*rgbIn >> 2];
      *psz++ = RFC1113_To[((*rgbIn << 4) & 060) | ((rgbIn[1] >> 4) & 017)];
      *psz++ = RFC1113_To[((rgbIn[1] << 2) & 074) | ((rgbIn[2] >> 6) & 03)];
      *psz++ = RFC1113_To[rgbIn[2] & 077];

      rgbIn += 3;
   }

   /*
    *   If cbIn was not a multiple of 3, then we have encoded too
    *   many characters.  Adjust appropriately.
    */
   if (ib == cbIn + 1) {
      /* There were only 2 bytes in that last group */
      psz[-1] = chPad;
   } else if (ib == cbIn + 2) {
      /* There was only 1 byte in that last group */
      psz[-1] = chPad;
      psz[-2] = chPad;
   }

   *psz = '\0';

}

/*****************************************************************************
 *
 *  RFC1113_Decode
 *
 *  Convert an ASCII string back into a binary blob.
 *
 *  rgbOut - output buffer
 *  szIn   - source buffer
 *
 *  Returns number of bytes converted.
 *
 *****************************************************************************/

#define RFC1113x(ch) (RFC1113_From[(BYTE)(ch)] & 63)

int
RFC1113_Decode(LPBYTE rgbOut, LPSTR szIn)
{
    int nbytesdecoded;
    LPSTR psz;
    BYTE *rgb = rgbOut;
    int cchIn;
    int cbRc;

    /*
     *  Skip leading whitespace, just to be safe.
     */

    while (szIn[0] == ' ' || szIn[0] == '\t') {
        szIn++;
    }

    /*
     *  Figure out how many characters are in the input buffer.
     */
    psz = szIn;
    while (RFC1113_From[(BYTE)*psz] < 64) {
        psz++;
    }

    /*
     *  The caller will pad the input string to a multiple of 4 in
     *  length with chPad's.
     *
     *  Three bytes out for each four chars in.
     */
    cchIn = (int)(psz - szIn);

    cbRc = ((cchIn + 3) / 4) * 3;

    /*
     *  Now decode it.
     */
    psz = szIn;

    while (cchIn > 0) {
        *rgb++ =
            (BYTE)(RFC1113x(psz[0]) << 2 | RFC1113x(psz[1]) >> 4);
        *rgb++ =
            (BYTE) (RFC1113x(psz[1]) << 4 | RFC1113x(psz[2]) >> 2);
        *rgb++ =
            (BYTE) (RFC1113x(psz[2]) << 6 | RFC1113x(psz[3]));
        psz += 4;
        cchIn -= 4;
    }

    /*
     *  Now adjust the number of output bytes based on the number of
     *  input equal-signs.
     */
    if (cchIn & 3) {
        if(RFC1113_From[psz[-2]] > 63) {
            rgbOut[cbRc - 2] = 0;
            cbRc -= 2;
        } else {
            rgbOut[cbRc - 1] = 0;
            cbRc -= 1;
        }
    }

    return cbRc;
}

/*****************************************************************************
 *
 *  LoadSecurityManager
 *
 *  Obtain all the entry points into the security DLL.
 *
 *****************************************************************************/

BOOL
LoadSecurityManager(void)
{
    INIT_SECURITY_INTERFACE InitSecurityInterface;

    /*
     *  On NT, the security DLL is named SECURITY.DLL.
     *  On 95, the security DLL is named SECUR32.DLL.
     *
     *  Go figure.
     */
    g_hinstSecur = LoadLibrary(IsNT() ? TEXT("security.dll") :
                                        TEXT("secur32.dll"));
    if (!g_hinstSecur) {
        Squirt(TEXT("Can't load security manager") EOL);
        return FALSE;
    }

    InitSecurityInterface = (INIT_SECURITY_INTERFACE)
                            GetProcAddress(g_hinstSecur, SECURITY_ENTRYPOINT);

    if (!InitSecurityInterface) {
        Squirt(TEXT("Can't find entrypoint") EOL);
        return FALSE;
    }

    g_psft = InitSecurityInterface();
    if (!g_psft) {
        Squirt(TEXT("Unable to init security interface") EOL);
        return FALSE;
    }

    Squirt(TEXT("Security manager successfully loaded") EOL);
    return TRUE;
}

/*****************************************************************************
 *
 *  Security_AcquireCredentials
 *
 *  pwas -> WIN32AUTHSTATE to track the state of this session
 *  ptszPackage - name of security package (e.g., "MSN")
 *
 *****************************************************************************/

BOOL INTERNAL
Security_AcquireCredentials(PWIN32AUTHSTATE pwas, LPTSTR ptszPackage)
{
    TimeStamp       tsExpires;
    SECURITY_STATUS ss;
    char szToken[PLENTY_BIG];

    /*
     *  Clean slate.
     */
    ZeroMemory(pwas, sizeof(*pwas));

    ss = g_psft->AcquireCredentialsHandle(
                NULL,                   /* Use credentials of current user  */
                ptszPackage,            /* Use this security package        */
                SECPKG_CRED_OUTBOUND,   /* I am the untrusted one           */
                NULL,                   /* Not gonna access remote files    */
                NULL,                   /* Additional info                  */
                NULL,                   /* No credential retriever          */
                NULL,                   /* No credential retriever          */
                &pwas->hCred,           /* Receives credentials handle      */
                &tsExpires);            /* Expiration time for hCred        */

    if (ss == SEC_E_OK) {
        pwas->fHCredValid = TRUE;
    }

    return (ss == SEC_E_OK);

}

/*****************************************************************************
 *
 *  Security_BuildOutString
 *
 *  Build a string that will be output.
 *
 *****************************************************************************/

BOOL
Security_BuildOutString(PWIN32AUTHSTATE pwas, PSecBufferDesc pdescIn,
                        PCtxtHandle pctxOld, PCtxtHandle pctxNew,
                        LPTSTR ptszTarget)
{
    SecBuffer       bufOut;
    SecBufferDesc   descOut;
    TimeStamp       tsExpire;
    SECURITY_STATUS ss;
    BYTE            rgbToken[PLENTY_BIG];
    ULONG           fContextAttrib;

    /*
     *  Set up the buffers...
     */
    descOut.ulVersion = SECBUFFER_VERSION;
    descOut.cBuffers  = 1;
    descOut.pBuffers  = &bufOut;

    bufOut.cbBuffer = PLENTY_BIG;
    bufOut.BufferType = SECBUFFER_TOKEN;
    bufOut.pvBuffer = rgbToken;

retry:;
    ss = g_psft->InitializeSecurityContext(
                &pwas->hCred,           /* Remember me?                     */
                pctxOld,                /* Current context                  */
                ptszTarget,             /* Server name                      */
                pwas->fContextReq,      /* Context requiremnents            */
                0,                      /* (reserved)                       */
                SECURITY_NATIVE_DREP,   /* Target data representation       */
                pdescIn,                /* Input buffer descriptor          */
                0,                      /* (reserved)                       */
                pctxNew,                /* New context                      */
                &descOut,               /* Output buffer descriptor         */
                &fContextAttrib,        /* Receives context attributes      */
                &tsExpire);             /* Expiration time                  */

    /*
     *  If we failed to obtain credentials, and we haven't yet prompted
     *  the user, then try again with prompting.
     */
    if (ss == SEC_E_NO_CREDENTIALS &&
        !(pwas->fContextReq & ISC_REQ_PROMPT_FOR_CREDS)) {
        pwas->fContextReq |= ISC_REQ_PROMPT_FOR_CREDS;
        goto retry;
    }

    if (FAILED(ss)) {
        Squirt(TEXT("Logon failed") EOL);
        return FALSE;
    }

    /*
     *  Oh dear, a continuation record?  Ack, I can't handle that
     *  because I'm lazy.
     */
    if (ss == SEC_I_CONTINUE_NEEDED) {
        /* Aigh! */
    }

    /*
     *  Since POP and NNTP are text-based protocols, we need to
     *  RFC1113-encode the binary data before transmitting.
     */

    RFC1113_Encode(pwas->szBuffer, rgbToken, bufOut.cbBuffer);

    return TRUE;
}

/*****************************************************************************
 *
 *  Security_GetNegotiation
 *
 *  Begin the transaction by building a negotiation string
 *
 *****************************************************************************/

BOOL INTERNAL
Security_GetNegotiation(PWIN32AUTHSTATE pwas)
{
    BOOL            fRc;

    /*
     *  We're starting over; throw away any leftover context.
     */
    if (pwas->fHCtxtValid) {
        g_psft->DeleteSecurityContext(&pwas->hCtxt);
        pwas->fHCtxtValid = FALSE;
    }

    /*
     *  Use common worker function to generate an output string.
     */

    fRc = Security_BuildOutString(
                        pwas,           /* Authorization state              */
                        NULL,           /* No input buffer                  */
                        NULL,           /* No source context                */
                        &pwas->hCtxt,   /* Destination context              */
                        NULL);          /* Server name                      */

    /*
     *  If it worked, then the hCtxt is valid and needs to be
     *  deleted when we're done.
     */
    if (fRc) {
        pwas->fHCtxtValid = TRUE;
    }

    return fRc;
}

/*****************************************************************************
 *
 *  Security_GetResponse
 *
 *  Build a reponse to the server's challenge.
 *
 *****************************************************************************/

BOOL INTERNAL
Security_GetResponse(PWIN32AUTHSTATE pwas, LPSTR szChallenge)
{
    BOOL            fRc;
    BYTE            rgbChallenge[PLENTY_BIG];
    int             cb;
    SecBuffer       bufIn;
    SecBufferDesc   descIn;

    cb = RFC1113_Decode(rgbChallenge, szChallenge);

#ifdef CHATTY
    Squirt("Decoded %d bytes" EOL, cb);
#endif

    /*
     *  Set up the buffers...
     */
    descIn.ulVersion = SECBUFFER_VERSION;
    descIn.cBuffers  = 1;
    descIn.pBuffers  = &bufIn;

    bufIn.cbBuffer   = cb;
    bufIn.BufferType = SECBUFFER_TOKEN;
    bufIn.pvBuffer   = rgbChallenge;

    /*
     *  Use common worker function to generate an output string.
     */

    fRc = Security_BuildOutString(
                        pwas,           /* Authorization state              */
                        &descIn,        /* No input buffer                  */
                        &pwas->hCtxt,   /* No source context                */
                        &pwas->hCtxt,   /* Destination context              */
                        NULL);          /* Server name                      */

    return fRc;
}

/*****************************************************************************
 *
 *  Security_ReleaseCredentials
 *
 *  pwas -> WIN32AUTHSTATE to track the state of this session
 *  ptszPackage - name of security package (e.g., "MSN")
 *
 *****************************************************************************/

void INTERNAL
Security_ReleaseCredentials(PWIN32AUTHSTATE pwas)
{
    if (pwas->fHCtxtValid) {
        g_psft->DeleteSecurityContext(&pwas->hCtxt);
        pwas->fHCtxtValid = FALSE;
    }

    if (pwas->fHCredValid) {
        g_psft->FreeCredentialHandle(&pwas->hCred);
        pwas->fHCredValid = FALSE;
    }
}

/*****************************************************************************
 *
 *  sendsz
 *
 *      Send an asciiz string.
 *
 *****************************************************************************/

int
sendsz(SOCKET s, LPCSTR psz)
{
    return send(s, psz, lstrlen(psz), 0);
}

#if 0
/*****************************************************************************
 *
 *  POP3_Negotiate
 *
 *      Perform an authenticated MSN logon.
 *
 *****************************************************************************/

void
POP3_Negotiate(PCONNECTIONSTATE pcxs)
{
    WIN32AUTHSTATE was;
    int cb;

    /*
     *  Tell the server to go into MSN mode.
     */
    sendsz(pcxs->ssfd, "AUTH MSN\r\n");

    /*
     *  Wait for the Proceed.
     */
    cb = recv(pcxs->ssfd, pcxs->buf, BUFSIZE, 0); /* read a hunk */
    if (cb <= 0 || pcxs->buf[0] != '+') {
        sendsz(pcxs->scfd, "-ERR Server lost 1\r\n");
        return;
    }

    pcxs->buf[cb] = 0;
#ifdef CHATTY
    Squirt("<%s", pcxs->buf);
#endif

    if (!Security_AcquireCredentials(&was, TEXT("MSN"), NULL)) {
        Die(TEXT("Cannot acquire credentials handle"));
    }

    if (!Security_GetNegotiation(&was)) {
        Die(TEXT("Cannot get negotiation string"));
    }

    /*
     *  Now send the initial cookie.
     */
    wsprintf(pcxs->buf, "%s\r\n", was.szBuffer);
    sendsz(pcxs->ssfd, pcxs->buf);
#ifdef CHATTY
    Squirt(">%s", pcxs->buf);
#endif

    /*
     *  Response should be
     *
     *  + <challenge>
     */
    cb = recv(pcxs->ssfd, pcxs->buf, BUFSIZE, 0);

    if (cb <= 0 || pcxs->buf[0] != '+') {
        if (cb > 0) {
            pcxs->buf[cb] = 0;
            sendsz(pcxs->scfd, pcxs->buf);
        } else {
            sendsz(pcxs->scfd, "-ERR Server lost 2\r\n");
        }
        return;
    }

#ifdef CHATTY
    pcxs->buf[cb] = 0;
    Squirt("<%s", pcxs->buf);
#endif

    if (!Security_GetResponse(&was, pcxs->buf + 2)) {
        Die(TEXT("Cannot build response"));
    }

    /*
     *  Now send the response.
     */
    wsprintf(pcxs->buf, "%s\r\n", was.szBuffer);
    sendsz(pcxs->ssfd, pcxs->buf);
#ifdef CHATTY
    Squirt(">%s", pcxs->buf);
#endif

    Security_ReleaseCredentials(&was);
}

//
// nntp: authinfo user blah
//       authinfo pass blah
//
#endif

/*****************************************************************************
 *
 *  Proxy_Main
 *
 *****************************************************************************/

void
Proxy_Main(void)
{
    HANDLE hThread;
    DWORD dwThid;

    WSADATA wsad;

    /*  -- Lazy!  I should check the return code */
    if (WSAStartup(0x0101, &wsad)) return;

    hThread = CreateThread(0, 0, ProxyThread, &g_proxyPop, 0, &dwThid);

    if (hThread) {

     CloseHandle(hThread);
     hThread = CreateThread(0, 0, ProxyThread, &g_proxyNntp1, 0, &dwThid);
     if (hThread) {
       CloseHandle(hThread);
       hThread = CreateThread(0, 0, ProxyThread, &g_proxyNntp2, 0, &dwThid);
       if (hThread) {

        HWND hdlg;
        MSG msg;

        CloseHandle(hThread);

        /*
         *  Create our UI window.
         */
        hdlg = UI_Init();
        while (GetMessage(&msg, 0, 0, 0)) {
            if (IsDialogMessage(hdlg, &msg)) {
            } else {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
       } else {
        Squirt("Can't spawn NNTP socket thread 2; bye-bye" EOL);
       }
      } else {
        Squirt("Can't spawn NNTP socket thread 1; bye-bye" EOL);
      }
    } else {
        Squirt("Can't spawn POP3 socket thread; bye-bye" EOL);
    }
}

/*****************************************************************************
 *
 *  Entry
 *
 *****************************************************************************/

void __cdecl
Entry(void)
{
    g_hinst = GetModuleHandle(0);

    if (LoadSecurityManager()) {
        Proxy_Main();
    }

    if (g_hinstSecur) {
        FreeLibrary(g_hinstSecur);
    }

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msnspa\msnspa.h ===
/*
 *  msnspa.h
 */

#define STRICT
#include <windows.h>
#include <winsock.h>

#define SECURITY_WIN32
#include <issperr.h>
#include <sspi.h>

#define IDD_MAIN        1
#define IDC_NEWS        16
#define IDC_MAIL        17
#define IDI_MAIN        1

#ifndef RC_INVOKED

#include <windowsx.h>

typedef LPVOID PV;

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")
#define INLINE static __inline

#define INTERNAL WINAPI
#define EXTERNAL WINAPI

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

/*
 *  Plenty big enough for authorization.
 */
#define PLENTY_BIG          1024

/*
 *  Private structure used to keep track of Win32 authorization state.
 */
typedef struct WIN32AUTHSTATE {
    CredHandle      hCred;
    CtxtHandle      hCtxt;
    ULONG           fContextReq;
    BOOL            fHCredValid;
    BOOL            fHCtxtValid;
    char            szBuffer[PLENTY_BIG];
} WIN32AUTHSTATE, *PWIN32AUTHSTATE;

BOOL INTERNAL
Security_AcquireCredentials(PWIN32AUTHSTATE pwas, LPTSTR ptszPackage);

BOOL INTERNAL Security_GetNegotiation(PWIN32AUTHSTATE pwas);

BOOL INTERNAL
Security_GetResponse(PWIN32AUTHSTATE pwas, LPSTR szChallenge);

void INTERNAL
Security_ReleaseCredentials(PWIN32AUTHSTATE pwas);

/*****************************************************************************/

#define BUFSIZE 1024

/*
 *  Private structure used to keep track of conversation with server.
 */
typedef struct CONNECTIONSTATE {        /* cxs */
    SOCKET          ssfd;               /* Socket to server */
    SOCKET          scfd;               /* Socket to client */
    struct PROXYINFO *pproxy;           /* Info about who we are */
    char            buf[BUFSIZE];       /* Working buffer */
    int             nread;              /* Size of buffer */
} CONNECTIONSTATE, *PCONNECTIONSTATE;

#define EOL TEXT("\r\n")

#ifdef DBG
void __cdecl Squirt(LPCTSTR ptszMsg, ...);
#else
#define Squirt sizeof
#endif

void __cdecl Die(LPCTSTR ptszMsg, ...);

int sendsz(SOCKET s, LPCSTR psz);

//DWORD INTERNAL POP3_Main(LPVOID pvRef);
//void POP3_Negotiate(PCONNECTIONSTATE pcxs);
//DWORD INTERNAL NNTP_Main(LPVOID pvRef);
//void NNTP_Negotiate(PCONNECTIONSTATE pcxs);

HWND INTERNAL UI_Init(void);
void INTERNAL UI_Term(void);
void INTERNAL UI_UpdateCounts(void);

extern HINSTANCE g_hinst;
extern int g_cMailUsers;
extern int g_cNewsUsers;

/*****************************************************************************
 *
 *      proxy.c
 *
 *****************************************************************************/

SOCKET INTERNAL
init_send_socket(SOCKET scfd, LPCSTR pszHost, u_short port, LPCSTR pszErrMsg);

SOCKET INTERNAL
create_listen_socket(u_short port);

/*****************************************************************************
 *
 *      PROXYINFO
 *
 *****************************************************************************/

typedef BOOL (CALLBACK *NEGOTIATE)(SOCKET s);

typedef struct PROXYINFO {
    u_short localport;              /* The port we listen on */
    u_short serverport;             /* The port we talk to */
    LPCSTR pszHost;                 /* The host we proxy to */
    PINT piUsers;                   /* Variable that tracks number of users */
    NEGOTIATE Negotiate;            /* Negotiates security info */
    LPCSTR pszError;                /* Error on failed connect */
    LPCSTR pszErrorPwd;             /* Error on bad password */
    LPCSTR pszResponse;             /* What to respond to ignored cmds */
    char szIgnore1[5];              /* First 4-char command to ignore */
    char szIgnore2[5];              /* Second 4-char command to ignore */

} PROXYINFO, *PPROXYINFO;

extern PROXYINFO g_proxyPop;
extern PROXYINFO g_proxyNntp1;
extern PROXYINFO g_proxyNntp2;

DWORD CALLBACK ProxyThread(LPVOID pvRef);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\debug.cpp ===
#include "precomp.hxx"
#include "stdio.h"
#pragma hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MYDOCS"
#define SZ_MODULE           "MYDOCS"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msnspa\nntp.c ===
/*****************************************************************************
 *
 *  nntp.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dumb layer that opens the socket to the server.
 *
 *****************************************************************************/

#include "msnspa.h"

#define PROXY_PORT1         119                     /* I listen to this */
#define PROXY_DEST1         119                     /* And talk to this */
#define PROXY_HOST1         "msnnews.msn.com"       /* And I talk to him */
#define PROTOCOL            "MSN"                   /* with this protocol */

#define PROXY_PORT2         120                     /* I listen to this */
#define PROXY_DEST2         119                     /* And talk to this */
#define PROXY_HOST2         "netnews.msn.com"       /* And I talk to him */

BOOL CALLBACK NNTP_Negotiate(SOCKET s);

/*****************************************************************************
 *
 *      PROXYINFO for NNTP
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

PROXYINFO g_proxyNntp1 = {
    PROXY_PORT1,                        /* localport */
    PROXY_DEST1,                        /* serverport */
    PROXY_HOST1,                        /* remote server */
    &g_cNewsUsers,                      /* Usage counter */
    NNTP_Negotiate,                     /* Negotiation function */
    "400 Server inaccessible\r\n",      /* Failed to connect */
    "400 Authentication failed\r\n",    /* Password problem */
    "200 MSN Secure Password Authentication Proxy\r\n", /* Generic happy */
    "",                                 /* First 4-char command to ignore */
    "",                                 /* Second 4-char command to ignore */
};

PROXYINFO g_proxyNntp2 = {
    PROXY_PORT2,                        /* localport */
    PROXY_DEST2,                        /* serverport */
    PROXY_HOST2,                        /* remote server */
    &g_cNewsUsers,                      /* Usage counter */
    NNTP_Negotiate,                     /* Negotiation function */
    "400 Server inaccessible\r\n",      /* Failed to connect */
    "400 Authentication failed\r\n",    /* Password problem */
    "200 MSN Secure Password Authentication Proxy\r\n", /* Generic happy */
    "",                                 /* First 4-char command to ignore */
    "",                                 /* Second 4-char command to ignore */
};

/*****************************************************************************
 *
 *  NNTP_Negotiate
 *
 *      Perform an authenticated MSN logon.
 *
 *****************************************************************************/

BOOL CALLBACK
NNTP_Negotiate(SOCKET ssfd)
{
    WIN32AUTHSTATE was;
    char buf[BUFSIZE+1];
    int cb;

    /*
     *  Wait for the greeting.
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);   /* read a hunk */
#ifdef CHATTY
    if (cb >= 0) {
        buf[cb] = 0;
        Squirt("<%s\r\n", buf);
    }
#endif

    if (cb <= 0 || buf[0] != '2') {
        return FALSE;
    }

    /*
     *  Tell the server to go into authentication mode.
     */
    sendsz(ssfd, "AUTHINFO TRANSACT " PROTOCOL "\r\n");
#ifdef CHATTY
    Squirt(">AUTHINFO TRANSACT " PROTOCOL "\r\n");
#endif


    /*
     *  Wait for the Proceed.
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);   /* read a hunk */

#ifdef CHATTY
    if (cb >= 0) {
        buf[cb] = 0;
        Squirt("<%s\r\n", buf);
    }
#endif

    if (cb <= 0 || buf[0] != '3') {
        return FALSE;
    }

    if (!Security_AcquireCredentials(&was, TEXT(PROTOCOL))) {
        Die(TEXT("Cannot acquire credentials handle"));
    }

    if (!Security_GetNegotiation(&was)) {
        Die(TEXT("Cannot get negotiation string"));
    }

    /*
     *  Now send the initial cookie.
     */
    sendsz(ssfd, "AUTHINFO TRANSACT ");
    sendsz(ssfd, was.szBuffer);
    sendsz(ssfd, "\r\n");

#ifdef CHATTY
    Squirt(">AUTHINFO TRANSACT %s\r\n", was.szBuffer);
#endif

    /*
     *  Response should be
     *
     *  381 <challenge>
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);

    if (cb <= 0 || buf[0] != '3') {
        return FALSE;
    }

#ifdef CHATTY
    buf[cb] = 0;
    Squirt("<%s", buf);
#endif

    /*
     *  Parse the server response and build our response.
     */
    if (!Security_GetResponse(&was, buf + 4)) {
        Die(TEXT("Cannot build response"));
    }

    /*
     *  Now send our response.
     */
    sendsz(ssfd, "AUTHINFO TRANSACT ");
    sendsz(ssfd, was.szBuffer);
    sendsz(ssfd, "\r\n");
#ifdef CHATTY
    Squirt(">AUTHINFO TRANSACT %s\r\n", was.szBuffer);
#endif

    Security_ReleaseCredentials(&was);

    /*
     *  Now see how that worked.  Response should be
     *
     *  281 OK
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);

    if (cb <= 0 || buf[0] != '2') {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\dll.h ===
#ifndef __dll_h
#define __dll_h

#define T_HKEY   0x0001
#define T_VALUE  0x0002
#define T_DWORD  0x0003
#define T_END    0xFFFF

extern HINSTANCE g_hInstance;

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#ifdef DEBUG
void DllSetTraceMask(void);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\copyhook.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include "util.h"
#include "dll.h"
#include "resource.h"

class CMyDocsCopyHook : public ICopyHook
{
public:
    CMyDocsCopyHook();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ICopyHook
    STDMETHOD_(UINT,CopyCallback)(HWND hwnd, UINT wFunc, UINT wFlags,
                                  LPCTSTR pszSrcFile, DWORD dwSrcAttribs,
                                  LPCTSTR pszDestFile, DWORD dwDestAttribs);
private:
    ~CMyDocsCopyHook();
    LONG _cRef;
};

STDMETHODIMP CMyDocsCopyHook::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsCopyHook, ICopyHook),    // IID_ICopyHook
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CMyDocsCopyHook::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsCopyHook::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

CMyDocsCopyHook::CMyDocsCopyHook() : _cRef(1)
{
    DllAddRef();
}

CMyDocsCopyHook::~CMyDocsCopyHook()
{
    DllRelease();
}

// ICopyHook methods
UINT CMyDocsCopyHook::CopyCallback(HWND hwnd, UINT wFunc, UINT wFlags,
                                   LPCTSTR pszSrcFile,  DWORD dwSrcAttribs,
                                   LPCTSTR pszDestFile, DWORD dwDestAttribs)
{
    UINT uRes = IDYES;

    if ((wFunc == FO_COPY) || (wFunc == FO_MOVE))
    {
        TCHAR szPersonal[MAX_PATH];

        if (S_OK == SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPersonal) &&
            lstrcmpi(pszSrcFile, szPersonal) == 0)
        {
            // the source is the personal directory, now check if the
            // destination is on the desktop...
            DWORD dwRes = IsPathGoodMyDocsPath(hwnd, pszDestFile);

            if (dwRes == PATH_IS_NONEXISTENT)
            {
                lstrcpyn(szPersonal, pszDestFile, ARRAYSIZE(szPersonal));
                if (PathRemoveFileSpec(szPersonal))
                {
                    dwRes = IsPathGoodMyDocsPath(hwnd, szPersonal);
                }
            }

            if (dwRes == PATH_IS_DESKTOP)
            {
                // keep the user from moving the personal folder to the desktop
                TCHAR szVerb[ 32 ];
                LoadString(g_hInstance, (wFunc == FO_COPY) ? IDS_COPY : IDS_MOVE, szVerb, ARRAYSIZE(szVerb));

                uRes = IDNO;

                GetFolderDisplayName(CSIDL_PERSONAL, szPersonal, ARRAYSIZE(szPersonal));

                ShellMessageBox(g_hInstance, hwnd,
                                (LPTSTR)IDS_NODRAG_DESKTOP_NOT_HIDDEN, szPersonal,
                                MB_OK | MB_ICONSTOP, szPersonal, szVerb);
            }
        }
    }
    return uRes;
}

HRESULT CMyDocsCopyHook_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CMyDocsCopyHook * pMDCH = new CMyDocsCopyHook();
    if (pMDCH)
    {
        *ppunk = SAFECAST(pMDCH, ICopyHook*);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msnspa\ui.c ===
/*****************************************************************************
 *
 *  UI.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The thing that does UI.
 *
 *****************************************************************************/

#include "msnspa.h"

/*****************************************************************************
 *
 *  Overview:
 *
 *      UI for the app is done on the main thread.  The app itself
 *      is not in the taskbar or in the tray.  The only way to get to
 *      it is to Alt+Tab to it.  When you minimize it, it vanishes again.
 *
 *      FEATURE -- someday create an optional tray icon
 *
 *  Details:
 *
 *          The main window
 *          is just a dialog box.  The window we create is just a
 *          subclassed static control.
 *
 *          By stealing an existing control, we don't need to register
 *          our own bogus class.
 *
 *          We hide from the taskbar by having a hidden owner.
 *
 *          We show up in Alt+Tab because the hidden owner is
 *          not marked WS_EX_TOOLWINDOW.
 *
 *          We vanish on minimization by hiding ourselves, parking
 *          the minimized window "in outer space" so it doesn't bother
 *          the user.  Then re-show it so it can take part in Alt+Tab.
 *
 *****************************************************************************/

/*
 *  These are the co-ordinates of outer space.  Note that we can't base
 *  this on GetSystemMetrics(SM_C[XY]SCREEN) because the user might be
 *  running multiple monitors, and we need to be sure we are outside all
 *  monitors.  So we pick a really absurd value for outer space.
 */
#define XOUTERSPACE         (-32000)
#define YOUTERSPACE         (-32000)

HWND g_hwndMain;
HWND g_hwndDlg;
int g_cMailUsers;
int g_cNewsUsers;

/*****************************************************************************
 *
 *  @func   void | UI_UpdateCounts |
 *
 *          Update the counts of things.
 *
 *****************************************************************************/

void INTERNAL
UI_UpdateCounts(void)
{
    SetDlgItemInt(g_hwndDlg, IDC_MAIL, g_cMailUsers, FALSE);
    SetDlgItemInt(g_hwndDlg, IDC_NEWS, g_cNewsUsers, FALSE);

    EnableWindow(GetDlgItem(g_hwndDlg, IDOK), !(g_cMailUsers | g_cNewsUsers));

}

/*****************************************************************************
 *
 *  @func   BOOL | UI_OnSysCommand |
 *
 *          Munge some commands around.
 *
 *****************************************************************************/

BOOL INTERNAL
UI_OnSysCommand(HWND hdlg, WPARAM wp)
{
    switch (wp & ~0xF) {
    case SC_CLOSE:
        FORWARD_WM_COMMAND(hdlg, IDCANCEL, 0, 0, PostMessage);
        return TRUE;
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  @func   BOOL | UI_OnCommand |
 *
 *          Munge some commands around.
 *
 *****************************************************************************/

BOOL INTERNAL
UI_OnCommand(HWND hdlg, WPARAM wp)
{
    ANIMATIONINFO aniOld, aniNew;

    switch (wp) {
    case IDCANCEL:
        /*
         *  There is no way to minimize a hidden window.
         */

        aniOld.cbSize = sizeof(aniOld);
        SystemParametersInfo(SPI_GETANIMATION, sizeof(aniOld), &aniOld, 0);

        aniNew.cbSize = sizeof(aniNew);
        aniNew.iMinAnimate = 0;
        SystemParametersInfo(SPI_SETANIMATION, sizeof(aniNew), &aniNew, 0);

        ShowWindow(hdlg, SW_MINIMIZE);

        SystemParametersInfo(SPI_SETANIMATION, sizeof(aniOld), &aniOld, 0);

        SetWindowPos(hdlg, HWND_BOTTOM,
                     XOUTERSPACE, YOUTERSPACE, 0, 0,
                     SWP_NOACTIVATE | SWP_NOSIZE | SWP_SHOWWINDOW);
        return TRUE;

    case IDOK:
        FORWARD_WM_CLOSE(hdlg, PostMessage);
        return TRUE;
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  @func   BOOL | UI_OnClose |
 *
 *          Note that various weird conditions can lead to us getting
 *          here while there are active sessions, so re-check before
 *          leaving.
 *
 *****************************************************************************/

void INTERNAL
UI_OnClose(HWND hdlg)
{
    if (IsWindowEnabled(GetDlgItem(hdlg, IDOK))) {
        DestroyWindow(hdlg);
    }
}

/*****************************************************************************
 *
 *  @func   INT_PTR | UI_DlgProc |
 *
 *          Our dialog procedure.
 *
 *****************************************************************************/

INT_PTR CALLBACK
UI_DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_SYSCOMMAND:
        return UI_OnSysCommand(hdlg, wp);

    case WM_COMMAND:
        return UI_OnCommand(hdlg, wp);

    case WM_NCPAINT:
        if (IsIconic(hdlg)) {
            return TRUE;
        }
        break;

    case WM_CLOSE:
        UI_OnClose(hdlg);
        return TRUE;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    }
    return FALSE;
}

/*****************************************************************************
 *
 *  @func   HWND | UI_Init |
 *
 *          Initialize the UI stuff.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

HWND INTERNAL
UI_Init(void)
{
    g_hwndMain = CreateWindow(
        "static",                       /* Class Name */
        "",                             /* Title */
        WS_OVERLAPPEDWINDOW | WS_MINIMIZE,
                                        /* Style (note: not visible) */
        CW_USEDEFAULT, CW_USEDEFAULT,   /* Position */
        CW_USEDEFAULT, CW_USEDEFAULT,   /* Size */
        NULL,                           /* Parent */
        NULL,                           /* Use class menu */
        g_hinst,                        /* Instance */
        0);                             /* No special parameters */

//    SubclassWindow(g_hwndMain, Main_WndProc);

    SendMessage(g_hwndMain, WM_SETICON, ICON_BIG,
                (LPARAM)LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_MAIN)));

    /*
     *  Create the dialog not visible because we're going to be shoving
     *  it around.
     */
    g_hwndDlg = CreateDialog(g_hinst, MAKEINTRESOURCE(IDD_MAIN),
                             g_hwndMain, UI_DlgProc);

    /*
     *  Tell the system that the window should be parked in outer space.
     */
    SetWindowPos(g_hwndDlg, HWND_BOTTOM,
                 XOUTERSPACE, YOUTERSPACE, 0, 0,
                 SWP_NOACTIVATE | SWP_NOSIZE | SWP_SHOWWINDOW);

    return g_hwndDlg;
}

/*****************************************************************************
 *
 *  @func   void | UI_Term |
 *
 *          Clean up the UI stuff.
 *
 *****************************************************************************/

void INTERNAL
UI_Term(void)
{
    DestroyWindow(g_hwndMain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msnspa\proxy.c ===
/*****************************************************************************
 *
 *  PROXYcc
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Does all the bookkeeping part of proxying.
 *
 *****************************************************************************/

#include "msnspa.h"

/*****************************************************************************
 *
 *      init_send_socket
 *
 *      Create a socket that talks to the real world.
 *
 *****************************************************************************/

SOCKET INTERNAL
init_send_socket(SOCKET scfd, LPCSTR pszHost, u_short port, LPCSTR pszErrMsg)
{
    SOCKET s;
    struct hostent *phe;
    struct sockaddr_in saddr;

    /*
     * Find out who the target is.
     */
    ZeroMemory(&saddr, sizeof(saddr));
    phe = gethostbyname(pszHost);

    if (!phe) {
        Squirt("Couldn't build address of gateway");
        send(scfd, pszErrMsg, lstrlen(pszErrMsg), 0);
        s = INVALID_SOCKET;
        goto done;
    }

    /*
     * Build the socket address packet for the open.
     */
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(port);
    CopyMemory(&saddr.sin_addr, phe->h_addr, phe->h_length);

    /*
     * Open sesame.
     */
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s == INVALID_SOCKET) {
        Squirt("Couldn't create send socket\r\n");
        send(scfd, pszErrMsg, lstrlen(pszErrMsg), 0);
        s = INVALID_SOCKET;
        goto done;
    }

    /*
     * One ringy-dingy...
     */
    if (connect(s, (struct sockaddr *)&saddr, sizeof(saddr))) {
        Squirt("Couldn't connect");
        closesocket(s);
        send(scfd, pszErrMsg, lstrlen(pszErrMsg), 0);
        s = INVALID_SOCKET;
        goto done;
    }

done:;
    return s;

}

/*****************************************************************************
 *
 *      set_sock_opt_int
 *
 *  Set an integer socket option or die trying.
 *
 *****************************************************************************/

void
set_sock_opt_int(SOCKET s, int optname, int val)
{
    if (setsockopt(s, SOL_SOCKET, optname, (PV)&val, sizeof(val)) == -1) {
        Die("set sock opt");
    }
}

/*****************************************************************************
 *
 *      create_listen_socket
 *
 *      Start listening on a port.
 *
 *****************************************************************************/

SOCKET INTERNAL
create_listen_socket(u_short port)
{
    SOCKET isckdes;
    struct hostent *phe;                /* my host entry table */
    struct sockaddr_in saddr;           /* my socket address */
    char hostname[64];

    /*
     * Find out who I am.
     */
    gethostname(hostname, 64);
    phe = gethostbyname(hostname);	/* Get my own hostent */

    if (!phe) {
        Die("Couldn't build address of localhost");
        return INVALID_SOCKET;
    }

    /*
     * Build the socket address packet for the open.
     */
    ZeroMemory(&saddr, sizeof(saddr));  /* start fresh */
    CopyMemory(&saddr.sin_addr, phe->h_addr, phe->h_length); /* Copy the IP */

    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = htonl(INADDR_ANY);
    saddr.sin_port = htons(port); /* Listen on this port */

    /*
     * Open sesame.
     */
    isckdes = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (isckdes == INVALID_SOCKET) {
        Die("Couldn't create listen socket");
        return INVALID_SOCKET;
    }

    /*
     * Set some socket options.
     */
    set_sock_opt_int(isckdes, SO_REUSEADDR, 1);
    set_sock_opt_int(isckdes, SO_KEEPALIVE, 1);

    /*
     * All right, let's bind to it already.
     */
    if (bind(isckdes, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {
        Die("Couldn't bind to recv. socket");
    }

    return isckdes;
}

/*****************************************************************************
 *
 *      ProxyPeekCommand
 *
 *      Study the incoming command to see if it is something we
 *      have a canned response to.
 *
 *****************************************************************************/

BOOL INTERNAL
ProxyPeekCommand(PCONNECTIONSTATE pcxs)
{
    PPROXYINFO pproxy = pcxs->pproxy;

    /*
     *  Now peek to see if we got a specific ignorable
     *  four-letter command from
     *  the client.  If so, then spit back the canned response.
     */
    if (pcxs->nread > 4 && pcxs->buf[4] == ' ') {
        char szWord[5];
        szWord[0] = pcxs->buf[0];
        szWord[1] = pcxs->buf[1];
        szWord[2] = pcxs->buf[2];
        szWord[3] = pcxs->buf[3];
        szWord[4] = 0;

        /*
         *  Are the first four letters an ignored command?
         */
        if (lstrcmpi(szWord, pproxy->szIgnore1) == 0 ||
            lstrcmpi(szWord, pproxy->szIgnore2) == 0) {

            /*
             *  Then spit back the canned response.
             */


            if (sendsz(pcxs->scfd, pproxy->pszResponse) == SOCKET_ERROR) {
                Squirt("Write failed" EOL);
            }
            return TRUE;

        }
    }

    return FALSE;
}

/*****************************************************************************
 *
 *      PROXYTHREADSTATE
 *
 *      Tiny chunk of memory used to transfer proxy state between
 *      the ProxyThread() and the ProxyWorkerThread().
 *
 *****************************************************************************/

typedef struct PROXYTHREADSTATE {
    PPROXYINFO pproxy;                  /* Who we are */
    SOCKET scfd;                        /* Newly-accepted socket to client */
} PROXYTHREADSTATE, *PPROXYTHREADSTATE;

/*****************************************************************************
 *
 *      ProxyWorkerThread
 *
 *      Hold two phones together.
 *
 *****************************************************************************/

DWORD WINAPI
ProxyWorkerThread(LPVOID pvRef)
{
    PPROXYTHREADSTATE ppts = pvRef;
    CONNECTIONSTATE cxs;

    cxs.scfd = ppts->scfd;
    cxs.pproxy = ppts->pproxy;

    LocalFree(ppts);

    Squirt("Connection %d..." EOL, GetCurrentThreadId());

    ++*cxs.pproxy->piUsers;
    UI_UpdateCounts();

    /* open the target socket */
    cxs.ssfd = init_send_socket(cxs.scfd,
                                cxs.pproxy->pszHost,
                                cxs.pproxy->serverport,
                                cxs.pproxy->pszError);

    if (cxs.ssfd != INVALID_SOCKET) {
#if 0
        Squirt("ssfd = %d; scfd = %d, &ssfd = %08x" EOL,
               cxs.ssfd, cxs.scfd, &cxs.ssfd);
#endif

        if (!cxs.pproxy->Negotiate(cxs.ssfd)) {
            sendsz(cxs.scfd, cxs.pproxy->pszErrorPwd);
            goto byebye;
        }

        sendsz(cxs.scfd, cxs.pproxy->pszResponse);

        for (;;) {
            fd_set fdrd, fder;
            SOCKET sfrom, sto;

            fdrd.fd_count = 2;
            fdrd.fd_array[0] = cxs.ssfd;
            fdrd.fd_array[1] = cxs.scfd;

            fder.fd_count = 2;
            fder.fd_array[0] = cxs.ssfd;
            fder.fd_array[1] = cxs.scfd;

            cxs.nread = select(32, &fdrd, 0, &fder, 0);

            if (cxs.nread != SOCKET_ERROR) {
                char *ptszSrc;
                char *ptszDst;

                if (fder.fd_count) {        /* error on a socket, e.g., EOF */
                    break;                  /* outta here */
                }

                if (fdrd.fd_count == 0) {   /* Huh?? */
                    continue;
                }

                if (fdrd.fd_array[0] == cxs.scfd) {
                    sfrom = cxs.scfd; sto = cxs.ssfd;
                } else if (fdrd.fd_array[0] == cxs.ssfd) {
                    sfrom = cxs.ssfd; sto = cxs.scfd;
                } else {
                    continue;
                }

                cxs.nread = recv(sfrom, cxs.buf, BUFSIZE, 0); /* read a hunk */

                if (cxs.nread > 0) {

                    /*
                     *  If it's from the client, then peek at it
                     *  in case we need to munge it.
                     */
                    if (sfrom == cxs.scfd) {
                        if (ProxyPeekCommand(&cxs)) {
                            continue;
                        }
                    }

                    if (send(sto, cxs.buf, cxs.nread, 0) == SOCKET_ERROR) {
                        Squirt("Write failed" EOL);
                    }
#ifdef DBG
                    cxs.buf[cxs.nread] = 0;
                    if (sto == cxs.scfd) {
                        /*
                         *  Walk the buffer studying each line.
                         */
                        int ich = 0;
                        while (ich < cxs.nread) {
                            int ichEnd;
                            DWORD dwFirst;

                            for (ichEnd = ich;
                                 ichEnd < cxs.nread &&
                                 cxs.buf[ichEnd] != '\n'; ichEnd++) {
                            }

                            dwFirst = *(LPDWORD)&cxs.buf[ich];
                            #define PLUSOK      0x004B4F2B
                            #define DASHERR     0x5252452D
                            #define SUBJECT     0x6A627553

                            if ((dwFirst & 0x00FFFFFF) == PLUSOK ||
                                dwFirst == DASHERR ||
                                dwFirst == SUBJECT) {

                                cxs.buf[ichEnd] = 0;
                                Squirt("<%s\n", &cxs.buf[ich]);
                            }

                            ich = ichEnd + 1;
                        }

                    } else {
                        Squirt(">%s", cxs.buf);
                    }

#endif
                } else {                /* EOF */
                    break;
                }
            } else {                    /* Panic */
                Squirt("select %d", WSAGetLastError());
                break;
            }
        }
    byebye:;
        Sleep(250);                     /* wait for socket to drain */
        closesocket(cxs.ssfd);
    }
    closesocket(cxs.scfd);
    Squirt("End connection %d..." EOL, GetCurrentThreadId());

    --*cxs.pproxy->piUsers;
    UI_UpdateCounts();

    return 0;
}

/*****************************************************************************
 *
 *      ProxyThread
 *
 *      Thread procedure for proxies.
 *
 *****************************************************************************/

DWORD CALLBACK
ProxyThread(LPVOID pvRef)
{
    PPROXYINFO pproxy = pvRef;
    SOCKET ic_sck;
    SOCKET scfd;

    ic_sck = create_listen_socket(pproxy->localport);

    for (;;) {
        HANDLE hThread;
        DWORD dwThid;
        PPROXYTHREADSTATE ppts;

        Squirt("listening..." EOL);
        if (listen(ic_sck, SOMAXCONN) == -1) {
            Squirt("listen failed %d" EOL, WSAGetLastError());
            // APPCOMPAT: For Win95, Close the socket and try again 
            closesocket(ic_sck);
            ic_sck = create_listen_socket(pproxy->localport);
            continue;
        }

        /*
         *  OLD COMMENT
         *
         * We ought to put a timeout in here, and then
         * if there are no connections, reap any zombies
         * and go back to listening... so if we've blocked some
         * sockets other people don't get refused... -- mikeg
         */

        Squirt("accept waiting..." EOL);
        scfd = accept(ic_sck, NULL, NULL); /* wait for a connection */

        if (scfd == INVALID_SOCKET) {
            Squirt("accept failed %d" EOL, WSAGetLastError());
            break;
        }

        ppts = LocalAlloc(LMEM_FIXED, sizeof(PROXYTHREADSTATE));
        if (ppts) {
            ppts->pproxy = pproxy;
            ppts->scfd = scfd;

            hThread = CreateThread(0, 0, ProxyWorkerThread, ppts, 0, &dwThid);
            if (hThread) {
                CloseHandle(hThread);
            } else {
                Squirt("Can't spawn worker thread; tossing connection" EOL);
                closesocket(scfd);
            }
        } else {
            Squirt("Out of memory; tossing connection" EOL);
            closesocket(scfd);
        }
    }
    closesocket(ic_sck);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\makefile.inc ===
..\resource.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\msnspa\pop3.c ===
/*****************************************************************************
 *
 *  pop3.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Prepares for and waits for client connections.
 *
 *****************************************************************************/

#include "msnspa.h"

#define PROXY_PORT          110                     /* I listen to this */
#define PROXY_DEST          110                     /* And talk to this */
#define PROXY_HOST          "pop3.email.msn.com"    /* And I talk to him */
#define PROTOCOL            "MSN"                   /* with this protocol */

BOOL CALLBACK POP3_Negotiate(SOCKET s);

/*****************************************************************************
 *
 *      PROXYINFO for POP3
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

PROXYINFO g_proxyPop = {
    PROXY_PORT,                         /* localport */
    PROXY_DEST,                         /* serverport */
    PROXY_HOST,                         /* remote server */
    &g_cMailUsers,                      /* Usage counter */
    POP3_Negotiate,                     /* Negotiation function */
    "-ERR Server inaccessible\r\n",     /* Failed to connect */
    "-ERR Authentication failed\r\n",   /* Password problem */
    "+OK MSN Secure Password Authentication Proxy\r\n", /* Generic happy */
    "USER",                             /* First 4-char command to ignore */
    "PASS",                             /* Second 4-char command to ignore */

};

/*****************************************************************************
 *
 *  POP3_Negotiate
 *
 *      Perform an authenticated MSN logon.
 *
 *****************************************************************************/

BOOL CALLBACK
POP3_Negotiate(SOCKET ssfd)
{
    WIN32AUTHSTATE was;
    char buf[BUFSIZE+1];
    int cb;

    /*
     *  Wait for the greeting.
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);   /* read a hunk */
#ifdef CHATTY
    if (cb >= 0) {
        buf[cb] = 0;
        Squirt("<%s\r\n", buf);
    }
#endif

    if (cb <= 0 || buf[0] != '+') {
        return FALSE;
    }

    /*
     *  Tell the server to go into authentication mode.
     */
    sendsz(ssfd, "AUTH " PROTOCOL "\r\n");
#ifdef CHATTY
    Squirt(">AUTH " PROTOCOL "\r\n");
#endif


    /*
     *  Wait for the Proceed.
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);   /* read a hunk */

#ifdef CHATTY
    if (cb >= 0) {
        buf[cb] = 0;
        Squirt("<%s\r\n", buf);
    }
#endif

    if (cb <= 0 || buf[0] != '+') {
        return FALSE;
    }

    if (!Security_AcquireCredentials(&was, TEXT(PROTOCOL))) {
        Die(TEXT("Cannot acquire credentials handle"));
    }

    if (!Security_GetNegotiation(&was)) {
        Die(TEXT("Cannot get negotiation string"));
    }

    /*
     *  Now send the initial cookie.
     */
    sendsz(ssfd, was.szBuffer);
    sendsz(ssfd, "\r\n");

#ifdef CHATTY
    Squirt(">%s\r\n", was.szBuffer);
#endif

    /*
     *  Response should be
     *
     *  + <challenge>
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);

    if (cb <= 0 || buf[0] != '+') {
        return FALSE;
    }

#ifdef CHATTY
    buf[cb] = 0;
    Squirt("<%s", buf);
#endif

    /*
     *  Parse the server response and build our response.
     */
    if (!Security_GetResponse(&was, buf + 2)) {
        Die(TEXT("Cannot build response"));
    }

    /*
     *  Now send our response.
     */
    sendsz(ssfd, was.szBuffer);
    sendsz(ssfd, "\r\n");
#ifdef CHATTY
    Squirt(">%s\r\n", was.szBuffer);
#endif

    Security_ReleaseCredentials(&was);

    /*
     *  Now see how that worked.  Response should be
     *
     *  + OK
     */
    cb = recv(ssfd, buf, BUFSIZE, 0);

    if (cb <= 0 || buf[0] != '+') {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\dll.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <shguidp.h>
#include <advpub.h>     // RegInstall stuff

#include "util.h"
#include "resource.h"
#include "version.h"

// {ECF03A32-103D-11d2-854D-006008059367}   CLSID_MyDocsDropTarget
const CLSID CLSID_MyDocsDropTarget = { 0xecf03a32, 0x103d, 0x11d2, { 0x85, 0x4d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67 } };
// {ECF03A33-103D-11d2-854D-006008059367}   CLSID_MyDocsCopyHook
const CLSID CLSID_MyDocsCopyHook = { 0xecf03a33, 0x103d, 0x11d2, { 0x85, 0x4d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67 } };
// {4a7ded0a-ad25-11d0-98a8-0800361b1103}   CLSID_MyDocsProp
const CLSID CLSID_MyDocsProp = {0x4a7ded0a, 0xad25, 0x11d0, 0x98, 0xa8, 0x08, 0x00, 0x36, 0x1b, 0x11, 0x03};

HINSTANCE g_hInstance = 0;
LONG g_cRefThisDll = 0;          // DLL global reference count

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefThisDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefThisDll ? S_FALSE : S_OK;
}

HRESULT CMyDocsCopyHook_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
HRESULT CMyDocsSendTo_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
HRESULT CMyDocsProp_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);


CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_MyDocsCopyHook,      CMyDocsCopyHook_CreateInstance,   COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_MyDocsDropTarget,    CMyDocsSendTo_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_MyDocsProp,          CMyDocsProp_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)


STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter) // && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

// export that ie4unit.exe calls at per user install time
// this lets us execute code instead of depending on the "DefaultUser" template
// that is used to init new accounts. this deals with upgrade cases too, very important

STDAPI_(void) PerUserInit(void)
{
    TCHAR szPath[MAX_PATH];

    SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);

    // Don't install these guys on server builds
    if (!IsOS(OS_ANYSERVER))
    {
        SHGetFolderPath(NULL, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);
        SHGetFolderPath(NULL, CSIDL_MYMUSIC | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);
    }

    UpdateSendToFile();
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_hInstance, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_hInstance, "UnregDll");
    return S_OK;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    if (pszCmdLine && *pszCmdLine)
    {
        if (0 == StrCmpIW(pszCmdLine, L"UseReadOnly"))
        {
            // Add key for system to use read only bit on shell folders...
            HKEY hkey;
            if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), &hkey))
            {
                if (bInstall)
                {
                    DWORD dwValue = 1;
                    RegSetValueEx(hkey, TEXT("UseReadOnlyForSystemFolders"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
                }
                else
                {
                    RegDeleteValue(hkey, TEXT("UseReadOnlyForSystemFolders"));
                }
                RegCloseKey(hkey);
            }
        }
        else if (0 == StrCmpIW(pszCmdLine, L"U"))
        {
            // not currently used, but for testing (and consistency with shell32.dll)
            // REGSVR32.EXE /n /i:U mydocs.dll
            PerUserInit();  
        }
    }
    return S_OK;
}

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, void *pReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModule(hInstance);
        break;

    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\dllload.h ===
#ifndef _DLLLOAD_H_
#define _DLLLOAD_H_

#include "cscapi.h"
#include "cscuiext.h"
#include "winnetwk.h"

#endif // _DLLLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\prop.h ===
#ifndef __props_h
#define __props_h


INT_PTR CALLBACK TargetDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

#define MAX_NAME_LEN 20
#define FILENAME_LEN_WITH_SLASH_AND_NULL 14
#define MAX_DIR_PATH (MAX_PATH-FILENAME_LEN_WITH_SLASH_AND_NULL)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\dllload.cpp ===
#include "precomp.hxx"
#include "util.h"

#include "..\..\inc\dllload.c"

/**********************************************************************/
/**********************************************************************/

// ---------- CSCDLL.DLL ------------

HINSTANCE g_hinstCSCDLL = NULL;

DELAY_LOAD_BOOL(g_hinstCSCDLL, CSCDLL, CSCQueryFileStatus,
            (LPCTSTR lpszFileName, LPDWORD lpdwStatus, LPDWORD lpdwPinCount, LPDWORD lpdwHintFlags),
            (lpszFileName, lpdwStatus, lpdwPinCount, lpdwHintFlags));


// ---------- CSCUI.DLL ------------

HINSTANCE g_hinstCSCUI = NULL;

DELAY_LOAD_HRESULT(g_hinstCSCUI, CSCUI, CSCUIRemoveFolderFromCache,
            (LPCWSTR pszFolder, DWORD dwReserved, PFN_CSCUIRemoveFolderCallback pfnCB, LPARAM lParam),
            (pszFolder, dwReserved, pfnCB, lParam));


// ---------- MPR.DLL --------------

HINSTANCE g_hinstMPR = NULL;

DELAY_LOAD_ERR(g_hinstMPR, MPR, DWORD, WNetGetUniversalName,
            (LPCTSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize),
            (lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize),
            ERROR_NOT_CONNECTED);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\prop.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include "util.h"
#include "dll.h"
#include "resource.h"
#include "prop.h"

#include <shellids.h>   // IDH_ values
#include "shlguidp.h"
#include "inetreg.h"

typedef struct {
    HWND hDlg;
    BOOL bDirty;
    BOOL bInitDone;
    BOOL bSetToDefault;
    TCHAR szFolder[MAX_PATH];
    UINT csidl;
} CUSTINFO;

const static DWORD rgdwHelpTarget[] = {
    IDD_TARGET_TXT,                   IDH_MYDOCS_TARGET,
    IDD_TARGET,                       IDH_MYDOCS_TARGET,
    IDD_FIND,                         IDH_MYDOCS_FIND_TARGET,
    IDD_BROWSE,                       IDH_MYDOCS_BROWSE,
    IDD_RESET,                        IDH_MYDOCS_RESET,
    0, 0
};

// Scans a desktop.ini file for sections to see if all of them are empty...

BOOL IsDesktopIniEmpty(LPCTSTR pIniFile)
{
    TCHAR szSections[1024];  // for section names
    if (GetPrivateProfileSectionNames(szSections, ARRAYSIZE(szSections), pIniFile))
    {
        for (LPTSTR pTmp = szSections; *pTmp; pTmp += lstrlen(pTmp) + 1)
        {
            TCHAR szSection[1024];   // for section key names and values
            GetPrivateProfileSection(pTmp, szSection, ARRAYSIZE(szSection), pIniFile);
            if (szSection[0])
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

void CleanupSystemFolder(LPCTSTR pszPath)
{
    TCHAR szIniFile[MAX_PATH];
    PathCombine(szIniFile, pszPath, TEXT("desktop.ini"));

    DWORD dwAttrb;
    if (PathFileExistsAndAttributes(szIniFile, &dwAttrb))
    {
        // Remove CLSID2, InfoTip, Icon
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID2"), NULL, szIniFile);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("InfoTip"), NULL, szIniFile);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("IconFile"), NULL, szIniFile);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("IconIndex"), NULL, szIniFile);

        // get rid of delete on copy entries to see if we can generate an empty .ini file
        WritePrivateProfileSection(TEXT("DeleteOnCopy"), NULL, szIniFile);

        if (IsDesktopIniEmpty(szIniFile))
        {
            dwAttrb &= ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN);
            SetFileAttributes(szIniFile, dwAttrb);
            DeleteFile(szIniFile);
        }

        // see if we can cleanout an old thumbs.db file too
        // so we have a better chance of deleting an empty folder
        PathCombine(szIniFile, pszPath, TEXT("thumbs.db"));
        DeleteFile(szIniFile);

        PathUnmakeSystemFolder(pszPath);
    }

    // in case it is empty try to delete it 
    // this will fail if there are contents in the folder
    if (RemoveDirectory(pszPath))
    {
        // it is gone, let people know
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszPath, NULL);
    }
    else
    {
        // attribute bits changed for this folder, refresh views of it
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pszPath, NULL);
    }
}

HRESULT ChangeFolderPath(UINT csidl, LPCTSTR pszNew, LPCTSTR pszOld)
{
    HRESULT hr = SHSetFolderPath(csidl, NULL, 0, pszNew);
    if (SUCCEEDED(hr))
    {
        // now we can cleanup the old folder... now that we have the new folder
        // established

        if (*pszOld)
        {
            CleanupSystemFolder(pszOld);
        }
        // force the per user init stuff on the new folder
        TCHAR szPath[MAX_PATH];
        hr = SHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szPath);
        if (SUCCEEDED(hr))
        {
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szPath, NULL);
        }
    }
    return hr;
}

// test to see if pszToTest is a sub folder of pszFolder
BOOL PathIsDirectChildOf(LPCTSTR pszFolder, LPCTSTR pszMaybeChild)
{
    return PATH_IS_CHILD == ComparePaths(pszMaybeChild, pszFolder);
}

LPTSTR GetMessageTitle(CUSTINFO *pci, LPTSTR psz, UINT cch)
{
    TCHAR szFormat[64], szName[MAX_PATH];

    LoadString(g_hInstance, IDS_PROP_ERROR_TITLE, szFormat, ARRAYSIZE(szFormat));
    GetFolderDisplayName(pci->csidl, szName, ARRAYSIZE(szName));
    wnsprintf(psz, cch, szFormat, szName);

    return psz;
}

void GetTargetExpandedPath(HWND hDlg, LPTSTR pszPath, UINT cch)
{
    *pszPath = 0;

    TCHAR szUnExPath[MAX_PATH];

    if (GetDlgItemText(hDlg, IDD_TARGET, szUnExPath, ARRAYSIZE(szUnExPath)))
    {
        // Turn "c:" into "c:\", but don't change other paths:
        PathAddBackslash(szUnExPath);
        PathRemoveBackslash(szUnExPath);
        SHExpandEnvironmentStrings(szUnExPath, pszPath, cch);
    }
}

// Check known key in the registry to see if policy has disabled changing
// of My Docs location.

BOOL PolicyAllowsFolderPathChange(CUSTINFO *pci)
{
    BOOL bChange = TRUE;

    if (pci->csidl == CSIDL_PERSONAL)
    {
        HKEY hkey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"), 0, KEY_READ, &hkey))
        {
            bChange = (ERROR_SUCCESS != RegQueryValueEx(hkey, TEXT("DisablePersonalDirChange"), NULL, NULL, NULL, NULL));
            RegCloseKey(hkey);
        }
    }
    return bChange;
}

BOOL InitTargetPage(HWND hDlg, LPARAM lParam)
{
    CUSTINFO *pci = (CUSTINFO *)LocalAlloc(LPTR, sizeof(*pci));
    if (pci)
    {
        TCHAR szPath[MAX_PATH];
        TCHAR szFormat[MAX_PATH];
        TCHAR szText[ARRAYSIZE(szFormat) + MAX_NAME_LEN];
        TCHAR szName[MAX_PATH];

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pci);
        pci->hDlg = hDlg;
        pci->csidl = CSIDL_PERSONAL;

        // Fill in title/instructions...
        GetFolderDisplayName(pci->csidl, szName, ARRAYSIZE(szName));
        if (lstrlen(szName) > MAX_NAME_LEN)
        {
            lstrcpy(&szName[MAX_NAME_LEN], TEXT("..."));
        }

        LoadString(g_hInstance, IDS_PROP_INSTRUCTIONS, szFormat, ARRAYSIZE(szFormat));

        wnsprintf(szText, ARRAYSIZE(szText), szFormat, szName);
        SetDlgItemText(hDlg, IDD_INSTRUCTIONS, szText);

        // Limit edit field to MAX_PATH-13 characters.  Why -13?
        // Well, 13 is the number of characters in a DOS style 8.3
        // filename with a '\', and CreateDirectory will fail if you try to create
        // a directory that can't at least contain 8.3 file names.
        SendDlgItemMessage(hDlg, IDD_TARGET, EM_SETLIMITTEXT, MAX_DIR_PATH, 0);

        // Check whether path can be changed
        if (PolicyAllowsFolderPathChange(pci))
        {
            SHAutoComplete(GetDlgItem(hDlg, IDD_TARGET), SHACF_FILESYS_DIRS);
        }
        else
        {
            // Make edit field read only
            SendDlgItemMessage(hDlg, IDD_TARGET, EM_SETREADONLY, (WPARAM)TRUE, 0);
            ShowWindow(GetDlgItem(hDlg, IDD_RESET), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_FIND), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDD_BROWSE), SW_HIDE);
        }

        SHGetFolderPath(NULL, pci->csidl | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);

        if (szPath[0])
        {
            PathRemoveBackslash(szPath);    // keep path without trailing backslash
            lstrcpy(pci->szFolder, szPath);
            SetDlgItemText(hDlg, IDD_TARGET, szPath);
        }

        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetFolderLocation(NULL, pci->csidl | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, &pidl)))
        {
            SHFILEINFO sfi;

            SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_PIDL);
            if (sfi.hIcon)
            {
                if (sfi.hIcon = (HICON)SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_SETICON, (WPARAM)sfi.hIcon, 0))
                    DestroyIcon(sfi.hIcon);
            }
            ILFree(pidl);
        }

        pci->bInitDone = TRUE;
    }
    return pci ? TRUE : FALSE;
}

const UINT c_rgRedirectCanidates[] = 
{
    CSIDL_MYPICTURES,
    CSIDL_MYMUSIC,
    CSIDL_MYVIDEO,
    CSIDL_MYDOCUMENTS,
};

int MoveFilesForRedirect(HWND hdlg, LPCTSTR pszNewPath, LPCTSTR pszOldPath)
{
    int iRet = 0;  // success

    // since we use FOF_RENAMEONCOLLISION when moving files from the old location
    // to the new we want to special case target folders if they are the shell special
    // folders that may live under the folder being redirected

    // this code implements a merge of those folders doing "rename on collision" at the
    // level below the folder. this keeps us from generating "copy of xxx" for each of
    // the special folders
    
    for (UINT i = 0; (iRet == 0) && (i < ARRAYSIZE(c_rgRedirectCanidates)); i++)
    {
        TCHAR szOld[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, c_rgRedirectCanidates[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szOld)) &&
            PathIsDirectChildOf(pszOldPath, szOld))
        {
            TCHAR szDestPath[MAX_PATH] = {0};   // zero init for SHFileOperation()
            PathCombine(szDestPath, pszNewPath, PathFindFileName(szOld));

            DWORD dwAtt;
            if (PathFileExistsAndAttributes(szDestPath, &dwAtt) &&
                (FILE_ATTRIBUTE_DIRECTORY & dwAtt))
            {
                // reset the folder with the system before the move
                ChangeFolderPath(c_rgRedirectCanidates[i], szDestPath, szOld);

                // the above may have emptied and deleted the old location
                // but if not we need to move the contents
                if (PathFileExistsAndAttributes(szOld, &dwAtt))
                {
                    // Move items in current MyPics to new location
                    TCHAR szSrcPath[MAX_PATH + 1] = {0};    // +1 for double null
                    PathCombine(szSrcPath, szOld, TEXT("*.*"));

                    SHFILEOPSTRUCT  fo = {0};
                    fo.hwnd = hdlg;
                    fo.wFunc = FO_MOVE;
                    fo.fFlags = FOF_RENAMEONCOLLISION;
                    fo.pFrom = szSrcPath;
                    fo.pTo = szDestPath;        

                    iRet = SHFileOperation(&fo);
                    if ((0 == iRet) && !fo.fAnyOperationsAborted)
                    {
                        // since the above was a full move no files should
                        // be left behind so this should work
                        if (RemoveDirectory(szOld))
                            SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szOld, NULL);
                    }
                }
            }
        }
    }

    // above failed or canceled?
    if (0 == iRet)
    {
        // move the rest of the stuff
        TCHAR szSrcPath[MAX_PATH + 1] = {0};    // +1 for double null
        PathCombine(szSrcPath, pszOldPath, TEXT("*.*"));

        TCHAR szDestPath[MAX_PATH] = {0};   // zero init for dbl null term
        lstrcpy(szDestPath, pszNewPath);

        SHFILEOPSTRUCT  fo = {0};
        fo.hwnd = hdlg;
        fo.wFunc = FO_MOVE;
        fo.fFlags = FOF_RENAMEONCOLLISION;  // don't want any "replace file" prompts

        fo.pFrom = szSrcPath;
        fo.pTo = szDestPath;

        iRet = SHFileOperation(&fo);
        if (0 == iRet)
        {
            // if the above worked we try to clean up the old path
            // now that it it empty
            if (RemoveDirectory(pszOldPath))
                SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszOldPath, NULL);
        }
    }
    return iRet;
}

// Ask the user if they want to create the directory of a given path.
// Returns TRUE if the user decided to create it, FALSE if not.
// If TRUE, the dir attributes are returned in pdwAttr.
BOOL QueryCreateTheDirectory(CUSTINFO *pci, LPCTSTR pPath, DWORD *pdwAttr)
{
    *pdwAttr = 0;

    UINT id = IDYES;

    if (pci->bSetToDefault)
        id = IDYES;
    else
        id = ShellMessageBox(g_hInstance, pci->hDlg, MAKEINTRESOURCE(IDS_CREATE_FOLDER), MAKEINTRESOURCE(IDS_CREATE_FOLDER_TITLE),
                              MB_YESNO | MB_ICONQUESTION, pPath);
    if (IDYES == id)
    {
        // user asked us to create the folder
        if (ERROR_SUCCESS == SHCreateDirectoryEx(pci->hDlg, pPath, NULL))
            *pdwAttr = GetFileAttributes(pPath);
    }
    return IDYES == id;
}

void _MaybeUnpinOldFolder(LPCTSTR pszPath, HWND hwnd, BOOL fPromptUnPin)
{
    //
    // Convert the path to canonical UNC form (the CSC and CSCUI
    // functions require the path to be in this form)
    //
    // WNetGetUniversalName fails if you give it a path that's already
    // in canonical UNC form, so in the failure case just try using
    // pszPath.  CSCQueryFileStatus will validate it.
    //
    LPCTSTR pszUNC;

    struct {
       UNIVERSAL_NAME_INFO uni;
       TCHAR szBuf[MAX_PATH];
    } s;
    DWORD cbBuf = sizeof(s);

    if (ERROR_SUCCESS == WNetGetUniversalName(pszPath, UNIVERSAL_NAME_INFO_LEVEL,
                                &s, &cbBuf))
    {
        pszUNC = s.uni.lpUniversalName;
    }
    else
    {
        pszUNC = pszPath;
    }

    //
    // Ask CSC if the folder is pinned for this user
    //
    DWORD dwHintFlags = 0;
    if (CSCQueryFileStatus(pszUNC, NULL, NULL, &dwHintFlags))
    {
        if (dwHintFlags & FLAG_CSC_HINT_PIN_USER)
        {
            //
            // Yes; figure out if we should unpin it
            //
            BOOL fUnpin;

            if (fPromptUnPin)
            {
                //
                // Give the unconverted path name in the message box, since
                // that's the name the user knows
                //
                UINT id = ShellMessageBox(g_hInstance, hwnd,
                                  MAKEINTRESOURCE(IDS_UNPIN_OLDTARGET), MAKEINTRESOURCE(IDS_UNPIN_OLD_TITLE),
                                  MB_YESNO | MB_ICONQUESTION | MB_TOPMOST | MB_DEFBUTTON2,
                                  pszPath);

                fUnpin = (id == IDNO);
            }
            else
            {
                fUnpin = TRUE;
            }

            if (fUnpin)
            {
                CSCUIRemoveFolderFromCache(pszUNC, 0, NULL, 0);
            }
        }
    }
}

void ComputChildrenOf(LPCTSTR pszOld, UINT rgChildren[], UINT sizeArray)
{
    UINT iCanidate = 0;

    ZeroMemory(rgChildren, sizeof(rgChildren[0]) * sizeArray);

    for (UINT i = 0; i < ARRAYSIZE(c_rgRedirectCanidates); i++)
    {
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, c_rgRedirectCanidates[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath)))
        {
            if (PathIsDirectChildOf(pszOld, szPath))
            {
                if (iCanidate < sizeArray)
                {
                    rgChildren[iCanidate++] = c_rgRedirectCanidates[i];
                }
            }
        }
    }
}

// if csidl DEFAULT VALUE ends up under the new folder we reset that folder
// to that value

HRESULT ResetSubFolderDefault(LPCTSTR pszNew, UINT csidl, LPCTSTR pszOldPath)
{
    HRESULT hr = S_OK;
    // note: getting the default value for this path, not the current value!
    TCHAR szDefault[MAX_PATH];
    if (S_OK == SHGetFolderPath(NULL, csidl, NULL, SHGFP_TYPE_DEFAULT, szDefault))
    {
        if (PathIsDirectChildOf(pszNew, szDefault))
        {
            hr = SHSetFolderPath(csidl, NULL, 0, szDefault);
            if (SUCCEEDED(hr))
            {
                // we've written the registry, that is enough to cleanup the old folder
                if (*pszOldPath)
                    CleanupSystemFolder(pszOldPath);

                hr = SHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, szDefault);
            }
        }
    }
    return hr;
}

void ResetNonMovedFolders(LPCTSTR pszNew, UINT rgChildren[], UINT sizeArray)
{
    for (UINT i = 0; i < sizeArray; i++)
    {
        // for all of these folders that were sub folders of the old location
        // and are now not sub folders we try to restore them to the default

        TCHAR szPath[MAX_PATH];
        if (rgChildren[i] && 
            SUCCEEDED(SHGetFolderPath(NULL, rgChildren[i] | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath)) &&
            !PathIsDirectChildOf(pszNew, szPath))
        {
            ResetSubFolderDefault(pszNew, rgChildren[i], szPath);
        }
    }
}
              
void _DoApply(CUSTINFO *pci)
{
    LONG lres = PSNRET_NOERROR;
    TCHAR szNewFolder[MAX_PATH];
    DWORD dwAttr;

    GetTargetExpandedPath(pci->hDlg, szNewFolder, ARRAYSIZE(szNewFolder));

    if (pci->bDirty && (lstrcmpi(szNewFolder, pci->szFolder) != 0))
    {
        TCHAR szPropTitle[MAX_PATH + 32];
        DWORD dwRes = IsPathGoodMyDocsPath(pci->hDlg, szNewFolder);

        // all of the special cases

        switch (dwRes)
        {
        case PATH_IS_DESKTOP:   // desktop is not good
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NODESKTOP_FOLDERS), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;

        case PATH_IS_SYSTEM:
        case PATH_IS_WINDOWS:   // these would be bad
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NOWINDIR_FOLDER), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;

        case PATH_IS_PROFILE:   // profile is bad
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NOPROFILEDIR_FOLDER), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;

        case PATH_IS_NONEXISTENT:
        case PATH_IS_NONDIR:
        case PATH_IS_GOOD:

            dwAttr = GetFileAttributes(szNewFolder);

            if (dwAttr == 0xFFFFFFFF)
            {
                // Ask user if we should create the directory...
                if (!QueryCreateTheDirectory(pci, szNewFolder, &dwAttr))
                {
                    // They don't want to create the directory.. break here
                    lres = PSNRET_INVALID_NOCHANGEPAGE;
                    break;
                }
            }

            if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (lstrcmpi(szNewFolder, pci->szFolder))
                {
                    UINT rgChildren[10];
                    ComputChildrenOf(pci->szFolder, rgChildren, ARRAYSIZE(rgChildren));

                    if (SUCCEEDED(ChangeFolderPath(pci->csidl, szNewFolder, pci->szFolder)))
                    {
                        BOOL fNewSubdirOfOld = PathIsEqualOrSubFolder(pci->szFolder, szNewFolder);

                        BOOL fPromptUnPin = TRUE;

                        if (fNewSubdirOfOld)
                        {
                            // can't move old content to a subdir
                            ShellMessageBox(g_hInstance, pci->hDlg,
                                    MAKEINTRESOURCE(IDS_CANT_MOVE_TO_SUBDIR), MAKEINTRESOURCE(IDS_MOVE_DOCUMENTS_TITLE),
                                    MB_OK | MB_ICONINFORMATION | MB_TOPMOST,
                                    pci->szFolder);
                        }
                        else if (IDYES == ShellMessageBox(g_hInstance, pci->hDlg,
                                        MAKEINTRESOURCE(IDS_MOVE_DOCUMENTS),
                                        MAKEINTRESOURCE(IDS_MOVE_DOCUMENTS_TITLE),
                                        MB_YESNO | MB_ICONQUESTION | MB_TOPMOST,
                                        pci->szFolder, szNewFolder))
                        {
                            // move old mydocs content -- returns 0 on success
                            if (0 == MoveFilesForRedirect(pci->hDlg, szNewFolder, pci->szFolder)) 
                            {
                                // Move succeeded, the old target dir is now empty, so
                                // no need to prompt about unpinning it (just go ahead
                                // and do it).

                                fPromptUnPin = FALSE;
                            }
                            else
                            {
                                // move failure
                                ShellMessageBox(g_hInstance, pci->hDlg,
                                    MAKEINTRESOURCE(IDS_MOVE_ERROR), MAKEINTRESOURCE(IDS_MOVE_ERROR_TITLE),
                                    MB_OK | MB_ICONSTOP | MB_TOPMOST,
                                    szNewFolder, pci->szFolder);
                            }
                        }

                        ResetNonMovedFolders(szNewFolder, rgChildren, ARRAYSIZE(rgChildren));

                        if (!fNewSubdirOfOld && pci->szFolder[0])
                        {
                            // If the old folder was pinned, offer to unpin it.
                            //
                            // Do this only if new target is not a subdir of the 
                            // old target, since otherwise we'd end up unpinning
                            // the new target as well

                            _MaybeUnpinOldFolder(pci->szFolder, pci->hDlg, fPromptUnPin);
                        }
                    }
                    else
                    {
                        ShellMessageBox(g_hInstance, pci->hDlg,
                                         MAKEINTRESOURCE(IDS_GENERAL_BADDIR), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                                         MB_OK | MB_ICONSTOP | MB_TOPMOST);
                        lres = PSNRET_INVALID_NOCHANGEPAGE;
                    }
                }
            }
            else if (dwAttr)
            {
                DWORD id = IDS_NONEXISTENT_FOLDER;

                // The user entered a path that doesn't exist or isn't a
                // directory...

                if (dwAttr != 0xFFFFFFFF)
                {
                    id = IDS_NOT_DIRECTORY;
                }

                ShellMessageBox(g_hInstance, pci->hDlg,
                                 IntToPtr_(LPTSTR, id), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                                 MB_OK | MB_ICONERROR | MB_TOPMOST);
                lres = PSNRET_INVALID_NOCHANGEPAGE;
            }
            else
            {
                ShellMessageBox(g_hInstance, pci->hDlg,
                                 MAKEINTRESOURCE(IDS_GENERAL_BADDIR), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                                 MB_OK | MB_ICONSTOP | MB_TOPMOST);
                lres = PSNRET_INVALID_NOCHANGEPAGE;
            }
            break;

        default:
            // the path to something isn't allowed
            ShellMessageBox(g_hInstance, pci->hDlg,
                             MAKEINTRESOURCE(IDS_NOTALLOWED_FOLDERS), GetMessageTitle(pci, szPropTitle, ARRAYSIZE(szPropTitle)),
                             MB_OK | MB_ICONSTOP | MB_TOPMOST);
            lres = PSNRET_INVALID_NOCHANGEPAGE;
            break;
        }
    }

    if (lres == PSNRET_NOERROR)
    {
        pci->bDirty = FALSE;
        lstrcpy(pci->szFolder, szNewFolder);
    }

    SetWindowLongPtr(pci->hDlg, DWLP_MSGRESULT, lres);
}

int _BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        // Set the caption. ('Select a destination')
        TCHAR szTitle[100];
        LoadString(g_hInstance, IDS_BROWSE_CAPTION, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
        break;

    case BFFM_SELCHANGED:
        if (lParam)
        {
            TCHAR szPath[MAX_PATH];

            szPath[0] = 0;
            SHGetPathFromIDList((LPITEMIDLIST)lParam, szPath);

            DWORD dwRes = IsPathGoodMyDocsPath(hwnd, szPath);

            if (dwRes == PATH_IS_GOOD || dwRes == PATH_IS_MYDOCS)
            {
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)TRUE);
                SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, 0);
            }
            else
            {
                TCHAR szStatus[128];

                SendMessage(hwnd, BFFM_ENABLEOK, 0, 0);

                szStatus[0] = 0;
                LoadString(g_hInstance, IDS_NOSHELLEXT_FOLDERS, szStatus, ARRAYSIZE(szStatus));
                SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)szStatus);
            }
        }
        break;
    }

    return 0;
}

void _MakeDirty(CUSTINFO *pci)
{
    pci->bDirty = TRUE;
    pci->bSetToDefault = FALSE;
    PropSheet_Changed(GetParent(pci->hDlg), pci->hDlg);
}

void _DoFind(CUSTINFO *pci)
{
    TCHAR szPath[MAX_PATH];
    GetTargetExpandedPath(pci->hDlg, szPath, ARRAYSIZE(szPath));

    LPITEMIDLIST pidl = ILCreateFromPath(szPath);
    if (pidl)
    {
        SHOpenFolderAndSelectItems(pidl, 0, NULL, 0);
        ILFree(pidl);
    }
    else
    {
        ShellMessageBox(g_hInstance, pci->hDlg,
                     MAKEINTRESOURCE(IDS_GENERAL_BADDIR), MAKEINTRESOURCE(IDS_INVALID_TITLE),
                     MB_OK | MB_ICONSTOP | MB_TOPMOST);
    }
}

void _DoBrowse(CUSTINFO *pci)
{
    BROWSEINFO bi = {0};
    TCHAR szTitle[128];

    LoadString(g_hInstance, IDS_BROWSE_TITLE, szTitle, ARRAYSIZE(szTitle));

    bi.hwndOwner = pci->hDlg;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT | BIF_NEWDIALOGSTYLE | BIF_UAHINT;
    bi.lpfn = _BrowseCallbackProc;

    // the default root for this folder is MyDocs so we don't need to set that up.

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl)
    {
        TCHAR szName[MAX_PATH];
        if (SHGetPathFromIDList(pidl, szName))
        {
            SetDlgItemText(pci->hDlg, IDD_TARGET, szName);
            _MakeDirty(pci);
        }
        ILFree(pidl);
    }
}

void DoReset(CUSTINFO *pci)
{
    TCHAR szPath[MAX_PATH];

    if (S_OK == SHGetFolderPath(NULL, pci->csidl, NULL, SHGFP_TYPE_DEFAULT, szPath))
    {
        SetDlgItemText(pci->hDlg, IDD_TARGET, szPath);
        _MakeDirty(pci);
        pci->bSetToDefault = TRUE;  // to avoid prompt to create
    }
}

INT_PTR CALLBACK TargetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUSTINFO *pci = (CUSTINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitTargetPage(hDlg, lParam);
        return 1;

    case WM_DESTROY:
        LocalFree(pci);
        SetWindowLongPtr(hDlg, DWLP_USER, 0);
        return 1;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_RESET:
            DoReset(pci);
            return 1;

        case IDD_TARGET:
	    if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE) && pci && (pci->bInitDone) && (!pci->bDirty))
            {
                _MakeDirty(pci);
            }
            return 1;

        case IDD_FIND:
            _DoFind(pci);
            return 1;

        case IDD_BROWSE:
            _DoBrowse(pci);
            return 1;
        }
        break;

    case WM_HELP:               /* F1 or title-bar help button */
        if ((((LPHELPINFO)lParam)->iCtrlId != IDD_ITEMICON)     &&
            (((LPHELPINFO)lParam)->iCtrlId != IDD_INSTRUCTIONS) &&
            (((LPHELPINFO)lParam)->iCtrlId != IDC_TARGET_GBOX))
        {
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle,
                     NULL, HELP_WM_HELP, (DWORD_PTR) rgdwHelpTarget);
        }
        break;

    case WM_CONTEXTMENU:        /* right mouse click */
        {
            POINT p;
            HWND hwndChild;
            INT ctrlid;

            //
            // Get the point where the user clicked...
            //

            p.x = GET_X_LPARAM(lParam);
            p.y = GET_Y_LPARAM(lParam);

            //
            // Now, map that to a child control if possible...
            //

            ScreenToClient(hDlg, &p);
            hwndChild = ChildWindowFromPoint((HWND)wParam, p);
            ctrlid = GetDlgCtrlID(hwndChild);

            //
            // Don't put up the help context menu for the items
            // that don't have help...
            //
            if ((ctrlid != IDD_ITEMICON)     &&
                (ctrlid != IDD_INSTRUCTIONS))
            {
                WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR)rgdwHelpTarget);
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            _DoApply(pci);
            return 1;
        }
        break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_MYDOCS                      100
#define IDI_MYPICS                      101

#define IDR_CONTEXT                     201
#define IDM_OPEN                        300
#define IDM_EXPLORE                     301
#define IDM_SHORTCUT                    302
#define IDM_DELETE                      303
#define IDM_RENAME                      304
#define IDM_PROPERTIES                  305
#define DLG_TARGET                      400
#define IDD_ITEMICON                    401
#define IDD_NAME                        402
#define IDD_TARGET_TXT                  406
#define IDD_TARGET                      407
#define IDD_BROWSE                      408
#define IDD_FIND                        409
#define IDD_INSTRUCTIONS                413
#define IDD_RESET                       414
#define IDS_CREATE_FOLDER_TITLE         630
#define IDS_CREATE_FOLDER               631
#define IDS_INVALID_TITLE               632
#define IDS_NONEXISTENT_FOLDER          633
#define IDS_NOT_DIRECTORY               634

#define IDS_NODESKTOP                   642
#define IDS_NODESKTOP_FOLDERS           643
#define IDS_NOSHELLEXT_FOLDERS          644

#define IDS_NODRAG_DESKTOP_NOT_HIDDEN   649
#define IDS_COPY                        651
#define IDS_MOVE                        652
#define IDS_PROP_ERROR_TITLE            653
#define IDS_NOWINDIR_FOLDER             656
#define IDS_NOPROFILEDIR_FOLDER         657
#define IDS_PROP_INSTRUCTIONS           661
#define IDS_GENERAL_BADDIR              664
#define IDS_BROWSE_TITLE                665
#define IDS_NOTALLOWED_FOLDERS          668
#define IDS_MOVE_DOCUMENTS_TITLE        676
#define IDS_MOVE_DOCUMENTS              677
#define IDS_MOVE_ERROR_TITLE            678
#define IDS_MOVE_ERROR                  679
#define IDS_BROWSE_CAPTION              680
#define IDS_CANT_MOVE_TO_SUBDIR         682
#define IDS_UNPIN_OLD_TITLE             685
#define IDS_UNPIN_OLDTARGET             686
#define IDS_SHARENAME                   689

#define IDS_DELETE_MESSAGE              900

#define IDC_TARGET_GBOX                 -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\sources.inc ===
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

SELFREGNAME= $(O)\selfreg_mydocs.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)

TARGETNAME= mydocs
TARGETTYPE= DYNLINK
TARGETPATH= obj

DLLDEF=     ..\mydocs.def
DLLENTRY=   DllMain
DLLBASE=    0x77000000

# Include ATL just to get conversion macros
USE_ATL=    1

USE_MSVCRT= 1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

#VERIFY_LC = 1
LC_PATH   = $(PROJECT_ROOT)\lcinf

TARGETLIBS= \
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\user32.lib      \
            $(SDK_LIB_PATH)\gdi32.lib       \
            $(SHELL_LIB_PATH)\shell32p.lib  \
            $(CCSHELL_DIR)\lib\$(O)\shguid.lib \
            $(CCSHELL_DIR)\lib\$(O)\shguidp.lib \
            $(SHELL_LIB_PATH)\shlwapip.lib  \
            $(SHELL_LIB_PATH)\shdocvw.lib   \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\uuid.lib        \
            $(SHELL_LIB_PATH)\shfusion.lib  \
            $(SDK_LIB_PATH)\ole32.lib       \
            $(SDK_LIB_PATH)\oleaut32.lib    \
            $(CCSHELL_DIR)\lib\$(O)\stock.lib

INCLUDES=   ..\;$(BASE_INC_PATH);$(DS_INC_PATH);$(O)

SOURCES=    ..\copyhook.cpp    \
            ..\debug.cpp       \
            ..\dll.cpp         \
            ..\dllload.cpp     \
            ..\mydocsexts.cpp  \
            ..\prop.cpp        \
            ..\resource.rc     \
            ..\util.cpp

NTTARGETFILES=

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
 
# Fusionized
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\mydocsexts.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <shguidp.h>    // CLSID_MyDocuments, CLSID_ShellFSFolder
#include <shellp.h>     // SHCoCreateInstance
#include <shlguidp.h>   // IID_IResolveShellLink
#include "util.h"
#include "dll.h"
#include "resource.h"
#include "prop.h"


HRESULT _GetUIObjectForMyDocs(REFIID riid, void **ppv)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHGetUIObjectFromFullPIDL(pidl, NULL, riid, ppv);
        ILFree(pidl);
    }
    return hr;
}


// send to "My Documents" handler

class CMyDocsSendTo : public IDropTarget, IPersistFile
{
public:
    CMyDocsSendTo();
    HRESULT _InitTarget();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFile
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName);

private:
    ~CMyDocsSendTo();

    LONG _cRef;
    IDropTarget *_pdtgt;
};

CMyDocsSendTo::CMyDocsSendTo() : _cRef(1)
{
    DllAddRef();
}

CMyDocsSendTo::~CMyDocsSendTo()
{
    if (_pdtgt)
        _pdtgt->Release();
    DllRelease();
}

STDMETHODIMP CMyDocsSendTo::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsSendTo, IDropTarget),
        QITABENT(CMyDocsSendTo, IPersistFile), 
        QITABENTMULTI(CMyDocsSendTo, IPersist, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMyDocsSendTo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMyDocsSendTo::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

HRESULT CMyDocsSendTo::_InitTarget()
{
    if (_pdtgt)
        return S_OK;
    return _GetUIObjectForMyDocs(IID_PPV_ARG(IDropTarget, &_pdtgt));
}

STDMETHODIMP CMyDocsSendTo::DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;     // don't let this be destructive
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->DragEnter(pDataObject, grfKeyState, pt, pdwEffect);
    return hr;
}

STDMETHODIMP CMyDocsSendTo::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;     // don't let this be destructive
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->DragOver(grfKeyState, pt, pdwEffect);
    return hr;
}

STDMETHODIMP CMyDocsSendTo::DragLeave()
{
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->DragLeave();
    return hr;
}

STDMETHODIMP CMyDocsSendTo::Drop(IDataObject *pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;     // don't let this be destructive
    HRESULT hr = _InitTarget();
    if (SUCCEEDED(hr))
        hr = _pdtgt->Drop(pDataObject, grfKeyState, pt, pdwEffect);
    return hr;
}

STDMETHODIMP CMyDocsSendTo::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MyDocsDropTarget;
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::IsDirty(void)
{
    return S_OK;        // no
}


STDMETHODIMP CMyDocsSendTo::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (_pdtgt)
        return S_OK;
    UpdateSendToFile();    // refresh the send to target (in case the desktop icon was renamed)
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

STDMETHODIMP CMyDocsSendTo::GetCurFile(LPOLESTR *ppszFileName)
{
    *ppszFileName = NULL;
    return E_NOTIMPL;
}

HRESULT CMyDocsSendTo_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CMyDocsSendTo* pdt = new CMyDocsSendTo();
    if (pdt)
    {
        *ppunk = SAFECAST(pdt, IDropTarget *);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}


// properyt page and context menu shell extension

class CMyDocsProp : public IShellPropSheetExt, public IShellExtInit
{
public:
    CMyDocsProp();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

private:
    ~CMyDocsProp();
    void _AddExtraPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

    LONG _cRef;
};

CMyDocsProp::CMyDocsProp() : _cRef(1)
{
    DllAddRef();
}

CMyDocsProp::~CMyDocsProp()
{
    DllRelease();
}

STDMETHODIMP CMyDocsProp::QueryInterface( REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsProp, IShellPropSheetExt), 
        QITABENT(CMyDocsProp, IShellExtInit), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CMyDocsProp::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsProp::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CMyDocsProp::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkey)
{
    return S_OK;
}

// {f81e9010-6ea4-11ce-a7ff-00aa003ca9f6}
const CLSID CLSID_CShare = {0xf81e9010, 0x6ea4, 0x11ce, 0xa7, 0xff, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6 };

// {1F2E5C40-9550-11CE-99D2-00AA006E086C}
const CLSID CLSID_RShellExt = {0x1F2E5C40, 0x9550, 0x11CE, 0x99, 0xD2, 0x00, 0xAA, 0x00, 0x6E, 0x08, 0x6C };

const CLSID *c_rgFilePages[] = {
    &CLSID_ShellFileDefExt,
    &CLSID_CShare,
    &CLSID_RShellExt,
};

const CLSID *c_rgDrivePages[] = {
    &CLSID_ShellDrvDefExt,
    &CLSID_CShare,
    &CLSID_RShellExt,
};

// add optional pages to Explore/Options.

void CMyDocsProp::_AddExtraPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    IDataObject *pdtobj;

    if (SUCCEEDED(_GetUIObjectForMyDocs(IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        TCHAR szPath[MAX_PATH];
        SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);
        BOOL fDriveRoot = PathIsRoot(szPath) && !PathIsUNC(szPath);
        const CLSID** pCLSIDs = fDriveRoot ? c_rgDrivePages : c_rgFilePages;
        int nCLSIDs = (int)(fDriveRoot ? ARRAYSIZE(c_rgDrivePages) : ARRAYSIZE(c_rgFilePages));
        for (int i = 0; i < nCLSIDs; i++)
        {
            IUnknown *punk;

            // We need to CoCreate for IUnknown instead of IShellPropSheetExt because the
            // class factory for the Win9x sharing property sheet (msshrui.dll) is buggy
            // and return E_NOINTERFACE ISPSE...
            HRESULT hr = SHCoCreateInstance(NULL, pCLSIDs[i], NULL, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hr))
            {
                IShellPropSheetExt *pspse;
                hr = punk->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));
                punk->Release();
                if (SUCCEEDED(hr))
                {
                    IShellExtInit *psei;
                    if (SUCCEEDED(pspse->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
                    {
                        hr = psei->Initialize(NULL, pdtobj, NULL);
                        psei->Release();
                    }

                    if (SUCCEEDED(hr))
                        pspse->AddPages(pfnAddPage, lParam);
                    pspse->Release();
                }
            }
        }
    }
}

STDMETHODIMP CMyDocsProp::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr = S_OK;

    PROPSHEETPAGE psp = {0};

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_TARGET);
    psp.pfnDlgProc = TargetDlgProc;

    HPROPSHEETPAGE hPage = CreatePropertySheetPage( &psp );
    if (hPage)
    {
        pfnAddPage( hPage, lParam );
        _AddExtraPages(pfnAddPage, lParam);
    }
    return hr;
}

STDMETHODIMP CMyDocsProp::ReplacePage( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}

HRESULT CMyDocsProp_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    CMyDocsProp* pmp = new CMyDocsProp();
    if (pmp)
    {
        *ppunk = SAFECAST(pmp, IShellExtInit *);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\winnt\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\util.h ===
#include <debug.h>
#include "dllload.h"
#include <shconv.h>    // for UNICODE/ANSI conversion macros

DWORD IsPathGoodMyDocsPath(HWND hwnd, LPCTSTR pPath);
void RestoreMyDocsFolder(void);
void UpdateSendToFile();
HRESULT GetFolderDisplayName(UINT csidl, LPTSTR pPath, UINT cch);

#define PATH_IS_GOOD            0x00000000
#define PATH_IS_DESKTOP         0x00000001
#define PATH_IS_PROFILE         0x00000002
#define PATH_IS_SYSTEM          0x00000003
#define PATH_IS_WINDOWS         0x00000004
#define PATH_IS_SHELLFOLDER     0x00000005
#define PATH_IS_MYDOCS          0x00000006
#define PATH_IS_NONDIR          0x00000007
#define PATH_IS_SENDTO          0x00000008
#define PATH_IS_RECENT          0x00000009
#define PATH_IS_HISTORY         0x0000000A
#define PATH_IS_COOKIES         0x0000000B
#define PATH_IS_PRINTHOOD       0x0000000C
#define PATH_IS_NETHOOD         0x0000000D
#define PATH_IS_STARTMENU       0x0000000E
#define PATH_IS_TEMPLATES       0x0000000F
#define PATH_IS_FAVORITES       0x00000010
#define PATH_IS_TEMP_INET       0x00000011
#define PATH_IS_FONTS           0x00000012
#define PATH_IS_APPDATA         0x00000013
#define PATH_IS_DRIVEROOT       0x00000014
#define PATH_IS_SYSDRIVEROOT    0x00000015
#define PATH_IS_ERROR           0x00000016
#define PATH_IS_NONEXISTENT     0x00000017
#define PATH_IS_READONLY        0x00000018

// This is a bit mask
#define PATH_IS_DIFFERENT   0x00000001
#define PATH_IS_EQUAL       0x00000002
#define PATH_IS_CHILD       0x00000004

// PATH_IS_ values returned
DWORD ComparePaths(LPCTSTR pszChild, LPCTSTR pszParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\util.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <shguidp.h>    // CLSID_MyDocuments, CLSID_ShellFSFolder
#include <shlobjp.h>    // SHFlushSFCache()
#include "util.h"
#include "dll.h"
#include "resource.h"
#include "sddl.h"

HRESULT GetFolderDisplayName(UINT csidl, LPTSTR pszPath, UINT cch)
{
    *pszPath = 0;

    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, &pidl)))
    {
        SHGetNameAndFlags(pidl, SHGDN_NORMAL, pszPath, cch, NULL);
        ILFree(pidl);
    }
    return *pszPath ? S_OK : E_FAIL;
}

#define MYDOCS_CLSID  TEXT("{450d8fba-ad25-11d0-98a8-0800361b1103}") // CLSID_MyDocuments

// Create/Updates file in SendTo directory to have current display name

void UpdateSendToFile()
{
    TCHAR szSendToDir[MAX_PATH];
    
    if (S_OK == SHGetFolderPath(NULL, CSIDL_SENDTO, NULL, SHGFP_TYPE_CURRENT, szSendToDir))
    {
        // Create c:\winnt\profile\chrisg\sendto\<display name>.mydocs
        BOOL bDeleteOnly = FALSE;
        TCHAR szNewFile[MAX_PATH];
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(GetFolderDisplayName(CSIDL_PERSONAL, szName, ARRAYSIZE(szName))))
        {
            PathCleanupSpec(NULL, szName);  // map any illegal chars to file sys chars
            PathRemoveBlanks(szName);

            PathCombine(szNewFile, szSendToDir, szName);
            lstrcat(szNewFile, TEXT(".mydocs"));
        }
        else
        {
            // we can't create a new file, because we don't have a name
            bDeleteOnly = TRUE;
        }
        
        TCHAR szFile[MAX_PATH];
        WIN32_FIND_DATA fd;

        // delete c:\winnt\profile\chrisg\sendto\*.mydocs

        PathCombine(szFile, szSendToDir, TEXT("*.mydocs"));

        HANDLE hFind = FindFirstFile(szFile, &fd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                PathCombine(szFile, szSendToDir, fd.cFileName);
                if (0 == lstrcmp(szFile, szNewFile))
                {
                    // The file that we needed to create already exists,
                    // just leave it in place instead of deleting it and
                    // then creating it again below (this fixes
                    // app compat problems - see NT bug 246932)
                    bDeleteOnly = TRUE;
                    // file now has the exact display name, MUI adjusts the return from GetFolderDisplayName and
                    // since we run this every time we dont have to worry about localizing the sendto target.
                }
                else
                {
                    DeleteFile(szFile);
                }
            } while (FindNextFile(hFind, &fd));
            FindClose(hFind);
        }

        if (!bDeleteOnly)
        {
            hFind = CreateFile(szNewFile, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFind);
                // file now has the exact display name, MUI adjusts the return from GetFolderDisplayName and
                // since we run this every time we dont have to worry about localizing the sendto target.
            }
            else
            {
                // might be illegal chars in the file name, fall back to the default MyDocs name here
            }
        }
    }
}

// test pszChild against pszParent to see if
// pszChild is equal (PATH_IS_EQUAL) or 
// a DIRECT child (PATH_IS_CHILD)

DWORD ComparePaths(LPCTSTR pszChild, LPCTSTR pszParent)
{
    DWORD dwRet = PATH_IS_DIFFERENT;

    TCHAR szParent[MAX_PATH];
    StrCpyN(szParent, pszParent, ARRAYSIZE(szParent));

    if (PathIsRoot(szParent) && (-1 != PathGetDriveNumber(szParent)))
    {
        szParent[2] = 0;    // trip D:\ -> D: to make code below work
    }

    INT cchParent = lstrlen(szParent);
    INT cchChild = lstrlen(pszChild);

    if (cchParent <= cchChild)
    {
        TCHAR szChild[MAX_PATH];
        lstrcpyn(szChild, pszChild, ARRAYSIZE(szChild));

        LPTSTR pszChildSlice = szChild + cchParent;
        if (TEXT('\\') == *pszChildSlice)
        {
            *pszChildSlice = 0;
        }

        if (lstrcmpi(szChild, szParent) == 0)
        {
            if (cchParent < cchChild)
            {
                LPTSTR pTmp = pszChildSlice + 1;

                while (*pTmp && *pTmp != TEXT('\\'))
                {
                    pTmp++; // find second level path segments
                }

                if (!(*pTmp))
                {
                    dwRet = PATH_IS_CHILD;  // direct child
                }
            }
            else
            {
                dwRet = PATH_IS_EQUAL;
            }
        }
    }

    return dwRet;
}

// Checks the path to see if it is marked as system or read only and
// then check desktop.ini for CLSID or CLSID2 entry...

BOOL IsPathAlreadyShellFolder(LPCTSTR pszPath, DWORD dwAttrib)
{
    BOOL bIsShellFolder = FALSE;

    if (PathIsSystemFolder(pszPath, dwAttrib))
    {
        TCHAR szDesktopIni[MAX_PATH];
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // Check for CLSID entry...
        TCHAR szBuffer[MAX_PATH];
        GetPrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID"), TEXT("foo"), szBuffer, ARRAYSIZE(szBuffer), szDesktopIni);

        if ((lstrcmpi(szBuffer, TEXT("foo")) !=0) &&
             (lstrcmpi(szBuffer, MYDOCS_CLSID) !=0))
        {
            bIsShellFolder = TRUE;
        }

        // Check for CLSID2 entry...
        GetPrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID2"), TEXT("foo"), szBuffer, ARRAYSIZE(szBuffer), szDesktopIni);

        if ((lstrcmpi(szBuffer, TEXT("foo")) != 0) &&
             (lstrcmpi(szBuffer, MYDOCS_CLSID) != 0))
        {
            bIsShellFolder = TRUE;
        }
    }
    return bIsShellFolder;
}

const struct
{
    DWORD dwDir;
    DWORD dwFlags;
    DWORD dwRet;
}
_adirs[] =
{
    { CSIDL_DESKTOP,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_DESKTOP   },
    { CSIDL_PERSONAL,           PATH_IS_EQUAL                , PATH_IS_MYDOCS    },
    { CSIDL_SENDTO,             PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_SENDTO    },
    { CSIDL_RECENT,             PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_RECENT    },
    { CSIDL_HISTORY,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_HISTORY   },
    { CSIDL_COOKIES,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_COOKIES   },
    { CSIDL_PRINTHOOD,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_PRINTHOOD },
    { CSIDL_NETHOOD,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_NETHOOD   },
    { CSIDL_STARTMENU,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_STARTMENU },
    { CSIDL_TEMPLATES,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_TEMPLATES },
    { CSIDL_FAVORITES,          PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_FAVORITES },
    { CSIDL_FONTS,              PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_FONTS     },
    { CSIDL_APPDATA,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_APPDATA   },
    { CSIDL_INTERNET_CACHE,     PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_TEMP_INET },
    { CSIDL_COMMON_STARTMENU,   PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_STARTMENU },
    { CSIDL_COMMON_DESKTOPDIRECTORY, PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_DESKTOP },
    { CSIDL_WINDOWS,            PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_WINDOWS },
    { CSIDL_SYSTEM,             PATH_IS_EQUAL | PATH_IS_CHILD, PATH_IS_SYSTEM },
    { CSIDL_PROFILE,            PATH_IS_EQUAL                , PATH_IS_PROFILE },
};

BOOL PathEndsInDot(LPCTSTR pszPath)
{
    // CreateDirectory("c:\foo.") or CreateDirectory("c:\foo.....")
    // will succeed but create a directory named "c:\foo", which isn't
    // what the user asked for.  So we use this function to guard
    // against those cases.
    //
    // Note that this simple test also picks off "c:\foo\." -- ok for
    // our purposes.

    UINT cLen = lstrlen(pszPath);
    return (cLen >= 1) && (pszPath[cLen - 1] == TEXT('.'));
}

//
// Checks the path to see if it is okay as a MyDocs path
//
DWORD IsPathGoodMyDocsPath(HWND hwnd, LPCTSTR pszPath)
{
    if (NULL == pszPath)
    {
        return PATH_IS_ERROR;
    }
    
    TCHAR szRootPath[MAX_PATH];
    lstrcpyn(szRootPath, pszPath, ARRAYSIZE(szRootPath));
    if (!PathStripToRoot(szRootPath))
    {
        return PATH_IS_ERROR;
    }

    if (PathEndsInDot(pszPath))
    {
        return PATH_IS_ERROR;
    }
    
    DWORD dwRes, dwAttr = GetFileAttributes(pszPath);
    if (dwAttr == 0xFFFFFFFF)
    {
        if (0xFFFFFFFF == GetFileAttributes(szRootPath))
        {
            // If the root path doesn't exist, then we're not going
            // to be able to create a path:
            return PATH_IS_ERROR;
        }
        else
        {
            return PATH_IS_NONEXISTENT;
        }
    }

    if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
    {
        return PATH_IS_NONDIR;
    }

    for (int i = 0; i < ARRAYSIZE(_adirs); i++)
    {
        TCHAR szPathToCheck[MAX_PATH];
        //
        // Check for various special shell folders
        //
        if (S_OK == SHGetFolderPath(hwnd, _adirs[i].dwDir | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPathToCheck))
        {
            dwRes = ComparePaths(pszPath, szPathToCheck);

            if (dwRes & _adirs[i].dwFlags)
            {
                //
                // The inevitable exceptions
                //
                switch (_adirs[i].dwDir) 
                {
                case CSIDL_DESKTOP:
                    if (PATH_IS_CHILD == dwRes) 
                    {
                        continue;   // allowing subfolder of CSIDL_DESKTOP
                    }
                    break;

                default:
                    break;
                } // switch

                return _adirs[i].dwRet;
            }
        }
    }
    
    //
    // Make sure path isn't set as a system or some other kind of
    // folder that already has a CLSID or CLSID2 entry...
    //
    if (IsPathAlreadyShellFolder(pszPath, dwAttr))
    {
        return PATH_IS_SHELLFOLDER;
    }

    return PATH_IS_GOOD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\mydocs2\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "My Documents Folder UI"
#define VER_INTERNALNAME_STR            "mydocs"
#define VER_LEGALCOPYRIGHT_YEARS        "1997"
#define VER_ORIGINALFILENAME_STR        "mydocs.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common.inc ===
DAVTRANS_ROOT=$(BASEDIR)\shell\ext\davtrans
DAVTRANS_IFACES=$(DAVTRANS_ROOT)\ifaces
DAVTRANS_CLSIDS=$(DAVTRANS_ROOT)\clsids
DAVINET_ROOT=$(DAVTRANS_ROOT)\davinet
HTTPCOM_ROOT=$(DAVTRANS_ROOT)\common

C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\asyncwntu.cpp ===
#include "asyncwnt.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY asyncwntIME[] =
{
    _INTFMAPENTRY(CAsyncWnt, IAsyncWnt),
};

const INTFMAPENTRY* CAsyncWnt::_pintfmap = asyncwntIME;
const DWORD CAsyncWnt::_cintfmap =
    (sizeof(asyncwntIME)/sizeof(asyncwntIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CAsyncWnt::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\asyncwnt.h ===
#ifndef _ASYNCWNT_H
#define _ASYNCWNT_H

#include <windows.h>
#include <wininet.h>
#include "unk.h"
#include "iasyncwnt.h"

class CAsyncWntImpl : public CCOMBase, public IAsyncWnt
{
public:
    CAsyncWntImpl();
    ~CAsyncWntImpl();

    STDMETHODIMP Init();

    STDMETHODIMP SetUserAgent   (LPCWSTR         pwszUserAgent);
    STDMETHODIMP SetLogFilePath (LPCWSTR         pwszLogFilePath);

    STDMETHODIMP Request (LPCWSTR              pwszURL,
                          LPCWSTR              pwszVerb,
                          LPCWSTR              pwszHeaders,
                          ULONG                nAcceptTypes,
                          LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                          IAsyncWntCallback*   pcallback,
                          DWORD                dwContext);

    STDMETHODIMP RequestWithStream (LPCWSTR              pwszURL,
                                    LPCWSTR              pwszVerb,
                                    LPCWSTR              pwszHeaders,
                                    ULONG                nAcceptTypes,
                                    LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                    IStream*             pStream,
                                    IAsyncWntCallback*   pcallback,
                                    DWORD                dwContext);

    STDMETHODIMP RequestWithBuffer (LPCWSTR              pwszURL,
                                    LPCWSTR              pWszVerb,
                                    LPCWSTR              pwszHeaders,
                                    ULONG                nAcceptTypes,
                                    LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                    LPBYTE               pbBuffer,
                                    UINT                 cbBuffer,
                                    IAsyncWntCallback*   pcallback,
                                    DWORD                dwContext);
private:
    // internal utility functions
    STDMETHODIMP _WriteRequestToLog(LPCWSTR pwszURL, 
                                    LPCWSTR pwszVerb, 
                                    ULONG   nAcceptTypes, 
                                    LPCWSTR rgwszAcceptTypes[], 
                                    LPCWSTR pwszHeaders);

    STDMETHODIMP _WriteResponseToLog(LPWSTR pwszVerb, 
                                     LPWSTR pwszURL, 
                                     UINT   cchResponseHeaders,
                                     LPWSTR pwszResponseHeaders,
                                     DWORD  dwStatusCode, 
                                     LPWSTR pwszStatusMsg, 
                                     LPWSTR pwszContentType, 
                                     UINT   cbSent, 
                                     LPVOID pbResponse, 
                                     UINT bytesReadTotal);

    STDMETHODIMP _MasterDriver (LPCWSTR              pwszURL,
                                LPCWSTR              pwszVerb,
                                LPCWSTR              pwszHeaders,
                                ULONG                nAcceptTypes,
                                LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                LPBYTE               pbBuffer,
                                UINT                 cbBuffer,
                                IStream*             pStream,
                                IAsyncWntCallback*   pcallback,
                                DWORD                dwContext);

    STDMETHODIMP _MasterConnect_InternetOpen(HINTERNET* phInternet);

    STDMETHODIMP _MasterConnect_InternetConnect(HINTERNET            hInternet,
                                                LPCWSTR              pwszURL,
                                                IAsyncWntCallback*   pcallback,
                                                HINTERNET*           phConnection,
                                                LPWSTR*              ppwszPath);

    STDMETHODIMP _MasterConnect_HttpOpenRequest(HINTERNET            hSession,
                                                LPCWSTR              pwszVerb,
                                                LPWSTR               pwszPath,
                                                UINT                 nAcceptTypes,
                                                LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],                                            
                                                HINTERNET*           phRequest);

    STDMETHODIMP _MasterConnect (LPCWSTR              pwszURL,
                                 LPCWSTR              pwszVerb,
                                 ULONG                nAcceptTypes,
                                 LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                 IAsyncWntCallback*   pcallback,
                                 DWORD                dwContext,
                                 HINTERNET*           phRequest);

    STDMETHODIMP _MasterRequest (HINTERNET           hRequest,
                                 LPCWSTR             pwszHeaders,
                                 LPBYTE              pbBuffer,
                                 UINT                cbBuffer,
                                 IStream*            pStream,
                                 DWORD*              pcbSent);

    STDMETHODIMP _MasterListen (HINTERNET            hRequest,
                                LPCWSTR              pwszURL,
                                LPCWSTR              pwszVerb,
                                DWORD                cbSent,
                                IAsyncWntCallback*   pcallback,
                                DWORD                dwContext);

private:
    // member variables
    LPWSTR _pwszUserAgent;
    LPWSTR _pwszLogFilePath;
};

typedef CUnkTmpl<CAsyncWntImpl> CAsyncWnt;

#endif // _ASYCNWNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\asyncwnt.cpp ===
// asyncwnt.cpp

#include <windows.h>
#include <wininet.h>
#include <assert.h>
#include <time.h>
#include <stdlib.h> // get rid of this, find a better IntToStr

#include "iasyncwnt.h"
#include "asyncwnt.h"
#include "asyncwnt.clsid.h"
#include "qxml.h"
#include "strutil.h"
#include "mischlpr.h"
#include <stdio.h>
//#define TRACE(a) (fprintf(stderr,"%d %s\n",GetTickCount(),a))
#define TRACE(a)

////////////////////////////////////////////////
//
// Globals
//

static HMODULE g_hModule = NULL;
static long g_cComponents = 0;
static long g_cServerLocks = 0;

const char g_szFriendlyName[] = "ASYNC WININET";
const char g_szVerIndProgID[] = "NeptuneStorage.AsyncWnt";
const char g_szProgID[] =       "NeptuneStorage.AsyncWnt.1";


////////////////////////////////////////////////
//
// Class AsyncWnt
//
CAsyncWntImpl::CAsyncWntImpl(): _pwszUserAgent(NULL), _pwszLogFilePath(NULL)
{
    TRACE("CAsyncWnt::CAsyncWnt");
}

CAsyncWntImpl::~CAsyncWntImpl()
{
    TRACE("CAsyncWnt::~CAsyncWnt");
}

STDMETHODIMP CAsyncWntImpl::Init() {
    TRACE("CAsyncWnt::Init");
    return S_OK;
}


////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::SetUserAgent (LPCWSTR pwszUserAgent)
{
    HRESULT hr = S_OK;
    TRACE("CAsyncWnt::SetUserAgent");

    if (!pwszUserAgent)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (!_pwszUserAgent)
        {
            free(_pwszUserAgent);
            _pwszUserAgent = NULL;
        }

        _pwszUserAgent = DuplicateStringW(pwszUserAgent);
        if (!_pwszUserAgent)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::SetLogFilePath (LPCWSTR pwszLogFilePath)
{
    HRESULT hr = S_OK;
    TRACE("CAsyncWnt::SetLogFilePath");

    if (_pwszLogFilePath)
    {
        free(_pwszLogFilePath);
        _pwszLogFilePath = NULL;
    }
        
        
    if (!pwszLogFilePath)
    {
        // no logging requested
    }
    else
    {
        _pwszLogFilePath = DuplicateStringW(pwszLogFilePath);
        if (!_pwszLogFilePath)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::Request (LPCWSTR               pwszURL,
                                     LPCWSTR              pwszVerb,
                                     LPCWSTR              pwszHeaders,
                                     ULONG                nAcceptTypes,
                                     LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                     IAsyncWntCallback*   pcallback,
                                     DWORD                dwContext)
{
    TRACE("CAsyncWnt::Request");
    return this->_MasterDriver(pwszURL,
                               pwszVerb,
                               pwszHeaders,
                               nAcceptTypes,
                               rgwszAcceptTypes,
                               NULL,
                               0,
                               NULL,
                               pcallback,
                               dwContext);
}

////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::RequestWithStream (LPCWSTR              pwszURL,
                                                LPCWSTR              pwszVerb,
                                                LPCWSTR              pwszHeaders,
                                                ULONG                nAcceptTypes,
                                                LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                                IStream*             pStream,
                                                IAsyncWntCallback*   pcallback,
                                                DWORD                dwContext)
{
    TRACE("CAsyncWnt::RequestWithStream");
    return this->_MasterDriver(pwszURL,
                               pwszVerb,
                               pwszHeaders,
                               nAcceptTypes,
                               rgwszAcceptTypes,
                               NULL,
                               0,
                               pStream,
                               pcallback,
                               dwContext);
}

////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::RequestWithBuffer (LPCWSTR              pwszURL,
                                                LPCWSTR              pwszVerb,
                                                LPCWSTR              pwszHeaders,
                                                ULONG                nAcceptTypes,
                                                LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                                LPBYTE               pbBuffer,
                                                UINT                 cbBuffer,
                                                IAsyncWntCallback*   pcallback,
                                                DWORD                dwContext)
{
    TRACE("CAsyncWnt::RequestWithBuffer");
    return this->_MasterDriver(pwszURL,
                               pwszVerb,
                               pwszHeaders,
                               nAcceptTypes,
                               rgwszAcceptTypes,
                               pbBuffer,
                               cbBuffer,
                               NULL,
                               pcallback,
                               dwContext);
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_WriteRequestToLog(LPCWSTR pwszURL, 
                                               LPCWSTR pwszVerb, 
                                               ULONG   nAcceptTypes, 
                                               LPCWSTR rgwszAcceptTypes[], 
                                               LPCWSTR pwszHeaders)
{
    HRESULT hr = S_OK;
    DWORD dw;
    WCHAR wszTime[30];
    WCHAR wszDate[20];
    
    TRACE("CAsyncWnt::_WriteRequestToLog");
    HANDLE hFile;
    hFile = CreateFile(_pwszLogFilePath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if ((SetFilePointer(hFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER) && (GetLastError() != ERROR_SUCCESS))
        {
            hr = E_FAIL;
        }
        else
        {
            _wstrtime(wszTime);
            _wstrdate(wszDate);
            WriteFile(hFile, wszDate, lstrlen(wszDate) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L",", lstrlen(L",") * sizeof(WCHAR), &dw, NULL);
            
            WriteFile(hFile, wszTime, lstrlen(wszTime) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n,", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Client says:\r\n", lstrlen(L"Client says:\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"URL:\r\n", lstrlen(L"URL:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszURL, lstrlen(pwszURL) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Verb:\r\n", lstrlen(L"Verb:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszVerb, lstrlen(pwszVerb) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            for (ULONG i = 0; i < nAcceptTypes; i++)
            {
                WriteFile(hFile, L"Accept:", lstrlen(L"Accept:") * sizeof(WCHAR), &dw, NULL);
                WriteFile(hFile, rgwszAcceptTypes[i], lstrlen(rgwszAcceptTypes[i]) * sizeof(WCHAR), &dw, NULL);
                WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);
            }

            WriteFile(hFile, L"Headers:\r\n", lstrlen(L"Headers:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszHeaders, lstrlen(pwszHeaders) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"**************************\r\n\r\n", lstrlen(L"**************************\r\n\r\n") * sizeof(WCHAR), &dw, NULL);
        }

        CloseHandle(hFile);
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_WriteResponseToLog(LPWSTR pwszVerb, 
                                                LPWSTR pwszURL, 
                                                UINT   cchResponseHeaders,
                                                LPWSTR pwszResponseHeaders,
                                                DWORD  dwStatusCode, 
                                                LPWSTR pwszStatusMsg, 
                                                LPWSTR pwszContentType, 
                                                UINT   cbSent, 
                                                LPVOID UNREF_PARAM(pbResponse), 
                                                UINT bytesReadTotal)
{
    HRESULT hr = S_OK;
    DWORD dw;
    WCHAR wszTime[30];
    WCHAR wszDate[20];
    WCHAR wszCode[20];

    TRACE("CAsyncWnt::_WriteResponseToLog");
    HANDLE hFile;
    hFile = CreateFile(_pwszLogFilePath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if ((SetFilePointer(hFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER) && (GetLastError() != ERROR_SUCCESS))
        {
            hr = E_FAIL;
        }
        else
        {
            _wstrtime(wszTime);
            _wstrdate(wszDate);
            WriteFile(hFile, wszDate, lstrlen(wszDate) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L",", lstrlen(L",") * sizeof(WCHAR), &dw, NULL);
            
            WriteFile(hFile, wszTime, lstrlen(wszTime) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n,", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Server says:\r\n", lstrlen(L"Client says:\r\n") * sizeof(WCHAR), &dw, NULL);

            // begin actual data
            WriteFile(hFile, L"URL:\r\n", lstrlen(L"URL:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszURL, lstrlen(pwszURL) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Verb:\r\n", lstrlen(L"Verb:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszVerb, lstrlen(pwszVerb) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Response Headers:\r\n", lstrlen(L"Response Headers:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszResponseHeaders, cchResponseHeaders * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Status:\r\n", lstrlen(L"Status:\r\n") * sizeof(WCHAR), &dw, NULL);
            _itow(dwStatusCode,wszCode,10);
            WriteFile(hFile, wszCode, lstrlen(wszCode) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"-", lstrlen(L"-") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszStatusMsg, lstrlen(pwszStatusMsg) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Bytes sent:\r\n", lstrlen(L"Bytes sent:\r\n") * sizeof(WCHAR), &dw, NULL);
            _itow(cbSent,wszCode,10);
            WriteFile(hFile, wszCode, lstrlen(wszCode) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Bytes received:\r\n", lstrlen(L"Bytes received:\r\n") * sizeof(WCHAR), &dw, NULL);
            _itow(bytesReadTotal,wszCode,10);
            WriteFile(hFile, wszCode, lstrlen(wszCode) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            WriteFile(hFile, L"Content-Type:\r\n", lstrlen(L"Content-Type:\r\n") * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, pwszContentType, lstrlen(pwszContentType) * sizeof(WCHAR), &dw, NULL);
            WriteFile(hFile, L"\r\n", lstrlen(L"\r\n") * sizeof(WCHAR), &dw, NULL);

            // end actual data
            WriteFile(hFile, L"**************************\r\n\r\n", lstrlen(L"**************************\r\n\r\n") * sizeof(WCHAR), &dw, NULL);
        }

        CloseHandle(hFile);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterDriver (LPCWSTR              pwszURL,
                                           LPCWSTR              pwszVerb,
                                           LPCWSTR              pwszHeaders,
                                           ULONG                nAcceptTypes,
                                           LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                           LPBYTE               pbBuffer,
                                           UINT                 cbBuffer,
                                           IStream*             pStream,
                                           IAsyncWntCallback*   pcallback,
                                           DWORD                dwContext)
{
    // locals
    HRESULT hr = S_OK;

    TRACE("CAsyncWnt::_MasterDriver");

    // argument checking

    if (((!pbBuffer) && (cbBuffer > 0)) || ((!pbBuffer) && (cbBuffer > 0)))
    {
        hr = E_INVALIDARG;
    } 
    else if (pbBuffer && pStream) // buffer or stream but not both
    {
        hr = E_INVALIDARG;
    }
    else if (!pwszURL || !pwszVerb)
    {
        hr = E_INVALIDARG;
    }
    else
    {        
        // code        
        LPCWSTR pwszLocalHeader = pwszHeaders ? pwszHeaders : L"Content-Type: application/x-www-form-urlencoded\n";

        // -- connect to the server
        HINTERNET hRequest = NULL;
        hr = this->_MasterConnect(pwszURL, pwszVerb, nAcceptTypes, rgwszAcceptTypes,
                                  pcallback, dwContext, &hRequest);
        if (SUCCEEDED(hr))
        {
            DWORD cbSent;    
            hr = this->_MasterRequest(hRequest, pwszLocalHeader, pbBuffer,
                                      cbBuffer, pStream, &cbSent);
            if (SUCCEEDED(hr))
            {
                // -- request was sent, write to log if appropriate
                if (_pwszLogFilePath)
                {
                    hr = this->_WriteRequestToLog(pwszURL, pwszVerb, nAcceptTypes, 
                                                  rgwszAcceptTypes, pwszHeaders);
                }

                if (SUCCEEDED(hr))
                {
                    hr = this->_MasterListen(hRequest, pwszURL, pwszVerb,
                                             cbSent, pcallback, dwContext);
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterConnect_InternetOpen(HINTERNET* phInternet)
{
    TRACE("CAsyncWnt::_MasterConnect_InternetOpen");
    *phInternet = InternetOpen(L"AsyncWnt",                   // agent
                               INTERNET_OPEN_TYPE_PRECONFIG,  // access type
                               NULL,                          // proxy name (not used)
                               NULL,                          // proxy bypass (not used)
                               0);                            // flags
    return S_OK;
}

/////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterConnect_InternetConnect(HINTERNET            hInternet,
                                                           LPCWSTR              pwszURL,
                                                           IAsyncWntCallback*   pcallback,
                                                           HINTERNET*           phSession,
                                                           LPWSTR*              ppwszPath)
{
    // locals
    HRESULT hr = S_OK;
    UINT uiOffset = 0;
    USHORT port;
    LPWSTR pwszSvrHostname = NULL;
    
    WCHAR wszUsername[255]; // we should use a better constant
    WCHAR wszPassword[255];
    LPWSTR pwszUsername = NULL;
    LPWSTR pwszPassword = NULL;
    URL_COMPONENTS urlComponents = {0};

    TRACE("CAsyncWnt::_MasterConnect_InternetConnect");
    // code

    // ---- first get the port of the destination
    // don't store this in hr, port not required
    // -- first parse the URL (server, port, path)
    urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
    urlComponents.dwHostNameLength = 1;
    urlComponents.dwUrlPathLength = 1;
    urlComponents.nPort = 1;
    if (!InternetCrackUrl(pwszURL, 0, 0, &urlComponents))
    {
        hr = E_FAIL;
    }
    else
    {
        pwszSvrHostname = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwHostNameLength));
        if (!pwszSvrHostname)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            lstrcpyn(pwszSvrHostname, urlComponents.lpszHostName, 1 + urlComponents.dwHostNameLength); // +1 for the final null char
                        
            port = urlComponents.nPort;
            *ppwszPath = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwUrlPathLength));
            
            if (!(*ppwszPath))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpyn(*ppwszPath, urlComponents.lpszUrlPath, 1 + urlComponents.dwUrlPathLength); // +1 for the final null char
                
                // ---- then get the username, password
                pwszUsername = NULL;
                pwszPassword = NULL;

                if (pcallback)
                {
                    hr = pcallback->OnAuthChallenge(wszUsername, wszPassword);
                
                    if (SUCCEEDED(hr))
                    {
                        if (lstrlen(wszUsername) > 0)
                        {
                            pwszUsername = wszUsername;
                        }
                    
                        if (lstrlen(wszPassword) > 0)
                        {
                            pwszPassword = wszPassword;
                        }
                    }
                }
                    
                // ---- third actually establish the connection
                *phSession = InternetConnect(hInternet,               // internet handle
                                             pwszSvrHostname,         // hostname of server
                                             port,                    // port number of server
                                             pwszUsername,            // username
                                             pwszPassword,            // password
                                             INTERNET_SERVICE_HTTP,   // service to use
                                             0,                       // flags
                                             1);                      // context info
            }
        }
    }

    if (pwszSvrHostname)
    {
        free(pwszSvrHostname);
    }

    return hr;
}

/////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterConnect_HttpOpenRequest(HINTERNET            hSession,
                                                           LPCWSTR               pwszVerb,
                                                           LPWSTR               pwszPath,
                                                           UINT                 nAcceptTypes,
                                                           LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],                                            
                                                           HINTERNET*           phRequest)
{
    HRESULT hr = S_OK;
    LPCWSTR* acceptAr = NULL;
    UINT i;

    TRACE("CAsyncWnt::_MasterConnect_HttpOpenRequest");
    // ---- first figure out what types are accepted, default is all
    if (nAcceptTypes == IASYNCWNT_ACCEPTALL)
    {
        // if no accept types passed in, assume "Accept: */*"
        
        acceptAr = (LPCWSTR*)malloc(sizeof(LPCWSTR) * 2);
        if (!acceptAr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            acceptAr[0] = L"*/*";
            acceptAr[1] = NULL;
        }
        
    } else if (nAcceptTypes == 0) {
        acceptAr = (LPCWSTR*)malloc(sizeof(LPCWSTR) * 1);
        if (!acceptAr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            acceptAr[0] = NULL;
        }
    } else {
        acceptAr = (LPCWSTR*)malloc(sizeof(LPCWSTR) * (nAcceptTypes + 1));
        if (!acceptAr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            for (i = 0 ; i < nAcceptTypes ; i++)
            {
                acceptAr[i] = rgwszAcceptTypes[i];
            }
            acceptAr[nAcceptTypes] = NULL;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // ---- then we can create the request
        *phRequest = HttpOpenRequestW(hSession,              // connection
                                      pwszVerb,              // verb
                                      pwszPath,              // objectname
                                      NULL,                  // HTTP version
                                      NULL,                  // referrer
                                      acceptAr,              // accept types
                                      0,                     // flags
                                      1);                    // context
        
        if (!(*phRequest))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (acceptAr)
    {
        free(acceptAr);
    }

    return hr;
}

/////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterConnect (LPCWSTR              pwszURL,
                                            LPCWSTR              pwszVerb,
                                            ULONG                nAcceptTypes,
                                            LPCWSTR __RPC_FAR    rgwszAcceptTypes[  ],
                                            IAsyncWntCallback*   pcallback,
                                            DWORD                UNREF_PARAM(dwContext),
                                            HINTERNET*           phRequest)
                                            
{
    // locals
    HRESULT   hr = S_OK;    
    HINTERNET hInternet = NULL;
    HINTERNET hSession = NULL;    
    LPWSTR    pwszPath = NULL;
    
    TRACE("CAsyncWnt::_MasterConnect");
    
    // code
    // -- first establish the internet handle
    hr = this->_MasterConnect_InternetOpen(&hInternet);
    if (SUCCEEDED(hr))
    {
        if (!hInternet)
        {
            hr = E_FAIL;
        }
        else
        {
            // -- next connect the internet session        
            hr = this->_MasterConnect_InternetConnect(hInternet, pwszURL, pcallback, &hSession, &pwszPath);
            if (SUCCEEDED(hr))
            {
                if (!hSession)
                {
                    hr = E_FAIL;
                }
                else
                {
                    // -- send the request across the connection
                    hr = this->_MasterConnect_HttpOpenRequest(hSession, pwszVerb, pwszPath, nAcceptTypes, rgwszAcceptTypes, phRequest);                        
                }
            }
        }
    }

    if (pwszPath)
    {
        free(pwszPath);
    }

    return hr;
}

/////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterRequest (HINTERNET           hRequest,
                                            LPCWSTR             pwszHeaders,
                                            LPBYTE              pbBuffer,
                                            UINT                cbBuffer,
                                            IStream*            pStream,
                                            DWORD*              pcbSent)
{
    // locals
    HRESULT hr = S_OK;
    STATSTG stats;
    LPVOID pbBufferLocal = NULL;
    DWORD cbBufferLocal = 0;
    LARGE_INTEGER liOffset = {0};
    DWORD cchHeaders;

    TRACE("CAsyncWnt::_MasterRequest");
    // code

    *pcbSent = 0;

    if (pStream)     
    {
        // ---- use the contents of the file as the body of the request
        hr = pStream->Stat(&stats, STATFLAG_NONAME);
        if (SUCCEEDED(hr))
        {
            cbBufferLocal = stats.cbSize.LowPart; // ISSUE: 2000/02/16-aidanl fails for streams > 2gig
            pbBufferLocal = (unsigned char *) malloc (cbBufferLocal);
            if (!pbBufferLocal)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = pStream->Seek(liOffset,STREAM_SEEK_SET,NULL); // should we seek to start, or should we write what's left of file?
                if (SUCCEEDED(hr))
                {
                    hr = pStream->Read(pbBufferLocal, cbBufferLocal, NULL);
                }
            }
        }
    }
    else
    {
        // ---- if pStream is null, use the pbBuffer and cbBuffer passed in, which may be NULL, which is fine
        pbBufferLocal = pbBuffer;
        cbBufferLocal = cbBuffer;
    }

    if (SUCCEEDED(hr))
    {
        if (!pwszHeaders)
        {
            cchHeaders = 0;
        }
        else
        {
            cchHeaders = lstrlen(pwszHeaders);
        }

        TRACE("CAsyncWnt::_MasterRequest - about to send request");
        if (!HttpSendRequestW(hRequest,
                      pwszHeaders,
                      cchHeaders,
                      (void*)pbBuffer,
                      cbBuffer))
        {
            hr = E_FAIL;
        }
        TRACE("CAsyncWnt::_MasterRequest - done sending request");

        *pcbSent = cbBufferLocal;
    }

    return hr;
}

/////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntImpl::_MasterListen (HINTERNET            hRequest,
                                           LPCWSTR              pwszURL,
                                           LPCWSTR              pwszVerb,
                                           DWORD                cbSent,
                                           IAsyncWntCallback*   pcallback,
                                           DWORD                UNREF_PARAM(dwContext))
{
    // locals
    HRESULT hr = S_OK;
    BYTE pbResponse[65000]; // BUGBUG: why did you choose this?
    BYTE buffer[1000];// BUGBUG: why did you choose this?

    DWORD bytesRead = 0;
    DWORD bytesReadTotal = 0;

    DWORD dwStatusCode;
    LPWSTR pwszStatusMsg = NULL;
    LPWSTR pwszContentType = NULL;
    
    DWORD cchTemp;
    WCHAR wszTemp[1000];// BUGBUG: why did you choose this?
    
    WCHAR wszResponseHeaders[10000];// BUGBUG: why did you choose this?
    DWORD cchResponseHeaders = 0;
    LPWSTR pwszResponseHeaders = NULL;
    
    TRACE("CAsyncWnt::_MasterListen");
    // code

    // for now, do the response synchronously

    // -- first, copy the response to buffer, 1000 bytes at a time
    // ---- BUGBUG: replace with virtualalloc, this can overflow trivially
    LPBYTE pbResponseCursor = pbResponse;

    do
    {
        if (!InternetReadFile(hRequest,    // handle to request to get response to
                              buffer,      // buffer to write response into
                              1000,        // size of buffer
                              &bytesRead))
        {
            hr = E_FAIL;
        }
        else
        {
            if (bytesRead>0)
            {
                CopyMemory(pbResponseCursor,buffer,bytesRead);
                pbResponseCursor+= bytesRead;

                bytesReadTotal+=bytesRead;
                if (bytesReadTotal > 65000)
                {
                    break; // BUGBUG: we should handle this better.
                }
            }
        }        
    } while (bytesRead>0 && SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        // now parse the response

        // -- get the return code (must be present or else error!)
        cchTemp=4;    
        if (!HttpQueryInfo(hRequest,                                        // handle to request to get info on
                           HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, // flags
                           &dwStatusCode,                                   // buffer to write into
                           &cchTemp,                                        // pointer to size of buffer
                           NULL))                                           // pointer to index to grab, unused
        {
            hr = E_FAIL;
        }
        else
        {    
            // -- call the pcallback, if appropriate, otherwise return this value as the return value of this function
            if (pcallback)
            {
                // -- get the return message, if present
                cchTemp = 1000;
                if (HttpQueryInfo(hRequest,                 // handle to request to get info on
                                  HTTP_QUERY_STATUS_TEXT,   // flags
                                  wszTemp,                  // buffer to write into
                                  &cchTemp,                 // pointer to size of buffer
                                  NULL))                    // pointer to index to grab, unused
                {
                    pwszStatusMsg = DuplicateStringW(wszTemp);
                }

                // -- get the return message, if present
                cchTemp=1000;
                if (HttpQueryInfo(hRequest,                 // handle to request to get info on
                                  HTTP_QUERY_CONTENT_TYPE, // flags
                                  wszTemp,                 // buffer to write into
                                  &cchTemp,                // pointer to size of buffer
                                  NULL))                   // pointer to index to grab, unused
                {
                    pwszContentType = DuplicateStringW(wszTemp);
                }
    
                // -- get the raw headers
                cchTemp=1000;
                if (HttpQueryInfo(hRequest,                 // handle to request to get info on
                                   //HTTP_QUERY_RAW_HEADERS,   // flags
                                   HTTP_QUERY_RAW_HEADERS_CRLF,   // flags, CRLF just for debugging
                                   wszResponseHeaders,               // buffer to write into
                                   &cchTemp,                 // pointer to size of buffer
                                   NULL))                    // pointer to index to grab, unused
                {
                    pwszResponseHeaders = wszResponseHeaders;
                    cchResponseHeaders = cchTemp;
                }
            
                // BUGBUG: cbBuffer needs to be updated, it's really the number of bytes we tried to send, we need to make it
                // the number of bytes that we DID send

                // write to the log, if appropriate
                if (_pwszLogFilePath)
                {
                    hr = this->_WriteResponseToLog((LPWSTR)pwszVerb, 
                                                     (LPWSTR)pwszURL, 
                                                     cchResponseHeaders,
                                                     pwszResponseHeaders,
                                                     dwStatusCode, 
                                                     pwszStatusMsg, 
                                                     pwszContentType, 
                                                     cbSent, 
                                                     pbResponse, 
                                                     bytesReadTotal);
                }

                if (SUCCEEDED(hr))
                {
                    // call the callback
                    hr = pcallback->Respond((LPWSTR)pwszVerb, 
                                              (LPWSTR)pwszURL, 
                                              cchResponseHeaders,
                                              pwszResponseHeaders,
                                              dwStatusCode, 
                                              pwszStatusMsg, 
                                              pwszContentType, 
                                              cbSent, 
                                              pbResponse, 
                                              bytesReadTotal);
                }
            }
            else
            {
                // no callback, just return the hr based on the HTTP Response Code
                if (dwStatusCode <= 99 ) {
                    hr = E_FAIL; // undefined                
                }
                else if (dwStatusCode <= 199) {
                    hr = S_OK; // RFC 2616 defines 1?? as "informational", ignore
                }
                else if (dwStatusCode <= 299) {
                    hr = S_OK; // RFC 2616 defines 2?? as "OK"
                }
                else if (dwStatusCode <= 399) {
                    hr = E_FAIL; // RFC 2616 defines 3?? as "redirection", we can't support this for now
                }
                else if (dwStatusCode <= 499) {
                    hr = E_FAIL; // RFC 2616 defines 4?? as "error"
                }
                else if (dwStatusCode <= 599) {
                    hr = E_FAIL; // RFC 2616 defines 5?? as "internal server error"
                }
                else
                {
                    hr = E_FAIL; // undefinfed
                }                
            }
        }
    }
    
    // release stuff
    if (pwszStatusMsg)
    {
        free(pwszStatusMsg);
    }

    if (pwszContentType)
    {
        free(pwszContentType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\idl\makefile.inc ===
$(DAVTRANS_ROOT)\ifaces\iasyncwnt.h: iasyncwnt.h
    copy $** $@

$(DAVTRANS_ROOT)\davstore\lib\iasyncwnt.tlb: iasyncwnt.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "asyncwnt.clsid.h"
#include "asyncwnt.h"

CFactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_AsyncWnt,
        CAsyncWnt::UnkCreateInstance,
        CAsyncWnt::UnkActiveComponents,
		L"Asynchronous WinInet",// Friendly name
		L"AsyncWnt.1",          // ProgID
		L"AsyncWnt",            // Version-independent
        TRUE,                  // ThreadingModel == Both
    },
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\clsids.cpp ===
// Define GUIDs of ASYNCWNT interface, component

#include <objbase.h>

extern "C"
{
    // {615D5814-21C8-4e16-9289-C9A9C5ADB4CF}
    extern const IID IID_IAsyncWnt = 
    { 0x615d5814, 0x21c8, 0x4e16, { 0x92, 0x89, 0xc9, 0xa9, 0xc5, 0xad, 0xb4, 0xcf } };

    // {23BDCB35-B4EE-45a6-86E0-0889348F28C2}
    extern const IID IID_IAsyncWntCallback  = 
    { 0x23bdcb35, 0xb4ee, 0x45a6, { 0x86, 0xe0, 0x8, 0x89, 0x34, 0x8f, 0x28, 0xc2 } };

    // {94392EA7-98AE-4e04-8E2C-E53387442D8E}
    extern const IID IID_IReportNetworkProgress  = 
    { 0x94392ea7, 0x98ae, 0x4e04, { 0x8e, 0x2c, 0xe5, 0x33, 0x87, 0x44, 0x2d, 0x8e } };

    // {B947C73F-DA0C-4914-BD1B-52DAB5A318CB}
    extern const CLSID CLSID_AsyncWnt = 
    { 0xb947c73f, 0xda0c, 0x4914, { 0xbd, 0x1b, 0x52, 0xda, 0xb5, 0xa3, 0x18, 0xcb } };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\asyncwnt\clsidslib\makefile.inc ===
$(DAVTRANS_CLSIDS)\lib\asyncwnt_g.lib: $(O)\asyncwnt_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\davstore.clsid.h ===
#ifndef __DAVSTORE_CLSID_H__
#define __DAVSTORE_CLSID_H__

extern "C" const IID IID_IDavStorage;
extern "C" const CLSID CLSID_CDavStorage;
extern "C" const CLSID CLSID_CDavStorageEnum;

#endif //__DAVSTORE_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\davinet.clsid.h ===
#ifndef __DAVINET_CLSID_H__
#define __DAVINET_CLSID_H__

extern "C" const IID IID_IDavTransport;
extern "C" const IID IID_IPropFindRequest;
extern "C" const IID IID_IPropPatchRequest;
extern "C" const IID IID_IDavCallback;

extern "C" const CLSID CLSID_DAVInet;
extern "C" const CLSID CLSID_DAVPropFindReq;
extern "C" const CLSID CLSID_DAVPropPatchReq;
extern "C" const CLSID CLSID_AsyncWntCallback;

#endif //__DAVINET_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\davbagmn.clsid.h ===
#ifndef __DAVBAGMN_CLSID_H__
#define __DAVBAGMN_CLSID_H__

extern "C" const IID IID_IDavBagMan;
extern "C" const CLSID CLSID_DAVBagMan;
extern "C" const CLSID CLSID_DAVBag;

#endif //__DAVBAGMN_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\asyncwnt.clsid.h ===
#ifndef __ASYNCWNT_CLSID_H__
#define __ASYNCWNT_CLSID_H__

extern "C" const CLSID CLSID_AsyncWnt;
extern "C" const IID IID_IAsyncWnt;
extern "C" const IID IID_IAsyncWntCallback;
extern "C" const IID IID_IReportNetworkProgress;
    
#endif //__ASYNCWNT_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\ftpstrm.clsid.h ===
#ifndef __FTPSTRM_CLSID_H__
#define __FTPSTRM_CLSID_H__

extern "C" const CLSID CLSID_FtpStrm;

#endif //__FTPSTRM_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\httpstor.clsid.h ===
#ifndef __HTTPSTOR_CLSID_H__
#define __HTTPSTOR_CLSID_H__

extern "C" const CLSID CLSID_HttpStorage;
extern "C" const IID IID_IHttpPropertyStorage;

#endif //__HTTPSTOR_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\ftpstore.clsid.h ===
#ifndef __FTPSTORE_CLSID_H__
#define __FTPSTORE_CLSID_H__

extern "C" const CLSID CLSID_CFtpStorage;

#endif //__FTPSTORE_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\shellstg.clsid.h ===
#ifndef __SHELLSTG_CLSID_H__
#define __SHELLSTG_CLSID_H__

extern "C" const IID IID_IShellStorage;
extern "C" const CLSID CLSID_CShellStorage;

#endif //__SHELLSTG_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\clsids\inc\httpstrm.clsid.h ===
#ifndef __HTTPSTRM_CLSID_H__
#define __HTTPSTRM_CLSID_H__

extern "C" const CLSID CLSID_HttpStrm;
extern "C" const IID IID_IHttpStrm;

#endif //__HTTPSTRM_CLSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\fact.h ===
#ifndef _FACT_H_
#define _FACT_H_

#include <objbase.h>
#include "factdata.h"

class CCOMBase;
class CCOMBaseFactory;

class CCOMBaseFactory : public IClassFactory
{
///////////////////////////////////////////////////////////////////////////////
// COM Interfaces
public:
	// IUnknown
	virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();
	
	// IClassFactory
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, REFIID riid,
        void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock);

///////////////////////////////////////////////////////////////////////////////
// 
public:
	CCOMBaseFactory(const CFactoryData* pFactoryData);
	~CCOMBaseFactory() {}

///////////////////////////////////////////////////////////////////////////////
// Helpers
private:
    static BOOL _IsLocked() { return (_cServerLocks > 0); }

public: // only for the exported fct in fact.cpp
	static HRESULT _RegisterAll();
	static HRESULT _UnregisterAll();
	static HRESULT _CanUnloadNow();
	static HRESULT _GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);

public:
	const CFactoryData*         _pFactoryData;
	static const CFactoryData*  _pDLLFactoryData;
    static const DWORD          _cDLLFactoryData;
	static HMODULE              _hModule;

private:
    static LONG                 _cServerLocks;   
	ULONG                       _cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\reg.h ===
#ifndef _REG_H_
#define _REG_H_

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
    REFCLSID clsid, 
    LPCWSTR szFriendlyName,
    LPCWSTR szVerIndProgID,
    LPCWSTR szProgID,
    BOOL fThreadingModelBoth);

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(REFCLSID clsid,
    LPCWSTR szVerIndProgID,
    LPCWSTR szProgID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\factdata.h ===
#ifndef _FACTDATA_H_
#define _FACTDATA_H_

#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
//  Component creation function
typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, IUnknown**);
typedef BOOL (*FPACTIVECOMPONENTS)();

///////////////////////////////////////////////////////////////////////////////
// CFactoryData
//   Information CFactory needs to create a component supported by the DLL
class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* _pCLSID;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance;

    // Pointer to the function that returns if there are active components
    // currently instantiated
    FPACTIVECOMPONENTS ActiveComponents;

    // Name of the component to register in the registry
    LPCWSTR _pszRegistryName;

    // ProgID
    LPCWSTR _pszProgID;

    // Version-independent ProgID
    LPCWSTR _pszVerIndProgID;

    // If we should set ThreadingModel == Both
    BOOL _fThreadingModelBoth;

    // Helper function for finding the class ID
    BOOL IsClassID(REFCLSID rclsid) const
    { return (*_pCLSID == rclsid);}
};

#endif //_FACTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\lib\makefile.inc ===
$(HTTPCOM_ROOT)\lib\$(O)\comlnm.lib: $(O)\comlnm.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\fact.cpp ===
///////////////////////////////////////////////////////////////////////////////
// CCOMBaseFactory
//    Base class for reusing a single class factory for all components in a DLL

#include "fact.h"
#include "unk.h"
#include "reg.h"

#ifdef RBDEBUG
#include "rbdebug.h"
#endif

LONG CCOMBaseFactory::_cServerLocks = 0;
HMODULE CCOMBaseFactory::_hModule = NULL;

///////////////////////////////////////////////////////////////////////////////
// Exported functions
STDAPI DllCanUnloadNow()
{
    return CCOMBaseFactory::_CanUnloadNow();
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    return CCOMBaseFactory::_GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer()
{
    return CCOMBaseFactory::_RegisterAll();
}

STDAPI DllUnregisterServer()
{
    return CCOMBaseFactory::_UnregisterAll();
}

///////////////////////////////////////////////////////////////////////////////
// DLL module information
BOOL WINAPI DllMain(HANDLE hModule, 
                      DWORD dwReason, 
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CCOMBaseFactory::_hModule = (HINSTANCE)hModule;

#ifdef RBDEBUG
        CRBDebug::Init();
#endif
    }
    else
    {
        if (dwReason == DLL_PROCESS_DETACH)
        {
#ifdef RBDEBUG
            CRBDebug::Cleanup();
#endif
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
STDMETHODIMP CCOMBaseFactory::QueryInterface(REFIID iid, void** ppv)
{   
    IUnknown* punk;
    HRESULT hres = S_OK;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        punk = this;
    }
    else
    {
        *ppv = NULL;
        hres = E_NOINTERFACE;
    }

    punk->AddRef();
    *ppv = punk;

    return hres;
}

STDMETHODIMP_(ULONG) CCOMBaseFactory::AddRef()
{
    return ::InterlockedIncrement((LONG*)&_cRef);
}

STDMETHODIMP_(ULONG) CCOMBaseFactory::Release()
{
    ULONG cRef = ::InterlockedDecrement((LONG*)&_cRef);

    if (!cRef)
    {
        delete this;
    }

    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
// IFactory implementation
STDMETHODIMP CCOMBaseFactory::CreateInstance(IUnknown* pUnknownOuter,
    REFIID riid, void** ppv)
{
    HRESULT hres = S_OK;

    // Aggregate only if the requested IID is IID_IUnknown.
    if ((pUnknownOuter != NULL) && (riid != IID_IUnknown))
    {
        hres = CLASS_E_NOAGGREGATION;
    }

    if (SUCCEEDED(hres))
    {
        // Create the component.
        IUnknown* punkNew;

        hres = _pFactoryData->CreateInstance(pUnknownOuter, &punkNew);

        if (SUCCEEDED(hres))
        {
//            ASSERT(punkNew);

            // Get the requested interface.
//            hres = pNewComponent->NondelegatingQueryInterface(iid, ppv);
            hres = punkNew->QueryInterface(riid, ppv);

            // Release the reference held by the class factory.
//            pNewComponent->NondelegatingRelease();
            punkNew->Release();
        }
    }

    return hres;
}

STDMETHODIMP CCOMBaseFactory::LockServer(BOOL bLock)
{
    if (bLock) 
    {
        ::InterlockedIncrement(&_cServerLocks);
    }
    else
    {
        ::InterlockedDecrement(&_cServerLocks);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CCOMBaseFactory implementation
CCOMBaseFactory::CCOMBaseFactory(const CFactoryData* pFactoryData) : _cRef(1),
    _pFactoryData(pFactoryData)
{}

// static
HRESULT CCOMBaseFactory::_GetClassObject(REFCLSID rclsid, REFIID riid,
    void** ppv)
{
    HRESULT hres = S_OK;
    
    if ((riid != IID_IUnknown) && (riid != IID_IClassFactory))
    {
        hres = E_NOINTERFACE;
    }

    if (SUCCEEDED(hres))
    {
        hres = CLASS_E_CLASSNOTAVAILABLE;

        // Traverse the array of data looking for this class ID.
        for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
        {
            const CFactoryData* pData = &_pDLLFactoryData[dw];

            if (pData->IsClassID(rclsid))
            {
                // Found the ClassID in the array of components we can
                // create.  So create a class factory for this component.
                // Pass the CDLLFactoryData structure to the class factory
                // so that it knows what kind of components to create.
                *ppv = (IUnknown*) new CCOMBaseFactory(pData);

                if (*ppv == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                else
                {
                    hres = NOERROR;
                }

                break;
            }
        }
    }

    return hres;
}

//static
HRESULT CCOMBaseFactory::_RegisterAll()
{
    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        RegisterServer(_hModule,
           *(_pDLLFactoryData[dw]._pCLSID),
           _pDLLFactoryData[dw]._pszRegistryName,
           _pDLLFactoryData[dw]._pszVerIndProgID,
           _pDLLFactoryData[dw]._pszProgID,
           _pDLLFactoryData[dw]._fThreadingModelBoth);
    }

    return S_OK;
}

//static
HRESULT CCOMBaseFactory::_UnregisterAll()
{
    for (DWORD dw = 0; dw < _cDLLFactoryData; ++dw)
    {
        UnregisterServer(*(_pDLLFactoryData[dw]._pCLSID),
            _pDLLFactoryData[dw]._pszVerIndProgID,
            _pDLLFactoryData[dw]._pszProgID);
    }

    return S_OK;
}

//static
HRESULT CCOMBaseFactory::_CanUnloadNow()
{
    HRESULT hres = S_OK;

    if (_IsLocked())
    {
        hres = S_FALSE;
    }
    else
    {
        for (DWORD dw = 0; (dw < _cDLLFactoryData) && (S_FALSE == hres); ++dw)
        {
            if (_pDLLFactoryData[dw].ActiveComponents())
            {
                hres = S_FALSE;
            }
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\unk.h ===
#ifndef _UNK_H_
#define _UNK_H_

#include <objbase.h>

class CCOMBase
{
public:
    virtual HRESULT UnkInit() { return S_OK; }
};

struct INTFMAPENTRY
{
    const IID*  piid;
    DWORD       dwOffset;
};

template <class CCOMBASE>
class CUnkTmpl : public CCOMBASE
{
public:
    CUnkTmpl(IUnknown*) : _cRef(1) { ::InterlockedIncrement((LONG*)&_cComponents); }
    ~CUnkTmpl() { ::InterlockedDecrement((LONG*)&_cComponents); }

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv)
    {
        HRESULT hres;

        if (IID_IUnknown == riid)
        {
            *ppv = (IUnknown*)(((PBYTE)this) + _pintfmap[0].dwOffset);
            hres = S_OK;
        }
        else
        {
            hres = _GetInterfaceFromMap(riid, ppv);
        }

        return hres;
    }

	STDMETHODIMP_(ULONG) AddRef() { return ::InterlockedIncrement((LONG*)&_cRef); }
	STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

protected:
    HRESULT _GetInterfaceFromMap(REFIID riid, void** ppv)
    {
        HRESULT hres = E_NOINTERFACE;

        for (DWORD dw = 0; dw < _cintfmap; ++dw)
        {
            if (riid == *(_pintfmap[dw].piid))
            {
                IUnknown* punk = (IUnknown*)(((PBYTE)this) + _pintfmap[dw].dwOffset);
                punk->AddRef();
                *ppv = punk;
                hres = S_OK;
                break;
            }
        }

        return hres;
    }

public:
    static HRESULT UnkCreateInstance(IUnknown* pUnknownOuter, IUnknown** ppunkNew)
    {
        HRESULT hres = E_OUTOFMEMORY;

        CUnkTmpl<CCOMBASE>* pNew = new CUnkTmpl<CCOMBASE>(pUnknownOuter);

        if (pNew)
        {
            hres = pNew->UnkInit();

            if (FAILED(hres))
            {
                delete pNew;
            }
            else
            {
                *ppunkNew = (IUnknown*)(((PBYTE)pNew) + pNew->_pintfmap[0].dwOffset);
            }
        }

        return hres;
    }

    static BOOL UnkActiveComponents()
    {
        LONG l = InterlockedCompareExchange((LONG*)&_cComponents, 0xFFFFFFFF, 0xFFFFFFFF);

        return l ? TRUE : FALSE;
    }

private:
    ULONG                       _cRef;

    static DWORD                _cComponents;
    static const INTFMAPENTRY*  _pintfmap;
    static const DWORD          _cintfmap;
};

// for now: being
#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(static_cast<base*>((derived*)8))-8)
#endif
// for now: end

#define _INTFMAPENTRY(Cthis, Ifoo) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Ifoo, Cthis) }

#define _INTFMAPENTRY2(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#endif // _UNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\comlnm\reg.cpp ===
#include <objbase.h>

#include "reg.h"

//for now
#define assert(a)

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))
///////////////////////////////////////////////////////////////////////////////
// Internal helper functions prototypes

BOOL _SetKeyAndValue(LPCWSTR pszPath, LPCWSTR szSubkey, LPCWSTR szValueName,
                    LPCWSTR szValue);
void _CLSIDtoChar(REFCLSID clsid, LPWSTR szCLSID, int length);
LONG _RecursiveDeleteKey(HKEY hKeyParent, LPCWSTR szKeyChild);

///////////////////////////////////////////////////////////////////////////////
// Constants

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39;

///////////////////////////////////////////////////////////////////////////////
// Public function implementation

// Register the component in the registry.
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       REFCLSID clsid,         // Class ID
                       LPCWSTR szFriendlyName, // Friendly Name
                       LPCWSTR szVerIndProgID, // Programmatic
                       LPCWSTR szProgID,       //   IDs
                       BOOL fThreadingModelBoth)
{
	// Get server location.
	WCHAR szModule[512];
	DWORD dwResult = ::GetModuleFileName(hModule, szModule, ARRAYSIZE(szModule));
	assert(dwResult != 0);

	// Convert the CLSID into a char.
	WCHAR szCLSID[CLSID_STRING_SIZE];
	_CLSIDtoChar(clsid, szCLSID, sizeof(szCLSID));

	// Build the key CLSID\\{...}
	WCHAR szKey[64];
	lstrcpy(szKey, L"CLSID\\");
	lstrcat(szKey, szCLSID);
  
	// Add the CLSID to the registry.
	_SetKeyAndValue(szKey, NULL, NULL, szFriendlyName);

	// Add the server filename subkey under the CLSID key.
	_SetKeyAndValue(szKey, L"InprocServer32", NULL, szModule);

	// Add the ProgID subkey under the CLSID key.
	_SetKeyAndValue(szKey, L"ProgID", NULL, szProgID);

	// Add the version-independent ProgID subkey under CLSID key.
	_SetKeyAndValue(szKey, L"VersionIndependentProgID", NULL,
	               szVerIndProgID);

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	_SetKeyAndValue(szVerIndProgID, NULL, NULL, szFriendlyName); 
	_SetKeyAndValue(szVerIndProgID, L"CLSID", NULL, szCLSID);
	_SetKeyAndValue(szVerIndProgID, L"CurVer", NULL, szProgID);

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	_SetKeyAndValue(szProgID, NULL, NULL, szFriendlyName); 
	_SetKeyAndValue(szProgID, L"CLSID", NULL, szCLSID);

    // Set the ThreadingModel, if applicable

    if (fThreadingModelBoth)
    {
	    _SetKeyAndValue(szKey, L"InprocServer32", L"ThreadingModel", L"Both");        
    }
    
    return S_OK;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(REFCLSID clsid,         // Class ID
                      LPCWSTR szVerIndProgID, // Programmatic
                      LPCWSTR szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	WCHAR szCLSID[CLSID_STRING_SIZE];
	_CLSIDtoChar(clsid, szCLSID, sizeof(szCLSID));

	// Build the key CLSID\\{...}
	WCHAR szKey[64];
	lstrcpy(szKey, L"CLSID\\");
	lstrcat(szKey, szCLSID);

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKey);
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)); // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID);
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)); // Subkey may not exist.

	// Delete the ProgID key.
	lResult = _RecursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID);
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)); // Subkey may not exist.

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Internal helper functions

// Convert a CLSID to a char string.
void _CLSIDtoChar(REFCLSID clsid,
                 LPWSTR szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE);
	// Get CLSID
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	assert(SUCCEEDED(hr));

    lstrcpyn(szCLSID, wszCLSID, length);
/*	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length);*/

	// Free memory.
	CoTaskMemFree(wszCLSID);
}

//
// Delete a key and all of its descendents.
//
LONG _RecursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        LPCWSTR lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild);
	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time;
	WCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = _RecursiveDeleteKey(hKeyChild, szBuffer);
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild);
			return lRes;
		}
		dwSize = 256;
	}

	// Close the child.
	RegCloseKey(hKeyChild);

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild);
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL _SetKeyAndValue(LPCWSTR szKey, LPCWSTR szSubkey, LPCWSTR szValueName,
    LPCWSTR szValue)
{
	HKEY hKey;
	WCHAR szKeyBuf[1024];

	// Copy keyname into buffer.
	lstrcpy(szKeyBuf, szKey);

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		lstrcat(szKeyBuf, L"\\");
		lstrcat(szKeyBuf, szSubkey );
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL);
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              (lstrlen(szValue) + 1) * sizeof(WCHAR));
	}

	RegCloseKey(hKey);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\qxml.cpp ===
#include <objbase.h>
#include "qxml.h"
//#include "dbgassrt.h"
#include <assert.h>
#include "strconv.h"

// BUGBUG: there are better ways to do this
#define ASSERT(a) (assert(a))
#define ASSERTVALIDSTATE()
#define INCDEBUGCOUNTER(a)
#define DECDEBUGCOUNTER(a)

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

#ifdef DEBUG
DWORD CQXML::d_cInstances = 0;
DWORD CQXML::d_cInstancesEnum = 0;
DWORD CQXML::d_cBSTRReturned = 0;
DWORD CQXML::d_cxddocRef = 0;
DWORD CQXML::d_cxdnodeRef = 0;
#endif

#define QXML_PARANOIA

HRESULT CQXML::_ValidateParams (LPCWSTR pszTag,
                                LPCWSTR pszNamespaceName, 
                                LPCWSTR pszNamespaceAlias)
{
    HRESULT hres = E_INVALIDARG;

    BOOL fNamespaceNameIsValid;
    BOOL fNamespaceAliasIsValid;

    if (pszTag && *pszTag) // must have tag
    {
        fNamespaceNameIsValid = (pszNamespaceName && *pszNamespaceName) ? TRUE : FALSE;
        fNamespaceAliasIsValid = (pszNamespaceAlias && *pszNamespaceAlias) ? TRUE : FALSE;
        
        // must have namespace name and alias or neither
        if ((fNamespaceNameIsValid && fNamespaceAliasIsValid) || (!fNamespaceNameIsValid && !fNamespaceAliasIsValid))
        {            
            hres = S_OK;
        }
    }

#ifdef QXML_PARANOIA
    if (SUCCEEDED(hres) && fNamespaceNameIsValid)
    {
        if (pszNamespaceName[lstrlen(pszNamespaceName) - 1] ==':')
        {
            hres = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hres) && fNamespaceAliasIsValid)
    {
        if (pszNamespaceAlias[lstrlen(pszNamespaceAlias) - 1] ==':')
        {
            hres = E_INVALIDARG;
        }
    }
#endif // QXML_PARANOIA
    return hres;       
}

HRESULT CQXML::InitFromBuffer(LPCWSTR psz)
{
    ASSERT(!_DbgIsInited());
    ASSERTVALIDSTATE();

    HRESULT hres = E_INVALIDARG;

    _fIsRoot = TRUE;

    if (psz && *psz)
    {
        hres = CoCreateInstance(CLSID_DOMDocument, 
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IXMLDOMDocument,
                        (void**)&_pxddoc);


        if (SUCCEEDED(hres))
        {   
            ASSERT(_pxddoc);
            INCDEBUGCOUNTER(d_cxddocRef);

            VARIANT_BOOL fSuccess;

            int cch = lstrlen(psz) + 1;

            BSTR bstr = SysAllocStringLen(NULL, cch);

            if (bstr)
            {
                lstrcpyn(bstr, psz, cch);

                hres = _pxddoc->loadXML(bstr, &fSuccess);

                if (SUCCEEDED(hres) && !fSuccess)
                {
                    hres = S_FALSE;

                    _pxddoc->Release();
                    _pxddoc = NULL;

                    DECDEBUGCOUNTER(d_cxddocRef);
                }
                else
                {
                    IXMLDOMElement* pxdelem;

                    hres = _pxddoc->get_documentElement(&pxdelem);

                    if (SUCCEEDED(hres) && (S_FALSE != hres))
                    {
                        ASSERT(pxdelem);

                        hres = pxdelem->QueryInterface(IID_IXMLDOMNode,
                                    (void**)&_pxdnode);

                        if (SUCCEEDED(hres))
                        {
                            ASSERT(_pxdnode);
                            INCDEBUGCOUNTER(d_cxdnodeRef);
                        }

                        pxdelem->Release();
                    }

                    if (FAILED(hres))
                    {
                        _pxdnode = NULL;

                        _pxddoc->Release();
                        _pxddoc = NULL;

                        DECDEBUGCOUNTER(d_cxddocRef);
                    }
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }
#ifdef DEBUG
    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        d_fInited = TRUE;
    }
#endif
    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::InitEmptyDoc(LPCWSTR pszDocName, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias)
{
    ASSERT(!_DbgIsInited());
    ASSERTVALIDSTATE();

    HRESULT hres = E_INVALIDARG;

    _fIsRoot = TRUE;

    if (SUCCEEDED(_ValidateParams(pszDocName, pszNamespaceName, pszNamespaceAlias)))
    {
        hres = CoCreateInstance(CLSID_DOMDocument, 
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IXMLDOMDocument,
                        (void**)&_pxddoc);

        if (SUCCEEDED(hres))
        {   
            ASSERT(_pxddoc);
            INCDEBUGCOUNTER(d_cxddocRef);

            hres = _SetDocTagName(pszDocName, pszNamespaceName, pszNamespaceAlias);

            if (FAILED(hres))
            {
                _pxddoc->Release();
                _pxddoc = NULL;

                DECDEBUGCOUNTER(d_cxddocRef);
            }
        }
    }
#ifdef DEBUG
    if (SUCCEEDED(hres))
    {
        d_fInited = TRUE;
    }
#endif

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetRootTagName(LPWSTR pszName, DWORD cchName)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (pszName && cchName)
    {
        hres = CQXMLHelper::GetTagTextFromNode(_pxdnode, pszName, cchName);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetRootNamespaceName(LPWSTR pszNamespaceName, DWORD cchNamespaceName)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (pszNamespaceName && cchNamespaceName)
    {
        hres = CQXMLHelper::GetNamespaceNameFromNode(_pxdnode, pszNamespaceName, cchNamespaceName);
        if (hres == S_FALSE)
        {
            *pszNamespaceName = NULL;
        }

    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetRootNamespaceAlias(LPWSTR pszNamespaceAlias, DWORD cchNamespaceAlias)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (pszNamespaceAlias && cchNamespaceAlias)
    {
        hres = CQXMLHelper::GetNamespaceAliasFromNode(_pxdnode, pszNamespaceAlias, cchNamespaceAlias);
        if (hres == S_FALSE)
        {
            *pszNamespaceAlias = NULL;
        }
        
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetQXML(LPCWSTR pszPath, LPCWSTR pszName, CQXML** ppqxml)
{
    ASSERTVALIDSTATE();
    TCHAR szText[12];
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;

    if (ppqxml)
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            ASSERT(pxdnode);

            *ppqxml = new CQXML();

            if (*ppqxml)
            {
                hres = (*ppqxml)->_InitFromNode(_pxddoc, pxdnode);

                if (FAILED(hres))
                {
                    delete *ppqxml;
                    *ppqxml = NULL;
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }
    
    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetText(LPCWSTR pszPath, LPCWSTR pszName, LPWSTR pszText,
    DWORD cchText)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;
    
    if (pszText && cchText)
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = CQXMLHelper::GetTextFromNode(pxdnode, pszText, cchText);

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetInt(LPCWSTR pszPath, LPCWSTR pszName, int* pi)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;

    if (pi)
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = CQXMLHelper::GetIntFromNode(pxdnode, pi);

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }
    
    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetFileTime(LPCWSTR pszPath, LPCWSTR pszName, FILETIME* pft)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;

    if (pft)
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = CQXMLHelper::GetFileTimeFromNode(pxdnode, pft);

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }
    
    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetGUID(LPCWSTR pszPath, LPCWSTR pszName, GUID* pguid)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;

    if (pguid)
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = CQXMLHelper::GetGUIDFromNode(pxdnode, pguid);

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }
    
    ASSERTVALIDSTATE();
    return hres;
}

/*HRESULT CQXML::GetBlob(LPCWSTR pszPath, LPCWSTR pszName, PVOID pvBlob, 
    DWORD cbBlob)
{

}*/

HRESULT CQXML::GetVariant(LPCWSTR pszPath, LPCWSTR pszName, VARTYPE vt,
    VARIANT* pvar)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;

    if (pvar && (VT_EMPTY != vt))
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = CQXMLHelper::GetVariantFromNode(pxdnode, vt, pvar);

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetXMLTreeText(LPWSTR pszText, DWORD cchText)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (pszText && cchText)
    {
        IXMLDOMNode* pxdnode;
        
        if (_fIsRoot)
        {
            pxdnode = _pxddoc;
        }
        else
        {
            pxdnode = _pxdnode;
        }

        hres = CQXMLHelper::GetXMLTreeTextFromNode(pxdnode, pszText, cchText);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetQXMLEnum(LPCWSTR pszPath, LPCWSTR pszName,
                                CQXMLEnum** ppqxmlEnum)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (ppqxmlEnum)
    {
        hres = E_OUTOFMEMORY;

        *ppqxmlEnum = new CQXMLEnum();

        if (*ppqxmlEnum)
        {
            hres = (*ppqxmlEnum)->_Init(_pxdnode, pszPath, pszName);

            if (SUCCEEDED(hres))
            {
                hres = (*ppqxmlEnum)->_InitDoc(_pxddoc);
            }
        }
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::AppendQXML(LPCWSTR pszPath, LPCWSTR pszName, LPCWSTR pszTag,
                          LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,        
                          BOOL fUseExisting, CQXML** ppqxml)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnodeNew;
    HRESULT hres = E_INVALIDARG;

    if (ppqxml && SUCCEEDED(_ValidateParams(pszTag, pszNamespaceName, pszNamespaceAlias)))
    {
        hres = _AppendNode(_pxdnode, pszPath, pszName, pszTag, 
                           pszNamespaceName, pszNamespaceAlias, fUseExisting,
                           &pxdnodeNew);

        if (SUCCEEDED(hres))
        {
            ASSERT(pxdnodeNew);

            *ppqxml = new CQXML;

            if (*ppqxml)
            {
                hres = (*ppqxml)->_InitFromNode(_pxddoc, pxdnodeNew);

                if (FAILED(hres))
                {
                    delete *ppqxml;
                    *ppqxml = NULL;
                }
            }

            pxdnodeNew->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::AppendTextNode(LPCWSTR pszPath, LPCWSTR pszName,
    LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,        
    LPCWSTR pszNodeText, BOOL fUseExisting)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (SUCCEEDED(_ValidateParams(pszNodeTag, pszNamespaceName, pszNamespaceAlias)))
    {
        hres = _AppendText(_pxdnode, pszPath, pszName, pszNodeTag, 
                           pszNamespaceName, pszNamespaceAlias, pszNodeText, fUseExisting);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::AppendIntNode(LPCWSTR pszPath, LPCWSTR pszName,
    LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias, 
    int iNodeInt, BOOL fUseExisting)
{
    ASSERTVALIDSTATE();
    TCHAR szText[50];
    HRESULT hres = E_INVALIDARG;

    if (SUCCEEDED(_ValidateParams(pszNodeTag, pszNamespaceName, pszNamespaceAlias)))
    {
        wsprintfW(szText, L"%d", iNodeInt);

        hres = _AppendText(_pxdnode, pszPath, pszName, 
                           pszNodeTag, pszNamespaceName, pszNamespaceAlias, 
                           szText, fUseExisting);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::AppendInt32NodeEx(LPCWSTR pszPath, LPCWSTR pszName,
    LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
    INT32 iNodeInt, LPWSTR pszFormat, BOOL fUseExisting)
{
    ASSERTVALIDSTATE();

    ASSERT(pszFormat);

    TCHAR szText[50];
    HRESULT hres = E_INVALIDARG;

    if (SUCCEEDED(_ValidateParams(pszNodeTag, pszNamespaceName, pszNamespaceAlias)))
    {
        wsprintfW(szText, pszFormat, iNodeInt);

        hres = _AppendText(_pxdnode, pszPath, pszName, pszNodeTag, 
                           pszNamespaceName, pszNamespaceAlias, 
                           szText, fUseExisting);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::AppendGUIDNode(LPCWSTR pszPath, LPCWSTR pszName,
    LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
    GUID* pguid, BOOL fUseExisting)
{
    ASSERTVALIDSTATE();
    TCHAR szText[50];
    HRESULT hres = E_INVALIDARG;

    if (SUCCEEDED(_ValidateParams(pszNodeTag, pszNamespaceName, pszNamespaceAlias)))
    {
        GUIDToString(pguid, szText);

        hres = _AppendText(_pxdnode, pszPath, pszName, pszNodeTag, 
                           pszNamespaceName, pszNamespaceAlias, 
                           szText, fUseExisting);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::AppendFileTimeNode(LPCWSTR pszPath, LPCWSTR pszName,
    LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
    FILETIME* pft, BOOL fUseExisting)
{
    ASSERTVALIDSTATE();
    TCHAR szText[50];
    HRESULT hres = E_INVALIDARG;

    if (SUCCEEDED(_ValidateParams(pszNodeTag, pszNamespaceName, pszNamespaceAlias)))
    {
        FileTimeToString(pft, szText, ARRAYSIZE(szText));

        hres = _AppendText(_pxdnode, pszPath, pszName, pszNodeTag, 
                           pszNamespaceName, pszNamespaceAlias, 
                           szText, fUseExisting);
    }

    ASSERTVALIDSTATE();
    return hres;
}

CQXML::CQXML() : _pxddoc(NULL), _pxdnode(NULL), _fIsRoot(FALSE)
{
#ifdef DEBUG
    INCDEBUGCOUNTER(d_cInstances);
    d_fInited = 0;
#endif
}

CQXML::~CQXML()
{
    if (_pxddoc)
    {
        _pxddoc->Release();
        DECDEBUGCOUNTER(d_cxddocRef);
    }

    if (_pxdnode)
    {
        _pxdnode->Release();
        DECDEBUGCOUNTER(d_cxdnodeRef);
    }

    DECDEBUGCOUNTER(d_cInstances);
    ASSERT(d_cInstances >= 0);
}

HRESULT CQXML::GetRootTagNameNoBuf(LPWSTR* ppszName)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (ppszName)
    {
        hres = CQXMLHelper::GetTagTextFromNodeNoBuf(_pxdnode, ppszName);
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetRootNamespaceNameNoBuf(LPWSTR* ppszNamespace)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (ppszNamespace)
    {
        hres = CQXMLHelper::GetNamespaceNameFromNodeNoBuf(_pxdnode, ppszNamespace);
        if (hres == S_FALSE)
        {
            *ppszNamespace = NULL;
        }
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetRootNamespaceAliasNoBuf(LPWSTR* ppszNamespaceAlias)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (ppszNamespaceAlias)
    {
        hres = CQXMLHelper::GetNamespaceAliasFromNodeNoBuf(_pxdnode, ppszNamespaceAlias);
        if (hres == S_FALSE)
        {
            *ppszNamespaceAlias = NULL;
        }
    }

    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetTextNoBuf(LPCWSTR pszPath, LPCWSTR pszName, LPWSTR* ppszText)
{
    ASSERTVALIDSTATE();
    IXMLDOMNode* pxdnode;
    HRESULT hres = E_INVALIDARG;

    if (ppszText)
    {
        hres = _GetNode(pszPath, pszName, &pxdnode);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            hres = CQXMLHelper::GetTextFromNodeNoBuf(pxdnode, ppszText);

            pxdnode->Release();
            DECDEBUGCOUNTER(d_cxdnodeRef);
        }
    }
   
    ASSERTVALIDSTATE();
    return hres;
}

HRESULT CQXML::GetXMLTreeTextNoBuf(LPWSTR* ppszText)
{
    ASSERTVALIDSTATE();
    HRESULT hres = E_INVALIDARG;

    if (ppszText)
    {
        IXMLDOMNode* pxdnode;
        
        if (_fIsRoot)
        {
            pxdnode = _pxddoc;
        }
        else
        {
            pxdnode = _pxdnode;
        }

        hres = CQXMLHelper::GetXMLTreeTextFromNodeNoBuf(pxdnode, ppszText);
    }

    ASSERTVALIDSTATE();
    return hres;
}

//static
HRESULT CQXML::ReleaseBuf(LPWSTR psz)
{
    if (psz)
    {
        DECDEBUGCOUNTER(d_cBSTRReturned);
    }

    SysFreeString(psz);

    return S_OK;
}

//static
HRESULT CQXML::FreeVariantMem(VARIANT* pvar)
{
    switch (pvar->vt)
    {
        case VT_BSTR:
        {
            SysFreeString(pvar->bstrVal);
            break;
        }
        default:
        {
            break;
        }
    }

#ifdef DEBUG
    if ((VT_BSTR == pvar->vt) && (pvar->bstrVal))
    {
        DECDEBUGCOUNTER(d_cBSTRReturned);
    }
#endif
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\qxmlenum.cpp ===
#include <objbase.h>
#include "qxml.h"
//#include "dbgassrt.h"
#include <assert.h>

// BUGBUG: deal with this
#define ASSERT(a) (assert(a))
#define INCDEBUGCOUNTER(a)
#define DECDEBUGCOUNTER(a)

// BUGBUG: deal with this
//DEBUG_ONLY(DWORD CQXMLEnum::d_cxdnodelistRef = 0);

CQXMLEnum::CQXMLEnum() : _pxdnodelist(NULL), _pxddoc(NULL), _pxdnode(NULL)
{
    INCDEBUGCOUNTER(CQXML::d_cInstancesEnum);
}

CQXMLEnum::~CQXMLEnum()
{
    if (_bstrPath)
    {
        SysFreeString(_bstrPath);
    }

    if (_pxdnode)
    {
        _pxdnode->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }

    if (_pxdnodelist)
    {
        _pxdnodelist->Release();
        DECDEBUGCOUNTER(d_cxdnodelistRef);
    }

    if (_pxddoc)
    {
        _pxddoc->Release();
        DECDEBUGCOUNTER(CQXML::d_cxddocRef);
    }

    DECDEBUGCOUNTER(CQXML::d_cInstancesEnum);
}

HRESULT CQXMLEnum::_Init(IXMLDOMNode* pxdnode, LPCWSTR pszPath, LPCWSTR pszName)
{
    HRESULT hres = CQXMLHelper::GetConcatenatedBSTR(pszPath, pszName, &_bstrPath);

    if (SUCCEEDED(hres))
    {
        pxdnode->AddRef();
        INCDEBUGCOUNTER(CQXML::d_cxdnodeRef);

        _pxdnode = pxdnode;
    }

    return hres;
}

// Only required when enumerating QXML
HRESULT CQXMLEnum::_InitDoc(IXMLDOMDocument* pxddoc)
{
    pxddoc->AddRef();
    INCDEBUGCOUNTER(CQXML::d_cxddocRef);

    _pxddoc = pxddoc;

    return S_OK;
}

HRESULT CQXMLEnum::GetCount(long* pl)
{
    HRESULT hres = S_OK;

    *pl = 0;

    if (!_pxdnodelist)
    {
        hres = _pxdnode->selectNodes(_bstrPath, &_pxdnodelist);
    }

    if (SUCCEEDED(hres)  && (S_FALSE != hres))
    {
        INCDEBUGCOUNTER(d_cxdnodelistRef);

        hres = _pxdnodelist->get_length(pl);
    }

    return hres;
}

HRESULT CQXMLEnum::NextQXML(CQXML** ppqxml)
{
    ASSERT(_pxddoc);

    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        *ppqxml = new CQXML();

        if (*ppqxml)
        {
            hres = (*ppqxml)->_InitFromNode(_pxddoc, pxdnodeSub);

            if (FAILED(hres))
            {
                delete *ppqxml;
                *ppqxml = NULL;
            }
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}

HRESULT CQXMLEnum::NextText(LPWSTR pszText, DWORD cchText)
{
    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        hres = CQXMLHelper::GetTextFromNode(pxdnodeSub, pszText, cchText);

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}

HRESULT CQXMLEnum::NextInt(int* pi)
{
    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        hres = CQXMLHelper::GetIntFromNode(pxdnodeSub, pi);

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}

HRESULT CQXMLEnum::NextGUID(GUID* pguid)
{
    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        hres = CQXMLHelper::GetGUIDFromNode(pxdnodeSub, pguid);

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}

HRESULT CQXMLEnum::NextFileTime(FILETIME* pft)
{
    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        hres = CQXMLHelper::GetFileTimeFromNode(pxdnodeSub, pft);

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}

HRESULT CQXMLEnum::NextVariant(VARTYPE vt, VARIANT* pvar)
{
    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        hres = CQXMLHelper::GetVariantFromNode(pxdnodeSub, vt, pvar);

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}

HRESULT CQXMLEnum::_NextGeneric(IXMLDOMNode** ppxdnode)
{
    HRESULT hres = S_OK;

    *ppxdnode = NULL;

    if (!_pxdnodelist)
    {
        hres = _pxdnode->selectNodes(_bstrPath, &_pxdnodelist);

        if (SUCCEEDED(hres))
        {
            INCDEBUGCOUNTER(d_cxdnodelistRef);
        }
    }

    if (SUCCEEDED(hres)  && (S_FALSE != hres))
    {
        IXMLDOMNode* pxdnodeSub;

        hres = _pxdnodelist->nextNode(&pxdnodeSub);

        if (SUCCEEDED(hres) && (S_FALSE != hres))
        {
            ASSERT(pxdnodeSub);
            INCDEBUGCOUNTER(CQXML::d_cxdnodeRef);

            *ppxdnode = pxdnodeSub;
        }
    }
    else
    {
        _pxdnodelist = NULL;
    }
    
    return hres;
}

HRESULT CQXMLEnum::NextTextNoBuf(LPWSTR* ppszText)
{
    IXMLDOMNode* pxdnodeSub;

    HRESULT hres = _NextGeneric(&pxdnodeSub);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(pxdnodeSub);

        hres = CQXMLHelper::GetTextFromNodeNoBuf(pxdnodeSub, ppszText);

        pxdnodeSub->Release();
        DECDEBUGCOUNTER(CQXML::d_cxdnodeRef);
    }
        
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\qxmli.cpp ===
#include <objbase.h>
#include "qxml.h"
//#include "dbgassrt.h"
#include <assert.h>

// BUGBUG: deal with this
#define ASSERT(a) (assert(a))
#define INCDEBUGCOUNTER(a)
#define DECDEBUGCOUNTER(a)

HRESULT CQXML::_InitFromNode(IXMLDOMDocument* pxddoc, IXMLDOMNode* pxdnode)
{
    pxddoc->AddRef();
    INCDEBUGCOUNTER(d_cxddocRef);

    pxdnode->AddRef();
    INCDEBUGCOUNTER(d_cxdnodeRef);

    _pxddoc = pxddoc;
    _pxdnode = pxdnode;

#ifdef DEBUG
    d_fInited = TRUE;
#endif

    return S_OK;
}

// Caller needs to release pxdnode
HRESULT CQXML::_GetNode(LPCWSTR pszPath, LPCWSTR pszName,
                             IXMLDOMNode** ppxdnode)
{
    ASSERT(_pxdnode);

    HRESULT hres = E_FAIL;

    if ((pszPath && *pszPath) || (pszName && *pszName))
    {
        BSTR bstrPath;

        hres = CQXMLHelper::GetConcatenatedBSTR(pszPath, pszName, &bstrPath);

        if (SUCCEEDED(hres))
        {
            IXMLDOMNode* pxdnodeSub;

            hres = _pxdnode->selectSingleNode(bstrPath, &pxdnodeSub);

            if (SUCCEEDED(hres) && (S_FALSE != hres))
            {
                ASSERT(pxdnodeSub);
                INCDEBUGCOUNTER(d_cxdnodeRef);

                *ppxdnode = pxdnodeSub;
            }
            else
            {
                ASSERT(!pxdnodeSub);

                *ppxdnode = NULL;
            }

            SysFreeString(bstrPath);
        }
    }
    else
    {
        _pxdnode->AddRef();
        INCDEBUGCOUNTER(d_cxdnodeRef);

        *ppxdnode = _pxdnode;

        hres = S_OK;
    }
   
    return hres;    
}

// Get sub node, creates it if not already there
HRESULT CQXML::_GetSafeSubNode(IXMLDOMNode* pxdnode, LPCWSTR pszNode,
                               LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
                               IXMLDOMNode** ppxdnodeSub, BOOL fUseExisting)
{
    HRESULT hres = S_FALSE;

    if (fUseExisting)
    {
        hres = _GetNode(NULL, pszNode, ppxdnodeSub);
    }

    if (SUCCEEDED(hres) && (S_FALSE == hres))
    {
        hres = CQXMLHelper::CreateAndInsertNode(_pxddoc, pxdnode,
            pszNode, pszNamespaceName, pszNamespaceAlias, NODE_ELEMENT, ppxdnodeSub);
    }

    return hres;
}


// Deals with path part
HRESULT CQXML::_GetNodeRecursePath(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
                                   LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
                                   IXMLDOMNode** ppxdnodeSub, BOOL fUseExisting)
{
    HRESULT hres = E_INVALIDARG;

    // Do we have a path?
    if (pszPath)
    {
        // Yes
        IXMLDOMNode* pxdnodeSubLocal;
        LPWSTR pszNode;

        LPWSTR pszNext = wcschr(pszPath, TEXT('/'));

        // Are there many components?
        if (pszNext)
        {
            // Yes
            pszNode = new WCHAR[pszNext - pszPath + 2];
            lstrcpyn(pszNode, pszPath, pszNext - pszPath + 1);
        }
        else
        {
            // No
            pszNode = (LPWSTR)pszPath;
        }

        hres = _GetSafeSubNode(pxdnode, pszNode, pszNamespaceName, pszNamespaceAlias, 
                               &pxdnodeSubLocal, fUseExisting);

        if (SUCCEEDED(hres))
        {
            ASSERT(pxdnodeSubLocal);

            // Did we have a multi-part path?
            if (pszNext)
            {
                CQXML qxml;

                qxml._InitFromNode(_pxddoc, pxdnodeSubLocal);

                // Yes, let's recurse
                hres = qxml._GetNodeRecursePath(pxdnodeSubLocal, pszNext + 1,
                                pszNamespaceName, pszNamespaceAlias,
                                ppxdnodeSub, fUseExisting);

                pxdnodeSubLocal->Release();
                DECDEBUGCOUNTER(d_cxdnodeRef);
            }
            else
            {
                // No, we're finished
                *ppxdnodeSub = pxdnodeSubLocal;
            }
        }

        if (pszNext && pszNode)
        {
            delete pszNode;
        }
    }

    return hres;
}

HRESULT CQXML::_GetSafeNode(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
    LPCWSTR pszName, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
    IXMLDOMNode** ppxdnodeSub, BOOL fUseExisting)
{
    HRESULT hres = S_OK;
    IXMLDOMNode* pxdnodeDeepest = pxdnode;

    if (!pszPath && !pszName)
    {
        pxdnode->AddRef();
        INCDEBUGCOUNTER(d_cxdnodeRef);

        *ppxdnodeSub = pxdnode;
    }
    else
    {
        // Do we have a path?
        if (pszPath)
        {
            // Yes
            hres = _GetNodeRecursePath(pxdnode, pszPath, pszNamespaceName, pszNamespaceAlias,
                                       &pxdnodeDeepest, fUseExisting);
        }

        if (SUCCEEDED(hres))
        {
            // Do we have a name?
            if (pszName)
            {
                // Yes
                CQXML qxml;

                qxml._InitFromNode(_pxddoc, pxdnodeDeepest);

                hres = qxml._GetSafeSubNode(pxdnodeDeepest, pszName,
                                            pszNamespaceName, pszNamespaceAlias,
                                            ppxdnodeSub, fUseExisting);

                pxdnodeDeepest->Release();
                DECDEBUGCOUNTER(d_cxdnodeRef);
            }
            else
            {
                *ppxdnodeSub = pxdnodeDeepest;
            }
        }
    }

    return hres;
}

HRESULT CQXML::_AppendText(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
                                LPCWSTR pszName, LPCWSTR pszTag, 
                                LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
                                LPCWSTR pszText, BOOL fUseExisting)
{
    IXMLDOMNode* pxdnodeTag;
    HRESULT hres = _AppendNode(pxdnode, pszPath, pszName, 
                               pszTag, pszNamespaceName, pszNamespaceAlias,
                               fUseExisting, &pxdnodeTag);

    if (SUCCEEDED(hres))
    {
        // Then Text, if applicable
        if (pszText)
        {
            BSTR bstr = SysAllocStringLen(NULL, lstrlen(pszText) + 1);

            if (bstr)
            {
                IXMLDOMText* pxdtext;

                lstrcpy(bstr, pszText);

                hres = _pxddoc->createTextNode(bstr, &pxdtext);

                if (SUCCEEDED(hres))
                {
                    IXMLDOMNode* pxdnodeNew;

                    VARIANT var;
                    
                    var.vt = VT_EMPTY;
                    var.intVal = 0;

                    // Add it to the current Node
                    hres = pxdnodeTag->insertBefore(pxdtext, var,
                        &pxdnodeNew);
                    INCDEBUGCOUNTER(d_cxdnodeRef);

                    pxdnodeNew->Release();
                    DECDEBUGCOUNTER(d_cxdnodeRef);
                }

                pxdtext->Release();

                SysFreeString(bstr);
            }
        }

        pxdnodeTag->Release();
        DECDEBUGCOUNTER(d_cxdnodeRef);
    }

    return hres;
}

HRESULT CQXML::_AppendNode(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
                                LPCWSTR pszName, LPCWSTR pszTag, 
                                LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
                                BOOL fUseExisting, IXMLDOMNode** ppxdnodeNew)
{
    IXMLDOMNode* pxdnodeSub;
    HRESULT hres = _GetSafeNode(pxdnode, pszPath, pszName, 
                                pszNamespaceName, pszNamespaceAlias, 
                                &pxdnodeSub, fUseExisting);

    if (SUCCEEDED(hres))
    {
        hres = CQXMLHelper::CreateAndInsertNode(_pxddoc, pxdnodeSub, pszTag, 
                                                pszNamespaceName, pszNamespaceAlias,
                                                NODE_ELEMENT, ppxdnodeNew);
        pxdnodeSub->Release();
        DECDEBUGCOUNTER(d_cxdnodeRef);
    }
    
    return hres;
}

HRESULT CQXML::_SetDocTagName(LPCWSTR pszName, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias)
{
    HRESULT hres = CQXMLHelper::CreateAndInsertNode(_pxddoc, _pxddoc, pszName, 
                                                    pszNamespaceName, pszNamespaceAlias,
                                                    NODE_ELEMENT, &_pxdnode);

    return hres;
}

#ifdef DEBUG
BOOL CQXML::_DbgIsInited()
{
    return d_fInited;
}

// ASSERTVALIDSTATE() will expand to this fct
// This should be called at the entry and exit of all the public fcts.
// The state of the class shall always be valid at these points.  It
// should NOT be called in private fcts, since the class might be in an
// intermediate invalid state but that's normal.

void CQXML::_DbgAssertValidState()
{
    if (d_fInited)
    {
        ASSERT(_pxddoc && _pxdnode);    

//        ASSERT((d_cInstances + d_cInstancesEnum) == d_cxdnodeRef);
//        ASSERT((d_cInstances + d_cInstancesEnum) == d_cxddocRef);
    }
    else
    {
        ASSERT(!_pxddoc && !_pxdnode);
    }
}

// Call this fct when you think that you have released all the LPWSTR
// returned to you thru a GetXYZNoBuf fct.  It also checks that all
// instance of CQXML are destroyed

//static
void CQXML::_DbgAssertNoLeak()
{
    ASSERT(!d_cBSTRReturned);
    ASSERT(!d_cInstances);
    ASSERT(!d_cInstancesEnum);
    ASSERT(!CQXMLEnum::d_cxdnodelistRef);
    ASSERT(!d_cxdnodeRef);
    ASSERT(!d_cxddocRef);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\lib\makefile.inc ===
$(HTTPCOM_ROOT)\lib\$(O)\genxml.lib: $(O)\genxml.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\qxml.h ===
// Quick XML
#ifndef _QXML_H
#define _QXML_H

class CQXMLEnum;
class CQXMLHelper;

class CQXML
{
public:
    CQXML();
    ~CQXML();

    HRESULT InitFromBuffer(LPCWSTR psz);
    HRESULT InitEmptyDoc(LPCWSTR pszDocName, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias);

    HRESULT GetRootTagName(LPWSTR pszName, DWORD cchName);
    HRESULT GetRootNamespaceName(LPWSTR pszNamespaceName, DWORD cchNamespaceName);
    HRESULT GetRootNamespaceAlias(LPWSTR pszNamespaceAlias, DWORD cchNamespaceAlias);

    HRESULT GetQXML(LPCWSTR pszPath, LPCWSTR pszName, CQXML** ppqxml);
    HRESULT GetText(LPCWSTR pszPath, LPCWSTR pszName, LPWSTR pszText,
        DWORD cchText);
    HRESULT GetInt(LPCWSTR pszPath, LPCWSTR pszName, int* pi);
    HRESULT GetFileTime(LPCWSTR pszPath, LPCWSTR pszName, FILETIME* pft);
    HRESULT GetGUID(LPCWSTR pszPath, LPCWSTR pszName, GUID* pguid);
    HRESULT GetVariant(LPCWSTR pszPath, LPCWSTR pszName, VARTYPE vt,
        VARIANT* pvar);
    static HRESULT FreeVariantMem(VARIANT* pvar);

    HRESULT GetXMLTreeText(LPWSTR pszText, DWORD cchText);    

    HRESULT GetQXMLEnum(LPCWSTR pszPath, LPCWSTR pszName, CQXMLEnum** ppqxmlEnum);

    HRESULT AppendQXML(LPCWSTR pszPath, LPCWSTR pszName, LPCWSTR pszTag,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        BOOL fUseExisting, CQXML** ppqxml);
    HRESULT AppendTextNode(LPCWSTR pszPath, LPCWSTR pszName,
        LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        LPCWSTR pszNodeText, BOOL fUseExisting);
    HRESULT AppendIntNode(LPCWSTR pszPath, LPCWSTR pszName, LPCWSTR pszNodeTag,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        int iNodeInt, BOOL fUseExisting);
    HRESULT AppendInt32NodeEx(LPCWSTR pszPath, LPCWSTR pszName, LPCWSTR pszNodeTag,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        int iNodeInt, LPWSTR pszFormat, BOOL fUseExisting);    
    HRESULT AppendGUIDNode(LPCWSTR pszPath, LPCWSTR pszName, LPCWSTR pszNodeTag,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        GUID* pguid, BOOL fUseExisting);
    HRESULT AppendFileTimeNode(LPCWSTR pszPath, LPCWSTR pszName, LPCWSTR pszNodeTag,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        FILETIME* pft, BOOL fUseExisting);

    // No buffer version of the above Get fcts
    HRESULT GetRootTagNameNoBuf(LPWSTR* ppszName);
    HRESULT GetRootNamespaceNameNoBuf(LPWSTR* ppszNamespace);
    HRESULT GetRootNamespaceAliasNoBuf(LPWSTR* ppszNamespaceAlias);
    HRESULT GetTextNoBuf(LPCWSTR pszPath, LPCWSTR pszName, LPWSTR* ppszText);
    HRESULT GetXMLTreeTextNoBuf(LPWSTR* ppszText);    
    static HRESULT ReleaseBuf(LPWSTR psz);

private:
    HRESULT _ValidateParams(LPCWSTR pszNodeTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias);
    HRESULT _InitFromNode(IXMLDOMDocument* pxddoc, IXMLDOMNode* pxdnode);
    HRESULT _GetNode(LPCWSTR pszPath, LPCWSTR pszName,
        IXMLDOMNode** ppxdnode);
    HRESULT _SetDocTagName(LPCWSTR pszName, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias);

    HRESULT _AppendText(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
        LPCWSTR pszName, LPCWSTR pszTag, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        LPCWSTR pszText, BOOL fUseExisting);
    HRESULT _AppendNode(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
        LPCWSTR pszName, LPCWSTR pszTag, 
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        BOOL fUseExisting, IXMLDOMNode** ppxdnodeNew);
    HRESULT _GetSafeSubNode(IXMLDOMNode* pxdnode, LPCWSTR pszNode,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        IXMLDOMNode** ppxdnodeSub, BOOL fUseExisting);
    HRESULT _GetNodeRecursePath(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        IXMLDOMNode** ppxdnodeSub, BOOL fUseExisting);
    HRESULT _GetSafeNode(IXMLDOMNode* pxdnode, LPCWSTR pszPath,
        LPCWSTR pszName, LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias,
        IXMLDOMNode** ppxdnodeSub, BOOL fUseExisting);

    friend class CQXMLEnum;

protected:
    IXMLDOMDocument*    _pxddoc;
    IXMLDOMNode*        _pxdnode;
    BOOL                _fIsRoot;

#ifdef DEBUG
public:
    static void _DbgAssertNoLeak();

    static DWORD        d_cBSTRReturned;
    static DWORD        d_cInstances;
    static DWORD        d_cInstancesEnum;
    BOOL                d_fInited;
    static DWORD        d_cxddocRef;
    static DWORD        d_cxdnodeRef;

private:
    BOOL _DbgIsInited();
    void _DbgAssertValidState();
#endif
};

class CQXMLEnum
{
public:
    ~CQXMLEnum();

    HRESULT NextQXML(CQXML** ppqxml);

    HRESULT NextGUID(GUID* pguid);
    HRESULT NextFileTime(FILETIME* pft);
    HRESULT NextText(LPWSTR pszText, DWORD cchText);
    HRESULT NextInt(int* pi);
    HRESULT NextVariant(VARTYPE vt, VARIANT* pvar);

    HRESULT GetCount(long* pl);

    // No buffer
    HRESULT NextTextNoBuf(LPWSTR* ppszText);

private:
    // Should be called from CQXML only
    CQXMLEnum();
    
    HRESULT _Init(IXMLDOMNode* pxdnode, LPCWSTR pszPath, LPCWSTR pszName);
    HRESULT _InitDoc(IXMLDOMDocument* pxddoc);

    friend class CQXML;

private:
    HRESULT _NextGeneric(IXMLDOMNode** ppxdnode);

private:
    IXMLDOMNodeList*    _pxdnodelist;
    IXMLDOMNode*        _pxdnode;
    IXMLDOMDocument*    _pxddoc;

    BSTR                _bstrPath;

#ifdef DEBUG
public:
    static DWORD        d_cxdnodelistRef;
#endif
};

class CQXMLHelper
{
public:
    static HRESULT GetTextFromNode(IXMLDOMNode* pxdnode, 
        LPWSTR pszText, DWORD cchText);
    static HRESULT GetTagTextFromNode(IXMLDOMNode* pxdnode, 
       LPWSTR pszText, DWORD cchText);
    static HRESULT GetNamespaceNameFromNode(IXMLDOMNode* pxdnode, 
       LPWSTR pszText, DWORD cchText);
    static HRESULT GetNamespaceAliasFromNode(IXMLDOMNode* pxdnode, 
       LPWSTR pszText, DWORD cchText);
    
    static HRESULT GetIntFromNode(IXMLDOMNode* pxdnode, int* pi);
    static HRESULT GetGUIDFromNode(IXMLDOMNode* pxdnode, 
        GUID* pguid);
    static HRESULT GetFileTimeFromNode(IXMLDOMNode* pxdnode, 
        FILETIME* pft);

    static HRESULT GetXMLTreeTextFromNode(IXMLDOMNode* pxdnode, 
        LPWSTR pszText, DWORD cchText);
    static HRESULT GetVariantFromNode(IXMLDOMNode* pxdnode, VARTYPE vt,
        VARIANT* pvar);

    static HRESULT GetConcatenatedBSTR(LPCWSTR pszStr1, LPCWSTR pszStr2,
        BSTR* pbstr);

    static HRESULT CreateAndInsertNode(IXMLDOMDocument* pxddoc,
        IXMLDOMNode* pxdnodeParent, LPCWSTR pszStr, 
        LPCWSTR pszNamespaceName, LPCWSTR pszNamespaceAlias, 
        DOMNodeType nodetype, IXMLDOMNode** ppxdnodeNew);

    // No buffer
    static HRESULT GetTextFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText);
    static HRESULT GetTagTextFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText);
    static HRESULT GetNamespaceNameFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText);
    static HRESULT GetNamespaceAliasFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText);
    static HRESULT GetXMLTreeTextFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText);
};

#endif //_QXML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\tstdrv\td_genxml.cpp ===
// hello.cpp : Defines the entry point for the console application.
//
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#include "qxml.h"

#include "dbgassrt.h"
#include "xmlhlpr.h"

#ifndef UNICODE
#error This has to be UNICODE
#endif

int DoTest();

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return DoTest();
}
}

///////////////////////////////////////////////////////////////////////////////
// These should be the same except for spaces and \n \r
WCHAR szCompareXML1A[] = L"     \
<D>                           \
    <B1>T</B1>     \
</D>                          \
";

WCHAR szCompareXML2A[] = L"<D><B1>T</B1></D>";

///////////////////////////////////////////////////////////////////////////////
// These should be the same different <D> -> <Z>
WCHAR szCompareXML1B[] = L"     \
<D>                           \
    <B1>T</B1>     \
</D>                          \
";

WCHAR szCompareXML2B[] = L"<Z><B1>T</B1></Z>";

WCHAR szTheDoc[] = L" \
<?xml version=\"1.0\"?> \
<DOC> \
    <BRANCH1> \
        <TAG1> \
            <TAG>Value1_2</TAG> \
            <TAG>Value1_3</TAG> \
            <NUMBER>7654</NUMBER> \
        </TAG1> \
    </BRANCH1> \
    <BRANCH2> \
        <TAG1> \
            <TAG2>Value1_2</TAG2> \
            <TAG3>Value1_3</TAG3> \
            <TAG4> \
                <TAG4_1>Value1_4_4-1</TAG4_1> \
            </TAG4> \
        </TAG1> \
    </BRANCH2> \
    <BRANCH3> \
        <TAG5> \
            <CLSID>{12345678-abcd-9876-1234-abcdef123456}</CLSID> \
        </TAG5> \
        <TAG6> \
            <FILETIME>12/31/1999 11:59:59.999</FILETIME> \
        </TAG6> \
        <TAG7> \
            <HEX>0xABCDEF12</HEX> \
        </TAG7> \
    </BRANCH3> \
</DOC>";       

int DoTest()
{
#ifdef RBDEBUG
    CRBDebug::Init();
#endif

    HRESULT hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    TRACE(L"This is a test");

    int y = 12;

    ASSERT(y == 13);

	if (ERROR_SUCCESS == hres)
    {
        {
            // Test the compare fct first

            // These should be the same
            ASSERT(BasicCompareXML(szCompareXML1A, szCompareXML2A));

            // These should be different
            ASSERT(!BasicCompareXML(szCompareXML1B, szCompareXML2B));

            BOOL f = WriteXMLToFile(szTheDoc, L"E:\\xml.txt", TRUE);

            if (f)
            {
                LPWSTR pszReadXML;

                f = ReadXMLFromFile(L"E:\\xml.txt", &pszReadXML);

                if (f)
                {
                    if (BasicCompareXML(pszReadXML, szTheDoc))
                    {
                        BOOL fSame;

                        f = BasicCompareXMLToFile(szTheDoc, L"E:\\xml.txt", &fSame);

                        ASSERT(fSame);
                    }

                    free(pszReadXML);
                }
            }
        }
        {
            CQXML qxml;

            hres = qxml.InitFromBuffer(szTheDoc);

            if (SUCCEEDED(hres))
            {
                WCHAR szName[20];

                {
                    hres = qxml.GetRootTagName(szName, 20);

                    if (SUCCEEDED(hres))
                    {
                        LPWSTR pszName;

                        hres = qxml.GetRootTagNameNoBuf(&pszName);

                        if (SUCCEEDED(hres))
                        {
                            if (lstrcmp(pszName, szName))
                            {
                                wprintf(L"Problem");
                            }

                            CQXML::ReleaseBuf(pszName);
                        }
                    }
                }
                {
                    hres = qxml.GetText(L"BRANCH1/TAG1", L"TAG", szName, 20);

                    if (SUCCEEDED(hres))
                    {
                        LPWSTR pszName;

                        hres = qxml.GetTextNoBuf(L"BRANCH1/TAG1", L"TAG", &pszName);

                        if (SUCCEEDED(hres))
                        {
                            if (lstrcmp(pszName, szName))
                            {
                                wprintf(L"Problem");
                            }
                            
                            CQXML::ReleaseBuf(pszName);

                            VARIANT var;

                            hres = qxml.GetVariant(L"BRANCH1/TAG1", L"TAG", VT_BSTR,
                                &var);

                            if (SUCCEEDED(hres))
                            {
                                if (lstrcmp(var.bstrVal, szName))
                                {
                                    wprintf(L"Problem");
                                }

                                CQXML::FreeVariantMem(&var);
                            }
                        }
                    }
                }
                {
                    int i = 0;

                    hres = qxml.GetInt(L"BRANCH1/TAG1", L"NUMBER", &i);

                    if (SUCCEEDED(hres))
                    {
                        VARIANT var;

                        hres = qxml.GetVariant(L"BRANCH1/TAG1", L"NUMBER", VT_I4,
                            &var);

                        if (SUCCEEDED(hres))
                        {
                            if (var.lVal != i)
                            {
                                wprintf(L"Problem");
                            }

                            CQXML::FreeVariantMem(&var);
                        }
                    }
                }
                {
    //            hres = qxml.GetNamedString(L"DOC/TAG1/*", L"DUMMY", szName, 20);
                    CQXMLEnum* pqxmlEnum;

                    hres = qxml.GetQXMLEnum(L"BRANCH1/TAG1", L"TAG", &pqxmlEnum);

                    if (SUCCEEDED(hres))
                    {
                        WCHAR szText[20];

                        while (SUCCEEDED(hres = pqxmlEnum->NextText(szText, 20)) && 
                            (S_FALSE != hres))
                        {

                        }

                        delete pqxmlEnum;
                    }

                    hres = qxml.GetQXMLEnum(L"BRANCH1/TAG1", L"TAG", &pqxmlEnum);

                    if (SUCCEEDED(hres))
                    {
                        VARIANT var;

                        while (SUCCEEDED(hres = pqxmlEnum->NextVariant(VT_BSTR, &var)) && 
                            (S_FALSE != hres))
                        {
                            CQXML::FreeVariantMem(&var);
                        }

                        delete pqxmlEnum;
                    }
                }
                {
                    WCHAR szText[1024];

                    hres = qxml.GetXMLTreeText(szText, 1024);

                    ASSERT(BasicCompareXML(szText, szTheDoc));

                    if (SUCCEEDED(hres))
                    {
                        LPWSTR pszText;

                        hres = qxml.GetRootTagNameNoBuf(&pszText);

                        if (SUCCEEDED(hres))
                        {
                            if (lstrcmp(pszText, szText))
                            {
                                wprintf(L"Problem");
                            }

                            CQXML::ReleaseBuf(pszText);
                        }
                    }
                }
                {
                    GUID guid;

                    hres = qxml.GetGUID(L"BRANCH3/TAG5", L"CLSID", &guid);

                    if (FAILED(hres))
                    {
                        wprintf(L"Problem");
                    }
                }
                {
                    FILETIME ft;

                    hres = qxml.GetFileTime(L"BRANCH3/TAG6", L"FILETIME", &ft);

                    SYSTEMTIME st;

                    FileTimeToSystemTime(&ft, &st);

                    if (FAILED(hres))
                    {
                        wprintf(L"Problem");
                    }
                }
                {
                    int iHex;

                    hres = qxml.GetInt(L"BRANCH3/TAG7", L"HEX", &iHex);

                    if (FAILED(hres))
                    {
                        wprintf(L"Problem");
                    }
                }
            }
        }

#ifdef DEBUG
        CQXML::_DbgAssertNoLeak();
#endif

        {
            CQXML qxml;

            hres = qxml.InitEmptyDoc(L"NewTree", NULL, NULL);

            if (SUCCEEDED(hres))
            {
                hres = qxml.AppendTextNode(L"Level1/Level2", L"Level3", L"TAG",
                    NULL, NULL, L"Value", TRUE);

                if (SUCCEEDED(hres))
                {
                    hres = qxml.AppendTextNode(L"Level1/Level2", L"Level3", 
                        L"TAG2", NULL, NULL, L"(existing) Value 2", TRUE);
                }

                if (SUCCEEDED(hres))
                {
                    hres = qxml.AppendTextNode(L"Level1/Level2", L"Level3", 
                        L"TAG2", NULL, NULL, L"(new) Value 2", FALSE);
                }

                if (SUCCEEDED(hres))
                {
                    hres = qxml.AppendIntNode(L"Level1/Level2", L"Level3", 
                        L"Number", NULL, NULL, 1234, TRUE);
                }

                if (SUCCEEDED(hres))
                {
                    GUID guid;
                
                    guid.Data1 = 0x12345678;
                    guid.Data2 = 0xabcd;
                    guid.Data3 = 0xef12;
                    guid.Data4[0] = 0x98;
                    guid.Data4[1] = 0x76;
                    guid.Data4[2] = 0x54;
                    guid.Data4[3] = 0x32;
                    guid.Data4[4] = 0x10;
                    guid.Data4[5] = 0xfe;
                    guid.Data4[6] = 0xdc;
                    guid.Data4[7] = 0xba;

                    hres = qxml.AppendGUIDNode(L"Level1/Level2", L"Level3", 
                        L"GUID", NULL, NULL, &guid, TRUE);
                }

                if (SUCCEEDED(hres))
                {
                    SYSTEMTIME st;
                    FILETIME ft;

                    st.wMonth = 12;
                    st.wDay = 31;
                    st.wYear = 1999;
                    st.wHour = 11;
                    st.wMinute = 59;
                    st.wSecond = 59;
                    st.wMilliseconds = 999;

                    SystemTimeToFileTime(&st, &ft);

                    hres = qxml.AppendFileTimeNode(L"Level1/Level2", L"Level3",
                        L"FILETIME", NULL, NULL, &ft, TRUE);
                }

                if (SUCCEEDED(hres))
                {
                    CQXML* pqxmlNew;

                    hres = qxml.AppendQXML(L"Level1/Level2", L"Level3",
                        L"NewQXML", NULL, NULL, TRUE, &pqxmlNew);

                    if (SUCCEEDED(hres))
                    {
                        ASSERT(pqxmlNew);

                        pqxmlNew->AppendTextNode(L"Level4/Level5", L"Level6",
                            L"TAG3", NULL, NULL, L"Value 12", FALSE);

                        delete pqxmlNew;
                    }
                }

                if (SUCCEEDED(hres))
                {
                    WCHAR szText[2048];
                    
                    hres = qxml.GetXMLTreeText(szText, 2048);

                    if (SUCCEEDED(hres))
                    {
                        LPWSTR pszText;

                        hres = qxml.GetXMLTreeTextNoBuf(&pszText);

                        ASSERT(BasicCompareXML(szText, pszText));

                        if (SUCCEEDED(hres))
                        {
                            wprintf(pszText);

                            CQXML::ReleaseBuf(pszText);
                        }
                    }
                }
            }
        }
#ifdef DEBUG
        CQXML::_DbgAssertNoLeak();
#endif

	    CoUninitialize();
    }

#ifdef RBDEBUG
    CRBDebug::Cleanup();
#endif

    return !SUCCEEDED(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\dbgassrt.h ===
#ifdef DEBUG

#pragma warning(disable: 4127)

#define ASSERTVALIDSTATE() _DbgAssertValidState()

#define INCDEBUGCOUNTER(a) ++(a)
#define DECDEBUGCOUNTER(a) --(a)

#define DEBUG_ONLY(a) a

#ifdef RBDEBUG

#include "rbdebug.h"

#define ASSERT(a) do { if ((a)) { ; } else { \
    if (RBD_ASSERT_BEEP & CRBDebug::_dwFlags) { Beep(1000, 500); } else { ; } \
    if (RBD_ASSERT_TRACE & CRBDebug::_dwFlags) { TRACE(ASSERT: #a); } else { ; } \
    if (RBD_ASSERT_STOP &  CRBDebug::_dwFlags) { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;}} else { ; } \
}} while (0)

#define TRACE(a) do { CRBDebug::TraceMsg(__FILE__, __LINE__, #a); } while (0);

#else

#define ASSERT(a) do { if ((a)) { ; } else { Beep(1000, 500); \
    _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } } while (0)

#define TRACE(a) do { OutputDebugString((a)); OutputDebugString(L"\n"); } while (0);

#endif

#else

#define ASSERT(a)
#define ASSERTVALIDSTATE() 
#define TRACE(a)
#define INCDEBUGCOUNTER(a)
#define DECDEBUGCOUNTER(a)
#define DEBUG_ONLY(a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\generlst.h ===
#ifndef __DAVINET_GENERLST_H
#define __DAVINET_GENERLST_H

#include <objbase.h>

// internal structure, clients should not use this
typedef struct __GenericListStruct
{
    LPVOID pv;
    UINT cb;
    LPWSTR pwszTag;
    struct __GenericListStruct* pNext;
} GenericList;

class CGenericList
{
public: 
    CGenericList();
    ~CGenericList();
    
    // add an element to the list
    // element is a tag, a pointer to data, and the size of that data
    //
    // note that on add, only the pointer is stored, the data is NOT copied
    // the tag IS copied, though
    HRESULT Add(LPWSTR pwszTag,
                LPVOID pv, // pointer to some data
                UINT   cb);  // size of the data being pointed to
    
    // find the element with the tag that matches pwszTag
    //
    // if not found, returns S_FALSE
    HRESULT Find(LPWSTR  pwszTag,
                 LPVOID* ppv,// pointer to data is returned through here (NOT A COPY)
                 UINT*   pcb);// size of the data is returned through here

    // return the data of the uiDexth element
    HRESULT FindByDex (UINT uiDex,
                       LPVOID* ppv, // pointer to data is returned through here (NOT A COPY)
                       UINT*   pcb); // size of the data is returned through here

    // delete an item from the list
    // does NOT delete the data, just the pointer to it
    //
    // if not found, returns S_FALSE
    HRESULT Delete(LPWSTR pwszTag);

    // delete an item AND its data from the list
    //
    // if not found, returns S_FALSE
    HRESULT Purge(LPWSTR pwszTag);

    // delete all items AND their data from the list
    //
    // if not found, returns S_FALSE
    HRESULT PurgeAll();

    // get size of the list
    HRESULT Size (UINT* puiSize);

    // get the tag associated with the uiDexth element
    // gets a pointer to the tag, NOT a copy
    HRESULT GetTagByDex (UINT uiDex,
                         LPWSTR* ppwszTag);
private:
    // internal methods
    HRESULT _GenericListDestroy(GenericList* plist,
                                BOOL fPurgeData);

    HRESULT _GenericListAdd (GenericList** pplistHead,
                             GenericList** pplistTail,
                             LPWSTR pwszTag,
                             LPVOID pv,
                             UINT cb);
    
    HRESULT _GenericListFind(GenericList* plist,
                             LPWSTR      pwszTag, 
                             LPVOID*     ppv,
                             UINT*       pcb);
    
    HRESULT _GenericListDelete(GenericList** pplistHead,
                               GenericList** pplistTail,
                               LPWSTR        pwszTag, 
                               LPVOID*       ppv,
                               UINT*         pcb);
    
    HRESULT _GenericListGetElByDex (UINT          iDex,
                                    GenericList** pptr);

    HRESULT _GenericListGetDataByDex (UINT         iDex,
                                      LPVOID*      ppv,
                                      UINT*        pcb);
    
    HRESULT _GenericListGetTagByDex (UINT         iDex,
                                     LPWSTR*      ppwszTag);
private:
    GenericList*    _pHead;
    GenericList*    _pTail;
    UINT            _cElements;
    
    UINT            _uiReadAheadDex; // when we read, we cache the pointer to the next element
    GenericList*    _pReadAheadEl;   // only valid if _pReadAheadEl is non-NULL
};

#endif // __DAVINET_GENERLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\genxml\qxmlhlpr.cpp ===
#include <objbase.h>
#include "qxml.h"
//#include "dbgassrt.h"
#include <assert.h>
#include "strconv.h"
#define ASSERT(a) (assert(a))
#define INCDEBUGCOUNTER(a)

//static
HRESULT CQXMLHelper::GetTextFromNode(IXMLDOMNode* pxdnode, 
                                           LPWSTR pszText, DWORD cchText)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_text(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        lstrcpyn(pszText, bstr, cchText);

        SysFreeString(bstr);
    }
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetTextFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_text(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        *ppszText = bstr;
    }

#ifdef DEBUG
    if (*ppszText)
    {
        INCDEBUGCOUNTER(CQXML::d_cBSTRReturned);
    }
#endif
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetGUIDFromNode(IXMLDOMNode* pxdnode, 
    GUID* pguid)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_text(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        StringToGUID(bstr, pguid);

        SysFreeString(bstr);
    }
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetFileTimeFromNode(IXMLDOMNode* pxdnode, 
    FILETIME* pft)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_text(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        hres = (StringToFileTime(bstr, pft) ? S_OK : E_FAIL);

        SysFreeString(bstr);
    }
   
    return hres;
}


//static
HRESULT CQXMLHelper::GetTagTextFromNode(IXMLDOMNode* pxdnode, 
                                        LPWSTR pszText, DWORD cchText)
{
    // We assume that the node passed in is a NODE_ELEMENT
    ASSERT(pxdnode);
    
    BSTR bstr;
    LPWSTR pszPtr;

    HRESULT hres = pxdnode->get_nodeName(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        pszPtr = wcschr(bstr,':');
        if (!pszPtr)
        {
            lstrcpyn(pszText, bstr, cchText); // if no colon, bstr is the text
        }
        else
        {
            lstrcpyn(pszText, pszPtr + 1, cchText);
        }


        SysFreeString(bstr);
    }
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetTagTextFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText)
{
    // We assume that the node passed in is a NODE_ELEMENT
    ASSERT(pxdnode);
    LPWSTR pszPtr;    
    BSTR bstr;

    HRESULT hres = pxdnode->get_nodeName(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        pszPtr = wcschr(bstr,':');
        if (!pszPtr)
        {
            *ppszText = bstr; // if no colon, bstr is the text
        }
        else
        {
            *ppszText = SysAllocStringLen(NULL, lstrlen(pszPtr + 1) + 1);
            lstrcpy(*ppszText, pszPtr + 1);
            SysFreeString(bstr);
        }
        
    }
   
#ifdef DEBUG
    if (*ppszText)
    {
        INCDEBUGCOUNTER(CQXML::d_cBSTRReturned);
    }
#endif

    return hres;
}

//static 
HRESULT CQXMLHelper::GetNamespaceNameFromNode(IXMLDOMNode* pxdnode, 
                                              LPWSTR pszText, DWORD cchText)
{
    // We assume that the node passed in is a NODE_ELEMENT
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_namespaceURI(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        lstrcpyn(pszText, bstr, cchText);

        SysFreeString(bstr);
    }
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetNamespaceNameFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText)
{
    // We assume that the node passed in is a NODE_ELEMENT
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_namespaceURI(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        *ppszText = bstr;
    }
   
#ifdef DEBUG
    if (*ppszText)
    {
        INCDEBUGCOUNTER(CQXML::d_cBSTRReturned);
    }
#endif

    return hres;
}

//static 
HRESULT CQXMLHelper::GetNamespaceAliasFromNode(IXMLDOMNode* pxdnode, 
                                               LPWSTR pszText, DWORD cchText)
{
    // We assume that the node passed in is a NODE_ELEMENT
    ASSERT(pxdnode);
    
    BSTR bstr;
    LPWSTR pszPtr;
    
    HRESULT hres = pxdnode->get_nodeName(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        pszPtr = wcschr(bstr,':');
        if (!pszPtr)
        {
            pszText[0] = NULL; // if no colon, alias is non
        }
        else
        {
            *pszPtr = NULL;
            lstrcpyn(pszText, bstr, cchText);
            *pszPtr = ':'; // replace the colon
        }

        SysFreeString(bstr);
    }
   
    return hres;
}

// static
HRESULT CQXMLHelper::GetNamespaceAliasFromNodeNoBuf(IXMLDOMNode* pxdnode, 
                                                    LPWSTR* ppszText)
{
    // We assume that the node passed in is a NODE_ELEMENT
    ASSERT(pxdnode);
    
    BSTR bstr;
    LPWSTR pszPtr;
    
    HRESULT hres = pxdnode->get_nodeName(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        pszPtr = wcschr(bstr,':');
        if (!pszPtr)
        {
            *ppszText = NULL; // if no colon, alias is non
        }
        else
        {
            *pszPtr = NULL;
            *ppszText = SysAllocStringLen(NULL, lstrlen(bstr) + 1);
            lstrcpy(*ppszText, bstr);            
        }

        SysFreeString(bstr);
    }
   
#ifdef DEBUG
    if (*ppszText)
    {
        INCDEBUGCOUNTER(CQXML::d_cBSTRReturned);
    }
#endif

    return hres;
}


//static
HRESULT CQXMLHelper::GetIntFromNode(IXMLDOMNode* pxdnode, int* pi)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    *pi = 0;

    HRESULT hres = pxdnode->get_text(&bstr);

    if (SUCCEEDED(hres)  && (S_FALSE != hres))
    {
        ASSERT(bstr);

        if ((L'0' == *bstr) && (L'x' == *(bstr + 1)))
        {
            LPWSTR psz = bstr + 2;

            while (*psz && ((psz - (bstr + 2)) <= 8))
            {
                int i = 0;

                if (*psz >= L'0' && *psz <= L'9')
                {
                    i = *psz - L'0';
                }
                else
                {
                    if (*psz >= L'a' && *psz <= L'f')
                    {
                        i = *psz - L'a' + 10;                    
                    }
                    else
                    {
                        if (*psz >= L'A' && *psz <= L'F')
                        {
                            i = *psz - L'A' + 10;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                (*pi) *= 16;

                (*pi) += i;

                ++psz;
            }
        }
        else
        {
            *pi = _wtoi(bstr);
        }

        SysFreeString(bstr);
    }
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetVariantFromNode(IXMLDOMNode* pxdnode, VARTYPE vt,
        VARIANT* pvar)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_text(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        pvar->vt = vt;

        switch (vt)
        {
            case VT_I4:
            {
                pvar->lVal = _wtoi(bstr);
                break;
            }
            case VT_BSTR:
            {
                pvar->bstrVal = bstr;
                break;
            }
            default:
            {
                pvar->vt = VT_EMPTY;
                hres = E_NOTIMPL;
                ASSERT(FALSE);
                break;
            }
        }

        switch (vt)
        {
            case VT_BSTR:
            {
                break;
            }
            default:
            {
                // free the BSTR for all
                SysFreeString(bstr);
                break;
            }
        }
    }
   
#ifdef DEBUG
    if ((VT_BSTR == pvar->vt) && (pvar->bstrVal))
    {
        INCDEBUGCOUNTER(CQXML::d_cBSTRReturned);
    }
#endif

    return hres;    
}

//static
HRESULT CQXMLHelper::GetConcatenatedBSTR(LPCWSTR pszStr1, LPCWSTR pszStr2, BSTR* pbstr)
{
    HRESULT hres = E_OUTOFMEMORY;
    int cchStr1 = 0;
    int cchStr2 = 0;

    if (pszStr1)
    {
        cchStr1 = lstrlen(pszStr1);
    }

    if (pszStr2)
    {
        cchStr2 = lstrlen(pszStr2);
    }    

    if (pszStr1 && pszStr2)
    {
        // we need a '/' between them
        ++cchStr1;
    }

    // + 1 for NULL terminator
    *pbstr = SysAllocStringLen(NULL, cchStr1 + cchStr2 + 1);

    if (*pbstr)
    {
        if (pszStr1)
        {
            lstrcpy(*pbstr, pszStr1);

            if (pszStr2)
            {
                lstrcat(*pbstr, TEXT("/"));
            }
        }
        else
        {
            **pbstr = 0;
        }

        if (pszStr2)
        {
            lstrcat(*pbstr, pszStr2);
        }

        hres = S_OK;
    }

    return hres;
}

//static
HRESULT CQXMLHelper::CreateAndInsertNode(IXMLDOMDocument* pxddoc,
    IXMLDOMNode* pxdnodeParent, LPCWSTR pszStr, LPCWSTR pszNamespaceName,
    LPCWSTR pszNamespaceAlias, DOMNodeType nodetype, IXMLDOMNode** ppxdnodeNew)
{
    ASSERT((pszNamespaceName && pszNamespaceAlias) || (!pszNamespaceName && !pszNamespaceAlias));

    HRESULT hres = E_OUTOFMEMORY;
    IXMLDOMNode* pxdnodeNewLocal;

    BSTR bstr = NULL;
    BSTR bstrNamespace = NULL;

    if (pszNamespaceName) 
    {
        UINT cchStr = lstrlen(pszStr);
        UINT cchNamespaceName = lstrlen(pszNamespaceName);
        UINT cchNamespaceAlias = lstrlen(pszNamespaceAlias);

        bstr = SysAllocStringLen(NULL, cchStr + cchNamespaceAlias  + 2);

        if (bstr)
        {
            lstrcpy(bstr, pszNamespaceAlias);
            lstrcpy(bstr + cchNamespaceAlias, L":");
            lstrcpy(bstr + cchNamespaceAlias + 1, pszStr);
        
            bstrNamespace = SysAllocStringLen(NULL, cchNamespaceName + 2);
            
            if (bstrNamespace)
            {
                lstrcpy(bstrNamespace, pszNamespaceName);    
                lstrcpy(bstrNamespace + cchNamespaceName, L":");
                hres = S_OK;
            }
        }        
    }
    else
    {
        bstr = SysAllocStringLen(NULL, lstrlen(pszStr) + 1);
        if (bstr)
        {
            lstrcpy(bstr, pszStr);
            hres = S_OK;
        }                    
    }

    if (SUCCEEDED(hres))
    {
        VARIANT var;
        var.vt = VT_INT;
        var.intVal = nodetype;
    
        hres = pxddoc->createNode(var, bstr, bstrNamespace, &pxdnodeNewLocal);

        if (SUCCEEDED(hres))
        {
            ASSERT(pxdnodeNewLocal);
        
            VARIANT var;
            var.vt = VT_EMPTY;
            var.intVal = 0;
        
            // Add it to the current Node
            hres = pxdnodeParent->insertBefore(pxdnodeNewLocal, var,
                ppxdnodeNew);
        
            if (SUCCEEDED(hres))
            {
                // for *pxdnodeNew which goes out
                INCDEBUGCOUNTER(CQXML::d_cxdnodeRef);
            }
        
            pxdnodeNewLocal->Release();
        }

    }

    if (bstr != NULL)
    {
        SysFreeString(bstr);
    }
    
    if (bstrNamespace != NULL)
    {
        SysFreeString(bstrNamespace);
    }

    return hres;
}

//static
HRESULT CQXMLHelper::GetXMLTreeTextFromNode(IXMLDOMNode* pxdnode, 
        LPWSTR pszText, DWORD cchText)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_xml(&bstr);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        lstrcpyn(pszText, bstr, cchText);

        SysFreeString(bstr);
    }
   
    return hres;
}

//static
HRESULT CQXMLHelper::GetXMLTreeTextFromNodeNoBuf(IXMLDOMNode* pxdnode, 
        LPWSTR* ppszText)
{
    ASSERT(pxdnode);
    
    BSTR bstr;

    HRESULT hres = pxdnode->get_xml(&bstr);

    
    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(bstr);

        *ppszText = bstr;
    }
   
#ifdef DEBUG
    if (*ppszText)
    {
        INCDEBUGCOUNTER(CQXML::d_cBSTRReturned);
    }
#endif

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\growvm.h ===
#ifndef _GROWVM_H
#define _GROWVM_H

class CGrowVirtMem
{
public:
    CGrowVirtMem();
    ~CGrowVirtMem();

    HRESULT Init(DWORD cbApproxMaxSize, DWORD cbGrowRate);
    HRESULT Grow();
    HRESULT GetBufferAddress(PBYTE* ppb);
    HRESULT GetBufferSize(DWORD* pcb);

private:
    // Helpers
    DWORD _RoundOffToPageSize(DWORD c);
    HRESULT _GrowHelper();

private:
    DWORD _dwPageSize;
    DWORD _cbGrowRate;
    DWORD _cbMaxSize;
    DWORD _cbApproxMaxSize;
    PBYTE _pbCurrent;
    PBYTE _pbBase;
};

#endif // _GROWVM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\httperr.h ===
// WindowsDB uses   300-399
// HTTPDB uses      400-500

// ERRORS
#define HSRV_ERROR(a) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, (a))

#define HSRV_E_FAIL                      HSRV_ERROR(400)
#define HSRV_E_NOVERB                    HSRV_ERROR(401)
#define HSRV_E_NOUSERNAME                HSRV_ERROR(402)
#define HSRV_E_NOOBJID                   HSRV_ERROR(403)
#define HSRV_E_NOXMLBODY                 HSRV_ERROR(404)
#define HSRV_E_UNKNOWNVERB               HSRV_ERROR(405)
#define HSRV_E_ILLFORMEDXML              HSRV_ERROR(406)
#define HSRV_E_INVALIDTRANSACTIONID      HSRV_ERROR(407)
#define HSRV_E_INVALIDTRANSACTIONSTATE   HSRV_ERROR(408)
#define HSRV_E_INVALIDSTORAGEFOLDER      HSRV_ERROR(409)
#define HSRV_E_XMLTOSTRUCTFAIL           HSRV_ERROR(410)
#define HSRV_E_INCOMPLETEXML             HSRV_ERROR(411)
#define HSRV_E_INVALIDBINDINGINFO        HSRV_ERROR(412)
#define HSRV_E_ACCESSORCREATIONFAIL      HSRV_ERROR(413)
#define HSRV_E_XMLGENERATIONFAIL         HSRV_ERROR(414)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\mischlpr.h ===
#define UNREF_PARAM(a)

#ifdef DEBUG

#define UNREF_RETAIL_PARAM(a) a
#define UNREF_FORNOW_PARAM(a) UNREF_PARAM(a)

#else

#define UNREF_RETAIL_PARAM(a) UNREF_PARAM(a)
//#define UNREF_FORNOW_PARAM(a) a // we want to not compile
#define UNREF_FORNOW_PARAM(a) UNREF_PARAM(a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\refcnt.h ===
#ifndef _REFCNT_H_
#define _REFCNT_H_

class CRefCount
{
public:
    CRefCount() : _cRCRef(1) {}

    ULONG AddRef()  { return ::InterlockedIncrement((LONG*)&_cRCRef); }
    ULONG Release()
    {
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRCRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

private:
    ULONG _cRCRef; // RC: to avoid name colision
};

#endif // _REFCNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\intfcach.h ===
#ifndef _INTFCACH_H
#define _INTFCACH_H

class CLinkList;
class CPair;
class CThreadCache;

#define INTFCACH_E_DUPLICATE MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, 500)

class CInterfaceCache
{
public:
    CInterfaceCache();
    ~CInterfaceCache();

public:
    virtual HRESULT Init();

    HRESULT GetCachedValue(LPCWSTR pszKey, REFIID riid, PVOID* ppv);
    HRESULT GetAndRemoveCachedValue(LPCWSTR pszKey, REFIID riid, PVOID* ppv);
    HRESULT SetCachedValue(LPCWSTR pszKey, IUnknown* punk, DWORD dwExpiration);

    HRESULT RemoveCachedPair(LPCWSTR pszKey);

protected:
    void _EnterCritical();
    void _LeaveCritical();

private:
    HRESULT _FindPair(LPCWSTR pszKey, CPair** pppair);
    HRESULT _GetCachedValueHelper(LPCWSTR pszKey, REFIID riid, PVOID* ppv);
    HRESULT _RemoveCachedPairHelperByKey(LPCWSTR pszKey);
    HRESULT _RemoveCachedPairHelper(CPair* ppair);

private:
    CLinkList*          _pllPairs;

    CThreadCache*       _pthread;
    HANDLE              _hEventWakeUp;

    CRITICAL_SECTION    _cs;

    friend CThreadCache;
};

#endif // _INTFCACH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\regexp.h ===
#ifndef __REGEXP_H
#define __REGEXP_H

#include <objbase.h> // how do I get BOOL

// this method finds first block of text contained between two other blocks of text in a buffer.
//
// ex. FindEnclosedText(L"A and B and C", L"A and ", L" and C", &pwszFound, &cchFound);
//
// returns TRUE if execution was normal, FALSE if an unexpected error occurred
// if block not found, returns NULL in *ppwszFound
//
// note that returns a pointer within the original string, not a copy
//
BOOL FindEnclosedText(LPCWSTR pwszBuffer,  // buffer to search
                      LPCWSTR pwszPre,     // text before text to return
                      LPCWSTR pwszPost,    // text after text to return
                      LPWSTR* ppwszFound,  // text found
                      DWORD*  pcchFound);  // length of text string found

#endif // __REGEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\llbase.h ===
#ifndef _LLBASE_H
#define _LLBASE_H

#include "dbgassrt.h"

class CLinkListElemBase
{
protected:
    CLinkListElemBase() : _pNext(NULL), _pPrev(NULL) { }
    virtual ~CLinkListElemBase() {}

public:
    CLinkListElemBase* GetNext() const
    {
        return _pNext;
    }
    CLinkListElemBase* GetPrev() const
    {
        return _pPrev;
    }

    void SetNext(CLinkListElemBase* pElem)
    {
        _pNext = pElem;
    }
    void SetPrev(CLinkListElemBase* pElem)
    {
        _pPrev = pElem;
    }

private:
    CLinkListElemBase* _pPrev;
    CLinkListElemBase* _pNext;
};

class CLinkList
{
public:
    CLinkList() : _pHead(NULL), _pTail(NULL) {}
    virtual ~CLinkList() {}

public:
    HRESULT AppendTail(CLinkListElemBase* pElem)
    {
        if (_pTail)
        {
            ASSERT(!_pTail->GetNext());

            _pTail->SetNext(pElem);
            pElem->SetNext(NULL);
            pElem->SetPrev(_pTail);

            _pTail = pElem;
        }
        else
        {
            ASSERT(!_pHead);

            _pTail = _pHead = pElem;

            pElem->SetNext(NULL);
            pElem->SetPrev(NULL);
        }

        return S_OK;
    }

    HRESULT RemoveElem(CLinkListElemBase* pElem)
    {
        CLinkListElemBase* pOldPrev = pElem->GetPrev();
        CLinkListElemBase* pOldNext = pElem->GetNext();

        if (pOldPrev)
        {
            pOldPrev->SetNext(pOldNext);
        }

        if (pOldNext)
        {
            pOldNext->SetPrev(pOldPrev);
        }

        if (_pHead == pElem)
        {
            _pHead = pOldNext;
        }

        if (_pTail == pElem)
        {
            _pTail = pOldPrev;
        }

        return S_OK;
    }

    HRESULT GetHead(CLinkListElemBase** ppElem) const
    {
        *ppElem = _pHead;

        return _pHead ? S_OK : S_FALSE;
    }

    HRESULT GetNext(CLinkListElemBase* pElem,
        CLinkListElemBase** ppElemOut) const
    {
        HRESULT hres = E_INVALIDARG;

        if (pElem)
        {
            *ppElemOut = pElem->GetNext();

            if (*ppElemOut)
            {
                hres = S_OK;
            }
            else
            {
                hres = S_FALSE;
            }
        }

        return hres;
    }

private:
    CLinkListElemBase*      _pHead;
    CLinkListElemBase*      _pTail;
};

#endif // _LLBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\regsuprt.h ===
#ifndef __REGSUPRT_H
#define __REGSUPRT_H

#include <objbase.h>

#define REG_OPTION_INVALID  0xFFFFFFFF

#ifndef UNICODE
#error This has to be UNICODE
#endif

#ifndef _UNICODE
#error This has to be UNICODE
#endif

// MAX_ROOT is the maximum we support for the root
#define MAX_ROOT            MAX_PATH

class CRSSubKeyEnum
{
public:
    HRESULT Next(LPTSTR pszKey, DWORD cchKey, class CRegSupport** pprs);

public:
    // Should be called from CRegSupport only
    HRESULT _Init(HKEY hkey, LPTSTR pszSubKey);
    CRSSubKeyEnum();
    ~CRSSubKeyEnum();

private:
    HKEY    _hkey;
    DWORD   _dwIndex;

    HKEY    _hkeyInit;
    TCHAR   _szSubKeyInit[MAX_PATH];

#ifdef DEBUG
    BOOL                    _fInited;
#endif
};

class CRSValueEnum
{
public:
    HRESULT Next(LPTSTR pszValue, DWORD cchValue);

public:
    // Should be called from CRegSupport only
    HRESULT _Init(HKEY hkey, LPTSTR pszSubKey);
    CRSValueEnum();
    ~CRSValueEnum();

private:
    HKEY    _hkey;
    DWORD   _dwIndex;

    HKEY    _hkeyInit;
    TCHAR   _szSubKeyInit[MAX_PATH];

#ifdef DEBUG
    BOOL                    _fInited;
#endif
};

class CRegSupport
{
public:
    CRegSupport();
    virtual ~CRegSupport();

public:
    HRESULT RSInitRoot(HKEY hkey, LPCTSTR pszSubKey1, LPCTSTR pszSubKey2,
        BOOL fAllocMemForKey1, BOOL fAllocMemForKey2);
    HRESULT RSInitOption(DWORD dwRootOptions, DWORD dwDefaultOptions);

    HRESULT RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    HRESULT RSSubKeyExist(LPCTSTR pszSubKey);

    HRESULT RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    HRESULT RSDeleteSubKey(LPCTSTR pszSubKey);
    HRESULT RSDeleteKey();

    HKEY RSDuplicateRootKey();

    HRESULT RSEnumSubKeys(LPCTSTR pszSubKey, CRSSubKeyEnum** ppenum);
    HRESULT RSEnumValues(LPCTSTR pszSubKey, CRSValueEnum** ppenum);

    HRESULT RSGetValueSize(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        DWORD* pcbSize);

    HRESULT RSGetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        LPTSTR pszValue, DWORD* pcchValue);
    HRESULT RSGetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        PBYTE pb, DWORD* pcb);
    HRESULT RSGetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        DWORD* pdwValue);

    HRESULT RSSetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        LPCTSTR pszValue, DWORD dwOptions = REG_OPTION_INVALID);
    HRESULT RSSetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        PBYTE pb, DWORD cb, DWORD dwOptions = REG_OPTION_INVALID);
    HRESULT RSSetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        DWORD dwValue, DWORD dwOptions = REG_OPTION_INVALID);

protected:
    HRESULT RSGetHiveKey(HKEY* phkey);
    HRESULT RSGetSubKey(LPTSTR pszKey, DWORD cchKey);

protected:
    void _CloseRegSubKey(HKEY hkeyVolumeSubKey);

    HKEY _GetRootKey(BOOL fCreate, DWORD dwOptions = REG_OPTION_INVALID);

    HRESULT _SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        PBYTE pb, DWORD cb, DWORD dwType, DWORD dwOptions);
    HRESULT _GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
        PBYTE pb, DWORD* pcb);

    HRESULT _SubKeyExist(LPCTSTR pszSubKey);
    HKEY _GetSubKey(LPCTSTR pszSubKey, BOOL fCreate,
        DWORD dwOptions = REG_OPTION_INVALID);

    static HKEY _RegCreateKeyExHelper(HKEY hkey, LPCTSTR pszSubKey,
        DWORD dwOptions);
    static HKEY _RegOpenKeyExHelper(HKEY hkey, LPCTSTR pszSubKey);

protected:
    HRESULT _InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2);
    void _InitCSKeyRoot();
    void _EnterCSKeyRoot();
    void _LeaveCSKeyRoot();

    LPCTSTR _GetRoot(LPTSTR pszRoot, DWORD cchRoot);

protected:
    LPCTSTR                 _pszSubKey1;
    LPCTSTR                 _pszSubKey2;

private:
    DWORD                   _dwRootOptions;
    DWORD                   _dwDefaultOptions;

    HKEY                    _hkeyInit; // HKEY_CURRENT_USER, ...
    
    CRITICAL_SECTION        _csKeyRoot;
    BOOL                    _fcsKeyRoot;
    
    BOOL                    _fAllocMemForKey1;
    BOOL                    _fAllocMemForKey2;

#ifdef DEBUG
    static UINT             _cRefHKEY;
    static UINT             _cRefExternalHKEY;

    BOOL                    _fInited;
#endif
};

#endif //__REGSUPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\timeconv.h ===
#ifndef _TIMECONV_H
#define _TIMECONV_H

HRESULT ConvertTime(LPWSTR pwszFormat, LPWSTR pwszTime, FILETIME* pftime);

#endif // _TIMECONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\strutil.h ===
#ifndef _STRUTIL_H
#define _STRUTIL_H

LPSTR  AllocateStringA(DWORD cch);
LPWSTR AllocateStringW(DWORD cch);

LPSTR  DuplicateStringA(LPCSTR psz);
LPWSTR DuplicateStringW(LPCWSTR psz);

LPWSTR ConvertToUnicode(UINT cp, LPCSTR pcszSource);
LPSTR  ConvertToANSI(UINT cp, LPCWSTR pcwszSource);

INT LStrCmpN(LPWSTR pwszLeft, LPWSTR pwszRight, UINT n);
INT LStrCmpNI(LPWSTR pwszLeft, LPWSTR pwszRight, UINT n);

LPWSTR LStrStr(LPWSTR pwszString, LPWSTR pwszSought);
LPWSTR LStrStrI(LPWSTR pwszString, LPWSTR pwszSought);

#endif // _STRUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\sxwdb.h ===
extern "C" STRUCTXMLMEMBER sxmrgCOLUMNBINDING[];
extern "C" STRUCTXMLMAP sxmapCOLUMNBINDING;

extern "C" STRUCTXMLMEMBER sxmrgDATABASECOLUMN[];
extern "C" STRUCTXMLMAP sxmapDATABASECOLUMN;

extern "C" STRUCTXMLMEMBER sxmrgDATABASESCHEMA[];
extern "C" STRUCTXMLMAP sxmapDATABASESCHEMA;

extern "C" STRUCTXMLMEMBER sxmrgGETSCHEMAINFO[];
extern "C" STRUCTXMLMAP sxmapGETSCHEMAINFO;

extern "C" STRUCTXMLMEMBER sxmrgDATABASETABLE[];
extern "C" STRUCTXMLMAP sxmapDATABASETABLE;

extern "C" STRUCTXMLMEMBER sxmrgDATABASEKEY[];
extern "C" STRUCTXMLMAP sxmapDATABASEKEY;

extern "C" STRUCTXMLMEMBER sxmrgDATABASEINDEX[];
extern "C" STRUCTXMLMAP sxmapDATABASEINDEX;

extern "C" STRUCTXMLMEMBER sxmrgGETINDEXINFO[];
extern "C" STRUCTXMLMAP sxmapGETINDEXINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\strconv.h ===
#ifndef _STRCONV_H
#define _STRCONV_H

 // + 1 is NULL terminator
#define MAX_GUIDSTR (38 + 1)
// GUID
BOOL GUIDToString(const GUID *pguid, LPWSTR psz);
BOOL StringToGUID(LPCWSTR psz, GUID *pguid);

// FILETIME
BOOL FileTimeToString(const FILETIME* pft, LPWSTR psz, DWORD cch);
BOOL StringToFileTime(LPCWSTR psz, FILETIME* pft);


#endif // _STRCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\generlst.cpp ===
#include <assert.h>
#include "generlst.h"
#include "strutil.h"

///////////////////////////////////////////////////////////////////////////////////////////

HRESULT CGenericList::_GenericListDestroy(GenericList* plist,
                                          BOOL fPurgeData)
{
    // locals
    GenericList* ptr;
    GenericList* ptr2;
    HRESULT hres;
    
    if (plist == NULL)
    {
        hres = S_OK;
    }
    else
    {
        ptr = plist;
        ptr2 = plist->pNext;
        while (ptr!=NULL)
        {
            if (fPurgeData)
            {
                free(ptr->pv);
            }
            free(ptr);
            ptr = ptr2;
            if (ptr != NULL)
            {
                ptr2 = ptr->pNext;
            }            

        }
        hres = S_OK;
    }
    return hres;
}

///////////////////////////////////

HRESULT CGenericList::_GenericListAdd (GenericList** pplistHead,
                                       GenericList** pplistTail,
                                       LPWSTR        pwszTag,
                                       LPVOID        pv,
                                       UINT          cb)
{
    // locals
    HRESULT      hres = S_OK;
    GenericList* newEl = NULL;
    GenericList* ptr = NULL;

    // check params
    if (pplistHead == NULL || pplistTail == NULL || pv == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        // code
        newEl = (GenericList*)malloc(sizeof(GenericList));
        if (newEl == NULL)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {    
            newEl->pNext=NULL;
            newEl->pwszTag=DuplicateStringW(pwszTag);    
            if (newEl->pwszTag == NULL)
            {
                hres = E_OUTOFMEMORY;
                free(newEl);
            }
            else
            {
                newEl->pv = pv;
                if (pv!=NULL)
                {
                    newEl->cb = cb;
                }
                else
                {
                    newEl->cb = 0;
                }
        
                // finally, newEl is ready, we can insert it
                if (*pplistHead==NULL)
                {
                    assert(*pplistHead==NULL);
                    *pplistHead=newEl; // head insertion
                    *pplistTail=newEl;
                }
                else
                {
                    assert(((*pplistTail)->pNext) == NULL); 
                    (*pplistTail)->pNext = newEl; // tail insertion
					(*pplistTail) = newEl; // update tail
                }
            }
        }
    }

    return hres;  
}

///////////////////////////////////

// Note: Returns a ptr to the found data, NOT A COPY
HRESULT CGenericList::_GenericListFind(GenericList* plist,
                                       LPWSTR       pwszTag, 
                                       LPVOID*      ppv,
                                       UINT*        pcb)
{
    // locals
    GenericList* ptr;
    BOOL fFound = FALSE;
    HRESULT hres = S_OK;

    // check params
    if (plist == NULL || pcb == NULL || ppv == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        // code
        ptr=plist;
    
        while (ptr != NULL && !fFound)
        {
            if (lstrcmp(ptr->pwszTag, pwszTag)==0)
            {
                *ppv=ptr->pv;
                *pcb=ptr->cb;
                fFound = TRUE;
            } 
            else        
            {
                ptr=ptr->pNext;
            }
        }
    
        if (fFound)
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
            *ppv = NULL;    
        }
    }
    
    return hres;
}

///////////////////////////////////

// note: this DOES NOT FREE THE DATA.  a pointer to the data is returned so that
//       the client will remember to free it herself.

// *data will be NULL if not found
HRESULT CGenericList::_GenericListDelete(GenericList** pplistHead,
                                         GenericList** pplistTail,
                                         LPWSTR        pwszTag, 
                                         LPVOID*       ppv,
                                         UINT*         pcb)
{
    // locals
    GenericList* ptr;
    GenericList* ptr2;
    BOOL fFound = FALSE;
    HRESULT hres;
    
    // check params    
    if (pcb == NULL || ppv == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        // code
        // -- head deletion
        if (lstrcmp((*pplistHead)->pwszTag, pwszTag)==0)
        {
            *ppv=(*pplistHead)->pv;
            *pcb=(*pplistHead)->cb;
            ptr=*pplistHead;
            *pplistHead=(*pplistHead)->pNext;
            free(ptr); // frees the GenericList structure, NOT the data
            fFound = TRUE;        
        }
        else
        {
            // -- body deletion
            ptr=*pplistHead;
            while (ptr->pNext!=NULL && !fFound)
            {           
                if (!fFound && lstrcmp(ptr->pNext->pwszTag, pwszTag)==0) 
                {
                    *ppv=ptr->pv;
                    ptr2=ptr->pNext;
                    ptr->pNext=ptr2->pNext;
                    free(ptr2);  // frees the GenericList structure, NOT the data
                    fFound = TRUE;
                    if (ptr->pNext == NULL)
                    {
                        *pplistTail = ptr;
                    }
                }
                else
                {
                    ptr=ptr->pNext;
                }
            }
        }    

        if (fFound)
        {
            hres = S_OK;
        }
        else
        {
            hres = S_FALSE;
        }
    }

    return hres;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


HRESULT CGenericList::_GenericListGetElByDex (UINT          iDex,
                                              GenericList** pptr)
{
    assert(pHead);
    assert(pptr);
    assert(puiReadAheadDex);
    assert(ppReadAheadEl);

    HRESULT hr;

    *pptr = _pHead;
    
    if (iDex == _uiReadAheadDex && _pReadAheadEl)
    {
        *pptr = _pReadAheadEl;
    }
    else
    {
        // if we go off the end, just let ptr stay at NULL
        for (UINT i = 0; i < iDex; i++)
        {
            if ((*pptr)!=NULL)
            {
                *pptr = (*pptr)->pNext;
            }
        }
    }

    // if we went off the end, failff
    if (*pptr)
    {
        _uiReadAheadDex = iDex + 1;
        _pReadAheadEl = (*pptr)->pNext;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////////

HRESULT CGenericList::_GenericListGetDataByDex (UINT         iDex,
                                                LPVOID*      ppv,
                                                UINT*        pcb)
{
    // locals
    GenericList* ptr;
    HRESULT hres = S_OK;

    // check params
    if (pcb == NULL || ppv == NULL || (iDex >= _cElements))
        hres = E_INVALIDARG;
    else
    {
        // code
        hres = this->_GenericListGetElByDex (iDex, &ptr);

        if (SUCCEEDED(hres))
        {
            *pcb = ptr->cb;
            *ppv = ptr->pv;
        }
        else
        {
            *pcb = 0;
            *ppv = NULL;
        }
    }

    return hres;
}

///////////////////////////////////


HRESULT CGenericList::_GenericListGetTagByDex (UINT          iDex,
                                               LPWSTR*       ppwszTag)
{
    // locals
    GenericList* ptr;
    HRESULT hres = S_OK;

    // check params
    if (ppwszTag == NULL || (iDex >= _cElements))
        hres = E_INVALIDARG;
    else
    {
        // code
        hres = this->_GenericListGetElByDex (iDex, &ptr);

        if (SUCCEEDED(hres))
        {
            *ppwszTag = ptr->pwszTag;
        }
        else
        {
            *ppwszTag = NULL;
        }
    }
    return hres;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

CGenericList::CGenericList() : _pHead(NULL), _pTail(NULL), _cElements(0), _pReadAheadEl(NULL)
{
}

CGenericList::~CGenericList()
{
    this->_GenericListDestroy(_pHead, FALSE); // don't delete the data itself
}

HRESULT CGenericList::Add(LPWSTR pwszTag,
                          LPVOID pv,
                          UINT   cb)
{
    HRESULT hr;    

    hr = this->_GenericListAdd(&_pHead, &_pTail, pwszTag, pv, cb);
    if (SUCCEEDED(hr))
    {
        _cElements++;
    }
    return hr;
}
    
HRESULT CGenericList::Find(LPWSTR  pwszTag,
                           LPVOID* ppv,
                           UINT*   pcb)
{
    return this->_GenericListFind(_pHead, pwszTag, ppv, pcb);
}



// does NOT delete the data, just the pointer to it
HRESULT CGenericList::Delete(LPWSTR pwszTag)
{
    HRESULT hr;    
    LPVOID pv;
    UINT cb;

    hr = this->_GenericListDelete(&_pHead, &_pTail, pwszTag, &pv, &cb);
    if (SUCCEEDED(hr))
    {
        _cElements--;
    }
    return hr;
}

// deletes the element AND the data
HRESULT CGenericList::Purge(LPWSTR pwszTag)
{
    HRESULT hr;    
    LPVOID pv;
    UINT cb;

    hr = this->_GenericListDelete(&_pHead, &_pTail, pwszTag, &pv, &cb);
    if (SUCCEEDED(hr))
    {
        free(pv); // delete the data
        _cElements--;
    }
    return hr;
}

// deletes all elements AND their data
HRESULT CGenericList::PurgeAll()
{
    HRESULT hres;
    
    hres = this->_GenericListDestroy(_pHead, TRUE); // delete all the data too

    if (SUCCEEDED(hres))
    {
        _pHead = NULL;
    }

    return hres;
}

HRESULT CGenericList::Size (UINT* puiSize)
{
    *puiSize = _cElements;
    return S_OK;
}

    
HRESULT CGenericList::FindByDex (UINT    uiDex,
                                 LPVOID* ppv,
                                 UINT*   pcb)
{
    return this->_GenericListGetDataByDex(uiDex, ppv, pcb);
}

HRESULT CGenericList::GetTagByDex (UINT uiDex,
                                   LPWSTR* ppwszTag)
{
    return this->_GenericListGetTagByDex(uiDex, ppwszTag);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\inc\xmlhlpr.h ===
#define CANSKIP(a) ((L'\t' == (a)) || (L' ' == (a)) || (L'\n' == (a)) || (L'\r' == (a)))

BOOL BasicCompareXML(LPCWSTR pszXML1, LPCWSTR pszXML2)
{
    BOOL fSame = TRUE;

    while (fSame && (*pszXML1 || *pszXML2))
    {
        while (CANSKIP(*pszXML1))
        {
            ++pszXML1;
        }

        while (CANSKIP(*pszXML2))
        {
            ++pszXML2;            
        }

        if (*pszXML1 != *pszXML2)
        {
            fSame = FALSE;
        }
        else
        {
            if (*pszXML1)
            {
                ++pszXML1;
            }

            if (*pszXML2)
            {
                ++pszXML2;
            }
        }
    }

    return fSame;
}

BOOL WriteXMLToFile(LPCWSTR pszXML, LPCWSTR pszFile, BOOL fOverWrite)
{
    BOOL fSuccess = FALSE;
    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ, 
        NULL, fOverWrite ? CREATE_ALWAYS : CREATE_NEW, FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        DWORD cbWritten;

        fSuccess = WriteFile(hFile, pszXML, lstrlen(pszXML) * sizeof(WCHAR), &cbWritten, NULL);
            
        CloseHandle(hFile);
    }

    return fSuccess;
}

BOOL ReadXMLFromFile(LPCWSTR pszFile, LPWSTR* ppszXML)
{
    BOOL fSuccess = FALSE;
    HANDLE hFile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ, 
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        DWORD cbRead;

        // NULL?  We do not support files in excess of 4 GB, what a shame...
        DWORD cbSize = GetFileSize(hFile, NULL);

        if (0xFFFFFFFF != cbSize)
        {
            *ppszXML = (LPWSTR)malloc(cbSize + sizeof(WCHAR));

            if (*ppszXML)
            {
                if (cbSize >= 2)
                {
                    fSuccess = ReadFile(hFile, *ppszXML, 2, &cbRead, NULL);
                    if (**ppszXML == 0xFEFF)
                    {
                        fSuccess = ReadFile(hFile, *ppszXML, cbSize-2, &cbRead, NULL);
                    }
                    else
                    {
                        fSuccess = ReadFile(hFile, (*ppszXML)+2, cbSize-2, &cbRead, NULL);
                        cbRead+=2;
                    }
                    // NULL terminate the thing
                    *((WCHAR*)(((PBYTE)(*ppszXML)) + cbRead)) = 0;
                }
            }
        }
            
        CloseHandle(hFile);
    }

    return fSuccess;
}

BOOL BasicCompareXMLToFile(LPWSTR pszXML, LPWSTR pszFile, BOOL* pfSame)
{
    BOOL fSuccess = FALSE;
    LPWSTR pszFileXML = NULL;

    if (ReadXMLFromFile(pszFile, &pszFileXML))
    {
        *pfSame = BasicCompareXML(pszXML, pszFileXML);
 
        fSuccess = TRUE;
        
        free(pszFileXML);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\regexp.cpp ===
#include "regexp.h"

BOOL FindEnclosedText(LPCWSTR pwszBuffer,  // buffer to search
                      LPCWSTR pwszPre,     // text before text to return
                      LPCWSTR pwszPost,    // text after text to return
                      LPWSTR* ppwszFound,  // text found
                      DWORD*  pcchFound)  // length of text string found
{
    LPWSTR pwszPrePtr;
    LPWSTR pwszPostPtr;

    pwszPrePtr = wcsstr(pwszBuffer, pwszPre);
    if (pwszPrePtr == NULL)
    {
        *ppwszFound = NULL;
        *pcchFound = 0;
    }
    else
    {
        pwszPostPtr = wcsstr(pwszPrePtr + lstrlen(pwszPre), pwszPost);
        if (pwszPostPtr == NULL)
        {
            *ppwszFound = NULL;
            *pcchFound = 0;
        }
        else
        {
            *ppwszFound = pwszPrePtr + lstrlen(pwszPre);
            *pcchFound = pwszPostPtr - (pwszPrePtr + lstrlen(pwszPre));
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\intfcach.cpp ===
#include <objbase.h>
#include "intfcach.h"

#include "llbase.h"
#include "thrdobj.h"

#include "dbgassrt.h"

class CPair : public CLinkListElemBase
{
public:
    LPWSTR      _pszKey;
    DWORD       _dwTimeLeft;

private:
    IUnknown*   _punk;

#ifdef DEBUG
public:
    // calculate the refs that we put on the object
    DWORD _cRef;
#endif

public:
    CPair() : _punk(NULL), _pszKey(NULL)
    {
        DEBUG_ONLY(_cRef = 0);
    }
    ~CPair()
    {
        if (_punk)
        {
            // Release the ref that we hold so that the thing would remain
            // in the cache
            _punk->Release();
            DECDEBUGCOUNTER(_cRef);
        }
        if (_pszKey)
        {
            free(_pszKey);
        }

        ASSERT(0 == _cRef);
    }

    HRESULT SetKey(LPCWSTR pszKey)
    {
        HRESULT hres = S_OK;
        int cch = lstrlen(pszKey);

        _pszKey = (LPWSTR)malloc((cch + 1) * sizeof(WCHAR));

        if (_pszKey)
        {
            lstrcpy(_pszKey, pszKey);
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }

        return hres;
    }

    HRESULT SetInterface(IUnknown* punk)
    {
        // We AddRef it to keep it in the cache until we remove it
        punk->AddRef();
        INCDEBUGCOUNTER(_cRef);

        _punk = punk;

        return S_OK;
    }

    // should addref on the interface we return but can't!
    HRESULT GetInterface(IUnknown** ppunk)
    {
        // Since we give back a ptr to this interface we addref, clients must
        // release 
        _punk->AddRef();
        INCDEBUGCOUNTER(_cRef);

        *ppunk = _punk;

        return S_OK;
    }
};

class CThreadCache : public CThreadObj
{
public:
    HRESULT Init(CInterfaceCache* pic, HANDLE hEventWakeUp)
    {
        _pic = pic;
        _hEventWakeUp = hEventWakeUp;
        _fContinue = TRUE;
        _dwMinDelta = INFINITE;

        return CThreadObj::Init(FALSE);
    }

    HRESULT RequestStop()
    {
        _fContinue = FALSE;

        return SetEvent(_hEventWakeUp) ? S_OK : E_FAIL;
    }

    HRESULT NotifyNewExpiration(DWORD dwExpiration)
    {
        HRESULT hres = S_OK;

        if (dwExpiration < _dwMinDelta)
        {
            hres = SetEvent(_hEventWakeUp) ? S_OK : E_FAIL;
        }

        return hres;
    }

protected:
    DWORD _Work();

private:
    HRESULT _SetLastUpdateTime()
    {
        SYSTEMTIME st;
        GetSystemTime(&st);

        SystemTimeToFileTime(&st, &_ftLastUpdate);

        return S_OK;
    }

    HRESULT _CalcToRemove(DWORD dwWakeUpReason, DWORD* pdwToRemove);

    HRESULT _ProcessCachedEntries(DWORD dwToRemove);
    HRESULT _PlayGod(CPair* ppair, DWORD dwToRemove);

private:
    DWORD               _dwMinDelta;
    FILETIME            _ftLastUpdate;

    HANDLE              _hEventWakeUp;
    BOOL                _fContinue;

    CInterfaceCache*    _pic;
};

HRESULT CInterfaceCache::RemoveCachedPair(LPCWSTR pszKey)
{
    HRESULT hres;

    _EnterCritical();

    hres = _RemoveCachedPairHelperByKey(pszKey);

    _LeaveCritical();

    return hres;
}

HRESULT CInterfaceCache::GetCachedValue(LPCWSTR pszKey, REFIID riid, PVOID* ppv)
{
    HRESULT hres;

    _EnterCritical();

    hres = _GetCachedValueHelper(pszKey, riid, ppv);

    _LeaveCritical();

    return hres;
}

HRESULT CInterfaceCache::GetAndRemoveCachedValue(LPCWSTR pszKey, REFIID riid,
    PVOID* ppv)
{
    HRESULT hres;

    _EnterCritical();

    hres = _GetCachedValueHelper(pszKey, riid, ppv);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        hres = _RemoveCachedPairHelperByKey(pszKey);
    }

    _LeaveCritical();

    return hres;
}

HRESULT CInterfaceCache::SetCachedValue(LPCWSTR pszKey, IUnknown* punk,
    DWORD dwExpiration)
{
    ASSERT(pszKey && *pszKey);
    ASSERT(_pllPairs);

    CPair* ppair;

    _EnterCritical();
    HRESULT hres = _FindPair(pszKey, &ppair);

    if (SUCCEEDED(hres))
    {
        if (S_FALSE == hres)
        {
            ASSERT(!ppair);

            ppair = new CPair();

            if (ppair)
            {
                ppair->_dwTimeLeft = dwExpiration;

                hres = ppair->SetKey(pszKey);

                if (SUCCEEDED(hres))
                {
                    hres = ppair->SetInterface(punk);
                }
                
                if (SUCCEEDED(hres))
                {
                    hres = _pllPairs->AppendTail(ppair);
                }

                if (FAILED(hres))
                {
                    delete ppair;
                    ppair = NULL;
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
        else
        {
            ASSERT(ppair);
            hres = INTFCACH_E_DUPLICATE;
        }
    }

    _pthread->NotifyNewExpiration(dwExpiration);

    _LeaveCritical();

    return hres;
}

HRESULT CInterfaceCache::Init()
{
    HRESULT hres = E_OUTOFMEMORY;

    _pllPairs = new CLinkList();

    if (_pllPairs)
    {
        _pthread = new CThreadCache();

        if (_pthread)
        {
            _hEventWakeUp = CreateEvent(NULL, TRUE, FALSE, NULL);

            if (_hEventWakeUp)
            {
                hres = _pthread->Init(this, _hEventWakeUp);

                _pthread->Resume();
            }
        }
    }

    return hres;
}

HRESULT CInterfaceCache::_FindPair(LPCWSTR pszKey, CPair** pppair)
{
    HRESULT hres = S_FALSE;
    CPair* ppairLocal;

    *pppair = NULL;

    hres = _pllPairs->GetHead((CLinkListElemBase**)&ppairLocal);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        do
        {
            ASSERT(ppairLocal);

            if (!lstrcmp(ppairLocal->_pszKey, pszKey))
            {
                *pppair = ppairLocal;
                hres = S_OK;
                break;
            }
            else
            {
                hres = _pllPairs->GetNext(ppairLocal, 
                    (CLinkListElemBase**)&ppairLocal);
            }
        }
        while (SUCCEEDED(hres) && (S_FALSE != hres));
    }

    return hres;
}

HRESULT CInterfaceCache::_GetCachedValueHelper(LPCWSTR pszKey, REFIID riid, PVOID* ppv)
{
    ASSERT(pszKey && *pszKey);
    ASSERT(_pllPairs);

    CPair* ppair;

    *ppv = NULL;

    HRESULT hres = _FindPair(pszKey, &ppair);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        ASSERT(ppair);

        IUnknown* punk;

        hres = ppair->GetInterface(&punk);

        if (SUCCEEDED(hres))
        {
            if (IID_IUnknown != riid)
            {
                hres = punk->QueryInterface(riid, ppv);

                if (SUCCEEDED(hres))
                {
                    ASSERT(*ppv);
                }
            }
            else
            {
                *ppv = (PVOID)punk;

                // Since there's no QI, we need to increment the ref
                punk->AddRef();
            }

            // CPair::GetInterface AddRef's the interface, release it
            punk->Release();
            DECDEBUGCOUNTER(ppair->_cRef);
        }
    }

    return hres;
}

HRESULT CInterfaceCache::_RemoveCachedPairHelperByKey(LPCWSTR pszKey)
{
    CPair* ppair;

    HRESULT hres = _FindPair(pszKey, &ppair);

    if (SUCCEEDED(hres))
    {
        if (S_FALSE != hres)
        {
            ASSERT(ppair);

            hres = _RemoveCachedPairHelper(ppair);
        }
        else
        {
            ASSERT(!ppair);

            hres = E_INVALIDARG;
        }
    }

    return hres;
}

HRESULT CInterfaceCache::_RemoveCachedPairHelper(CPair* ppair)
{
    ASSERT(ppair);
    HRESULT hres = _pllPairs->RemoveElem(ppair);

    if (SUCCEEDED(hres))
    {
        delete ppair;
    }

    return hres;
}

CInterfaceCache::CInterfaceCache() : _pllPairs(NULL)
{
    InitializeCriticalSection(&_cs);
}

CInterfaceCache::~CInterfaceCache()
{
    DeleteCriticalSection(&_cs);

    if (_pllPairs)
    {
        delete _pllPairs;
    }

    if (_pthread)
    {
        delete _pthread;
    }
}

void CInterfaceCache::_EnterCritical()
{
    EnterCriticalSection(&_cs);
}

void CInterfaceCache::_LeaveCritical()
{
    LeaveCriticalSection(&_cs);
}

///////////////////////////////////////////////////////////////////////////////
// CThreadCache
///////////////////////////////////////////////////////////////////////////////
DWORD CThreadCache::_Work()
{
    DWORD dwWakeUpReason = WAIT_TIMEOUT;

    do
    {
        _pic->_EnterCritical();

        {
            DWORD dwToRemove;

            _CalcToRemove(dwWakeUpReason, &dwToRemove);

            HRESULT hres = _ProcessCachedEntries(dwToRemove);
        }

        _pic->_LeaveCritical();

        _SetLastUpdateTime();

        ResetEvent(_hEventWakeUp);

        dwWakeUpReason = WaitForSingleObject(_hEventWakeUp, _dwMinDelta);
    }
    while (_fContinue);

    return 0;
}

HRESULT CThreadCache::_ProcessCachedEntries(DWORD dwToRemove)
{
    CPair* ppair;
    HRESULT hres = _pic->_pllPairs->GetHead((CLinkListElemBase**)&ppair);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        do
        {
            ASSERT(ppair);
            CPair* ppairTmp;

            HRESULT hresKill = hres = _PlayGod(ppair, dwToRemove);

            ppairTmp = ppair;

            if (SUCCEEDED(hres))
            {
                hres = _pic->_pllPairs->GetNext(ppair,
                    (CLinkListElemBase**)&ppair);

                if (S_FALSE != hresKill)
                {
                    // Kill it
                    IUnknown* punk;

                    hresKill = ppairTmp->GetInterface(&punk);

                    if (SUCCEEDED(hres))
                    {
                        ASSERT(punk);
                        punk->Release();
                        DECDEBUGCOUNTER(ppairTmp->_cRef);

                        TRACE(L"Kill:");
                        TRACE(ppairTmp->_pszKey);

                        hresKill = _pic->_pllPairs->RemoveElem(ppairTmp);
                        
                        if (SUCCEEDED(hres))
                        {
                            delete ppairTmp;
                        }
                    }
                }
            }
        }
        while (_fContinue && SUCCEEDED(hres) && (S_FALSE != hres));
    }

    return hres;
}

HRESULT CThreadCache::_CalcToRemove(DWORD dwWakeUpReason, DWORD* pdwToRemove)
{
    if (WAIT_TIMEOUT != dwWakeUpReason)
    {
        // The event was set, so we wake up early
        SYSTEMTIME st;
        FILETIME ft;
        GetSystemTime(&st);

        SystemTimeToFileTime(&st, &ft);

        ULARGE_INTEGER* pulLo = (ULARGE_INTEGER*)&_ftLastUpdate;
        ULARGE_INTEGER* pulHi = (ULARGE_INTEGER*)&ft;

        *pdwToRemove = (DWORD)(((pulHi->QuadPart) - (pulLo->QuadPart)) /
            10000);
    }
    else
    {
        if (INFINITE != _dwMinDelta)
        {
            *pdwToRemove = _dwMinDelta;
        }
        else
        {
            *pdwToRemove = 0;
        }
    }
    
    return S_OK;
}

// S_FALSE: live
// S_OK:    die
HRESULT CThreadCache::_PlayGod(CPair* ppair, DWORD dwToRemove)
{
    HRESULT hresKill = S_FALSE;

    if ((INFINITE != ppair->_dwTimeLeft) && (ppair->_dwTimeLeft <= dwToRemove))
    {
        // Oops!
        ppair->_dwTimeLeft = 0;

        hresKill = S_OK;
    }
    else
    {
        // Reduce life expectancy
        ppair->_dwTimeLeft -= dwToRemove;

        // Check when we'll need to wake up next time
        if (ppair->_dwTimeLeft < _dwMinDelta)
        {
            _dwMinDelta = ppair->_dwTimeLeft;
        }
    }

    return hresKill;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\growvm.cpp ===
#include <objbase.h>
#include "growvm.h"

#include "dbgassrt.h"

CGrowVirtMem::CGrowVirtMem() : _dwPageSize(0), _cbGrowRate(0), _cbMaxSize(0),
    _cbApproxMaxSize(0), _pbCurrent(NULL), _pbBase(NULL)
{}

CGrowVirtMem::~CGrowVirtMem()
{
    if (_pbBase)
    {
        BOOL b = VirtualFree(_pbBase, 0, MEM_RELEASE);
    }
}

HRESULT CGrowVirtMem::Init(DWORD cbApproxMaxSize, DWORD cbGrowRate)
{
    HRESULT hres = E_OUTOFMEMORY;
    SYSTEM_INFO sysinfo;

    GetSystemInfo(&sysinfo);

    _dwPageSize = sysinfo.dwPageSize;

    _cbGrowRate = _RoundOffToPageSize(cbGrowRate);
    _cbMaxSize = _cbApproxMaxSize = _RoundOffToPageSize(cbApproxMaxSize);

    _pbCurrent = _pbBase = (PBYTE)VirtualAlloc(NULL, _cbApproxMaxSize, MEM_RESERVE,
        PAGE_READWRITE);

    if (_pbBase)
    {
        hres = _GrowHelper();
    }

    return hres;
}

HRESULT CGrowVirtMem::Grow()
{
    return _GrowHelper();
}

HRESULT CGrowVirtMem::GetBufferAddress(PBYTE* ppb)
{
    ASSERT(ppb);

    *ppb = _pbBase;

    return S_OK;
}

HRESULT CGrowVirtMem::GetBufferSize(DWORD* pcb)
{
    ASSERT(pcb);
    
    *pcb = _pbCurrent - _pbBase;

    return S_OK;
}
///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////
DWORD CGrowVirtMem::_RoundOffToPageSize(DWORD c)
{
    ASSERT(_dwPageSize);

    return (((c + _dwPageSize) / _dwPageSize) * _dwPageSize) - _dwPageSize;
}

HRESULT CGrowVirtMem::_GrowHelper()
{
    HRESULT hres = E_OUTOFMEMORY;

    if (((_pbCurrent - _pbBase) + _cbGrowRate) <= _cbMaxSize)
    {
        PVOID pv = VirtualAlloc(_pbCurrent, _cbGrowRate, MEM_COMMIT, PAGE_READWRITE);

        if (pv)
        {
            hres = S_OK;

            _pbCurrent += _cbGrowRate;
        }
    }
    else
    {
        // FOR NOW WE DO NOT TRY TO GROW/REALLOCATE THE BUFFER
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\regsuprt.cpp ===
#include "regsuprt.h"

#include "dbgassrt.h"

#ifdef DEBUG
UINT CRegSupport::_cRefHKEY = 0;
UINT CRegSupport::_cRefExternalHKEY = 0;
#endif

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// for now
#define lstrcatn(a, b, c) lstrcat((a), (b))

#undef lstrcpyn

#define lstrcpyn(a, b, c) lstrcpy((a), (b))
// for now

// From shlwapi: required for NT only
DWORD RegDeleteKeyRecursively(HKEY hkey, LPCWSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkeySubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkeySubKey);

    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        WCHAR   szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        WCHAR   szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkeySubKey, szClass, &cbClass, NULL, &dwIndex,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkeySubKey, --dwIndex,
                szSubKeyName, cchSubKeyName))
            {
                RegDeleteKeyRecursively(hkeySubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkeySubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}


///////////////////////////////////////////////////////////////////////////////
// Init
HRESULT CRegSupport::RSInitRoot(HKEY hkey, LPCTSTR pszSubKey1, LPCTSTR pszSubKey2,
    BOOL fAllocMemForKey1, BOOL fAllocMemForKey2)
{
    HRESULT hres = E_OUTOFMEMORY;
    LPTSTR pszKeyFinal1 = (LPTSTR)pszSubKey1;
    LPTSTR pszKeyFinal2 = (LPTSTR)pszSubKey2;

    _fAllocMemForKey1 = fAllocMemForKey1;
    _fAllocMemForKey2 = fAllocMemForKey2;

    if (fAllocMemForKey1)
    {
        pszKeyFinal1 = (LPTSTR)LocalAlloc(LPTR,
            (lstrlen(pszSubKey1) + 1) * sizeof(TCHAR));

        if (pszKeyFinal1)
        {
            hres = S_OK;

            lstrcpy(pszKeyFinal1, pszSubKey1);
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        hres = S_OK;
    }

    if (pszSubKey2 && *pszSubKey2 && fAllocMemForKey2)
    {
        pszKeyFinal2 = (LPTSTR)LocalAlloc(LPTR,
            (lstrlen(pszSubKey2) + 1) * sizeof(TCHAR));

        if (pszKeyFinal2)
        {
            hres = S_OK;

            lstrcpy(pszKeyFinal2, pszSubKey2);
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        hres = S_OK;
    }

    if (SUCCEEDED(hres))
    {
        _hkeyInit = hkey;

        _InitSetRoot(pszKeyFinal1, pszKeyFinal2);

        // Default
        _dwRootOptions = REG_OPTION_NON_VOLATILE;
        _dwDefaultOptions = REG_OPTION_NON_VOLATILE;
    
#ifdef DEBUG
        ASSERT(!_fInited);
        _fInited = TRUE;
#endif
    }

    return hres;
}

HRESULT CRegSupport::RSInitOption(DWORD dwRootOptions, DWORD dwDefaultOptions)
{
    ASSERT(_fInited);

    _dwRootOptions = dwRootOptions; 
    _dwDefaultOptions = dwDefaultOptions;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Exist
HRESULT CRegSupport::RSSubKeyExist(LPCTSTR pszSubKey)
{
    HRESULT hres;

    _EnterCSKeyRoot();

    hres = _SubKeyExist(pszSubKey);

    _LeaveCSKeyRoot();

    return hres;
}

HRESULT CRegSupport::RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    HRESULT hres = S_FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        hres = (RegQueryValueEx(hkeySubKey, pszValueName, 0, NULL, NULL, NULL) ==
            ERROR_SUCCESS) ? S_OK : S_FALSE;

        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// Delete
HRESULT CRegSupport::RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    HRESULT hres = S_FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegDeleteValue(hkeySubKey, pszValueName))
        {
            hres = S_OK;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return hres;
}

HRESULT CRegSupport::RSDeleteKey()
{
    TCHAR szRoot[MAX_ROOT];

    return (ERROR_SUCCESS == RegDeleteKeyRecursively(_hkeyInit,
        _GetRoot(szRoot, ARRAYSIZE(szRoot)))) ? S_OK : S_FALSE;
}

HRESULT CRegSupport::RSDeleteSubKey(LPCTSTR pszSubKey)
{
    HRESULT hres = S_FALSE;

    _EnterCSKeyRoot();

    HKEY hkey = _GetRootKey(FALSE);

    if (hkey)
    {
        if (ERROR_SUCCESS == RegDeleteKeyRecursively(hkey, pszSubKey))
        {
            hres = S_OK;
        }
        _CloseRegSubKey(hkey);
    }

    _LeaveCSKeyRoot();

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// Set
HRESULT CRegSupport::RSSetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD cb,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, pb, cb, REG_BINARY, dwOptions);
}

HRESULT CRegSupport::RSSetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               LPCTSTR pszValue,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, (PBYTE)pszValue,
        (lstrlen(pszValue) + 1) * sizeof(TCHAR), REG_SZ, dwOptions);
}

HRESULT CRegSupport::RSSetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               DWORD dwValue,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, (PBYTE)&dwValue, 
        sizeof(DWORD), REG_DWORD, dwOptions);
}

///////////////////////////////////////////////////////////////////////////////
// Get
HRESULT CRegSupport::RSGetValueSize(LPCTSTR pszSubKey, LPCTSTR pszValueName,
    DWORD* pcbSize)
{
    return _GetGeneric(pszSubKey, pszValueName, NULL, pcbSize);
}

HRESULT CRegSupport::RSGetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD* pcb)
{
    return _GetGeneric(pszSubKey, pszValueName, pb, pcb);
}

HRESULT CRegSupport::RSGetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                LPTSTR pszValue, DWORD* pcchValue)
{
    DWORD cbData = *pcchValue * sizeof(TCHAR);

    return _GetGeneric(pszSubKey, pszValueName, (PBYTE)pszValue, &cbData);
}

HRESULT CRegSupport::RSGetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD* pdwValue)
{
    DWORD cbData = sizeof(DWORD);

    return _GetGeneric(pszSubKey, pszValueName, (PBYTE)pdwValue, &cbData);
}

///////////////////////////////////////////////////////////////////////////////
// Enum
HRESULT CRegSupport::RSEnumSubKeys(LPCTSTR pszSubKey, CRSSubKeyEnum** ppenum)
{
    HRESULT hres = E_FAIL;

    _EnterCSKeyRoot();

    hres = _SubKeyExist(pszSubKey);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        *ppenum = new CRSSubKeyEnum();

        if (*ppenum)
        {
            TCHAR szRoot[MAX_ROOT];

            _GetRoot(szRoot, ARRAYSIZE(szRoot));

            if (pszSubKey)
            {
                lstrcatn(szRoot, TEXT("\\"), ARRAYSIZE(szRoot));
                lstrcatn(szRoot, pszSubKey, ARRAYSIZE(szRoot));
            }

            hres = (*ppenum)->_Init(_hkeyInit, szRoot);

            if (FAILED(hres))
            {
                delete *ppenum;
            }
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        hres = E_FAIL;
    }

    _LeaveCSKeyRoot();

    return hres;
}

HRESULT CRegSupport::RSEnumValues(LPCTSTR pszSubKey, CRSValueEnum** ppenum)
{
    HRESULT hres = E_FAIL;

    _EnterCSKeyRoot();

    hres = _SubKeyExist(pszSubKey);

    if (SUCCEEDED(hres) && (S_FALSE != hres))
    {
        *ppenum = new CRSValueEnum();

        if (*ppenum)
        {
            TCHAR szRoot[MAX_ROOT];

            _GetRoot(szRoot, ARRAYSIZE(szRoot));

            if (pszSubKey)
            {
                lstrcatn(szRoot, TEXT("\\"), ARRAYSIZE(szRoot));
                lstrcatn(szRoot, pszSubKey, ARRAYSIZE(szRoot));
            }

            hres = (*ppenum)->_Init(_hkeyInit, szRoot);

            if (FAILED(hres))
            {
                delete *ppenum;
            }
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        hres = E_FAIL;
    }

    _LeaveCSKeyRoot();

    return hres;
}
///////////////////////////////////////////////////////////////////////////////
// Misc
HKEY CRegSupport::RSDuplicateRootKey()
{
    ASSERT(_fInited);
#ifdef DEBUG
    // we need to decrement here since it will be icnremented inside this fct
    // and the key will not be close by this object
    --_cRefHKEY;
    ++_cRefExternalHKEY;
#endif
    TCHAR szRoot[MAX_ROOT];

    return _RegCreateKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)), _dwRootOptions);
}

HRESULT CRegSupport::RSGetHiveKey(HKEY* phkey)
{
    ASSERT(_fInited);

    *phkey = _hkeyInit;

    return S_OK;
}

HRESULT CRegSupport::RSGetSubKey(LPTSTR pszKey, DWORD cchKey)
{
    ASSERT(_fInited);

    lstrcpyn(pszKey, _pszSubKey1, cchKey);

    if (_pszSubKey2)
    {
        lstrcatn(pszKey, TEXT("\\"), cchKey);
        lstrcatn(pszKey, _pszSubKey2, cchKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\rsimpl.cpp ===
#include "regsuprt.h"

#include "dbgassrt.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

// for now
#define lstrcatn(a, b, c) lstrcat((a), (b))
// for now

HRESULT CRegSupport::_SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD cb, DWORD dwType,
                                DWORD dwOptions)
{
    HRESULT hres = E_FAIL;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, TRUE, dwOptions);
    else
        hkeySubKey = _GetRootKey(TRUE, dwOptions);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkeySubKey, pszValueName, 0, 
            dwType, pb, cb))
        {
            hres = S_OK;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return hres;
}

HRESULT CRegSupport::_GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD* pcb)
{
    HRESULT hres = E_FAIL;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkeySubKey, pszValueName, 0, 
            NULL, pb, pcb))
        {
            hres = S_OK;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return hres;
}

// Always need to be called from within the _csRootKey critical section (when critical section
// stuff is enabled)

HRESULT CRegSupport::_SubKeyExist(LPCTSTR pszSubKey)
{
    HRESULT hres = S_FALSE;
    HKEY hkeySubKey = NULL;
    
    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        hres = S_OK;
        _CloseRegSubKey(hkeySubKey);
    }

    return hres;
}

HKEY CRegSupport::_GetRootKey(BOOL fCreate, DWORD dwOptions)
{
    ASSERT(_fInited);

    HKEY hkey;
    TCHAR szRoot[MAX_ROOT];

    if (REG_OPTION_INVALID == dwOptions)
        dwOptions = _dwRootOptions;

    if (fCreate)
        hkey = _RegCreateKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)), dwOptions);
    else
        hkey = _RegOpenKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)));

    return hkey;
}

void CRegSupport::_CloseRegSubKey(HKEY hkeySubKey)
{
    RegCloseKey(hkeySubKey);

#ifdef DEBUG
    --_cRefHKEY;
#endif
}

// Always need to be called from within the _csRootKey critical section (when critical section
// stuff is enabled)

HKEY CRegSupport::_GetSubKey(LPCTSTR pszSubKey, BOOL fCreate, DWORD dwOptions)
{
    HKEY hkey = NULL;

    HKEY hRootKey = _GetRootKey(fCreate, dwOptions);

    if (REG_OPTION_INVALID == dwOptions)
        dwOptions = _dwDefaultOptions;

    if (hRootKey)
    {
        if (fCreate)
            hkey = _RegCreateKeyExHelper(hRootKey, pszSubKey, dwOptions);
        else
            hkey = _RegOpenKeyExHelper(hRootKey, pszSubKey);

        _CloseRegSubKey(hRootKey);
    }

    return hkey;
}

//static
HKEY CRegSupport::_RegCreateKeyExHelper(HKEY hkey, LPCTSTR pszSubKey, DWORD dwOptions)
{
    HKEY hkeyTmp;
    DWORD dwDisp;

    ASSERT(REG_OPTION_INVALID != dwOptions);

    if (ERROR_SUCCESS != RegCreateKeyEx(hkey, pszSubKey, 0, NULL, 
        dwOptions, MAXIMUM_ALLOWED, NULL, &hkeyTmp, &dwDisp))
    {
        hkeyTmp = NULL;
    }
#ifdef DEBUG
    else
    {
        ++_cRefHKEY;
    }
#endif

    return hkeyTmp;
}

//static
HKEY CRegSupport::_RegOpenKeyExHelper(HKEY hkey, LPCTSTR pszSubKey)
{
    HKEY hkeyTmp;

    if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0,
        MAXIMUM_ALLOWED, &hkeyTmp))
    {
        hkeyTmp = NULL;
    }
#ifdef DEBUG
    else
    {
        ++_cRefHKEY;
    }
#endif

    return hkeyTmp;
}

HRESULT CRegSupport::_InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2)
{
    _pszSubKey1 = pszSubKey1;
    _pszSubKey2 = pszSubKey2;

    return S_OK;
}

LPCTSTR CRegSupport::_GetRoot(LPTSTR pszRoot, DWORD cchRoot)
{
    ASSERT(cchRoot > 0);

    lstrcpyn(pszRoot, _pszSubKey1, cchRoot);

    if (_pszSubKey2)
    {
        lstrcatn(pszRoot, TEXT("\\"), cchRoot);
        lstrcatn(pszRoot, _pszSubKey2, cchRoot);
    }

    return pszRoot;
}

void CRegSupport::_InitCSKeyRoot()
{
    ASSERT(!_fcsKeyRoot);

    _fcsKeyRoot = TRUE;
    InitializeCriticalSection(&_csKeyRoot);
}

void CRegSupport::_EnterCSKeyRoot()
{
    if (_fcsKeyRoot)
    {
        EnterCriticalSection(&_csKeyRoot);
    }
}

void CRegSupport::_LeaveCSKeyRoot()
{
    if (_fcsKeyRoot)
    {
        LeaveCriticalSection(&_csKeyRoot);
    }
}

CRegSupport::CRegSupport() : _fAllocMemForKey1(FALSE),
    _fAllocMemForKey2(FALSE), _fcsKeyRoot(FALSE)
#ifdef DEBUG
    , _fInited(FALSE)
#endif
{}

CRegSupport::~CRegSupport()
{
    if (_fAllocMemForKey1 && _pszSubKey1)
    {
        LocalFree((HLOCAL)_pszSubKey1);
    }

    if (_fAllocMemForKey2 && _pszSubKey2)
    {
        LocalFree((HLOCAL)_pszSubKey2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\rsenum.cpp ===
#include "regsuprt.h"

#include "dbgassrt.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CRSSubKeyEnum::Next(LPTSTR pszKey, DWORD cchKey, CRegSupport** pprs)
{
    ASSERT(_fInited);
    ASSERT(_hkey);
    HRESULT hres = E_FAIL;
    TCHAR szKeyLocal[MAX_PATH];
    DWORD cchKeyLocal = ARRAYSIZE(szKeyLocal);

    LONG lRes = RegEnumKeyEx(_hkey, _dwIndex, szKeyLocal, &cchKeyLocal, NULL, NULL,
        NULL, NULL);

    if (pprs)
    {
        *pprs = NULL;
    }

    if (pszKey && cchKey)
    {
        *pszKey = 0;
    }

    switch (lRes)
    {
        case ERROR_NO_MORE_ITEMS:
            hres = S_FALSE;
            break;

        case ERROR_SUCCESS:
            if (pprs)
            {
                *pprs = new CRegSupport();

                if (*pprs)
                {
                    hres = (*pprs)->RSInitRoot(_hkeyInit, _szSubKeyInit,
                        szKeyLocal, TRUE, TRUE);

                    if (FAILED(hres))
                    {
                        delete *pprs;
                        *pprs = NULL;
                    }
                }
                else
                {
                    hres = E_OUTOFMEMORY;
                }
            }
            else
            {
                hres = S_OK;
            }

            if (SUCCEEDED(hres))
            {
                if (pszKey && cchKey)
                {
                    lstrcpyn(pszKey, szKeyLocal, cchKey);
                }

                ++_dwIndex;
            }
            break;

        default:
            hres = E_FAIL;
            break;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CRSSubKeyEnum::_Init(HKEY hkey, LPTSTR pszSubKey)
{
    HRESULT hres = E_FAIL;

    if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0, MAXIMUM_ALLOWED,
        &_hkey))
    {
        _hkey = NULL;
    }
    else
    {
        _hkeyInit = hkey;
        lstrcpyn(_szSubKeyInit, pszSubKey, ARRAYSIZE(_szSubKeyInit));

        hres = S_OK;
    }

#ifdef DEBUG
    if (SUCCEEDED(hres))
    {
        _fInited = TRUE;
    }
#endif

    return hres;
}

CRSSubKeyEnum::CRSSubKeyEnum() : _hkey(NULL), _dwIndex(0)
#ifdef DEBUG
    ,_fInited(FALSE)
#endif
{}

CRSSubKeyEnum::~CRSSubKeyEnum()
{
    if (_hkey)
    {
        RegCloseKey(_hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\strconv.cpp ===
#include <objbase.h>
#include "strconv.h"

BOOL _CopyXDigitChars(LPCWSTR pszSource, LPWSTR pszDest, DWORD cch);
BOOL _HexStringToDword(LPCWSTR* ppsz, DWORD* lpValue, int cDigits,
    WCHAR chDelim);

///////////////////////////////////////////////////////////////////////////////
// FILETIME
///////////////////////////////////////////////////////////////////////////////
BOOL FileTimeToString(const FILETIME* pft, LPWSTR psz, DWORD cch)
{
    SYSTEMTIME st;

    BOOL fSuccess = FileTimeToSystemTime(pft, &st);
    
    if (fSuccess)
    {
        // should use wsnprintf
        // MM/DD/YYYY hh:mm:ss.mmm
        wsprintf(psz, L"%02d/%02d/%04d %02d:%02d:%02d.%03d",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute,
            st.wSecond, st.wMilliseconds);
    }

    return fSuccess;
}

BOOL StringToFileTime(LPCWSTR psz, FILETIME* pft)
{
    BOOL fSuccess = FALSE;
    SYSTEMTIME st;
    WCHAR szBuffer[5];

    // let's parse the string
    // Required format: MM/DD/YYYY hh:mm:ss.mmm

    // Month
    if (_CopyXDigitChars(psz, szBuffer, 2))
    {
        st.wMonth = (unsigned short)_wtoi(szBuffer);

        // skip delimiter
        psz += 3;

        // Day
        if (_CopyXDigitChars(psz, szBuffer, 2))
        {
            st.wDay = (unsigned short)_wtoi(szBuffer);

            // skip delimiter
            psz += 3;

            // Year
            if (_CopyXDigitChars(psz, szBuffer, 4))
            {
                st.wYear = (unsigned short)_wtoi(szBuffer);

                // skip delimiter
                psz += 5;

                // Hour
                if (_CopyXDigitChars(psz, szBuffer, 2))
                {
                    st.wHour = (unsigned short)_wtoi(szBuffer);

                    // skip delimiter
                    psz += 3;

                    // Minute
                    if (_CopyXDigitChars(psz, szBuffer, 2))
                    {
                        st.wMinute = (unsigned short)_wtoi(szBuffer);

                        // skip delimiter
                        psz += 3;

                        // Second
                        if (_CopyXDigitChars(psz, szBuffer, 2))
                        {
                            st.wSecond = (unsigned short)_wtoi(szBuffer);

                            // skip delimiter
                            psz += 3;

                            // Millisec
                            if (_CopyXDigitChars(psz, szBuffer, 3))
                            {
                                st.wMilliseconds = (unsigned short)_wtoi(szBuffer);

                                fSuccess = TRUE;
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (fSuccess)
    {
        fSuccess = SystemTimeToFileTime(&st, pft);
    }

    return fSuccess;
}

///////////////////////////////////////////////////////////////////////////////
// GUID
///////////////////////////////////////////////////////////////////////////////
// Will return something like this: {2CA8CA52-3C3F-11D2-B73D-00C04FB6BD3D}

// psz should point to a string which is at least 39 char long
BOOL GUIDToString(const GUID *pguid, LPWSTR psz)
{
    wsprintf(psz,
        L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        pguid->Data1,
        pguid->Data2,
        pguid->Data3,
        pguid->Data4[0],
        pguid->Data4[1],
        pguid->Data4[2],
        pguid->Data4[3],
        pguid->Data4[4],
        pguid->Data4[5],
        pguid->Data4[6],
        pguid->Data4[7]); 

    return TRUE;
}

BOOL StringToGUID(LPCWSTR psz, GUID *pguid)
{
    DWORD dw;
    if (*psz++ != TEXT('{') /*}*/ )
        return FALSE;

    if (!_HexStringToDword(&psz, &pguid->Data1, sizeof(DWORD)*2, TEXT('-')))
        return FALSE;

    if (!_HexStringToDword(&psz, &dw, sizeof(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, TEXT('-')))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!_HexStringToDword(&psz, &dw, sizeof(BYTE)*2, /*(*/ TEXT('}')))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

// caller needs to provide room in pszDest for cch chars + NULL terminator
BOOL _CopyXDigitChars(LPCWSTR pszSource, LPWSTR pszDest, DWORD cch)
{
    while (cch && (*pszSource) && (*pszSource >= L'0') && (*pszSource <= L'9'))
    {
        *pszDest = *pszSource;

        ++pszSource;
        ++pszDest;
        --cch;
    }

    *pszDest = 0;

    return !cch;
}

BOOL _HexStringToDword(LPCWSTR* ppsz, DWORD* lpValue, int cDigits,
    WCHAR chDelim)
{
    LPCWSTR psz = *ppsz;
    DWORD Value = 0;
    BOOL fRet = TRUE;

    for (int ich = 0; ich < cDigits; ich++)
    {
        WCHAR ch = psz[ich];
        if ((ch >= TEXT('0')) && (ch <= TEXT('9')))
        {
            Value = (Value << 4) + ch - TEXT('0');
        }
        else
        {
            if (((ch |= (TEXT('a')-TEXT('A'))) >= TEXT('a')) &&
                ((ch |= (TEXT('a')-TEXT('A'))) <= TEXT('f')))
            {
                Value = (Value << 4) + ch - TEXT('a') + 10;
            }
            else
            {
                return(FALSE);
            }
        }
    }

    if (chDelim)
    {
        fRet = (psz[ich++] == chDelim);
    }

    *lpValue = Value;
    *ppsz = psz+ich;

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\dll\makefile.inc ===
$(HTTPCOM_ROOT)\lib\$(O)\httpcom.lib: $(O)\httpcom.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\rsvalenum.cpp ===
#include "regsuprt.h"

#include "dbgassrt.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

HRESULT CRSValueEnum::Next(LPTSTR pszValue, DWORD cchValue)
{
    ASSERT(_fInited);
    ASSERT(_hkey);
    HRESULT hres;

    LONG lRes = RegEnumValue(_hkey, _dwIndex, pszValue, &cchValue, NULL, NULL,
        NULL, NULL);

    switch (lRes)
    {
        case ERROR_NO_MORE_ITEMS:
            hres = S_FALSE;
            break;

        case ERROR_SUCCESS:
            ++_dwIndex;
            hres = S_OK;
            break;

        default:
            hres = E_FAIL;
            break;
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
//
HRESULT CRSValueEnum::_Init(HKEY hkey, LPTSTR pszSubKey)
{
    HRESULT hres = E_FAIL;

    if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0, MAXIMUM_ALLOWED,
        &_hkey))
    {
        _hkey = NULL;
    }
    else
    {
        _hkeyInit = hkey;
        lstrcpyn(_szSubKeyInit, pszSubKey, ARRAYSIZE(_szSubKeyInit));

        hres = S_OK;
    }

#ifdef DEBUG
    if (SUCCEEDED(hres))
    {
        _fInited = TRUE;
    }
#endif

    return hres;
}

CRSValueEnum::CRSValueEnum() : _hkey(NULL), _dwIndex(0)
#ifdef DEBUG
    ,_fInited(FALSE)
#endif
{}

CRSValueEnum::~CRSValueEnum()
{
    if (_hkey)
    {
        RegCloseKey(_hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\acallfnd.cpp ===
// acallfnd.cpp
//
// PROPFIND and PROPPATCH response handlers

#include <objbase.h>
#include <assert.h>
#include <wininet.h>
#include "asynccall.h"
#include "qxml.h"
#include "strutil.h"
#include "regexp.h"
#include "mischlpr.h"

#define MAX_PREFIX 100

// creates a new string which is pwszXMLPath with "<pwszNamespace>:" added before each tag
//
// ex. "foo/bar/baz", "DAV" -> "DAV:foo/DAV:bar/DAV:baz"
//
// new string is allocated and returned,  client is responsible for freeing it.
LPWSTR CAsyncWntCallbackImpl::_XMLNSExtend (LPWSTR pwszNamespace, 
                                            LPWSTR pwszXMLPath)
{
    DWORD cch;
    DWORD cchWritten = 0;
    LPWSTR pwsz = NULL;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszTemp2 = NULL;
    UINT cSlashes = 0;
    UINT cchNamespace;
    UINT cchXMLPath;

    if (pwszNamespace != NULL && pwszXMLPath != NULL)
    {
        cchXMLPath = lstrlen(pwszXMLPath);
        cchNamespace = lstrlen(pwszNamespace);

        // count the slashes
        for (UINT i = 0; i < cchXMLPath ; i++)
        {
            if (pwszXMLPath[i] == '/')
            {
                cSlashes++;
            }
        }

        // need length of initial string, 
        // plus (length of namespace + 1) for each token,
        // and there is ((number of slashes) + 1) tokens
        cch = cchXMLPath + (cSlashes+1) * (1 + cchNamespace);
        pwsz = AllocateStringW(cch);
    
        if (pwsz != NULL)
        {            
            // initialize the string so we can use lstrcat
            pwsz[0] = NULL;

            pwszTemp = pwszXMLPath; // we advance pwszTemp down pwszXMLPath, building up pwsz as we go
    
            for (i = 0 ; i < cSlashes ; i++) // for each token
            {
                if (pwszTemp == NULL) // have we reached the end?
                {
                    free(pwsz);
                    pwsz = NULL;
                }
                else
                {
                    // find the next slash after the read head
                    pwszTemp2=LStrStr(pwszTemp, L"/");
                    if (pwszTemp2 == NULL)
                    {
                        free(pwsz);
                        pwsz = NULL;
                    }
                    else
                    {
                        // copy namespace:<token>, where token is the text up to the next slash
                        // -- add the "namespace:"
                        lstrcat(pwsz, pwszNamespace);
                        lstrcat(pwsz, L":");
                        cchWritten+= lstrlen(pwszNamespace) + 1;
        
                        // -- add the next token
                        lstrcpyn(pwsz + cchWritten, pwszTemp, pwszTemp2 - pwszTemp + 1);
                        lstrcat(pwsz, L"/");
                        cchWritten+= (pwszTemp2 - pwszTemp + 1 + 1);

                        // advance read head to after the next slash
                        pwszTemp = pwszTemp2+1;
                    }
                }
            }
        }

        if (pwsz != NULL) // if we haven't failed yet
        {
            // we stop after the last slash, but we still need to add in the last 
            // token in the path, which is the token AFTER the last slash
            lstrcat(pwsz, pwszNamespace);
            lstrcat(pwsz, L":");
            lstrcat(pwsz, pwszTemp);
        }
    }

    return pwsz;
}

////////////////////////

// take in a buffer, initialize pqxml with everything between "<?xml" and :"multistatus>"
// also store the alias for DAV: in this XML blob
STDMETHODIMP CAsyncWntCallbackImpl::_InitQXMLFromMessyBuffer(CQXML*  pqxml,
                                                             LPSTR   pszXML,
                                                             WCHAR   wszDAVAlias[])
{
    // locals
    HRESULT hres = S_OK;
    LPWSTR pwszTemp = NULL;
    LPWSTR pwszResponse = NULL;
    LPWSTR pwszResponsePtr = NULL;
    ULONG  cch;
    
    // code
    
    // -- first, convert the ANSI string that holds the XML into a CQXML object
    // is the response coming back ANSI or Unicode?  Is there a way we can tell?
    
    // ---- pwszResponse is the ptr to the start of the response string
    pwszResponse = ConvertToUnicode (CP_ACP, pszXML);
    if (pwszResponse == NULL)
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        // ---- pwszResponsePtr is the ptr to the first meaningful part of the response string
        pwszResponsePtr = pwszResponse;
    
        // -- strip off the <?xml versioninfo ?> thing
        pwszTemp = LStrStr(pwszResponse, L"<?xml");
        if (pwszTemp != NULL)
        {
            pwszTemp = LStrStr(pwszTemp, L"?>");
            if (pwszTemp != NULL)
            {
                pwszResponsePtr = pwszTemp + 3;
                pwszTemp = NULL;
            }
            else
            {
                hres = E_FAIL;
            }
        }
        else
        {
            hres = E_FAIL;
        }
    
        if (SUCCEEDED(hres))
        {
            // -- strip off any garbage after </D:multistatus>
            pwszTemp = LStrStr(pwszResponsePtr, L"multistatus>");
            if (pwszTemp != NULL)
            {
                *(pwszTemp+12) = NULL; // cutt of stuff after
    
                // -- initialize the qxml object
                hres = pqxml->InitFromBuffer(pwszResponsePtr);
    
                if (SUCCEEDED(hres) && hres != S_FALSE)
                {
                    // find the alias associated with DAV:
                    if (FindEnclosedText(pwszResponse, L"xmlns:", L"=\"DAV:\"", &pwszTemp, &cch))
                    {        
                        if (pwszTemp == NULL)
                        {
                            lstrcpy(wszDAVAlias, L"DAV"); // default to "DAV" as the name for DAV:
                        }
                        else
                        {
                            lstrcpyn(wszDAVAlias, pwszTemp, cch+1); // may be that user has defined A: to mean DAV:
                        }
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
            }
            else
            {
                hres = E_FAIL;
            }
        }
    }

    // release stuff
    if (pwszResponse != NULL)
    {
        free(pwszResponse);
    }

    // return value
    return hres;
}
////////////////////////

LPWSTR CAsyncWntCallbackImpl::_GetHREF (CQXML* pqxml,
                                        WCHAR wszDavPrefix[])
{
    // locals
    LPWSTR  pwszTagName = NULL;
    HRESULT hres = S_OK;
    WCHAR   wszPath[MAX_PATH];
    LPWSTR  pwszResult = NULL;

    // check params
    if (pqxml == NULL || wszDavPrefix == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        // code
        pwszTagName = _XMLNSExtend ( wszDavPrefix, L"href");
        if (pwszTagName != NULL)
        {
            hres = pqxml->GetText(NULL, pwszTagName, wszPath, MAX_PATH);
        }            
        
    }

    // release stuff
    if (pwszTagName != NULL)
    {
        free(pwszTagName);
    }

    // return value
    if (SUCCEEDED(hres))
    {
        pwszResult = DuplicateStringW(wszPath);
    }
    else
    {
        pwszResult = NULL;
    }
    return pwszResult;
}

////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePROPFINDHelper(DAVRESPONSE* pdavResponse,
                                                                 LPWSTR       pwszPath,                                                                
                                                                 LPWSTR       pwszDavPrefix,
                                                                 CQXML*       pqxml)                                                           
{
    // locals
    HRESULT             hres = S_OK;
    
    CQXML*              pqxml2 = NULL;
    CQXML*              pqxml3 = NULL;
    CQXMLEnum*          pqxmlEnum2 = NULL;
    IPropFindRequest*   pfindreq;
    
    UINT                cProperties;
    UINT                cPropertiesRequested;
    
    DAVPROPVAL*         prgPropValTemp = NULL;
    DAVPROPID           dpi;
    
    LPWSTR pwszTag = NULL;
    LPWSTR pwszTagName = NULL;
    LPWSTR pwszNamespace = NULL;
    LPWSTR pwszNamespaceAlias = NULL;
    LPWSTR pwszValue = NULL;
    URL_COMPONENTS urlComponents = {0};
    
    // code
    // first, if this is noRoot, then stop if this is the root
    urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
    urlComponents.dwUrlPathLength = 1;
    if (!InternetCrackUrl(pwszPath, 0, 0, &urlComponents))
    {
        hres = E_FAIL;
    }
    else if (_fNoRoot &&
             (lstrlen(pdavResponse->rPropFind.pwszHref) == (INT)urlComponents.dwUrlPathLength) &&
             (LStrCmpNI((LPWSTR)pdavResponse->rPropFind.pwszHref, urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength) == 0))
    {
        hres = S_OK; // this is the root, ignore it
    }
    else
    {
        // get the properties of the item found
        pwszTagName = _XMLNSExtend ( pwszDavPrefix, L"propstat");
        if (pwszTagName == NULL)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = pqxml->GetQXML(NULL, pwszTagName, &pqxml2);
            if (SUCCEEDED(hres) && hres != S_FALSE)
            {
                pwszTagName = _XMLNSExtend ( pwszDavPrefix, L"prop");
                if (pwszTagName == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                else
                {
                    hres = pqxml2->GetQXMLEnum(pwszTagName, L"*", &pqxmlEnum2);
                    if (SUCCEEDED(hres) && hres != S_FALSE)
                    {
                        free(pwszTagName);
                        pwszTagName = NULL;
                    
                        // this is the count of properties for this entry
                        hres = pqxmlEnum2->GetCount((long*)&cProperties);    
                        if (SUCCEEDED(hres) && hres != S_FALSE)
                        {
                            // this is the number of properties requested by the user
                            pfindreq = (IPropFindRequest*)_dwParam;
                            assert(pfindreq != NULL);
                        
                            hres = pfindreq->GetPropCount(&cPropertiesRequested);
                            if (SUCCEEDED(hres))
                            {
                            
                                // is this an allprop?
                                if (cPropertiesRequested > 0)
                                {
                                    // if not an allprop, we only need entries for the things we requested
                                    prgPropValTemp = (DAVPROPVAL*)malloc(sizeof(DAVPROPVAL) * cPropertiesRequested);
                                    pdavResponse->rPropFind.cPropVal = 0;
                                }
                                else
                                {
                                    // if cProperties == 0, then this is an allprop, so we need double the total number of entries
                                    prgPropValTemp = (DAVPROPVAL*)malloc(sizeof(DAVPROPVAL) * cProperties * 2);
                                    pdavResponse->rPropFind.cPropVal = (WORD)(cProperties * 2);
                                }
                                if (prgPropValTemp == NULL)
                                {
                                    hres = E_OUTOFMEMORY;
                                }
                                else
                                {
                                
                                    for (DWORD j = 0; j < cProperties; j++)
                                    {
                                        hres = (pqxmlEnum2->NextQXML(&pqxml3));
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pqxml3->GetRootTagNameNoBuf(&pwszTag);
                                            if (SUCCEEDED(hres) && hres != S_FALSE)
                                            {
                                                hres = pqxml3->GetRootNamespaceNameNoBuf(&pwszNamespace);
                                                if (SUCCEEDED(hres))
                                                {
                                                    hres = pqxml3->GetRootNamespaceAliasNoBuf(&pwszNamespaceAlias);
                                                    if (SUCCEEDED(hres) && hres != S_FALSE)
                                                    {
                                                        hres = pqxml3->GetTextNoBuf(NULL, NULL, &pwszValue);
                                                        if (SUCCEEDED(hres) && hres != S_FALSE)
                                                        {
                                                        
                                                            if (cPropertiesRequested > 0)
                                                            {
                                                                // not a find: allprop, only return if one of the requested props
                                                                if (pfindreq->GetPropInfo(pwszNamespace,
                                                                    //pwszNamespaceAlias,
                                                                    pwszTag,
                                                                    &dpi))
                                                                {
                                                                    prgPropValTemp[(pdavResponse->rPropFind.cPropVal)].dwId = dpi.dwId;
                                                                    prgPropValTemp[(pdavResponse->rPropFind.cPropVal)].dpt = DPT_LPWSTR;
                                                                    prgPropValTemp[(pdavResponse->rPropFind.cPropVal)].pwszVal = DuplicateStringW(pwszValue);
                                                                
                                                                    pdavResponse->rPropFind.cPropVal = (WORD)(pdavResponse->rPropFind.cPropVal + 1);
                                                                }                    
                                                            }
                                                            else
                                                            {
                                                                // a find: allprop, return prop no matter what it is
                                                                // we need to return two properties: the tag name (w/ namespace) and the value, since on an allprop we
                                                                // don't know what IDs to bind things to
                                                                prgPropValTemp[j*2].dwId = j*2;
                                                                prgPropValTemp[j*2].dpt = DPT_LPWSTR;
                                                                if (pwszNamespace != NULL)
                                                                {
                                                                    prgPropValTemp[j*2].pwszVal = (LPWSTR)malloc(sizeof(WCHAR) * (lstrlen(pwszTag) + lstrlen(pwszNamespace) + 1));
                                                                    lstrcpy(prgPropValTemp[j*2].pwszVal, pwszNamespace);
                                                                    lstrcat(prgPropValTemp[j*2].pwszVal, pwszTag);
                                                                }
                                                                else
                                                                {
                                                                    prgPropValTemp[j*2].pwszVal = DuplicateStringW(pwszTag);
                                                                }
                                                            
                                                                prgPropValTemp[j*2 + 1].dwId = j*2 + 1;
                                                                prgPropValTemp[j*2 + 1].dpt = DPT_LPWSTR;
                                                                prgPropValTemp[j*2 + 1].pwszVal = DuplicateStringW(pwszValue);
                                                            }
                                                        
                                                            pqxml3->ReleaseBuf(pwszTag);
                                                            if (pwszNamespace != NULL)
                                                            {
                                                                pqxml3->ReleaseBuf(pwszNamespace);
                                                                assert(pwszNamespaceAlias != NULL); // namespace and alias go together
                                                                pqxml3->ReleaseBuf(pwszNamespaceAlias);
                                                            }
                                                            pqxml3->ReleaseBuf(pwszValue);
                                                            delete pqxml3;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            delete pqxmlEnum2;
                        }
                    }
                }
                delete pqxml2;
            }
        }
    

        if (pdavResponse->rPropFind.cPropVal > 0)
        {
            // only call the callback if we actually found anything
        
            pdavResponse->rPropFind.rgPropVal = (DAVPROPVAL*)malloc(sizeof(DAVPROPVAL) * pdavResponse->rPropFind.cPropVal);
            if (pdavResponse->rPropFind.rgPropVal == NULL)
            {
                hres = E_OUTOFMEMORY;
            }
            else
            {
                CopyMemory(pdavResponse->rPropFind.rgPropVal, prgPropValTemp, sizeof(DAVPROPVAL) * pdavResponse->rPropFind.cPropVal);
        
                // call the callback once for each entity returned by the server
                hres = _pcallback->OnResponse(pdavResponse);
                free(pdavResponse->rPropFind.rgPropVal);
            }        
        }
    
        // release stuff
        if (prgPropValTemp != NULL)
        {
            free(prgPropValTemp);
        }
    }
    
    // return value
    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePROPPATCHHelper(DAVRESPONSE* pdavResponse,
                                                                  LPWSTR       UNREF_PARAM(pwszPath),
                                                                  LPWSTR       pwszDavPrefix,
                                                                  CQXML*       pqxml)
{
    // locals
    HRESULT             hres;
    
    LPWSTR              pwszTagName = NULL;
    CQXMLEnum*          pqxmlEnum2 = NULL;
    CQXML*              pqxml2 = NULL;
    UINT                cValidResponses = 0;    
    LPWSTR              pwszTag = NULL;
    LPWSTR              pwszNamespace = NULL;
    LPWSTR              pwszNamespaceAlias = NULL;
    IPropPatchRequest*  ppatchreq;                                
    DAVPROPID           dpi;
            

    // code

    // get the properties of the item found
    pwszTagName = _XMLNSExtend ( pwszDavPrefix, L"propstat/prop");
    if (pwszTagName == NULL)
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        hres = pqxml->GetQXMLEnum(pwszTagName, L"*", &pqxmlEnum2);
        if (SUCCEEDED(hres) && hres != S_FALSE)
        {
            free(pwszTagName);
            pwszTagName = NULL;
    
            // this is the count of properties returned by the proppatch
            hres = pqxmlEnum2->GetCount((long*)&(pdavResponse->rPropFind.cPropVal));
            if (SUCCEEDED(hres) && hres != S_FALSE)
            {
    
                if (pdavResponse->rPropFind.cPropVal == 0)
                {                
                    pdavResponse->rPropFind.rgPropVal = NULL;
                }
                else
                {
                    pdavResponse->rPropFind.rgPropVal = (DAVPROPVAL*)malloc(sizeof(DAVPROPVAL) * pdavResponse->rPropFind.cPropVal);
                    if (FAILED(pdavResponse->rPropFind.rgPropVal))
                    {
                        hres = E_OUTOFMEMORY;
                    }
                    else
                    {        
                        for (DWORD j = 0; j < pdavResponse->rPropFind.cPropVal; j++)
                        {
                            hres = pqxmlEnum2->NextQXML(&pqxml2);
                            if (SUCCEEDED(hres))
                            {
                                hres = pqxml2->GetRootTagNameNoBuf(&pwszTag);
                                if (SUCCEEDED(hres) && hres != S_FALSE)
                                {
                                    hres = pqxml2->GetRootNamespaceNameNoBuf(&pwszNamespace); // namespace can be NULL
                                    if (SUCCEEDED(hres))
                                    {
                                        hres = pqxml2->GetRootNamespaceAliasNoBuf(&pwszNamespaceAlias); // namespace can be NULL
                                        if (SUCCEEDED(hres))
                                        {
                                            ppatchreq = (IPropPatchRequest*)_dwParam;                    
                                            assert(ppatchreq != NULL);
            
                                            if (ppatchreq->GetPropInfo(pwszNamespace,
                                                pwszTag,
                                                &dpi))
                                            {
                                                pdavResponse->rPropFind.rgPropVal[cValidResponses].dwId = dpi.dwId;
                                                pdavResponse->rPropFind.rgPropVal[cValidResponses].dpt = dpi.dpt;                        
                                                cValidResponses++;
                                            }
                                        }
                                        if (pwszNamespace != NULL)
                                        {
                                            pqxml2->ReleaseBuf(pwszNamespace);
                                            assert(pwszNamespaceAlias != NULL);
                                            pqxml2->ReleaseBuf(pwszNamespaceAlias);
                                        }
                                    }
                                    pqxml2->ReleaseBuf(pwszTag);
                                }
                                delete pqxml2;
                            }
                        }
        
                        // call the callback once for each entity returned by the server
                        pdavResponse->rPropFind.cPropVal = (WORD)cValidResponses;
                        hres = _pcallback->OnResponse(pdavResponse);
        
                        free(pdavResponse->rPropFind.rgPropVal);
                    }
                }
            }    
            delete pqxmlEnum2;
        }
    }

    // return value
    return hres;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePROPFINDPATCH(DAVRESPONSE* pdavResponse,
                                                                LPWSTR       UNREF_PARAM(pwszVerb),
                                                                LPWSTR       pwszPath,
                                                                DWORD        cchHeaders,
                                                                LPWSTR       UNREF_RETAIL_PARAM(pwszHeaders),
                                                                DWORD        UNREF_PARAM(dwStatusCode),
                                                                LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                                LPWSTR       UNREF_PARAM(pwszContentType),
                                                                DWORD        UNREF_PARAM(cbSent),
                                                                LPBYTE       pbResponse,
                                                                DWORD        cbResponse,
                                                                BOOL         fFind) // find: true, patch: false
{
    // locals
    HRESULT         hres = S_OK;
    LPWSTR          pwszTagName = NULL;
    LONG            cResponses;
    WCHAR           wszDavPrefix[100]; // how long can a namespace name be?
    CQXML           qxml;
    CQXML*          pqxml = NULL;
    CQXML*          pqxml2 = NULL;
    CQXMLEnum*      pqxmlEnum = NULL;
    CQXMLEnum*      pqxmlEnum2 = NULL;

    // check params
    assert(pdavResponse != NULL);
    assert(pwszVerb != NULL);
    assert(pwszPath != NULL);
    if (cbResponse > 0)
    {
        assert(pbResponse != NULL);
    }
    if (cchHeaders > 0)
    {
        assert(pwszHeaders != NULL);
    }
    assert(pbResponse != NULL);

    // code
    if (fFind)
    {
        pdavResponse->command = DAV_PROPFIND;
    }
    else
    {
        pdavResponse->command = DAV_PROPPATCH;
    }

    if (SUCCEEDED(pdavResponse->hrResult))
    {
        hres = this->_InitQXMLFromMessyBuffer(&qxml, (LPSTR)pbResponse, wszDavPrefix);

        if (SUCCEEDED(hres))
        {
            pwszTagName = _XMLNSExtend ( wszDavPrefix, L"response");
            if (pwszTagName == NULL)
            {
                hres = E_OUTOFMEMORY;
            }
            else
            {
                hres = qxml.GetQXMLEnum(NULL, pwszTagName, &pqxmlEnum);
                if (SUCCEEDED(hres) && hres != S_FALSE)
                {
                    hres = pqxmlEnum->GetCount(&cResponses);
                    if (SUCCEEDED(hres) && hres != S_FALSE)
                    {
                        // iterate over all the responses returned by the server
                        for (LONG i = 0; i < cResponses; i++)
                        {
                            hres = pqxmlEnum->NextQXML(&pqxml);
                            if (FAILED(hres) || hres == S_FALSE)
                            {
                                break;
                            }
                            else
                            {
                                // get the href of each item found
                                pdavResponse->rPropFind.pwszHref = this->_GetHREF(pqxml, wszDavPrefix);
                                if (pdavResponse->rPropFind.pwszHref != NULL)
                                {
                                    if (fFind)
                                    {
                                        hres = this->_RespondHandlePROPFINDHelper(pdavResponse, pwszPath, wszDavPrefix, pqxml);
                                    }
                                    else
                                    {
                                        hres = this->_RespondHandlePROPPATCHHelper(pdavResponse, pwszPath, wszDavPrefix, pqxml);
                                    }
                                }
                                delete pqxml;
                                pqxml = NULL;
                            }
                        }
                    }
                    delete pqxmlEnum;
                }
                        
            }
        }        
    }
    
    // release stuff
    if (pwszTagName != NULL)
    {
        free(pwszTagName);
    }

    return hres;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePROPFIND(DAVRESPONSE* pdavResponse,
                                                           LPWSTR       pwszVerb,
                                                           LPWSTR       pwszPath,
                                                           DWORD        cchHeaders,
                                                           LPWSTR       pwszHeaders,
                                                           DWORD        dwStatusCode,
                                                           LPWSTR       pwszStatusCode,
                                                           LPWSTR       pwszContentType,
                                                           DWORD        cbSent,
                                                           LPBYTE       pbResponse,
                                                           DWORD        cbResponse)
{
    return this->_RespondHandlePROPFINDPATCH(pdavResponse,
                                             pwszVerb,
                                             pwszPath,
                                             cchHeaders,
                                             pwszHeaders,
                                             dwStatusCode,
                                             pwszStatusCode,
                                             pwszContentType,
                                             cbSent,
                                             pbResponse,
                                             cbResponse,
                                             TRUE); // PROPFIND version
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePROPPATCH(DAVRESPONSE* pdavResponse,
                                                            LPWSTR       pwszVerb,
                                                            LPWSTR       pwszPath,
                                                            DWORD        cchHeaders,
                                                            LPWSTR       pwszHeaders,
                                                            DWORD        dwStatusCode,
                                                            LPWSTR       pwszStatusCode,
                                                            LPWSTR       pwszContentType,
                                                            DWORD        cbSent,
                                                            LPBYTE       pbResponse,
                                                            DWORD        cbResponse)
{
    return this->_RespondHandlePROPFINDPATCH(pdavResponse,
                                             pwszVerb,
                                             pwszPath,
                                             cchHeaders,
                                             pwszHeaders,
                                             dwStatusCode,
                                             pwszStatusCode,
                                             pwszContentType,
                                             cbSent,
                                             pbResponse,
                                             cbResponse,
                                             FALSE); // PROPPATCH version
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\timeconv.cpp ===
// --------------------------------------------------------------------------------
// timeconv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>
#include <assert.h>

#include "timeconv.h"
#include "strutil.h"
#include "mischlpr.h"

HRESULT _ConvertTime_3Month(LPWSTR pTime, WORD* pwMonth)
{
    HRESULT hres = S_OK;

    if (LStrCmpNI(pTime, L"jan", 3) == 0)
    {
        *pwMonth = 1;
    }
    else if (LStrCmpNI(pTime, L"feb", 3) == 0)
    {
        *pwMonth = 2;
    }
    else if (LStrCmpNI(pTime, L"mar", 3) == 0)
    {
        *pwMonth = 3;
    }
    else if (LStrCmpNI(pTime, L"apr", 3) == 0)
    {
        *pwMonth = 4;
    }
    else if (LStrCmpNI(pTime, L"may", 3) == 0)
    {
        *pwMonth = 5;
    }
    else if (LStrCmpNI(pTime, L"jun", 3) == 0)
    {
        *pwMonth = 6;
    }
    else if (LStrCmpNI(pTime, L"jul", 3) == 0)
    {
        *pwMonth = 7;
    }
    else if (LStrCmpNI(pTime, L"aug", 3) == 0)
    {
        *pwMonth = 8;
    }
    else if (LStrCmpNI(pTime, L"sep", 3) == 0)
    {
        *pwMonth = 9;
    }
    else if (LStrCmpNI(pTime, L"oct", 3) == 0)
    {
        *pwMonth = 10;
    }
    else if (LStrCmpNI(pTime, L"nov", 3) == 0)
    {
        *pwMonth = 11;
    }
    else if (LStrCmpNI(pTime, L"dec", 3) == 0)
    {
        *pwMonth = 12;
    }
    else 
    {
        hres = E_FAIL;
    }
    
    return hres;
}

HRESULT _ConvertTime_FullMonth(LPWSTR pTime, WORD* pwMonth, UINT* pcchUsed)
{
    HRESULT hres = S_OK;

    if (LStrCmpNI(pTime, L"january", 7) == 0)
    {
        *pwMonth = 1;
        *pcchUsed = 7;
    }
    else if (LStrCmpNI(pTime, L"february", 8) == 0)
    {
        *pwMonth = 2;
        *pcchUsed = 8;
    }
    else if (LStrCmpNI(pTime, L"march", 5) == 0)
    {
        *pwMonth = 3;
        *pcchUsed = 5;
    }
    else if (LStrCmpNI(pTime, L"april", 5) == 0)
    {
        *pwMonth = 4;
        *pcchUsed = 5;
    }
    else if (LStrCmpNI(pTime, L"may", 3) == 0)
    {
        *pwMonth = 5;
        *pcchUsed = 3;
    }
    else if (LStrCmpNI(pTime, L"june", 4) == 0)
    {
        *pwMonth = 6;
        *pcchUsed = 4;
    }
    else if (LStrCmpNI(pTime, L"july", 4) == 0)
    {
        *pwMonth = 7;
        *pcchUsed = 4;
    }
    else if (LStrCmpNI(pTime, L"august", 6) == 0)
    {
        *pwMonth = 8;
        *pcchUsed = 6;
    }
    else if (LStrCmpNI(pTime, L"september", 9) == 0)
    {
        *pwMonth = 9;
        *pcchUsed = 9;
    }
    else if (LStrCmpNI(pTime, L"october", 7) == 0)
    {
        *pwMonth = 10;
        *pcchUsed = 7;
    }
    else if (LStrCmpNI(pTime, L"november", 8) == 0)
    {
        *pwMonth = 11;
        *pcchUsed = 8;
    }
    else if (LStrCmpNI(pTime, L"december", 8) == 0)
    {
        *pwMonth = 12;
        *pcchUsed = 8;
    }
    else 
    {
        hres = E_FAIL;
    }
    
    return hres;
}

HRESULT _ProcessToken(WCHAR chTokenType, LPWSTR pTime, SYSTEMTIME* psystime, USHORT* puAMPM,
                      BOOL* pfYearFound, BOOL* pfMonthFound, BOOL* pfDayFound,
                      BOOL* pfAMPMFound, BOOL* pfHourFound, BOOL* pfMinFound,
                      BOOL* pfSecFound, BOOL* pfMSecFound,
                      UINT* pcchUsed)
{
    HRESULT hres = S_OK;
    INT iRead;

    switch (chTokenType)
    {
    case 'Y': // 4 digit year
        if (*pfYearFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfYearFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wYear = (WORD)iRead;
                if (psystime->wYear < 1000 || psystime->wYear > 9999)
                {
                    // not four digits!
                    hres = E_FAIL;
                }
                else
                {
                    *pcchUsed = 4;
                }
            }
        }
        break;
    case 'y': // 2 digit year
        if (*pfYearFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfYearFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wYear = (WORD)iRead;
                if (psystime->wYear > 99 || (psystime->wYear < 10 && (*pTime != '0')))
                {
                    // not 2 digits!
                    hres = E_FAIL;
                }
                else 
                {
                    *pcchUsed = 2;
                    // if succeeded, need to extend to be 4-digit
                    if (psystime->wYear > 30) // BUGBUG: where is cutoff?  is "30" really 1930 or 2030?
                    {
                        psystime->wYear += 1900;
                    }
                    else
                    {
                        psystime->wYear += 2000;
                    }
                }
            }
        }
        break;
    case 'm': // numerical month
        if (*pfMonthFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfMonthFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wMonth = (WORD)iRead;
                if (psystime->wMonth < 10)
                {
                    *pcchUsed = 1;
                }
                else
                {
                    *pcchUsed = 2;
                }
            }
        }
        break;
    case 'M': // three letter text month
        if (*pfMonthFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfMonthFound = TRUE;
            hres = _ConvertTime_3Month(pTime, &(psystime->wMonth));
            if (SUCCEEDED(hres))
            {
                *pcchUsed = 3;
            }
        }
        break;
    case 'W': // full length name text month
        if (*pfMonthFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfMonthFound = TRUE;
            hres = _ConvertTime_FullMonth(pTime, &(psystime->wMonth), pcchUsed);
        }
        break;
    case 'D': // numerical day of the month
        if (*pfDayFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfDayFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wDay = (WORD)iRead;
                if (psystime->wDay < 1 || psystime->wDay > 31)
                {
                    // not valid
                    hres = E_FAIL;
                }
                else
                {
                    if (psystime->wDay < 10 && ((*pTime) != '0'))
                    {
                        *pcchUsed = 1;
                    }
                    else
                    {
                        *pcchUsed = 2;
                    }
                }
            }
        }
        break;
    case 'P': // AM or PM, two letter
        if (*pfAMPMFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfAMPMFound = TRUE;
            if (LStrCmpNI(pTime, L"AM", 2) == 0)
            {
                *puAMPM = 1;
                *pcchUsed = 2;
            }
            else if (LStrCmpNI(pTime, L"PM", 2) == 0)
            {
                *puAMPM = 2;
                *pcchUsed = 2;
            }
            else
            {
                hres = E_FAIL;
            }
        }
        break;
    case 'p': // am or pm, one letter
        if (*pfAMPMFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfAMPMFound = TRUE;
            if (*pTime == 'A' || *pTime == 'a')
            {
                *puAMPM = 1;
                *pcchUsed = 1;
            }
            else if (*pTime == 'P' || *pTime == 'p')
            {
                *puAMPM = 2;
                *pcchUsed = 1;
            }
            else
            {
                hres = E_FAIL;
            }
        }
        break;
    case 'H': // numerical hour, military (24 hour)
        if (*pfAMPMFound || *pfHourFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfAMPMFound = TRUE;
            *pfHourFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wHour = (WORD)iRead;

                if (psystime->wHour > 9 || *pTime == '0')
                {
                    *pcchUsed = 2;
                }
                else
                {
                    *pcchUsed = 1;
                }

                if (psystime->wHour > 11)
                {
                    *puAMPM = 2;
                    psystime->wHour -= 12;
                }
                else
                {
                    *puAMPM = 1;
                }
            }
        }
        break;
    case 'h': // numerical hour, standard (12 hour)
        if (*pfHourFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfHourFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wHour = (WORD)iRead;
                if ((psystime->wHour > 9) || *pTime == '0')
                {
                    *pcchUsed = 2;
                }
                else
                {
                    *pcchUsed = 1;
                }
            }
        }
        break;
    case 'N': // numerical minute
        if (*pfMinFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfMinFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wMinute = (unsigned short)iRead;
                if (psystime->wMinute > 59)
                {
                    // not valid
                    hres = E_FAIL;
                }
                else
                {
                    if ((psystime->wMinute > 9) || *pTime == '0')
                    {
                        *pcchUsed = 2;
                    }
                    else
                    {
                        *pcchUsed = 1;
                    }
                }
            }
        }
        break;
    case 'S': // numerical second
        if (*pfSecFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfSecFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wSecond = (WORD)iRead;

                if (psystime->wSecond > 59)
                {
                    // not valid
                    hres = E_FAIL;
                }
                else
                {
                    if ((psystime->wSecond > 9) || *pTime == '0')
                    {
                        *pcchUsed = 2;
                    }
                    else
                    {
                        *pcchUsed = 1;
                    }
                }
            }
        }
        break;
    case 's': // numerical milliseconds
        if (*pfMSecFound)
        {
            hres = E_FAIL;
        }
        else
        {
            *pfMSecFound = TRUE;
            if (swscanf(pTime, L"%d", &iRead) != 1)
            {
                hres = E_FAIL;
            }
            else
            {
                psystime->wMilliseconds = (WORD)iRead;
                if (psystime->wMilliseconds > 1000)
                {
                    // not valid
                    hres = E_FAIL;
                }
                else
                {
                    if ((psystime->wSecond > 99) || (*pTime == '0' && psystime->wSecond > 9) || (*pTime == '0' && *(pTime+1) == '0'))
                    {
                        *pcchUsed = 3;
                    }
                    else if ((psystime->wSecond > 9) || (*pTime == '0'))
                    {
                        *pcchUsed = 2;
                    }
                    else
                    {
                        *pcchUsed = 1;
                    }
                }
            }
        }
        break;
    case 'Z': // time zone, format A ????
        break;
    case 'z': // time zone, format B ????
        break;
    case 'i': // ignore one char
        *pcchUsed = 1;
        break;
    case 'I': // ignore a string
        LPWSTR pwszTemp;
        pwszTemp = AllocateStringW(lstrlen(pTime));
        if (pwszTemp == NULL)
        {
            hres = E_OUTOFMEMORY;
        } 
        else if (swscanf(pTime, L"%s", pwszTemp) != 1)
        {
            hres = E_FAIL;
        }
        else
        {
            *pcchUsed = lstrlen(pwszTemp);
            free(pwszTemp);
        }        
        break;
    case 'X': // ignore the rest of the string
        *pcchUsed = lstrlen(pTime);
        break;
    default: // error
        hres = E_FAIL;
    }

    return hres;
}

HRESULT ConvertTime(LPWSTR pwszFormat, LPWSTR pwszTime, FILETIME* pftime)
{
    HRESULT hres = S_OK;

    WCHAR* pFormat = pwszFormat; // pointer to advance along the pwszFormat string
    WCHAR* pTime = pwszTime; // pointer to advance along the pwszTime string
    BOOL fDone = FALSE;
    WCHAR chTokenType;
    SYSTEMTIME systime = {0};
    USHORT uAMPM = 0;

    BOOL fYearFound = FALSE;
    BOOL fMonthFound = FALSE;
    BOOL fDayFound = FALSE;
    BOOL fAMPMFound = FALSE;
    BOOL fHourFound = FALSE;
    BOOL fMinFound = FALSE;
    BOOL fSecFound = FALSE;
    BOOL fMSecFound = FALSE;

    UINT cchUsed;

    while (!fDone)
    {
        if (*pFormat == NULL)
        {
            fDone = TRUE;
        }
        else
        {
            if (*pFormat != '%')
            {
                if (*pFormat == *pTime)
                {
                    pFormat++;
                    pTime++;                
                }
                else
                {
                    hres = E_FAIL; // strings are different
                }
            }
            else
            {
                // we hit a magic token
                chTokenType = *(pFormat+1);
                pFormat+=2;
                hres = _ProcessToken(chTokenType, pTime, &systime, &uAMPM,
                                     &fYearFound, &fMonthFound, &fDayFound,
                                     &fAMPMFound, &fHourFound, &fMinFound,
                                     &fSecFound, &fMSecFound, &cchUsed);

                if (SUCCEEDED(hres))
                {
                    pTime += cchUsed;
                }
            }

            if (FAILED(hres))
            {
                fDone = TRUE;
            }
        }
    }

    if (SUCCEEDED(hres))
    {
        if (fAMPMFound && uAMPM==2)
        {
            // pm
            systime.wHour += 12;
        }

        if (!SystemTimeToFileTime(&systime, pftime))
        {
            hres = E_FAIL;
        }
    }
                
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\acallsmp.cpp ===
// acallsmp.cpp
//
// simple response handlers (everything except PROPFIND and PROPPATCH)

#include <assert.h>
#include "asynccall.h"
#include "qxml.h"
#include "strutil.h"
#include "regexp.h"
#include "mischlpr.h"

///////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleGET(DAVRESPONSE* pdavResponse,
                                                      LPWSTR       UNREF_PARAM(pwszVerb),
                                                      LPWSTR       UNREF_PARAM(pwszPath),
                                                      DWORD        UNREF_PARAM(cchHeaders),
                                                      LPWSTR       UNREF_PARAM(pwszHeaders),
                                                      DWORD        UNREF_PARAM(dwStatusCode),
                                                      LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                      LPWSTR       pwszContentType,
                                                      DWORD        UNREF_PARAM(cbSent),
                                                      LPBYTE       pbResponse,
                                                      DWORD        cbResponse)
{
    HRESULT hres = S_OK;

    pdavResponse->command = DAV_GET;

    // parse the response as if it were a DAV GET command
    if (SUCCEEDED(pdavResponse->hrResult))
    {
        pdavResponse->rGet.fTotalKnown = TRUE;
        pdavResponse->rGet.cbIncrement = 0;
        pdavResponse->rGet.cbCurrent = cbResponse;
        pdavResponse->rGet.cbTotal = cbResponse;
        pdavResponse->rGet.pvBody = pbResponse;
        pdavResponse->rGet.pwszContentType = pwszContentType;
    }

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleHEAD(DAVRESPONSE* pdavResponse,
                                                       LPWSTR       UNREF_PARAM(pwszVerb),
                                                       LPWSTR       UNREF_PARAM(pwszPath),
                                                       DWORD        cchHeaders,
                                                       LPWSTR       pwszHeaders,
                                                       DWORD        UNREF_PARAM(dwStatusCode),
                                                       LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                       LPWSTR       UNREF_PARAM(pwszContentType),
                                                       DWORD        UNREF_PARAM(cbSent),
                                                       LPBYTE       UNREF_PARAM(pbResponse),
                                                       DWORD        UNREF_PARAM(cbResponse))
{   
    HRESULT hres = S_OK;

    pdavResponse->command = DAV_HEAD;

    // parse the response as if it were a DAV HEAD command
    pdavResponse->command = DAV_HEAD;
    pdavResponse->rHead.cchRawHeaders = cchHeaders;
    pdavResponse->rHead.pwszRawHeaders = pwszHeaders;


    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

void AddVerbToVector (DWORD* pdw,
                      LPWSTR pwszText,
                      UINT   cch)
{
    if (LStrCmpN(pwszText, L"GET", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_GET;
    }
    else if (LStrCmpN(pwszText, L"HEAD", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_HEAD;
    }
    else if (LStrCmpN(pwszText, L"OPTIONS", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_OPTIONS;
    }
    else if (LStrCmpN(pwszText, L"PUT", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_PUT;
    }
    else if (LStrCmpN(pwszText, L"POST", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_POST;
    }
    else if (LStrCmpN(pwszText, L"DELETE", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_DELETE;
    }
    else if (LStrCmpN(pwszText, L"MKCOL", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_MKCOL;
    }
    else if (LStrCmpN(pwszText, L"COPY", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_COPY;
    }
    else if (LStrCmpN(pwszText, L"MOVE", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_MOVE;
    }
    else if (LStrCmpN(pwszText, L"PROPFIND", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_PROPFIND;
    }
    else if (LStrCmpN(pwszText, L"PROPPATCH", cch) == 0)
    {
        *pdw = *pdw | DAVOPTIONS_DAVVERB_PROPPATCH;
    }

}


void CAsyncWntCallbackImpl::_ParseDAVVerbs (LPWSTR pwsz,
											DWORD* pdw)
{
    LPWSTR pwszTemp = pwsz;
    LPWSTR pwszTemp2;
    LPWSTR pwszDavMethodsSupported = NULL;

    pwszTemp2 = LStrStr(pwszTemp, L"\n");
    if (pwszTemp2 != NULL)
    {
        assert((pwszTemp2 - pwszTemp) > 0);
        pwszDavMethodsSupported = AllocateStringW(pwszTemp2 - pwszTemp);
        lstrcpyn(pwszDavMethodsSupported, pwszTemp, pwszTemp2 - pwszTemp);
        
        pwszTemp = pwszDavMethodsSupported;
        pwszTemp2 = pwszDavMethodsSupported;
        while (*pwszTemp != NULL)
        {
            if ((*pwszTemp2)==',')
            {
                AddVerbToVector(pdw, pwszTemp, pwszTemp2 - pwszTemp);
                
                pwszTemp=pwszTemp2;
                while (*pwszTemp == ' ' || *pwszTemp == ',')
                {
                    pwszTemp++;
                }
                pwszTemp2 = pwszTemp;
            }
            else if ((*pwszTemp2) == NULL)
            {
                AddVerbToVector(pdw, pwszTemp, pwszTemp2 - pwszTemp - 1);
                pwszTemp=pwszTemp2;
            }
            else
            {
                pwszTemp2++;
            }
            
        }
        
    }

    if (pwszDavMethodsSupported != NULL)
    {
        free(pwszDavMethodsSupported);
    }
}

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleOPTIONS(DAVRESPONSE* pdavResponse,
                                                          LPWSTR       UNREF_PARAM(pwszVerb),
                                                          LPWSTR       UNREF_PARAM(pwszPath),
                                                          DWORD        cchHeaders,
                                                          LPWSTR       pwszHeaders,
                                                          DWORD        UNREF_PARAM(dwStatusCode),
                                                          LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                          LPWSTR       UNREF_PARAM(pwszContentType),
                                                          DWORD        UNREF_PARAM(cbSent),
                                                          LPBYTE       UNREF_PARAM(pbResponse),
                                                          DWORD        UNREF_PARAM(cbResponse))
{
    HRESULT hres = S_OK;
    LPWSTR pwszTemp;
    LPWSTR pwszTemp2;
    WCHAR wszDavSupported[10];

    // parse the response as if it were a DAV OPTIONS command
    pdavResponse->command = DAV_OPTIONS;

    pdavResponse->rOptions.cchRawHeaders = cchHeaders;
    pdavResponse->rOptions.pwszRawHeaders = pwszHeaders;

    // determine support for DAV: 1, 2, both, or none at all
    pdavResponse->rOptions.bDavSupport = 0;

    pwszTemp = LStrStrI(pwszHeaders, L"DAV: ");
    if (pwszTemp != NULL) 
    {
        pwszTemp += 5;
        pwszTemp2 = LStrStr(pwszTemp, L"\n");
        if (pwszTemp2 != NULL)
        {
            if ((pwszTemp2 - pwszTemp) < 20)
            {
                lstrcpyn(wszDavSupported, pwszTemp, pwszTemp2 - pwszTemp);

                // now we have a string of the format "1, 2" or "1" or "2" or something.
                // WARNING: this assumes can only be single digit

                if (LStrStr(wszDavSupported, L"1") != NULL)
                {
                    pdavResponse->rOptions.bDavSupport = (BYTE)(pdavResponse->rOptions.bDavSupport | DAVOPTIONS_DAVSUPPORT_1);
                }

                if (LStrStr(wszDavSupported, L"2") != NULL)
                {
                    pdavResponse->rOptions.bDavSupport = (BYTE)(pdavResponse->rOptions.bDavSupport | DAVOPTIONS_DAVSUPPORT_2);
                }

            }
        }
    }

    // determine support for each DAV method for this URL
    pdavResponse->rOptions.dwDavMethodsAllow = 0;

    pwszTemp = LStrStr(pwszHeaders, L"Allow: ");
    if (pwszTemp == NULL)
    {
        pwszTemp = LStrStr(pwszHeaders, L"ALLOW: ");
    }

    if (pwszTemp != NULL) 
    {
        pwszTemp += 7;
        this->_ParseDAVVerbs(pwszTemp, &pdavResponse->rOptions.dwDavMethodsAllow);
    }

    // determine support for each DAV method for the server entire
    pdavResponse->rOptions.dwDavMethodsPublic = 0;

    pwszTemp = LStrStr(pwszHeaders, L"Public: ");
    if (pwszTemp == NULL)
    {
        pwszTemp = LStrStr(pwszHeaders, L"PUBLIC: ");
    }

    if (pwszTemp != NULL) 
    {
        pwszTemp += 8;
        this->_ParseDAVVerbs(pwszTemp, &pdavResponse->rOptions.dwDavMethodsPublic);
    }   

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePUTPOST(DAVRESPONSE* pdavResponse,
                                                          LPWSTR       UNREF_PARAM(pwszVerb),
                                                          LPWSTR       pwszPath,
                                                          DWORD        UNREF_PARAM(cchHeaders),
                                                          LPWSTR       UNREF_PARAM(pwszHeaders),
                                                          DWORD        UNREF_PARAM(dwStatusCode),
                                                          LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                          LPWSTR       UNREF_PARAM(pwszContentType),
                                                          DWORD        cbSent,
                                                          LPBYTE       UNREF_PARAM(pbResponse),
                                                          DWORD        UNREF_PARAM(cbResponse))
{   
    HRESULT hres = S_OK;

    pdavResponse->rPut.pwszLocation = pwszPath;
    pdavResponse->rPost.fResend = FALSE;
    pdavResponse->rPost.cbIncrement = 0;

    if (SUCCEEDED(pdavResponse->hrResult))
    {
        // we PUT ok, so return data about it
        pdavResponse->rPut.cbCurrent = cbSent;
        pdavResponse->rPut.cbTotal = cbSent;
    }
    else
    {
        // we failed to PUT, so say so
        pdavResponse->rPost.cbCurrent = 0;
        pdavResponse->rPost.cbTotal = 0;        
    }

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePUT(DAVRESPONSE* pdavResponse,
                                                              LPWSTR       pwszVerb,
                                                              LPWSTR       pwszPath,
                                                              DWORD        cchHeaders,
                                                              LPWSTR       pwszHeaders,
                                                              DWORD        dwStatusCode,
                                                              LPWSTR       pwszStatusCode,
                                                              LPWSTR       pwszContentType,
                                                              DWORD        cbSent,
                                                              LPBYTE       pbResponse,
                                                              DWORD        cbResponse)
{   
    pdavResponse->command = DAV_PUT;

    return this->_RespondHandlePUTPOST(pdavResponse,
                                       pwszVerb,
                                       pwszPath,
                                       cchHeaders,
                                       pwszHeaders,
                                       dwStatusCode,
                                       pwszStatusCode,
                                       pwszContentType,
                                       cbSent,
                                       pbResponse,
                                       cbResponse);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandlePOST(DAVRESPONSE* pdavResponse,
                                                       LPWSTR       pwszVerb,
                                                       LPWSTR       pwszPath,
                                                       DWORD        cchHeaders,
                                                       LPWSTR       pwszHeaders,
                                                       DWORD        dwStatusCode,
                                                       LPWSTR       pwszStatusCode,
                                                       LPWSTR       pwszContentType,
                                                       DWORD        cbSent,
                                                       LPBYTE       pbResponse,
                                                       DWORD        cbResponse)
{   
    pdavResponse->command = DAV_POST;

    return this->_RespondHandlePUTPOST(pdavResponse,
                                       pwszVerb,
                                       pwszPath,
                                       cchHeaders,
                                       pwszHeaders,
                                       dwStatusCode,
                                       pwszStatusCode,
                                       pwszContentType,
                                       cbSent,
                                       pbResponse,
                                       cbResponse);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleDELETE(DAVRESPONSE* pdavResponse,
                                                         LPWSTR       UNREF_PARAM(pwszVerb),
                                                         LPWSTR       UNREF_PARAM(pwszPath),
                                                         DWORD        UNREF_PARAM(cchHeaders),
                                                         LPWSTR       UNREF_PARAM(pwszHeaders),
                                                         DWORD        UNREF_PARAM(dwStatusCode),
                                                         LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                         LPWSTR       UNREF_PARAM(pwszContentType),
                                                         DWORD        UNREF_PARAM(cbSent),
                                                         LPBYTE       UNREF_PARAM(pbResponse),
                                                         DWORD        UNREF_PARAM(cbResponse))
{   
    HRESULT hres = S_OK;

    pdavResponse->command = DAV_DELETE;

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleMKCOL(DAVRESPONSE* pdavResponse,
                                                        LPWSTR       UNREF_PARAM(pwszVerb),
                                                        LPWSTR       UNREF_PARAM(pwszPath),
                                                        DWORD        UNREF_PARAM(cchHeaders),
                                                        LPWSTR       UNREF_PARAM(pwszHeaders),
                                                        DWORD        UNREF_PARAM(dwStatusCode),
                                                        LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                        LPWSTR       UNREF_PARAM(pwszContentType),
                                                        DWORD        UNREF_PARAM(cbSent),
                                                        LPBYTE       UNREF_PARAM(pbResponse),
                                                        DWORD        UNREF_PARAM(cbResponse))
{   
    HRESULT hres = S_OK;

    pdavResponse->command = DAV_MKCOL;

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleCOPY(DAVRESPONSE* pdavResponse,
                                                       LPWSTR       UNREF_PARAM(pwszVerb),
                                                       LPWSTR       UNREF_PARAM(pwszPath),
                                                       DWORD        UNREF_PARAM(cchHeaders),
                                                       LPWSTR       UNREF_PARAM(pwszHeaders),
                                                       DWORD        UNREF_PARAM(dwStatusCode),
                                                       LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                       LPWSTR       UNREF_PARAM(pwszContentType),
                                                       DWORD        UNREF_PARAM(cbSent),
                                                       LPBYTE       UNREF_PARAM(pbResponse),
                                                       DWORD        UNREF_PARAM(cbResponse))
{   
    HRESULT hres = S_OK;

    pdavResponse->command = DAV_COPY;

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::_RespondHandleMOVE(DAVRESPONSE* pdavResponse,
                                                       LPWSTR       UNREF_PARAM(pwszVerb),
                                                       LPWSTR       UNREF_PARAM(pwszPath),
                                                       DWORD        UNREF_PARAM(cchHeaders),
                                                       LPWSTR       UNREF_PARAM(pwszHeaders),
                                                       DWORD        UNREF_PARAM(dwStatusCode),
                                                       LPWSTR       UNREF_PARAM(pwszStatusCode),
                                                       LPWSTR       UNREF_PARAM(pwszContentType),
                                                       DWORD        UNREF_PARAM(cbSent),
                                                       LPBYTE       UNREF_PARAM(pbResponse),
                                                       DWORD        UNREF_PARAM(cbResponse))
{   
    HRESULT hres = S_OK;

    pdavResponse->command = DAV_MOVE;

    hres = _pcallback->OnResponse(pdavResponse);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\common\src\strutil.cpp ===
#include <objbase.h>
#include "strutil.h"

// --------------------------------------------------------------------------
// AllocateStringA
// --------------------------------------------------------------------------
LPSTR AllocateStringA(DWORD cch)
{
    // Allocate It
    return((LPSTR)malloc((cch + 1) * sizeof(CHAR)));
}

// --------------------------------------------------------------------------
// AllocateStringW
// --------------------------------------------------------------------------
LPWSTR AllocateStringW(DWORD cch)
{
    // Allocate It
    return((LPWSTR)malloc((cch + 1) * sizeof(WCHAR)));
}

// --------------------------------------------------------------------------
// DuplicateStringA
// --------------------------------------------------------------------------
LPSTR DuplicateStringA(LPCSTR psz)
{
    DWORD   cch;
    LPSTR   pszT = NULL;

    if (psz != NULL)
    {
        cch = lstrlenA(psz);

        if (cch > 0)
        {
            pszT = AllocateStringA(cch);
            if (pszT != NULL)
            {
                memcpy(pszT, psz, (cch + 1) * sizeof(CHAR));
            }
        }
    }

    return pszT;
}

// --------------------------------------------------------------------------
// DuplicateStringW
// --------------------------------------------------------------------------
LPWSTR DuplicateStringW(LPCWSTR pwsz)
{
    DWORD   cch;
    LPWSTR   pwszT = NULL;

    if (pwsz != NULL)
    {
        cch = lstrlenW(pwsz);

        if (cch > 0)
        {
            pwszT = AllocateStringW(cch);
            if (pwszT != NULL)
            {
                memcpy(pwszT, pwsz, (cch + 1) * sizeof(WCHAR));
            }
        }
    }

    return pwszT;
}

// --------------------------------------------------------------------------
// ConvertToUnicode
// --------------------------------------------------------------------------
LPWSTR ConvertToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    pwszDup = AllocateStringW(cchWide);
    if (NULL == pwszDup)
    {
        goto exit;
    }

    // Do the actual translation
	cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        if (NULL != pwszDup)
        {
            free(pwszDup);
        }
        goto exit;
    }

exit:
    // Done
    return pwszDup;
}

// --------------------------------------------------------------------------
// ConvertToANSI
// --------------------------------------------------------------------------
LPSTR ConvertToANSI(UINT cp, LPCWSTR pcwszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPSTR       pszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Length
    cchWide = lstrlenW(pcwszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, NULL, 0, NULL, NULL);

    // Error
    if (cchNarrow == 0)
        goto exit;

    // Alloc temp buffer
    pszDup = AllocateStringA(cchNarrow + 1);
    if (NULL == pszDup)
    {
        goto exit;
    }

    // Do the actual translation
	cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, pszDup, cchNarrow + 1, NULL, NULL);

    // Error
    if (cchNarrow == 0)
    {
        if (NULL != pszDup)
        {
            free(pszDup);
        }
        goto exit;
    }

exit:
    // Done
    return(pszDup);
}

// --------------------------------------------------------------------------
// _LStrCmpN
// --------------------------------------------------------------------------
INT _LStrCmpN(LPWSTR pwszLeft, LPWSTR pwszRight, UINT n, BOOL fCaseInsensitive)
{
    INT iResult = 0; // BUGBUG: better error code?
    WCHAR chLeft, chRight;

    if (pwszLeft == NULL || pwszRight == NULL)
    {
        iResult = -1;
    }
    else
    {
        // iterate over n characters, if we drop out without changing iResult then
        //  the two strings are equal, since iResult begins at 0, meaning equal
        for (UINT i = 0; i < n; i++)
        {
            if (fCaseInsensitive)
            {                
                chLeft = (unsigned short)toupper(pwszLeft[i]);
                chRight = (unsigned short)toupper(pwszRight[i]);
            }
            else
            {
                chLeft = pwszLeft[i];
                chRight = pwszRight[i];
            }

            if (chLeft != chRight)
            {
                if (chLeft > chRight)
                {
                    iResult = 1;
                    break;
                }
                else
                {
                    iResult = -1;
                    break;
                }
            }
            else
            {
                if (pwszLeft[i] == NULL) // and hence pwszRight[i] == NULL
                {
                    // both strings are identical, we can stop and return 0
                    break;
                }
            }
        }
    }

    return iResult;
}

// --------------------------------------------------------------------------
// LStrCmpN
// --------------------------------------------------------------------------
INT LStrCmpN(LPWSTR pwszLeft, LPWSTR pwszRight, UINT n)
{
    return _LStrCmpN(pwszLeft, pwszRight, n, FALSE);
}

// --------------------------------------------------------------------------
// LStrCmpNI
// --------------------------------------------------------------------------
INT LStrCmpNI(LPWSTR pwszLeft, LPWSTR pwszRight, UINT n)
{
    return _LStrCmpN(pwszLeft, pwszRight, n, TRUE);
}

// --------------------------------------------------------------------------
// _LStrStr
// --------------------------------------------------------------------------
LPWSTR _LStrStr(LPWSTR pwszString, LPWSTR pwszSought, BOOL fCaseSensitive)
{
    LPWSTR pwszReturnVal = NULL;
    INT i;
    INT j;
    INT cchString;
    INT cchSought;
    
    // BUGBUG: this code is untested
    if (pwszString != NULL && pwszSought != NULL)
    {
        cchString = lstrlen(pwszString);
        cchSought = lstrlen(pwszSought);

        for (i = 0; i <= cchString - cchSought; i++) // check all possible starting points, can't start within cchSought of end
        {
            for (j = 0; j < cchSought; j++) // check all characters of this possible string
            {
                if (fCaseSensitive)
                {
                    // case sensitive
                    if (pwszString[i+j] != pwszSought[j]) // if they're ever different, then we're done
                    {
                        break;
                    }
                }
                else
                {
                    // not case sensitive
                    if (towupper(pwszString[i+j]) != towupper(pwszSought[j])) // if they're ever different, then we're done
                    {
                        break;
                    }
                }
            }

            if (j == cchSought) // we dropped out of the loop because we matched all the characters, not because we 
            {
                pwszReturnVal = pwszString + i;
                break;
            }
        }
    }

    return pwszReturnVal;
}

// --------------------------------------------------------------------------
// LStrStr
// --------------------------------------------------------------------------
LPWSTR LStrStr(LPWSTR pwszString, LPWSTR pwszSought)
{
    return _LStrStr(pwszString, pwszSought, TRUE);
}

// --------------------------------------------------------------------------
// LStrStrI
// --------------------------------------------------------------------------
LPWSTR LStrStrI(LPWSTR pwszString, LPWSTR pwszSought)
{
    return _LStrStr(pwszString, pwszSought, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\asynccall.cpp ===
#include <assert.h>
#include "asynccall.h"
#include "qxml.h"
#include "strutil.h"
#include "regexp.h"

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CAsyncWntCallbackImpl::Init (IDavCallback*   pcallback,
                                          DWORD           dwParam,
                                          LPWSTR          pwszUserName,
                                          LPWSTR          pwszPassword,
                                          BOOL            fNoRoot)
{
    HRESULT hres = S_OK;
    _pcallback = pcallback;
    _dwParam = dwParam;

    // if we have a password, must have a username
    if (pwszUserName == NULL && pwszPassword != NULL)
    {
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres))
    {
        _fNoRoot = fNoRoot;
        if (pwszUserName)
        {
            lstrcpyn(_wszUserName, pwszUserName, 255);
        }
        else
        {
            *_wszUserName = NULL;
        }
        if (pwszPassword)
        {
            lstrcpyn(_wszPassword, pwszPassword, 255);
        }
        else
        {
            *_wszPassword = NULL;
        }
    }
    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::OnAuthChallenge(TCHAR __RPC_FAR szUserName[ 255 ],
                                                    TCHAR __RPC_FAR szPassword[ 255 ])
{
    HRESULT hres = S_OK;

    if (*_wszUserName == NULL && *_wszPassword == NULL)
    {
        // if the user provided neither username nor password, we need to use the callback
        hres = _pcallback->OnAuthChallenge(szUserName, szPassword);
    }
    else if (*_wszUserName != NULL && *_wszPassword == NULL)
    {
        // the user may have specified a name but no password, we should respect that
        lstrcpyn(szUserName, _wszUserName, 255);
        *_wszPassword = NULL;
    }
    else 
    {
        // szPassword is not null, szUserName better be non-null too
        // we can assert b/c we checked this in Init
        assert(szUserName != NULL);

        lstrcpyn(szUserName, _wszUserName, 255);
        lstrcpyn(szPassword, _wszPassword, 255);
    }        

    return hres;
}

///////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAsyncWntCallbackImpl::Respond(LPWSTR       pwszVerb,
                                            LPWSTR       pwszPath,
                                            DWORD        cchHeaders,
                                            LPWSTR       pwszHeaders,
                                            DWORD        dwStatusCode,
                                            LPWSTR       pwszStatusCode,
                                            LPWSTR       pwszContentType,
                                            DWORD        cbSent,
                                            LPBYTE       pbResponse,
                                            DWORD        cbResponse)
{
    // local
    HRESULT hres = S_OK;
    CQXML qxml;
    DAVRESPONSE davResponse;

    // argument checking
    if (pwszVerb == NULL || pwszPath == NULL || (cbResponse > 0 && pbResponse == NULL) || (cchHeaders == 0 && pwszHeaders != NULL))
    {
        hres = E_INVALIDARG;
    }
    else 
    {
        // code
        // -- populate the davResponse object to send back
        davResponse.fDone = TRUE; // we are purely synchronous for now, we block until all data is ready
        davResponse.uHTTPReturnCode = dwStatusCode;

        if (dwStatusCode < 100) {
            davResponse.hrResult = E_FAIL; // undefined
            hres = E_INVALIDARG;
        }
        else if (dwStatusCode < 200) { // note that < 200 means 100-199
            davResponse.hrResult = S_OK; // RFC 2616 defines 1?? as "informational", ignore
        }
        else if (dwStatusCode < 300) {
            davResponse.hrResult = S_OK; // RFC 2616 defines 2?? as "OK"
        }
        else if (dwStatusCode < 400) {
            davResponse.hrResult = E_FAIL; // RFC 2616 defines 3?? as "redirection", we can't support this for now
        }
        else if (dwStatusCode < 500) {
            davResponse.hrResult = E_FAIL; // RFC 2616 defines 4?? as "error"
        }
        else if (dwStatusCode < 600) {
            davResponse.hrResult = E_FAIL; // RFC 2616 defines 5?? as "internal server error"
        }
        else
        {
            davResponse.hrResult = E_FAIL; // undefinfed
            hres = E_INVALIDARG;
        }

        // important: if there is no callback registered, then we just return the hrResult
        if (_pcallback == NULL)
        {
            hres = davResponse.hrResult;
        }
        else if (SUCCEEDED(hres)) // check not if we got a success code, but if we got a VALID HTTP code
        {
            // now dispatch on the verb, executing the appropriate method and populating the davResponse object with more data
            // for now, we don't do any work after the method, but we might in the future. (logging?)
            if (lstrcmp(pwszVerb, L"GET") == 0)
            {
                hres = this->_RespondHandleGET(&davResponse,
                                             pwszVerb,
                                             pwszPath,
                                             cchHeaders,
                                             pwszHeaders,
                                             dwStatusCode,
                                             pwszStatusCode,
                                             pwszContentType,
                                             cbSent,
                                             pbResponse,
                                             cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"OPTIONS") == 0)
            {
                hres = this->_RespondHandleOPTIONS(&davResponse,
                                                     pwszVerb,
                                                     pwszPath,
                                                     cchHeaders,
                                                     pwszHeaders,
                                                     dwStatusCode,
                                                     pwszStatusCode,
                                                     pwszContentType,
                                                     cbSent,
                                                     pbResponse,
                                                     cbResponse);

            }
            else if (lstrcmp(pwszVerb, L"HEAD") == 0)
            {
                hres = this->_RespondHandleHEAD(&davResponse,
                                                  pwszVerb,
                                                  pwszPath,
                                                  cchHeaders,
                                                  pwszHeaders,
                                                  dwStatusCode,
                                                  pwszStatusCode,
                                                  pwszContentType,
                                                  cbSent,
                                                  pbResponse,
                                                  cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"PUT") == 0)
            {
                hres = this->_RespondHandlePUT(&davResponse,
                                                 pwszVerb,
                                                 pwszPath,
                                                 cchHeaders,
                                                 pwszHeaders,
                                                 dwStatusCode,
                                                 pwszStatusCode,
                                                 pwszContentType,
                                                 cbSent,
                                                 pbResponse,
                                                 cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"POST") == 0)
            {
                hres = this->_RespondHandlePOST(&davResponse,
                                                 pwszVerb,
                                                 pwszPath,
                                                 cchHeaders,
                                                 pwszHeaders,
                                                 dwStatusCode,
                                                 pwszStatusCode,
                                                 pwszContentType,
                                                 cbSent,
                                                 pbResponse,
                                                 cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"MKCOL") == 0)
            {
                hres = this->_RespondHandleMKCOL(&davResponse,
                                                   pwszVerb,
                                                   pwszPath,
                                                   cchHeaders,
                                                   pwszHeaders,
                                                   dwStatusCode,
                                                   pwszStatusCode,
                                                   pwszContentType,
                                                   cbSent,
                                                   pbResponse,
                                                   cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"COPY") == 0)
            {
                hres = this->_RespondHandleCOPY(&davResponse,
                                                  pwszVerb,
                                                  pwszPath,
                                                  cchHeaders,
                                                  pwszHeaders,
                                                  dwStatusCode,
                                                  pwszStatusCode,
                                                  pwszContentType,
                                                  cbSent,
                                                  pbResponse,
                                                  cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"MOVE") == 0)
            {
                hres = this->_RespondHandleMOVE(&davResponse,
                                                  pwszVerb,
                                                  pwszPath,
                                                  cchHeaders,
                                                  pwszHeaders,
                                                  dwStatusCode,
                                                  pwszStatusCode,
                                                  pwszContentType,
                                                  cbSent,
                                                  pbResponse,
                                                  cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"DELETE") == 0)
            {
                hres = this->_RespondHandleDELETE(&davResponse,
                                                    pwszVerb,
                                                    pwszPath,
                                                    cchHeaders,
                                                    pwszHeaders,
                                                    dwStatusCode,
                                                    pwszStatusCode,
                                                    pwszContentType,
                                                    cbSent,
                                                    pbResponse,
                                                    cbResponse);
            }
            else if (lstrcmp(pwszVerb, L"PROPFIND") == 0)
            {
                hres = this->_RespondHandlePROPFIND(&davResponse,
                                                      pwszVerb,
                                                      pwszPath,
                                                      cchHeaders,
                                                      pwszHeaders,
                                                      dwStatusCode,
                                                      pwszStatusCode,
                                                      pwszContentType,
                                                      cbSent,
                                                      pbResponse,
                                                      cbResponse);

            }
            else if (lstrcmp(pwszVerb, L"PROPPATCH") == 0)
            {
                hres = this->_RespondHandlePROPPATCH(&davResponse,
                                                       pwszVerb,
                                                       pwszPath,
                                                       cchHeaders,
                                                       pwszHeaders,
                                                       dwStatusCode,
                                                       pwszStatusCode,
                                                       pwszContentType,
                                                       cbSent,
                                                       pbResponse,
                                                       cbResponse);

            }
            else if (lstrcmp(pwszVerb, L"SEARCH") == 0)
            {
                // parse the response as if it were a DAV SEARCH command
                hres = E_INVALIDARG;
            }
            else if (lstrcmp(pwszVerb, L"REPLSEARCH") == 0)
            {
                // parse the response as if it were a DAV REPLSEARCH command
                hres = E_INVALIDARG;
            }
            else
            {        
                hres = E_INVALIDARG;
            }
        }
    }
        
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\davinet.cpp ===
#include <objbase.h>
#include <assert.h>

#include "davinet.clsid.h"
#include "httpstrm.clsid.h"
#include "asyncwnt.clsid.h"

#include "qxml.h"

#include "iasyncwnt.h"
#include "davinet.h"
#include "httpstrm.h"
#include "asynccall.h"
#include "propreqs.h"
#include "strutil.h"
#include "mischlpr.h"

///////////////////////////////////////

CDavInetImpl::CDavInetImpl(): _pwszUserName(NULL), _pasyncInet(NULL), _pwszPassword(NULL), _pwszLogFilePath(NULL)
{
}

///////////////////////////////////////

CDavInetImpl::~CDavInetImpl()
{
    if (_pasyncInet != NULL)
    {
        _pasyncInet->Release();
    }
    if (_pwszUserName != NULL)
    {
        free(_pwszUserName);
    }
    if (_pwszPassword != NULL)
    {
        free(_pwszPassword);
    }
    if (_pwszLogFilePath != NULL)
    {
        free(_pwszLogFilePath);
    }   
}

///////////////////////////////////////

// pseudo-constructor: called before we do any operation,
//                     doesn't do anything if already initialized

STDMETHODIMP CDavInetImpl::_Init()
{
    HRESULT hr = S_OK;

    if (_pasyncInet == NULL)
    {
        hr = ::CoCreateInstance(CLSID_AsyncWnt, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_IAsyncWnt, 
                                  (LPVOID*)&_pasyncInet);
        if (FAILED(hr))
        {
            _pasyncInet = NULL;
        }
    }
    return hr;
}

///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////

STDMETHODIMP CDavInetImpl::SetUserAgent(/* [in] */ LPCWSTR pwszUserAgent)
{
    HRESULT hr = S_OK;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {
        hr = _pasyncInet->SetUserAgent(pwszUserAgent);
    }

    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::SetLogFilePath(/* [in] */ LPCWSTR pwszLogFilePath)
{
    HRESULT hr = S_OK;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {
        hr = _pasyncInet->SetLogFilePath(pwszLogFilePath);
    }

    return hr;
}

///////////////////////////////////////

// note that setting username/password to null will clear that field, not leave it as it was

STDMETHODIMP CDavInetImpl::SetAuthentication(/* [optional][in] */ LPCWSTR pwszUserName,
                                             /* [optional][in] */ LPCWSTR pwszPassword)
{
    // local
    HRESULT hr = S_OK;
    UINT cchUserName;
    UINT cchPassword;

    // check params
    if (pwszUserName == NULL && pwszPassword != NULL)
    {
        // only combination that is illegal is a blank username and a non-blank password
        hr = E_INVALIDARG;
    }
    else
    {
        // code    
        hr = this->_Init();

        if (SUCCEEDED(hr))
        {
            // clear previous username/password if appropriate
            if (_pwszUserName != NULL)
            {
                free(_pwszUserName);            
                _pwszUserName = NULL;
            }
            if (_pwszPassword != NULL)
            {
                free(_pwszPassword);
                _pwszPassword = NULL;
            }    
    
            // set new username/password if appropriate
            if (pwszUserName != NULL && ((cchUserName = lstrlen(pwszUserName)) > 0))
            {
                _pwszUserName = AllocateStringW(cchUserName);
                if (_pwszUserName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {        
                    lstrcpy(_pwszUserName, pwszUserName);
                }
            }
    
            if (SUCCEEDED(hr))
            {
                if (pwszPassword != NULL && ((cchPassword = lstrlen(pwszPassword)) > 0))
                {
                    _pwszPassword = AllocateStringW(cchPassword);
                    if (_pwszPassword == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {        
                        lstrcpy(_pwszPassword, pwszPassword);
                    }
                }
            }
        }
    }

    // return value
    return hr;
}

///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////

STDMETHODIMP CDavInetImpl::_Command(/* [in] */ LPCWSTR         pwszUrl,
                                    /* [in] */ LPCWSTR         pwszVerb,          
                                    /* [in] */ LPCWSTR         pwszHeaders,
                                    /* [in] */ ULONG           nAcceptTypes,
                                    /* [in] */ LPCWSTR         rgwszAcceptTypes[],
                                    /* [in] */ IStream*        pStream,
                                    /* [in] */ IDavCallback*   pCallback,
                                    /* [in] */ DWORD           dwCallbackParam)

{
    HRESULT hr = S_OK;
    IAsyncWntCallback* pAsyncCallback = NULL;
    BOOL fNoRoot = FALSE;
    UINT cchHeaders;
    LPWSTR pwszHeadersLocal;

    hr = ::CoCreateInstance(CLSID_AsyncWntCallback, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IAsyncWntCallback, 
                              (LPVOID*)&pAsyncCallback);
    if (SUCCEEDED(hr))
    {
        pwszHeadersLocal = (LPWSTR)pwszHeaders;

        // BUGBUG: we need to test this code
        // initialize the AsyncCallback with the DavCallback and auth info
        // pCallback may well be null, but we still need to pass along the auth info
        if (lstrcmp(pwszVerb, L"PROPFIND") == 0)
        {
            // BUGBUG: ugly special case detection of noroot
            // note: don't need to do this if we're talking to an exchange-enabled server
            cchHeaders = lstrlen(pwszHeaders);
            if (LStrStr((LPWSTR)pwszHeaders, L",noroot") == (pwszHeaders + cchHeaders - 7))
            {
                fNoRoot = TRUE;
                pwszHeadersLocal = (LPWSTR)malloc((cchHeaders - 7 + 1) * sizeof(WCHAR)); // get rid of ,noroot
                if (pwszHeadersLocal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    lstrcpyn(pwszHeadersLocal, pwszHeaders, cchHeaders - 7 + 1);
                }
            } 
        }

        if (SUCCEEDED(hr))
        {        
            hr = ((CAsyncWntCallback*)pAsyncCallback)->Init(pCallback, dwCallbackParam, _pwszUserName, _pwszPassword, fNoRoot);
            if (SUCCEEDED(hr))
            {            
                if (pStream == NULL)
                {
                    hr = _pasyncInet->Request(pwszUrl, pwszVerb, pwszHeadersLocal, nAcceptTypes,
                                              rgwszAcceptTypes, pAsyncCallback, 0);
                }
                else
                {
                    hr = _pasyncInet->RequestWithStream(pwszUrl, pwszVerb, pwszHeadersLocal, nAcceptTypes,
                                                        rgwszAcceptTypes, pStream, pAsyncCallback, 0);
                }
            }
            if (pwszHeadersLocal != pwszHeaders)
            {
                free(pwszHeadersLocal);
            }
        }
                
        pAsyncCallback->Release();

    }

    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandGET(/* [in] */          LPCWSTR          pwszUrl,
                                      /* [in] */          ULONG            nAcceptTypes,
                                      /* [size_is][in] */ LPCWSTR          rgwszAcceptTypes[],
                                      /* [in] */          BOOL             UNREF_PARAM(fTranslate),
                                      /* [in] */          IDavCallback*    pCallback,
                                      /* [in] */          DWORD            dwCallbackParam)
{
    HRESULT hr = S_OK;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        // GET does not require a callback, 
        // but if no callback is specified, 
        // GET really only tests for whether the file is found
        hr = this->_Command(pwszUrl,
                              L"GET",
                              NULL,
                              nAcceptTypes,
                              rgwszAcceptTypes,
                              NULL,
                              pCallback,
                              dwCallbackParam);
    }
    
    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandOPTIONS(/* [in] */ LPCWSTR pwszUrl,
                                          /* [in] */ IDavCallback __RPC_FAR *pCallback,
                                          /* [in] */ DWORD dwCallbackParam)
{
    HRESULT hr = S_OK;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        // OPTIONS requires a callback
        if (pCallback == NULL)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = this->_Command(pwszUrl,
                                     L"OPTIONS",
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     pCallback,
                                     dwCallbackParam);
        }
    }
    
    return hr;
}

///////////////////////////////////////
        
STDMETHODIMP CDavInetImpl::CommandHEAD(/* [in] */ LPCWSTR       pwszUrl,
                                       /* [in] */ IDavCallback* pCallback,
                                       /* [in] */ DWORD         dwCallbackParam)
{
    HRESULT hr = S_OK;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        // HEAD does not require a callback, 
        // but if no callback is specified, 
        // HEAD really only tests for whether the file is found
        hr = this->_Command(pwszUrl,
                              L"HEAD",
                              NULL,
                              0,
                              NULL,
                              NULL,
                              pCallback,
                              dwCallbackParam);
    }
    
    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandPUT(/* [in] */ LPCWSTR       pwszUrl,
                                      /* [in] */ IStream*      pStream,
                                      /* [in] */ LPCWSTR       pwszContentType,
                                      /* [in] */ IDavCallback* pCallback,
                                      /* [in] */ DWORD         dwCallbackParam)
{
    HRESULT hr = S_OK;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        // PUT doesn't require a callback
        hr = this->_Command(pwszUrl,
                              L"PUT",
                              pwszContentType,
                              0,
                              NULL,
                              pStream,
                              pCallback,
                              dwCallbackParam);
    }
    
    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandPOST(/* [in] */ LPCWSTR       pwszUrl,
                                       /* [in] */ IStream*      pStream,
                                       /* [in] */ LPCWSTR       pwszContentType,
                                       /* [in] */ IDavCallback* pCallback,
                                       /* [in] */ DWORD         dwCallbackParam)
{
    // DAV supports the DAV PUT verb
    // This POST method is simply here for people who are used to using GET and POST

    
    
    HRESULT hr;

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        // POST doesn't require a callback
        hr = this->CommandPUT(pwszUrl,
                                pStream,
                                pwszContentType,
                                pCallback,
                                dwCallbackParam);
    }

    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandMKCOL(/* [in] */ LPCWSTR pwszUrl,
                                        /* [in] */ IDavCallback* pCallback,
                                        /* [in] */ DWORD dwCallbackParam)
{
    HRESULT hr = S_OK;

    // MKCOL doesn't require a callback
    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        hr = this->_Command(pwszUrl,
                              L"MKCOL",
						NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 pCallback,
                                 dwCallbackParam);
    }
    
    return hr;
}
        
///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandDELETE(/* [in] */ LPCWSTR       pwszUrl,
                                         /* [in] */ IDavCallback* pCallback,
                                         /* [in] */ DWORD         dwCallbackParam)
{
    HRESULT hr = S_OK;

    // DELETE doesn't require a callback
    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        hr = this->_Command(pwszUrl,
                              L"DELETE",
                              NULL,
                              0,
                              NULL,
                              NULL,
                              pCallback,
                              dwCallbackParam);
    }
    
    return hr;
}
        
///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandCOPY(/* [in] */ LPCWSTR       pwszUrlSource,
                                       /* [in] */ LPCWSTR       pwszUrlDest,
                                       /* [in] */ DWORD         dwDepth,
                                       /* [in] */ BOOL          fOverwrite,
                                       /* [in] */ IDavCallback* pCallback,
                                       /* [in] */ DWORD         dwCallbackParam)
{
    HRESULT hr = S_OK;
    WCHAR wszHeader[100];

    // COPY doesn't require a callback

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        if (dwDepth == DEPTH_INFINITY)
        {
            lstrcpy(wszHeader, L"Depth: infinity");
        }
        else
        {
            wsprintf(wszHeader, L"Depth: %d", dwDepth);
        }
        
        lstrcat(wszHeader, L"Destination: ");
        lstrcat(wszHeader, pwszUrlDest);
        
        if (fOverwrite)
        {
            lstrcat(wszHeader, L"\nOverwrite: T");
        }
        else
        {
            lstrcat(wszHeader, L"\nOverwrite: F");
        }
        
        hr = this->_Command(pwszUrlSource,
                              L"COPY",
                              wszHeader,
                              0,
                              NULL,
                              NULL,
                              pCallback,
                              dwCallbackParam);                                  
    }    

    return hr;
}
        
///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandMOVE(/* [in] */ LPCWSTR       pwszUrlSource,
                                                    /* [in] */ LPCWSTR       pwszUrlDest,
                                                    /* [in] */ BOOL          fOverwrite,
                                                    /* [in] */ IDavCallback* pCallback,
                                                    /* [in] */ DWORD         dwCallbackParam)
{
    HRESULT hr = S_OK;
    WCHAR wszHeader[100];

    // MOVE doesn't require a callback

    hr = this->_Init();
    if (SUCCEEDED(hr))
    {        
        lstrcpy(wszHeader, L"Destination: ");
        lstrcat(wszHeader, pwszUrlDest);
        
        if (fOverwrite)
        {
            lstrcat(wszHeader, L"\nOverwrite: T");
        }
        else
        {
            lstrcat(wszHeader, L"\nOverwrite: F");
        }
        
        hr = this->_Command(pwszUrlSource,
                              L"MOVE",
                              wszHeader,
                              0,
                              NULL,
                              NULL,
                              pCallback,
                              dwCallbackParam);                              
    }    

    return hr;
}
        
///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandPROPFIND(/* [in] */ LPCWSTR           pwszUrl,
                                           /* [in] */ IPropFindRequest* pRequest,
                                           /* [in] */ DWORD             dwDepth,
                                           /* [in] */ BOOL              fNoRoot,
                                           /* [in] */ IDavCallback*     pCallback,
                                           /* [in] */ DWORD             dwCallbackParam)
{
    HRESULT hr = S_OK;
    IStream* pStream = NULL;
    WCHAR wszHeader[100];

    // PROPFIND requires a callback
    if (pCallback == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = this->_Init();
        if (SUCCEEDED(hr))
        {        
            hr = pRequest->GetXmlUtf8(&pStream);
            if (SUCCEEDED(hr))
            {
                if (dwDepth == DEPTH_INFINITY)
                {
                    lstrcpy(wszHeader, L"Depth: infinity");
                }
                else
                {
                    wsprintf(wszHeader, L"Depth: %d", dwDepth);
                }

                if (fNoRoot)
                {
                    lstrcat(wszHeader, L",noroot"); // exchange-specific
                }

                hr = this->_Command(pwszUrl,
                                      L"PROPFIND",
                                      wszHeader,
                                      0,
                                      NULL,
                                      pStream,
                                      pCallback,
                                      dwCallbackParam);
                pStream->Release();
            }
        }
    }
    
    return hr;  
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandPROPPATCH(/* [in] */ LPCWSTR             pwszUrl,
                                                         /* [in] */ IPropPatchRequest*  pRequest,
                                                         /* [in] */ LPCWSTR             pwszHeaders,
                                                         /* [in] */ IDavCallback*       pCallback,
                                                         /* [in] */ DWORD               dwCallbackParam)
{
    HRESULT hr = S_OK;
    IStream* pStream = NULL;

    // PROPPATCH requires a callback
    if (pCallback == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = this->_Init();
        if (SUCCEEDED(hr))
        {        
            hr = pRequest->GetXmlUtf8(&pStream);
    
            if (SUCCEEDED(hr))
            {
                hr = this->_Command(pwszUrl,
                                      L"PROPPATCH",
                                      pwszHeaders,
                                      0,
                                      NULL,
                                      pStream,
                                      pCallback,
                                      dwCallbackParam);
                pStream->Release();
            }
        }
    }

    return hr;
}

///////////////////////////////////////

STDMETHODIMP CDavInetImpl::CommandSEARCH(/* [in] */ LPCWSTR       UNREF_PARAM(pwszUrl),
                                         /* [in] */ IDavCallback* UNREF_PARAM(pCallback),
                                         /* [in] */ DWORD         UNREF_PARAM(dwCallbackParam))
{
    return E_NOTIMPL;
}

STDMETHODIMP CDavInetImpl::CommandREPLSEARCH(/* [in] */ LPCWSTR         UNREF_PARAM(pwszUrl),
                                             /* [in] */ ULONG           UNREF_PARAM(cbCollblob),
                                             /* [size_is][in] */ BYTE*  UNREF_PARAM(pbCollblob),
                                             /* [in] */ IDavCallback*   UNREF_PARAM(pCallback),
                                             /* [in] */ DWORD           UNREF_PARAM(dwCallbackParam))
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\clsids.cpp ===
//
//   - Defines CLSID for the DAVINET
//
#include <objbase.h>

// {93F23B8C-C20C-11d2-B2F5-00105A9974A0}
extern "C" const IID IID_IDavTransport = 
{ 0x93F23B8C, 0xC20C, 0x11d2, { 0xB2, 0xF5, 0x00, 0x10, 0x5A, 0x99, 0x74, 0xA0} };

// {391B226C-D032-11d2-B311-00105A9974A0}
extern "C" const IID IID_IPropFindRequest =
{ 0x391B226C, 0xD032, 0x11d2, { 0xB3, 0x11, 0x00, 0x10, 0x5A, 0x99, 0x74, 0xA0} };

// {9A508200-3EA3-4725-84EE-8A326976D483}
extern "C" const IID IID_IPropPatchRequest =
{ 0x9A508200, 0x3EA3, 0x4725, { 0x84, 0xEE, 0x8A, 0x32, 0x69, 0x76, 0xD4, 0x83} };

// {FC0D2910-C20D-11d2-B2F5-00105A9974A0}
extern "C" const IID IID_IDavCallback =
{ 0xFC0D2910, 0xC20D, 0x11d2, { 0xB2, 0xF5, 0x00, 0x10, 0x5A, 0x99, 0x74, 0xA0} };

// {8EFBD597-63C4-429d-ADB1-3909A8A9415B}
extern "C" const CLSID CLSID_DAVInet = 
{ 0x8efbd597, 0x63c4, 0x429d, { 0xad, 0xb1, 0x39, 0x9, 0xa8, 0xa9, 0x41, 0x5b } };

// {2450C6D2-DD43-4027-B358-3C072F8ED5E6}
extern "C" const CLSID CLSID_DAVPropFindReq = 
{ 0x2450c6d2, 0xdd43, 0x4027, { 0xb3, 0x58, 0x3c, 0x7, 0x2f, 0x8e, 0xd5, 0xe6 } };

// {E29C3A70-B92C-4f5a-87F6-4B9E0DE14EA1}
extern "C" const CLSID CLSID_DAVPropPatchReq = 
{ 0xe29c3a70, 0xb92c, 0x4f5a, { 0x87, 0xf6, 0x4b, 0x9e, 0xd, 0xe1, 0x4e, 0xa1 } };

// {6668F83F-CAAE-435c-B663-0D0A2BF3569E}
extern "C" const CLSID CLSID_AsyncWntCallback = 
{ 0x6668f83f, 0xcaae, 0x435c, { 0xb6, 0x63, 0xd, 0xa, 0x2b, 0xf3, 0x56, 0x9e } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\asynccall.h ===
#ifndef __ASYNCCALL_H
#define __ASYNCCALL_H

#include "unk.h"
#include "idavinet.h"
#include "iasyncwnt.h"

// prototype
class CQXML;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

class CAsyncWntCallbackImpl : public CCOMBase, public IAsyncWntCallback {

public:    
    // IAsyncWntCallback methods
    // this method is called when a response is received from the DAV server.
    // it dispatches to one of the internal response handlers.
    //
    // simple handlers are found in acallsmp.cpp, propfind and proppatch are in acallfnd.cpp
    //
    virtual STDMETHODIMP Respond(LPWSTR       pwszVerb,
                                 LPWSTR       pwszPath,
                                 DWORD        cchHeaders,
                                 LPWSTR       pwszHeaders,
                                 DWORD        dwStatusCode,
                                 LPWSTR       pwszStatusCode,
                                 LPWSTR       pwszContentType,
                                 DWORD        cbSent,
                                 LPBYTE       pbResponse,
                                 DWORD        cbResponse);

    virtual STDMETHODIMP OnAuthChallenge( 
            /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
            /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ]);

public:
    // CAsyncWntCallback methods

    
    virtual STDMETHODIMP Init (IDavCallback*   pcallback,
                               DWORD           dwParam,
                               LPWSTR          pwszUserName,
                               LPWSTR          pwszPassword,
                               BOOL            fNoRoot);

private:
    // Internal helper methods
    // implemented in acallsmp.cpp
	void _ParseDAVVerbs (LPWSTR pwsz, DWORD* pdw);

    STDMETHODIMP _RespondHandleGET(DAVRESPONSE* pdavResponse,
                                   LPWSTR       pwszVerb,
                                   LPWSTR       pwszPath,
                                   DWORD        cchHeaders,
                                   LPWSTR       pwszHeaders,
                                   DWORD        dwStatusCode,
                                   LPWSTR       pwszStatusCode,
                                   LPWSTR       pwszContentType,
                                   DWORD        cbSent,
                                   LPBYTE       pbResponse,
                                   DWORD        cbResponse);

    STDMETHODIMP _RespondHandleHEAD(DAVRESPONSE* pdavResponse,
                                    LPWSTR       pwszVerb,
                                    LPWSTR       pwszPath,
                                    DWORD        cchHeaders,
                                    LPWSTR       pwszHeaders,
                                    DWORD        dwStatusCode,
                                    LPWSTR       pwszStatusCode,
                                    LPWSTR       pwszContentType,
                                    DWORD        cbSent,
                                    LPBYTE       pbResponse,
                                    DWORD        cbResponse);

    STDMETHODIMP _RespondHandleOPTIONS(DAVRESPONSE* pdavResponse,
                                       LPWSTR       pwszVerb,
                                       LPWSTR       pwszPath,
                                       DWORD        cchHeaders,
                                       LPWSTR       pwszHeaders,
                                       DWORD        dwStatusCode,
                                       LPWSTR       pwszStatusCode,
                                       LPWSTR       pwszContentType,
                                       DWORD        cbSent,
                                       LPBYTE       pbResponse,
                                       DWORD        cbResponse);

    STDMETHODIMP _RespondHandlePUT(DAVRESPONSE* pdavResponse,
                                   LPWSTR       pwszVerb,
                                   LPWSTR       pwszPath,
                                   DWORD        cchHeaders,
                                   LPWSTR       pwszHeaders,
                                   DWORD        dwStatusCode,
                                   LPWSTR       pwszStatusCode,
                                   LPWSTR       pwszContentType,
                                   DWORD        cbSent,
                                   LPBYTE       pbResponse,
                                   DWORD        cbResponse);

    STDMETHODIMP _RespondHandlePOST(DAVRESPONSE* pdavResponse,
                                    LPWSTR       pwszVerb,
                                    LPWSTR       pwszPath,
                                    DWORD        cchHeaders,
                                    LPWSTR       pwszHeaders,
                                    DWORD        dwStatusCode,
                                    LPWSTR       pwszStatusCode,
                                    LPWSTR       pwszContentType,
                                    DWORD        cbSent,
                                    LPBYTE       pbResponse,
                                    DWORD        cbResponse);

    STDMETHODIMP _RespondHandlePUTPOST(DAVRESPONSE* pdavResponse,
                                       LPWSTR       pwszVerb,
                                       LPWSTR       pwszPath,
                                       DWORD        cchHeaders,
                                       LPWSTR       pwszHeaders,
                                       DWORD        dwStatusCode,
                                       LPWSTR       pwszStatusCode,
                                       LPWSTR       pwszContentType,
                                       DWORD        cbSent,
                                       LPBYTE       pbResponse,
                                       DWORD        cbResponse);

    STDMETHODIMP _RespondHandleDELETE(DAVRESPONSE* pdavResponse,
                                      LPWSTR       pwszVerb,
                                      LPWSTR       pwszPath,
                                      DWORD        cchHeaders,
                                      LPWSTR       pwszHeaders,
                                      DWORD        dwStatusCode,
                                      LPWSTR       pwszStatusCode,
                                      LPWSTR       pwszContentType,
                                      DWORD        cbSent,
                                      LPBYTE       pbResponse,
                                      DWORD        cbResponse);

    STDMETHODIMP _RespondHandleMKCOL(DAVRESPONSE* pdavResponse,
                                     LPWSTR       pwszVerb,
                                     LPWSTR       pwszPath,
                                     DWORD        cchHeaders,
                                     LPWSTR       pwszHeaders,
                                     DWORD        dwStatusCode,
                                     LPWSTR       pwszStatusCode,
                                     LPWSTR       pwszContentType,
                                     DWORD        cbSent,
                                     LPBYTE       pbResponse,
                                     DWORD        cbResponse);

    STDMETHODIMP _RespondHandleCOPY(DAVRESPONSE* pdavResponse,
                                    LPWSTR       pwszVerb,
                                    LPWSTR       pwszPath,
                                    DWORD        cchHeaders,
                                    LPWSTR       pwszHeaders,
                                    DWORD        dwStatusCode,
                                    LPWSTR       pwszStatusCode,
                                    LPWSTR       pwszContentType,
                                    DWORD        cbSent,
                                    LPBYTE       pbResponse,
                                    DWORD        cbResponse);

    STDMETHODIMP _RespondHandleMOVE(DAVRESPONSE* pdavResponse,
                                    LPWSTR       pwszVerb,
                                    LPWSTR       pwszPath,
                                    DWORD        cchHeaders,
                                    LPWSTR       pwszHeaders,
                                    DWORD        dwStatusCode,
                                    LPWSTR       pwszStatusCode,
                                    LPWSTR       pwszContentType,
                                    DWORD        cbSent,
                                    LPBYTE       pbResponse,
                                    DWORD        cbResponse);

    // implemented in acallfnd.cpp

    LPWSTR _XMLNSExtend (LPWSTR pwszNamespace, LPWSTR pwszXMLPath);

    STDMETHODIMP _InitQXMLFromMessyBuffer(CQXML*  pqxml,
                                          LPSTR   pszXML,
                                          WCHAR   wszDAVAlias[]);

    LPWSTR _GetHREF (CQXML* pqxml,
                     WCHAR wszDavPrefix[]);

    // PROPFIND-specific code to plug into _RespondHandlePROPFINDPATCH
    STDMETHODIMP _RespondHandlePROPFINDHelper(DAVRESPONSE* pdavResponse,
                                              LPWSTR pwszPath,
                                              LPWSTR pwszDavPrefix,
                                              CQXML* pqxml);

    // PROPPATCH-specific code to plug into _RespondHandlePROPFINDPATCH
    STDMETHODIMP _RespondHandlePROPPATCHHelper(DAVRESPONSE* pdavResponse,
                                               LPWSTR pwszPath,
                                               LPWSTR pwszDavPrefix,
                                               CQXML* pqxml);

    // simply calls _RespondHandlePROPFINDPATCH with fFind == TRUE
    STDMETHODIMP _RespondHandlePROPFIND(DAVRESPONSE* pdavResponse,
                                        LPWSTR       pwszVerb,
                                        LPWSTR       pwszPath,
                                        DWORD        cchHeaders,
                                        LPWSTR       pwszHeaders,
                                        DWORD        dwStatusCode,
                                        LPWSTR       pwszStatusCode,
                                        LPWSTR       pwszContentType,
                                        DWORD        cbSent,
                                        LPBYTE       pbResponse,
                                        DWORD        cbResponse);
    
    // simply calls _RespondHandlePROPFINDPATCH with fFind == FALSE
    STDMETHODIMP _RespondHandlePROPPATCH(DAVRESPONSE* pdavResponse,
                                         LPWSTR       pwszVerb,
                                         LPWSTR       pwszPath,
                                         DWORD        cchHeaders,
                                         LPWSTR       pwszHeaders,
                                         DWORD        dwStatusCode,
                                         LPWSTR       pwszStatusCode,
                                         LPWSTR       pwszContentType,
                                         DWORD        cbSent,
                                         LPBYTE       pbResponse,
                                         DWORD        cbResponse);

    // shared handler for PROPFIND and PROPPATCH
    STDMETHODIMP _RespondHandlePROPFINDPATCH(DAVRESPONSE* pdavResponse,
                                             LPWSTR       pwszVerb,
                                             LPWSTR       pwszPath,
                                             DWORD        cchHeaders,
                                             LPWSTR       pwszHeaders,
                                             DWORD        dwStatusCode,
                                             LPWSTR       pwszStatusCode,
                                             LPWSTR       pwszContentType,
                                             DWORD        cbSent,
                                             LPBYTE       pbResponse,
                                             DWORD        cbResponse,
                                             BOOL         fFind); // find: true, patch: false

    
private:
    ////////////////////////////////////////////////////////////////
    // Member variables
    ////////////////////////////////////////////////////////////////

    IDavCallback*   _pcallback;
    DWORD           _dwParam;
    WCHAR           _wszUserName[255];
    WCHAR           _wszPassword[255];
    BOOL            _fNoRoot; // used for PROPFIND
};

typedef CUnkTmpl<CAsyncWntCallbackImpl> CAsyncWntCallback;

#endif // __ASYNCCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\davinetu.cpp ===
#include "davinet.h"
#include "propreqs.h"
#include "asynccall.h"
#include "asyncwnt.clsid.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// for:
// 
// (*) CDavInet
// (*) CDavInetPropFindRequest
// (*) CDavInetPropPatchRequest
// (*) CAsyncWntCallback
//
// Begin ->
const INTFMAPENTRY davinetIME[] =
{
    _INTFMAPENTRY(CDavInet, IDavTransport),
};

const INTFMAPENTRY* CDavInet::_pintfmap = davinetIME;
const DWORD CDavInet::_cintfmap =
    (sizeof(davinetIME)/sizeof(davinetIME[0]));

//////////////

const INTFMAPENTRY davinetpropfindrequestIME[] =
{
    _INTFMAPENTRY(CDavInetPropFindRequest, IPropFindRequest),
};

const INTFMAPENTRY* CDavInetPropFindRequest::_pintfmap = davinetpropfindrequestIME;
const DWORD CDavInetPropFindRequest::_cintfmap =
    (sizeof(davinetpropfindrequestIME)/sizeof(davinetpropfindrequestIME[0]));

//////////////

const INTFMAPENTRY davinetproppatchrequestIME[] =
{
    _INTFMAPENTRY(CDavInetPropPatchRequest, IPropPatchRequest),
};

const INTFMAPENTRY* CDavInetPropPatchRequest::_pintfmap = davinetproppatchrequestIME;
const DWORD CDavInetPropPatchRequest::_cintfmap =
    (sizeof(davinetproppatchrequestIME)/sizeof(davinetproppatchrequestIME[0]));

//////////////

const INTFMAPENTRY asynccallbackIME[] =
{
    _INTFMAPENTRY(CAsyncWntCallback, IAsyncWntCallback),
};

const INTFMAPENTRY* CAsyncWntCallback::_pintfmap = asynccallbackIME;
const DWORD CAsyncWntCallback::_cintfmap =
    (sizeof(asynccallbackIME)/sizeof(asynccallbackIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CDavInet::_cComponents = 0;
DWORD CDavInetPropFindRequest::_cComponents = 0;
DWORD CDavInetPropPatchRequest::_cComponents = 0;
DWORD CAsyncWntCallback::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "davinet.clsid.h"
#include "davinet.h"
#include "propreqs.h"
#include "asynccall.h"

CFactoryData g_FactoryDataArray[] =
{
    { &CLSID_DAVInet, 
        CDavInet::UnkCreateInstance, 
        CDavInet::UnkActiveComponents, 
        L"DAV Transport Object",                    // Friendly name
        L"DavInet.1",                  // ProgID
        L"DavInet",                    // Version-independent
        TRUE},                         // ThreadingModel == Both
    { &CLSID_DAVPropFindReq, 
        CDavInetPropFindRequest::UnkCreateInstance, 
        CDavInetPropFindRequest::UnkActiveComponents, 
        L"DAV PropFindRequest Helper",                    // Friendly name
        L"DavInetPropFindRequest.1",                  // ProgID
        L"DavInetPropFindRequest",                    // Version-independent
        TRUE},                         // ThreadingModel == Both
    { &CLSID_DAVPropPatchReq,
        CDavInetPropPatchRequest::UnkCreateInstance, 
        CDavInetPropPatchRequest::UnkActiveComponents, 
        L"DAV PropPatchRequest Helper",                    // Friendly name
        L"DavInetPropPatchRequest.1",                  // ProgID
        L"DavInetPropPatchRequest",                    // Version-independent
        TRUE},                         // ThreadingModel == Both
    { &CLSID_AsyncWntCallback,
        CAsyncWntCallback::UnkCreateInstance, 
        CAsyncWntCallback::UnkActiveComponents, 
        L"AsyncWntCallback",                    // Friendly name
        L"AsyncWntCallback.1",                  // ProgID
        L"AsyncWntCallback",                    // Version-independent
        TRUE},                        // ThreadingModel == Both
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\propfreq.cpp ===
#include <assert.h>
#include "propreqs.h"
#include "httpstrm.clsid.h"
#include "ihttpstrm.h"
#include "strutil.h"

/////////////////////////////////////////////////////

//
// DavInetPropFindRequest methods
//

// need a destructor, only member variable is CGenericList, which is declared on the stack,
// so it will be destroyed when this object is destroyed, but we need to destroy all the things that
// it points to.
//

CDavInetPropFindRequestImpl::~CDavInetPropFindRequestImpl ()
{
    _genlst.PurgeAll();
}

/////////////////////////////////////////////////////

STDMETHODIMP CDavInetPropFindRequestImpl::SetPropInfo(LPCWSTR pwszNamespace,
                                                      LPCWSTR pwszPropname,
                                                      DAVPROPID propid)
{
    // locals
    HRESULT hres = S_OK;
    LPWSTR pwszTemp = NULL;
    UINT cchTemp; // space for string's NULL terminator
    DAVPROPID* ppropid;
        
    // check args
    if (pwszPropname == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        
        // code    
        // -- copy fullname
        cchTemp = lstrlen(pwszPropname);
        
        if (pwszNamespace != NULL)
        {
            cchTemp += (lstrlen(pwszNamespace));
        }    
        
        pwszTemp = AllocateStringW(cchTemp);
        if (pwszTemp == NULL)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {            
            pwszTemp[0]=NULL;
            if (pwszNamespace !=NULL)
            {
                lstrcat(pwszTemp, pwszNamespace);
            }
            lstrcat(pwszTemp, pwszPropname);
            
            // -- copy propid
            ppropid = (DAVPROPID*)malloc(sizeof(DAVPROPID));
            if (ppropid == NULL)
            {
                hres = E_OUTOFMEMORY;
            }
            else
            {
                CopyMemory(ppropid, &propid, sizeof(DAVPROPID));
                
                // -- add propid to the list of ids, organized by fullname
                hres = _genlst.Add(pwszTemp,           
                                   ppropid,
                                   sizeof(DAVPROPID));
            }
            free(pwszTemp);
        }
    }

    return hres;  
}
        
/////////////////////////////////////////////////////

BOOL __stdcall CDavInetPropFindRequestImpl::GetPropInfo(LPCWSTR pwszNamespace,
                                                        LPCWSTR pwszPropName,
                                                        LPDAVPROPID ppropid)
{
    // locals
    BOOL fReturnCode = FALSE;
    HRESULT hres = S_OK;
    LPWSTR pwszTemp = NULL;
    UINT cchTemp=1;
    UINT cbSize;
    LPVOID lpv;

    // check args
    if (ppropid == NULL || pwszPropName == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {

        // code
        // -- copy full name
        cchTemp = lstrlen(pwszPropName);
        if (pwszNamespace != NULL)
        {
            cchTemp += lstrlen(pwszNamespace);
        }

        pwszTemp = AllocateStringW(cchTemp);
        if (pwszTemp == NULL)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            pwszTemp[0]=NULL;
            if (pwszNamespace !=NULL)
            {
                lstrcat(pwszTemp, pwszNamespace);
            }
            lstrcat(pwszTemp, pwszPropName);
    

            // -- use the string to find the property
            hres = _genlst.Find(pwszTemp,
                                &lpv,   
                                &cbSize);
            if (SUCCEEDED(hres))
            {        
                if (hres == S_FALSE)
                {
                    // if we didn't find it, then return FALSE
                    fReturnCode = FALSE;
                }
                else
                {
                    // otherwise, copy the data and then return TRUE
                    CopyMemory(ppropid, lpv, sizeof(PROPID));
                    fReturnCode = TRUE;
                }
            }
            free(pwszTemp);
        }
    }

    if (FAILED(hres))
    {
        fReturnCode = FALSE;
    }
    return fReturnCode;  
}

/////////////////////////////////////////////////////

STDMETHODIMP CDavInetPropFindRequestImpl::GetPropCount(UINT* cProp)
{
    return _genlst.Size(cProp);
}

/////////////////////////////////////////////////////

STDMETHODIMP CDavInetPropFindRequestImpl::GetXmlUtf8(IStream** ppStream)
{    
    // locals
    WCHAR           wszTempPath[MAX_PATH];
    WCHAR           wszTempFname[MAX_PATH];
    UINT            cchTempFname;
    LPWSTR          pwszFileURL = NULL;
    CQXML           qxml;
    CQXML*          pqxml = NULL;
    UINT            i;
    UINT            cElements;
    HRESULT         hres = S_OK;
    LPSTR           pszXML = NULL;
    LPWSTR          pwszTag = NULL;
    LPWSTR          pwszTagNoAlias = NULL;
    LPWSTR          pwszXML = NULL;
    ULONG           cbWritten;
    ULARGE_INTEGER  cbNewPos;
    
    
    // check args
    if (ppStream == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        // code
        // Create XML blob
        hres = qxml.InitEmptyDoc(L"propfind", L"DAV", L"D");
        if (SUCCEEDED(hres))
        {
            // Populate XML blob
            hres = _genlst.Size(&cElements);
            if (SUCCEEDED(hres))
            {
                if (cElements > 0)
                {
                    hres = qxml.AppendQXML(NULL, NULL, L"prop", L"DAV", L"D", TRUE, &pqxml);
                    
                    if (SUCCEEDED(hres))
                    {
                        if (hres == S_FALSE)
                        {
                            hres = E_FAIL;
                        }
                        else
                        {
                            for (i = 0; i < cElements; i++)
                            {
                                // for each element, get the tag and copy it.
                                hres = _genlst.GetTagByDex(i, &pwszTag);
                                if (SUCCEEDED(hres))
                                {
                                    pwszTag = DuplicateStringW(pwszTag);
                                    if (pwszTag == NULL)
                                    {
                                        hres = E_OUTOFMEMORY;
                                    }
                                    else
                                    {
                                        // look for ':' in the tag
                                        pwszTagNoAlias = wcschr(pwszTag, ':');
                                        if (pwszTagNoAlias == NULL)
                                        {
                                            // if no ':' was found, then namespace is NULL
                                            pwszTagNoAlias = pwszTag;
                                            hres = pqxml->AppendTextNode(NULL, NULL, pwszTagNoAlias, NULL, NULL, NULL, FALSE);
                                        }
                                        else
                                        {
                                            // if : was found, then after the : is the tag with no alias, before is the namespace
                                            *pwszTagNoAlias=NULL;
                                            pwszTagNoAlias++;
                                            // hres = pqxml->AppendTextNode(NULL, NULL, pwszTagNoAlias, pwszTag, L"Q", NULL, FALSE); // BUGBUG: what is Q?
                                            hres = pqxml->AppendTextNode(NULL, NULL, pwszTagNoAlias, pwszTag, pwszTag, NULL, FALSE); // BUGBUG: use namespace instead of Q
                                        }            
                                    
                                        free(pwszTag);
                                        pwszTag = NULL;
                                    }
                                }
                                if (FAILED(hres))
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    // if we don't have any properties, that's our secret code for all the properties
                    hres = qxml.AppendTextNode(NULL, NULL, L"allprop", L"DAV", L"D", NULL, FALSE);
                }
                
                if (SUCCEEDED(hres))
                {
                    // convert XML blob to a string, convert string to ANSI string
                    hres = qxml.GetXMLTreeTextNoBuf(&pwszXML);
                    if (SUCCEEDED(hres))
                    {
                        pszXML = ConvertToANSI(CP_ACP, pwszXML);
                        if (pszXML == NULL)
                        {
                            hres = E_OUTOFMEMORY;
                        }
                        else
                        {
                            // convert string to an IStream    
                            // -- get the path and name for a new temp file
                            if (GetTempPath(MAX_PATH, wszTempPath) == 0)
                            {
                                hres = E_FAIL;
                            }
                            else if (GetTempFileName(wszTempPath, L"DAV", 0, wszTempFname) == 0)
                            {
                                hres = E_FAIL;
                            }
                            else
                            {
                                cchTempFname = lstrlen(wszTempFname);
                                pwszFileURL = AllocateStringW(cchTempFname + 8); // 8 for "file:///"

                                if (pwszFileURL == NULL)
                                {
                                    hres = E_OUTOFMEMORY;
                                }
                                else
                                {
                                    // turn filepath into a file URL
                                    lstrcpy(pwszFileURL, L"file:///");
                                    lstrcpy(pwszFileURL+8, wszTempFname);
                                    for (i = 8; i < 8 + cchTempFname; i++)
                                    {
                                        if (pwszFileURL[i] == '\\')
                                        {
                                            pwszFileURL[i] = '/';
                                        }
                                    }
                                
                                    // -- create IStream on that file
                                    hres = ::CoCreateInstance(CLSID_HttpStrm, 
                                                              NULL, 
                                                              CLSCTX_INPROC_SERVER,                                                               
                                                              //IID_IStream, 
                                                              IID_IHttpStrm, 
                                                              (LPVOID*)ppStream);
                                    if (SUCCEEDED(hres))
                                    {
                                        hres = ((IHttpStrm*)*ppStream)->Open(pwszFileURL, TRUE, TRUE, TRUE);
                                    
                                        if (SUCCEEDED(hres))
                                        {
                                            // -- write ANSI string to the file
                                            hres = (*ppStream)->Write((LPVOID)pszXML, lstrlenA(pszXML), &cbWritten);
                                            if (SUCCEEDED(hres))
                                            {
                                                // -- seek the stream pointer to the start of the stream
                                                LARGE_INTEGER largeint;
                                                largeint.LowPart = 0;
                                                largeint.HighPart = 0;        
                                                hres = (*ppStream)->Seek(largeint, STREAM_SEEK_SET, &cbNewPos);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // release stuff
    if (pwszTag != NULL)
    {
        free(pwszTag);
    }
    
    if (pwszXML != NULL)
    {
        qxml.ReleaseBuf(pwszXML);
    }
    
    if (pszXML != NULL)
    {
        free(pszXML);
    }
    
    if (pqxml != NULL)
    {
        delete pqxml;
    }
    
    // return value
    return hres;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\davinet.h ===
#ifndef __DAVINET_H
#define __DAVINET_H

#include "unk.h"
#include "idavinet.h"
#include "iasyncwnt.h"

class CDavInetImpl : public CCOMBase, public IDavTransport
{
public:
    CDavInetImpl();
    ~CDavInetImpl();

    // IDavTransport
    STDMETHODIMP SetUserAgent( 
        /* [in] */ LPCWSTR pwszUserAgent);
    
    STDMETHODIMP SetAuthentication( 
        /* [optional][in] */ LPCWSTR pwszUserName,
        /* [optional][in] */ LPCWSTR pwszPassword);    

	STDMETHODIMP SetLogFilePath( 
        /* [optional][in] */ LPCWSTR pwszLogFilePath);    
		
    STDMETHODIMP CommandGET( 
        /* [in] */          LPCWSTR       pwszUrl,
        /* [in] */          ULONG         nAcceptTypes,
        /* [size_is][in] */ LPCWSTR       rgwszAcceptTypes[],
        /* [in] */          BOOL          fTranslate,
        /* [in] */          IDavCallback* pCallback,
        /* [in] */          DWORD         dwCallbackParam);

    STDMETHODIMP CommandOPTIONS( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandHEAD( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandPUT( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IStream*      pStream,
        /* [in] */ LPCWSTR       pwszContentType,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandPOST( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IStream*      pStream,
        /* [in] */ LPCWSTR       pwszContentType,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandMKCOL( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandDELETE( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandCOPY( 
        /* [in] */ LPCWSTR       pwszUrlSource,
        /* [in] */ LPCWSTR       pwszUrlDest,
        /* [in] */ DWORD         dwDepth,
        /* [in] */ BOOL          fOverwrite,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandMOVE( 
        /* [in] */ LPCWSTR       pwszUrlSource,
        /* [in] */ LPCWSTR       pwszUrlDest,
        /* [in] */ BOOL          fOverwrite,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandPROPFIND( 
        /* [in] */ LPCWSTR           pwszUrl,
        /* [in] */ IPropFindRequest* pRequest,
        /* [in] */ DWORD             dwDepth,
        /* [in] */ BOOL              fNoRoot,
        /* [in] */ IDavCallback*     pCallback,
        /* [in] */ DWORD             dwCallbackParam);

    STDMETHODIMP CommandPROPPATCH( 
        /* [in] */ LPCWSTR            pwszUrl,
        /* [in] */ IPropPatchRequest* pRequest,
        /* [in] */ LPCWSTR            pwszHeaders,
        /* [in] */ IDavCallback*      pCallback,
        /* [in] */ DWORD              dwCallbackParam);
    
    STDMETHODIMP CommandSEARCH( 
        /* [in] */ LPCWSTR       pwszUrl,
        /* [in] */ IDavCallback* pCallback,
        /* [in] */ DWORD         dwCallbackParam);
    
    STDMETHODIMP CommandREPLSEARCH( 
        /* [in] */          LPCWSTR       pwszUrl,
        /* [in] */          ULONG         cbCollblob,
        /* [size_is][in] */ BYTE*         pbCollblob,
        /* [in] */          IDavCallback* pCallback,
        /* [in] */          DWORD         dwCallbackParam);
    
private:
    // internal methods
    STDMETHODIMP _Init();
    STDMETHODIMP _Command(
        /* [in] */ LPCWSTR         pwszUrl,
        /* [in] */ LPCWSTR         pwszVerb,          
        /* [in] */ LPCWSTR         pwszHeaders,
        /* [in] */ ULONG           nAcceptTypes,
        /* [in] */ LPCWSTR         rgwszAcceptTypes[],
        /* [in] */ IStream*        pStream,
        /* [in] */ IDavCallback*   pCallback,
        /* [in] */ DWORD           dwCallbackParam);

private:
    // member variables
    IAsyncWnt*      _pasyncInet;
    LPWSTR          _pwszUserName;
    LPWSTR          _pwszPassword; // BUGBUG: is it bad to store this unencrypted or something?
	LPWSTR          _pwszLogFilePath;
};

typedef CUnkTmpl<CDavInetImpl> CDavInet;

#endif // __DAVINET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\clsidslib\makefile.inc ===
$(DAVTRANS_ROOT)\clsids\lib\davinet_g.lib: $(O)\davinet_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\idl\makefile.inc ===
$(DAVTRANS_ROOT)\ifaces\idavinet.h: idavinet.h
    copy $** $@

$(DAVTRANS_ROOT)\davinet\lib\idavinet.tlb: idavinet.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\clsids.cpp ===
//
//   - Defines CLSID for the DAVSTORE
//
#include <objbase.h>

// {97B79B7E-6701-43cb-8515-035301124B4F}
extern "C" const IID IID_IDavStorage = 
{ 0x97B79B7E, 0x6701, 0x43cb, { 0x85, 0x15, 0x03, 0x53, 0x01, 0x12, 0x4B, 0x4F} };

// {2E844B51-90A4-4259-827E-D36E71E89591}
extern "C" const CLSID CLSID_CDavStorage = 
{ 0x2e844b51, 0x90a4, 0x4259, { 0x82, 0x7e, 0xd3, 0x6e, 0x71, 0xe8, 0x95, 0x91 } };

// {67FB75F0-AA91-4050-BA11-578DD69CFEDD}
extern "C" const CLSID CLSID_CDavStorageEnum = 
{ 0x67fb75f0, 0xaa91, 0x4050, { 0xba, 0x11, 0x57, 0x8d, 0xd6, 0x9c, 0xfe, 0xdd } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\xmltest\xmltest.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>
#include <assert.h>
#include "davinet.clsid.h"
#include "httpstrm.clsid.h"
#include "idavinet.h"
#include "davinet.h"
#include "ihttpstrm.h"
#include "httpstrm.h"
#include "xmlhlpr.h"
#include "qxml.h"
#include "strutil.h"
#include "mischlpr.h"

// --------------------------------------------------------------------------------
// ARRAYSIZE
// --------------------------------------------------------------------------------
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

// prototypes
HRESULT ProcessDAVXML (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommand (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandGET (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandHEAD (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandOPTIONS (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandPUT (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandPOST (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandDELETE (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandMKCOL (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandCOPY (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandMOVE (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandLOCK (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandUNLOCK (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandPROPFIND (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandPROPPATCH (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLCommandSEARCH (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);

HRESULT ProcessDAVXMLAdminUSERAGENT (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);
HRESULT ProcessDAVXMLAdminAUTH (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavtransport);

///////////////////////////////////////////////////////////////////////////////////

class MyCallback : public IDavCallback {

public:
    STDMETHODIMP Init();
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);

    ULONG STDMETHODCALLTYPE AddRef();
	
    ULONG STDMETHODCALLTYPE Release();

    STDMETHODIMP OnAuthChallenge( 
        /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
        /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ]);
        
    STDMETHODIMP OnResponse( 
        /* [in] */ DAVRESPONSE __RPC_FAR *pResponse);

    STDMETHODIMP SetOutput (
        /* [in */ LPWSTR pwszOutput);
private:
    LONG _cRef;
    LPWSTR _pwszOutput;
};

    
STDMETHODIMP MyCallback::QueryInterface(REFIID iid, void** ppv)
{
    // locals
    HRESULT hres = S_OK;

    // code
    if (iid != IID_IDavCallback && iid != IID_IUnknown) // only interface we implement
    {
        hres = E_NOINTERFACE;
    }
    else
    {
        *ppv = static_cast<IDavCallback*>(this);
    }

    return hres;
}

STDMETHODIMP MyCallback::Init()
{
    _pwszOutput = NULL;
    return S_OK;
}

ULONG STDMETHODCALLTYPE MyCallback::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
	
ULONG STDMETHODCALLTYPE MyCallback::Release()
{
    // locals
    UINT t;    

    // code
    t = ::InterlockedDecrement(&_cRef);
    if (t==0)
    {
        delete this;
    }    
    return t;
}

STDMETHODIMP MyCallback::OnAuthChallenge( /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
                                                       /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ])
{    
    *szUserName = NULL;
    *szPassword = NULL;    
    return S_OK;
}

STDMETHODIMP MyCallback::SetOutput( /* [in] */ LPWSTR pwszOutput)
{    
    if (NULL != _pwszOutput)
    {
        free(_pwszOutput);
    }

    if (NULL == pwszOutput)
    {
        _pwszOutput = NULL;
    }
    else
    {
        _pwszOutput = DuplicateStringW(pwszOutput);
    }
    return S_OK;
}

STDMETHODIMP MyCallback::OnResponse( /* [in] */ DAVRESPONSE __RPC_FAR * pResponse)
{
    HRESULT hr;
    UINT i;

    if (SUCCEEDED(hr = pResponse->hrResult))
    {

        if (_pwszOutput == NULL)
        {
            switch (pResponse->command)
            {
            case DAV_GET:            
                printf("\n%s\n\n",pResponse->rGet.pvBody);
                break;
            case DAV_OPTIONS:
                wprintf(L"\n%s\n\n",pResponse->rHead.pwszRawHeaders);
                break;
            case DAV_HEAD:
                wprintf(L"\n%s\n\n",pResponse->rHead.pwszRawHeaders);
                break;
            case DAV_PUT:
                printf("succeeded.\n\n");
                break;
            case DAV_MKCOL:
                printf("succeeded.\n\n");
                break;
            case DAV_POST:
                printf("succeeded.\n\n");
                break;
            case DAV_DELETE:
                printf("succeeded.\n\n");
                break;
            case DAV_COPY:
                printf("succeeded.\n\n");
                break;
            case DAV_MOVE:
                printf("succeeded.\n\n");
                break;
            case DAV_PROPFIND:                
                printf(" found %d properties.\n", pResponse->rPropFind.cPropVal);
                for (i = 0; i < pResponse->rPropFind.cPropVal; i++)
                {
                    wprintf(L"%d: %s\n", pResponse->rPropFind.rgPropVal[i].dwId, pResponse->rPropFind.rgPropVal[i].pwszVal);
                }
                break;
            case DAV_PROPPATCH:
                printf("succeeded.\n\n");
                break;                
            case DAV_SEARCH:
                break;
            case DAV_REPLSEARCH:
                break;
            default:
                break;
            }	    
        }
    }
    else
    {
        printf("failed with error code %d.\n", pResponse->uHTTPReturnCode);
    }

    return hr;
}


// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------

void __cdecl main(int argc, char *argv[])
{
    // locals
    HRESULT hres = S_OK;
    MyCallback*     pcallback   = NULL;
    LPWSTR          pwszfname     = NULL;
    LPWSTR          pwszXML     = NULL;
    IDavTransport*  pdavTransport = NULL;

    CQXML           qxml;
    
    // check params
    if (argc != 2)
    {
        assert(argv[0] != NULL);
        printf("Usage: %s <xmlfile>\n", argv[0]);
        exit(0);
    }
    
    // allocation    
    CoInitialize(NULL);
    
    pcallback = new MyCallback();
    hres = pcallback->Init();
    if (SUCCEEDED(hres))
    {
        hres= ::CoCreateInstance(CLSID_DAVInet, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER, 
                                 IID_IDavTransport, 
                                 (LPVOID*)&pdavTransport);
        if (SUCCEEDED(hres))
        {
            hres = pdavTransport->SetUserAgent(L"XMLTEST");
            
            // code
            pwszfname = ConvertToUnicode(CP_ACP, argv[1]);
            if (pwszfname == NULL)
            {
                hres = E_FAIL;
            }
            else
            {
                if (!ReadXMLFromFile(pwszfname, &pwszXML))
                {
                    hres = E_FAIL;
                }
                else
                {            
                    hres = qxml.InitFromBuffer(pwszXML);
                    if (SUCCEEDED(hres))
                    {
                        if (hres != S_FALSE)
                        {
                            hres = ProcessDAVXML(&qxml, pcallback, pdavTransport);
                        }
                        else
                        {
                            hres = E_FAIL;
                        }
                    }
                }
            }
        }
    }
    
    // release stuff
    if (pcallback != NULL)
    {
        delete pcallback;
    }

    if (pwszXML != NULL)
    {
        free(pwszXML);
    }
    if (pwszfname != NULL)
    {
        free(pwszfname);
    }
    CoUninitialize();
}


HRESULT ProcessDAVXML (CQXML* pqxml, // XML of the file passed in
                       IDavCallback* pcallback,
                       IDavTransport* pdavTransport)
{
    HRESULT     hres;
    LONG        cCommands, i;
    CQXMLEnum*  pqxmlEnum = NULL;
    CQXML*      pqxml2 = NULL;
    
    hres = pqxml->GetQXMLEnum(NULL, L"command", &pqxmlEnum);
    if (SUCCEEDED(hres))
    {
        if (hres == S_FALSE)
        {
            hres = E_FAIL;
        }
        else
        {
            hres = pqxmlEnum->GetCount(&cCommands);
            if (SUCCEEDED(hres))
            {
                if (hres == S_FALSE)
                {
                    hres = E_FAIL;
                }
                else
                {
                    for (i = 0; i < cCommands; i++)
                    {
                        hres = pqxmlEnum->NextQXML(&pqxml2);                        
                
                        if (SUCCEEDED(hres))
                        {            
                            if (hres == S_FALSE)
                            {
                                hres = E_FAIL;
                            }
                            else
                            {
                                hres = ProcessDAVXMLCommand(pqxml2, pcallback, pdavTransport);
                            }
                        }                
                        if (pqxml2 != NULL)
                        {
                            delete pqxml2;
                            pqxml2 = NULL;
                        }
                        if (FAILED(hres))
                        {
                            break;
                        }
                    }
                }
            }
        }
    }

    // release stuff
    if (pqxmlEnum != NULL)
    {
        delete pqxmlEnum;
    }

    return hres;
}


HRESULT ProcessDAVXMLCommand (CQXML* pqxml, // XML of a single command
                              IDavCallback* pcallback, 
                              IDavTransport* pdavtransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszVerb = NULL;

    hres = pqxml->GetTextNoBuf(NULL, L"VERB", &pwszVerb);
    
    if (SUCCEEDED(hres))
    {
        if (hres == S_FALSE)
        {
            hres = E_FAIL;
        }
        else
        {
            wprintf(L"Verb is %s... ", pwszVerb);

            if (lstrcmp(pwszVerb, L"GET")==0)
            {
                hres = (ProcessDAVXMLCommandGET(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"HEAD")==0)
            {
                hres = (ProcessDAVXMLCommandHEAD(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"OPTIONS")==0)
            {
                hres = (ProcessDAVXMLCommandOPTIONS(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"PUT")==0)
            {
                hres = (ProcessDAVXMLCommandPUT(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"POST")==0)
            {
                hres = (ProcessDAVXMLCommandPOST(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"DELETE")==0)
            {
                hres = (ProcessDAVXMLCommandDELETE(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"MKCOL")==0)
            {
                hres = (ProcessDAVXMLCommandMKCOL(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"COPY")==0)
            {
                hres = (ProcessDAVXMLCommandCOPY(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"MOVE")==0)
            {
                hres = (ProcessDAVXMLCommandMOVE(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"LOCK")==0)
            {
                hres = (ProcessDAVXMLCommandLOCK(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"UNLOCK")==0)
            {
                hres = (ProcessDAVXMLCommandUNLOCK(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"PROPFIND")==0)
            {
                hres = (ProcessDAVXMLCommandPROPFIND(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"PROPPATCH")==0)
            {
                hres = (ProcessDAVXMLCommandPROPPATCH(pqxml, pcallback, pdavtransport));
            }
            else if (lstrcmp(pwszVerb, L"SEARCH")==0)
            {
                hres = (ProcessDAVXMLCommandSEARCH(pqxml, pcallback, pdavtransport));
            }
            else
            {
                hres = E_INVALIDARG;
            }        
        }
    }
    else
    {        
        hres = pqxml->GetTextNoBuf(NULL, L"ADMIN", &pwszVerb);
        if (SUCCEEDED(hres))
        {    
            if (hres == S_FALSE)
            {
                 hres = E_FAIL;
            }
            else
            {
                wprintf(L"Admin command is %s...", pwszVerb);
                if (lstrcmp(pwszVerb, L"USERAGENT") == 0)
                {
                    hres = (ProcessDAVXMLAdminUSERAGENT(pqxml, pcallback, pdavtransport));
                } else if (lstrcmp(pwszVerb, L"AUTH") == 0)
                {
                    hres = (ProcessDAVXMLAdminAUTH(pqxml, pcallback, pdavtransport));
                } 

                if (SUCCEEDED(hres))
                {
                    wprintf(L" done.\n");
                }
                else
                {
                    wprintf(L" failed.\n");
                }
            }
        }
    }

    // release stuff
    if (pwszVerb != NULL)
    {
        pqxml->ReleaseBuf(pwszVerb);
    }

    return hres;
}


HRESULT GetStandardDAVStuff (CQXML* pqxml,
                             LPWSTR* ppwszURL,
                             LPWSTR* ppwszOutput,
                             CQXML** ppqxmlBody)
{
    HRESULT hres = S_OK;
    
    *ppwszURL = NULL;
    *ppwszOutput = NULL;
    *ppqxmlBody = NULL;

    hres = pqxml->GetTextNoBuf(NULL,L"URL",ppwszURL);
    
    if (SUCCEEDED(hres))
    {
        if (hres == S_FALSE)
        {
            hres = E_FAIL;
        }
        else
        {
            hres = pqxml->GetQXML(NULL,L"BODY",ppqxmlBody);
            if (SUCCEEDED(hres))
            {            
                if (hres == S_FALSE)
                {
                    hres = E_FAIL;
                }
                else
                {
                    hres = pqxml->GetTextNoBuf(NULL,L"OUTPUT",ppwszOutput);
                    if (hres == S_FALSE)
                    {
                        hres = E_FAIL;
                    }
                }
            }
        }
    }

    return hres;
}

HRESULT ProcessDAVXMLCommandGET (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {        
        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
        if (SUCCEEDED(hres))
        {
            hres = pdavTransport->CommandGET(pwszURL, 
                0,      // nAcceptTypes
                NULL,   // rgwszAcceptTypes
                FALSE,  // fTranslate
                pcallback,
                0);
        }        
    }

    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    return hres;
}

HRESULT ProcessDAVXMLCommandHEAD (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;
    
    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);    
    if (SUCCEEDED(hres))
    {
        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
        if (SUCCEEDED(hres))
        {
            hres = pdavTransport->CommandHEAD(pwszURL, pcallback, 0);
        }
    }

    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    return hres;
}

HRESULT ProcessDAVXMLCommandOPTIONS (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
        if (SUCCEEDED(hres))
        {
            hres = pdavTransport->CommandOPTIONS(pwszURL, pcallback, 0);
        }
    }
    

    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    return hres;
}

HRESULT ProcessDAVXMLCommandPUT (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszFilePath = NULL;
    UINT cchFilePath;
    IStream* pStream = NULL;    
    LPWSTR pwszURL = NULL;
    LPWSTR pwszFileURL = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = pqxml->GetTextNoBuf(NULL, L"FILEPATH", &pwszFilePath);
        if (SUCCEEDED(hres))
        {
            if (hres == S_FALSE)
            {
                hres = E_FAIL;
            }
            else
            {
                hres = ::CoCreateInstance(CLSID_HttpStrm,
                    NULL, 
                    CLSCTX_INPROC_SERVER, 
                    IID_IStream, 
                    (LPVOID*)&pStream);
                
                if (SUCCEEDED(hres))
                {
                    cchFilePath = lstrlen(pwszFilePath);
                    pwszFileURL = AllocateStringW(cchFilePath + 8); // 8 for "file:///"

                    if (pwszFileURL == NULL)
                    {
                        hres = E_OUTOFMEMORY;
                    }
                    else
                    {
                        // turn filepath into a file URL
                        lstrcpy(pwszFileURL, L"file:///");
                        lstrcpy(pwszFileURL+8, pwszFilePath);
                        for (UINT i = 8; i < 8 + cchFilePath; i++)
                        {
                            if (pwszFileURL[i] == '\\')
                            {
                                pwszFileURL[i] = '/';
                            }
                        }

                        // we created these, so it's ok to cast them to IHttpStrm 
                        //    b/c we know they are really CHttpStrm objects
                        // BUGBUG: we should QI for this
                        hres = ((IHttpStrm*)pStream)->Open(pwszFileURL, TRUE, FALSE, TRUE);
                        if (SUCCEEDED(hres))
                        {                        
                            hres = pdavTransport->CommandPUT(pwszURL,
                                pStream,
                                L"Content-Type: application/x-www-form-urlencoded\n",
                                pcallback,
                                0);
                        }
                    }
                }
            }
        }
    }
    
    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pwszFilePath != NULL)
    {
        pqxml->ReleaseBuf(pwszFilePath);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    if (pStream != NULL)
    {
        pStream->Release();
    }
    return hres;
}

HRESULT ProcessDAVXMLCommandPOST (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    return ProcessDAVXMLCommandPUT(pqxml, pcallback, pdavTransport);
}

HRESULT ProcessDAVXMLCommandDELETE (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {    
        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
        if (SUCCEEDED(hres))
        {    
            hres = pdavTransport->CommandDELETE(pwszURL, pcallback, 0);
        }
    }    

    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    return hres;
}

HRESULT ProcessDAVXMLCommandMKCOL (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
        if (SUCCEEDED(hres))
        {
            hres = pdavTransport->CommandMKCOL(pwszURL, pcallback, 0);
        }
    }
    
    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    return hres;
}

HRESULT ProcessDAVXMLCommandCOPY (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    LPWSTR pwszDest = NULL;
    LPWSTR pwszOverwrite = NULL;
    CQXML* pqxmlBody = NULL;
    BOOL   fOverwrite = FALSE;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = pqxml->GetTextNoBuf(NULL, L"DEST", &pwszDest);
        if (SUCCEEDED(hres))
        {
            if (hres == S_FALSE)
            {
                hres = E_FAIL;
            }
            else
            {
                hres = pqxml->GetTextNoBuf(NULL, L"OVERWRITE", &pwszOverwrite);
                if (SUCCEEDED(hres))
                {
                    if (hres == S_FALSE)
                    {
                        hres = E_FAIL;
                    }
                    else
                    {        
                        if (lstrcmp(pwszOverwrite, L"TRUE") == 0)
                        {
                            fOverwrite = TRUE;
                        }

                        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
                        if (SUCCEEDED(hres))
                        {
                            hres = pdavTransport->CommandCOPY(pwszURL, 
                                                              pwszDest,
                                                              DEPTH_INFINITY,
                                                              fOverwrite,
                                                              pcallback,
                                                              0);
                        }
                    }
                }
            }
        }
    }

    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    if (pwszDest != NULL)
    {
        pqxml->ReleaseBuf(pwszDest);
    }
    if (pwszOverwrite != NULL)
    {
        pqxml->ReleaseBuf(pwszOverwrite);
    }

    return hres;
}

HRESULT ProcessDAVXMLCommandMOVE (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszOutput = NULL;
    LPWSTR pwszDest = NULL;
    LPWSTR pwszOverwrite = NULL;
    CQXML* pqxmlBody = NULL;
    BOOL   fOverwrite = FALSE;

    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = pqxml->GetTextNoBuf(NULL, L"DEST", &pwszDest);
        if (SUCCEEDED(hres))
        {
            if (hres == S_FALSE)
            {
                hres = E_FAIL;
            }
            else
            {
                hres = pqxml->GetTextNoBuf(NULL, L"OVERWRITE", &pwszOverwrite);
                if (SUCCEEDED(hres))
                {
                    if (hres == S_FALSE)
                    {
                        hres = E_FAIL;
                    }
                    else
                    {
                        if (lstrcmp(pwszOverwrite, L"TRUE") == 0)
                        {
                            fOverwrite = TRUE;
                        }
                        hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
                        if (SUCCEEDED(hres))
                        {            
                            hres = pdavTransport->CommandMOVE(pwszURL, 
                                                              pwszDest,
                                                              fOverwrite,
                                                              pcallback,
                                                              0);
                        }
                    }
                }    
            }
        }
    }
    
    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    if (pwszDest != NULL)
    {
        pqxml->ReleaseBuf(pwszDest);
    }
    if (pwszOverwrite != NULL)
    {
        pqxml->ReleaseBuf(pwszOverwrite);
    }

    return hres;
}

HRESULT ProcessDAVXMLCommandLOCK (CQXML* UNREF_PARAM(pqxml), 
                                  IDavCallback* UNREF_PARAM(pcallback), 
                                  IDavTransport* UNREF_PARAM(pdavTransport))
{
    return E_NOTIMPL;
}

HRESULT ProcessDAVXMLCommandUNLOCK (CQXML* UNREF_PARAM(pqxml), 
                                    IDavCallback* UNREF_PARAM(pcallback), 
                                    IDavTransport* UNREF_PARAM(pdavTransport))
{
    return E_NOTIMPL;
}

HRESULT ProcessDAVXMLCommandPROPFIND (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszDepth = NULL;
    LPWSTR pwszNoRoot = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;
    DWORD  dwDepth = 0;
    BOOL fNoRoot = FALSE;
    IPropFindRequest* pRequest = NULL;
    CQXMLEnum* pqxmlEnum = NULL;
    CQXML* pqxml2 = NULL;
    DWORD  cSought = 0;
    
    LPWSTR pwszPropNS = NULL;
    LPWSTR pwszPropNSAlias = NULL;
    LPWSTR pwszPropTag = NULL;
    LPWSTR pwszPropType = NULL;
    DAVPROPID davPropId;
    LPWSTR pwszTemp2;
    
    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = pqxml->GetTextNoBuf(NULL, L"DEPTH", &pwszDepth);
        if (SUCCEEDED(hres))
        {
            // not finding DEPTH is not an error, it's optional
            if (hres != S_FALSE)
            {
                if (lstrcmp(pwszDepth, L"INFINITE") == 0)
                {
                    dwDepth = DEPTH_INFINITY;
                }
                else
                {
                    if (EOF == swscanf(pwszDepth, L"%d", &dwDepth))
                    {
                        dwDepth = 0;
                    }
                }
            }    
            
            hres = pqxml->GetTextNoBuf(NULL, L"NOROOT", &pwszNoRoot);
            if (SUCCEEDED(hres))
            {
                // not finding NOROOT is not an error, it's optional
                if (hres != S_FALSE)
                {
                    if (lstrcmp(pwszNoRoot, L"TRUE") == 0)
                    {
                        fNoRoot = TRUE;
                    }
                }    
                
                hres = ::CoCreateInstance(CLSID_DAVPropFindReq, 
                    NULL, 
                    CLSCTX_INPROC_SERVER, 
                    IID_IPropFindRequest, 
                    (LPVOID*)&pRequest);
                if (SUCCEEDED(hres))
                {
                    hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
                    if (SUCCEEDED(hres))
                    {
                        pqxml->GetXMLTreeTextNoBuf(&pwszTemp2);
                        pqxml->ReleaseBuf(pwszTemp2);
                        pwszTemp2=NULL;
                        hres = pqxml->GetQXMLEnum(L"PROPERTIES",L"PROP",&pqxmlEnum);
                        if (SUCCEEDED(hres))
                        {
                            while (SUCCEEDED(hres = pqxmlEnum->NextQXML(&pqxml2)) && (hres != S_FALSE))
                            {
                                cSought++;
                                
                                hres = pqxml2->GetTextNoBuf(NULL, L"NAMESPACE", &pwszPropNS);
                                if (SUCCEEDED(hres))
                                {
                                    // not finding NAMESPACE is not an error, it's optional
                                    if (hres == S_FALSE)
                                    {
                                        pwszPropNS = NULL;
                                        pwszPropNSAlias = NULL;
                                        hres = S_OK;
                                    }
                                    else
                                    {
                                        hres = pqxml2->GetTextNoBuf(NULL, L"NAMESPACEALIAS", &pwszPropNSAlias);
                                        if (hres == S_FALSE)
                                        {
                                            hres = E_FAIL; // but NAMESPACEALIAS is not optional if NAMESPACE is present
                                        }
                                    }
                                    if (SUCCEEDED(hres))
                                    {                                        
                                        hres = pqxml2->GetTextNoBuf(NULL, L"PROPNAME", &pwszPropTag);
                                        if (SUCCEEDED(hres))
                                        {
                                            if (hres == S_FALSE)
                                            {
                                                hres = E_FAIL; // PROPNAME is not optional
                                            }
                                            else
                                            {
                                                
                                                hres = pqxml2->GetInt(NULL, L"PROPID", (int*)&(davPropId.dwId));
                                                if (SUCCEEDED(hres))
                                                {
                                                    if (hres == S_FALSE)
                                                    {
                                                        hres = E_FAIL; // PROPID is not optional
                                                    }
                                                    else
                                                    {
                                                        hres = pRequest->SetPropInfo(pwszPropNS, 
                                                            pwszPropTag, 
                                                            davPropId);
                                                        if (SUCCEEDED(hres))
                                                        {
                                                            if (pwszPropNS != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropNS);
                                                                pwszPropNS = NULL;
                                                            }
                                                            if (pwszPropNSAlias != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropNSAlias);
                                                                pwszPropNSAlias = NULL;
                                                            }
                                                            if (pwszPropTag != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropTag);
                                                                pwszPropTag = NULL;
                                                            }
                                                            if (pwszPropType != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropType);
                                                                pwszPropType = NULL;
                                                            }
                                                            delete pqxml2;
                                                            pqxml2 = NULL;
                                                        }
                                                        
                                                        
                                                        if (cSought == 0)
                                                        {
                                                            // if we didn't find PROPERTIES, look for ALLPROPERTIES
                                                            hres = (pqxml->GetQXML(NULL, L"ALLPROPERTIES", &pqxml));
                                                            cSought = 1;
                                                        }
                                                        
                                                        if (SUCCEEDED(hres))
                                                        {
                                                            
                                                            if (cSought > 0)
                                                            {
                                                                // if we found either an allproperties or a properties, then we're all set
                                                                hres = pdavTransport->CommandPROPFIND(pwszURL, 
                                                                    pRequest,
                                                                    dwDepth,
                                                                    fNoRoot,
                                                                    pcallback,
                                                                    (DWORD)pRequest); // BUGBUG: this will break if we go async
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if (FAILED(hres))
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
            }    
        }
    }

    // release stuff
    
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pwszDepth != NULL)
    {
        pqxml->ReleaseBuf(pwszDepth);
    }
    if (pwszNoRoot != NULL)
    {
        pqxml->ReleaseBuf(pwszNoRoot);
    }
    if (pwszPropNS != NULL)
    {
        assert(pqxml2 != NULL);
        pqxml2->ReleaseBuf(pwszPropNS);
    }
    if (pwszPropTag != NULL)
    {
        assert(pqxml2 != NULL);
        pqxml2->ReleaseBuf(pwszPropTag);
    }
    if (pwszPropType != NULL)
    {
        assert(pqxml2 != NULL);
        pqxml2->ReleaseBuf(pwszPropType);
    }
    if (pqxml2 != NULL)
    {
        delete pqxml2;
    }
    if (pqxmlEnum != NULL)
    {
        delete pqxmlEnum;
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    if (pRequest != NULL)
    {
        pRequest->Release();
    }

    // return value
    return hres;
}

HRESULT ProcessDAVXMLCommandPROPPATCH (CQXML* pqxml, IDavCallback* pcallback, IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszDepth = NULL;
    LPWSTR pwszNoRoot = NULL;
    LPWSTR pwszOutput = NULL;
    CQXML* pqxmlBody = NULL;
    IPropPatchRequest* pRequest = NULL;
    CQXMLEnum* pqxmlEnum = NULL;
    CQXML* pqxml2 = NULL;
    DWORD  cChanges = 0;
    
    LPWSTR pwszPropNS = NULL;
    LPWSTR pwszPropTag = NULL;
    LPWSTR pwszPropType = NULL;
    LPWSTR pwszPropVal = NULL;
    DAVPROPVAL davPropVal;
    
    hres = GetStandardDAVStuff(pqxml, &pwszURL, &pwszOutput, &pqxmlBody);
    if (SUCCEEDED(hres))
    {
        hres = ::CoCreateInstance(CLSID_DAVPropPatchReq, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_IPropPatchRequest, 
            (LPVOID*)&pRequest);
        if (SUCCEEDED(hres))
        {
            hres = ((MyCallback*)pcallback)->SetOutput(pwszOutput);
            if (SUCCEEDED(hres))
            {
                // get all the "set" properties
                hres = pqxml->GetQXMLEnum(L"SETPROPERTIES",L"PROP",&pqxmlEnum);
                if (SUCCEEDED(hres))
                {
                    while (SUCCEEDED(hres = pqxmlEnum->NextQXML(&pqxml2)) && (hres != S_FALSE))
                    {
                        cChanges++;
                        
                        hres = pqxml2->GetTextNoBuf(NULL, L"NAMESPACE", &pwszPropNS);
                        if (SUCCEEDED(hres))
                        {
                            if (hres == S_FALSE)
                            {
                                pwszPropNS = NULL; // NAMESPACE is optional
                            }
                            
                            hres = (pqxml2->GetTextNoBuf(NULL, L"PROPNAME", &pwszPropTag));
                            if (SUCCEEDED(hres))
                            {
                                if (hres == S_FALSE)
                                {
                                    hres = E_FAIL; // PROPNAME is not optional in this context
                                }
                                else
                                {
                                    hres = pqxml2->GetTextNoBuf(NULL, L"PROPVAL", &pwszPropVal);
                                    if (SUCCEEDED(hres))
                                    {
                                        if (hres == S_FALSE)
                                        {
                                            hres = E_FAIL; // PROPVAL is not optional in this context
                                        }
                                        else
                                        {
                                            hres = pqxml2->GetTextNoBuf(NULL, L"PROPTYPE", &pwszPropType);
                                            if (SUCCEEDED(hres))
                                            {
                                                if (hres == S_FALSE)
                                                {
                                                    hres = E_FAIL; // PROPTYPE is not optional in this context
                                                }
                                                else
                                                {    
                                                    
                                                    if (lstrcmp(L"BLOB", pwszPropType) == 0)
                                                    {
                                                        hres = E_NOTIMPL;
                                                    } 
                                                    else if (lstrcmp(L"FILETIME", pwszPropType) == 0)
                                                    {
                                                        hres = E_NOTIMPL;
                                                    } 
                                                    else if (lstrcmp(L"I2", pwszPropType) == 0)
                                                    {
                                                        davPropVal.dpt = DPT_I2;
                                                        swscanf(pwszPropVal, L"%d", &(davPropVal.iVal));
                                                    } 
                                                    else if (lstrcmp(L"I4", pwszPropType) == 0)
                                                    {
                                                        davPropVal.dpt = DPT_I4;
                                                        swscanf(pwszPropVal, L"%d", &(davPropVal.lVal));
                                                    } 
                                                    else if (lstrcmp(L"LPWSTR", pwszPropType) == 0)
                                                    {
                                                        davPropVal.dpt = DPT_LPWSTR;
                                                        davPropVal.pwszVal = DuplicateStringW(pwszPropVal);
                                                    } 
                                                    else if (lstrcmp(L"UI2", pwszPropType) == 0)
                                                    {
                                                        davPropVal.dpt = DPT_UI2;
                                                        swscanf(pwszPropVal, L"%d", &(davPropVal.uiVal));
                                                    } 
                                                    else if (lstrcmp(L"DPT_UI4", pwszPropType) == 0)
                                                    {
                                                        davPropVal.dpt = DPT_UI4;
                                                        swscanf(pwszPropVal, L"%d", &(davPropVal.ulVal));
                                                    } 
                                                    else {
                                                        hres = E_INVALIDARG;
                                                    }            
                                                    
                                                    if (SUCCEEDED(hres))
                                                    {
                                                        
                                                        hres = pRequest->SetPropValue(pwszPropNS, 
                                                            pwszPropTag, 
                                                            &davPropVal);
                                                        if (SUCCEEDED(hres))
                                                        {
                                                            
                                                            if (pwszPropNS != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropNS);
                                                                pwszPropNS = NULL;
                                                            }
                                                            if (pwszPropTag != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropTag);
                                                                pwszPropTag = NULL;
                                                            }
                                                            if (pwszPropType != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropType);
                                                                pwszPropType = NULL;
                                                            }
                                                            if (pwszPropVal != NULL)
                                                            {
                                                                pqxml2->ReleaseBuf(pwszPropVal);
                                                                pwszPropVal = NULL;
                                                            }
                                                            delete pqxml2;
                                                            pqxml2 = NULL;
                                                        }
                                                        
                                                        
                                                        // get all the "remove" properties
                                                        hres = pqxml->GetQXMLEnum(L"REMOVEPROPERTIES",L"PROP",&pqxmlEnum);
                                                        if (SUCCEEDED(hres))
                                                        {
                                                            while (SUCCEEDED(hres = pqxmlEnum->NextQXML(&pqxml2)) && (hres != S_FALSE))
                                                            {
                                                                cChanges++;
                                                                
                                                                hres = (pqxml2->GetTextNoBuf(NULL, L"NAMESPACE", &pwszPropNS));
                                                                if (SUCCEEDED(hres))
                                                                {
                                                                    if (hres == S_FALSE)
                                                                    {
                                                                        pwszPropNS = NULL; // NAMESPACE is optional
                                                                    }
                                                                    
                                                                    hres = pqxml2->GetTextNoBuf(NULL, L"PROPNAME", &pwszPropTag);
                                                                    if (SUCCEEDED(hres))
                                                                    {
                                                                        if (hres == S_FALSE)
                                                                        {
                                                                            hres = E_FAIL; // PROPNAME is not optional in this context
                                                                        }
                                                                        else
                                                                        {
                                                                            hres = pRequest->SetPropValue(pwszPropNS, 
                                                                                pwszPropTag, 
                                                                                NULL);
                                                                            if (SUCCEEDED(hres))
                                                                            {
                                                                                if (pwszPropNS != NULL)
                                                                                {
                                                                                    pqxml2->ReleaseBuf(pwszPropNS);
                                                                                    pwszPropNS = NULL;
                                                                                }
                                                                                if (pwszPropTag != NULL)
                                                                                {
                                                                                    pqxml2->ReleaseBuf(pwszPropTag);
                                                                                    pwszPropTag = NULL;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                delete pqxml2;
                                                                pqxml2 = NULL;
                                                                
                                                                if (FAILED(hres))
                                                                {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (FAILED(hres))
                        {
                            break;
                        }                                        
                    }
                }
            }
        }
    }
                                        
    if (SUCCEEDED(hres))
    {
        if (cChanges > 0)
        {
            // if we found either an allproperties or a properties, then we're all set
            hres = pdavTransport->CommandPROPPATCH(pwszURL, 
                pRequest,
                NULL, // extra headers
                pcallback,
                (DWORD)pRequest); // BUGBUG: this will break if we go async
        }
    }
    
    
    // release stuff
    if (pwszURL != NULL)
    {
        pqxml->ReleaseBuf(pwszURL);
    }
    if (pwszDepth != NULL)
    {
        pqxml->ReleaseBuf(pwszDepth);
    }
    if (pwszNoRoot != NULL)
    {
        pqxml->ReleaseBuf(pwszNoRoot);
    }
    if (pwszPropNS != NULL)
    {
        assert(pqxml2 != NULL);
        pqxml2->ReleaseBuf(pwszPropNS);
    }
    if (pwszPropTag != NULL)
    {
        assert(pqxml2 != NULL);
        pqxml2->ReleaseBuf(pwszPropTag);
    }
    if (pwszPropVal != NULL)
    {
        assert(pqxml2 != NULL);
        pqxml2->ReleaseBuf(pwszPropVal);
    }
    if (pqxml2 != NULL)
    {
        delete pqxml2;
    }
    if (pqxmlEnum != NULL)
    {
        delete pqxmlEnum;
    }
    if (pqxmlBody != NULL)
    {
        delete pqxmlBody;
    }
    if (pRequest != NULL)
    {
        pRequest->Release();
    }
    return hres;
}

///////////////////////////////////

HRESULT ProcessDAVXMLCommandSEARCH (CQXML* UNREF_PARAM(pqxml), 
                                    IDavCallback* UNREF_PARAM(pcallback), 
                                    IDavTransport* UNREF_PARAM(pdavTransport))

{
    return E_NOTIMPL;
}

///////////////////////////////////

HRESULT ProcessDAVXMLAdminUSERAGENT (CQXML* pqxml, IDavCallback* UNREF_PARAM(pcallback), IDavTransport* pdavTransport)
{
    HRESULT hres = S_OK;
    LPWSTR  pwszUserAgent = NULL;

    hres = pqxml->GetTextNoBuf(NULL, L"AGENT", &pwszUserAgent);
    if (SUCCEEDED(hres))
    {        
        if (hres == S_FALSE)
        {
            hres = E_FAIL; // AGENT is not optional in this context
        }
        else
        {
            hres = pdavTransport->SetUserAgent(pwszUserAgent);
        }
    }
    
    // release stuff
    if (pwszUserAgent != NULL)
    {
        pqxml->ReleaseBuf(pwszUserAgent);
    }

    // return value
    return hres;
}

HRESULT ProcessDAVXMLAdminAUTH (CQXML* pqxml, IDavCallback* UNREF_PARAM(pcallback), IDavTransport* pdavTransport)
{    
    HRESULT hres = S_OK;
    LPWSTR  pwszUserName = NULL;
    LPWSTR  pwszPassword = NULL;

    hres = pqxml->GetTextNoBuf(NULL, L"USERNAME", &pwszUserName);
    if (SUCCEEDED(hres))
    {        
        if (hres == S_FALSE)
        {
            hres = E_FAIL; // USERNAME is not optional in this context
        }
        else
        {
            hres = pqxml->GetTextNoBuf(NULL, L"PASSWORD", &pwszPassword);
            if (SUCCEEDED(hres))
            {
                if (hres == S_FALSE)
                {
                    pwszPassword = NULL; // PASSWORD is optional in this context
                }            
                hres = pdavTransport->SetAuthentication(pwszUserName, pwszPassword);
            }
        }
    }
    
    // release stuff
    if (pwszUserName != NULL)
    {
        pqxml->ReleaseBuf(pwszUserName);
    }
    if (pwszPassword != NULL)
    {
        pqxml->ReleaseBuf(pwszPassword);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\proppreq.cpp ===
#include <assert.h>
#include "propreqs.h"
#include "httpstrm.clsid.h"
#include "ihttpstrm.h"
#include "strutil.h"

//
// DavInetPropPatchRequest methods
//

// need a destructor, only member variable is CGenericList, which is declared on the stack,
// so it will be destroyed when this object is destroyed, but we need to destroy all the things that
// it points to.
//

CDavInetPropPatchRequestImpl::~CDavInetPropPatchRequestImpl ()
{
    _genlst.PurgeAll();
}

/////////////////

// note: if propval is NULL, then this means "delete the value"

STDMETHODIMP CDavInetPropPatchRequestImpl::SetPropValue(LPCWSTR pwszNamespace,
                                                        LPCWSTR pwszPropname,
                                                        LPDAVPROPVAL ppropval)
{
    // locals
    HRESULT         hres = S_OK;
    LPWSTR          pwszTemp = NULL;
    UINT            cchTemp; // space for string's NULL terminator
    LPDAVPROPVAL    ppropvalNew = NULL;
    
    // check args
    if (pwszPropname == NULL || (ppropval != NULL && ppropval->dpt != DPT_LPWSTR))
    {
        hres = E_INVALIDARG; // propname cannot be null, propval must be LPWSTR if we're setting something
    }
    else
    {
        
        // code
        // -- copy the fullname
        cchTemp = lstrlen(pwszPropname);
        if (pwszNamespace != NULL)
        {
            cchTemp += (lstrlen(pwszNamespace));
        }
        pwszTemp = AllocateStringW(cchTemp);
        if (pwszTemp == NULL)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            
            pwszTemp[0]=NULL;
            if (pwszNamespace !=NULL)
            {
                lstrcat(pwszTemp,pwszNamespace);
            }
            lstrcat(pwszTemp,pwszPropname);
            
            
            if (ppropval != NULL)
            {
                // if we are adding a propval, copy it
                ppropvalNew = (LPDAVPROPVAL)malloc(sizeof(DAVPROPVAL));
                if (ppropvalNew == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                else
                {
                    ppropvalNew->dwId = ppropval->dwId;
                    ppropvalNew->dpt = ppropval->dpt;
                    
                    if (ppropval->pwszVal == NULL)
                    {
                        ppropvalNew->pwszVal = NULL;
                    }
                    else
                    {
                        assert(ppropval->dpt == DPT_LPWSTR);
                        ppropvalNew->pwszVal = AllocateStringW(lstrlen(ppropval->pwszVal));
                        if (ppropvalNew->pwszVal == NULL)
                        {
                            hres = E_OUTOFMEMORY;
                        }
                        else
                        {
                            lstrcpy(ppropvalNew->pwszVal, ppropval->pwszVal);
                        }
                    }
                    
                    if (SUCCEEDED(hres))
                    {
                        // add the propval to the list, using the fullname as the tag
                        hres = _genlst.Add(pwszTemp, ppropvalNew, sizeof(DAVPROPVAL));
                    }
                }
            }
            else
            {
                // if we are deleting a propval, add a NULL ptr to the list, using the fullname as the tag
                hres = _genlst.Add(pwszTemp, NULL, 0);
            }
        }
    }
        
    // release stuff
    if (pwszTemp != NULL)
    {
        free(pwszTemp);
    }
    // we need to keep ppropval, so don't release it
    
    return hres;  
}

/////////////////
        
BOOL STDMETHODCALLTYPE CDavInetPropPatchRequestImpl::GetPropInfo(LPCWSTR pwszNamespace,
                                                                 LPCWSTR pwszPropName,
                                                                 LPDAVPROPID ppropid)
{
    // locals
    HRESULT hres = S_OK;
    BOOL    fReturnCode = FALSE;
    LPWSTR  pwszTemp = NULL;
    UINT    cchTemp;
    LPVOID  lpv = NULL;
    UINT    cbSize;

    // check args
    if (pwszPropName == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        // code
        // -- copy the fullname
        cchTemp = lstrlen(pwszPropName);
        if (pwszNamespace != NULL)
        {
            cchTemp += lstrlen(pwszNamespace);
        }
        pwszTemp = AllocateStringW(cchTemp);
        if (pwszTemp == NULL)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {        
            pwszTemp[0]=NULL;
            if (pwszNamespace !=NULL)
            {
                lstrcat(pwszTemp, pwszNamespace);
            }

            lstrcat(pwszTemp, pwszPropName);

            // -- find the property info
            hres = _genlst.Find(pwszTemp,
                                &lpv,
                                &cbSize);
            if (SUCCEEDED(hres))
            {
                if (lpv == NULL)
                {
                    fReturnCode = FALSE;
                }
                else
                {
                    ppropid->dpt = ((LPDAVPROPVAL)lpv)->dpt;
                    ppropid->dwId = ((LPDAVPROPVAL)lpv)->dwId;
                    fReturnCode = TRUE;
                }    
            }
        }
    }

    // release stuff
    if (pwszTemp != NULL)
    {
        free(pwszTemp);
    }
    // don't free lpv, that will blow away data that lives inside the list

    // return value
    return fReturnCode;
}

/////////////////

HRESULT CDavInetPropPatchRequestImpl::_CQXMLAddPropVal (CQXML* pqxml,
                                                        LPWSTR pwszTag,
                                                        LPWSTR pwszNamespaceName,
                                                        LPWSTR pwszNamespaceAlias,
                                                        LPDAVPROPVAL ppropval)
{
    // locals
    HRESULT hres = E_FAIL;
    
    // check params
    assert(pqxml != NULL);
    assert(ppropval != NULL);

    // code

    switch (ppropval->dpt) {
    case DPT_BLOB:
        hres = E_INVALIDARG; // BUGBUG: add support for blob-> string
        break;
    case DPT_FILETIME:
        hres = E_INVALIDARG; // BUGBUG: add support for filetime -> string
        break;
    case DPT_I2:
        hres = pqxml->AppendIntNode(NULL, NULL, pwszTag, pwszNamespaceName, pwszNamespaceAlias, ppropval->iVal, FALSE);
        break;
    case DPT_I4:
        hres = pqxml->AppendIntNode(NULL, NULL, pwszTag, pwszNamespaceName, pwszNamespaceAlias, ppropval->lVal, FALSE);
        break;
    case DPT_LPWSTR:
        hres = pqxml->AppendTextNode(NULL, NULL, pwszTag, pwszNamespaceName, pwszNamespaceAlias, ppropval->pwszVal, FALSE);
        break;
    case DPT_UI2:
        hres = pqxml->AppendIntNode(NULL, NULL, pwszTag, pwszNamespaceName, pwszNamespaceAlias, ppropval->uiVal, FALSE);
        break;
    case DPT_UI4:
        hres = pqxml->AppendIntNode(NULL, NULL, pwszTag, pwszNamespaceName, pwszNamespaceAlias, ppropval->ulVal, FALSE);
        break;
    default:
        assert(FALSE);
        break;
    }

    return hres;
}

/////////////////
// if fSet == true, this is a set request (process all set commands)
// if fSet == false, this is a remove request (process all remove commands)

STDMETHODIMP CDavInetPropPatchRequestImpl::_BuildXMLPatch (CQXML* pqxmlRoot,
                                                           UINT   cElements,
                                                           BOOL   fSet) 
{
    // locals
    HRESULT hres = S_OK;
    CQXML*  pqxml = NULL;
    CQXML*  pqxml2 = NULL;
    UINT    i;
    LPVOID  pv = NULL;
    UINT    cb;
    LPWSTR  pwszTag = NULL;
    LPWSTR  pwszTagNoAlias = NULL;
    
    // check params
    assert(pqxmlRoot != NULL);
    
    // code
    for (i = 0; i < cElements; i++)
    {        
        // for each element, get the data
        hres = _genlst.FindByDex(i, &pv, &cb);
        
        if (SUCCEEDED(hres))
        {
            if ((pv != NULL && fSet == TRUE) || (pv == NULL && fSet == FALSE))
            {
                // only act if it's appropriate to fSet
                hres = _genlst.GetTagByDex(i, &pwszTag);
                if (SUCCEEDED(hres))
                {
                    pwszTag = DuplicateStringW(pwszTag);
                    if (pwszTag == NULL)
                    {
                        hres = E_OUTOFMEMORY;
                    }
                    else
                    {
                        // if we haven't created the set/prop XML subtree yet, create it
                        if (pqxml == NULL)
                        {
                            if (fSet)
                            {
                                hres = pqxmlRoot->AppendQXML(NULL, NULL, L"set", L"DAV", L"D", TRUE, &pqxml);
                            }
                            else
                            {
                                hres = pqxmlRoot->AppendQXML(NULL, NULL, L"remove", L"DAV", L"D", TRUE, &pqxml);
                            }
                            if (SUCCEEDED(hres))
                            {
                                if (hres == S_FALSE)
                                {
                                    hres = E_FAIL;
                                }
                                hres = pqxml->AppendQXML(NULL, NULL, L"prop", L"DAV", L"D", TRUE, &pqxml2);
                            }
                            
                        }
                        
                        if (SUCCEEDED(hres))
                        {
                            pwszTagNoAlias = wcschr(pwszTag, ':');
                            
                            if (fSet)
                            {
                                // add something, add the whole value
                                if (pwszTagNoAlias == NULL)
                                {
                                    hres = this->_CQXMLAddPropVal(pqxml2, pwszTag, NULL, NULL, (LPDAVPROPVAL)pv);
                                }
                                else
                                {
                                    *pwszTagNoAlias = NULL;
                                    pwszTagNoAlias++;
                                    hres = this->_CQXMLAddPropVal(pqxml2, pwszTagNoAlias, pwszTag, L"Q", (LPDAVPROPVAL)pv); // BUGBUG: alias is 'Q'?
                                }
                            }
                            else
                            {
                                // remove something, just add the text tag
                                if (pwszTagNoAlias == NULL)
                                {
                                    hres = pqxml->AppendTextNode(NULL, NULL, pwszTag, NULL, NULL, NULL, TRUE);
                                }
                                else
                                {
                                    *pwszTagNoAlias = NULL;
                                    pwszTagNoAlias++;
                                    hres = pqxml->AppendTextNode(NULL, NULL, pwszTagNoAlias, pwszTag, L"Q", NULL, TRUE);                    
                                }
                            }
                            
                        }
                    }
                }
            }
        }
        free(pwszTag);
        pwszTag = NULL;
        
        if (FAILED(hres))
        {
            break;
        }
    }
    
    // release stuff
    // can't delete pv, that is a pointer to data internal to the list
    
    if (pwszTag != NULL)
    {
        free(pwszTag);
    }
    
    // don't want to delete pwszTagNoAlias, it's a pointer within pwszTag
    
    if (pqxml != NULL)
    {
        assert(pqxml2 != NULL);
        delete pqxml2;
        delete pqxml;
    }
    
    // return value
    return hres;
}

/////////////////

STDMETHODIMP CDavInetPropPatchRequestImpl::GetXmlUtf8(IStream** ppStream)
{
    // locals
    HRESULT         hres = S_OK;
    WCHAR           wszTempPath[MAX_PATH];
    WCHAR           wszTempFname[MAX_PATH];
    UINT            cchTempFname;
    CQXML           qxml;
    UINT            cElements;

    LPWSTR          pwszXML = NULL;
    LPSTR           pszXML = NULL;
    LPWSTR          pwszFileURL = NULL;

    ULONG           cbWritten;
    ULARGE_INTEGER  cbNewPos;
    LARGE_INTEGER   largeint;
    
    // check args
    if (ppStream == NULL)
    {
        return E_INVALIDARG;
    }
    
    // Create XML blob
    hres = qxml.InitEmptyDoc(L"propertyupdate", L"DAV", L"D");
    if (SUCCEEDED(hres))
    {    
        hres = _genlst.Size(&cElements);
        if (SUCCEEDED(hres))
        {            
            if (cElements > 0)
            {
                hres = this->_BuildXMLPatch(&qxml, cElements, TRUE); // set
                if (SUCCEEDED(hres))
                {
                    hres = this->_BuildXMLPatch(&qxml, cElements, FALSE); // remove
                }
            }            

            if (SUCCEEDED(hres))
            {                
                // XML tree -> unicode string -> ansi string
                hres = qxml.GetXMLTreeTextNoBuf(&pwszXML);
                if (SUCCEEDED(hres))
                {                    
                    pszXML = ConvertToANSI(CP_ACP, pwszXML);
                    if (pszXML == NULL)
                    {
                        hres = E_OUTOFMEMORY;
                    }
                    else
                    {                        
                        // ansi string -> IStream (using temp file)
                        if (GetTempPath(MAX_PATH, wszTempPath) == 0)
                        {
                            hres = E_FAIL;
                        }
                        else
                        {
                            if (GetTempFileName(wszTempPath, L"DAV", 0, wszTempFname) == 0)
                            {
                                hres = E_FAIL;
                            }
                            else
                            {
                                cchTempFname = lstrlen(wszTempFname);
                                pwszFileURL = AllocateStringW(cchTempFname + 8); // 8 for "file:///"

                                if (pwszFileURL == NULL)
                                {
                                    hres = E_OUTOFMEMORY;
                                }
                                else
                                {
                                    // turn filepath into a file URL
                                    lstrcpy(pwszFileURL, L"file:///");
                                    lstrcpy(pwszFileURL+8, wszTempFname);
                                    for (UINT i = 8; i < 8 + cchTempFname; i++)
                                    {
                                        if (pwszFileURL[i] == '\\')
                                        {
                                            pwszFileURL[i] = '/';
                                        }
                                    }
                                
                                    // -- create IStream on that file
                                    hres = ::CoCreateInstance(CLSID_HttpStrm, 
                                                              NULL, 
                                                              CLSCTX_INPROC_SERVER, 
                                                              IID_IHttpStrm, 
                                                              (LPVOID*)ppStream);
                                    if (SUCCEEDED(hres))
                                    {
                                        hres = ((IHttpStrm*)*ppStream)->Open(pwszFileURL, TRUE, TRUE, TRUE);
                                        if (SUCCEEDED(hres))
                                        {
                                        
                                            hres = (*ppStream)->Write((LPVOID)pszXML, lstrlenA(pszXML), &cbWritten);
                                            if (SUCCEEDED(hres))
                                            {
                                                // seek IStream to start
                                                largeint.LowPart = 0;
                                                largeint.HighPart = 0;        
                                                hres = (*ppStream)->Seek(largeint, STREAM_SEEK_SET, &cbNewPos);
                                            }
                                        }
                                    }
                                }
                            }
                        }            
                    }
                }
                
            }
        }
    }

    // release stuff
    if (pwszXML != NULL)
    {
        qxml.ReleaseBuf(pwszXML);
    }

    if (pszXML != NULL)
    {
        free(pszXML);
    }

    return hres;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\tstdrv\tstdrv.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>
#include "davinet.clsid.h"
#include "httpstrm.clsid.h"
#include "idavinet.h"
#include "ihttpstrm.h"


// --------------------------------------------------------------------------------
// ARRAYSIZE
// --------------------------------------------------------------------------------
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

///////////////////////////////////////////////////////////////////////////////////

class MyCallback : public IDavCallback {

    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);

    ULONG STDMETHODCALLTYPE AddRef();
	
    ULONG STDMETHODCALLTYPE Release();

    STDMETHODIMP OnAuthChallenge( 
        /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
        /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ]);
        
    STDMETHODIMP OnResponse( 
        /* [in] */ DAVRESPONSE __RPC_FAR *pResponse);

private:
    LONG _cRef;
};

    
STDMETHODIMP MyCallback::QueryInterface(REFIID iid, void** ppv)
{
    // locals
    HRESULT hres = S_OK;

    // code
    if (iid != IID_IDavCallback && iid != IID_IUnknown) // only interface we implement
    {
        hres = E_NOINTERFACE;
    }
    else
    {
        *ppv = static_cast<IDavCallback*>(this);
    }

    return hres;
}

ULONG STDMETHODCALLTYPE MyCallback::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
	
ULONG STDMETHODCALLTYPE MyCallback::Release()
{
    // locals
    UINT t;    

    // code
    t = ::InterlockedDecrement(&_cRef);
    if (t==0)
    {
        delete this;
    }    
    return t;
}

STDMETHODIMP MyCallback::OnAuthChallenge( /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
                                                       /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ])
{
    printf("OnAuthChallenge\n");
    lstrcpy(szUserName, L"aidan");
    lstrcpy(szPassword, L"grendela");
    return S_OK;
}


STDMETHODIMP MyCallback::OnResponse( /* [in] */ DAVRESPONSE __RPC_FAR * pResponse)
{
    printf("OnResponse\n");
    return S_OK;
}


// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(int argc, char *argv[])
{
    // locals
    HRESULT             hres;
    
    IDavTransport*      pdavTransport = NULL;
    IStream*            phttpstrmPut = NULL;
    IStream*            phttpstrmPost = NULL;    
    MyCallback*         pcallback = NULL;
    IPropFindRequest*   pfindreq = NULL;
    IPropPatchRequest*   ppatchreq = NULL;

    LPCWSTR pwszTemp1 = L"This is property one.";
    LPCWSTR pwszTemp2 = L"This is property two.";
    LPCWSTR pwszTemp3 = L"This is property three.";


    // allocation
    
    CoInitialize(NULL);
    hres = ::CoCreateInstance(CLSID_DAVInet, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IDavTransport, 
        (LPVOID*)&pdavTransport);
    if (SUCCEEDED(hres))
    {
        hres = ::CoCreateInstance(CLSID_DAVPropFindReq, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_IPropFindRequest, 
            (LPVOID*)&pfindreq);
        
        if (SUCCEEDED(hres))
        {
        /*
        hres = ::CoCreateInstance(CLSID_DAVPROPPATCHREQ, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IPropPatchRequest, 
        (LPVOID*)&ppatchreq);
            */
            
            if (SUCCEEDED(hres))
            {
                hres = ::CoCreateInstance(CLSID_HttpStrm, 
                    NULL, 
                    CLSCTX_INPROC_SERVER, 
                    IID_IStream, 
                    (LPVOID*)&phttpstrmPut);
                
                if (SUCCEEDED(hres))
                {
                    hres = ::CoCreateInstance(CLSID_HttpStrm,
                        NULL, 
                        CLSCTX_INPROC_SERVER, 
                        IID_IStream, 
                        (LPVOID*)&phttpstrmPost);
                    
                    
                    pcallback = new MyCallback();
                    if (pcallback == NULL)
                    {
                        hres = E_OUTOFMEMORY;
                    }
                    else
                    {
                        // code
                        
                        // we created these, so it's ok to cast them to IHttpStrm
                        //    b/c we know they are really CHttpStrm objects
                        // BUGBUG: we should QI for this
                        hres = ((IHttpStrm*)phttpstrmPut)->Open(L"file:///c:/put.txt", TRUE, FALSE, FALSE);
                        if (SUCCEEDED(hres))
                        {
                            
                            hres = ((IHttpStrm*)phttpstrmPost)->Open(L"file:///c:/post.txt", TRUE, FALSE, FALSE);
                            
                            if (SUCCEEDED(hres))
                            {
                                hres = pdavTransport->SetUserAgent(L"XMLBOY");
                                
                                
                                
                                pdavTransport->CommandDELETE(L"http://aidanl:8080/aidanl/put2.txt",
                                    pcallback,
                                    0);
                                
                                
                                hres = pdavTransport->CommandPUT(L"http://aidanl:8080/aidanl/put2.txt",
                                    phttpstrmPut,
                                    L"Content-Type: application/x-www-form-urlencoded\n",
                                    pcallback,
                                    0);
                                
                                if (SUCCEEDED(hres))
                                {
                                    
                                    pdavTransport->CommandOPTIONS(L"http://aidanl:8080/aidanl/put2.txt",
                                        pcallback,
                                        0);
                                    
                                    pdavTransport->CommandMKCOL(L"http://aidanl:8080/aidanl/mydir",
                                        pcallback,
                                        0);
                                    
                                    
                                    pdavTransport->CommandHEAD(L"http://aidanl:8080/aidanl/put2.txt",
                                        pcallback,
                                        0);
                                    
                                    hres = pdavTransport->CommandGET(L"http://aidanl:8080/aidanl/put2.txt", 
                                        0,      // nAcceptTypes
                                        NULL,   // rgwszAcceptTypes
                                        FALSE,  // fTranslate
                                        pcallback,
                                        0);
                                    if (SUCCEEDED(hres))
                                    {
                                        
                                        
                                        hres = pdavTransport->CommandPOST(L"http://aidanl:8080/aidanl/post2.txt",
                                            phttpstrmPost,
                                            L"Content-Type: application/x-www-form-urlencoded\n",
                                            pcallback,
                                            0);
                                        if (SUCCEEDED(hres))
                                        {
                                            
                                            hres = pdavTransport->CommandCOPY(L"http://aidanl:8080/aidanl/post2.txt",
                                                L"http://aidanl:8080/aidanl/post2copy.txt",
                                                0,
                                                TRUE,
                                                pcallback,
                                                0);
                                            if (SUCCEEDED(hres))
                                            {
                                                
                                                hres = pdavTransport->CommandMOVE(L"http://aidanl:8080/aidanl/post2copy.txt",
                                                    L"http://aidanl:8080/aidanl/post2moved.txt",
                                                    TRUE,
                                                    pcallback,
                                                    0);
                                                if (SUCCEEDED(hres))
                                                {
                                                    
                                                    hres = pdavTransport->CommandDELETE(L"http://aidanl:8080/aidanl/post2.txt",
                                                        pcallback,
                                                        0);
                                                    
                                                    if (SUCCEEDED(hres))
                                                    {
                                                        
                                                        DAVPROPID davpropid;
                                                        davpropid.dpt = DPT_LPWSTR;
                                                        
                                                        davpropid.dwId = 123;
                                                        pfindreq->SetPropInfo(NULL, L"displayname", davpropid);
                                                        
                                                        davpropid.dwId = 456;
                                                        pfindreq->SetPropInfo(NULL, L"getcontentlength", davpropid);
                                                        
                                                        hres = pdavTransport->CommandPROPFIND(L"http://aidanl:8080/aidanl/put2.txt",
                                                            pfindreq,
                                                            1, // DWORD dwDepth,
                                                            FALSE, // / * [in] * / BOOL fNoRoot,
                                                            pcallback,
                                                            (DWORD)pfindreq);
                                                        if (SUCCEEDED(hres))
                                                        {
                                                        /*
                                                        DAVPROPVAL davpropval;
                                                        davpropval.dwId = 789;
                                                        davpropval.dpt = DPT_LPWSTR;
                                                        davpropval.pwszVal = L"This is my thing";
                                                        ppatchreq->SetPropValue(NULL, L"aidanprop1", &davpropval);    
                                                        
                                                          davpropval.dwId = 999;
                                                          davpropval.dpt = DPT_LPWSTR;
                                                          davpropval.pwszVal = L"This is my thing2";
                                                          ppatchreq->SetPropValue(NULL, L"aidanprop2", &davpropval);
                                                          
                                                            hres = pdavTransport->CommandPROPPATCH(L"http://aidanl:8080/aidanl/put2.txt",
                                                            ppatchreq,
                                                            NULL, // additional headers
                                                            pcallback,
                                                            (DWORD)ppatchreq);
                                                            
                                                              davpropid.dwId = 789;
                                                              pfindreq->SetPropInfo(NULL, L"aidanprop1", davpropid);
                                                              
                                                                davpropid.dwId = 999;
                                                                pfindreq->SetPropInfo(NULL, L"aidanprop2", davpropid);
                                                                
                                                                  hres = pdavTransport->CommandPROPFIND(L"http://aidanl:8080/aidanl/put2.txt",
                                                                  pfindreq,
                                                                  1, // DWORD dwDepth,
                                                                  FALSE, // / * [in] * / BOOL fNoRoot,
                                                                  pcallback,
                                                                  (DWORD)pfindreq);
                                                                  
                                                            */
                                                            
                                                            /*
                                                            hres = pdavTransport->CommandSEARCH(L"http://aidanl:8080/test/foo.html",
                                                            pcallback,
                                                            0);
                                                            
                                                              
                                                                pdavTransport->CommandREPLSEARCH(L"http://aidanl:8080/test/foo.html"
                                                                ULONG cbCollblob,
                                                                BYTE __RPC_FAR *pbCollblob,
                                                                pcallback);
                                                            */
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // release stuff
    if (pdavTransport != NULL)
    {
        pdavTransport->Release();
    }
    
    if (phttpstrmPut != NULL)
    {
        phttpstrmPut->Release();
    }
    
    if (phttpstrmPost != NULL)
    {
        phttpstrmPost->Release();
    }

    if (pfindreq != NULL)
    {
        pfindreq ->Release();
    }
    
    if (pcallback != NULL)
    {
        delete pcallback;
    }
    
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davinet\propreqs.h ===
#ifndef __PROPREQS_H
#define __PROPREQS_H

#include "unk.h"
#include "idavinet.h"
#include "generlst.h"
#include "qxml.h"

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


class CDavInetPropFindRequestImpl : public CCOMBase, public IPropFindRequest
{
public: 
    ~CDavInetPropFindRequestImpl();

    STDMETHODIMP SetPropInfo(LPCWSTR pwszNamespace,
                             LPCWSTR pwszPropname,
                             DAVPROPID propid);
    
    BOOL STDMETHODCALLTYPE GetPropInfo(LPCWSTR pwszNamespace,
                                       LPCWSTR pwszPropName,
                                       LPDAVPROPID ppropid);
    STDMETHODIMP GetPropCount(UINT* cProp);
    STDMETHODIMP GetXmlUtf8(IStream __RPC_FAR *__RPC_FAR *ppStream);

private:
    CGenericList _genlst;
};


class CDavInetPropPatchRequestImpl : public CCOMBase, public IPropPatchRequest
{
public: 
    ~CDavInetPropPatchRequestImpl();
    STDMETHODIMP SetPropValue(LPCWSTR pwszNamespace,
                              LPCWSTR pwszPropname,
                              LPDAVPROPVAL ppropval);
    
    BOOL STDMETHODCALLTYPE GetPropInfo(LPCWSTR pwszNamespace,
                                       LPCWSTR pwszPropName,
                                       LPDAVPROPID ppropid);
    
    STDMETHODIMP GetXmlUtf8(IStream __RPC_FAR *__RPC_FAR *ppStream);

private:
    // utility functions
    STDMETHODIMP _CQXMLAddPropVal (CQXML* pqxml,
                                   LPWSTR pwszTag,
                                   LPWSTR pwszNamespaceName,
                                   LPWSTR pwszNamespaceAlias,
                                   LPDAVPROPVAL ppropval);
    STDMETHODIMP _BuildXMLPatch  (CQXML* pqxmlRoot,
                                  UINT   cElements,
                                  BOOL   fSet) ;

private:
    CGenericList _genlst;
};

typedef CUnkTmpl<CDavInetPropFindRequestImpl> CDavInetPropFindRequest;
typedef CUnkTmpl<CDavInetPropPatchRequestImpl> CDavInetPropPatchRequest;

#endif // __PROPREQS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\davstorn.h ===
#ifndef __DAVSTORN_H
#define __DAVSTORN_H

#include <objbase.h>
#include "unk.h"
#include "generlst.h"

class CDavStorageEnumImpl : public CCOMBase, public IEnumSTATSTG {

public:    
    CDavStorageEnumImpl();
    ~CDavStorageEnumImpl();

    // IEnumSTATSTG
    STDMETHODIMP Next(ULONG celt,           
                      STATSTG * rgelt,      
                      ULONG * pceltFetched);
 
    STDMETHODIMP Skip(ULONG celt);
 
    STDMETHODIMP Reset();
 
    STDMETHODIMP Clone(IEnumSTATSTG ** ppenum);

    // Extra methods, not in the interface
    STDMETHODIMP Init(LPWSTR pwszURL,
                      IDavTransport* pDavTransport);
    
    // caller is responsible for allocating the space for this element!
    STDMETHODIMP AddElement(LPWSTR pwszURL,
                            STATSTG* pelt);


private:
    DWORD _dwDex;
    DWORD _cElts;
    CGenericList* _pGenLst;
    DWORD _cchRoot; // number of characters in the path of the root of this enum
};

typedef CUnkTmpl<CDavStorageEnumImpl> CDavStorageEnum;


#endif // __DAVSTORN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\davstoreu.cpp ===
#include <objbase.h>
#include "davstore.clsid.h"
#include "davstore.h"
#include "davstorn.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY davstorageIME[] =
{
    _INTFMAPENTRY(CDavStorage, IDavStorage),
};

const INTFMAPENTRY* CDavStorage::_pintfmap = davstorageIME;
const DWORD CDavStorage::_cintfmap =
    (sizeof(davstorageIME)/sizeof(davstorageIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CDavStorage::_cComponents = 0;


///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY davstorageEnumIME[] =
{
    _INTFMAPENTRY(CDavStorageEnum, IEnumSTATSTG),
};

const INTFMAPENTRY* CDavStorageEnum::_pintfmap = davstorageEnumIME;
const DWORD CDavStorageEnum::_cintfmap =
    (sizeof(davstorageEnumIME)/sizeof(davstorageEnumIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CDavStorageEnum::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "davstore.clsid.h"
#include "davstore.h"
#include "davstorn.h"

CFactoryData g_FactoryDataArray[] =
{
    { &CLSID_CDavStorage, 
      CDavStorage::UnkCreateInstance, 
      CDavStorage::UnkActiveComponents, 
      L"DAV IStorage",     // Friendly name
      L"DavStore.1",                  // ProgID
      L"DavStore",                    // Version-independent
      TRUE},                         // ThreadingModel == Both
    { &CLSID_CDavStorageEnum, 
      CDavStorageEnum::UnkCreateInstance, 
      CDavStorageEnum::UnkActiveComponents, 
      L"DAV IStorage Enum",     // Friendly name
      L"DavStoreEnum.1",                  // ProgID
      L"DavStoreEnum",                    // Version-independent
      TRUE},                         // ThreadingModel == Both
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\clsidslib\makefile.inc ===
$(DAVTRANS_ROOT)\clsids\lib\davstore_g.lib: $(O)\davstore_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\davstore.h ===
#ifndef __DAVSTORE_H
#define __DAVSTORE_H

#include <objbase.h>
#include "unk.h"
#include "idavstore.h"

interface IDavTransport;

class CDavStorageImpl : public CCOMBase, public IDavStorage, public IPropertySetStorage
{
public:
    CDavStorageImpl ();
    ~CDavStorageImpl ();
    
    ///////////////////////////////////////////////////////////
    // IDavStorage
    STDMETHODIMP Init(LPWSTR pwszURL,
                 IDavTransport* pDavTransport);

    STDMETHODIMP SetAuth(LPWSTR pwszUserName,
                         LPWSTR pwszPassword);

    ///////////////////////////////////////////////////////////
    // IStorage
    STDMETHODIMP CreateStream(
        const WCHAR * pwcsName,  //Points to the name of the new stream
        DWORD grfMode,           //Access mode for the new stream
        DWORD reserved1,         //Reserved; must be zero
        DWORD reserved2,         //Reserved; must be zero
        IStream ** ppstm);       //Points to new stream object

    STDMETHODIMP OpenStream(
        const WCHAR * pwcsName,   //Points to name of stream to open
        void * reserved1,         //Reserved; must be NULL
        DWORD grfMode,            //Access mode for the new stream
        DWORD reserved2,          //Reserved; must be zero
        IStream ** ppstm);        //Address of output variable
        // that receives the IStream interface pointer

    STDMETHODIMP CreateStorage(
        const WCHAR * pwcsName,  //Points to the name of the new storage object
        DWORD grfMode,           //Access mode for the new storage object
        DWORD reserved1,         //Reserved; must be zero
        DWORD reserved2,         //Reserved; must be zero
        IStorage ** ppstg);      //Points to new storage object
    
    STDMETHODIMP OpenStorage(
        const WCHAR * pwcsName,   //Points to the name of the
                                  // storage object to open
        IStorage * pstgPriority,  //Must be NULL.
        DWORD grfMode,            //Access mode for the new storage object
        SNB snbExclude,           //Must be NULL.
        DWORD reserved,           //Reserved; must be zero
        IStorage ** ppstg);       //Points to opened storage object
        
    STDMETHODIMP CopyTo(
        DWORD ciidExclude,         //Number of elements in rgiidExclude
        IID const * rgiidExclude,  //Array of interface identifiers (IIDs)
        SNB snbExclude,            //Points to a block of stream
        // names in the storage object
        IStorage * pstgDest);      //Points to destination storage object
        
    STDMETHODIMP MoveElementTo(
        const WCHAR * pwcsName,  //Name of the element to be moved
        IStorage * pstgDest,     //Points to destination storage object IStorage
        const WCHAR * pwcsNewName,      //Points to new name of element in destination
        DWORD grfFlags);         //Specifies a copy or a move
            
    STDMETHODIMP Commit(DWORD grfCommitFlags);  //Specifies how changes are to be committed
    
    STDMETHODIMP Revert(void);
    
    STDMETHODIMP EnumElements(
        DWORD reserved1,        //Reserved; must be zero
        void * reserved2,       //Reserved; must be NULL
        DWORD reserved3,        //Reserved; must be zero
        IEnumSTATSTG ** ppenum);//Address of output variable that
                                // receives the IEnumSTATSTG interface pointer

    STDMETHODIMP DestroyElement(const WCHAR* pwcsName);  //Points to the name of the element to be removed
        
    STDMETHODIMP RenameElement(
        const WCHAR * pwcsOldName,  //Points to the name of the
                                    // element to be changed
        const WCHAR * pwcsNewName); //Points to the new name for
                                    // the specified element
        
    STDMETHODIMP SetElementTimes(
        const WCHAR * pwcsName,   //Points to name of element to be changed
        FILETIME const * pctime,  //New creation time for element, or NULL
        FILETIME const * patime,  //New access time for element, or NULL
        FILETIME const * pmtime); //New modification time for element, or NULL
        
    STDMETHODIMP SetClass(REFCLSID clsid);  //Class identifier to be assigned to the storage object
        
    STDMETHODIMP SetStateBits(
        DWORD grfStateBits,  //Specifies new values of bits
        DWORD grfMask);      //Specifies mask that indicates which
                             // bits are significant
        
    STDMETHODIMP Stat(
        STATSTG * pstatstg,  //Location for STATSTG structure
        DWORD grfStatFlag);  //Values taken from the STATFLAG enumeration
        
    ///////////////////////////////////////////////////////////
    // IPropertySetStorage
    
    STDMETHODIMP Create(
        REFFMTID fmtid, //Format identifier of the property set to be created
        const CLSID * pclsid, //Pointer to initial CLSID for this property set
        DWORD grfFlags, //PROPSETFLAG values
        DWORD grfMode,  //Storage mode of new property set
        IPropertyStorage** ppPropStg); //Address of output variable that receives
                                       // the IPropertyStorage interface pointer
    STDMETHODIMP Open(
        REFFMTID  fmtid,  //The format identifier of the property
                          // set to be opened
        DWORD grfMode,    //Storage mode in which property set is
                          // to be opened
        IPropertyStorage** ppPropStg);
                          //Address of output variable that
                          // receives the IPropertyStorage interface pointer
    
    STDMETHODIMP Delete(REFFMTID fmtid);  //Format identifier of the property set to be deleted                
    
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG**ppenum);
                    // Address of output variable
                    // that receives the IEnumSTATPROPSETSTG
                    // interface pointer

private:
    // internal utility functions
    LPWSTR __stdcall _ResolveURL(LPWSTR pwszRootURL, LPWSTR pwszRelativeURL);
    STDMETHODIMP _GetStream(const WCHAR * pwcsName,  //Points to the name of the new stream
                            DWORD grfMode,           //Access mode for the new stream
                            IStream ** ppstm,        //Points to new stream object
                            BOOL fCreate);

    STDMETHODIMP _OpenStorage(LPWSTR pwszURL,   //Points to the URL of the new storage object
                              IStorage ** ppstg);       //Points to new storage object

private:
    // member variables
    IDavTransport*      _pDavTransport;
    LPWSTR              _pwszURL;
    LPWSTR              _pwszUserName;
    LPWSTR              _pwszPassword;
    DWORD               _grfStateBits;
    BOOL                _fInit;
};

typedef CUnkTmpl<CDavStorageImpl> CDavStorage;

#endif // __DAVSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\davstore.cpp ===
#include <objbase.h>
#include <assert.h>

#include "davstore.h"
#include "davstorn.h"

#include "davinet.clsid.h"
#include "davbagmn.clsid.h"
#include "httpstrm.clsid.h"
#include "davstore.clsid.h"

#include "idavinet.h"
#include "ihttpstrm.h"

#include "strconv.h"
#include "strutil.h"
#include "mischlpr.h"

#include <stdio.h>

//#define TRACE(a) (fprintf(stderr,"%d %s\n",GetTickCount(),a))
#define TRACE(a)

///////////////////////////////////////

CDavStorageImpl::CDavStorageImpl (): _pDavTransport(NULL), _grfStateBits(0), _fInit(FALSE), _pwszURL(NULL), _pwszUserName(NULL), _pwszPassword(NULL)

{
    TRACE("CDavStorage::CDavStorage");
}

///////////////////////////////////////

CDavStorageImpl::~CDavStorageImpl ()
{
    TRACE("CDavStorage::~CDavStorage");
    if (_pDavTransport != NULL)
    {
        _pDavTransport->Release();
    }
	if (_pwszURL != NULL)
    {
		free(_pwszURL);
	}
	if (_pwszUserName != NULL)
	{
		free(_pwszUserName);
	}
	if (_pwszPassword != NULL)
	{
		free(_pwszPassword);
	}
}

///////////////////////////////////////

LPWSTR __stdcall CDavStorageImpl::_ResolveURL(LPWSTR pwszRootURL, LPWSTR pwszRelativeURL)
{
    LPWSTR pwszURL = NULL;
    ULONG cchRootURL;

    TRACE("CDavStorage::_ResolveURL");

    assert(pwszRootURL != NULL);
    assert(pwszRelativeURL != NULL);

    cchRootURL = lstrlen(pwszRootURL);
    if (pwszRootURL[cchRootURL-1] == '/')
    {
        // don't need to add an extra /
        pwszURL = AllocateStringW (cchRootURL + lstrlen(pwszRelativeURL)); // AllocateString auto-does the +1 for the NULL
        if (pwszURL != NULL)
        {
            lstrcpy(pwszURL, pwszRootURL);
            lstrcpy(pwszURL + cchRootURL, pwszRelativeURL);
        }
    }
    else
    {
        // we DO need to add an extra /
        pwszURL = AllocateStringW (cchRootURL + lstrlen(pwszRelativeURL) + 1); // +1 for the extra slash
        if (pwszURL != NULL)
        {
            lstrcpy(pwszURL, pwszRootURL);
            pwszURL[cchRootURL] = '/';
            lstrcpy(pwszURL + cchRootURL + 1, pwszRelativeURL);
        }
    }
    
    return pwszURL;
}

///////////////////////////////////////
STDMETHODIMP CDavStorageImpl::Init(LPWSTR pwszURL,
                                   IDavTransport* pDavTransport)
{
    HRESULT hr = S_OK;
    TRACE("CDavStorage::Init");
    if (pwszURL == NULL || pDavTransport == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (_fInit == TRUE)
        {
            hr = E_FAIL;
        }
        else
        {
//            hr = pDavTransport->CommandHEAD(pwszURL, NULL, 0); // check if this is a URL to a valid place // DEBUG: replace check in the future

            if (SUCCEEDED(hr))
            {
                _pwszURL = DuplicateStringW(pwszURL);
                if (_pwszURL == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _pDavTransport = pDavTransport;                    
                    _pDavTransport->AddRef();
                    _fInit = TRUE;
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::SetAuth(LPWSTR pwszUserName,
                                      LPWSTR pwszPassword)
{
    HRESULT hr = S_OK;
    TRACE("CDavStorage::SetAuth");
    if (_pwszUserName != NULL)
    {
        free(_pwszUserName);
        _pwszUserName = NULL;
    }
    if (_pwszPassword != NULL)
    {
        free(_pwszPassword);
        _pwszPassword = NULL;
    }

    if (pwszUserName != NULL)
    {
        _pwszUserName = DuplicateStringW(pwszUserName);
        if (_pwszUserName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pwszPassword != NULL)
        {
            _pwszPassword = DuplicateStringW(pwszPassword);
            if (_pwszPassword == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }


    return hr;
}

/////////////////////////////////////
STDMETHODIMP CDavStorageImpl::_GetStream(const WCHAR * pwcsName,  //Points to the name of the new stream
                                         DWORD grfMode,           //Access mode for the new stream
                                         IStream ** ppstm,        //Points to new stream object
                                         BOOL fCreate)
{
    HRESULT hr;    
    LPWSTR pwszURL;
    BOOL fTransacted;
    BOOL fDeleteOnRelease;
    
    TRACE("CDavStorage::_GetStream");
    // code
    assert(fInit);

    // open a HTTPStrm to that location, passing in _pDavTransport so that it can do the right thing
    CoInitialize(NULL);
    hr = ::CoCreateInstance(CLSID_HttpStrm, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IHttpStrm, 
                              (LPVOID*)ppstm);
    
    if (SUCCEEDED(hr))
    {
        hr = ((IHttpStrm*)*ppstm)->SetAuth(_pwszUserName, _pwszPassword);
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr))
            {
                pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
                if (pwszURL == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    // parse the grfMode
                    // BUGBUG: only things we can deal with are transacted and deleteonrelease
                    if (grfMode & STGM_TRANSACTED)
                    {
                        fTransacted = TRUE;
                    }
                    else
                    {
                        fTransacted = FALSE;
                    }
                    if (grfMode & STGM_DELETEONRELEASE)
                    {
                        fDeleteOnRelease = TRUE;
                    }
                    else
                    {
                        fDeleteOnRelease = FALSE;
                    }

                    hr = ((IHttpStrm*)*ppstm)->Open(pwszURL, 
                                                      !fTransacted, // direct mode?
                                                      fDeleteOnRelease, // delete when finished?
                                                      fCreate);
                }
            }
        }
    }
    return hr;
}

///////////////////////////////////

STDMETHODIMP CDavStorageImpl::CreateStream(const WCHAR * pwcsName,  //Points to the name of the new stream
                                           DWORD grfMode,           //Access mode for the new stream
                                           DWORD reserved1,         //Reserved; must be zero
                                           DWORD reserved2,         //Reserved; must be zero
                                           IStream ** ppstm)        //Points to new stream object
{
    HRESULT hr = S_OK;

    TRACE("CDavStorage::CreateStream");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        // check params
        if (pwcsName == NULL || reserved1 != 0 || reserved2 != 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = this->_GetStream(pwcsName, grfMode, ppstm, TRUE);
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::OpenStream(const WCHAR * pwcsName,   //Points to name of stream to open
                                         void * reserved1,         //Reserved; must be NULL
                                         DWORD grfMode,            //Access mode for the new stream
                                         DWORD reserved2,          //Reserved; must be zero
                                         IStream ** ppstm)         //Address of output variable
                                                                   // that receives the IStream interface pointer
{
    HRESULT hr = S_OK;

    TRACE("CDavStorage::OpenStream");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        // check params
        if (pwcsName == NULL || reserved1 != NULL || reserved2 != 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // code
            // open a HTTPStrm to that location, passing in _pDavTransport so that it can do the right thing
            hr = this->_GetStream(pwcsName, grfMode, ppstm, FALSE);

        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::_OpenStorage(LPWSTR pwszURL,   //Points to the URL of the new storage object
                                           IStorage ** ppstg)       //Points to new storage object
{
    HRESULT hr;

    hr = ::CoCreateInstance(CLSID_CDavStorage, 
                            NULL, 
                            CLSCTX_INPROC_SERVER, 
                            IID_IDavStorage, 
                            (LPVOID*)ppstg);

    if (SUCCEEDED(hr))
    {
        hr = ((IDavStorage*)*ppstg)->Init(pwszURL, _pDavTransport);
        if (SUCCEEDED(hr))
        {
            hr = ((IDavStorage*)*ppstg)->SetAuth(_pwszUserName, _pwszPassword);
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::CreateStorage(const WCHAR * pwcsName,  //Points to the name of the new storage object
                                            DWORD UNREF_PARAM(grfMode),           //Access mode for the new storage object
                                            DWORD reserved1,         //Reserved; must be zero
                                            DWORD reserved2,         //Reserved; must be zero
                                            IStorage ** ppstg)       //Points to new storage object
{
    HRESULT hr = S_OK;
    LPWSTR pwszURL = NULL;

    TRACE("CDavStorage::CreateStorage");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else if (pwcsName == NULL  || ppstg == NULL || reserved1 != NULL || reserved2 != 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // code
        pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
        if (pwszURL == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = _pDavTransport->CommandMKCOL(pwszURL, NULL, 0);
            
            if (SUCCEEDED(hr))
            {                
                hr = this->_OpenStorage(pwszURL, ppstg);
            }
        }
    }

    return hr;
}
    
/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::OpenStorage(const WCHAR * pwcsName,   //Points to the name of the
                                                                    // storage object to open
                                          IStorage * pstgPriority,  //Must be NULL.
                                          DWORD UNREF_PARAM(grfMode),            //Access mode for the new storage object
                                          SNB snbExclude,           //Must be NULL.
                                          DWORD reserved,           //Reserved; must be zero
                                          IStorage ** ppstg)        //Points to opened storage object
{
    HRESULT hr = S_OK;
    LPWSTR pwszURL = NULL;

    TRACE("CDavStorage::OpenStorage");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else if (pwcsName == NULL  || ppstg == NULL || pstgPriority != NULL || snbExclude != NULL || reserved != 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
        if (pwszURL == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = this->_OpenStorage(pwszURL, ppstg);
        }
    }

    return hr;
}
        
/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::CopyTo(DWORD ciidExclude,         //Number of elements in rgiidExclude
                                     IID const * rgiidExclude,  //Array of interface identifiers (IIDs)
                                     SNB snbExclude,            //Points to a block of stream
                                                                // names in the storage object
                                     IStorage * pstgDest)       //Points to destination storage object
{
    HRESULT hr = S_OK;

    TRACE("CDavStorage::CopyTo");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if (ciidExclude > 0 || rgiidExclude != NULL || snbExclude != NULL || pstgDest == NULL)
        {
            hr = E_INVALIDARG; // BUGBUG: we don't support exclusion right now
        }
        else
        {
            hr = _pDavTransport->SetAuthentication(_pwszUserName, _pwszPassword);
            if (SUCCEEDED(hr))
            {
                hr = _pDavTransport->CommandCOPY(_pwszURL, ((CDavStorageImpl*)pstgDest)->_pwszURL, DEPTH_INFINITY, TRUE, NULL, 0); // synchronous (no callback)                
            }
        }
    }
    
    return S_OK;
}
        
/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::MoveElementTo(const WCHAR * pwcsName,  //Name of the element to be moved
                                            IStorage * pstgDest,     //Points to destination storage object
                                            const WCHAR* pwcsNewName,      //Points to new name of element in destination
                                            DWORD UNREF_PARAM(grfFlags))          //Specifies a copy or a move
{
    HRESULT hr = S_OK;
    LPWSTR pwszSource = NULL;
    LPWSTR pwszDest = NULL;

    TRACE("CDavStorage::MoveElementTo");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if (pwcsName == NULL || pstgDest != NULL || pwcsNewName != NULL)
        {
            hr = E_INVALIDARG; 
        }
        else
        {
            pwszSource = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
            if (pwszSource == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pwszDest = this->_ResolveURL(((CDavStorageImpl*)pstgDest)->_pwszURL, (LPWSTR)pwcsNewName);
                if (pwszDest == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = _pDavTransport->SetAuthentication(_pwszUserName, _pwszPassword);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pDavTransport->CommandMOVE(pwszSource, pwszDest, TRUE, NULL, 0);  // synchronous (no callback)
                    }
                }
            }            
        }
    }
    
    return S_OK;
}
            
/////////////////////////////////////

// IStorage::EnumElements
STDMETHODIMP CDavStorageImpl::EnumElements(DWORD reserved1,        //Reserved; must be zero
                                           void * reserved2,       //Reserved; must be NULL
                                           DWORD reserved3,        //Reserved; must be zero
                                           IEnumSTATSTG ** ppenum) //Address of output variable that
                                                                   // receives the IEnumSTATSTG interface pointer
{
    HRESULT hr = S_OK;
    IEnumSTATSTG* pEnumObj = NULL;

    TRACE("CDavStorage::EnumElements");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        // check params
        if (reserved1 != 0 || reserved2 != NULL || reserved3 != 0 || ppenum == NULL)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // do some magic of issuing a PROPFIND, collecting all the responses, and packaging them into an IEnumSTATSTG
            hr = ::CoCreateInstance(CLSID_CDavStorageEnum, 
                                      NULL, 
                                      CLSCTX_INPROC_SERVER, 
                                      IID_IEnumSTATSTG, 
                                      (LPVOID*)&pEnumObj);
            if (SUCCEEDED(hr))
            {
                hr = ((CDavStorageEnum*)pEnumObj)->Init(_pwszURL, _pDavTransport);
                if (SUCCEEDED(hr))
                {
                    *ppenum = pEnumObj;
                }
                else
                {
                    pEnumObj->Release();
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::DestroyElement(const WCHAR* pwcsName)  //Points to the name of the element to be removed
{
    HRESULT hr = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszDest = NULL;

    TRACE("CDavStorage::DestroyElement");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if (pwcsName == NULL)
        {
            hr = E_INVALIDARG; 
        }
        else
        {
            pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
            if (pwszURL == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = _pDavTransport->SetAuthentication(_pwszUserName, _pwszPassword);
                if (SUCCEEDED(hr))
                {
                    hr = _pDavTransport->CommandDELETE(pwszURL, NULL, 0);
                }
            }            
        }
    }
    
    return S_OK;
}

/////////////////////////////////////
        
STDMETHODIMP CDavStorageImpl::RenameElement(const WCHAR * pwcsOldName,  //Points to the name of the
                                                                        // element to be changed
                                            const WCHAR * pwcsNewName)  //Points to the new name for
                                                                        // the specified element
{
    TRACE("CDavStorage::RenameElement");
    return this->MoveElementTo(pwcsOldName, this, (LPWSTR)pwcsNewName, 0); // BUGBUG: what should last param be?
}

/////////////////////////////////////
        
STDMETHODIMP CDavStorageImpl::SetStateBits(DWORD grfStateBits,  //Specifies new values of bits
                                           DWORD grfMask)       //Specifies mask that indicates which
                                                                // bits are significant
{
    TRACE("CDavStorage::SetStateBits");
    _grfStateBits = _grfStateBits & !grfMask; // clear the elements of the mask
    _grfStateBits = _grfStateBits | (grfStateBits & grfMask); // elements of the mask in the grfStateBits copied to _grfStateBits    

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CDavStorageImpl::Commit(DWORD UNREF_PARAM(grfCommitFlags))  //Specifies how changes are to be committed
{
    return E_NOTIMPL;  // first pass, we do everything synchronously to the server
}
    
/////////////////////////////////////

STDMETHODIMP CDavStorageImpl::Revert(void)
{
    return E_NOTIMPL;  // first pass, we do everything synchronously to the server
}
    
/////////////////////////////////////
        
STDMETHODIMP CDavStorageImpl::SetElementTimes(const WCHAR * UNREF_PARAM(pwcsName),   //Points to name of element to be changed
                                              FILETIME const * UNREF_PARAM(pctime),  //New creation time for element, or NULL
                                              FILETIME const * UNREF_PARAM(patime),  //New access time for element, or NULL
                                              FILETIME const * UNREF_PARAM(pmtime))  //New modification time for element, or NULL
{
    return E_NOTIMPL; // not the first time around
}

/////////////////////////////////////
        
STDMETHODIMP CDavStorageImpl::SetClass(REFCLSID UNREF_PARAM(clsid))  //Class identifier to be assigned to the storage object
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////
        
STDMETHODIMP CDavStorageImpl::Stat(STATSTG* UNREF_PARAM(pstatstg),  //Location for STATSTG structure
                                   DWORD UNREF_PARAM(grfStatFlag))  //Values taken from the STATFLAG enumeration
{
    return E_NOTIMPL; // not the first pass
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

// IPropertySetStorage


STDMETHODIMP CDavStorageImpl::Create(REFFMTID UNREF_PARAM(fmtid),
                                     const CLSID * UNREF_PARAM(pclsid),
                                     DWORD UNREF_PARAM(grfFlags),
                                     DWORD UNREF_PARAM(grfMode),
                                     IPropertyStorage** UNREF_PARAM(ppPropStg))
{
    return E_NOTIMPL;
}


STDMETHODIMP CDavStorageImpl::Open(REFFMTID UNREF_PARAM(fmtid),
                                   DWORD UNREF_PARAM(grfMode),
                                   IPropertyStorage** UNREF_PARAM(ppPropStg))
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CDavStorageImpl::Delete(REFFMTID UNREF_PARAM(fmtid))
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CDavStorageImpl::Enum(IEnumSTATPROPSETSTG** UNREF_PARAM(ppenum))
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\davstorn.cpp ===
#include <objbase.h>
#include <assert.h>
#include <wininet.h>

#include "davstore.h"
#include "davstorn.h"

#include "davinet.clsid.h"
#include "davbagmn.clsid.h"
#include "httpstrm.clsid.h"
#include "davstore.clsid.h"

#include "idavinet.h"
#include "ihttpstrm.h"

#include "timeconv.h"
#include "strconv.h"
#include "strutil.h"
#include "mischlpr.h"

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

class CDavStorageEnumCallback : public CCOMBase, public IDavCallback {

public:    
    CDavStorageEnumCallback();
    ~CDavStorageEnumCallback();
    
    // client gives the callback a pointer to a place to stick the result
    STDMETHODIMP Init(CDavStorageEnum* pEnumObj); 
    
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);

    ULONG STDMETHODCALLTYPE AddRef();
	
    ULONG STDMETHODCALLTYPE Release();

    STDMETHODIMP OnAuthChallenge( TCHAR szUserName[ 255 ],
                                  TCHAR szPassword[ 255 ]);
        
    STDMETHODIMP OnResponse(DAVRESPONSE* pResponse);

private:
    STDMETHODIMP _ConvertCreationDate(LPWSTR pwszDate, FILETIME* ptime);
    STDMETHODIMP _ConvertModifiedDate(LPWSTR pwszDate, FILETIME* ptime);

private:
    LONG _cRef;
    CDavStorageEnum* _pEnumObj; // we pass back the result through here
};

  
CDavStorageEnumCallback::CDavStorageEnumCallback(): _pEnumObj(NULL)
{}

CDavStorageEnumCallback::~CDavStorageEnumCallback()
{
    if (_pEnumObj != NULL)
    {
        _pEnumObj->Release();
    }
}

STDMETHODIMP CDavStorageEnumCallback::Init(CDavStorageEnum* pEnumObj)
{
    HRESULT hres = S_OK;

    if (pEnumObj == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        _pEnumObj = pEnumObj;
        _pEnumObj->AddRef();
    }
    return hres;
}

// boilerplate COM stuff
STDMETHODIMP CDavStorageEnumCallback::QueryInterface(REFIID iid, void** ppv)
{
    // locals
    HRESULT hres = S_OK;

    // code
    if (iid != IID_IDavCallback && iid != IID_IUnknown) // only interface we ement
    {
        hres = E_NOINTERFACE;
    }
    else
    {
        *ppv = static_cast<IDavCallback*>(this);
    }

    return hres;
}

ULONG STDMETHODCALLTYPE CDavStorageEnumCallback::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
	
ULONG STDMETHODCALLTYPE CDavStorageEnumCallback::Release()
{
    // locals
    UINT t;    

    // code
    t = ::InterlockedDecrement(&_cRef);
    if (t==0)
    {
        delete this;
    }    
    return t;
}
// end boilerplate COM stuff


STDMETHODIMP CDavStorageEnumCallback::OnAuthChallenge( TCHAR __RPC_FAR UNREF_PARAM(szUserName)[255],
                                                  TCHAR __RPC_FAR UNREF_PARAM(szPassword)[255])
{
    return E_NOTIMPL;
}

STDMETHODIMP CDavStorageEnumCallback::_ConvertCreationDate(LPWSTR pwszDate, 
                                                           FILETIME* ptime)
{
    // creation date is in format: "1999-12-16T00:35:35Z"
    HRESULT hres = S_OK;

    hres = ConvertTime(L"%Y-%m-%D%i%H:%N:%S%i", pwszDate, ptime);

    return hres;
}

STDMETHODIMP CDavStorageEnumCallback::_ConvertModifiedDate(LPWSTR pwszDate, 
                                                           FILETIME* ptime)
{
    // modification date is in format: "Tue, 14 Dec 1999 00:56:26 GMT"
    HRESULT hres = S_OK;

    hres = ConvertTime(L"%I %D %M %Y %H:%N:%S %I", pwszDate, ptime);

    return hres;
}

HRESULT STDMETHODCALLTYPE CDavStorageEnumCallback::OnResponse( /* [in] */ DAVRESPONSE __RPC_FAR * pResponse)
{
    HRESULT hres = S_OK;
    STATSTG* pStats = NULL;
    UINT i;

    // flags that tell us if we've got each one of these things yet
    BOOL fcbSize = FALSE;
    BOOL fmtime = FALSE;
    BOOL fctime = FALSE;

    if (_pEnumObj != NULL)
    {
        hres = pResponse->hrResult;
        if (SUCCEEDED(hres))
        {
            if (pResponse->command == DAV_PROPFIND)
            {
                // we'll get one callback for each item with all the properties of that item
                if (pResponse->rPropFind.pwszHref != NULL)
                {
                    // collect the href and other appropriate properties
                    pStats = (STATSTG*)malloc(sizeof(STATSTG));
                    if (pStats == NULL)
                    {
                        hres = E_OUTOFMEMORY;
                    }
                    else
                    {
                        // BUGBUG: check to see that string is desired
                        pStats->pwcsName = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + lstrlen(pResponse->rPropFind.pwszHref)));                        
                        if (pStats->pwcsName == NULL)
                        {
                            hres = E_OUTOFMEMORY;
                        }
                        else
                        {
                            lstrcpy(pStats->pwcsName, pResponse->rPropFind.pwszHref);
                            if (pStats->pwcsName[lstrlen(pStats->pwcsName) - 1] == '/')
                            {
                                pStats->pwcsName[lstrlen(pStats->pwcsName) - 1] = TEXT('\0'); // remove the / at the end of dirs
								pStats->type = STGTY_STORAGE;
                            }
                            else
                            {
                                pStats->type = STGTY_STREAM;
                            }

                            for (i = 0; i < pResponse->rPropFind.cPropVal; i+=2) 
                                // because we did a propfind without any properties filled in,
                                // we get all the properties in name/value pairs
                            {
                                // Enum supports the following:
                                //  pStats->pwcsName
                                //  pStats->type
                                //  pStats->cbSize
                                //  pStats->mtime
                                //  pStats->ctime
                                //
                                // if we don't get them all, then we don't insert it at all

                                if (pResponse->rPropFind.rgPropVal[i].dpt != DPT_LPWSTR)
                                {
                                    hres = E_FAIL;
                                }
                                else if (lstrcmpi(pResponse->rPropFind.rgPropVal[i].pwszVal, L"DAV:creationdate") == 0)
                                {
                                    hres = this->_ConvertCreationDate(pResponse->rPropFind.rgPropVal[i+1].pwszVal, &(pStats->ctime));
                                    fctime = TRUE;
                                }
                                else if (lstrcmpi(pResponse->rPropFind.rgPropVal[i].pwszVal, L"DAV:getcontentlength") == 0)
                                {
                                    pStats->cbSize.LowPart = _wtoi(pResponse->rPropFind.rgPropVal[i+1].pwszVal);
                                    pStats->cbSize.HighPart = 0;
                                    fcbSize = TRUE;
                                }
                                else if (lstrcmpi(pResponse->rPropFind.rgPropVal[i].pwszVal, L"DAV:getlastmodified") == 0)
                                {    
                                    hres = this->_ConvertModifiedDate(pResponse->rPropFind.rgPropVal[i+1].pwszVal, &(pStats->ctime));
                                    fmtime = TRUE;
                                }
                            }


                            // Enum doesn't support the following:
                            //  pStats->grfMode
                            //
                            // we don't support the following:
                            //  pStats->atime
                            //  pStats->grfLocksSupported
                            //  pStats->clsid
                            //  pStats->grfStateBits
                            //  pStats->reserved 
                            
                            // add them all to the enum object in one sweep, if we got all the data we need
                            if (SUCCEEDED(hres) && fctime && fmtime && (fcbSize || pStats->type == STGTY_STORAGE))
                            {
                                hres = _pEnumObj->AddElement(pStats->pwcsName, pStats);
                            }                                    
                        }
                    }
                }
            }
        }
    }

    return hres;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

CDavStorageEnumImpl::CDavStorageEnumImpl()
{
}

CDavStorageEnumImpl::~CDavStorageEnumImpl()
{
}

// Extra methods

STDMETHODIMP CDavStorageEnumImpl::Init(LPWSTR pwszURL,
                                       IDavTransport* pDavTransport)
{
    HRESULT hres = S_OK;
    IDavCallback* pCallback = NULL;
    IPropFindRequest* pFindReq = NULL;
    URL_COMPONENTS urlComponents = {0};

    if (pDavTransport == NULL || pwszURL == NULL)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
        urlComponents.dwUrlPathLength = 1;
            
        if (!InternetCrackUrl(pwszURL, 0, 0, &urlComponents))
        {
            hres = E_FAIL;
        }
        else
        {
            _cchRoot = urlComponents.dwUrlPathLength;
            _pGenLst = new CGenericList();
            if (_pGenLst == NULL)
            {
                hres = E_OUTOFMEMORY;
            }
            else
            {
                _dwDex = 0;
                _cElts = 0;
                pCallback = new CDavStorageEnumCallback();
                if (pCallback == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                else
                {
                    hres = ((CDavStorageEnumCallback*)pCallback)->Init((CDavStorageEnum*)this);
                    if (SUCCEEDED(hres))
                    {

                        hres = ::CoCreateInstance(CLSID_DAVPropFindReq, 
                                                  NULL, 
                                                  CLSCTX_INPROC_SERVER, 
                                                  IID_IPropFindRequest, 
                                                  (LPVOID*)&pFindReq);
                        if (SUCCEEDED(hres))
                        {
                            // don't put anything into the propfindrequest, that way we'll get all properties
                            hres = pDavTransport->CommandPROPFIND(pwszURL,
                                                                  pFindReq,
                                                                  1, // DWORD dwDepth,
                                                                  TRUE, // / * [in] * / BOOL fNoRoot,
                                                                  pCallback,
                                                                  (DWORD)pFindReq);
                        }
                    }
                }
            }
        }
    }
    
    return hres;
}

STDMETHODIMP CDavStorageEnumImpl::AddElement(LPWSTR pwszURL,
                                             STATSTG* pelt)
{
    HRESULT hres = S_OK;

    // BUGBUG: for now just add, in future we may need to do some merging
    hres = _pGenLst->Add(pwszURL,
                         pelt,
                         sizeof(STATSTG));

    if (SUCCEEDED(hres))
    {
        _cElts++;
    }

    return hres;
}

    // IEnumSTATSTG
STDMETHODIMP CDavStorageEnumImpl::Next(ULONG celt,           
                                       STATSTG * rgelt,      
                                       ULONG * pceltFetched)
{
    HRESULT hres = S_OK;
    STATSTG* pElt;
    UINT cbElt;

    // BUGBUG: ugly
    LPWSTR pwszHack = NULL;

    if (pceltFetched == NULL && celt != 1)
    {
        hres = E_INVALIDARG;
    }
    else
    {
        assert(_dwDex <= _cElts);
        if (_dwDex == _cElts) // all outta elts to give
        {
            hres = S_FALSE;
        }
        else
        {            
            for (DWORD i = 0; i < celt; i++)
            {
                hres = _pGenLst->FindByDex(i + _dwDex, (LPVOID*)&pElt, &cbElt);
                if (SUCCEEDED(hres))
                {
                    if (pElt == NULL || cbElt != sizeof(STATSTG))
                    {
                        hres = E_FAIL;
                    }
                    else
                    {
                        CopyMemory((LPVOID)(&(rgelt[i])), pElt, sizeof(STATSTG));
                        pwszHack = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + lstrlen(pElt->pwcsName) - _cchRoot));
                        lstrcpy(pwszHack, pElt->pwcsName + _cchRoot);
                        rgelt[i].pwcsName = pwszHack;                          
                    }
                }
                if (FAILED(hres))
                {
                    break;
                }
                if  ((i + _dwDex) >= _cElts)
                {
                    // not S_FALSE, we just want to return the ones we found
                    // next time we call Next, THEN we return S_FALSE
                    break;
                }
            }

            if (SUCCEEDED(hres))
            {        
                if (pceltFetched != NULL)
                {
                    *pceltFetched = i; // count number of entries we've copied
                    
                }
                _dwDex += i;
            }
        }
    }

    return hres;
}
 
STDMETHODIMP CDavStorageEnumImpl::Skip(ULONG celt)
{
    HRESULT hres = S_OK;

    if (_dwDex + celt >= _cElts)
    {
        hres = S_FALSE;
    }
    else
    {
        _dwDex += celt;
    }

    return hres;
}

 
STDMETHODIMP CDavStorageEnumImpl::Reset()
{
    HRESULT hres = S_OK;
    _dwDex = 0;
    
    return hres;
}
 
STDMETHODIMP CDavStorageEnumImpl::Clone(IEnumSTATSTG ** UNREF_PARAM(ppenum))
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\idl\makefile.inc ===
$(DAVTRANS_ROOT)\ifaces\idavstore.h: idavstore.h
    copy $** $@

$(DAVTRANS_ROOT)\davstore\lib\idavstore.tlb: idavstore.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\clsids.cpp ===
//
//   - Defines CLSID for the FTPSTORE
//
#include <objbase.h>

// {1C1AD6F2-95D8-4ac2-B6D8-C3E9B87A7693}
extern "C" const CLSID CLSID_CFtpStorage = 
{ 0x1c1ad6f2, 0x95d8, 0x4ac2, { 0xb6, 0xd8, 0xc3, 0xe9, 0xb8, 0x7a, 0x76, 0x93 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\ftpstoreu.cpp ===
#include <objbase.h>
#include "ftpstore.clsid.h"
#include "ftpstore.h"
#include "ftpstorn.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY ftpstorageIME[] =
{
    _INTFMAPENTRY(CFtpStorage, IDavStorage),
};

const INTFMAPENTRY* CFtpStorage::_pintfmap = ftpstorageIME;
const DWORD CFtpStorage::_cintfmap =
    (sizeof(ftpstorageIME)/sizeof(ftpstorageIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CFtpStorage::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\ftpstore.cpp ===
#include <objbase.h>
#include <assert.h>

#include "ftpstore.h"
#include "ftpstorn.h"

#include "davinet.clsid.h"
#include "davbagmn.clsid.h"
#include "httpstrm.clsid.h"
#include "davstore.clsid.h"
#include "ftpstore.clsid.h"

#include "idavinet.h"
#include "ihttpstrm.h"

#include "strconv.h"
#include "strutil.h"
#include "mischlpr.h"

#include <stdio.h>

//#define TRACE(a) (fprintf(stderr,"%d %s\n",GetTickCount(),a))
#define TRACE(a)

///////////////////////////////////////

CFtpStorageImpl::CFtpStorageImpl (): _pDavTransport(NULL), _grfStateBits(0), _fInit(FALSE), _pwszURL(NULL), _pwszUserName(NULL), _pwszPassword(NULL)

{
    TRACE("CDavStorage::CDavStorage");
}

///////////////////////////////////////

CFtpStorageImpl::~CFtpStorageImpl ()
{
    TRACE("CDavStorage::~CDavStorage");
    if (_pDavTransport != NULL)
    {
        _pDavTransport->Release();
    }
	if (_pwszURL != NULL)
    {
		free(_pwszURL);
	}
	if (_pwszUserName != NULL)
	{
		free(_pwszUserName);
	}
	if (_pwszPassword != NULL)
	{
		free(_pwszPassword);
	}
}

///////////////////////////////////////

LPWSTR __stdcall CFtpStorageImpl::_ResolveURL(LPWSTR pwszRootURL, LPWSTR pwszRelativeURL)
{
    LPWSTR pwszURL = NULL;
    ULONG cchRootURL;

    TRACE("CDavStorage::_ResolveURL");

    assert(pwszRootURL != NULL);
    assert(pwszRelativeURL != NULL);

    cchRootURL = lstrlen(pwszRootURL);
    if (pwszRootURL[cchRootURL-1] == '/')
    {
        // don't need to add an extra /
        pwszURL = AllocateStringW (cchRootURL + lstrlen(pwszRelativeURL)); // AllocateString auto-does the +1 for the NULL
        if (pwszURL != NULL)
        {
            lstrcpy(pwszURL, pwszRootURL);
            lstrcpy(pwszURL + cchRootURL, pwszRelativeURL);
        }
    }
    else
    {
        // we DO need to add an extra /
        pwszURL = AllocateStringW (cchRootURL + lstrlen(pwszRelativeURL) + 1); // +1 for the extra slash
        if (pwszURL != NULL)
        {
            lstrcpy(pwszURL, pwszRootURL);
            pwszURL[cchRootURL] = '/';
            lstrcpy(pwszURL + cchRootURL + 1, pwszRelativeURL);
        }
    }
    
    return pwszURL;
}

///////////////////////////////////////
STDMETHODIMP CFtpStorageImpl::Init(LPWSTR pwszURL,
                                   IDavTransport* pDavTransport)
{
    HRESULT hr = S_OK;
    TRACE("CDavStorage::Init");
    if (pwszURL == NULL || pDavTransport == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (_fInit == TRUE)
        {
            hr = E_FAIL;
        }
        else
        {
//            hr = pDavTransport->CommandHEAD(pwszURL, NULL, 0); // check if this is a URL to a valid place // DEBUG: replace check in the future

            if (SUCCEEDED(hr))
            {
                _pwszURL = DuplicateStringW(pwszURL);
                if (_pwszURL == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _pDavTransport = pDavTransport;                    
                    _pDavTransport->AddRef();
                    _fInit = TRUE;
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::SetAuth(LPWSTR pwszUserName,
                                      LPWSTR pwszPassword)
{
    HRESULT hr = S_OK;
    TRACE("CDavStorage::SetAuth");
    if (_pwszUserName != NULL)
    {
        free(_pwszUserName);
        _pwszUserName = NULL;
    }
    if (_pwszPassword != NULL)
    {
        free(_pwszPassword);
        _pwszPassword = NULL;
    }

    if (pwszUserName != NULL)
    {
        _pwszUserName = DuplicateStringW(pwszUserName);
        if (_pwszUserName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pwszPassword != NULL)
        {
            _pwszPassword = DuplicateStringW(pwszPassword);
            if (_pwszPassword == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }


    return hr;
}

/////////////////////////////////////
STDMETHODIMP CFtpStorageImpl::_GetStream(const WCHAR * pwcsName,  //Points to the name of the new stream
                                         DWORD grfMode,           //Access mode for the new stream
                                         IStream ** ppstm,        //Points to new stream object
                                         BOOL fCreate)
{
    HRESULT hr;    
    LPWSTR pwszURL;
    BOOL fTransacted;
    BOOL fDeleteOnRelease;
    
    TRACE("CDavStorage::_GetStream");
    // code
    assert(fInit);

    // open a HTTPStrm to that location, passing in _pDavTransport so that it can do the right thing
    CoInitialize(NULL);
    hr = ::CoCreateInstance(CLSID_HttpStrm, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IHttpStrm, 
                              (LPVOID*)ppstm);
    
    if (SUCCEEDED(hr))
    {
        hr = ((IHttpStrm*)*ppstm)->SetAuth(_pwszUserName, _pwszPassword);
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr))
            {
                pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
                if (pwszURL == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    // parse the grfMode
                    // BUGBUG: only things we can deal with are transacted and deleteonrelease
                    if (grfMode & STGM_TRANSACTED)
                    {
                        fTransacted = TRUE;
                    }
                    else
                    {
                        fTransacted = FALSE;
                    }
                    if (grfMode & STGM_DELETEONRELEASE)
                    {
                        fDeleteOnRelease = TRUE;
                    }
                    else
                    {
                        fDeleteOnRelease = FALSE;
                    }

                    hr = ((IHttpStrm*)*ppstm)->Open(pwszURL, 
                                                      !fTransacted, // direct mode?
                                                      fDeleteOnRelease, // delete when finished?
                                                      fCreate);
                }
            }
        }
    }
    return hr;
}

///////////////////////////////////

STDMETHODIMP CFtpStorageImpl::CreateStream(const WCHAR * pwcsName,  //Points to the name of the new stream
                                           DWORD grfMode,           //Access mode for the new stream
                                           DWORD reserved1,         //Reserved; must be zero
                                           DWORD reserved2,         //Reserved; must be zero
                                           IStream ** ppstm)        //Points to new stream object
{
    HRESULT hr = S_OK;

    TRACE("CDavStorage::CreateStream");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        // check params
        if (pwcsName == NULL || reserved1 != 0 || reserved2 != 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = this->_GetStream(pwcsName, grfMode, ppstm, TRUE);
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::OpenStream(const WCHAR * pwcsName,   //Points to name of stream to open
                                         void * reserved1,         //Reserved; must be NULL
                                         DWORD grfMode,            //Access mode for the new stream
                                         DWORD reserved2,          //Reserved; must be zero
                                         IStream ** ppstm)         //Address of output variable
                                                                   // that receives the IStream interface pointer
{
    HRESULT hr = S_OK;

    TRACE("CDavStorage::OpenStream");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        // check params
        if (pwcsName == NULL || reserved1 != NULL || reserved2 != 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // code
            // open a HTTPStrm to that location, passing in _pDavTransport so that it can do the right thing
            hr = this->_GetStream(pwcsName, grfMode, ppstm, FALSE);

        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::_OpenStorage(LPWSTR pwszURL,   //Points to the URL of the new storage object
                                           IStorage ** ppstg)       //Points to new storage object
{
    HRESULT hr;

    hr = ::CoCreateInstance(CLSID_CDavStorage, 
                            NULL, 
                            CLSCTX_INPROC_SERVER, 
                            IID_IDavStorage, 
                            (LPVOID*)ppstg);

    if (SUCCEEDED(hr))
    {
        hr = ((IDavStorage*)*ppstg)->Init(pwszURL, _pDavTransport);
        if (SUCCEEDED(hr))
        {
            hr = ((IDavStorage*)*ppstg)->SetAuth(_pwszUserName, _pwszPassword);
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::CreateStorage(const WCHAR * pwcsName,  //Points to the name of the new storage object
                                            DWORD UNREF_PARAM(grfMode),           //Access mode for the new storage object
                                            DWORD reserved1,         //Reserved; must be zero
                                            DWORD reserved2,         //Reserved; must be zero
                                            IStorage ** ppstg)       //Points to new storage object
{
    HRESULT hr = S_OK;
    LPWSTR pwszURL = NULL;

    TRACE("CDavStorage::CreateStorage");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else if (pwcsName == NULL  || ppstg == NULL || reserved1 != NULL || reserved2 != 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // code
        pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
        if (pwszURL == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = _pDavTransport->CommandMKCOL(pwszURL, NULL, 0);
            
            if (SUCCEEDED(hr))
            {                
                hr = this->_OpenStorage(pwszURL, ppstg);
            }
        }
    }

    return hr;
}
    
/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::OpenStorage(const WCHAR * pwcsName,   //Points to the name of the
                                                                    // storage object to open
                                          IStorage * pstgPriority,  //Must be NULL.
                                          DWORD UNREF_PARAM(grfMode),            //Access mode for the new storage object
                                          SNB snbExclude,           //Must be NULL.
                                          DWORD reserved,           //Reserved; must be zero
                                          IStorage ** ppstg)        //Points to opened storage object
{
    HRESULT hr = S_OK;
    LPWSTR pwszURL = NULL;

    TRACE("CDavStorage::OpenStorage");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else if (pwcsName == NULL  || ppstg == NULL || pstgPriority != NULL || snbExclude != NULL || reserved != 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
        if (pwszURL == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = this->_OpenStorage(pwszURL, ppstg);
        }
    }

    return hr;
}
        
/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::CopyTo(DWORD ciidExclude,         //Number of elements in rgiidExclude
                                     IID const * rgiidExclude,  //Array of interface identifiers (IIDs)
                                     SNB snbExclude,            //Points to a block of stream
                                                                // names in the storage object
                                     IStorage * pstgDest)       //Points to destination storage object
{
    HRESULT hr = S_OK;

    TRACE("CDavStorage::CopyTo");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if (ciidExclude > 0 || rgiidExclude != NULL || snbExclude != NULL || pstgDest == NULL)
        {
            hr = E_INVALIDARG; // BUGBUG: we don't support exclusion right now
        }
        else
        {
            hr = _pDavTransport->SetAuthentication(_pwszUserName, _pwszPassword);
            if (SUCCEEDED(hr))
            {
                hr = _pDavTransport->CommandCOPY(_pwszURL, ((CFtpStorageImpl*)pstgDest)->_pwszURL, DEPTH_INFINITY, TRUE, NULL, 0); // synchronous (no callback)                
            }
        }
    }
    
    return S_OK;
}
        
/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::MoveElementTo(const WCHAR * pwcsName,  //Name of the element to be moved
                                            IStorage * pstgDest,     //Points to destination storage object
                                            const WCHAR* pwcsNewName,      //Points to new name of element in destination
                                            DWORD UNREF_PARAM(grfFlags))          //Specifies a copy or a move
{
    HRESULT hr = S_OK;
    LPWSTR pwszSource = NULL;
    LPWSTR pwszDest = NULL;

    TRACE("CDavStorage::MoveElementTo");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if (pwcsName == NULL || pstgDest != NULL || pwcsNewName != NULL)
        {
            hr = E_INVALIDARG; 
        }
        else
        {
            pwszSource = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
            if (pwszSource == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pwszDest = this->_ResolveURL(((CFtpStorageImpl*)pstgDest)->_pwszURL, (LPWSTR)pwcsNewName);
                if (pwszDest == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = _pDavTransport->SetAuthentication(_pwszUserName, _pwszPassword);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pDavTransport->CommandMOVE(pwszSource, pwszDest, TRUE, NULL, 0);  // synchronous (no callback)
                    }
                }
            }            
        }
    }
    
    return S_OK;
}
            
/////////////////////////////////////

// IStorage::EnumElements
STDMETHODIMP CFtpStorageImpl::EnumElements(DWORD reserved1,        //Reserved; must be zero
                                           void * reserved2,       //Reserved; must be NULL
                                           DWORD reserved3,        //Reserved; must be zero
                                           IEnumSTATSTG ** ppenum) //Address of output variable that
                                                                   // receives the IEnumSTATSTG interface pointer
{
    HRESULT hr = S_OK;
    IEnumSTATSTG* pEnumObj = NULL;

    TRACE("CDavStorage::EnumElements");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        // check params
        if (reserved1 != 0 || reserved2 != NULL || reserved3 != 0 || ppenum == NULL)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // do some magic of issuing a PROPFIND, collecting all the responses, and packaging them into an IEnumSTATSTG
            hr = ::CoCreateInstance(CLSID_CDavStorageEnum, 
                                      NULL, 
                                      CLSCTX_INPROC_SERVER, 
                                      IID_IEnumSTATSTG, 
                                      (LPVOID*)&pEnumObj);
            if (SUCCEEDED(hr))
            {
                hr = ((CFtpStorageEnum*)pEnumObj)->Init(_pwszURL, _pDavTransport);
                if (SUCCEEDED(hr))
                {
                    *ppenum = pEnumObj;
                }
                else
                {
                    pEnumObj->Release();
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::DestroyElement(const WCHAR* pwcsName)  //Points to the name of the element to be removed
{
    HRESULT hr = S_OK;
    LPWSTR pwszURL = NULL;
    LPWSTR pwszDest = NULL;

    TRACE("CDavStorage::DestroyElement");
    if (_fInit != TRUE)
    {
        hr = E_FAIL;
    }
    else
    {
        if (pwcsName == NULL)
        {
            hr = E_INVALIDARG; 
        }
        else
        {
            pwszURL = this->_ResolveURL(_pwszURL, (LPWSTR)pwcsName);
            if (pwszURL == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = _pDavTransport->SetAuthentication(_pwszUserName, _pwszPassword);
                if (SUCCEEDED(hr))
                {
                    hr = _pDavTransport->CommandDELETE(pwszURL, NULL, 0);
                }
            }            
        }
    }
    
    return S_OK;
}

/////////////////////////////////////
        
STDMETHODIMP CFtpStorageImpl::RenameElement(const WCHAR * pwcsOldName,  //Points to the name of the
                                                                        // element to be changed
                                            const WCHAR * pwcsNewName)  //Points to the new name for
                                                                        // the specified element
{
    TRACE("CDavStorage::RenameElement");
    return this->MoveElementTo(pwcsOldName, this, (LPWSTR)pwcsNewName, 0); // BUGBUG: what should last param be?
}

/////////////////////////////////////
        
STDMETHODIMP CFtpStorageImpl::SetStateBits(DWORD grfStateBits,  //Specifies new values of bits
                                           DWORD grfMask)       //Specifies mask that indicates which
                                                                // bits are significant
{
    TRACE("CDavStorage::SetStateBits");
    _grfStateBits = _grfStateBits & !grfMask; // clear the elements of the mask
    _grfStateBits = _grfStateBits | (grfStateBits & grfMask); // elements of the mask in the grfStateBits copied to _grfStateBits    

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::Commit(DWORD UNREF_PARAM(grfCommitFlags))  //Specifies how changes are to be committed
{
    return E_NOTIMPL;  // first pass, we do everything synchronously to the server
}
    
/////////////////////////////////////

STDMETHODIMP CFtpStorageImpl::Revert(void)
{
    return E_NOTIMPL;  // first pass, we do everything synchronously to the server
}
    
/////////////////////////////////////
        
STDMETHODIMP CFtpStorageImpl::SetElementTimes(const WCHAR * UNREF_PARAM(pwcsName),   //Points to name of element to be changed
                                              FILETIME const * UNREF_PARAM(pctime),  //New creation time for element, or NULL
                                              FILETIME const * UNREF_PARAM(patime),  //New access time for element, or NULL
                                              FILETIME const * UNREF_PARAM(pmtime))  //New modification time for element, or NULL
{
    return E_NOTIMPL; // not the first time around
}

/////////////////////////////////////
        
STDMETHODIMP CFtpStorageImpl::SetClass(REFCLSID UNREF_PARAM(clsid))  //Class identifier to be assigned to the storage object
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////
        
STDMETHODIMP CFtpStorageImpl::Stat(STATSTG* UNREF_PARAM(pstatstg),  //Location for STATSTG structure
                                   DWORD UNREF_PARAM(grfStatFlag))  //Values taken from the STATFLAG enumeration
{
    return E_NOTIMPL; // not the first pass
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\davstore\tstdrv\tstdrv.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>

#include "davstore.clsid.h"
#include "idavstore.h"
#include "davinet.clsid.h"
#include "idavinet.h"
#include "mischlpr.h"

// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(int UNREF_PARAM(argc), char * UNREF_PARAM(argv[]))
{
    // locals
    HRESULT             hres;
    
    IDavStorage*      pStorage = NULL;
    IDavStorage*      pStorage2 = NULL;
    IDavTransport*    pDavTransport = NULL;
    IStream*          pStream = NULL;
    IStream*          pStream2 = NULL;
    IStream*          pStream3 = NULL;
    IEnumSTATSTG*     pEnum = NULL;

    STATSTG           statstg;
    DWORD             cFetched;
    BYTE rgb[10000];
    ULONG cbRead;
    ULONG cbWritten;
//    IEnumSTATSTG* penum;

    CoInitialize(NULL);
    hres = ::CoCreateInstance(CLSID_CDavStorage, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IDavStorage, 
        (LPVOID*)&pStorage);
    
    if (SUCCEEDED(hres))
    {
        hres = ::CoCreateInstance(CLSID_DAVInet, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_IDavTransport, 
            (LPVOID*)&pDavTransport);
        if (SUCCEEDED(hres))
        {                        
            hres = pDavTransport->SetAuthentication(L"aidan", L"grendel");
            
            if (SUCCEEDED(hres))
            {
                hres = pStorage->Init(L"http://aidanl:8088/dav/aidanl/", pDavTransport);
                if (SUCCEEDED(hres))
                {
/*                    hres = pStorage->EnumElements(0, NULL, 0, &penum);
                    if (SUCCEEDED(hres))
                    {
                    }
*/
                    hres = pStorage->OpenStream(L"cartman.txt", NULL, STGM_TRANSACTED, 0, &pStream);
                    if (SUCCEEDED(hres))
                    {
                        hres = pStream->Read(rgb, 10000, &cbRead);                
                        if (SUCCEEDED(hres))
                        {
                            hres = pStorage->CreateStream(L"eric.txt", STGM_TRANSACTED, 0, 0, &pStream2);
                            if (SUCCEEDED(hres))
                            {
                                hres = pStream2->Write(rgb, cbRead, &cbWritten);
                                if (SUCCEEDED(hres))
                                {
                                    hres = pStream2->Commit(0);
                                    if (SUCCEEDED(hres))
                                    {
                                        hres = pStorage->CreateStorage(L"ericdir", STGM_DIRECT, 0, 0, (IStorage**)&pStorage2);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pStorage2->CreateStream(L"eric.txt", STGM_TRANSACTED, 0, 0, &pStream3);
                                            if (SUCCEEDED(hres))
                                            {
                                                hres = pStream3->Write(rgb, cbRead, &cbWritten);
                                                if (SUCCEEDED(hres))
                                                {
                                                    hres = pStream3->Commit(0);
                                                    if (SUCCEEDED(hres))
                                                    {
                                                        hres = pStorage->EnumElements(0, NULL, 0, &pEnum);
                                                        if (SUCCEEDED(hres))
                                                        {
                                                            hres = pEnum->Next(1, &statstg, &cFetched);
                                                            if (SUCCEEDED(hres))
                                                            {
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                }
            }
        }
    }
    
    // release stuff
    if (pStream3 != NULL)
    {
        pStream3->Release();
    }
    if (pStream2 != NULL)
    {
        pStream2->Release();
    }
    if (pStream != NULL)
    {
        pStream->Release();
    }
    if (pStorage2 != NULL)
    {
        pStorage2->Release();
    }
    if (pStorage != NULL)
    {
        pStorage->Release();
    }
    if (pDavTransport != NULL)
    {
        pDavTransport->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "ftpstore.clsid.h"
#include "ftpstore.h"

CFactoryData g_FactoryDataArray[] =
{
    { &CLSID_CFtpStorage, 
      CFtpStorage::UnkCreateInstance, 
      CFtpStorage::UnkActiveComponents, 
      L"Ftp IStorage",     // Friendly name
      L"FtpStore.1",                  // ProgID
      L"FtpStore",                    // Version-independent
      TRUE},                         // ThreadingModel == Both
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\clsidslib\makefile.inc ===
$(DAVTRANS_ROOT)\clsids\lib\ftpstore_g.lib: $(O)\ftpstore_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\ftpstore.h ===
#ifndef __FTPSTORE_H
#define __FTPSTORE_H

#include <objbase.h>
#include "unk.h"
#include "idavstore.h"

interface IDavTransport;

class CFtpStorageImpl : public CCOMBase, public IDavStorage
{
private:
public:
    CFtpStorageImpl ();
    ~CFtpStorageImpl ();
    
    ///////////////////////////////////////////////////////////
    // IDavStorage
    STDMETHODIMP Init(LPWSTR pwszURL,
                 IDavTransport* pDavTransport);

    STDMETHODIMP SetAuth(LPWSTR pwszUserName,
                         LPWSTR pwszPassword);

    ///////////////////////////////////////////////////////////
    // IStorage
    STDMETHODIMP CreateStream(
        const WCHAR * pwcsName,  //Points to the name of the new stream
        DWORD grfMode,           //Access mode for the new stream
        DWORD reserved1,         //Reserved; must be zero
        DWORD reserved2,         //Reserved; must be zero
        IStream ** ppstm);       //Points to new stream object

    STDMETHODIMP OpenStream(
        const WCHAR * pwcsName,   //Points to name of stream to open
        void * reserved1,         //Reserved; must be NULL
        DWORD grfMode,            //Access mode for the new stream
        DWORD reserved2,          //Reserved; must be zero
        IStream ** ppstm);        //Address of output variable
        // that receives the IStream interface pointer

    STDMETHODIMP CreateStorage(
        const WCHAR * pwcsName,  //Points to the name of the new storage object
        DWORD grfMode,           //Access mode for the new storage object
        DWORD reserved1,         //Reserved; must be zero
        DWORD reserved2,         //Reserved; must be zero
        IStorage ** ppstg);      //Points to new storage object
    
    STDMETHODIMP OpenStorage(
        const WCHAR * pwcsName,   //Points to the name of the
                                  // storage object to open
        IStorage * pstgPriority,  //Must be NULL.
        DWORD grfMode,            //Access mode for the new storage object
        SNB snbExclude,           //Must be NULL.
        DWORD reserved,           //Reserved; must be zero
        IStorage ** ppstg);       //Points to opened storage object
        
    STDMETHODIMP CopyTo(
        DWORD ciidExclude,         //Number of elements in rgiidExclude
        IID const * rgiidExclude,  //Array of interface identifiers (IIDs)
        SNB snbExclude,            //Points to a block of stream
        // names in the storage object
        IStorage * pstgDest);      //Points to destination storage object
        
    STDMETHODIMP MoveElementTo(
        const WCHAR * pwcsName,  //Name of the element to be moved
        IStorage * pstgDest,     //Points to destination storage object IStorage
        const WCHAR * pwcsNewName,      //Points to new name of element in destination
        DWORD grfFlags);         //Specifies a copy or a move
            
    STDMETHODIMP Commit(DWORD grfCommitFlags);  //Specifies how changes are to be committed
    
    STDMETHODIMP Revert(void);
    
    STDMETHODIMP EnumElements(
        DWORD reserved1,        //Reserved; must be zero
        void * reserved2,       //Reserved; must be NULL
        DWORD reserved3,        //Reserved; must be zero
        IEnumSTATSTG ** ppenum);//Address of output variable that
                                // receives the IEnumSTATSTG interface pointer

    STDMETHODIMP DestroyElement(const WCHAR* pwcsName);  //Points to the name of the element to be removed
        
    STDMETHODIMP RenameElement(
        const WCHAR * pwcsOldName,  //Points to the name of the
                                    // element to be changed
        const WCHAR * pwcsNewName); //Points to the new name for
                                    // the specified element
        
    STDMETHODIMP SetElementTimes(
        const WCHAR * pwcsName,   //Points to name of element to be changed
        FILETIME const * pctime,  //New creation time for element, or NULL
        FILETIME const * patime,  //New access time for element, or NULL
        FILETIME const * pmtime); //New modification time for element, or NULL
        
    STDMETHODIMP SetClass(REFCLSID clsid);  //Class identifier to be assigned to the storage object
        
    STDMETHODIMP SetStateBits(
        DWORD grfStateBits,  //Specifies new values of bits
        DWORD grfMask);      //Specifies mask that indicates which
                             // bits are significant
        
    STDMETHODIMP Stat(
        STATSTG * pstatstg,  //Location for STATSTG structure
        DWORD grfStatFlag);  //Values taken from the STATFLAG enumeration
        
private:
    // internal utility functions
    LPWSTR __stdcall _ResolveURL(LPWSTR pwszRootURL, LPWSTR pwszRelativeURL);
    STDMETHODIMP _GetStream(const WCHAR * pwcsName,  //Points to the name of the new stream
                            DWORD grfMode,           //Access mode for the new stream
                            IStream ** ppstm,        //Points to new stream object
                            BOOL fCreate);

    STDMETHODIMP _OpenStorage(LPWSTR pwszURL,   //Points to the URL of the new storage object
                              IStorage ** ppstg);       //Points to new storage object


private:
    // member variables
    IDavTransport*      _pDavTransport;
    LPWSTR              _pwszURL;
    LPWSTR              _pwszUserName;
    LPWSTR              _pwszPassword;
    BOOL                _fInit;
    DWORD               _grfStateBits;
};

typedef CUnkTmpl<CFtpStorageImpl> CFtpStorage;

#endif // __FTPSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\ftpstorn.h ===
#ifndef __DAVSTORN_H
#define __DAVSTORN_H

#include <objbase.h>
#include "unk.h"
#include "generlst.h"

class CFtpStorageEnumImpl : public CCOMBase, public IEnumSTATSTG {

public:    
    CFtpStorageEnumImpl();
    ~CFtpStorageEnumImpl();

    // IEnumSTATSTG
    STDMETHODIMP Next(ULONG celt,           
                      STATSTG * rgelt,      
                      ULONG * pceltFetched);
 
    STDMETHODIMP Skip(ULONG celt);
 
    STDMETHODIMP Reset();
 
    STDMETHODIMP Clone(IEnumSTATSTG ** ppenum);

    // Extra methods, not in the interface
    STDMETHODIMP Init(LPWSTR pwszURL,
                      IDavTransport* pDavTransport);
    
    // caller is responsible for allocating the space for this element!
    STDMETHODIMP AddElement(LPWSTR pwszURL,
                            STATSTG* pelt);


private:
    DWORD _dwDex;
    DWORD _cElts;
    CGenericList* _pGenLst;
    DWORD _cchRoot; // number of characters in the path of the root of this enum
};

typedef CUnkTmpl<CFtpStorageEnumImpl> CFtpStorageEnum;


#endif // __DAVSTORN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\ftpstorn.cpp ===
#include <objbase.h>
#include <assert.h>
#include <wininet.h>

#include "ftpstore.h"
#include "ftpstorn.h"

#include "davinet.clsid.h"
#include "davbagmn.clsid.h"
#include "httpstrm.clsid.h"
#include "davstore.clsid.h"
#include "ftpstore.clsid.h"

#include "idavinet.h"
#include "ihttpstrm.h"

#include "timeconv.h"
#include "strconv.h"
#include "strutil.h"
#include "mischlpr.h"

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

class CFtpStorageEnumCallback : public CCOMBase, public IDavCallback {

public:    
    CFtpStorageEnumCallback();
    ~CFtpStorageEnumCallback();
    
    // client gives the callback a pointer to a place to stick the result
    STDMETHODIMP Init(CFtpStorageEnum* pEnumObj); 
    
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);

    ULONG STDMETHODCALLTYPE AddRef();
	
    ULONG STDMETHODCALLTYPE Release();

    STDMETHODIMP OnAuthChallenge( TCHAR szUserName[ 255 ],
                                  TCHAR szPassword[ 255 ]);
        
    STDMETHODIMP OnResponse(DAVRESPONSE* pResponse);

private:
    STDMETHODIMP _ConvertCreationDate(LPWSTR pwszDate, FILETIME* ptime);
    STDMETHODIMP _ConvertModifiedDate(LPWSTR pwszDate, FILETIME* ptime);

private:
    LONG _cRef;
    CFtpStorageEnum* _pEnumObj; // we pass back the result through here
};

  
CFtpStorageEnumCallback::CFtpStorageEnumCallback(): _pEnumObj(NULL)
{}

CFtpStorageEnumCallback::~CFtpStorageEnumCallback()
{
    if (_pEnumObj != NULL)
    {
        _pEnumObj->Release();
    }
}

STDMETHODIMP CFtpStorageEnumCallback::Init(CFtpStorageEnum* pEnumObj)
{
    HRESULT hr = S_OK;

    if (pEnumObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _pEnumObj = pEnumObj;
        _pEnumObj->AddRef();
    }
    return hr;
}

// boilerplate COM stuff
STDMETHODIMP CFtpStorageEnumCallback::QueryInterface(REFIID iid, void** ppv)
{
    // locals
    HRESULT hr = S_OK;

    // code
    if (iid != IID_IDavCallback && iid != IID_IUnknown) // only interface we ement
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppv = static_cast<IDavCallback*>(this);
    }

    return hr;
}

ULONG STDMETHODCALLTYPE CFtpStorageEnumCallback::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
	
ULONG STDMETHODCALLTYPE CFtpStorageEnumCallback::Release()
{
    // locals
    UINT t;    

    // code
    t = ::InterlockedDecrement(&_cRef);
    if (t==0)
    {
        delete this;
    }    
    return t;
}
// end boilerplate COM stuff


STDMETHODIMP CFtpStorageEnumCallback::OnAuthChallenge( TCHAR __RPC_FAR UNREF_PARAM(szUserName)[255],
                                                  TCHAR __RPC_FAR UNREF_PARAM(szPassword)[255])
{
    return E_NOTIMPL;
}

STDMETHODIMP CFtpStorageEnumCallback::_ConvertCreationDate(LPWSTR pwszDate, 
                                                           FILETIME* ptime)
{
    // creation date is in format: "1999-12-16T00:35:35Z"
    HRESULT hr = S_OK;

    hr = ConvertTime(L"%Y-%m-%D%i%H:%N:%S%i", pwszDate, ptime);

    return hr;
}

STDMETHODIMP CFtpStorageEnumCallback::_ConvertModifiedDate(LPWSTR pwszDate, 
                                                           FILETIME* ptime)
{
    // modification date is in format: "Tue, 14 Dec 1999 00:56:26 GMT"
    HRESULT hr = S_OK;

    hr = ConvertTime(L"%I %D %M %Y %H:%N:%S %I", pwszDate, ptime);

    return hr;
}

HRESULT STDMETHODCALLTYPE CFtpStorageEnumCallback::OnResponse( /* [in] */ DAVRESPONSE __RPC_FAR * pResponse)
{
    HRESULT hr = S_OK;
    STATSTG* pStats = NULL;
    UINT i;

    // flags that tell us if we've got each one of these things yet
    BOOL fcbSize = FALSE;
    BOOL fmtime = FALSE;
    BOOL fctime = FALSE;

    if (_pEnumObj != NULL)
    {
        hr = pResponse->hrResult;
        if (SUCCEEDED(hr))
        {
            if (pResponse->command == DAV_PROPFIND)
            {
                // we'll get one callback for each item with all the properties of that item
                if (pResponse->rPropFind.pwszHref != NULL)
                {
                    // collect the href and other appropriate properties
                    pStats = (STATSTG*)malloc(sizeof(STATSTG));
                    if (pStats == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        // BUGBUG: check to see that string is desired
                        pStats->pwcsName = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + lstrlen(pResponse->rPropFind.pwszHref)));                        
                        if (pStats->pwcsName == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            lstrcpy(pStats->pwcsName, pResponse->rPropFind.pwszHref);
                            if (pStats->pwcsName[lstrlen(pStats->pwcsName) - 1] == '/')
                            {
                                pStats->type = STGTY_STORAGE;
                            }
                            else
                            {
                                pStats->type = STGTY_STREAM;
                            }

                            for (i = 0; i < pResponse->rPropFind.cPropVal; i+=2) 
                                // because we did a propfind without any properties filled in,
                                // we get all the properties in name/value pairs
                            {
                                // Enum supports the following:
                                //  pStats->pwcsName
                                //  pStats->type
                                //  pStats->cbSize
                                //  pStats->mtime
                                //  pStats->ctime
                                //
                                // if we don't get them all, then we don't insert it at all

                                if (pResponse->rPropFind.rgPropVal[i].dpt != DPT_LPWSTR)
                                {
                                    hr = E_FAIL;
                                }
                                else if (lstrcmpi(pResponse->rPropFind.rgPropVal[i].pwszVal, L"DAV:creationdate") == 0)
                                {
                                    hr = this->_ConvertCreationDate(pResponse->rPropFind.rgPropVal[i+1].pwszVal, &(pStats->ctime));
                                    fctime = TRUE;
                                }
                                else if (lstrcmpi(pResponse->rPropFind.rgPropVal[i].pwszVal, L"DAV:getcontentlength") == 0)
                                {
                                    pStats->cbSize.LowPart = _wtoi(pResponse->rPropFind.rgPropVal[i+1].pwszVal);
                                    pStats->cbSize.HighPart = 0;
                                    fcbSize = TRUE;
                                }
                                else if (lstrcmpi(pResponse->rPropFind.rgPropVal[i].pwszVal, L"DAV:getlastmodified") == 0)
                                {    
                                    hr = this->_ConvertModifiedDate(pResponse->rPropFind.rgPropVal[i+1].pwszVal, &(pStats->ctime));
                                    fmtime = TRUE;
                                }
                            }


                            // Enum doesn't support the following:
                            //  pStats->grfMode
                            //
                            // we don't support the following:
                            //  pStats->atime
                            //  pStats->grfLocksSupported
                            //  pStats->clsid
                            //  pStats->grfStateBits
                            //  pStats->reserved 
                            
                            // add them all to the enum object in one sweep, if we got all the data we need
                            if (SUCCEEDED(hr) && fctime && fmtime && (fcbSize || pStats->type == STGTY_STORAGE))
                            {
                                hr = _pEnumObj->AddElement(pStats->pwcsName, pStats);
                            }                                    
                        }
                    }
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

CFtpStorageEnumImpl::CFtpStorageEnumImpl()
{
}

CFtpStorageEnumImpl::~CFtpStorageEnumImpl()
{
}

// Extra methods

STDMETHODIMP CFtpStorageEnumImpl::Init(LPWSTR pwszURL,
                                       IDavTransport* pDavTransport)
{
    HRESULT hr = S_OK;
    IDavCallback* pCallback = NULL;
    IPropFindRequest* pFindReq = NULL;
    URL_COMPONENTS urlComponents = {0};

    if (pDavTransport == NULL || pwszURL == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
        urlComponents.dwUrlPathLength = 1;
            
        if (!InternetCrackUrl(pwszURL, 0, 0, &urlComponents))
        {
            hr = E_FAIL;
        }
        else
        {
            _cchRoot = urlComponents.dwUrlPathLength;
            _pGenLst = new CGenericList();
            if (_pGenLst == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _dwDex = 0;
                _cElts = 0;
                pCallback = new CFtpStorageEnumCallback();
                if (pCallback == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = ((CFtpStorageEnumCallback*)pCallback)->Init((CFtpStorageEnum*)this);
                    if (SUCCEEDED(hr))
                    {

                        hr = ::CoCreateInstance(CLSID_DAVPropFindReq, 
                                                  NULL, 
                                                  CLSCTX_INPROC_SERVER, 
                                                  IID_IPropFindRequest, 
                                                  (LPVOID*)&pFindReq);
                        if (SUCCEEDED(hr))
                        {
                            // don't put anything into the propfindrequest, that way we'll get all properties
                            hr = pDavTransport->CommandPROPFIND(pwszURL,
                                                                  pFindReq,
                                                                  1, // DWORD dwDepth,
                                                                  TRUE, // / * [in] * / BOOL fNoRoot,
                                                                  pCallback,
                                                                  (DWORD)pFindReq);
                        }
                    }
                }
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CFtpStorageEnumImpl::AddElement(LPWSTR pwszURL,
                                             STATSTG* pelt)
{
    HRESULT hr = S_OK;

    // BUGBUG: for now just add, in future we may need to do some merging
    hr = _pGenLst->Add(pwszURL,
                         pelt,
                         sizeof(STATSTG));

    if (SUCCEEDED(hr))
    {
        _cElts++;
    }

    return hr;
}

    // IEnumSTATSTG
STDMETHODIMP CFtpStorageEnumImpl::Next(ULONG celt,           
                                       STATSTG * rgelt,      
                                       ULONG * pceltFetched)
{
    HRESULT hr = S_OK;
    STATSTG* pElt;
    UINT cbElt;

    // BUGBUG: ugly
    LPWSTR pwszHack = NULL;

    if (pceltFetched == NULL && celt != 1)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        assert(_dwDex <= _cElts);
        if (_dwDex == _cElts) // all outta elts to give
        {
            hr = S_FALSE;
        }
        else
        {            
            for (DWORD i = 0; i < celt; i++)
            {
                hr = _pGenLst->FindByDex(i + _dwDex, (LPVOID*)&pElt, &cbElt);
                if (SUCCEEDED(hr))
                {
                    if (pElt == NULL || cbElt != sizeof(STATSTG))
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        CopyMemory((LPVOID)(&(rgelt[i])), pElt, sizeof(STATSTG));
                        pwszHack = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (1 + lstrlen(pElt->pwcsName) - _cchRoot));
                        lstrcpy(pwszHack, pElt->pwcsName + _cchRoot);
                        rgelt[i].pwcsName = pwszHack;                          
                    }
                }
                if (FAILED(hr))
                {
                    break;
                }
                if  ((i + _dwDex) >= _cElts)
                {
                    // not S_FALSE, we just want to return the ones we found
                    // next time we call Next, THEN we return S_FALSE
                    break;
                }
            }

            if (SUCCEEDED(hr))
            {        
                if (pceltFetched != NULL)
                {
                    *pceltFetched = i; // count number of entries we've copied
                    
                }
                _dwDex += i;
            }
        }
    }

    return hr;
}
 
STDMETHODIMP CFtpStorageEnumImpl::Skip(ULONG celt)
{
    HRESULT hr = S_OK;

    if (_dwDex + celt >= _cElts)
    {
        hr = S_FALSE;
    }
    else
    {
        _dwDex += celt;
    }

    return hr;
}

 
STDMETHODIMP CFtpStorageEnumImpl::Reset()
{
    HRESULT hr = S_OK;
    _dwDex = 0;
    
    return hr;
}
 
STDMETHODIMP CFtpStorageEnumImpl::Clone(IEnumSTATSTG ** UNREF_PARAM(ppenum))
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstore\tstdrv\tstdrv.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>

#include "ftpstore.clsid.h"
#include "idavstore.h"
#include "davinet.clsid.h"
#include "idavinet.h"
#include "mischlpr.h"

// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(int UNREF_PARAM(argc), char * UNREF_PARAM(argv[]))
{
    // locals
    HRESULT             hres;
    
    IDavStorage*      pStorage = NULL;
    IDavStorage*      pStorage2 = NULL;
    IDavTransport*    pDavTransport = NULL;
    IStream*          pStream = NULL;
    IStream*          pStream2 = NULL;
    IStream*          pStream3 = NULL;
    IEnumSTATSTG*     pEnum = NULL;

    STATSTG           statstg;
    DWORD             cFetched;
    BYTE rgb[10000];
    ULONG cbRead;
    ULONG cbWritten;
//    IEnumSTATSTG* penum;

    CoInitialize(NULL);
    hres = ::CoCreateInstance(CLSID_CFtpStorage, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IDavStorage, 
        (LPVOID*)&pStorage);
    
    if (SUCCEEDED(hres))
    {
        hres = ::CoCreateInstance(CLSID_DAVInet, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_IDavTransport, 
            (LPVOID*)&pDavTransport);
        if (SUCCEEDED(hres))
        {                        
            hres = pDavTransport->SetAuthentication(L"aidan", L"grendel");
            
            if (SUCCEEDED(hres))
            {
                hres = pStorage->Init(L"http://aidanl:8088/dav/aidanl/", pDavTransport);
                if (SUCCEEDED(hres))
                {
/*                    hres = pStorage->EnumElements(0, NULL, 0, &penum);
                    if (SUCCEEDED(hres))
                    {
                    }
*/
                    hres = pStorage->OpenStream(L"cartman.txt", NULL, STGM_TRANSACTED, 0, &pStream);
                    if (SUCCEEDED(hres))
                    {
                        hres = pStream->Read(rgb, 10000, &cbRead);                
                        if (SUCCEEDED(hres))
                        {
                            hres = pStorage->CreateStream(L"eric.txt", STGM_TRANSACTED, 0, 0, &pStream2);
                            if (SUCCEEDED(hres))
                            {
                                hres = pStream2->Write(rgb, cbRead, &cbWritten);
                                if (SUCCEEDED(hres))
                                {
                                    hres = pStream2->Commit(0);
                                    if (SUCCEEDED(hres))
                                    {
                                        hres = pStorage->CreateStorage(L"ericdir", STGM_DIRECT, 0, 0, (IStorage**)&pStorage2);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pStorage2->CreateStream(L"eric.txt", STGM_TRANSACTED, 0, 0, &pStream3);
                                            if (SUCCEEDED(hres))
                                            {
                                                hres = pStream3->Write(rgb, cbRead, &cbWritten);
                                                if (SUCCEEDED(hres))
                                                {
                                                    hres = pStream3->Commit(0);
                                                    if (SUCCEEDED(hres))
                                                    {
                                                        hres = pStorage->EnumElements(0, NULL, 0, &pEnum);
                                                        if (SUCCEEDED(hres))
                                                        {
                                                            hres = pEnum->Next(1, &statstg, &cFetched);
                                                            if (SUCCEEDED(hres))
                                                            {
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                }
            }
        }
    }
    
    // release stuff
    if (pStream3 != NULL)
    {
        pStream3->Release();
    }
    if (pStream2 != NULL)
    {
        pStream2->Release();
    }
    if (pStream != NULL)
    {
        pStream->Release();
    }
    if (pStorage2 != NULL)
    {
        pStorage2->Release();
    }
    if (pStorage != NULL)
    {
        pStorage->Release();
    }
    if (pDavTransport != NULL)
    {
        pDavTransport->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\clsids.cpp ===
//
//   - Defines CLSID for SimpleStream
//
#include <objbase.h>

// {53AF2500-DC58-41fb-BF2A-73B52B28ABF1}
extern "C" CLSID CLSID_FtpStrm = 
{ 0x53af2500, 0xdc58, 0x41fb, { 0xbf, 0x2a, 0x73, 0xb5, 0x2b, 0x28, 0xab, 0xf1 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\useful.h ===
#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
// macros

// the size of an array is its total size divided by the size of its first element
#define ARRAYSIZE(_rg)  (sizeof((_rg)) / sizeof((_rg)[0]))

// free a pointer only if it is null: 
// note, this may hide errors, you may want to assert if it's not null, or something

#define SAFEFREE(x) \
    if ((x) != NULL) \
    { \
    free((x)); \
    } \
    else
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\ftpstrmu.cpp ===
#include "ftpstrm.h"
#include "ihttpstrm.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY ftpstrmIME[] =
{
    _INTFMAPENTRY(CFtpStrm, IHttpStrm),
};

const INTFMAPENTRY* CFtpStrm::_pintfmap = ftpstrmIME;
const DWORD CFtpStrm::_cintfmap =
    (sizeof(ftpstrmIME)/sizeof(ftpstrmIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CFtpStrm::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\ftpstrm.cpp ===
///////////////////////////////////////////////////////////////////////////////
// includes

#include <objbase.h>
#include <wchar.h>
#include <assert.h>
#include <wininet.h>

#include "ftpstrm.h"
#include "mischlpr.h"
#include "strutil.h"
#include <stdio.h>
//#define TRACE(a) (fprintf(stderr,"%d %s\n",GetTickCount(),a))
#define TRACE(a)

//////////////////////////////////////////////////////////////////////////////

CFtpStrmImpl::CFtpStrmImpl(): _hLocalFile(NULL), _hInternet(NULL), _pwszURL(NULL), _pwszLocalFile(NULL),
                              _pwszUserName(NULL), _pwszPassword(NULL)
{
    TRACE("CFtpStrm::CFtpStrm");
}

CFtpStrmImpl::~CFtpStrmImpl() 
{
    TRACE("CFtpStrm::~CFtpStrm");
    if (_hLocalFile != NULL)
    {
        CloseHandle(_hLocalFile);
    }
    if (_hInternet != NULL)
    {
        InternetCloseHandle(_hInternet);
    }
    if (_pwszURL != NULL)
    {
        free(_pwszURL);
    }
    if (_pwszLocalFile != NULL)
    {
        free(_pwszLocalFile);
    }
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFtpStrmImpl::_DuplicateFileURL(LPWSTR pwszURL,
                                              LPWSTR* ppwszWin32FName)
{
    HRESULT hr = S_OK;

    TRACE("CFtpStrm::_DuplicateFileURL");
    assert(LStrCmpN(pwszURL, L"file:///", 8) == 0);

    *ppwszWin32FName = DuplicateStringW(pwszURL+8);
    if (*ppwszWin32FName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {        
        // change the forward slashes into backslashes, to turn the URL into a win32 filepath
        // could use shlwapi, but shlwapi is big and we don't need to bring it all in
        UINT i = 0;
        while (*ppwszWin32FName[i] != NULL)
        {
            if (*ppwszWin32FName[i] == '/')
            {
                *ppwszWin32FName[i] = '\\';
            }
            i++;
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IHttpStrm methods

STDMETHODIMP CFtpStrmImpl::_OpenRemoteTransacted(BOOL fCreate)       // path to file to base stream on
{
    HINTERNET hSession;
    HRESULT hr = S_OK;
    WCHAR wszTempFname[MAX_PATH];
    WCHAR wszTempPath[MAX_PATH];
    ULONG cbRead;
    ULONG cbWritten;
    BYTE rgb[4096];
    DWORD dwStatusCode;
    LPWSTR pwszServer = NULL;
    LPWSTR pwszPath = NULL;
    INTERNET_PORT nPort = INTERNET_DEFAULT_FTP_PORT;
    URL_COMPONENTS urlComponents = {0};

    TRACE("CFtpStrm::_OpenRemoteTransacted");

    
    urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
    urlComponents.dwHostNameLength = 1;
    urlComponents.dwUrlPathLength = 1;
    urlComponents.nPort = 1;
    if (!InternetCrackUrl(_pwszURL, 0, 0, &urlComponents))
    {
        hr = E_FAIL;
    }
    else
    {
        pwszServer = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwHostNameLength));
        if (!pwszServer)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            lstrcpyn(pwszServer, urlComponents.lpszHostName, 1 + urlComponents.dwHostNameLength); // +1 for the final null char
                        
            pwszPath = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwUrlPathLength - 1));            
            if (!pwszPath)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpyn(pwszPath, urlComponents.lpszUrlPath + 1, 1 + urlComponents.dwUrlPathLength); // +1 for the final null char
                
                if (urlComponents.nPort != 0)
                {
                    nPort = urlComponents.nPort;
                }

                // PERF: should we use dwFlags here?
                hSession = InternetConnect(_hInternet, pwszServer, nPort, 
                                           _pwszUserName, _pwszPassword, INTERNET_SERVICE_FTP, 0, 0);
                if (hSession == NULL)
                {
                    hr = E_FAIL;
                }
                else
                {
                    // copy the file to a local temp file, set _hLocalFile to be equal to that file
                    if (GetTempPath(MAX_PATH, wszTempPath) == 0)
                    {
                        hr = E_FAIL;
                    }
                    else if (GetTempFileName(wszTempPath, L"FTP", 0, wszTempFname) == 0)
                    {
                        hr = E_FAIL;
                    }
                    else 
/*						HINTERNET hFile = FtpOpenFile(hSession, pwszPath, GENERIC_READ, FTP_TRANSFER_TYPE_UNKNOWN, 0);
						if (!hFile)
						{
							hr = E_FAIL;
							DWORD dw = GetLastError();
							HRESULT hres2 = HRESULT_FROM_WIN32(dw);
						}
						else
						{
							WCHAR szBuf[10000];
							BOOL fAidan;
							DWORD cbRead;
							fAidan = InternetReadFile(hFile, szBuf, sizeof(szBuf), &cbRead);

						}*/

					
					if (!FtpGetFile(hSession, pwszPath, wszTempFname, FALSE, 0, FTP_TRANSFER_TYPE_UNKNOWN, 0))
                    {
                        DWORD dw = GetLastError();
						hr = E_FAIL;
                    }
                    else
                    {
                        _pwszLocalFile = DuplicateStringW(wszTempFname);
						if (!_pwszLocalFile)
						{
							hr = E_OUTOFMEMORY;
						}
						else
						{
							_hLocalFile = CreateFile(_pwszLocalFile, GENERIC_READ | GENERIC_WRITE, 
								0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
							if (_hLocalFile == INVALID_HANDLE_VALUE)
							{
								hr = E_FAIL;
							}
						}

                    }
                }
                free(pwszPath);
            }
            free(pwszServer);
        }

        InternetCloseHandle(hSession);
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFtpStrmImpl::_OpenLocalDirect(BOOL fCreate, BOOL fDeleteWhenDone)  // should we remove this file after closing the stream?
{
    HRESULT hr = S_OK;

    // we've been handed a local file URL and we should open it for direct access
    DWORD dwFileAttributes;
    DWORD dwCreation;

    TRACE("CFtpStrm::_OpenLocalDirect");

    if (fDeleteWhenDone && !fCreate)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (fDeleteWhenDone)
        {
            dwFileAttributes = FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE;
        }
        else
        {
            dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        if (fCreate)
        {
            dwCreation = CREATE_ALWAYS;
        }
        else
        {
            dwCreation = OPEN_EXISTING;
        }

        // -- open the file
        _hLocalFile = CreateFile(_pwszURL + 8, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ,  // +8 to skip file:///
                                 NULL, dwCreation, dwFileAttributes, NULL);
    
        if (_hLocalFile == INVALID_HANDLE_VALUE)
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFtpStrmImpl::_OpenLocalTransacted(BOOL fCreate, BOOL fDeleteWhenDone)  // should we remove this file after closing the stream?
                                                                                     // must be FALSE for ftp:// pwszPath
{
    HRESULT hr = S_OK;
    WCHAR wszTempFname[MAX_PATH];
    WCHAR wszTempPath[MAX_PATH];
    HANDLE hNewFile;

    TRACE("CFtpStrm::_OpenLocalTransacted");

    if (!fCreate && fDeleteWhenDone)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // copy the file to a local temp file, set _hLocalFile to be equal to that file
        if (GetTempPath(MAX_PATH, wszTempPath) == 0)
        {
            hr = E_FAIL;
        }
        else if (GetTempFileName(wszTempPath, L"FTP", 0, wszTempFname) == 0)
        {
            hr = E_FAIL;
        }
        else
        {
            if (!fCreate)
            {
                // copy the file, in the process checking if it exists
                if (CopyFile(_pwszURL + 8, wszTempFname, FALSE))
                {
                    _pwszLocalFile = DuplicateStringW(wszTempFname);

                    _hLocalFile = CreateFile(wszTempFname, GENERIC_READ | GENERIC_WRITE, 0,
                                             NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
                    if (_hLocalFile == INVALID_HANDLE_VALUE)
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                // create a new file
                _pwszLocalFile = DuplicateStringW(wszTempFname);
                
                hNewFile = CreateFile(_pwszURL + 8, GENERIC_WRITE, 0,
                                      NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (hNewFile == INVALID_HANDLE_VALUE)
                {
                    hr = E_FAIL;
                }
                else
                {
                    CloseHandle(hNewFile);
                    _hLocalFile = CreateFile(wszTempFname, GENERIC_READ | GENERIC_WRITE, 0,
                                             NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
                    if (_hLocalFile == INVALID_HANDLE_VALUE)
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        // everything is fine, seek back to beginning
                        if (SetFilePointer(_hLocalFile,
                                           0,
                                           NULL,
                                           FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                        {
                            hr = E_FAIL;
                        }
                    }
                }
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFtpStrmImpl::Open(LPWSTR pwszURL,        // URL to base stream on
                                 BOOL fDirect,          // should we open this in direct mode, or transacted mode?
                                                        // must be FALSE for ftp:// pwszPath
                                 BOOL fDeleteWhenDone,  // should we remove this file after closing the stream?
                                                        // must be FALSE for ftp:// pwszPath
                                 BOOL fCreate)          // are we trying to create/overwrite a file (TRUE), or only open an existing file (FALSE)
{
    // locals
    HRESULT hr = S_OK;
    TRACE("CFtpStrm::Open");

    // check args
    if (pwszURL == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _pwszURL = DuplicateStringW(pwszURL);
        if (_pwszURL == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _fDirect = fDirect;

            // code
            if (LStrCmpN(_pwszURL, L"file:///", 8) == 0) // BUGBUG: case sensitive?
            {
                _fLocalResource = TRUE;
            }
            else if (LStrCmpN(_pwszURL, L"ftp://", 6) == 0) // BUGBUG: does this break user:// ?
            {
                _fLocalResource = FALSE;
            }
            else
            {
                hr = E_INVALIDARG;
            }

            if (SUCCEEDED(hr))
            {   
                if (_fLocalResource && fDirect)
                {
                    hr = this->_OpenLocalDirect(fCreate, fDeleteWhenDone);
                }
                else if (_fLocalResource && !fDirect)
                {
                    hr = this->_OpenLocalTransacted(fCreate, fDeleteWhenDone);
                }
                else
                {
                    if (!_fLocalResource && (fDirect || fDeleteWhenDone))
                    {
                        hr = E_INVALIDARG; // remote files must be transacted, cannot be temp files
                    }
                    else
                    {                        
                        _hInternet = InternetOpen(L"FTPSTRM", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
                        if (_hInternet == NULL)
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            hr = this->_OpenRemoteTransacted(fCreate);
                        }
                    }
                }
            }
        }
    }

    return hr;  
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFtpStrmImpl::SetAuth(LPWSTR pwszUserName,
                                    LPWSTR pwszPassword)
{
    HRESULT hr = S_OK;
    TRACE("CFtpStrm::SetAuth");

    if (_pwszUserName != NULL)
    {
        free(_pwszUserName);
        _pwszUserName = NULL;
    }
    if (_pwszPassword != NULL)
    {
        free(_pwszPassword);
        _pwszPassword = NULL;
    }

    if (pwszUserName != NULL)
    {
        _pwszUserName = DuplicateStringW(pwszUserName);
        if (_pwszUserName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pwszPassword != NULL)
        {
            _pwszPassword = DuplicateStringW(pwszPassword);
            if (_pwszPassword == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }


    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// IStream methods

HRESULT CFtpStrmImpl::Read(void * pv,
                        ULONG cb,          
                        ULONG * pcbRead)
{
    // locals
    HRESULT hr = S_OK;
    DWORD cbRead;
    BOOL fReadSuccess;
    TRACE("CFtpStrm::Read");

    // check arguments
    if (pv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {    
        // code    
        fReadSuccess = ReadFile(_hLocalFile,
                                pv,
                                cb,
                                &cbRead,
                                NULL);
        if (!fReadSuccess)
        {
            hr = E_FAIL;
        }
        else
        {
            if (pcbRead != NULL)
            {
                *pcbRead = cbRead;
            }
        }
    }

    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::Write(void const* pv,
                         ULONG cb,
                         ULONG * pcbWritten)
{
    // locals
    HRESULT hr = S_OK;
    DWORD cbWritten;
    BOOL fWriteSuccess;
    TRACE("CFtpStrm::Write");

    // check arguments
    if (pv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // code    
        fWriteSuccess = WriteFile(_hLocalFile,
                                  pv,
                                  cb,
                                  &cbWritten,
                                  NULL);
        if (!fWriteSuccess)
        {
            hr = E_FAIL;
        }
        else
        {
            if (pcbWritten != NULL)
            {
                *pcbWritten = cbWritten;
            }
        }
    }

    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::Seek(LARGE_INTEGER dlibMove,          
                        DWORD dwOrigin,                  
                        ULARGE_INTEGER * plibNewPosition)
{
    // locals
    DWORD dwMoveMethod = FILE_BEGIN; // makes compiler happy
    LONG iHighPart;
    DWORD dwResult;
    HRESULT hr = S_OK;
    TRACE("CFtpStrm::Seek");

    // check args
    if (dwOrigin != STREAM_SEEK_SET && dwOrigin != STREAM_SEEK_CUR && dwOrigin != STREAM_SEEK_END)
    {
        hr = E_INVALIDARG;
    }
    else
    {

        // code
        switch (dwOrigin) {
        case STREAM_SEEK_SET:
            dwMoveMethod = FILE_BEGIN;
            break;
        case STREAM_SEEK_CUR:
            dwMoveMethod = FILE_CURRENT;
            break;
        case STREAM_SEEK_END:
            dwMoveMethod = FILE_END;
            break;
        default:
            assert(0);
        }

        iHighPart = dlibMove.HighPart;
        
        dwResult = SetFilePointer(_hLocalFile,
                                  dlibMove.LowPart,
                                  &iHighPart,
                                  dwMoveMethod);

        if (dwResult == INVALID_SET_FILE_POINTER)
        {
            hr = E_FAIL;
        }
        else
        {
            if (plibNewPosition != NULL)
            {
                (*plibNewPosition).LowPart = dwResult;
                (*plibNewPosition).HighPart = iHighPart;
            }
        }
    }

    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::Stat(STATSTG*  pstatstg,     //Location for STATSTG structure
                            DWORD     grfStatFlag)  //Values taken from the STATFLAG enumeration             
{
    // locals
    HRESULT hr = S_OK;
    TRACE("CFtpStrm::Stat");

    // check args
    if (grfStatFlag != STATFLAG_DEFAULT && grfStatFlag != STATFLAG_NONAME)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (grfStatFlag == STATFLAG_DEFAULT) 
        {
            pstatstg->pwcsName = DuplicateStringW(_pwszURL);
        }

        pstatstg->type = STGTY_STREAM;
    
        if (!GetFileSizeEx(_hLocalFile,(LARGE_INTEGER*)&pstatstg->cbSize))
        {
            hr = E_FAIL;
        }
        else
        {
            if (_fLocalResource)
            {
                if (!GetFileTime(_hLocalFile, &(pstatstg->ctime), &(pstatstg->atime), &(pstatstg->mtime)))
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                // BUGBUG: currently we look at the local file for filetime
                if (!GetFileTime(_hLocalFile, &(pstatstg->ctime), &(pstatstg->atime), &(pstatstg->mtime)))
                {
                    hr = E_FAIL;
                }
            }

            if (SUCCEEDED(hr))
            {
                pstatstg->grfMode = 0; // BUGBUG: what should this be???
                pstatstg->grfLocksSupported = LOCK_EXCLUSIVE;
                pstatstg->clsid = CLSID_NULL;
                pstatstg->grfStateBits = 0;
                pstatstg->reserved = 0;
            }
        }
    }
   
    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::_CommitLocal(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;
    TRACE("CFtpStrm::CommitLocal");

    // commit a local transacted file
    // a local transacted file should be copied to the original place
    if (!CloseHandle(_hLocalFile)) // close local
    {
        hr = E_FAIL;
    }
    else if (!CopyFile(_pwszLocalFile, _pwszURL+8, FALSE)) // copy local
    {
        hr = E_FAIL;
    }
    else
    {
        _hLocalFile = CreateFile(_pwszLocalFile, GENERIC_READ | GENERIC_WRITE, 0,
                             NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); // re-open local
        if (_hLocalFile == INVALID_HANDLE_VALUE)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::_CommitRemote(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;
    HINTERNET hSession = NULL;
    LPWSTR pwszServer = NULL;
    LPWSTR pwszPath = NULL;
    ULONG cbRead;
    DWORD fSizeHigh;
    DWORD fSizeLow;
    ULONG cbData;
    LPVOID pbData;
    URL_COMPONENTS urlComponents = {0};
    INTERNET_PORT nPort = INTERNET_DEFAULT_FTP_PORT;

    TRACE("CFtpStrm::CommitRemote");

    // commit a remote transacted resource
    // open remote resource and seek to start of it
    // -- first parse the URL (server, port, path)
    urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
    urlComponents.dwHostNameLength = 1;
    urlComponents.dwUrlPathLength = 1;
    urlComponents.nPort = 1;
    if (!InternetCrackUrl(_pwszURL, 0, 0, &urlComponents))
    {
        hr = E_FAIL;
    }
    else
    {
        pwszServer = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwHostNameLength));
        if (pwszServer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pwszServer = lstrcpyn(pwszServer, urlComponents.lpszHostName, 1 + urlComponents.dwHostNameLength); // +1 for the final null char
            if (urlComponents.nPort != 0)
            {
                nPort = urlComponents.nPort;
            }

			pwszPath = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwUrlPathLength));
            if (pwszPath == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                lstrcpyn(pwszPath, urlComponents.lpszUrlPath, 1 + urlComponents.dwUrlPathLength);
                
                // -- then connect to the server
                hSession = InternetConnect(_hInternet, pwszServer, urlComponents.nPort, 
                                           _pwszUserName, _pwszPassword, INTERNET_SERVICE_FTP, 0, 0);
                if (hSession == NULL)
                {
                    hr = E_FAIL;
                }
                else
                {
                    if (!CloseHandle(_hLocalFile))
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        if (!FtpPutFile(hSession, _pwszLocalFile, pwszPath, FTP_TRANSFER_TYPE_UNKNOWN, 0))
                        {
                            DWORD dw = GetLastError();
							HRESULT hres = HRESULT_FROM_WIN32(dw);
							hr = E_FAIL;
                        }
                        else
                        {
                            _hLocalFile = CreateFile(_pwszLocalFile, GENERIC_READ | GENERIC_WRITE, 0,
                                                     NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                            if (_hLocalFile == INVALID_HANDLE_VALUE)
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                }
                free(pwszPath);
            }
        }
        free(pwszServer);
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;

    if (_fDirect)
    {
        hr = E_FAIL; // in direct mode, commit is meaningless
    }
    else if (grfCommitFlags != STGC_DEFAULT)
    {
        hr = E_INVALIDARG; // we only support the default commit style
    }
    else
    {
        if (_fLocalResource)
            hr = this->_CommitLocal(grfCommitFlags);
        else
            hr = this->_CommitRemote(grfCommitFlags);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CFtpStrmImpl::Revert()
{
    HRESULT hr = S_OK;
    TRACE("CFtpStrm::Revert");

    if (_fDirect)
    {
        hr = E_FAIL; // in direct mode, revert is meaningless
    }
    else
    {
        if (_fLocalResource)
        {
            // revert a local transacted file
            if (!CloseHandle(_hLocalFile)) // should delete the file if needed...
            {
                hr = E_FAIL;
            }
            else if (!CopyFile(_pwszURL+8, _pwszLocalFile, FALSE)) // ... but we'll overwrite it if not
            {
                hr = E_FAIL;
            }
            else
            {
                _hLocalFile = CreateFile(_pwszLocalFile, GENERIC_READ | GENERIC_WRITE, 0,
                                         NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (_hLocalFile == INVALID_HANDLE_VALUE)
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {            
            // revert commit a remote transacted resource
            if (!CloseHandle(_hLocalFile)) // this should delete the file
            {
                hr = E_FAIL;
            }
            else
            {
                hr = this->_OpenRemoteTransacted(FALSE); // don't create, we want to reopen what was there before
            }
        }
    }

    return hr;
} 

/////////////////////////////////////////////////////////////////////////////////
// These IStream methods are not supported

HRESULT CFtpStrmImpl::SetSize(ULARGE_INTEGER UNREF_PARAM(libNewSize))  //Specifies the new size of the stream object
{
    return E_NOTIMPL;
} 

HRESULT CFtpStrmImpl::CopyTo(IStream * UNREF_PARAM(pstm),              //Points to the destination stream
                          ULARGE_INTEGER UNREF_PARAM(cb),           //Specifies the number of bytes to copy
                          ULARGE_INTEGER * UNREF_PARAM(pcbRead),    //Pointer to the actual number of bytes 
                                                                    // read from the source
                          ULARGE_INTEGER * UNREF_PARAM(pcbWritten)) //Pointer to the actual number of 
                          // bytes written to the destination
{
    return E_NOTIMPL;
} 

HRESULT CFtpStrmImpl::LockRegion(ULARGE_INTEGER UNREF_PARAM(libOffset),  //Specifies the byte offset for
                                                                      // the beginning of the range
                              ULARGE_INTEGER UNREF_PARAM(cb),         //Specifies the length of the range in bytes
                              DWORD UNREF_PARAM(dwLockType))          //Specifies the restriction on
                                                                      // accessing the specified range
{
    return E_NOTIMPL;
} 

HRESULT CFtpStrmImpl::UnlockRegion(ULARGE_INTEGER UNREF_PARAM(libOffset),  //Specifies the byte offset for
                                                                        // the beginning of the range
                                ULARGE_INTEGER UNREF_PARAM(cb),         //Specifies the length of the range in bytes
                                DWORD UNREF_PARAM(dwLockType))          //Specifies the access restriction
                                                                        // previously placed on th