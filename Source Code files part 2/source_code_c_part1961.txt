 // calling System.Assembly.Load on each one. During the load call, the 
        // loaded assembly is placed in this collection: 
        // System.AppDomain.CurrentDomain.GetAssemblies(). When the test suite
        // is run, the currently running app domain looks up an assembly when 
        // it is needed. So in this case, if the loaded test suite runs some 
        // code from an external assembly, the app domain searches for that 
        // external assembly that that code belongs to and uses it. For some 
        // reason, System.AppDomain.CurrentDomain.GetAssemblies() is not a part
        // of this external assembly search path. The following method is 
        // called when the CurrentDomain cannot find a said assembly. This is 
        // a hack so that CurrentDomain's Assembly loader can search through 
        // System.AppDomain.CurrentDomain.GetAssemblies() to load external 
        // assemblies. I'm not sure why it doesn't do this already, but until 
        // I find out, this hack will remain. (t-robtos)
        private Assembly CurrentDomain_AssemblyResolve (object sender, ResolveEventArgs args)
        {
            foreach(Assembly a in AppDomain.CurrentDomain.GetAssemblies())
            {
                if(a.FullName == args.Name)
                    return a;
            }
            return null;
        }


        /// <summary>Loads taskdesc items in the XML config. file.</summary>
        /// <param name="doc">The XML configuration file.</param>
        protected void LoadTaskDescriptors (XmlDocument doc)
        {

            XmlNodeList nodeList = doc.SelectNodes("/stressmix/taskdesc");

            uint nextId = 0;
            _TaskDescriptors.Clear();

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null != el)
                {
                    TaskDescriptor desc = new TaskDescriptor(nextId++);

                    desc.Name               = GetStringAttribute(el, "name", "<noname>");
                    desc.Enabled            = GetBoolAttribute(el, "enabled", true);
                    desc.DesiredTps         = GetScalarAttribute(el, "tps", 0.0f);
                    desc.Scale              = GetScalarAttribute(el, "scale", 1.0f);
                    desc.ContextNames       = GetStringAttribute(el, "contexts", "").Split(",".ToCharArray());
                    desc.WorkerMethodName   = GetStringAttribute(el, "workerMethod", "");
                    desc.WorkerMethod       = _WorkerType.GetMethod(
                                                    desc.WorkerMethodName,
                                                    BindingFlags.Instance|BindingFlags.IgnoreCase|BindingFlags.Public,
                                                    null,
                                                    CallingConventions.Standard,
                                                    new Type[0],
                                                    null);
                    if(null == desc.WorkerMethod)
                    {
                        _Report.Error("Failed to find appropriate worker method: {0} on worker class: {1}",
                                desc.WorkerMethodName,
                                _WorkerType.Name);
                        continue;
                    }

                    // Parse context names
                    desc.ContextIds = new uint[desc.ContextNames.Length];
                    for(uint i = 0; i < desc.ContextNames.Length; ++i)
                    {
                        if(null != _ContextManager)
                        {
                            desc.ContextIds[i] = _ContextManager.ContextTypeNameToId(desc.ContextNames[i]);
                        }
                        else
                        {
                            desc.ContextIds[i] = 0;
                        }
                    }

                    _TaskDescriptors.Add(desc);

                    _Report.Debug("Loaded task descriptor for task: {0}, tps: {1}, method: {2}",
                            desc.Name,
                            desc.DesiredTps,
                            desc.WorkerMethodName);

                }
            }
        }

        /// <summary>
        ///  Calculates how many tasks of each task type to schedule for the 
        ///  timeslice.
        /// </summary>
        /// <param name="elapsed">Passed to LeftToSchedule.</param>
        /// <param name="leftToSchedule">Array containing the number of tasks 
        ///  to schedule for each task type.</param>
        /// <returns>The total number of tasks to schedule.</returns>
        protected uint GetLeftToSchedule (float elapsed, uint[] leftToSchedule)
        {
            uint total = 0;
            TaskDescriptor desc;

            for(int i = 0; i < _TaskDescriptors.Count; ++i)
            {
                desc = _TaskDescriptors[i];

                if(!desc.Enabled)
                {
                    continue;
                }

                leftToSchedule[i] = desc.LeftToSchedule(elapsed, settings.loadScale);
                total += leftToSchedule[i];
            }

            return total;
        }

        /// <summary>Distributes the tasks among inactive Workers.</summary>
        /// <param name="inProgressLeft">Number of Workers not in progress.
        ///  </param>
        /// <param name="tasksLeft">Total count of tasks to schedule.</param>
        /// <param name="leftToSchedule">Mapping of tasks to how many of that 
        ///  task to schedule.</param>
        protected void DistributeTasks (float elapsed, uint inProgressLeft, uint tasksLeft, uint[] leftToSchedule)
        {
            uint scheduled;  // How many tasks ended up being scheduled
            uint toSchedule; // How many tasks to schedule for a given task type
            float schedulerRatio;

            for(int i = 0; i < _TaskDescriptors.Count; ++i)
            {
                TaskDescriptor desc = _TaskDescriptors[i];

                if(!desc.Enabled)
                {
                    desc.RecordScheduled(elapsed, 0);
                    continue;
                }

                toSchedule = leftToSchedule[i];

                if(tasksLeft > inProgressLeft)
                {
                    schedulerRatio = (float)toSchedule / (float)tasksLeft;
                    // This line wasn't working for one worker, because it 
                    // kept rounding to zero, and the worker would never get
                    // scheduled. (t-robtos)
                    toSchedule = (uint)Math.Floor((schedulerRatio * inProgressLeft));
                }

                if(toSchedule > 0)
                {
                    scheduled = ScheduleTasks(desc, toSchedule);
                }
                else
                {
                    scheduled = 0;
                }

                desc.RecordScheduled(elapsed, scheduled);
            }
        }


        /// <summary>
        ///  Assigns toSchedule tasks to an available Worker and begins Worker 
        ///  execution. It prepares the Worker by calling the 
        ///  IContextManager.Acquire method on the internal IContextManager 
        ///  instance. This method decrements toSchedule every time a task was 
        ///  attempted to be scheduled until toSchedule reaches 0.
        /// </summary>
        /// <param name="desc">TaskDescriptor to schedule.</param>
        /// <param name="toSchedule">Number of tasks to schedule.</param>
        /// <returns>The number of desc tasks that were scheduled (or 
        ///  attempted).</returns>
        protected uint ScheduleTasks (TaskDescriptor desc, uint toSchedule)
        {
            uint scheduled = 0;

            //_Report.Debug("Number of workers to schedule: "+toSchedule);

            while(toSchedule-- > 0)
            {
                //_Report.Debug("Number of workers left to schedule: "+toSchedule);

                bool succeeded = false;

                Debug.Assert(_WorkerQueue.Count > 0);
                Worker worker = AcquireWorker();

                succeeded = (null != _ContextManager) ? 
                                _ContextManager.Acquire(desc.ContextIds, worker) : true;
                if(!succeeded)
                {
                    _Report.Debug("Failed to acquire resources for task: {0}", desc.Name);
                    goto lbDoneLoop;
                }

                // Associate the worker with the descriptor for 
                // accounting on the return trip
                worker.Key = desc.Id;

                try
                {
                    worker.Start(desc.WorkerMethod, this);

                    // Added this catch block because the DllNotFoundException is 
                    // not clear on the fact that if this exception is thrown, it
                    // might mean that the DLL is actually found, but one of its 
                    // dependencies have not been found. (t-robtos)
                }
                catch(DllNotFoundException dex)
                {
                    succeeded = false;
                    _Errors++;
                    _Report.Error("A dll, or one of its dependencies, was "+
								  "not found. Make sure that the dll is in "+
								  "the correct path and all of its "+
								  "dependencies are as well: "+dex.ToString());
                    goto lbDoneLoop;

                }
                catch(Exception ex)
                {
                    succeeded = false;
                    _Errors++;
                    _Report.Error("Failed to start worker task: {0}, class: {1}, method: {2}, reason: {3}",
                            desc.Name,
                            _WorkerType.Name,
                            desc.WorkerMethodName,
                            ex.ToString());
                    goto lbDoneLoop;
                }

            lbDoneLoop:
                if(!succeeded)
                {
                    // release and leave the scheduling loop for this worker
                    ReleaseWorker(worker);
                    break;
                }

                ++_InProgress;
                ++scheduled;
                ++_Scheduled;

                //_Report.Debug("Worker scheduled. InProgress: "+_InProgress);
            }

            return scheduled;
        }

        /// <summary>
        ///  Cleans up Workers that have completed their tasks. This involves 
        ///  recording how long it took a given Worker to complete its task and
        ///  recording the (if any) Exception that the Worker may have 
        ///  encountered during execution.
        /// </summary>
        protected void ProcessCleanupQueue ()
        {
            Worker worker;

            try
            {
                while(true)
                {
					
					worker = _CleanupQueue.Dequeue();
                    if(worker == null) continue;
					_TaskDescriptors[(int)worker.Key].RecordCompleted(worker.TotalTicks, worker.Exception);
					ReleaseWorker(worker);
					_Cleaned++;
					_InProgress--;
					
					
                }
            }
            catch(InvalidOperationException)
            {
                // queue is empty.. ignore
            }
        }

        /// <summary>
        ///  Main executing thread for the scheduler. Processes Worker queue
        ///  and distributes tasks.
        /// </summary>
        public void SchedulingThread ()
        {
            uint tasksLeft; // Total tasks to schedule
            uint[] leftToSchedule = new uint[_TaskDescriptors.Count];
            float elapsed = 0.0f;
            float timeSlice = 0.01f;
            ScopeTimer timer = new ScopeTimer();

            _Running = true;

            while(_Running)
            {
                timer.Enter();

                ProcessCleanupQueue();

                if(_Pause)
                {
                    goto lbEndScheduleLoop;
                }

                if(_InProgress > settings.maxInProgress)
                {
                    // Reversed arguments -- t-robtos
                    _Report.Error("Max in progress setting exceeded: {0} > {1}",
                            _InProgress,
                            settings.maxInProgress);
                    ++_Starved;

                    goto lbEndScheduleLoop;
                }

                tasksLeft = GetLeftToSchedule(elapsed, leftToSchedule);
                DistributeTasks(
                        elapsed,
                        settings.maxInProgress - _InProgress,
                        tasksLeft,
                        leftToSchedule);


            lbEndScheduleLoop:

                // Consume unused time
                while(timeSlice > 0 && elapsed < 1.0f)
                {
                    elapsed = (float)timer.Sample();
                    if(timeSlice - elapsed < 0.0f)
                    {
                        break;
                    }

                    // Yield to workers
                    Thread.Sleep(0);
                }

                ++_Cycles;
                timer.Leave();
                elapsed = (float)timer.Duration;
            }
        }

        /// <returns>A string representation of this.</returns>
        public override string ToString ()
        {
            return String.Format("Cleanup: {0} Free Workers: {1}\nScheduled: {2} Cleaned: {3} Starved: {4} Errors: {5}\nInProgress: {6}",
                    _CleanupQueue.Count,
                    _WorkerQueue.Count,
                    _Scheduled,
                    _Cleaned,
                    _Starved,
                    _Errors,
                    _InProgress);
        }

        public void ToggleTask (uint id, bool enabled)
        {
            foreach (TaskDescriptor task in _TaskDescriptors)
            {
                if(task.Id == id)
                {
                    task.Enabled = enabled;
                    return;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\client\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\stress\StressMonitorWindow.cs ===
using System;
using System.Drawing;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Threading;
using System.IO;

namespace livetest.stress
{
    /// <summary>
    ///  A graphical user interface to monitor stress tests. This class has two
    ///  constructors. One is for loading an configuration file from the 
    ///  command line, and the other is start the interface without a 
    ///  configuration file specified.
    /// </summary>
    public class StressMonitorWindow : System.Windows.Forms.Form
    {
        private const uint TIMER_DELAY = 2000; // 2 seconds

        private System.Windows.Forms.ListView _TaskList;
        private System.Windows.Forms.Button _StartButton;
        private System.Windows.Forms.Button _StopButton;

        // Required designer variable.
        private System.ComponentModel.Container components = null;

        // User-defined Window members/delegates
        private Scheduler _Scheduler;
        private System.Windows.Forms.Label _StatsLabel;
        private System.Windows.Forms.GroupBox _StatsGroupBox;
        private Button LoadButton;
        private System.Threading.Timer _UpdateTimer;
        private Button pauseButton;
        private Button logViewButton;

        private OpenFileDialog openFileDialog;
        private LogView logView;
        private EditTaskBox editTaskBox = new EditTaskBox();

        private Form progressForm = new Form();
        private ProgressBar loadingSuiteProgressBar = new ProgressBar();
        private Label loadingLabel = new Label();

        /// <summary>
        ///  Creates a StressMonitorWindow with the given configuration file.
        /// </summary>
        /// <param name="xmlConfigFile">A string path to a xml configuration 
        ///  file.</param>
        public StressMonitorWindow (string xmlConfigFile)
            : this()
        {
            LoadXMLConfig(xmlConfigFile);
        }

        /// <summary>
        ///  Creates a StressMonitorWindow with no configuration file loaded.
        /// </summary>
        public StressMonitorWindow ()
        {
            InitializeComponent();
            logView = new LogView("Stress Monitor Log");
            Scheduler._Report.AddReportDestination(logView);

            // Progress bar initialization
            loadingLabel.Dock = DockStyle.Top;
            loadingLabel.Text = "Loading Test Suite...";
            loadingSuiteProgressBar.Style = ProgressBarStyle.Continuous;
            loadingSuiteProgressBar.Dock = DockStyle.Bottom;
            loadingSuiteProgressBar.Step = 1;
            progressForm.Controls.Add(loadingLabel);
            progressForm.Controls.Add(loadingSuiteProgressBar);
            progressForm.Hide();
            progressForm.ControlBox = false;
            progressForm.Size = new Size(400, 50);

            Show();
        }

        /// <summary>
        ///  Loads a StressMonitor XML configuration file.
        /// </summary>
        /// <param name="xmlConfigFile">A string path to the xml config file.
        /// </param>
        public void LoadXMLConfig (string xmlConfigFile)
        {
            try
            {
                Update();

                progressForm.StartPosition = FormStartPosition.CenterScreen;
                progressForm.Show(this);
                //progressForm.Location = this.;
                
                
                loadingLabel.Update();
                _Scheduler = new Scheduler(xmlConfigFile.ToString());
                _Scheduler.UnitWorkLoadingCompleted += 
                delegate (int unitsLeft)
                {
                    if(loadingSuiteProgressBar.Value == 0)
                        loadingSuiteProgressBar.Maximum = unitsLeft;

                    if (loadingSuiteProgressBar.Value < loadingSuiteProgressBar.Maximum)
                        loadingSuiteProgressBar.PerformStep();
                };
                _Scheduler.LoadSettings();

                loadingLabel.Text = "Initializing task list...";
                loadingLabel.Update();
                loadingSuiteProgressBar.Value = 0;
                loadingSuiteProgressBar.Maximum = _Scheduler.TaskDescriptors.Count + 1;
                _InitializeTaskList();
                _UpdateTimer = new System.Threading.Timer(new TimerCallback(this._TimerCallback), null, TIMER_DELAY, TIMER_DELAY);

                logViewButton.Enabled = true;
            }
            catch(Exception e)
            {
                DisplayException("Error Loading Configuration File.",
                                 "Could not load "+xmlConfigFile, e);
            }
            finally
            {
                progressForm.Hide();
                loadingSuiteProgressBar.Value = 0;
            }
        }

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        protected override void Dispose (bool disposing)
        {
            if(_Scheduler != null)
                _Scheduler.Stop();

            if(disposing)
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code
        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            Control.CheckForIllegalCrossThreadCalls = false;

            this._TaskList = new System.Windows.Forms.ListView();
            this._StartButton = new System.Windows.Forms.Button();
            this._StopButton = new System.Windows.Forms.Button();
            this._StatsLabel = new System.Windows.Forms.Label();
            this._StatsGroupBox = new System.Windows.Forms.GroupBox();
            this.LoadButton = new System.Windows.Forms.Button();
            this.openFileDialog = new System.Windows.Forms.OpenFileDialog();
            this.pauseButton = new System.Windows.Forms.Button();
            this.logViewButton = new System.Windows.Forms.Button();
            this._StatsGroupBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // _TaskList
            // 
            this._TaskList.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this._TaskList.CheckBoxes = true;
            this._TaskList.Location = new System.Drawing.Point(8, 35);
            this._TaskList.Name = "_TaskList";
            this._TaskList.Size = new System.Drawing.Size(535, 293);
            this._TaskList.TabIndex = 0;
            this._TaskList.UseCompatibleStateImageBehavior = false;
            // 
            // _StartButton
            // 
            this._StartButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this._StartButton.Location = new System.Drawing.Point(468, 372);
            this._StartButton.Name = "_StartButton";
            this._StartButton.Size = new System.Drawing.Size(75, 23);
            this._StartButton.TabIndex = 1;
            this._StartButton.Text = "Start";
            this._StartButton.Click += new System.EventHandler(this._StartButton_Click);
            // 
            // _StopButton
            // 
            this._StopButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this._StopButton.Enabled = false;
            this._StopButton.Location = new System.Drawing.Point(468, 401);
            this._StopButton.Name = "_StopButton";
            this._StopButton.Size = new System.Drawing.Size(75, 23);
            this._StopButton.TabIndex = 1;
            this._StopButton.Text = "Stop";
            this._StopButton.Click += new System.EventHandler(this._StopButton_Click);
            // 
            // _StatsLabel
            // 
            this._StatsLabel.BackColor = System.Drawing.SystemColors.ControlLight;
            this._StatsLabel.Dock = System.Windows.Forms.DockStyle.Fill;
            this._StatsLabel.Location = new System.Drawing.Point(3, 16);
            this._StatsLabel.Name = "_StatsLabel";
            this._StatsLabel.Size = new System.Drawing.Size(452, 69);
            this._StatsLabel.TabIndex = 2;
            // 
            // _StatsGroupBox
            // 
            this._StatsGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this._StatsGroupBox.BackColor = System.Drawing.SystemColors.Control;
            this._StatsGroupBox.Controls.Add(this._StatsLabel);
            this._StatsGroupBox.Location = new System.Drawing.Point(8, 336);
            this._StatsGroupBox.Name = "_StatsGroupBox";
            this._StatsGroupBox.Size = new System.Drawing.Size(458, 88);
            this._StatsGroupBox.TabIndex = 3;
            this._StatsGroupBox.TabStop = false;
            this._StatsGroupBox.Text = "Scheduler Stats";
            // 
            // LoadButton
            // 
            this.LoadButton.Location = new System.Drawing.Point(14, 6);
            this.LoadButton.Name = "LoadButton";
            this.LoadButton.Size = new System.Drawing.Size(105, 23);
            this.LoadButton.TabIndex = 4;
            this.LoadButton.Text = "Load XML Config";
            this.LoadButton.UseVisualStyleBackColor = true;
            this.LoadButton.Click += new System.EventHandler(this.LoadButton_Click);
            // 
            // openFileDialog
            // 
            this.openFileDialog.InitialDirectory = Directory.GetCurrentDirectory();
            this.openFileDialog.Filter = "xml files (*.xml)|*.xml|All files (*.*)|*.*";
            this.openFileDialog.FileOk += new System.ComponentModel.CancelEventHandler(this.openFileDialog_FileOk);
            // 
            // pauseButton
            // 
            this.pauseButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.pauseButton.Enabled = false;
            this.pauseButton.Location = new System.Drawing.Point(468, 342);
            this.pauseButton.Name = "pauseButton";
            this.pauseButton.Size = new System.Drawing.Size(75, 23);
            this.pauseButton.TabIndex = 5;
            this.pauseButton.Text = "Pause";
            this.pauseButton.UseVisualStyleBackColor = true;
            this.pauseButton.Click += new System.EventHandler(this.pauseButton_Click);
            // 
            // logViewButton
            // 
            this.logViewButton.Location = new System.Drawing.Point(125, 6);
            this.logViewButton.Name = "logViewButton";
            this.logViewButton.Size = new System.Drawing.Size(75, 23);
            this.logViewButton.TabIndex = 6;
            this.logViewButton.Text = "Show Log";
            this.logViewButton.UseVisualStyleBackColor = true;
            this.logViewButton.Click += new System.EventHandler(this.logViewButton_Click);
            this.logViewButton.Enabled = false;
            // 
            // StressMonitorWindow
            // 
            this.StartPosition = FormStartPosition.CenterScreen;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(551, 429);
            this.Controls.Add(this.logViewButton);
            this.Controls.Add(this.pauseButton);
            this.Controls.Add(this.LoadButton);
            this.Controls.Add(this._StatsGroupBox);
            this.Controls.Add(this._StartButton);
            this.Controls.Add(this._TaskList);
            this.Controls.Add(this._StopButton);
            this.Name = "StressMonitorWindow";
            this.Text = "Stress Monitor";
            this._StatsGroupBox.ResumeLayout(false);
            this.ResumeLayout(false);

        }
        #endregion

        // 
        // Initialization code
        //
        private void _InitializeTaskList ()
        {
            _TaskList.Clear();

            _TaskList.View = View.Details;
            _TaskList.Columns.Add("Name", 120, HorizontalAlignment.Left);
            _TaskList.Columns.Add("Scale", 40, HorizontalAlignment.Left);
            _TaskList.Columns.Add("DesiredTps", 78, HorizontalAlignment.Left);
            _TaskList.Columns.Add("ActualTps", 60, HorizontalAlignment.Left);
            _TaskList.Columns.Add("InProgress", 70, HorizontalAlignment.Left);
            _TaskList.Columns.Add("Completed", 65, HorizontalAlignment.Left);
            _TaskList.Columns.Add("Errors", 40, HorizontalAlignment.Left);
            _TaskList.Columns.Add("AvgRTT", 55, HorizontalAlignment.Left);
            _TaskList.ItemCheck += 
                delegate(object sender, ItemCheckEventArgs e)
                {
                    _Scheduler.ToggleTask((uint)_TaskList.Items[e.Index].Tag,
                        e.NewValue == CheckState.Checked);
                };
            _TaskList.MouseClick += 
                delegate(object sender, MouseEventArgs e)
                {
                    if(e.Button == MouseButtons.Right)
                    {
                        foreach(ListViewItem lvi in _TaskList.Items)
                        {
                            if(lvi.Bounds.Contains(e.X, e.Y))
                            {
                                editTask((uint)lvi.Tag);
                                break;
                            }
                        }
                    }
                            
                };
            _TaskList.KeyDown += 
                delegate(object sender, KeyEventArgs e)
                {
                    if(_TaskList.SelectedItems.Count > 0)
                    {
                        ListViewItem lvi = _TaskList.SelectedItems[0];

                        if(e.KeyCode == Keys.Enter)
                            editTask((uint)lvi.Tag);
                        else if(e.KeyCode == Keys.Space)
                            _Scheduler.ToggleTask((uint)lvi.Tag, lvi.Checked);
                    }
                };
            loadingSuiteProgressBar.PerformStep();

            // Populate the empty records
            foreach(TaskDescriptor desc in _Scheduler.TaskDescriptors)
            {
                ListViewItem lvi = new ListViewItem(desc.Name);
                lvi.SubItems.Add("0");
                lvi.SubItems.Add("0");
                lvi.SubItems.Add("0");
                lvi.SubItems.Add("0");
                lvi.SubItems.Add("0");
                lvi.SubItems.Add("0");
                lvi.SubItems.Add("0");
                lvi.Checked = desc.Enabled;
                lvi.Tag = desc.Id;
                _TaskList.Items.Add(lvi);
                loadingSuiteProgressBar.PerformStep();
            }
        }

        //
        // Event handlers
        //

        private void _StartButton_Click (object sender, System.EventArgs e)
        {
            if(_Scheduler == null)
            {
                MessageBox.Show(this, "No configuration file loaded.",
                                "Error", MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                return;
            }

            try
            {
                _StartButton.Enabled = false;
                _Scheduler.Start();
                _StopButton.Enabled = true;
                pauseButton.Enabled = true;

            }
            catch(Exception ex)
            {
                _StartButton.Enabled = true;
                _StopButton.Enabled = false;
                pauseButton.Enabled = false;
                DisplayException("Error", "Could not start stress tests.", ex);
            }
        }

        private void _StopButton_Click (object sender, System.EventArgs e)
        {
            _StopButton.Enabled = false;
            pauseButton.Enabled = false;
            _Scheduler.Stop();

            _StartButton.Enabled = true;
        }

        private void _TimerCallback (object state)
        {
            _TaskList.BeginUpdate();
            try
            {
                // Read the scheduler task descriptions and write them to the listview
                int i = 0;
                List<TaskDescriptor> taskDescriptors = _Scheduler.TaskDescriptors;
                foreach(ListViewItem lvi in _TaskList.Items)
                {
                    if(null == lvi)
                    {
                        continue;
                    }

                    TaskDescriptor desc = taskDescriptors[i++] as TaskDescriptor;
                    if(null == desc)
                    {
                        continue;
                    }

                    lvi.SubItems[1].Text = desc.Scale.ToString();
                    lvi.SubItems[2].Text = desc.DesiredTps.ToString();
                    lvi.SubItems[3].Text = desc.ActualTps.ToString();
                    lvi.SubItems[4].Text = desc.InProgress.ToString();
                    lvi.SubItems[5].Text = desc.Completed.ToString();
                    lvi.SubItems[6].Text = desc.Errors.ToString();
                    lvi.SubItems[7].Text = desc.AverageRoundTripTime.ToString();
                }
            }
            finally
            {
                _TaskList.EndUpdate();
            }

            _StatsLabel.Text = _Scheduler.ToString();
        }

        private void LoadButton_Click (object sender, EventArgs e)
        {
            // Launch file chooser
            openFileDialog.ShowDialog(this);
        }

        private void openFileDialog_FileOk (object sender, CancelEventArgs e)
        {
            LoadXMLConfig(openFileDialog.FileName);
        }

        private void DisplayException (string caption, string message, Exception reason)
        {
            MessageBox.Show(this, message+"\nReason: "+reason.ToString(), caption, MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        private void pauseButton_Click (object sender, EventArgs e)
        {
            if(_Scheduler.IsPaused)
            {
                _Scheduler.Unpause();
                pauseButton.Text = "Pause";

            }
            else
            {
                _Scheduler.Pause();
                pauseButton.Text = "Resume";
            }
        }

        private void logViewButton_Click (object sender, EventArgs e)
        {
            logView.Show();
        }

        private void editTask (uint taskID)
        {
            TaskDescriptor task = _Scheduler.TaskDescriptors[(int)taskID];

            if(editTaskBox.EditTask(task.Name,
                                    task.Scale,
                                    task.DesiredTps))
            {
                task.Scale = editTaskBox.ScaleFactor;
                task.DesiredTps = editTaskBox.DesiredTps;
            }
        }

        private class EditTaskBox : Form
        {
            Label scaleFactorLabel = new Label();
            Label desiredTpsLabel = new Label();

            TextBox scaleFactorTextBox = new TextBox();
            TextBox desiredTpsTextBox = new TextBox();

            Button okButton = new Button();
            Button cancelButton = new Button();

            public float ScaleFactor
            {
                get { return float.Parse(scaleFactorTextBox.Text); }
            }

            public float DesiredTps
            {
                get { return float.Parse(desiredTpsTextBox.Text); }
            }


            public EditTaskBox ()
            {
                // Scale factor
                scaleFactorLabel.Text = "Scale:";
                scaleFactorLabel.Location = new Point(5, 5);
                scaleFactorLabel.Size = new Size(37, 15);
                scaleFactorTextBox.Size = new Size(20, 30);
                scaleFactorTextBox.Location = new Point(42, 0);
                // Desired Tps
                desiredTpsLabel.Text = "Desired Tps:";
                desiredTpsLabel.Location = new Point(70, 5);
                desiredTpsLabel.Size = new Size(70, 15);
                desiredTpsTextBox.Location = new Point(140, 0);
                desiredTpsTextBox.Size = new Size(40, 10);
                // OK button
                okButton.DialogResult = DialogResult.OK;
                okButton.Text = "OK";
                okButton.Location = new Point(17, 30);
                // Cancel button
                cancelButton.DialogResult = DialogResult.Cancel;
                cancelButton.Text = "Cancel";
                cancelButton.Location = new Point(97, 30);
                // This window
                Text = "Edit Task";
                Size = new Size(195, 90);
                MinimizeBox = false;
                MaximizeBox = false;
                ControlBox = false;
                CancelButton = cancelButton;
                AcceptButton = okButton;
                FormBorderStyle = FormBorderStyle.FixedDialog;
                ShowInTaskbar = false;
                Controls.Add(scaleFactorLabel);
                Controls.Add(scaleFactorTextBox);
                Controls.Add(desiredTpsLabel);
                Controls.Add(desiredTpsTextBox);
                Controls.Add(okButton);
                Controls.Add(cancelButton);
            }

            public bool EditTask (string name, float scaleFactor, 
                                  float desiredTps)
            {
                Text = name;
                scaleFactorTextBox.Text = scaleFactor.ToString();
                desiredTpsTextBox.Text = desiredTps.ToString();
                scaleFactorTextBox.Select();
                scaleFactorTextBox.SelectAll();
                StartPosition = FormStartPosition.CenterParent;

                return ShowDialog() == DialogResult.OK;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\common\PartnerId.cs ===
namespace xonline.login.common
{
    public enum PartnerId : int
    {
        Xbox     =  0,
        Zune     =  1,
        Facebook =  256
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\dll\install\Installer.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.login
{
    [RunInstaller(true)]
    public class LoginInstaller : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class LoginPerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\common\PartnerName.cs ===
namespace xonline.login.common
{
    public class PartnerName
    {
        public string Xbox     = "Xbox";
        public string Zune     = "Zune";
        public string Facebook = "Facebook";
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\client\partner\PartnerUser.cs ===
using System;
using System.Xml;

using xonline.common.service;

namespace xonline.login.client.partner
{
    /// <summary>A partner user is a pairwise user for communicating with a partner .
    /// The partner user may store credentials and other data for communicating with
    /// that partner.  Additionally, each partner user has a pairwise xuid  that  is
    /// specific to that partner and can be used in place of the real user xuid  for
    /// purposes of protecting the user's xuid which  could  otherwise  be  used  to
    /// correlate user pii.</summary>
    
    public sealed class PartnerUser
    {
        xonline.login.partner.PartnerUser _partnerUser;

        #region Constructors
        private PartnerUser(xonline.login.partner.PartnerUser partnerUser)
        {
            _partnerUser = partnerUser;
        }
        #endregion

        #region Accessors
        /// <summary>The Data property represents partner specific data associated with the partner user.  Like
        /// the Data property for Partner object.  There is no enforced schema for the XML.   It must simply be
        /// well-formed. However,  it is recommended that different  domains  coordinate  both the root element
        /// and any sub-elements, and take care to not alter data in other domains</summary>
        ///
        /// <example><code>
        /// <root>
        ///     <community>
        ///     </community>
        ///     <marketplace>
        ///     </marketplace>
        /// </root>
        /// </code></example>
        
        public XmlNode Data {
            get { return _partnerUser.Data; }
            set { _partnerUser.Data = value; }
        }

        /// <summary>The PartnerXuid property represents the pairwise xuid used when communicating with the partner system.</summary>
        /// <value>The Token property gets the pairwise xuid used when communicating with the partner system</value>

        public Puid PartnerXuid {
            get { return _partnerUser.PartnerXuid; }
        }

        /// <summary>The Token property represents the user credentials used to log into the partner system</summary>
        /// <value>The Token property gets/sets the user credentials partner user uses to log into the partner system.  The value can be null</value>

        public byte[] Token {
            get { return _partnerUser.Token; }
            set { _partnerUser.Token = value; }
        }

        /// <summary>The UserId property represents the unique user id the partner user uses to log into the partner system</summary>
        /// <value>The Id property gets/sets the unique user id the partner user uses to log into the partner system.  The value can be null</value>

        public string UserId {
            get { return _partnerUser.UserId; }
            set { _partnerUser.UserId = value; }
        }

        /// <summary>The Xuid property represents the unique xbox live user xuid for the partner user.</summary>
        /// <value>The Id property gets the unique xbox live user xuid for the partner user</value>

        public Puid Xuid {
            get { return _partnerUser.Xuid; }
        }
        #endregion

        /// <summary>Saves the ParterUser to the database.   All values will be written
        /// whether they are modified or not.</summary>
        /// <exception cref="System.Exception">Thrown when the specified partner is not found.</exception>

        public void Save() {
            _partnerUser.Save();
        }

        #region Static Methods

        /// <summary>Get a record of the partner user matching the specified partner id and xuid.  If
        /// no record is found, then one will be created to establish the relationship between the
        /// user and partner.</summary>
        ///
        /// <param name="partnerId">partnerId - the unique identifier of the partner for this user.</param>
        /// <param name="xuid">xuid - the xbox user id of the user (without respect to .</param>
        /// <returns>A partner object with the specified id.</returns>
        /// <exception cref="System.Exception">Thrown when the specified partner is not found.</exception>
        ///
        /// <remark>
        /// This method currently makes direct use of the  underlying  server
        /// side object model resulting in direct access to the backing store.
        /// This is temporary.  Once the server is developed, this method will
        /// will be reimplemented to call that server.  That is,  this will be
        /// a remote call.
        /// </remark>
        public static PartnerUser GetPartnerXuid(int partnerId, Puid xuid)
        {
            return new PartnerUser(
                xonline.login.partner.PartnerUser.GetPartnerXuid(partnerId, xuid)
            );
        }

        /// <summary>Get a record of the partner user matching the specified partner xuid.  
        ///</summary>
        ///
        /// <param name="partner_xuid">partner_xuid - the partner xuid that maps to the partnerId and the user</param>
        /// <returns>A partner object with the specified partner and user id.</returns>
        /// <exception cref="System.Exception">Thrown when the specified partner xuid is not found.</exception>
        ///
        /// <remark>
        /// This method currently makes direct use of the  underlying  server
        /// side object model resulting in direct access to the backing store.
        /// This is temporary.  Once the server is developed, this method will
        /// will be reimplemented to call that server.  That is,  this will be
        /// a remote call.
        /// </remark>
        public static PartnerUser GetPartnerUser(Puid partner_xuid)
        {
            return new PartnerUser(
                xonline.login.partner.PartnerUser.GetPartnerUser(partner_xuid)
            );
        }

        /// <summary>Reverse lookup partner users by their partner user ids</summary>
        /// <param name="partnerId">partnerId - the unique identifier of the partner for this user.</param>
        /// <param name="userIds">userIds - an array of userIds to lookup.</param>
        ///
        /// <returns>A an array of PartnerUser objects.  The array will contain
        /// one entry for every partner user found.  The array can be zero length.
        /// The order of the partner users in the array is indeterminate, callers
        /// must not make assumptions about the order of elements.</returns>
        ///
        /// <remarks>
        /// This method currently makes direct use of the  underlying  server
        /// side object model resulting in direct access to the backing store.
        /// This is temporary.  Once the server is developed, this method will
        /// will be reimplemented to call that server.  That is,  this will be
        /// a remote call.
        /// </remarks>
        
        public static PartnerUser[] LookupPartnerXuid(int partnerId, params string[] userIds)
        {
            xonline.login.partner.PartnerUser[] results =
                xonline.login.partner.PartnerUser.LookupPartnerXuid(partnerId, userIds);
            
            PartnerUser[] partnerUsers = new PartnerUser[results.Length];

            for (int i = 0; i < results.Length; i++) {
                partnerUsers[i] = new PartnerUser(results[i]);
            }

            return partnerUsers;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\client\partner\Partner.cs ===
using System;
using System.Xml;

namespace xonline.login.client.partner
{
    /// <summary>A partner is any external entity with which we communicate. They
    /// have names, have a unique identifier, and associated metadata</summary>

    public sealed class Partner
    {
        xonline.login.partner.Partner _partner;
    
        private Partner(xonline.login.partner.Partner partner)
        {
            _partner = partner;
        }
        
        /// <summary>The Id property represents the unique integer identifier of the partner.</summary>
        /// <value>The Id property gets the unique identifier for the partner</value>

        public int Id
        {
            get { return _partner.Id; }
        }
        
        /// <summary> Returns the friendly name for the partner</summary>
        
        public string Name
        {
            get { return _partner.Name; }
        }
        
        /// <summary>Returns XML data associated the  partner.   Currently  there
        /// is no schema enforcement for the data.  It must simply be well-formed.
        /// However,  it is recommended that different  domains  coordinate  both
        /// the root element and any sub-elements.  for example: </summary>
        ///
        /// <example><code>
        /// <root>
        ///     <community>
        ///     </community>
        ///     <marketplace>
        ///     </marketplace>
        /// </root>
        /// </code></example>

        public XmlNode Data
        {
            get { return _partner.Data; }
        }
        
        /// <summary>Returns a partner object.</summary>
        /// <param name="id">the unique identifier of the partner to return.</param>
        /// <returns>A partner object with the specified id.</returns>
        /// <exception cref="System.Exception">Thrown when the specified partner is not found.</exception>
        ///
        /// <remarks>
        /// This method currently makes direct use of the  underlying  server
        /// side object model resulting in direct access to the backing store.
        /// This is temporary.  Once the server is developed, this method will
        /// will be reimplemented to call that server.  That is,  this will be
        /// a remote call.
        /// </remarks>

        public static Partner Get(int id)
        {
            return new Partner(xonline.login.partner.Partner.Get(id));
        }
        
        /// <summary>Returns a partner object.</summary>
        /// <param name="name">the name of the partner to return.</param>
        /// <returns>The partner object with the specified name.</returns>
        /// <exception cref="System.Exception">Thrown when the specified partner is not found.</exception>
        ///
        /// <remarks>
        /// This method currently makes direct use of the  underlying  server
        /// side object model resulting in direct access to the backing store.
        /// This is temporary.  Once the server is developed, this method will
        /// will be reimplemented to call that server.  That is,  this will be
        /// a remote call.
        /// </remarks>
        
        public static Partner Get(string name)
        {
            return new Partner(xonline.login.partner.Partner.Get(name));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\dll\partner\Partner.cs ===
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Xml;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.login.partner
{
    public class Partner 
    {
        private int             _id;
        private string          _name;

        private ServiceKeyType? _publicKeyType;
        private ServiceKeyType? _privateKeyType;
        private int?            _keyVersion;
        
        // opaque blob of partner data
        
        private XmlNode         _data;
        
        // private and public keys used for encryption 

        private RsaPrivateKey   _privateKey;
        private RsaPublicKey    _publicKey;

        #region Constructors
        private Partner(int id, string name, ServiceKeyType? privateKeyType, ServiceKeyType? publicKeyType, int? keyVersion, XmlNode data)
        {
            _id         = id;
            _name       = name;

            _publicKeyType  = publicKeyType;
            _privateKeyType = privateKeyType;
            _keyVersion     = keyVersion;

            if ((privateKeyType != null) && (publicKeyType != null)) {
                _privateKey = new RsaPrivateKey((ServiceKeyType) _privateKeyType, (int) _keyVersion);
                _publicKey  = new RsaPublicKey((ServiceKeyType) _publicKeyType,   (int) _keyVersion);
            }

            else if ((publicKeyType == null) ^ (privateKeyType == null)) {
                throw new ArgumentException("Must supply 0 or 2 key types");
            }

            _data = data;
        }
        #endregion

        #region Accessors
        public int Id {
            get { return _id; }
        }

        public int? KeyVersion {
            get { return _keyVersion; }
            internal set { _keyVersion = value; }
        }

        public string Name {
            get { return _name; }
        }

        public ServiceKeyType? PrivateKeyType {
            get { return _privateKeyType; }
            internal set { _privateKeyType = value; }
        }

        public ServiceKeyType? PublicKeyType {
            get { return _publicKeyType; }
            internal set { _privateKeyType = value; }
        }
        
        public XmlNode Data {
            get { return _data; }
            internal set { _data = value; }
        }
        #endregion

        #region Static Methods
        private static PartnerCache _cache;

        public static Partner Get(int id)
        {
            return Cache[id];
        }

        public static Partner Get(string name)
        {
            return Cache[name];
        }

        private static PartnerCache Cache
        {
            get {
                PartnerCache cache;
                if ((cache = _cache) != null) return cache;

                lock (typeof(PartnerCache)) {
                    if ((cache = _cache) != null) return cache;
                    return cache = _cache = new PartnerCache();
                }
            }
        }

        public static void Flush()
        {
            lock (typeof(PartnerCache))
            {
                _cache = null;
            }
        }

        internal class PartnerCache
        {
            private Dictionary<int, Partner>    _byId   = new Dictionary<int, Partner>();
            private Dictionary<string, Partner> _byName = new Dictionary<string, Partner>();

            internal PartnerCache()
            {
               foreach (int partition in WSClient.GetPhysicalPartitions(ConfigUtil.SecUserHistoryWebstoreApp))
               {
                   using (WSClient ws = new WSClient(ConfigUtil.SecUserHistoryWebstoreApp, CmdType.READTHENWRITE_COMMANDTYPE))
                   {
                       ws.StoredProc = "dbo.p_partner_read";
                       ws.PhysicalPartition = partition;

                       // no parameters for this sproc means we get every partner

                       using (WstDataReader reader = ws.Execute())
                       {
                           while (reader.Read())
                           {
                               Partner partner = Read(reader);
                               _byId.Add(partner.Id, partner);
                               _byName.Add(partner.Name, partner);
                           }
                       }
                   }
               }
            }

            internal Partner this[int id]
            {
                get {
                    if (! _byId.ContainsKey(id)) return null;
                    return _byId[id];
                }
            }

            internal Partner this[string name]
            {
                get {
                    if (! _byName.ContainsKey(name)) return null;
                    return _byName[name];
                }
            }

            private static Partner Read(WstDataReader reader)
            {
                return new Partner(
                    WSClient.GetInt32(reader, "i_partner_id"),
                    WSClient.GetString(reader, "vc_partner_name"),
                    (ServiceKeyType?) WSClient.GetNullableInt32(reader, "i_private_key_type"),
                    (ServiceKeyType?) WSClient.GetNullableInt32(reader, "i_public_key_type"),
                    WSClient.GetNullableInt32(reader, "i_key_version"),
                    WSClient.GetNullableXml(reader, "xml_data")
                );
            }
        }
#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\dll\partner\PartnerUser.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Xml;
using System.Transactions;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.puidmgr;

using Microsoft.Webstore.WstClient;

namespace xonline.login.partner
{
    public class PartnerUser
    {
        private Puid    _xuid;
        private Puid    _partnerXuid;

        // partner specific user  id  and  credential
        // used for logging into the specific partner

        private string  _userId;
        private byte[]  _token;

        // opaque blob of user data for this  partner
        
        private XmlNode _data;

        // cached reference to the partner  used  for
        // encrypting and decrypting the  user  token

        private Partner _partner;

        private PartnerUser(Partner partner, ulong xuid, ulong partnerXuid)
        {
            _xuid        = xuid;
            _partnerXuid = partnerXuid;
            _partner     = partner;
        }

#region Accessors
        public Puid Xuid {
            get { return _xuid; }
            private set { _xuid = value; }
        }

        public Puid PartnerXuid {
            get { return _partnerXuid; }
            private set { _partnerXuid = value; }
        }

        public byte[] Token {
            get { return _token; }
            set { _token = value; }
        }

        public XmlNode Data
        {
            get { return _data;  }
            set { _data = value; }
        }

        public Partner Partner
        {
            get { return _partner; }
        }

        public string UserId
        {
            get { return _userId;  }
            set { _userId = value; }
        }
#endregion

        public void Save()
        {

            using (WSClient ws = new WSClient(ConfigUtil.SecUserHistoryWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_partner_user_update";
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_xuid);

                // key fields used to find the partner user for  this  user

                ws.AddParameter("@i_partner_id", Partner.Id);
                ws.AddParameter("@bi_user_xuid", Xuid);

                // if these are not there, then the stored  procedure  will
                // default these values to NULL (effectively deleting them)

                if (UserId != null) {
                    ws.AddParameter("@vc_user_id", UserId);
                }

                if (Token != null)
                {
                    if (Partner.PublicKeyType == null)
                        ws.AddParameter("@bin_token", Token);
                    else
                    {
                        // yes, we store the private key type (so we can decrypt)

                        ws.AddParameter("@i_private_key_type", (int) Partner.PrivateKeyType);
                        ws.AddParameter("@i_key_version", (int) Partner.KeyVersion);

                        using (RsaPublicKey publicKey = new RsaPublicKey((ServiceKeyType) Partner.PublicKeyType, (int) Partner.KeyVersion)) {
                            ws.AddParameter("@bin_token", publicKey.Encrypt(Token));
                        }
                    }
                }

                if (_data != null) {
                    ws.AddParameter("@xml_data", Data.OuterXml);
                }

                ws.ExecuteNonQuery();
            }
        }

#region Static Methods
        private static PartnerUser ReadPartnerXuid(WstDataReader reader)
        {
            Partner partner = Partner.Get(
                WSClient.GetInt32(reader, "i_partner_id")
            );

            PartnerUser partnerUser = new PartnerUser(
                partner, WSClient.GetUInt64(reader, "bi_user_xuid"),
                WSClient.GetUInt64(reader, "bi_partner_xuid")
            );

            int? keyType       = WSClient.GetNullableInt32(reader,  "i_private_key_type");
            int? keyVersion    = WSClient.GetNullableInt32(reader,  "i_key_version");

            partnerUser.UserId = WSClient.GetNullableString(reader, "vc_user_id");
            partnerUser.Token  = WSClient.GetNullableBytes(reader,  "bin_token");

            // if the key (and key version) are not  null,  then  the
            // partner credential needs to be decrypted using the key

            if (keyType != null) {
                using (RsaPrivateKey privateKey = new RsaPrivateKey((ServiceKeyType) keyType, (int) keyVersion)) {
                    partnerUser.Token = privateKey.Decrypt(partnerUser.Token);
                }
            }

            // finally we fetch the opaque user data for the partner
            string xml = WSClient.GetNullableString(reader, "xml_data");
            
            if (xml != null) {
                XmlDocument document = new XmlDocument();
                document.LoadXml(xml);
                partnerUser.Data = document.ChildNodes.Item(0);
            }
            
            return partnerUser;
        }

        private static PartnerUser ReadPartnerUser(WstDataReader reader)
        {
            Partner partner = Partner.Get(
                WSClient.GetInt32(reader, "i_partner_id")
            );

            PartnerUser partnerUser = new PartnerUser(
                partner, WSClient.GetUInt64(reader, "bi_user_xuid"),
                WSClient.GetUInt64(reader, "bi_partner_xuid")
            );

            return partnerUser;
        }


        public static PartnerUser GetPartnerXuid(int partnerId, Puid xuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.SecUserHistoryWebstoreApp, CmdType.READTHENWRITE_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_partner_user_read";
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(xuid);
                
                ws.AddParameter("@i_partner_id", partnerId);
                ws.AddParameter("@bi_user_xuid", xuid);

                using (WstDataReader reader = ws.Execute()) {
                    if (reader.Read()) return ReadPartnerXuid(reader);
                }

                // we got back an empty result set,  clear  the
                // parameters then create a  new  partner  user
                // and to create the reverse lookup
				
		using (TransactionScope txnScope = new TransactionScope())
		{
			ws.ClearParameters();

			ws.StoredProc = "dbo.p_partner_user_create";
			ws.PartitionType = WstPartitionType.Logical;
			ws.SetHashVal(xuid);

			// for the partner and xuid, but we also create
			// the pairwise xuid associated with that  pair

                        ulong pPUID = PUIDMgr.GetNewPUID();

			ws.AddParameter("@i_partner_id", partnerId);
			ws.AddParameter("@bi_user_xuid", xuid);
			ws.AddParameter("@bi_partner_xuid", pPUID);
			ws.AddParameter("@si_hash_bucket", ws.Partition);

			// create returns a partner just  like  the  get
			// but without userid,  token,  and data columns

			using (WstDataReader reader = ws.Execute()) 
                        {
			  if (reader.Read()) 
			  {
			    //created the partner, now we need the reverse
			    ws.ClearParameters();
			    ws.StoredProc = "dbo.p_partner_xuid_create";
                            ws.PartitionType = WstPartitionType.Logical;

                            ws.AddParameter("@i_partner_id", partnerId);
                            ws.AddParameter("@bi_user_xuid", xuid);
                            ws.AddParameter("@bi_partner_xuid", pPUID);
                            ws.AddParameter("@si_hash_bucket", ws.Partition);

			    using (WstDataReader xuidreader = ws.Execute())
                            {
                               if (xuidreader.Read())
                               {
                                   //both creates succeeded so now return
                                   //the data from the initial create call
                                   return ReadPartnerXuid(reader);
                               }
                            }
			  }
                        }

		        txnScope.Complete();
		}
                throw new Exception("Error getting partner xuid");
            }
        }

        public static PartnerUser GetPartnerUser(Puid partner_xuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.SecUserHistoryWebstoreApp, CmdType.READTHENWRITE_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_partner_xuid_read";
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(partner_xuid);
                
                ws.AddParameter("@bi_partner_xuid", partner_xuid);

                using (WstDataReader reader = ws.Execute()) {
                    if (reader.Read()) return ReadPartnerUser(reader);
                }

                throw new Exception("Error getting partner user");
            }
        }


        public static PartnerUser[] LookupPartnerXuid(int partnerId, params string[] userIds)
        {
            List<PartnerUser> partnerUsers = new List<PartnerUser>();

            DataTable userIdTable = new DataTable();
            userIdTable.Columns.Add("vc_user_id");
            foreach (string s in userIds) userIdTable.Rows.Add(s);

            using (WSClient ws = new WSClient(ConfigUtil.SecUserHistoryWebstoreApp, CmdType.READTHENWRITE_COMMANDTYPE))
            {
                for (int i = 0; i < ws.PhysicalPartitions; i++)
                {
                    ws.ClearParameters();

                    ws.Partition = i;
                    ws.PartitionType = WstPartitionType.Physical;

                    ws.StoredProc = "dbo.p_partner_user_lookup";
                    ws.AddParameter("@i_partner_id", partnerId);
                    ws.Parameters.AddWithValue("@vc_user_ids", userIdTable);

                    // execute and then read all the partner users and
                    // accumulate a list across all of the  partitions
                    
                    using (WstDataReader reader = ws.Execute()) {
                        while (reader.Read()) {
                            partnerUsers.Add(ReadPartnerXuid(reader));
                        }
                    }
                }
            }

            return partnerUsers.ToArray();
        }
#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\LogLineClass.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

using xonline.common.offer;
using xonline.common.billing;

namespace xonline.common.logline
{
    public class LogLineClass
    {
        protected Dictionary<string, string> m_parameters;
        protected DateTime m_calltime;
        protected string m_apiname;
        protected string m_apidescription;
        protected string m_component;

        public LogLineClass()
        {
            m_parameters = new Dictionary<string, string>();
            m_calltime = DateTime.MinValue;
            m_apiname = null;
            m_apidescription = null;
            m_component = null;
        }

        public Dictionary<string, string> Parameters
        {
            get
            {
                return m_parameters;
            }
            set
            {
                m_parameters = value;
            }
        }

        public DateTime CallTime
        {
            get
            {
                return m_calltime;
            }
            set
            {
                m_calltime = value;
            }
        }

        public string ApiName
        {
            get
            {
                return m_apiname;
            }
            set
            {
                m_apiname = value;
            }
        }

        public string ApiDescription
        {
            get
            {
                return m_apidescription;
            }
            set
            {
                m_apidescription = value;
            }
        }

        public string Component
        {
            get
            {
                return m_component;
            }
            set
            {
                m_component = value;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\LogLineSchema.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.4.1
// Schema file: loglines.xsd
// Creation Date: 12/22/2009 12:36:00 PM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace xonline.common.logline
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/loglines";
	}

	[Serializable]
	public enum ElementType
	{
		[XmlEnum(Name="Bitfield")] Bitfield,
		[XmlEnum(Name="CountryID")] CountryID,
		[XmlEnum(Name="CultureID")] CultureID,
		[XmlEnum(Name="Date")] Date,
		[XmlEnum(Name="DMPFailureCheck")] DMPFailureCheck,
		[XmlEnum(Name="DMPOrderIDType")] DMPOrderIDType,
		[XmlEnum(Name="DMPPurchaseOrigin")] DMPPurchaseOrigin,
		[XmlEnum(Name="DMPPurchaseType")] DMPPurchaseType,
		[XmlEnum(Name="DMPStatus")] DMPStatus,
		[XmlEnum(Name="DMPTransactionStatus")] DMPTransactionStatus,
		[XmlEnum(Name="Double")] @Double,
		[XmlEnum(Name="HexNumber")] HexNumber,
		[XmlEnum(Name="HResult")] HResult,
		[XmlEnum(Name="HtmlEncodedXml")] HtmlEncodedXml,
		[XmlEnum(Name="LanguageID")] LanguageID,
		[XmlEnum(Name="Number")] Number,
		[XmlEnum(Name="OfferType")] OfferType,
		[XmlEnum(Name="PaymentTypeID")] PaymentTypeID,
		[XmlEnum(Name="PricePair")] PricePair,
		[XmlEnum(Name="PUIDHighLow")] PUIDHighLow,
		[XmlEnum(Name="Rating")] Rating,
		[XmlEnum(Name="RatingSystem")] RatingSystem,
		[XmlEnum(Name="StorageKey")] StorageKey,
		[XmlEnum(Name="SyncCastFulfillmentActionType")] SyncCastFulfillmentActionType,
		[XmlEnum(Name="Text")] Text,
		[XmlEnum(Name="TierID")] TierID,
		[XmlEnum(Name="TitleId")] TitleId,
		[XmlEnum(Name="TitleIdHex")] TitleIdHex,
		[XmlEnum(Name="WMRMChallengeType")] WMRMChallengeType
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public partial class ElementCollection : ArrayList
	{
		public xonline.common.logline.Element Add(xonline.common.logline.Element obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.logline.Element Add()
		{
			return Add(new xonline.common.logline.Element());
		}

		public void Insert(int index, xonline.common.logline.Element obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.logline.Element obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.logline.Element this[int index]
		{
			get { return (xonline.common.logline.Element) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public partial class ElementGroupCollection : ArrayList
	{
		public xonline.common.logline.ElementGroup Add(xonline.common.logline.ElementGroup obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.logline.ElementGroup Add()
		{
			return Add(new xonline.common.logline.ElementGroup());
		}

		public void Insert(int index, xonline.common.logline.ElementGroup obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.logline.ElementGroup obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.logline.ElementGroup this[int index]
		{
			get { return (xonline.common.logline.ElementGroup) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public partial class LogLineCollection : ArrayList
	{
		public xonline.common.logline.LogLine Add(xonline.common.logline.LogLine obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.logline.LogLine Add()
		{
			return Add(new xonline.common.logline.LogLine());
		}

		public void Insert(int index, xonline.common.logline.LogLine obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.logline.LogLine obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.logline.LogLine this[int index]
		{
			get { return (xonline.common.logline.LogLine) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="Element",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public partial class Element
	{

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlElement(ElementName="elementType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.logline.ElementType __elementType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __elementTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.logline.ElementType elementType
		{ 
			get { return __elementType; }
			set { __elementType = value; __elementTypeSpecified = true; }
		}

		[XmlElement(ElementName="description",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __description;
		
		[XmlIgnore]
		public string description
		{ 
			get { return __description; }
			set { __description = value; }
		}

		public Element()
		{
		}
	}


	[XmlType(TypeName="ElementGroup",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public partial class ElementGroup
	{

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlElement(ElementName="description",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __description;
		
		[XmlIgnore]
		public string description
		{ 
			get { return __description; }
			set { __description = value; }
		}

		[XmlElement(Type=typeof(xonline.common.logline.Element),ElementName="element",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ElementCollection __elementCollection;
		
		[XmlIgnore]
		public ElementCollection elementCollection
		{
			get
			{
				if (__elementCollection == null) __elementCollection = new ElementCollection();
				return __elementCollection;
			}
			set {__elementCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.logline.ElementGroup),ElementName="elementGroup",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ElementGroupCollection __elementGroupCollection;
		
		[XmlIgnore]
		public ElementGroupCollection elementGroupCollection
		{
			get
			{
				if (__elementGroupCollection == null) __elementGroupCollection = new ElementGroupCollection();
				return __elementGroupCollection;
			}
			set {__elementGroupCollection = value;}
		}

		public ElementGroup()
		{
		}
	}


	[XmlType(TypeName="LogLine",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public partial class LogLine
	{

		[XmlElement(ElementName="identifier",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __identifier;
		
		[XmlIgnore]
		public string identifier
		{ 
			get { return __identifier; }
			set { __identifier = value; }
		}

		[XmlElement(ElementName="api",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __api;
		
		[XmlIgnore]
		public string api
		{ 
			get { return __api; }
			set { __api = value; }
		}

		[XmlElement(ElementName="component",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __component;
		
		[XmlIgnore]
		public string component
		{ 
			get { return __component; }
			set { __component = value; }
		}

		[XmlElement(ElementName="description",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __description;
		
		[XmlIgnore]
		public string description
		{ 
			get { return __description; }
			set { __description = value; }
		}

		[XmlElement(ElementName="filenameWhereLogged",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __filenameWhereLogged;
		
		[XmlIgnore]
		public string filenameWhereLogged
		{ 
			get { return __filenameWhereLogged; }
			set { __filenameWhereLogged = value; }
		}

		[XmlElement(ElementName="filenameWhereDefined",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __filenameWhereDefined;
		
		[XmlIgnore]
		public string filenameWhereDefined
		{ 
			get { return __filenameWhereDefined; }
			set { __filenameWhereDefined = value; }
		}

		[XmlElement(Type=typeof(xonline.common.logline.Element),ElementName="element",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ElementCollection __elementCollection;
		
		[XmlIgnore]
		public ElementCollection elementCollection
		{
			get
			{
				if (__elementCollection == null) __elementCollection = new ElementCollection();
				return __elementCollection;
			}
			set {__elementCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.logline.ElementGroup),ElementName="elementGroup",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ElementGroupCollection __elementGroupCollection;
		
		[XmlIgnore]
		public ElementGroupCollection elementGroupCollection
		{
			get
			{
				if (__elementGroupCollection == null) __elementGroupCollection = new ElementGroupCollection();
				return __elementGroupCollection;
			}
			set {__elementGroupCollection = value;}
		}

		public LogLine()
		{
		}
	}


	[XmlRoot(ElementName="LogLines",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public partial class LogLines
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
            return logLineCollection.GetEnumerator();
		}

		public xonline.common.logline.LogLine Add(xonline.common.logline.LogLine obj)
		{
			return logLineCollection.Add(obj);
		}

		[XmlIgnore]
		public xonline.common.logline.LogLine this[int index]
		{
			get { return (xonline.common.logline.LogLine) logLineCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return logLineCollection.Count; }
        }

        public void Clear()
		{
			logLineCollection.Clear();
        }

		public xonline.common.logline.LogLine Remove(int index) 
		{ 
            xonline.common.logline.LogLine obj = logLineCollection[index];
            logLineCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            logLineCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(xonline.common.logline.LogLine),ElementName="logLine",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LogLineCollection __logLineCollection;
		
		[XmlIgnore]
		public LogLineCollection logLineCollection
		{
			get
			{
				if (__logLineCollection == null) __logLineCollection = new LogLineCollection();
				return __logLineCollection;
			}
			set {__logLineCollection = value;}
		}

		public LogLines()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\LogLine.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.ServiceProcess;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Services.Protocols;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

using xonline.common.billing;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.common.logline
{
    public class LogLineUtil
    {
        private Hashtable m_lines;
        private TitleCollection titleCollection;

        public Hashtable Lines
        {
            get
            {
                if (m_lines == null)
                    LoadDefinitions();

                return m_lines;
            }
        }

        public LogLineUtil()
        {
            m_lines = null;
            titleCollection = null;
        }

        public static string LookupEnum(string s, Type enumType)
        {
            string formattedValue = string.Empty;

            ulong ul = ParseUlong(s);

            Array values = Enum.GetValues(enumType);
            string enumName = enumType.Name;

            foreach (object o in values)
            {
                ulong ulv = Convert.ToUInt64(o);

                if (ul == ulv)
                {
                    formattedValue += string.Format("{0} ({1}={2:X8})",
                        Enum.GetName(enumType, ulv), enumName, ulv);

                    break;
                }
            }

            if (formattedValue == string.Empty)
                formattedValue = string.Format("unknown ({0}={1})", enumName, ul);

            return formattedValue;
        }

        public static string LookupBitfield(string s, Type enumType)
        {
            string formattedValue = string.Empty;

            ulong ul = ParseUlong(s);

            Array values = Enum.GetValues(enumType);
            string enumName = enumType.Name;

            foreach (object o in values)
            {
                ulong ulv = Convert.ToUInt64(o);

                if ((ul & ulv) == ulv)
                {
                    if (formattedValue != string.Empty)
                        formattedValue += ", ";

                    formattedValue += string.Format("{0} ({1}={2:X8})",
                        Enum.GetName(enumType, ulv), enumName, ulv);

                    // remove this bit to prevent listing out combined bitflag enumeration values
                    ul = ul & ~ulv;
                }
            }

            if (formattedValue == string.Empty)
                formattedValue = string.Format("unknown ({0}={1})", enumName, ul);

            return formattedValue;
        }

        public string LookupTitleName(int id)
        {
            if (null == titleCollection)
                titleCollection = new TitleCollection(@"titles.xml");

            return (titleCollection[id].Name);
        }

        public string LookupTitleName(string str)
        {
            return (LookupTitleName(ParseInt32(str, 0)));
        }

        public string ExplainLogLine(string logLine)
        {
            string [] sections = logLine.Split("|".ToCharArray());

            // see if we have a datetime or not, we want to handle things either way
            try
            {
                DateTime dtLogLine = DateTime.Parse(sections[0]);
            }
            catch
            {
                logLine = "|" + logLine;
                sections = logLine.Split("|".ToCharArray());
            }

            string identifier = sections[1];

            object o = Lines[identifier];
            if (o == null)
            {
                return string.Format("unknown logline identifier: {0}", identifier);
            }
            else if (o is LogLine)
            {
                LogLine lineDef = (LogLine) Lines[identifier];
                return ExplainLogLine(sections, lineDef);
            }
            else if (o is ArrayList)
            {
                // duplicate definition :-(
                // try each LogLine and see if one parses, hopefully they both don't

                ArrayList list = (ArrayList) o;
                foreach (LogLine lineDef in list)
                {
                    try
                    {
                        string explanation = ExplainLogLine(sections, lineDef);
                        return explanation;
                    }
                    catch
                    {
                        // try the next one in the list
                    }
                }

                return string.Format("tried {0} definitions for {1}, all failed", list.Count, identifier);
            }
            else
            {
                return "uh oh";
            }

        }

        public string ExplainElement(string [] sections, ref int section,
            ArrayList ec, ref int element)
        {
            Element e = (Element)ec[element];

            if (section >= sections.Length)
            {
                element++;

                return "not found in log entry";
            }

            char[] trim = { ' ', '\t', '\n' };
            string s = sections[section].Trim(trim);
            string formattedValue = "unknown";

            try
            {
                if (s == "" || s == null)
                {
                    formattedValue = "(empty)";
                }
                else
                {
                    switch (e.elementType)
                    {
                        case ElementType.Date:
                            {
                                DateTime dt = DateTime.Parse(s);
                                formattedValue = string.Format("{0}, {1} (GMT)", dt.ToLongDateString(), dt.ToLongTimeString());
                                break;
                            }

                        case ElementType.HResult:
                            {
                                ulong hr = SafeConvert.ToUInt64(s);
                                formattedValue = string.Format("0x{0} ({1})", s, hr);
                                break;
                            }

                        case ElementType.Number:
                            {
                                ulong num = ParseUlong(s);
                                formattedValue = string.Format("0x{0} (decimal={1})", num.ToString("X"), num);
                                break;
                            }

                        case ElementType.HexNumber:
                            {
                                UInt64 num = ParseUInt64(s, 0 /* default */, 16 /* forceBase */);
                                formattedValue = String.Format("0x{0} (decimal={1})", num.ToString("X"), num);
                                break;
                            }

                        case ElementType.Double:
                            {
                                double d = ParseDouble(s);
                                formattedValue = string.Format("{0:f}", d);
                                break;
                            }

                        case ElementType.Bitfield:
                            {
                                ulong num = ParseUlong(s);
                                if (num > UInt32.MaxValue)
                                {
                                    formattedValue = string.Format("0x{0} ({1}[56] {2}[48] {3}[40] {4}[32] {5}[24] {6}[16] {7}[8] {8}[0])",
                                        num.ToString("X").PadLeft(16, '0'),
                                        Convert.ToString((uint)((num >> 56) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 48) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 40) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 32) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 24) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 16) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 08) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 00) & 0xFF), 2).PadLeft(8, '0'));
                                }
                                else
                                {
                                    formattedValue = string.Format("0x{0} ({1}[24] {2}[16] {3}[8] {4}[0])",
                                        num.ToString("X").PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 24) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 16) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 08) & 0xFF), 2).PadLeft(8, '0'),
                                        Convert.ToString((uint)((num >> 00) & 0xFF), 2).PadLeft(8, '0'));
                                }

                                break;
                            }

                        case ElementType.CountryID:
                            uint cid = ParseUint(s);
                            string cfn = CountryUtil.GetFriendlyName((int)cid);
                            string code = CountryUtil.GetCode((int)cid);
                            formattedValue = string.Format("{0} (cid={1}, code={2})", cfn, cid, code);
                            break;

                        case ElementType.CultureID:
                            uint cultId = ParseUint(s);

                            if (cultId == 0)
                            {
                                formattedValue = "unknown (id=0)";
                            }
                            else
                            {
                                string cultName = Culture.CultureToString((int)cultId);
                                string cultCode = Culture.CultureToCode((int)cultId);
                                formattedValue = string.Format("{0} (id={1}, code={2})", cultName, cultId, cultCode);
                            }
                            break;

                        case ElementType.LanguageID:
                            uint langid = ParseUint(s);
                            string lfn = LanguageUtil.GetFriendlyName((int)langid);
                            formattedValue = string.Format("{0} (langid={1})", lfn, langid);
                            break;

                        case ElementType.TierID:
                            formattedValue = LookupEnum(s, typeof(TierEnum));

                            break;

                        case ElementType.PaymentTypeID:
                            formattedValue = LookupEnum(s, typeof(PaymentTypeEnum));

                            break;

                        case ElementType.DMPStatus:
                            formattedValue = LookupEnum(s, typeof(DMPWSDL.Status));

                            break;

                        case ElementType.Text:
                            formattedValue = string.Format("{0}", s);
                            break;

                        case ElementType.StorageKey:
                            break;

                        case ElementType.PUIDHighLow:
                            uint puidHigh = ParseUint(s);
                            section++;
                            s = sections[section];
                            uint puidLow = ParseUint(s);
                            ulong puid = ((ulong)puidHigh << 32) | ((ulong)puidLow & 0xFFFFFFFF);
                            formattedValue = string.Format("0x{0} (decimal={1})", puid.ToString("X"), puid);
                            break;

                        case ElementType.PricePair:
                            ulong priceWhole = ParseUlong(s);
                            section++;
                            s = sections[section];
                            ulong priceFractional = ParseUlong(s);
                            formattedValue = string.Format("{0}.{1}", priceWhole, priceFractional);
                            break;

                        case ElementType.Rating:
                            formattedValue = string.Empty;
                            ushort rating = ParseUshort(s);

                            ushort[] ratings =
                            {
                                0x0000,
                                0x0002,
                                0x0004,
                                0x0006,
                                0x0008,
                                0x000E,
                                0x00FF,
                                0x0100,
                                0x0104,
                                0x0109,
                                0x010D,
                                0x010E,
                                0x0200,
                                0x0204,
                                0x0208,
                                0x020C,
                                0x020E,
                                0x0301,
                                0x0303,
                                0x0309,
                                0x030D,
                                0x030E,
                                0x0400,
                                0x0401,
                                0x0404,
                                0x0405,
                                0x0409,
                                0x040C,
                                0x040D,
                                0x040E,
                                0x0500,
                                0x0502,
                                0x0504,
                                0x0506,
                                0x0500,
                                0x0600,
                                0x0602,
                                0x0604,
                                0x0606,
                                0x0608,
                                0x0700,
                                0x0702,
                                0x0704,
                                0x0706,
                                0x070F,
                                0x0800,
                                0x0802,
                                0x0804,
                                0x0806,
                                0x080F,
                                0x0900,
                                0x0902,
                                0x0904,
                                0x0906,
                                0x0A00,
                                0x0A02,
                                0x0A04,
                                0x0A05,
                                0x0A08,
                                0x3FFF
                            };

                            string[] ratingNames =
                            {
                                "ESRB - eC (Early Childhood)",
                                "ESRB - E (Everyone)",
                                "ESRB - E10 (10+)",
                                "ESRB - T (Teen)",
                                "ESRB - M (Mature)",
                                "ESRB - AO (Adult Oriented)",
                                "ESRB - RP (Rating Pending)",
                                "PEGI - Ages 3+",
                                "PEGI - Ages 7+",
                                "PEGI - Ages 12+",
                                "PEGI - Ages 16+",
                                "PEGI - Ages 18+",
                                "PEGI (Finland) - Ages 3+",
                                "PEGI (Finland) - Ages 7+",
                                "PEGI (Finland) - Ages 11+",
                                "PEGI (Finland) - Ages 15+",
                                "PEGI (Finland) - Ages 18+",
                                "PEGI (Portugal) - Ages 4+",
                                "PEGI (Portugal) - Ages 6+",
                                "PEGI (Portugal) - Ages 12+",
                                "PEGI (Portugal) - Ages 16+",
                                "PEGI (Portugal) - Ages 18+",
                                "PEGI BBFC - 3+",
                                "PEGI BBFC - U",
                                "PEGI BBFC - 7+",
                                "PEGI BBFC - PG",
                                "PEGI BBFC - 12+",
                                "PEGI BBFC - 15+",
                                "PEGI BBFC - 16+",
                                "PEGI BBFC - 18+",
                                "CERO - All Ages",
                                "CERO - 12+",
                                "CERO - 15+",
                                "CERO - 18+",
                                "CERO - Standard",
                                "USK - Released without age restriction",
                                "USK - Released starting from 6 years",
                                "USK - Released starting from 12 years",
                                "USK - Released starting from 16 years",
                                "USK - No youth release",
                                "OFLC - G",
                                "OFLC - G8+",
                                "OFLC - M15+",
                                "OFLC - MA15+",
                                "OFLC - RC",
                                "OFLC - G",
                                "OFLC - G8+",
                                "OFLC - M15+",
                                "OFLC - MA15+",
                                "OFLC - RC",
                                "KMRB - All",
                                "KMRB - 12 year",
                                "KMRB - 15 year",
                                "KMRB - 18 year",
                                "Brazil - All",
                                "Brazil - 12+",
                                "Brazil - 14+",
                                "Brazil - 16+",
                                "Brazil - 18+",
                                "No Restrictions"
                            };

                            for (int i = 0; i < ratings.Length; i++)
                            {
                                if (rating == ratings[i])
                                    formattedValue = string.Format("{0} (rating={1})", ratingNames[i], rating);
                            }

                            if (formattedValue == string.Empty)
                                formattedValue = string.Format("unknown (rating={0})", rating);

                            break;

                        case ElementType.RatingSystem:
                            formattedValue = string.Empty;
                            ushort ratingSystem = ParseUshort(s);

                            ushort[] ratingSystems =
                            {
                                0,
                                1,
                                2,
                                3,
                                4,
                                5,
                                6,
                                7,
                                8,
                                9,
                                10,
                                63
                            };

                            string[] ratingSystemNames =
                            {
                                "ESRB",
                                "PEGI",
                                "PEGI (Finland)",
                                "PEGI (Portugal)",
                                "PEGI/BBFC (UK/Ireland)",
                                "CERO",
                                "USK",
                                "OFLC (Australia)",
                                "OFLC (New Zealand)",
                                "KMRB (Korea)",
                                "Brazil",
                                "No Rating System"
                            };

                            for (int i = 0; i < ratingSystems.Length; i++)
                            {
                                if (ratingSystem == ratingSystems[i])
                                    formattedValue = string.Format("{0} (ratingSystem={1})", ratingSystemNames[i], ratingSystem);
                            }

                            if (formattedValue == string.Empty)
                                formattedValue = string.Format("unknown (ratingSystem={0})", ratingSystem);

                            break;

                        case ElementType.OfferType:
                            formattedValue = LookupBitfield(s, typeof(OfferingTypeEnum));

                            break;

                        case ElementType.DMPFailureCheck:
                            if (string.Compare(s, "Failed", true) == 0)
                            {
                                // due to failure, all of the out params will be empty

                                section = sections.Length - 1;
                                element = ec.Count - 1;

                                return null;
                            }
                            else
                            {
                                // there was no failure, so move on to the next element
                                // without incrementing the section we are on

                                element++;

                                return null;
                            }

                        case ElementType.DMPTransactionStatus:
                            formattedValue = LookupEnum(s, typeof(DMPClient.DMPTransactionStatus));

                            break;

                        case ElementType.DMPPurchaseOrigin:
                            formattedValue = LookupEnum(s, typeof(DMPPurchaseOrigin));
                            break;

                        case ElementType.DMPPurchaseType:
                            formattedValue = LookupEnum(s, typeof(DMPClient.DMPPurchaseType));

                            break;

                        case ElementType.DMPOrderIDType:
                            formattedValue = LookupEnum(s, typeof(DMPClient.DMPOrderIDType));
                            break;

                        case ElementType.TitleId:
                            formattedValue = String.Format("{0} = {1}", s, LookupTitleName(s));
                            break;

                        case ElementType.TitleIdHex:
                            {
                            Int32 titleId = ParseInt32(s, 0 /* default */, 16 /* forceBase */);
                            formattedValue = String.Format("0x{0:X} = {1}", titleId, LookupTitleName(titleId));
                            }
                            break;

                        case ElementType.HtmlEncodedXml:
                            formattedValue = DecodeAndPrettyPrintXml(s);
                            break;

                        default:
                            formattedValue = string.Format("(invalid type) {0}", s);
                            break;
                    }
                }

                section++;
                element++;
            }
            catch (Exception ex)
            {
                throw new ApplicationException(String.Format("Could not convert section {0} to an ElementType.{1}. The value being converted is \"{2}\".",
                    section, e.elementType.ToString("G"), s), ex);
            }

            return formattedValue;
        }

        public string ExplainElementGroup(string [] sections, ref int section, ElementGroup eg)
        {
            StringBuilder explanation = new StringBuilder();

            int groupLength = Int32.Parse(sections[section]);
            section++;

            explanation.AppendFormat("{0} ({1}): [{2} items]\n",
                eg.friendlyName, eg.description, groupLength);

            for (int c = 0; c < groupLength; c++)
            {
                explanation.AppendFormat("{0}\n", c);

                for (int element = 0; element < eg.elementCollection.Count;)
                {
                    if (section >= sections.Length)
                    {
                        explanation.AppendFormat("    {0,-21}: {1}\n",
                            eg.friendlyName, "not found in log entry");

                        element++;

                        continue;
                    }

                    object o = eg.elementCollection[element];
                    if (o is Element)
                    {
                        Element e = (Element) o;

                        string formattedValue = ExplainElement(sections, ref section,
                            eg.elementCollection, ref element);

                        if (formattedValue != null)
                        {
                            if ( IsMultilineValuedElement(e) )
                            {
                                explanation.AppendFormat("{0,-21}: {1,-60} // {2}\n{3}",
                                    e.friendlyName, "", e.description, formattedValue);
                            }
                            else
                            {
                                explanation.AppendFormat("    {0,-21}: {1,-60} // {2}\n", e.friendlyName, formattedValue,
                                    e.description);
                            }
                        }
                    }
                    else if (o is ElementGroup)
                    {
                        ElementGroup nestedEg = (ElementGroup) o;

                        explanation.Append(ExplainElementGroup(sections, ref section, nestedEg));

                        element++;
                    }
                }
            }

            return explanation.ToString();
        }

        public string ExplainLogLine(string [] sections, LogLine lineDef)
        {
            StringBuilder explanation = new StringBuilder();

            explanation.AppendFormat("{0,-25}: {1}\n",
                "API Name", lineDef.api);
            explanation.AppendFormat("{0,-25}: {1}\n",
                "API Description", lineDef.description);
            explanation.AppendFormat("{0,-25}: {1}\n",
                "Component Name", lineDef.component);

            if (!String.IsNullOrEmpty(lineDef.filenameWhereLogged))
            {
                explanation.AppendFormat("{0,-25}: {1}\n",
                    "Logged from",
                    lineDef.filenameWhereLogged);
            }

            try
            {
                DateTime dtLogLine = DateTime.Parse(sections[0]);

                explanation.AppendFormat("{0,-25}: {1}, {2} (adjusted to local server time), {3}, {4} (unadjusted from log)\n",
                    "DateTime API Called", dtLogLine.ToLocalTime().ToLongDateString(),
                    dtLogLine.ToLocalTime().ToLongTimeString(), dtLogLine.ToLongDateString(),
                    dtLogLine.ToLongTimeString());
            }
            catch
            {
                // fine, no datetime
            }

            int element;
            int section = 2;

            for (element = 0; element < lineDef.elementCollection.Count;)
            {
                object o = lineDef.elementCollection[element];
                if (o is Element)
                {
                    Element e = (Element) o;

                    string formattedValue = ExplainElement(sections, ref section,
                        lineDef.elementCollection, ref element);

                    if (formattedValue != null)
                    {
                        if ( IsMultilineValuedElement(e) )
                        {
                            explanation.AppendFormat("{0,-25}: {1,-60} // {2}\n{3}",
                                e.friendlyName, "", e.description, formattedValue);
                        }
                        else
                        {
                            explanation.AppendFormat("{0,-25}: {1,-60} // {2}\n",
                                e.friendlyName, formattedValue, e.description);
                        }
                    }
                }
                else if (o is ElementGroup)
                {
                    ElementGroup eg = (ElementGroup) o;

                    explanation.Append(ExplainElementGroup(sections, ref section, eg));

                    element++;
                }
            }

            if (section < sections.Length)
                explanation.AppendFormat("WARNING: The parsed line contains more sections than were defined for this line type in \"{0}\".", lineDef.filenameWhereDefined);

            return explanation.ToString();
        }

        public LogLineClass ParseLogLine(string logLine)
        {
            LogLineClass parsedLogLine = null;
            DateTime dtLogLine = DateTime.MinValue;
            string[] sections = logLine.Split("|".ToCharArray());

            // see if we have a datetime or not, we want to handle things either way
            try
            {
                dtLogLine = DateTime.Parse(sections[0]);
            }
            catch
            {
                logLine = "|" + logLine;
                sections = logLine.Split("|".ToCharArray());
                dtLogLine = DateTime.MinValue;
            }

            string identifier = sections[1];

            object o = Lines[identifier];
            if (o == null)
            {
                Console.WriteLine("unknown logline identifier: {0}", identifier);
                parsedLogLine = new LogLineClass();
                parsedLogLine.ApiName = identifier;
                parsedLogLine.CallTime = dtLogLine;
            }
            else if (o is LogLine)
            {
                LogLine lineDef = (LogLine)Lines[identifier];
                parsedLogLine = ParseLogLine(sections, lineDef);
            }
            else if (o is ArrayList)
            {
                // duplicate definition :-(
                // try each LogLine and see if one parses, hopefully they both don't

                ArrayList list = (ArrayList)o;
                foreach (LogLine lineDef in list)
                {
                    try
                    {
                        parsedLogLine = ParseLogLine(sections, lineDef);
                    }
                    catch
                    {
                        // try the next one in the list
                    }
                }

                Console.WriteLine("tried {0} definitions for {1}, all failed", list.Count, identifier);
            }
            else
            {
                Console.WriteLine("uh oh");
            }

            return parsedLogLine;
        }

        public LogLineClass ParseLogLine(string[] sections, LogLine lineDef)
        {
            LogLineClass logLineClass = new LogLineClass();

            logLineClass.ApiName = lineDef.api;
            logLineClass.ApiDescription = lineDef.description;
            logLineClass.Component = lineDef.component;

            try
            {
                DateTime dtLogLine = DateTime.Parse(sections[0]);
                logLineClass.CallTime = dtLogLine;
            }
            catch
            {
                // fine, no datetime
            }

            int section = 2;
            for (int element = 0; element < lineDef.elementCollection.Count; )
            {
                object o = lineDef.elementCollection[element];
                if (o is Element)
                {
                    Element e = (Element)o;

                    // element and section are incremented by ExplainElement()
                    string formattedValue = ExplainElement(sections, ref section,
                        lineDef.elementCollection, ref element);

                    if (formattedValue != null)
                    {
                        logLineClass.Parameters.Add(e.friendlyName, formattedValue);
                    }
                }
                else if (o is ElementGroup)
                {
                    ElementGroup eg = (ElementGroup)o;

                    Dictionary<string, string> callParameters = ParseElementGroup(sections, ref section, eg);
                    foreach (KeyValuePair<string, string> de in callParameters)
                    {
                        logLineClass.Parameters.Add(de.Key, de.Value);
                    }

                    element++;
                }
            }

            return logLineClass;
        }

        public Dictionary<string, string> ParseElementGroup(string[] sections, ref int section, ElementGroup eg)
        {
            Dictionary<string, string> callParameters = new Dictionary<string, string>();

            int groupLength = Int32.Parse(sections[section]);
            section++;

            callParameters.Add(eg.friendlyName, groupLength.ToString());

            for (int c = 0; c < groupLength; c++)
            {
                for (int element = 0; element < eg.elementCollection.Count; )
                {
                    if (section >= sections.Length)
                    {
                        // not found in log entry
                        element++;

                        continue;
                    }

                    object o = eg.elementCollection[element];
                    if (o is Element)
                    {
                        Element e = (Element)o;

                        string formattedValue = ExplainElement(sections, ref section,
                            eg.elementCollection, ref element);

                        if (formattedValue != null)
                        {
                            callParameters.Add(e.friendlyName, formattedValue);
                        }
                    }
                    else if (o is ElementGroup)
                    {
                        ElementGroup nestedEg = (ElementGroup)o;

                        Dictionary<string, string> nestedcallParameters = ParseElementGroup(sections, ref section, nestedEg);
                        foreach (KeyValuePair<string, string> de in nestedcallParameters)
                        {
                            callParameters.Add(de.Key, de.Value);
                        }

                        element++;
                    }
                }
            }

            return callParameters;
        }

        private void LoadDefinitions()
        {
            m_lines = new Hashtable();

            string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            string [] files = Directory.GetFiles(path, "*.logline.xml");

            foreach (string file in files)
            {
                string filePath = Path.Combine(path, file);

                try
                {
                    LoadDefinitions(filePath);
                }
                catch (Exception e)
                {
                    // This used to swallow exceptions. That made it nearly impossible to
                    // debug problems with your XML file. However, using a MessageBox may
                    // not be the best choice, as it depends on having a GUI application;
                    // if anyone ever uses LogLine in a batch-processed automated
                    // command-line way, it would be stupid to pop up a message box. But
                    // it works fine for now and is definitely worth it as we all add more
                    // XML files to this thing.
                    MessageBox.Show(
                        String.Format("Could not parse configuration file {0}. It will be ignored. {1}", filePath, e.ToString()),
                        "Error parsing XML",
                        MessageBoxButtons.OK
                        );
                }
            }
        }

        private void LoadDefinitions(string file)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(LogLines));
            XmlReader validatingReader = CreateValidatingReader(file);
            LogLines lines = (LogLines) serializer.Deserialize(validatingReader);

            foreach (LogLine line in lines)
            {
                line.filenameWhereDefined = file;

                if (m_lines.Contains(line.identifier))
                {
                    // if there is an identifier collision, try to differentiate by the number of elements

                    LogLine l = (LogLine) m_lines[line.identifier];
                    m_lines.Remove(line.identifier);

                    ArrayList list = new ArrayList();
                    list.Add(l);
                    list.Add(line);

                    m_lines[line.identifier] = list;
                }
                else
                {
                    m_lines[line.identifier] = line;
                }
            }
        }

        private XmlReader CreateValidatingReader(string file)
        {
            string schemaPath = Path.Combine(
                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                "LogLines.xsd");
            if (!File.Exists(schemaPath))
                throw new Exception(string.Format("cannot find LogLines.xsd at {0}", schemaPath));

            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add(null, new XmlTextReader(schemaPath));
            readerSettings.ValidationType = ValidationType.Schema;

            StreamReader streamReader = new StreamReader(file);
            XmlReader validatingReader = XmlReader.Create(new XmlTextReader(streamReader), readerSettings);

            return validatingReader;
        }

        private static int ParseInt32(string str, int nDefault, int forceBase)
        {
            try
            {
                int fromBase = 10;

                if (str.StartsWith("0x"))
                {
                    fromBase = 16;
                    str = str.Substring(2);
                }

                if (0 < forceBase)
                    fromBase = forceBase;

                return (str == String.Empty ? nDefault : Convert.ToInt32(str, fromBase));
            }
            catch
            {
                return nDefault;
            }
        }

        private static int ParseInt32(string str, int nDefault)
        {
            return(ParseInt32(str, nDefault, -1 /* forceBase */));
        }

        private static UInt64 ParseUInt64(string str, UInt64 nDefault, int forceBase)
        {
            try
            {
                int fromBase = 10;

                if (str.StartsWith("0x"))
                {
                    fromBase = 16;
                    str = str.Substring(2);
                }

                if (0 < forceBase)
                    fromBase = forceBase;

                return (str == String.Empty ? nDefault : Convert.ToUInt64(str, fromBase));
            }
            catch
            {
                return nDefault;
            }
        }

        private static UInt64 ParseUInt64(string str, UInt64 nDefault)
        {
            return (ParseUInt64(str, nDefault, -1 /* forceBase */));
        }

        private static UInt64 ParseUInt64(string str)
        {
            return (ParseUInt64(str, 0 /* default */, -1 /* forceBase */));
        }

        private static ulong ParseUlong(string s)
        {
            s = s.Trim().ToUpper();

            ulong u;

            if (s.Length > 2 && s[0] == '0' && s[1] == 'X')
                u = UInt64.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    u = (ulong)Int64.Parse(s);
                }
                catch (FormatException)
                {
                    u = UInt64.Parse(s, NumberStyles.HexNumber);
                }
                catch (OverflowException)
                {
                    // If its going to overflow we'll set it to 0. Yes this happened in an applog
                    u = 0;
                }

            }

            return u;
        }

        private static uint ParseUint(string s)
        {
            s = s.Trim().ToUpper();

            uint i;

            if (s.Length > 2 && s[0] == '0' && s[1] == 'X')
                i = UInt32.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    i = (uint) Int32.Parse(s);
                }
                catch (FormatException)
                {
                    i = UInt32.Parse(s, NumberStyles.HexNumber);
                }
            }

            return i;
        }

        private static ushort ParseUshort(string s)
        {
            s = s.Trim().ToUpper();

            ushort i;

            if (s.Length > 2 && s[0] == '0' && s[1] == 'X')
                i = UInt16.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    i = (ushort) UInt16.Parse(s);
                }
                catch (FormatException)
                {
                    i = UInt16.Parse(s, NumberStyles.HexNumber);
                }
            }

            return i;
        }

        private static double ParseDouble(string s)
        {
            double d = (double)Double.Parse(s.Trim());
            return d;
        }

        public static string DecodeAndPrettyPrintXml(string encodedXml)
        {
            string rawXml = HttpUtility.HtmlDecode(encodedXml);

            string formattedXml = XmlUtil.PrettyPrint(rawXml);

            return formattedXml;
        }

        public static bool IsMultilineValuedElement(Element e)
        {
            return ( e.elementType == ElementType.HtmlEncodedXml );
        }
    }

    public class CountryInfo
    {
        public CountryInfo(int n, string c, string f)
        {
            Number = n;
            Code = c;
            FriendlyName = f;
        }

        public int Number;
        public string Code;
        public string FriendlyName;
    }

    public class CountryUtil
    {
        public static string GetCode(int n)
        {
            foreach (CountryInfo info in CountryInfos)
            {
                if (info.Number == n)
                    return info.Code;
            }

            return string.Format("unknown (cid={0})", n);
        }

        public static string GetFriendlyName(int n)
        {
            foreach (CountryInfo info in CountryInfos)
            {
                if (info.Number == n)
                    return info.FriendlyName;
            }

            return string.Format("unknown (cid={0})", n);
        }

        private static readonly CountryInfo [] CountryInfos =
        {
            new CountryInfo(0, "XX", ""),
            new CountryInfo(1, "AE", "UNITED ARAB EMIRATES"),
            new CountryInfo(2, "AL", "ALBANIA"),
            new CountryInfo(3, "AM", "ARMENIA"),
            new CountryInfo(4, "AR", "ARGENTINA"),
            new CountryInfo(5, "AT", "AUSTRIA"),
            new CountryInfo(6, "AU", "AUSTRALIA"),
            new CountryInfo(7, "AZ", "AZERBAIJAN"),
            new CountryInfo(8, "BE", "BELGIUM"),
            new CountryInfo(9, "BG", "BULGARIA"),
            new CountryInfo(10, "BH", "BAHRAIN"),
            new CountryInfo(11, "BN", "BRUNEI DARUSSALAM"),
            new CountryInfo(12, "BO", "BOLIVIA"),
            new CountryInfo(13, "BR", "BRAZIL"),
            new CountryInfo(14, "BY", "BELARUS"),
            new CountryInfo(15, "BZ", "BELIZE"),
            new CountryInfo(16, "CA", "CANADA"),
            new CountryInfo(17, "CB", ""),
            new CountryInfo(18, "CH", "SWITZERLAND"),
            new CountryInfo(19, "CL", "CHILE"),
            new CountryInfo(20, "CN", "CHINA"),
            new CountryInfo(21, "CO", "COLOMBIA"),
            new CountryInfo(22, "CR", "COSTA RICA"),
            new CountryInfo(23, "CZ", "CZECH REPUBLIC"),
            new CountryInfo(24, "DE", "GERMANY"),
            new CountryInfo(25, "DK", "DENMARK"),
            new CountryInfo(26, "DO", "DOMINICAN REPUBLIC"),
            new CountryInfo(27, "DZ", "ALGERIA"),
            new CountryInfo(28, "EC", "ECUADOR"),
            new CountryInfo(29, "EE", "ESTONIA"),
            new CountryInfo(30, "EG", "EGYPT"),
            new CountryInfo(31, "ES", "SPAIN"),
            new CountryInfo(32, "FI", "FINLAND"),
            new CountryInfo(33, "FO", "FAROE ISLANDS"),
            new CountryInfo(34, "FR", "FRANCE"),
            new CountryInfo(35, "GB", "UNITED KINGDOM"),
            new CountryInfo(36, "GE", "GEORGIA"),
            new CountryInfo(37, "GR", "GREECE"),
            new CountryInfo(38, "GT", "GUATEMALA"),
            new CountryInfo(39, "HK", "HONG KONG"),
            new CountryInfo(40, "HN", "HONDURAS"),
            new CountryInfo(41, "HR", "CROATIA"),
            new CountryInfo(42, "HU", "HUNGARY"),
            new CountryInfo(43, "ID", "INDONESIA"),
            new CountryInfo(44, "IE", "IRELAND"),
            new CountryInfo(45, "IL", "ISRAEL"),
            new CountryInfo(46, "IN", "INDIA"),
            new CountryInfo(47, "IQ", "IRAQ"),
            new CountryInfo(48, "IR", "IRAN, ISLAMIC REPUBLIC OF"),
            new CountryInfo(49, "IS", "ICELAND"),
            new CountryInfo(50, "IT", "ITALY"),
            new CountryInfo(51, "JM", "JAMAICA"),
            new CountryInfo(52, "JO", "JORDAN"),
            new CountryInfo(53, "JP", "JAPAN"),
            new CountryInfo(54, "KE", "KENYA"),
            new CountryInfo(55, "KG", "KYRGYZSTAN"),
            new CountryInfo(56, "KR", "KOREA, REPUBLIC OF"),
            new CountryInfo(57, "KW", "KUWAIT"),
            new CountryInfo(58, "KZ", "KAZAKHSTAN"),
            new CountryInfo(59, "LB", "LEBANON"),
            new CountryInfo(60, "LI", "LIECHTENSTEIN"),
            new CountryInfo(61, "LT", "LITHUANIA"),
            new CountryInfo(62, "LU", "LUXEMBOURG"),
            new CountryInfo(63, "LV", "LATVIA"),
            new CountryInfo(64, "LY", "LIBYAN ARAB JAMAHIRIYA"),
            new CountryInfo(65, "MA", "MOROCCO"),
            new CountryInfo(66, "MC", "MONACO"),
            new CountryInfo(67, "MK", "MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OF"),
            new CountryInfo(68, "MN", "MONGOLIA"),
            new CountryInfo(69, "MO", "MACAO"),
            new CountryInfo(70, "MV", "MALDIVES"),
            new CountryInfo(71, "MX", "MEXICO"),
            new CountryInfo(72, "MY", "MALAYSIA"),
            new CountryInfo(73, "NI", "NICARAGUA"),
            new CountryInfo(74, "NL", "NETHERLANDS"),
            new CountryInfo(75, "NO", "NORWAY"),
            new CountryInfo(76, "NZ", "NEW ZEALAND"),
            new CountryInfo(77, "OM", "OMAN"),
            new CountryInfo(78, "PA", "PANAMA"),
            new CountryInfo(79, "PE", "PERU"),
            new CountryInfo(80, "PH", "PHILIPPINES"),
            new CountryInfo(81, "PK", "PAKISTAN"),
            new CountryInfo(82, "PL", "POLAND"),
            new CountryInfo(83, "PR", "PUERTO RICO"),
            new CountryInfo(84, "PT", "PORTUGAL"),
            new CountryInfo(85, "PY", "PARAGUAY"),
            new CountryInfo(86, "QA", "QATAR"),
            new CountryInfo(87, "RO", "ROMANIA"),
            new CountryInfo(88, "RU", "RUSSIAN FEDERATION"),
            new CountryInfo(89, "SA", "SAUDI ARABIA"),
            new CountryInfo(90, "SE", "SWEDEN"),
            new CountryInfo(91, "SG", "SINGAPORE"),
            new CountryInfo(92, "SI", "SLOVENIA"),
            new CountryInfo(93, "SK", "SLOVAKIA"),
            new CountryInfo(94, "SP", ""),
            new CountryInfo(95, "SV", "EL SALVADOR"),
            new CountryInfo(96, "SY", "SYRIAN ARAB REPUBLIC"),
            new CountryInfo(97, "TH", "THAILAND"),
            new CountryInfo(98, "TN", "TUNISIA"),
            new CountryInfo(99, "TR", "TURKEY"),
            new CountryInfo(100, "TT", "TRINIDAD AND TOBAGO"),
            new CountryInfo(101, "TW", "TAIWAN, PROVINCE OF CHINA"),
            new CountryInfo(102, "UA", "UKRAINE"),
            new CountryInfo(103, "US", "UNITED STATES"),
            new CountryInfo(104, "UY", "URUGUAY"),
            new CountryInfo(105, "UZ", "UZBEKISTAN"),
            new CountryInfo(106, "VE", "VENEZUELA"),
            new CountryInfo(107, "VN", "VIET NAM"),
            new CountryInfo(108, "YE", "YEMEN"),
            new CountryInfo(109, "ZA", "SOUTH AFRICA"),
            new CountryInfo(110, "ZW", "ZIMBABWE")
        };
    }

    public class LanguageInfo
    {
        public LanguageInfo(int n, string f)
        {
            Number = n;
            FriendlyName = f;
        }

        public int Number;
        public string FriendlyName;
    }

    public class LanguageUtil
    {
        public static string GetFriendlyName(int n)
        {
            foreach (LanguageInfo info in LanguageInfos)
            {
                if (info.Number == n)
                    return info.FriendlyName;
            }

            return string.Format("unknown (langid={0})", n);
        }

        public static LanguageInfo [] LanguageInfos =
        {
            new LanguageInfo(1, "English"),
            new LanguageInfo(2, "Japanese"),
            new LanguageInfo(3, "German"),
            new LanguageInfo(4, "French"),
            new LanguageInfo(5, "Spanish"),
            new LanguageInfo(6, "Italian"),
            new LanguageInfo(7, "Korean"),
            new LanguageInfo(8, "Chinese Traditional"),
            new LanguageInfo(9, "Portuguese"),
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\TitleCollection.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// File: TitleCollection.cs
//
////////////////////////////////////////////////////////////////////


namespace xonline.common.logline
{
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.IO;                // For StreamReader
    using System.Xml;               // For XmlTextReader
    using System.Xml.XPath;

    public class TitleCollection
    {
        public class Title
        {
            internal Title()
            {
                this.id         = 0;
                this.name       = String.Empty;
            }


            internal Title(int id, string name)
            {
                this.id         = id;
                this.name       = name;
            }


            internal string Name
            {
                get { return(name); }
            }   // Name


            internal int Id
            {
                get { return(id); }
            }   // Id


            internal void ParseXml(XPathNavigator xPathNavigator)
            {
                id = Int32.Parse(xPathNavigator.GetAttribute("Id", ""));
                name = xPathNavigator.GetAttribute("Name", "");
            }   // ParseXml


            private int         id;
            private string      name;
        };  // class Title


        // Parameterless ctor for serialization
        internal TitleCollection()
        {
        }   // TitleCollection


        internal TitleCollection(string fileName)
        {
            this.titles = new Hashtable();
            this.fileName = fileName;
        }   // TitleCollection


        internal Title this[int titleid]
        {
            get
            {
                if (!filesLoaded)
                {
                    LoadFile(fileName);
                    filesLoaded = true;
                }

                Title title = (Title)titles[titleid];

                if (null == title)
                    title = new Title(titleid, String.Format("Unknown title {0} (0x{0:X})", titleid));

                return(title);
            }
        }

        internal void Add(Title title)
        {
            // Remove any previous version of this setting
            titles.Remove(title.Name);

            // Add the new setting
            titles.Add(title.Id, title);
        }   // Add


        internal void AddXml(XPathNavigator xPathNavigator)
        {
            // Search anywhere down the tree for the Achievements node
            XPathExpression expr = xPathNavigator.Compile(@"Title");

            // Select the settings
            XPathNodeIterator iterator = xPathNavigator.Select(expr);

            while (iterator.MoveNext())
            {
                Title title = new Title();

                title.ParseXml(iterator.Current);

                Add(title);
            }
        }   // AddXml


        internal void LoadXml(string xml)
        {
            XmlDocument xmlDocument = new XmlDocument();

            xmlDocument.LoadXml(xml);

            XPathNavigator xPathNavigator = xmlDocument.CreateNavigator();

            XPathExpression expr = xPathNavigator.Compile("//Titles");

            XPathNodeIterator iterator = xPathNavigator.Select(expr);

            if (iterator.MoveNext())
                AddXml(iterator.Current);
        }   // LoadXml


        internal void LoadFile(string fileName)
        {
            try
            {
                using (StreamReader inputStream = File.OpenText(fileName))
                {
                    LoadXml(inputStream.ReadToEnd());

                    inputStream.Close();
                }
            }
            catch(Exception)
            {
                // Don't care about errors, we'll just display "Unknown" for every title
            }
        }   // LoadFile


        internal string GetName(int titleId)
        {
            return (this[titleId].Name);
        }   // GetName


        //
        // Data
        //

        private string      fileName;
        private bool        filesLoaded = false;
        private Hashtable   titles;

    }   // class TitleCollection

}   // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__logline_4_none_12.4.56.0_none_12d118d4c07aad0e
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_logline_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.manifest
XP_MANIFEST_PATH=manifests\x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.cat
XP_CATALOG_PATH=manifests\x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.cat
XP_PAYLOAD_PATH=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_logline_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\logline\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__logline_4_none_12.4.56.0_none_12d118d4c07aad0e
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_logline_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.manifest
XP_MANIFEST_PATH=manifests\x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.cat
XP_CATALOG_PATH=manifests\x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4.cat
XP_PAYLOAD_PATH=x86__logline_4_no-public-key_12.4.56.0_x-ww_6636e5a4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_logline_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\acctutil\AcctUtil.cs ===
using System;
using System.Text;

using xonline.common.billing;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.user;

namespace xonline.common.acctutil
{
    public class AcctUtil
    {
        public static string GetRandomGamertag()
        {
            string name = "";

            for (;;)
            {
                string[] names = null;
                GamertagSuggestionParameters parameters = new GamertagSuggestionParameters(null, 1, 103);
                GamertagSuggestions gamerTagSuggestions = GamertagSuggestionsFactory.GetGamerTagSuggestions(GamertagSuggestionType.NounAdjectiveSuggestion);

                gamerTagSuggestions.GetNameSuggestions(parameters, out names);
                name = names[0];
                int padLength = (int)XOn.XONLINE_NAME_MAX_SIZE - name.Length;

                if ( padLength > 0 )
                {
                    Random r = new Random();
                    string pad = r.Next().ToString().Substring(1, padLength);
                    name += pad;
                }

                if ( NameUtil.VetName(name) )
                {
                    break;
                }
            }

            return name;
        }

        public static string GenerateCCNumber()
        {
            int n;
            int pos;        // left->right 0-based char position
            int sum;        // checksum
            StringBuilder strB = new StringBuilder(16);
            Random rand = new Random();

            strB.Append("4");
            sum = 8;

            for (pos= 1; pos < 15; pos++)
            {
                n = rand.Next(10);

                strB.Append(n);

                if (pos % 2 == 0) n *= 2;
                if (n >= 10) n -= 9;

                sum += n;
            }

            int check = 10 - (sum % 10);
            if (check == 10) check = 0;
            strB.Append(check);

            return strB.ToString();
        }

        public static CreditCardInfoData GenerateFakeCCInfo()
        {
            CreditCardInfoData cci = new CreditCardInfoData();
            cci.cardType = (byte) CardTypeEnum.Visa;
            cci.accountHolderName = "Joe Blow";
            cci.accountNumber = GenerateCCNumber();
            cci.expirationDate = new DateTime(DateTime.UtcNow.Year + 3, 1, 1);

            return cci;
        }

        public static AddressInfoData GenerateFakeAddress(byte countryId)
        {
            AddressInfoData ai = new AddressInfoData();

            switch ((uint)countryId)
            {
            case XOn.XONLINE_COUNTRY_AUSTRIA:  // AT
                {
                    ai.street1 = "Liechtenstienstrabe 89";
                    ai.city = "Vienna";
                    ai.postalCode = "1090";
                }
                break;
            case XOn.XONLINE_COUNTRY_AUSTRALIA:  // AU
                {
                    ai.street1 = "7 Haas";
                    ai.city = "Broome";
                    ai.state = "WA";
                    ai.postalCode = "6725";
                }
                break;
            case XOn.XONLINE_COUNTRY_BELGIUM:  // BE
                {
                    ai.street1 = "20 Place Rogier";
                    ai.city = "Brussels";
                    ai.postalCode = "1210";
                }
                break;
            case XOn.XONLINE_COUNTRY_CANADA: // CA
                {
                    ai.street1 = "1348 Robson Street";
                    ai.city = "Vancouver";
                    ai.state = "BC";
                    ai.postalCode = "V6E 1C5";
                }
                break;
            case XOn.XONLINE_COUNTRY_SWITZERLAND: // CH
                {
                    ai.street1 = "TrockMatt 6c";
                    ai.city = "Othmarsingen";
                    ai.postalCode = "5504";
                }
                break;
            case XOn.XONLINE_COUNTRY_GERMANY: // DE
                {
                    ai.street1 = "111 Foo";
                    ai.city = "Mnchen";
                    ai.postalCode = "80788";
                }
                break;
            case XOn.XONLINE_COUNTRY_DENMARK: // DK
                {
                    ai.street1 = "Gammel Strand 50";
                    ai.city = "Kbenhavn";
                    ai.postalCode = "1202";
                }
                break;
            case XOn.XONLINE_COUNTRY_SPAIN: // ES
                {
                    ai.street1 = "Grand Via 12";
                    ai.city = "Madrid";
                    ai.postalCode = "28013";
                }
                break;
            case XOn.XONLINE_COUNTRY_FINLAND: // FI
                {
                    ai.street1 = "Pohjoinen Rautatiekatu 23";
                    ai.city = "Helsinki";
                    ai.postalCode = "00100";
                }
                break;
            case XOn.XONLINE_COUNTRY_FRANCE: // FR
                {
                    ai.street1 = "15 rue Edouard Manet";
                    ai.city = "Paris";
                    ai.postalCode = "75013";
                }
                break;
            case XOn.XONLINE_COUNTRY_GREAT_BRITAIN: // GB
                {
                    ai.street1 = "87-135 Brompton Road";
                    ai.street2 = "Knightsbridge";
                    ai.city = "London";
                    ai.postalCode = "SW1X 7XL";
                }
                break;
            case XOn.XONLINE_COUNTRY_HONG_KONG: // HK
                {
                    ai.street1 = "Salisbury Road";
                    ai.city = "Kowloon";
                }
                break;
            case XOn.XONLINE_COUNTRY_IRELAND: // IE
                {
                    ai.street1 = "4 Chapel Hill";
                    ai.city = "Kildaire";
                    ai.state = "Kildaire";
                }
                break;
            case XOn.XONLINE_COUNTRY_ITALY: // IT
                {
                    ai.street1 = "Via A. Lamarmora 28";
                    ai.city = "Firenze";
                    ai.postalCode = "50121";
                }
                break;
            case XOn.XONLINE_COUNTRY_JAPAN: // JP
                {
                    ai.street1 = "\x1753415361677F89";
                    ai.city = "\x2D674C5E025E17533A53";
                    ai.state = "\x1753776D5390";
                    ai.postalCode = "0010010";
                }
                break;
            case XOn.XONLINE_COUNTRY_KOREA: // KR
                {
                    ai.street1 = "123 Elm St.";
                    ai.city = "Seoul";
                    ai.postalCode = "110-700";
                }
                break;
            case XOn.XONLINE_COUNTRY_MEXICO: // MX
                {
                    ai.street1 = "Paseo de los cocoteros";
                    ai.city = "Nuevo Vallarta";
                    ai.state = "NAY";
                    ai.postalCode = "63735";
                }
                break;
            case XOn.XONLINE_COUNTRY_NETHERLANDS: // NL
                {
                    ai.street1 = "Nieuwezijds Voorburgwal 5";
                    ai.city = "Amsterdam";
                    ai.postalCode = "1012 RC";
                }
                break;
            case XOn.XONLINE_COUNTRY_NORWAY: // NO
                {
                    ai.street1 = "Ruths Vei 25 B";
                    ai.city = "Oslo";
                    ai.postalCode = "0980";
                }
                break;
            case XOn.XONLINE_COUNTRY_NEW_ZEALAND: // NZ
                {
                    ai.street1 = "Queen Street";
                    ai.city = "Methven";
                    ai.postalCode = "8353";
                }
                break;
            case XOn.XONLINE_COUNTRY_SWEDEN: // SE
                {
                    ai.street1 = "Norra Vallgaton 62";
                    ai.city = "Malmo";
                    ai.postalCode = "20180";
                }
                break;
            case XOn.XONLINE_COUNTRY_SINGAPORE: // SG
                {
                    ai.street1 = "Joo Chait Road";
                    ai.city = "Singapore";
                    ai.postalCode = "427373";
                }
                break;
            case XOn.XONLINE_COUNTRY_TAIWAN: // TW
                {
                    ai.street1 = "Pei Ta Road";
                    ai.city = "Hsinchu";
                    ai.postalCode = "300";
                }
                break;
            case XOn.XONLINE_COUNTRY_UNITED_STATES: // US
            default:
                {
                    ai.street1 = "123 Main St.";
                    ai.street2 = "Apt. #321";
                    ai.state = "AK";
                    ai.city = "Eek";
                    ai.postalCode = "99578";
                }
                break;
            }
            return ai;
        }

        public static PhoneInfoData GenerateFakePhone()
        {
            PhoneInfoData pi = new PhoneInfoData();
            pi.phonePrefix = "888";
            pi.phoneNumber = "5551212";

            return pi;
        }

        public static CreateLiveAccountRequest CreateArgoAccountRequest()
        {
            CreateLiveAccountRequest req = new CreateLiveAccountRequest();

            req.machinePuid = 0;
            req.offlineXuid = 0;
            req.titleId = XOn.WEB_TITLE_ID;
            req.firstName = "Joe";
            req.lastName = "Blow";
            req.gamertag = GetRandomGamertag();
            //req.signedUserPassportPuid = PassportTestUtil.Create();
            //req.signedOwnerPassportPuid = req.signedUserPassportPuid;
            req.billingToken = "";
            req.birthdate = new DateTime(1980,1,1);
            req.email = req.gamertag + "@xboxtest.com";
            req.countryId = (byte) XOn.XONLINE_COUNTRY_UNITED_STATES;
            req.languageId = XOn.XC_LANGUAGE_ENGLISH;

            req.paymentInstrumentType = (byte) PaymentInstrumentTypeEnum.CreditCard;
            //req.offerId = 0xFFFE07D180000011;
            req.offerId = 0xFFFE07D18000000A;

            req.addressInfo = GenerateFakeAddress((byte)XOn.XONLINE_COUNTRY_UNITED_STATES);
            req.phoneInfo = GenerateFakePhone();

            req.creditCardInfo = GenerateFakeCCInfo();
            req.directDebitInfo = new DirectDebitInfoData();


            return req;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\AccountInfoSet.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Xml;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.billing
{

    /// <summary>
    /// The Account class represents a user account in SPS.  The public fields of this class are used to
    /// set up the information required, and then Create() can be called.  GetInfo() will retrieve that
    /// data from the SPS server.
    /// </summary>

public class AccountInfoSet
{
    // internal sps instance
    private BillingProvider _bdk;


    public AccountInfoSet()
    {
    }

    private ArrayList accountInfoList = null;

    public ArrayList AccountInfoList
    {
        get { return accountInfoList; }
    }

    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields(bool isUpdate)
    {
    }


    public void FromXml(string xml, string rootNodeName)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        accountInfoList = new ArrayList();

        xmlReader.MoveToContent();
        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                xmlReader.Name == rootNodeName)
            {
                xmlReader.Skip();
                break;
            }

            switch (xmlReader.Name)
            {
            case "AccountInfo":
                Account accountInfo = new Account();
                accountInfo.FromXml(xmlReader, "AccountInfo");
                accountInfoList.Add(accountInfo);
                break;

            default:
                if (xmlReader.Name == rootNodeName)
                {
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "AccountInfoSet: Unrecognized Xml element: " + xmlReader.Name );
                xmlReader.Skip();
                break;
            }
        }
    }

    public string ToXml()
    {
        StringBuilder xmlBldr = new StringBuilder(1536);
        ToXml(xmlBldr);
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "AccountInfoSet.ToXml() - xmlBldr size = " + xmlBldr.Length );
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, xmlBldr.ToString() );
        return xmlBldr.ToString();
    }

    public void ToXml(StringBuilder xmlBldr)
    {


        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<AccountInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\"><CustomerType>");
        foreach (Object o in accountInfoList)
        {
            Account accountInfo = (Account) o;
            accountInfo.ToXml(xmlBldr);
        }
        xmlBldr.Append("</AccountInfoSet>");
    }

    private BillingProvider BillingProvider
    {
        get {
            if (_bdk == null) _bdk = new BillingProvider();
            return _bdk;
        }

        set { _bdk = value; }
    }

    /// <summary>
    /// Used to dump the basic information on an account. For debugging purposes only.
    /// (remove from retail build?)
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        return "AccountInfoSet: " + (accountInfoList == null ? 0 : accountInfoList.Count) + " accounts.";
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\AccountsConfig.cs ===
using System;
using System.Globalization;
using System.Text;
using System.Net;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.common.billing
{
    public class AccountsConfig
    {
        private static IPAddress[] _xonWatchIPs;
        private static IPAddress[] _xonWatchSubnets;

        // xonwatch variables
        public static string _xonwatchVoucher;
        public static string _xonwatchCreditCard;

        public static string GetCurrentSettingsDump()
        {
            StringBuilder bldr = new StringBuilder();
            bldr.Append("XUACS Account settings:\r\n");
            bldr.Append("  AutoGenCC: " + AccountsConfig.AutoGenCC.ToString() + "\r\n");
            bldr.Append("  AllowFakeActivationCode: " + AccountsConfig.AllowFakeActivationCode.ToString() + "\r\n");
            bldr.Append("  AllowSetUserAccountStatus: " + AccountsConfig.AllowSetUserAccountStatus.ToString() + "\r\n");
            bldr.Append("  AllowSetUserSettings2: " + AccountsConfig.AllowSetUserSettings2.ToString() + "\r\n");
            bldr.Append("  AllowClearSubscriptions: " + AccountsConfig.AllowClearSubscriptions.ToString() + "\r\n");
            bldr.Append("  XenonMigrationOfferId: " + AccountsConfig.XenonMigrationOfferId.ToString("X") + "\r\n");
            bldr.Append("  XonWatchVoucher: " + _xonwatchVoucher.ToString() + "\r\n");
            bldr.Append("  XonWatchCreditCard: " + _xonwatchCreditCard.ToString() + "\r\n");

            if (_xonWatchIPs != null)
            {
                bldr.Append("  XOnWatchIPs (subnet mask):\r\n");
                for (int i = 0; i < _xonWatchIPs.Length; i++)
                {
                    bldr.Append("    " + _xonWatchIPs[i].ToString() + " (" + _xonWatchSubnets[i].ToString() + ")\r\n");
                }
            }

            return bldr.ToString();
        }

        private static void ParseXonWatchIPs()
        {

            string val = Config.GetSetting(Setting.xuacs_xonwatch_ips);
            if (val != "")
            {
                string[] vals = val.Split(new char[] { ';', ',' });

                if ((vals.Length % 2) != 0)
                {
                  Xom.NtEvent(XEvent.Id.BILLING_CONFIG_9,
                        "Odd number of IPs found in XOnWatchIPs setting ('" +
                        val + "')!  IPs must be specified in IP, Subnet pairs!");

                    _xonWatchIPs = null;
                    _xonWatchSubnets = null;
                    return;
                }

                _xonWatchIPs = new IPAddress[vals.Length/2];
                _xonWatchSubnets = new IPAddress[vals.Length/2];


                try
                {
                    for (int i = 0; i < vals.Length/2; i++)
                    {
                        _xonWatchIPs[i] = IPAddress.Parse(vals[i*2].Trim());
                        _xonWatchSubnets[i] = IPAddress.Parse(vals[(i*2)+1].Trim());
                    }
                }
                catch(Exception e2)
                {
                  Xom.NtEvent(XEvent.Id.XUACS_MISSING_OR_BAD_CONFIG, e2, "Error parsing XOnWatchIPs! ('" + val + "')!");
                    _xonWatchIPs = null;
                    _xonWatchSubnets = null;
                }
            }
            else
            {
                _xonWatchIPs = null;
                _xonWatchSubnets = null;
            }
        }


        public static bool AutoGenCC
        {
            get
            {
                return Config.GetBoolSetting(Setting.xuacs_autoGenCC);
            }
        }

        public static bool AllowFakeActivationCode
        {
            get
            {
                return Config.GetBoolSetting(Setting.billing_allowFakeActivationCode);
            }
        }

        public static bool AllowSetUserAccountStatus
        {
            get
            {
                return Config.GetBoolSetting(Setting.xuacs_allowSetUserAccountStatus);
            }
        }

        public static bool AllowSetUserSettings2
        {
            get
            {
                return Config.GetBoolSetting(Setting.xuacs_allowSetUserSettings2);
            }
        }

        public static bool AllowClearSubscriptions
        {
            get
            {
                return Config.GetBoolSetting(Setting.xuacs_allowClearSubscriptions);
            }
        }

        public static bool AllowDisableSubscription
        {
            get
            {
                return Config.GetBoolSetting(Setting.xuacs_allowDisableSubscription);
            }
        }

        public static bool AllowGetNoAgeOut
        {
            get
            {
                return Config.GetBoolSetting(Setting.xuacs_allowGetNoAgeOut);
            }
        }

        public static bool AllowUncheckedRecovery
        {
            get
            {
                bool val = Config.GetBoolSetting(Setting.xuacs_allowUncheckedRecovery);
                if ( val == true && Config.IsTestEnvironment() == false )
                {
                  Xom.NtEvent( XEvent.Id.BILLING_CONFIG_11, "xuacs_allowUncheckedRecovery=yes in config database, however this is NOT ALLOWED in non-test environments and will be ignored." );
                }

                return val;
            }
        }

        public static ulong XenonMigrationOfferId
        {
            get
            {
                string offerId = Config.GetSetting(Setting.billing_migrationOfferId);
                if ( offerId.StartsWith("0x") )
                {
                    return UInt64.Parse(offerId.Substring(2), NumberStyles.AllowHexSpecifier);
                }

                return UInt64.Parse(offerId);
            }
        }

        public static bool IsXonWatch(string gamerTag, string voucher, string creditCard, IPAddress clientIp)
        {
            if ( gamerTag == null || gamerTag == string.Empty )
            {
                return false;
            }

            ParseXonWatchIPs();
            _xonwatchVoucher = Config.GetSetting(Setting.xuacs_xonwatch_voucher).ToLower();
            _xonwatchCreditCard = Config.GetSetting(Setting.xuacs_xonwatch_creditCard).ToLower();

            if (_xonWatchIPs == null || _xonWatchSubnets == null || _xonwatchVoucher == null || _xonwatchCreditCard == null)
                return false;

            if ((gamerTag[0] == '0' || gamerTag[0] == '1') &&
                (voucher == null || voucher == string.Empty || voucher == _xonwatchVoucher) &&
                (creditCard == null || creditCard == string.Empty || creditCard == _xonwatchCreditCard))
            {
                if (clientIp != null)
                {
                    byte [] clientIPBytes = clientIp.GetAddressBytes();
                    if (clientIPBytes.Length == 4)
                    {
                        for (int i = 0; i < _xonWatchIPs.Length; i++)
                        {
                            byte [] subnetBytes = _xonWatchSubnets[i].GetAddressBytes();
                            byte [] xonWatchBytes = _xonWatchIPs[i].GetAddressBytes();

                            if (subnetBytes.Length != 4 || xonWatchBytes.Length != 4)
                                continue;

                            bool bMatched = true;

                            for (int j = 0; j < 4; ++j)
                            {
                                if (( subnetBytes[j] & xonWatchBytes[j] ) !=
                                    ( subnetBytes[j] & clientIPBytes[j] ))
                                {
                                    bMatched = false;
                                    break;
                                }
                            }

                            if (bMatched)
                            {
                                return true;
                            }
                        }
                    }
                }

                // The gamertag, voucher, and credit card are all consistent with
                // XonWatch but the client IP address is null or doesn't match the
                // list of known XonWatch subnet addresses so log an event.
              Xom.NtEvent(XEvent.Id.BILLING_CONFIG_12,
                    "IsXonWatch: client IP address: {0} is not a valid XonWatch IP address\r\ngamertag={1}, voucher={2}, creditCard={3}",
                        clientIp == null ? "" : clientIp.ToString(),
                        gamerTag,
                        voucher == null ? "" : voucher,
                        creditCard == null ? "" : creditCard);
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Account.cs ===
using System;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.common.billing
{

    /// <summary>
    /// The Account class represents a user account in SCS.  The public fields of this class are used to
    /// set up the information required, and then Create() can be called.  GetInfo() will retrieve that
    /// data from the SCS server.
    /// </summary>

public class Account
{
    // this goes into SCS on creation
    public bool     IsBusinessAccount;     // if this flag is set, the account will be flagged for business
    public string   FriendlyName;
    public string   FirstName;
    public string   LastName;
    public string   CompanyName;
    public string   Email;
    public string   Locale;                // must be a 2-letter lang code followed by 2-letter country code
    public Address  UserAddress;
    public Phone    UserPhone;
    public PaymentInfo PayInfo;
    public string   CountryCode;

    // this comes back from SCS on creation, if you want this data, get it after a create.
    public string   Id;
    public string   PaymentInstrumentId;
    public string   AnniversaryDate;
    public string   TransactionGUID;

    // this data comes back only via a GetInfo call.  not used otherwise.
    // other fields from GetInfo are ignored.
    public string   AccountStatusInfo;
    public string   AccountCreationDate;

    // internal sps instance
    //private BillingProvider _bdk;


    public Account()
    {
        IsBusinessAccount = false;          // always default to personal account
    }


    public string Create(ulong passportId, string passportName, string guid)
    {
        string accountId = null;

        ValidateFields(false);

        accountId = CreateInBillingProvider(passportId, passportName, guid);

        Debug.Assert( accountId != null );
        if( accountId == null )
        {
            throw new Exception("No account ID has been associated with this account!");
        }

        Id = accountId;

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "New account created for user " + passportId + " (acct ID: " + accountId + ")" );

        return accountId;
    }


    public string CreateInBillingProvider(ulong passportId, string passportName, string guid)
    {

        uint puidHigh;
        uint puidLow;
        string errorXml;
        string paperworkUrl;
        string accountId = null;

        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Creating new account for user " + passportId);

        if ( PayInfo.PaymentInstrumentType != PaymentInstrumentTypeEnum.None )
        {
            PayInfo.EncryptAccountNumber();
        }

        if (PayInfo.BillingAddress == null)
        {
            PayInfo.BillingAddress = this.UserAddress;
        }

        BillingProvider.CreateAccount(
            0x1,
            0x1,
            (int)puidHigh,
            (int)puidLow,
            passportName,
            guid,
            this.ToXml(),
            PayInfo.ToXml("PaymentInstrumentInfo"),
            out errorXml,
            out accountId,
            out this.PaymentInstrumentId,
            out this.AnniversaryDate,
            out paperworkUrl );

        Debug.Assert( accountId != null );
        if( accountId == null )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "No account ID returned for a successfully created account!" );
            throw new Exception("No account ID has been associated with this account!");
        }

        Id = accountId;
        TransactionGUID = guid;

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "New account created for user " + passportId + " (acct ID: " + accountId + ")" );

        return accountId;
    }


    public void UpdateWithoutPayInfo(ulong passportId)
    {
        uint puidHigh;
        uint puidLow;

        string errorXml;
        string paperworkXml;

        ValidateFields(true);
        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Updating account for user 0x" + passportId.ToString("x") );

        BillingProvider.UpdateAccountInfo(0, 0, (int)puidHigh, (int)puidLow, Id, ToXml(), out errorXml, out paperworkXml);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Updated account info for user " + passportId + " (acct ID: " + Id + ")" );
    }

    public void Update(ulong passportId)
    {
        this.Update(passportId, null);
    }

    public void Update(ulong passportId, string reinstateSubscriptionId)
    {
        uint puidHigh;
        uint puidLow;

        string errorXml;
        string paperworkXml;

        ValidateFields(true);
        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Updating account for user 0x" + passportId.ToString("x") );
        BillingProvider.UpdateAccountInfo(0, 0, (int)puidHigh, (int)puidLow, Id, ToXml(), out errorXml, out paperworkXml);
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Updated account info for user " + passportId + " (acct ID: " + Id + ")" );

UpdatePayInfo:
        if (PayInfo.AccountNumber == null)
        {
            // In addition to calling UpdatePaymentInstrumentInfo, we
            // also call SettleBalance.  The reason we do this is because
            // if the user is in a suspended state due to an expired
            // credit card, calling UpdatePII will not change their account
            // from suspended to enabled.  Because of this, we call
            // SettleBalance which will correct the state of their account
            // (assuming the last authorization on the old PI isn't still
            // being processed by Citi).
            //
            // Note that we do not need to do this in the case of
            // SwitchPaymentInstrument since SwitchPI calls SettleBalance
            // implicitly.
            //
            Guid inGuid = Guid.NewGuid();
            string amtChargedXml;

            BillingProvider.UpdatePaymentInstrumentInfo(0, 0, (int)puidHigh, (int)puidLow, PayInfo.Id, PayInfo.ToXml("PaymentInstrumentInfo"), out errorXml);
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Updated existing payment instrument for user " + passportId + " (acct ID: " + Id + ")" );

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Settling balance for user 0x" + passportId.ToString("x") + " (payInfo ID: " + PayInfo.Id + ")" );

            BillingProvider.SettleBalance(0, 0, inGuid.ToString(), PayInfo.Id, out errorXml, out amtChargedXml);

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Settled balance for user 0x" + passportId.ToString("x") + " (payInfo ID: " + PayInfo.Id + ", amtChargedXml: " + amtChargedXml + ")" );

            if ( reinstateSubscriptionId != null && reinstateSubscriptionId != "" )
            {
                string commentInfoXml = "";
                string subInfoXml = "";

                commentInfoXml =
                    "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                        "<CommentCode>0</CommentCode>" +
                        "<CommentText>Xbox Live calling ReinstateSubscription due to subscription being EXPIRED with violations.</CommentText>" +
                    "</CommentInfo>";

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Reinstating subscription for user 0x" + passportId.ToString("x") + ", subscription " + reinstateSubscriptionId );

                BillingProvider.ReinstateSubscription(0, 0, (int)puidHigh, (int)puidLow, reinstateSubscriptionId, 0, commentInfoXml, out errorXml, out amtChargedXml, out subInfoXml);

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Reinstated subscription for user 0x" + passportId.ToString("x") + " (amtChargedXml: " + amtChargedXml + ", subInfoXml: " + subInfoXml + ")" );
            }
        }
        else
        {
            Guid inGuid = Guid.NewGuid();
            string amtChargedXml;
            string oldPayInfoId;
            string newPayInfoId;

            PayInfo.EncryptAccountNumber();

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Adding new payment instrument for " + passportId + " (cur payInfo.Id: " + PayInfo.Id + ")" );
            oldPayInfoId = PayInfo.Id;
            PayInfo.Id = null;

            try
            {
                BillingProvider.AddPaymentInstrument(0,0, (int)puidHigh, (int)puidLow, inGuid.ToString(), Id, PayInfo.ToXml("PaymentInstrumentInfo"), out errorXml, out newPayInfoId, out paperworkXml);
            }
            catch (BillingProviderException bpe)
            {
                if ( bpe.XonlineHResult == HResult.XONLINE_E_BILLING_PI_ALREADY_ON_ACCOUNT )
                {
                    // duplicate payment instrument.  we really just want to do an update.
                    // (unforunately this is currently the only way to detect this suitation)
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Duplicate payment instrument found when trying to switch pay instruments.  just updating current instrument instead of replacing.  " + passportId + " (acct ID: " + Id + ")" );

                    PayInfo.AccountNumber = null;
                    PayInfo.Id = oldPayInfoId;
                    goto UpdatePayInfo;
                }

                throw;
            }

            // If there is an error switching payment instruments, try to
            // remove the payment instrument which was just added.  This
            // will let the user return through this path again and let
            //
            try
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "switching to new payment instrument for " + passportId + " (cur payInfo.Id: " + PayInfo.Id + ")" );
                inGuid = Guid.NewGuid();
                BillingProvider.SwitchPaymentInstruments(0, 0, (int)puidHigh, (int)puidLow, inGuid.ToString(), oldPayInfoId, newPayInfoId, out errorXml, out amtChargedXml);
                PayInfo.Id = newPayInfoId;
            }
            catch (BillingProviderException bpe)
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "SwitchPaymentError failed for user: 0x" + passportId.ToString("x") + ", oldPayInfoId: " + oldPayInfoId + ", newPayInfoId: " + newPayInfoId + " with exception: " + bpe );

                // Make a best effort at removing the newly added
                // payment instrument so the user could go through
                // this path again using the same PI.  If the call
                // to RemovePI fails, there's not much we can do.
                try
                {
                    string removeErrorXml;

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "SwitchPaymentInstrument failed - removing new payment instrument for passportId " + passportId + " (newPayInfoId: " + newPayInfoId + ")" );

                    BillingProvider.RemovePaymentInstrument(0, 0, (int)puidHigh, (int)puidLow, newPayInfoId, out removeErrorXml);

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "SwitchPaymentInstrument failed - removed new payment instrument for passportId " + passportId + " (newPayInfoId: " + newPayInfoId + ")" );
                }
                catch (Exception eSwitchRemove)
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "failed to remove new payment instrument for passportId " + passportId + " (newPayInfoId: " + newPayInfoId + "), received exception: " + eSwitchRemove );
                }

                throw;
            }

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "removing old payment instrument for " + passportId + " (old payInfo.Id: " + oldPayInfoId + ")" );
            BillingProvider.RemovePaymentInstrument(0, 0, (int)puidHigh, (int)puidLow, oldPayInfoId, out errorXml);

            if ( reinstateSubscriptionId != null && reinstateSubscriptionId != "" )
            {
                string commentInfoXml = "";
                string subInfoXml = "";

                commentInfoXml =
                    "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                        "<CommentCode>0</CommentCode>" +
                        "<CommentText>Xbox Live calling ReinstateSubscription due to subscription being EXPIRED with violations.</CommentText>" +
                    "</CommentInfo>";

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Reinstating subscription for user 0x" + passportId.ToString("x") + ", subscription " + reinstateSubscriptionId );

                BillingProvider.ReinstateSubscription(0, 0, (int)puidHigh, (int)puidLow, reinstateSubscriptionId, 0, commentInfoXml, out errorXml, out amtChargedXml, out subInfoXml);

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Reinstated subscription for user 0x" + passportId.ToString("x") + " (amtChargedXml: " + amtChargedXml + ", subInfoXml: " + subInfoXml + ")" );
            }
        }
    }

    public void GetInfo (ulong passportId)
    {
        Debug.Assert( Id != null );
        GetInfo(passportId, Id, null);
    }

    /// <summary>
    /// Gets user account info from SCS by PUID and account ID. The results are readable through
    /// the public fields of the class.  Phone and Address classes will be created as necessary.
    /// </summary>
    /// <param name="passportId">PUID</param>
    /// <param name="accountId">The account ID for which account information is being requested.
    /// A subscription, payment instrument, or service instance ID can be passed in lieu of an
    /// account ID; the account related to that object will be used. </param>
    public void GetInfo(ulong passportId, string accountId, string payInfoId)
    {
        string resultXml;
        string xml = "";
        int c = 0;

        uint puidHigh;
        uint puidLow;

        // validate accountId
        if(accountId == null)
        {
            throw new Exception("Must supply SCS account ID to GetInfo");
        }


        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        if ( BillingConfig.ConnectToBilling == true )
        {
            BillingProvider.GetAccountInfo(0x1, 0x1, (int)puidHigh, (int)puidLow, accountId, out resultXml, out xml);

            // initialize FirstName and LastName
            this.FirstName = string.Empty;
            this.LastName = string.Empty;

            // set the fields of this instance to the retrieved information.
            this.FromXml(xml, "AccountInfo");
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "\nAccount Info: " + xml );

            if ( string.IsNullOrEmpty(payInfoId) == false )
            {
                BillingProvider.GetPaymentInstruments(0x1, 0x1, (int)puidHigh, (int)puidLow, payInfoId, out resultXml, out c, out xml);
                this.PayInfo = new PaymentInfo();
                this.PayInfo.Id = payInfoId;
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "\nPayinstr Info: " + xml );
                this.PayInfo.FromXml(xml, "PaymentInstrumentInfoSet");
            }
            else
            {
                this.PayInfo = new PaymentInfo();
                this.PayInfo.PaymentInstrumentType = PaymentInstrumentTypeEnum.None;
            }

        }
        else
        {
            // half-assed dummy data

            this.PayInfo = new PaymentInfo();
            this.PayInfo.BillingPhone = new Phone();
            this.PayInfo.BillingAddress = new Address();

            this.PayInfo.BillingPhone.AreaCode = "425";
            this.PayInfo.BillingPhone.PhoneNumber = "882-8080";
            this.PayInfo.BillingPhone.PhoneExtension = "";
            this.PayInfo.BillingAddress.PostalCode = "98052";
            this.PayInfo.AccountHolderName = "Bill Gates";
            this.PayInfo.AccountNumberLastFour = "1111";
        }
    }


    /// <summary>
    /// Gets payment instrument info from SCS by PUID and payinfo ID. The results are readable through
    /// the public fields of the class.  Phone and Address classes will be created as necessary.
    /// </summary>
    /// <param name="passportId">PUID</param>
    public void GetPayInfo(ulong passportId, string payInfoId)
    {
        string resultXml;
        string xml = "";
        int c = 0;

        uint puidHigh;
        uint puidLow;

        // validate id
        if ( string.IsNullOrEmpty(payInfoId) )
        {
            throw new Exception("Must supply SCS payinfo ID to GetPayInfo");
        }

        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        if ( BillingConfig.ConnectToBilling == true )
        {
            BillingProvider.GetPaymentInstruments(0x1, 0x1, (int)puidHigh, (int)puidLow, payInfoId, out resultXml, out c, out xml);
            this.PayInfo = new PaymentInfo();
            this.PayInfo.Id = payInfoId;
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "\nPayinstr Info: " + xml );
            this.PayInfo.FromXml(xml, "PaymentInstrumentInfoSet");
        }
        else
        {
            throw new XRLException(HResult.XONLINE_E_BILLING_NOT_CONNECTED, XEvent.Id.COMMON_BILLING_CODE_0, "Couldn't load information for user puid 0x" + passportId.ToString("x") + " because ConnectToBilling=false!");
        }
    }


    public static bool VerifyLastFourAccountDigits(ulong passportId, string accountId, string payInfoId, string lastFour)
    {
        string resultXml;
        string xml = "";
        int c = 0;

        uint puidHigh;
        uint puidLow;
        PaymentInfo pi = new PaymentInfo();
        BillingProvider bdk = new BillingProvider();

        if( BillingConfig.ConnectToBilling == false )
        {
            //
            // always succeed here.
            //
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "VerifyLastFourAccountDigits: SKIPPING call to SCS for payment instrument last 4 digits" );
            return true;
        }

        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        bdk.GetPaymentInstruments(0x1, 0x1, (int)puidHigh, (int)puidLow, payInfoId, out resultXml, out c, out xml);
        pi.FromXml(xml, "PaymentInstrumentInfoSet");

        Debug.Assert(pi.AccountNumberLastFour != null);

        return lastFour.Equals(pi.AccountNumberLastFour);
    }


    public bool IsLightweight()
    {
        bool isLightweight = true;

        do
        {
            if ( string.IsNullOrEmpty(this.FirstName) )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Account.IsLightweightAccount: account missing FirstName -> lightweight" );
                break;
            }

            if ( string.IsNullOrEmpty(this.LastName) )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Account.IsLightweightAccount: account missing LastName -> lightweight" );
                break;
            }

            if ( this.UserAddress == null || string.IsNullOrEmpty(this.UserAddress.Street1) )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Account.IsLightweightAccount: account missing Street1 -> lightweight" );
                break;
            }

            // either phone or e-mail is sufficient
            if ( (this.UserPhone == null || string.IsNullOrEmpty(this.UserPhone.PhoneNumber)) && string.IsNullOrEmpty(this.Email) )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Account.IsLightweightAccount: account missing PhoneNumber and Email -> lightweight" );
                break;
            }

            isLightweight = false;

        } while (false);

        return isLightweight;
    }


    public static bool IsLightweightAccount(ulong userPuid, ulong passportPuid, string accountId)
    {
        Account acct = null;

        if ( BillingProvider.IsDummyId(accountId) )
        {
            BillingQueueItem bqi = BillingQueueItem.Load(userPuid, false);
            if ( bqi == null )
            {
                throw new XRLException(HResult.XONLINE_E_BILLING_QUEUED_ACCOUNT_NOT_FOUND, XEvent.Id.COMMON_BILLING_QUEUED_ACCOUNT_NOT_FOUND, "Account.IsLightweightAccount: could not load queued user: 0x" + userPuid.ToString("x") + ", accountId: " + accountId);
            }
            acct = bqi.Account;
        }
        else
        {
            if ( BillingConfig.ConnectToBilling == false )
            {
                throw new XRLException(HResult.XONLINE_E_BILLING_NOT_CONNECTED, XEvent.Id.COMMON_BILLING_NOT_CONNECTED_TO_BILLING, "Account.IsLightweightAccount: called for an account stored in SCS but ConnectToBilling is off!");
            }

            acct = new Account();
            acct.GetInfo(passportPuid, accountId, null);
        }

        return acct.IsLightweight();
    }


    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields(bool isUpdate)
    {
        if (FriendlyName == null)   throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_FRIENDLY_NAME_NOT_FOUND_ERROR, "Missing Account.FriendlyName");
        if (Locale == null)         throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_LOCALE_NOT_FOUND, "Missing Account.Locale");
        if (PayInfo == null)        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_PAYMENT_INFO_NOT_FOUND_ERROR, "Missing Account.PayInfo");
        if (CountryCode == null)    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_COUNTRY_ID_NOT_FOUND, "Missing Account.CountryCode");

        // validate that no one's specifying outgoing data
        if (isUpdate == false)
        {
            if (AnniversaryDate != null)        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_CANNOT_SPECIFY_ANNIVERSARY_DATE_ERROR, "Cannot specify Account.AnniversaryDate");
            if (Id != null)                     throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_CANNOT_SPECIFY_ACCOUNT_ID_ERROR, "Cannot specify Account.Id");
            if (PaymentInstrumentId != null)    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_CANNOT_SPECIFY_PAYMENT_ID_ERROR, "Cannot specify Account.PaymentInstrumentId");
        }

        /*
        if (isUpdate)
        {
            if (Id == 0)     throw new Exception("Missing Account.Id");
        }
        */

        if ( UserAddress != null )
        {
            UserAddress.ValidateFields(isUpdate);
        }

        if ( UserPhone != null )
        {
            UserPhone.ValidateFields(isUpdate);
        }

        PayInfo.ValidateFields(isUpdate);
    }


    public void FromXml(string xml, string rootNodeName)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        xmlReader.MoveToContent();
        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                xmlReader.Name == rootNodeName)
            {
                xmlReader.Skip();
                break;
            }

            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                ((xmlReader.Name == "Phone") || (xmlReader.Name == "AddressInfo")))
            {
                xmlReader.Skip();
                continue;
            }

            if (xmlReader.NodeType != XmlNodeType.Element)
            {
                xmlReader.Skip();
                continue;
            }

            switch (xmlReader.Name)
            {
                case "AccountId":
                    Id = xmlReader.ReadElementString();
                    break;

                case "AnniversaryDate":
                    AnniversaryDate = xmlReader.ReadElementString();
                    break;

                case "AccountStatusInfo":
                    AccountStatusInfo = xmlReader.ReadElementString();
                    break;

                case "AccountCreationDate":
                    AccountCreationDate = xmlReader.ReadElementString();
                    break;

                case "CustomerType":
                    if(xmlReader.ReadElementString() == "BUSINESS")
                    {
                        IsBusinessAccount = true;
                    }
                    else
                    {
                        IsBusinessAccount = false;
                    }
                    break;

                case "FriendlyName":
                    FriendlyName = xmlReader.ReadElementString();
                    break;

                case "FirstName":
                    FirstName = xmlReader.ReadElementString();
                    break;

                case "LastName":
                    LastName = xmlReader.ReadElementString();
                    break;

                case "CompanyName":
                    CompanyName = xmlReader.ReadElementString();
                    break;

                case "Email":
                    Email = xmlReader.ReadElementString();
                    break;

                case "Locale":
                    Locale = xmlReader.ReadElementString();
                    break;

                case "Currency":
                    // ignore this and use the CountryCode to determine it
                    xmlReader.ReadElementString();
                    break;

                case "CountryCode":
                    CountryCode = xmlReader.ReadElementString();
                    break;

                case "PhoneSet":
                    if( UserPhone == null ) UserPhone = new Phone();

                    // advance to the first inner element
                    xmlReader.ReadStartElement();

                    // if there is no phone element, skip and continue
                    if ( xmlReader.NodeType == XmlNodeType.EndElement )
                    {
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Account: no phone element present in PhoneSet info from SCS" );
                        xmlReader.Skip();
                    }
                    else
                    {
                        UserPhone.FromXml(xmlReader, "Phone");
                    }
                    break;

                case "Phone":
                    // shouldn't see this-- another phone entry? skip it.
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Account: Throwing away secondary phone info from SCS" );
                    xmlReader.Skip();
                    break;

                case "AddressInfoSet":
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    if( UserAddress == null )
                    {
                        UserAddress = new Address();
                        UserAddress.FriendlyName = BillingProvider.FriendlyName;
                        UserAddress.CountryCode = this.CountryCode;
                    }
                    UserAddress.FromXml(xmlReader, "AddressInfo");
                    break;

                case "AddressInfo":
                    // shouldn't see this-- another address entry? skip it.
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Account: Throwing away secondary address info from SCS" );
                    xmlReader.Skip();
                    break;

                case "TaxExemptionInfoSet":
                    // yikes!
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Account: Throwing away tax exemption info" );
                    xmlReader.Skip();
                    break;

                default:
                    if (xmlReader.Name == rootNodeName)
                    {
                        // advance to the first inner element
                        xmlReader.ReadStartElement();
                        break;
                    }

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Account: Unrecgonized Xml element: " + xmlReader.Name );
                    xmlReader.Skip();
                    break;
            }
        }
    }

    public string ToXml()
    {
        StringBuilder xmlBldr = new StringBuilder(1536);
        ToXml(xmlBldr);
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "AccountInfo::ToXml() - xmlBldr size = " + xmlBldr.Length );
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, xmlBldr.ToString() );
        return xmlBldr.ToString();
    }

    public void ToXml(StringBuilder xmlBldr)
    {
        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<AccountInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">");

        xmlBldr.Append("<CustomerType>");
        if( IsBusinessAccount )
        {
            xmlBldr.Append("BUSINESS");
        }
        else
        {
            xmlBldr.Append("PERSONAL");
        }
        xmlBldr.Append("</CustomerType>");

        if ( FriendlyName != null )
        {
            xmlBldr.Append("<FriendlyName>");
            xmlBldr.Append(XmlCleanser.Cleanup(FriendlyName));
            xmlBldr.Append("</FriendlyName>");
        }

        if ( FirstName != null )
        {
            xmlBldr.Append("<FirstName>");
            xmlBldr.Append(XmlCleanser.Cleanup(FirstName));
            xmlBldr.Append("</FirstName>");
        }

        if ( LastName != null )
        {
            xmlBldr.Append("<LastName>");
            xmlBldr.Append(XmlCleanser.Cleanup(LastName));
            xmlBldr.Append("</LastName>");
        }

        if ( Email != null )
        {
            xmlBldr.Append("<Email>");
            xmlBldr.Append(XmlCleanser.Cleanup(Email));
            xmlBldr.Append("</Email>");
        }

        if( CompanyName != null )
        {
            xmlBldr.Append("<CompanyName>");
            xmlBldr.Append(XmlCleanser.Cleanup(CompanyName));
            xmlBldr.Append("</CompanyName>");
        }
        xmlBldr.Append("<Locale>");
        xmlBldr.Append(XmlCleanser.Cleanup(Locale));
        xmlBldr.Append("</Locale>");

        xmlBldr.Append("<Currency>");
        if (CountryCode != null)
        {
            xmlBldr.Append(XmlCleanser.Cleanup(Culture.GetCurrencySymbol(CountryCode)));
        }
        xmlBldr.Append("</Currency>");

        if ( UserPhone != null && UserPhone.PhoneNumber != null && UserPhone.PhoneNumber != string.Empty )
        {
            xmlBldr.Append("<PhoneSet>");
            UserPhone.ToXml(xmlBldr, "Phone");
            xmlBldr.Append("</PhoneSet>");
        }

        // TODO: someday the server should be able to make use of the same country
        // config files the client does
        bool requiresPostalCode = ( CountryCode != "CO" && CountryCode != "HK" && CountryCode != "IE" && CountryCode != "NZ" );

        if ( UserAddress != null &&
             UserAddress.Street1 != null && UserAddress.Street1 != string.Empty &&
             UserAddress.City != null && UserAddress.City != string.Empty &&
             ( !requiresPostalCode || (UserAddress.PostalCode != null && UserAddress.PostalCode != string.Empty) ) )
        {
            xmlBldr.Append("<AddressInfoSet>");
            UserAddress.ToXml(xmlBldr, "AddressInfo");
            xmlBldr.Append("</AddressInfoSet>");
        }

        if ( CountryCode != null )
        {
            xmlBldr.Append("<CountryCode>");
            xmlBldr.Append(XmlCleanser.Cleanup(CountryCode));
            xmlBldr.Append("</CountryCode>");
        }

        xmlBldr.Append("</AccountInfo>");
    }

    public string Currency
    {
        get
        {
            if ( CountryCode != null )
            {
                return Culture.GetCurrencySymbol(CountryCode);
            }

            throw new Exception("Account.Currency: CountryCode is not set -- Currency cannot be determined!");
        }
    }

    private BillingProvider BillingProvider
    {
        get {
            //if (_bdk == null) _bdk = new BillingProvider();
            //return _bdk;
            return new BillingProvider();
        }

        //set { _bdk = value; }
    }

    /// <summary>
    /// Used to dump the basic information on an account. For debugging purposes only.
    /// (remove from retail build?)
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        string a;

        a = "AccountId: " + Id +
            "\nFriendlyName: " + FriendlyName +
            "\nCustomer type: " + (IsBusinessAccount ? "Business" : "Personal") +
            ((FirstName != null) ? "\nFirstName: " + FirstName : "") +
            ((LastName != null) ? "\nLastName: " + LastName : "") +
            "\nCompanyName: " + CompanyName +
            "\nEmail: " + Email +
            "\nLocale: " + Locale +
            "\nCurrency: " + Currency +
            ((UserAddress != null) ? "\nAddress: " + UserAddress.ToString() : "") +
            ((UserPhone != null) ? "\nPhone: " + UserPhone.ToString() : "") +
            "\nPaymentInstrumentId: " + PaymentInstrumentId +
            "\nAnniversaryDate: " + AnniversaryDate +
            "\nAccountStatusInfo: " + AccountStatusInfo +
            "\nAccountCreationDate: " + AccountCreationDate;

        return a;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BdkApiWrappers.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Xml;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities2;

//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS FILE IS AUTO-GENERATED!  DO NOT HAND-EDIT THIS FILE!
//
// This file was generated by the tool BdkApiWrapperGen in \private\tools\BdkApiWrapperGen
// If changes are needed to this file, please modify the tool and regenerate the API
// using the tool.  This allows us to easily incorporate new SCS BDK APIs into our
// service without having to resort to the hand-editing we had to do for years.
//

namespace xonline.common.billing
{
partial class BdkWrapper : BDKWSDL.bdk
{

public new virtual void ActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus)
{
    string apiName = "ActivateToken";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        delegateIdHigh.ToString(),
        delegateIdLow.ToString(),
        (trackingGuid == null ? "null" : trackingGuid),
        (token == null ? "null" : token),
        tokenType.ToString(),
        (externalReferenceId == null ? "null" : externalReferenceId),
        (timeStamp == null ? "null" : timeStamp),
        committedStatus.ToString()
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.ActivateToken(delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, timeStamp, committedStatus);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML)
{
    string apiName = "AddComment";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrAccountId == null ? "null" : bstrAccountId),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.AddComment(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, bstrCommentInfoXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL)
{
    string apiName = "AddPaymentInstrument";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrAccountId == null ? "null" : bstrAccountId),
        (bstrPaymentInstrumentInfoXML == null ? "null" : SanitizeXmlInputParameter(bstrPaymentInstrumentInfoXML))
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("bstrAccountId", bstrAccountId));
        auditParams.Add(new AuditXmlParam("bstrPaymentInstrumentInfoXML", SanitizeXmlInputParameter(bstrPaymentInstrumentInfoXML)));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.AddPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrAccountId, bstrPaymentInstrumentInfoXML, out pbstrErrorXML, out pbstrPaymentInstrumentId, out pbstrRequiredPaperWorkURL);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrPaymentInstrumentId == null ? "null" : pbstrPaymentInstrumentId),
            (pbstrRequiredPaperWorkURL == null ? "null" : pbstrRequiredPaperWorkURL)
        };

        auditMessage = "success";
        auditParams.Add(new AuditParam("pbstrPaymentInstrumentId", pbstrPaymentInstrumentId));
        auditParams.Add(new AuditParam("pbstrRequiredPaperWorkURL", pbstrRequiredPaperWorkURL));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML)
{
    string apiName = "AddRoleAssignment";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId),
        (bstrRoleAssignmentXML == null ? "null" : bstrRoleAssignmentXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.AddRoleAssignment(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrRoleAssignmentXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML)
{
    string apiName = "AddViolation";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId),
        lViolationId.ToString(),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.AddViolation(lDelegateIdHigh, lDelegateIdLow, bstrObjectId, lViolationId, bstrCommentInfoXML, out pbstrErrorXML, out pbstrStatusInfoXML, out pbstrAmountChargedXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrStatusInfoXML == null ? "null" : pbstrStatusInfoXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CalculateTax(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml, out string returnOrderDetailXml)
{
    string apiName = "CalculateTax";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        (version == null ? "null" : version),
        (callerInfoXml == null ? "null" : callerInfoXml),
        (accountId == null ? "null" : accountId),
        (taxCalculationInfoXml == null ? "null" : taxCalculationInfoXml),
        (orderDetailXml == null ? "null" : orderDetailXml)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CalculateTax(version, callerInfoXml, accountId, taxCalculationInfoXml, orderDetailXml, out returnOrderDetailXml);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (returnOrderDetailXml == null ? "null" : returnOrderDetailXml)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML)
{
    string apiName = "CancelSubscription";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        fComputeOnly.ToString(),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        (bstrCancelDate == null ? "null" : bstrCancelDate),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("fComputeOnly", fComputeOnly));
        auditParams.Add(new AuditParam("bstrSubscriptionId", bstrSubscriptionId));
        auditParams.Add(new AuditParam("bstrCancelDate", bstrCancelDate));
        auditParams.Add(new AuditXmlParam("bstrCommentInfoXML", bstrCommentInfoXML));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CancelSubscription(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionId, bstrCancelDate, bstrCommentInfoXML, out pbstrErrorXML, out pbstrAmountChargedXML, out pbstrSubscriptionStatusInfoXML, out plRemovedServiceInstanceCount, out pbstrRemovedServiceInstanceSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML),
            (pbstrSubscriptionStatusInfoXML == null ? "null" : pbstrSubscriptionStatusInfoXML),
            plRemovedServiceInstanceCount.ToString(),
            (pbstrRemovedServiceInstanceSetXML == null ? "null" : pbstrRemovedServiceInstanceSetXML)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));
        auditParams.Add(new AuditXmlParam("pbstrSubscriptionStatusInfoXML", pbstrSubscriptionStatusInfoXML));
        auditParams.Add(new AuditParam("plRemovedServiceInstanceCount", plRemovedServiceInstanceCount));
        auditParams.Add(new AuditXmlParam("pbstrRemovedServiceInstanceSetXML", pbstrRemovedServiceInstanceSetXML));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML)
{
    string apiName = "CheckProvisioningStatus";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrServiceComponentId == null ? "null" : bstrServiceComponentId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CheckProvisioningStatus(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceComponentId, out pbstrErrorXML, out pbstrResponseXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrResponseXML == null ? "null" : pbstrResponseXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
{
    string apiName = "CloseBalance";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrObjectId == null ? "null" : bstrObjectId),
        (bstrLineItemId == null ? "null" : bstrLineItemId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CloseBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrObjectId, bstrLineItemId, out pbstrErrorXML, out pbstrAmountChargedXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void ConvertSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, int lConvertMode, int lOverrideFlags, string bstrSubscriptionName, string bstrSubscriptionId, string bstrOfferingGUID, int lOverrideAmount, string bstrSubscriptionEndDate, string bstrReferralSetXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
{
    string apiName = "ConvertSubscription";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        fComputeOnly.ToString(),
        lConvertMode.ToString(),
        lOverrideFlags.ToString(),
        (bstrSubscriptionName == null ? "null" : bstrSubscriptionName),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        (bstrOfferingGUID == null ? "null" : bstrOfferingGUID),
        lOverrideAmount.ToString(),
        (bstrSubscriptionEndDate == null ? "null" : bstrSubscriptionEndDate),
        (bstrReferralSetXML == null ? "null" : bstrReferralSetXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("fComputeOnly", fComputeOnly));
        auditParams.Add(new AuditParam("lConvertMode", lConvertMode));
        auditParams.Add(new AuditParam("lOverrideFlags", lOverrideFlags));
        auditParams.Add(new AuditParam("bstrSubscriptionName", bstrSubscriptionName));
        auditParams.Add(new AuditParam("bstrSubscriptionId", bstrSubscriptionId));
        auditParams.Add(new AuditParam("bstrOfferingGUID", bstrOfferingGUID));
        auditParams.Add(new AuditParam("lOverrideAmount", lOverrideAmount));
        auditParams.Add(new AuditParam("bstrSubscriptionEndDate", bstrSubscriptionEndDate));
        auditParams.Add(new AuditXmlParam("bstrReferralSetXML", bstrReferralSetXML));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.ConvertSubscription(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, lConvertMode, lOverrideFlags, bstrSubscriptionName, bstrSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrSubscriptionEndDate, bstrReferralSetXML, out pbstrErrorXML, out pbstrAmountChargedXML, out plAddedServiceInstanceSetCount, out pbstrAddedServiceInstanceSet, out plRemovedServiceInstanceSetCount, out pbstrRemoveServiceInstanceSet);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML),
            plAddedServiceInstanceSetCount.ToString(),
            (pbstrAddedServiceInstanceSet == null ? "null" : pbstrAddedServiceInstanceSet),
            plRemovedServiceInstanceSetCount.ToString(),
            (pbstrRemoveServiceInstanceSet == null ? "null" : pbstrRemoveServiceInstanceSet)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));
        auditParams.Add(new AuditParam("plAddedServiceInstanceSetCount", plAddedServiceInstanceSetCount));
        auditParams.Add(new AuditParam("pbstrAddedServiceInstanceSet", pbstrAddedServiceInstanceSet));
        auditParams.Add(new AuditParam("plRemovedServiceInstanceSetCount", plRemovedServiceInstanceSetCount));
        auditParams.Add(new AuditParam("pbstrRemoveServiceInstanceSet", pbstrRemoveServiceInstanceSet));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void ConvertSubscriptionEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, int lConvertMode, int lOverrideFlags, string bstrSubscriptionName, string bstrSubscriptionId, string bstrOfferingGUID, int lOverrideAmount, string bstrSubscriptionEndDate, string bstrReferralSetXML, string bstrPaymentInstrumentId, string bstrTokenId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
{
    string apiName = "ConvertSubscriptionEx";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        fComputeOnly.ToString(),
        lConvertMode.ToString(),
        lOverrideFlags.ToString(),
        (bstrSubscriptionName == null ? "null" : bstrSubscriptionName),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        (bstrOfferingGUID == null ? "null" : bstrOfferingGUID),
        lOverrideAmount.ToString(),
        (bstrSubscriptionEndDate == null ? "null" : bstrSubscriptionEndDate),
        (bstrReferralSetXML == null ? "null" : bstrReferralSetXML),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId),
        (bstrTokenId == null ? "null" : bstrTokenId),
        (bstrPolicyGUID == null ? "null" : bstrPolicyGUID),
        lPolicyVersion.ToString(),
        (bstrSignatureDateTime == null ? "null" : bstrSignatureDateTime)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("fComputeOnly", fComputeOnly));
        auditParams.Add(new AuditParam("lConvertMode", lConvertMode));
        auditParams.Add(new AuditParam("lOverrideFlags", lOverrideFlags));
        auditParams.Add(new AuditParam("bstrSubscriptionName", bstrSubscriptionName));
        auditParams.Add(new AuditParam("bstrSubscriptionId", bstrSubscriptionId));
        auditParams.Add(new AuditParam("bstrOfferingGUID", bstrOfferingGUID));
        auditParams.Add(new AuditParam("lOverrideAmount", lOverrideAmount));
        auditParams.Add(new AuditParam("bstrSubscriptionEndDate", bstrSubscriptionEndDate));
        auditParams.Add(new AuditXmlParam("bstrReferralSetXML", bstrReferralSetXML));
        auditParams.Add(new AuditParam("bstrPaymentInstrumentId", bstrPaymentInstrumentId));
        auditParams.Add(new AuditParam("bstrTokenId", bstrTokenId));
        auditParams.Add(new AuditParam("bstrPolicyGUID", bstrPolicyGUID));
        auditParams.Add(new AuditParam("lPolicyVersion", lPolicyVersion));
        auditParams.Add(new AuditParam("bstrSignatureDateTime", bstrSignatureDateTime));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.ConvertSubscriptionEx(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, lConvertMode, lOverrideFlags, bstrSubscriptionName, bstrSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrSubscriptionEndDate, bstrReferralSetXML, bstrPaymentInstrumentId, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, out pbstrErrorXML, out pbstrAmountChargedXML, out plAddedServiceInstanceSetCount, out pbstrAddedServiceInstanceSet, out plRemovedServiceInstanceSetCount, out pbstrRemoveServiceInstanceSet);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML),
            plAddedServiceInstanceSetCount.ToString(),
            (pbstrAddedServiceInstanceSet == null ? "null" : pbstrAddedServiceInstanceSet),
            plRemovedServiceInstanceSetCount.ToString(),
            (pbstrRemoveServiceInstanceSet == null ? "null" : pbstrRemoveServiceInstanceSet)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));
        auditParams.Add(new AuditParam("plAddedServiceInstanceSetCount", plAddedServiceInstanceSetCount));
        auditParams.Add(new AuditParam("pbstrAddedServiceInstanceSet", pbstrAddedServiceInstanceSet));
        auditParams.Add(new AuditParam("plRemovedServiceInstanceSetCount", plRemovedServiceInstanceSetCount));
        auditParams.Add(new AuditParam("pbstrRemoveServiceInstanceSet", pbstrRemoveServiceInstanceSet));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL)
{
    string apiName = "CreateAccount";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrPPMemberName == null ? "null" : bstrPPMemberName),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrAccountInfoXML == null ? "null" : bstrAccountInfoXML),
        (bstrPaymentInstrumentXML == null ? "null" : SanitizeXmlInputParameter(bstrPaymentInstrumentXML))
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrPPMemberName", bstrPPMemberName));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditXmlParam("bstrAccountInfoXML", bstrAccountInfoXML));
        auditParams.Add(new AuditXmlParam("bstrPaymentInstrumentXML", SanitizeXmlInputParameter(bstrPaymentInstrumentXML)));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CreateAccount(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPPMemberName, bstrTrackingGUID, bstrAccountInfoXML, bstrPaymentInstrumentXML, out pbstrErrorXML, out pbstrAccountId, out pbstrPaymentInstrumentId, out pbstrDate, out bstrRequiredPaperWorkURL);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAccountId == null ? "null" : pbstrAccountId),
            (pbstrPaymentInstrumentId == null ? "null" : pbstrPaymentInstrumentId),
            (pbstrDate == null ? "null" : pbstrDate),
            (bstrRequiredPaperWorkURL == null ? "null" : bstrRequiredPaperWorkURL)
        };

        auditMessage = "success";
        auditParams.Add(new AuditParam("pbstrAccountId", pbstrAccountId));
        auditParams.Add(new AuditParam("pbstrPaymentInstrumentId", pbstrPaymentInstrumentId));
        auditParams.Add(new AuditParam("pbstrDate", pbstrDate));
        auditParams.Add(new AuditParam("bstrRequiredPaperWorkURL", bstrRequiredPaperWorkURL));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError)
{
    string apiName = "CreditPaymentInstrument";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId),
        lFinancialReportingCode.ToString(),
        (bstrAmount == null ? "null" : bstrAmount),
        fImmediatelySettle.ToString(),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CreditPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, lFinancialReportingCode, bstrAmount, fImmediatelySettle, bstrCommentInfoXML, out pbstrError);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrError == null ? "null" : pbstrError)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError)
{
    string apiName = "CreditPaymentInstrumentEx";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        lFinancialReportingCode.ToString(),
        (bstrAmount == null ? "null" : bstrAmount),
        fImmediatelySettle.ToString(),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.CreditPaymentInstrumentEx(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, bstrSubscriptionId, lFinancialReportingCode, bstrAmount, fImmediatelySettle, bstrCommentInfoXML, out pbstrError);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrError == null ? "null" : pbstrError)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML)
{
    string apiName = "DeprovisionServices";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrServiceInstanceSetXML == null ? "null" : bstrServiceInstanceSetXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.DeprovisionServices(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceInstanceSetXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
{
    string apiName = "GetAccountIdFromAdminPUID";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lSearchPUIDHigh.ToString(),
        lSearchPUIDLow.ToString(),
        fFullData.ToString(),
        lMax.ToString()
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetAccountIdFromAdminPUID(lDelegateIdHigh, lDelegateIdLow, lSearchPUIDHigh, lSearchPUIDLow, fFullData, lMax, out pbstrErrorXML, out pfMoreRows, out plAccountInfoCount, out pbstrAccountInfoSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            pfMoreRows.ToString(),
            plAccountInfoCount.ToString(),
            (pbstrAccountInfoSetXML == null ? "null" : pbstrAccountInfoSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML)
{
    string apiName = "GetAccountInfo";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrAccountId == null ? "null" : bstrAccountId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetAccountInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, out pbstrErrorXML, out pbstrAccountInfoXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAccountInfoXML == null ? "null" : pbstrAccountInfoXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML)
{
    string apiName = "GetComments";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrAccountId == null ? "null" : bstrAccountId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetComments(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, out pbstrErrorXML, out plCommentInfoSetCount, out pbstrCommentInfoSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            plCommentInfoSetCount.ToString(),
            (pbstrCommentInfoSetXML == null ? "null" : pbstrCommentInfoSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
{
    string apiName = "GetEligibleOfferings";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrAccountId == null ? "null" : bstrAccountId),
        (bstrOfferingGUID == null ? "null" : bstrOfferingGUID),
        (bstrCategory == null ? "null" : bstrCategory),
        (bstrFilter == null ? "null" : bstrFilter)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetEligibleOfferings(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrOfferingGUID, bstrCategory, bstrFilter, out pbstrErrorText, out plOfferingInfoCount, out pbstrOfferingInfoSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorText == null ? "null" : pbstrErrorText),
            plOfferingInfoCount.ToString(),
            (pbstrOfferingInfoSetXML == null ? "null" : pbstrOfferingInfoSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml)
{
    string apiName = "GetKey";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrKeyGuid == null ? "null" : bstrKeyGuid)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetKey(lRequesterIdHigh, lRequesterIdLow, bstrKeyGuid, out pbstrErrorXML, out pbstrKeyXml);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrKeyXml == null ? "null" : pbstrKeyXml)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetPartnerConfiguration(Guid trackingGuid, Guid ownerID, string partnerConfigQueryXML, out string responseXML)
{
    string apiName = "GetPartnerConfiguration";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        trackingGuid.ToString(),
        ownerID.ToString(),
        (partnerConfigQueryXML == null ? "null" : partnerConfigQueryXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetPartnerConfiguration(trackingGuid, ownerID, partnerConfigQueryXML, out responseXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (responseXML == null ? "null" : responseXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML)
{
    string apiName = "GetPaymentInstruments";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetPaymentInstruments(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, out pbstrErrorXML, out plPaymentInstrumentInfoCount, out pbstrPaymentInstrumentInfoSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            plPaymentInstrumentInfoCount.ToString(),
            (pbstrPaymentInstrumentInfoSetXML == null ? "null" : pbstrPaymentInstrumentInfoSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML)
{
    string apiName = "GetPaymentInstrumentsEx";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId),
        fReturnRemoved.ToString()
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetPaymentInstrumentsEx(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, fReturnRemoved, out pbstrErrorXML, out plPaymentInstrumentInfoCount, out pbstrPaymentInstrumentInfoSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            plPaymentInstrumentInfoCount.ToString(),
            (pbstrPaymentInstrumentInfoSetXML == null ? "null" : pbstrPaymentInstrumentInfoSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML)
{
    string apiName = "GetPermitsForObjectId";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId),
        fDeep.ToString()
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetPermitsForObjectId(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, fDeep, out pbstrErrorXML, out plPermitCount, out pbstrPermitSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            plPermitCount.ToString(),
            (pbstrPermitSetXML == null ? "null" : pbstrPermitSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML)
{
    string apiName = "GetSubscriptions";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetSubscriptions(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            plSubscriptionInfoCount.ToString(),
            (pbstrSubscriptionInfoSetXML == null ? "null" : pbstrSubscriptionInfoSetXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML)
{
    string apiName = "GetSubscriptionStatus";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetSubscriptionStatus(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, out pbstrErrorXML, out pbstrSubscriptionStatusInfoXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrSubscriptionStatusInfoXML == null ? "null" : pbstrSubscriptionStatusInfoXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML)
{
    string apiName = "GetTokenInfoEx";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrToken == null ? "null" : bstrToken),
        lTokenType.ToString()
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.GetTokenInfoEx(lDelegateIdHigh, lDelegateIdLow, bstrToken, lTokenType, out pbstrErrorXML, out pbstrTokenOrderXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrTokenOrderXML == null ? "null" : pbstrTokenOrderXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void LoadTokenInstance(Guid trackingGuid, string tokenInfoXML, out string responseXML)
{
    string apiName = "LoadTokenInstance";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        trackingGuid.ToString(),
        (tokenInfoXML == null ? "null" : tokenInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.LoadTokenInstance(trackingGuid, tokenInfoXML, out responseXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (responseXML == null ? "null" : responseXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void MigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
{
    string apiName = "MigrateOffer";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        (bstrOfferingGUID == null ? "null" : bstrOfferingGUID),
        (bstrPolicyGUID == null ? "null" : bstrPolicyGUID),
        lPolicyVersion.ToString(),
        (bstrSignatureDateTime == null ? "null" : bstrSignatureDateTime)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("bstrSubscriptionId", bstrSubscriptionId));
        auditParams.Add(new AuditParam("bstrOfferingGUID", bstrOfferingGUID));
        auditParams.Add(new AuditParam("bstrPolicyGUID", bstrPolicyGUID));
        auditParams.Add(new AuditParam("lPolicyVersion", lPolicyVersion));
        auditParams.Add(new AuditParam("bstrSignatureDateTime", bstrSignatureDateTime));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.MigrateOffer(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, bstrOfferingGUID, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, out plAddedServiceInstanceSetCount, out pbstrAddedServiceInstanceSet, out plRemovedServiceInstanceSetCount, out pbstrRemoveServiceInstanceSet);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            plAddedServiceInstanceSetCount.ToString(),
            (pbstrAddedServiceInstanceSet == null ? "null" : pbstrAddedServiceInstanceSet),
            plRemovedServiceInstanceSetCount.ToString(),
            (pbstrRemoveServiceInstanceSet == null ? "null" : pbstrRemoveServiceInstanceSet)
        };

        auditMessage = "success";
        auditParams.Add(new AuditParam("plAddedServiceInstanceSetCount", plAddedServiceInstanceSetCount));
        auditParams.Add(new AuditParam("pbstrAddedServiceInstanceSet", pbstrAddedServiceInstanceSet));
        auditParams.Add(new AuditParam("plRemovedServiceInstanceSetCount", plRemovedServiceInstanceSetCount));
        auditParams.Add(new AuditParam("pbstrRemoveServiceInstanceSet", pbstrRemoveServiceInstanceSet));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void OffsetOrder(string version, Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, out string orderReceiptXml)
{
    string apiName = "OffsetOrder";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        (version == null ? "null" : version),
        trackingGuid.ToString(),
        (callerInfoXml == null ? "null" : callerInfoXml),
        (objectId == null ? "null" : objectId),
        (correlationInfoXml == null ? "null" : correlationInfoXml),
        (orderDetailXml == null ? "null" : orderDetailXml),
        (commentInfoXml == null ? "null" : commentInfoXml)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("version", version));
        auditParams.Add(new AuditParam("trackingGuid", trackingGuid));
        auditParams.Add(new AuditXmlParam("callerInfoXml", callerInfoXml));
        auditParams.Add(new AuditParam("objectId", objectId));
        auditParams.Add(new AuditXmlParam("correlationInfoXml", correlationInfoXml));
        auditParams.Add(new AuditXmlParam("orderDetailXml", orderDetailXml));
        auditParams.Add(new AuditXmlParam("commentInfoXml", commentInfoXml));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.OffsetOrder(version, trackingGuid, callerInfoXml, objectId, correlationInfoXml, orderDetailXml, commentInfoXml, out orderReceiptXml);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (orderReceiptXml == null ? "null" : orderReceiptXml)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("orderReceiptXml", orderReceiptXml));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML)
{
    string apiName = "ProvisionServices";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrServiceInstanceSetXML == null ? "null" : bstrServiceInstanceSetXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditXmlParam("bstrServiceInstanceSetXML", bstrServiceInstanceSetXML));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.ProvisionServices(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceInstanceSetXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

        auditMessage = "success";

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void PurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, out string receiptXml)
{
    string apiName = "PurchaseItem";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        delegateIdHigh.ToString(),
        delegateIdLow.ToString(),
        requesterIdHigh.ToString(),
        requesterIdLow.ToString(),
        (trackingGuid == null ? "null" : trackingGuid),
        (itemSetXml == null ? "null" : itemSetXml),
        (paymentMethodXml == null ? "null" : paymentMethodXml),
        (transactionContextXml == null ? "null" : transactionContextXml)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("delegateIdHigh", delegateIdHigh));
        auditParams.Add(new AuditParam("delegateIdLow", delegateIdLow));
        auditParams.Add(new AuditParam("requesterIdHigh", requesterIdHigh));
        auditParams.Add(new AuditParam("requesterIdLow", requesterIdLow));
        auditParams.Add(new AuditParam("trackingGuid", trackingGuid));
        auditParams.Add(new AuditXmlParam("itemSetXml", itemSetXml));
        auditParams.Add(new AuditXmlParam("paymentMethodXml", paymentMethodXml));
        auditParams.Add(new AuditXmlParam("transactionContextXml", transactionContextXml));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.PurchaseItem(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, trackingGuid, itemSetXml, paymentMethodXml, transactionContextXml, out receiptXml);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (receiptXml == null ? "null" : receiptXml)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("receiptXml", receiptXml));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void PurchaseOffering(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionName, string bstrAccountId, string bstrBaseSubscriptionId, string bstrOfferingGUID, int lOverrideAmount, string bstrPaymentInstrumentId, string bstrShippingAddressId, string bstrActivationDate, string bstrSubscriptionEndDate, string bstrReferralSetXML, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML)
{
    string apiName = "PurchaseOffering";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        fComputeOnly.ToString(),
        (bstrSubscriptionName == null ? "null" : bstrSubscriptionName),
        (bstrAccountId == null ? "null" : bstrAccountId),
        (bstrBaseSubscriptionId == null ? "null" : bstrBaseSubscriptionId),
        (bstrOfferingGUID == null ? "null" : bstrOfferingGUID),
        lOverrideAmount.ToString(),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId),
        (bstrShippingAddressId == null ? "null" : bstrShippingAddressId),
        (bstrActivationDate == null ? "null" : bstrActivationDate),
        (bstrSubscriptionEndDate == null ? "null" : bstrSubscriptionEndDate),
        (bstrReferralSetXML == null ? "null" : bstrReferralSetXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("fComputeOnly", fComputeOnly));
        auditParams.Add(new AuditParam("bstrSubscriptionName", bstrSubscriptionName));
        auditParams.Add(new AuditParam("bstrAccountId", bstrAccountId));
        auditParams.Add(new AuditParam("bstrBaseSubscriptionId", bstrBaseSubscriptionId));
        auditParams.Add(new AuditParam("bstrOfferingGUID", bstrOfferingGUID));
        auditParams.Add(new AuditParam("lOverrideAmount", lOverrideAmount));
        auditParams.Add(new AuditParam("bstrPaymentInstrumentId", bstrPaymentInstrumentId));
        auditParams.Add(new AuditParam("bstrShippingAddressId", bstrShippingAddressId));
        auditParams.Add(new AuditParam("bstrActivationDate", bstrActivationDate));
        auditParams.Add(new AuditParam("bstrSubscriptionEndDate", bstrSubscriptionEndDate));
        auditParams.Add(new AuditXmlParam("bstrReferralSetXML", bstrReferralSetXML));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.PurchaseOffering(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionName, bstrAccountId, bstrBaseSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrPaymentInstrumentId, bstrShippingAddressId, bstrActivationDate, bstrSubscriptionEndDate, bstrReferralSetXML, out pbstrErrorXML, out pbstrSubscriptionId, out pbstrAmountChargedXML, out plAddedServiceInstanceCount, out pbstrAddedServiceInstanceSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrSubscriptionId == null ? "null" : pbstrSubscriptionId),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML),
            plAddedServiceInstanceCount.ToString(),
            (pbstrAddedServiceInstanceSetXML == null ? "null" : pbstrAddedServiceInstanceSetXML)
        };

        auditMessage = "success";
        auditParams.Add(new AuditParam("pbstrSubscriptionId", pbstrSubscriptionId));
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));
        auditParams.Add(new AuditParam("plAddedServiceInstanceCount", plAddedServiceInstanceCount));
        auditParams.Add(new AuditXmlParam("pbstrAddedServiceInstanceSetXML", pbstrAddedServiceInstanceSetXML));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void PurchaseOfferingEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionName, string bstrAccountId, string bstrBaseSubscriptionId, string bstrOfferingGUID, int lOverrideAmount, string bstrPaymentInstrumentId, string bstrShippingAddressId, string bstrActivationDate, string bstrSubscriptionEndDate, string bstrReferralSetXML, string bstrTokenId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML)
{
    string apiName = "PurchaseOfferingEx";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        fComputeOnly.ToString(),
        (bstrSubscriptionName == null ? "null" : bstrSubscriptionName),
        (bstrAccountId == null ? "null" : bstrAccountId),
        (bstrBaseSubscriptionId == null ? "null" : bstrBaseSubscriptionId),
        (bstrOfferingGUID == null ? "null" : bstrOfferingGUID),
        lOverrideAmount.ToString(),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId),
        (bstrShippingAddressId == null ? "null" : bstrShippingAddressId),
        (bstrActivationDate == null ? "null" : bstrActivationDate),
        (bstrSubscriptionEndDate == null ? "null" : bstrSubscriptionEndDate),
        (bstrReferralSetXML == null ? "null" : bstrReferralSetXML),
        (bstrTokenId == null ? "null" : bstrTokenId),
        (bstrPolicyGUID == null ? "null" : bstrPolicyGUID),
        lPolicyVersion.ToString(),
        (bstrSignatureDateTime == null ? "null" : bstrSignatureDateTime)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("fComputeOnly", fComputeOnly));
        auditParams.Add(new AuditParam("bstrSubscriptionName", bstrSubscriptionName));
        auditParams.Add(new AuditParam("bstrAccountId", bstrAccountId));
        auditParams.Add(new AuditParam("bstrBaseSubscriptionId", bstrBaseSubscriptionId));
        auditParams.Add(new AuditParam("bstrOfferingGUID", bstrOfferingGUID));
        auditParams.Add(new AuditParam("lOverrideAmount", lOverrideAmount));
        auditParams.Add(new AuditParam("bstrPaymentInstrumentId", bstrPaymentInstrumentId));
        auditParams.Add(new AuditParam("bstrShippingAddressId", bstrShippingAddressId));
        auditParams.Add(new AuditParam("bstrActivationDate", bstrActivationDate));
        auditParams.Add(new AuditParam("bstrSubscriptionEndDate", bstrSubscriptionEndDate));
        auditParams.Add(new AuditXmlParam("bstrReferralSetXML", bstrReferralSetXML));
        auditParams.Add(new AuditParam("bstrTokenId", bstrTokenId));
        auditParams.Add(new AuditParam("bstrPolicyGUID", bstrPolicyGUID));
        auditParams.Add(new AuditParam("lPolicyVersion", lPolicyVersion));
        auditParams.Add(new AuditParam("bstrSignatureDateTime", bstrSignatureDateTime));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.PurchaseOfferingEx(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionName, bstrAccountId, bstrBaseSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrPaymentInstrumentId, bstrShippingAddressId, bstrActivationDate, bstrSubscriptionEndDate, bstrReferralSetXML, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, out pbstrErrorXML, out pbstrSubscriptionId, out pbstrAmountChargedXML, out plAddedServiceInstanceCount, out pbstrAddedServiceInstanceSetXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrSubscriptionId == null ? "null" : pbstrSubscriptionId),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML),
            plAddedServiceInstanceCount.ToString(),
            (pbstrAddedServiceInstanceSetXML == null ? "null" : pbstrAddedServiceInstanceSetXML)
        };

        auditMessage = "success";
        auditParams.Add(new AuditParam("pbstrSubscriptionId", pbstrSubscriptionId));
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));
        auditParams.Add(new AuditParam("plAddedServiceInstanceCount", plAddedServiceInstanceCount));
        auditParams.Add(new AuditXmlParam("pbstrAddedServiceInstanceSetXML", pbstrAddedServiceInstanceSetXML));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML)
{
    string apiName = "ReinstateSubscription";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        lReserved.ToString(),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrSubscriptionId", bstrSubscriptionId));
        auditParams.Add(new AuditParam("lReserved", lReserved));
        auditParams.Add(new AuditXmlParam("bstrCommentInfoXML", bstrCommentInfoXML));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.ReinstateSubscription(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, lReserved, bstrCommentInfoXML, out pbstrErrorXML, out pbstrAmountChargedXML, out pbstrSubscriptionStatusInfoXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML),
            (pbstrSubscriptionStatusInfoXML == null ? "null" : pbstrSubscriptionStatusInfoXML)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));
        auditParams.Add(new AuditXmlParam("pbstrSubscriptionStatusInfoXML", pbstrSubscriptionStatusInfoXML));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML)
{
    string apiName = "RemovePaymentInstrument";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrPaymentInstrumentId", bstrPaymentInstrumentId));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.RemovePaymentInstrument(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

        auditMessage = "success";

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML)
{
    string apiName = "RemoveRoleAssignment";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId),
        (bstrRoleAssignmentXML == null ? "null" : bstrRoleAssignmentXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.RemoveRoleAssignment(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrRoleAssignmentXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML)
{
    string apiName = "RemoveViolation";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrObjectId == null ? "null" : bstrObjectId),
        lViolationId.ToString(),
        (bstrCommentInfoXML == null ? "null" : bstrCommentInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.RemoveViolation(lDelegateIdHigh, lDelegateIdLow, bstrObjectId, lViolationId, bstrCommentInfoXML, out pbstrErrorXML, out pbstrStatusInfoXML, out pbstrAmountChargedXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrStatusInfoXML == null ? "null" : pbstrStatusInfoXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void SetPartnerConfiguration(Guid trackingGuid, Guid ownerID, string partnerConfigObjectXML, out string responseXML)
{
    string apiName = "SetPartnerConfiguration";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        trackingGuid.ToString(),
        ownerID.ToString(),
        (partnerConfigObjectXML == null ? "null" : partnerConfigObjectXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.SetPartnerConfiguration(trackingGuid, ownerID, partnerConfigObjectXML, out responseXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (responseXML == null ? "null" : responseXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
{
    string apiName = "SettleBalance";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.SettleBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, out pbstrErrorXML, out pbstrAmountChargedXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML)
{
    string apiName = "StopPayments";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.StopPayments(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentId, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void SubmitOrder(string version, Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml, out string orderReceiptXml)
{
    string apiName = "SubmitOrder";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        (version == null ? "null" : version),
        trackingGuid.ToString(),
        (callerInfoXml == null ? "null" : callerInfoXml),
        (objectId == null ? "null" : objectId),
        (paymentInstrumentInfoXml == null ? "null" : paymentInstrumentInfoXml),
        (orderDetailXml == null ? "null" : orderDetailXml)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("version", version));
        auditParams.Add(new AuditParam("trackingGuid", trackingGuid));
        auditParams.Add(new AuditXmlParam("callerInfoXml", callerInfoXml));
        auditParams.Add(new AuditParam("objectId", objectId));
        auditParams.Add(new AuditXmlParam("paymentInstrumentInfoXml", paymentInstrumentInfoXml));
        auditParams.Add(new AuditXmlParam("orderDetailXml", orderDetailXml));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.SubmitOrder(version, trackingGuid, callerInfoXml, objectId, paymentInstrumentInfoXml, orderDetailXml, out orderReceiptXml);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (orderReceiptXml == null ? "null" : orderReceiptXml)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("orderReceiptXml", orderReceiptXml));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
{
    string apiName = "SwitchPaymentInstruments";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrFromPaymentInstrumentId == null ? "null" : bstrFromPaymentInstrumentId),
        (bstrToPaymentInstrumentId == null ? "null" : bstrToPaymentInstrumentId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("bstrFromPaymentInstrumentId", bstrFromPaymentInstrumentId));
        auditParams.Add(new AuditParam("bstrToPaymentInstrumentId", bstrToPaymentInstrumentId));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.SwitchPaymentInstruments(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentId, out pbstrErrorXML, out pbstrAmountChargedXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void TestConnection(string bstrInputString, out string pbstrOutputString)
{
    string apiName = "TestConnection";

    string errorXmlText;

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        (bstrInputString == null ? "null" : bstrInputString)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    errorXmlText = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.TestConnection(bstrInputString, out pbstrOutputString);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrOutputString == null ? "null" : pbstrOutputString)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            errorXmlText = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, errorXmlText);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
{
    string apiName = "TransferBalance";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrFromPaymentInstrumentId == null ? "null" : bstrFromPaymentInstrumentId),
        (bstrToPaymentInstrumentId == null ? "null" : bstrToPaymentInstrumentId)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("bstrTrackingGUID", bstrTrackingGUID));
        auditParams.Add(new AuditParam("bstrFromPaymentInstrumentId", bstrFromPaymentInstrumentId));
        auditParams.Add(new AuditParam("bstrToPaymentInstrumentId", bstrToPaymentInstrumentId));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.TransferBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentId, out pbstrErrorXML, out pbstrAmountChargedXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrAmountChargedXML == null ? "null" : pbstrAmountChargedXML)
        };

        auditMessage = "success";
        auditParams.Add(new AuditXmlParam("pbstrAmountChargedXML", pbstrAmountChargedXML));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL)
{
    string apiName = "UpdateAccountInfo";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrAccountId == null ? "null" : bstrAccountId),
        (bstrAccountInfoXML == null ? "null" : bstrAccountInfoXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        SetUserContextualData();

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrAccountId", bstrAccountId));
        auditParams.Add(new AuditXmlParam("bstrAccountInfoXML", bstrAccountInfoXML));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.UpdateAccountInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrAccountInfoXML, out pbstrErrorXML, out pbstrRequiredPaperWorkURL);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrRequiredPaperWorkURL == null ? "null" : pbstrRequiredPaperWorkURL)
        };

        auditMessage = "success";
        auditParams.Add(new AuditParam("pbstrRequiredPaperWorkURL", pbstrRequiredPaperWorkURL));

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        LogUserContextualInfo(this.UserContextualInfoSoapHeaderValue);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML)
{
    string apiName = "UpdatePaymentInstrumentInfo";
    string auditMessage = string.Empty;
    List<AuditParam> auditParams = new List<AuditParam>();

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrPaymentInstrumentId == null ? "null" : bstrPaymentInstrumentId),
        (bstrPaymentInstrumentInfoXML == null ? "null" : SanitizeXmlInputParameter(bstrPaymentInstrumentInfoXML))
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, ref timeout);

        Timeout = timeout;

        auditParams.Add(new AuditParam("lDelegateIdHigh", lDelegateIdHigh));
        auditParams.Add(new AuditParam("lDelegateIdLow", lDelegateIdLow));
        auditParams.Add(new AuditParam("lRequesterIdHigh", lRequesterIdHigh));
        auditParams.Add(new AuditParam("lRequesterIdLow", lRequesterIdLow));
        auditParams.Add(new AuditParam("bstrPaymentInstrumentId", bstrPaymentInstrumentId));
        auditParams.Add(new AuditXmlParam("bstrPaymentInstrumentInfoXML", SanitizeXmlInputParameter(bstrPaymentInstrumentInfoXML)));

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.UpdatePaymentInstrumentInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, bstrPaymentInstrumentInfoXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

        auditMessage = "success";

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();
            apiResult = APIResultEnum.Timeout;
            HandleTimeout(apiName);
            auditMessage = "timeout";
        }
        else
        {
            auditMessage = we.Message;
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            auditMessage = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }

        auditMessage = e.Message;
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( auditParams.Count > 0 )
        {
            AuditStream.Write(0, AuditSubsystem.BDK, apiName, auditMessage, auditParams);
        }

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML)
{
    string apiName = "UpdateSubscriptionInfo";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrTrackingGUID == null ? "null" : bstrTrackingGUID),
        (bstrSubscriptionId == null ? "null" : bstrSubscriptionId),
        (bstrSubscriptionInfoXML == null ? "null" : bstrSubscriptionInfoXML),
        (bstrReferralSetXML == null ? "null" : bstrReferralSetXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.UpdateSubscriptionInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, bstrSubscriptionInfoXML, bstrReferralSetXML, out pbstrErrorXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


public new virtual void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML)
{
    string apiName = "ValidateProvisioningData";

    FastFailTracker ffTracker = null;

    string[] inParams = new string[] {
        lDelegateIdHigh.ToString(),
        lDelegateIdLow.ToString(),
        lRequesterIdHigh.ToString(),
        lRequesterIdLow.ToString(),
        (bstrServiceComponentId == null ? "null" : bstrServiceComponentId),
        (bstrDetailsXML == null ? "null" : bstrDetailsXML)
    };

    string[] outParams = null;

    XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

    APIResultEnum apiResult = APIResultEnum.Failed;

    pbstrErrorXML = "";

    try
    {
        SetSessionBdkApi(apiName);

        ffTracker = GetFastFailTracker(apiName);

        int timeout = BillingConfig.GetApiTimeout(apiName);

        HandlePerfCountersBegin(apiName);

        ScsFailure.PostCallDelegate postCallInjectedBehavior = HandleSessionInjectedError(apiName, inParams, ref timeout);

        Timeout = timeout;

        using (HistogramPerfCounterManager.GetHistogramManager("BDK",apiName))
        {

            base.ValidateProvisioningData(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceComponentId, bstrDetailsXML, out pbstrErrorXML, out pbstrResponseXML);

        }

        postCallInjectedBehavior();

        apiResult = APIResultEnum.Success;

        ffTracker.IndicateSuccess();

        outParams = new string[] {
            (pbstrErrorXML == null ? "null" : pbstrErrorXML),
            (pbstrResponseXML == null ? "null" : pbstrResponseXML)
        };

    }
    catch (WebException we)
    {
        if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
        {
            ffTracker.IndicateTimeout();

            apiResult = APIResultEnum.Timeout;

            HandleTimeout(apiName);
        }
        throw;
    }
    catch (Exception e)
    {
        if ( BdkExceptionUtil.IsBillingError(e) )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SCS error: " + e.Message);
            pbstrErrorXML = e.Message;
            BillingProviderException bpe = BdkExceptionUtil.CreateBillingProviderException(e);
            throw bpe;
        }
        throw;
    }
    finally
    {
        HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

        LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, pbstrErrorXML);

        if ( ffTracker != null )
        {
            ffTracker.IndicateSuccess();

            ffTracker = null;
        }
    }
}


}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BdkError.cs ===
//
// BdkError.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections.Generic;
using System.Net;

using xonline.common.mgmt;
using xonline.common.service;
using XHResult = xonline.common.service.HResult;

namespace xonline.common.billing
{
    public class BdkErrorDetail
    {
        public BdkErrorDetail(HResult bdkHr, string message, bool retryable, HResult xonHr)
        {
            this.BdkHResult = bdkHr;
            this.Message = message;
            this.Retryable = retryable;
            this.XonHResult = xonHr;
        }

        public HResult BdkHResult;
        public string  Message;
        public bool    Retryable;
        public HResult XonHResult;
    }

    public partial class BdkError
    {
        static BdkError()
        {
            // create a dictionary to store the hr <-> detail mappings
            _errorDetails = new Dictionary<uint,BdkErrorDetail>();

            // populate the dictionary with the hr <-> detail mappings
            InitializeErrorDetails();
        }

        /// <summary>
        /// This utility method translates an SCS HRESULT into an XONLINE-appropriate HRESULT,
        /// and logs integrity and other issues in the event logs.  Used in catch clauses.
        /// </summary>
        /// <param name="e">the billing exception</param>
        /// <returns></returns>
        public static HResult BdkToXonlineHr(BillingProviderException e)
        {
            BdkError bdkErr = new BdkError(e.HResult);

            if ( bdkErr.XonlineHResult == XHResult.XOFF_E_BILLING_SERVER_ERROR )
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_1, e,
                    "Unrecognized SCS error (0x" + bdkErr.BdkHResult +
                    ", \"" + bdkErr.Message + "\"), translating to " +
                    bdkErr.XonlineHResult
                );
            }

            return bdkErr.XonlineHResult;
        }

        public static HResult BdkToXonlineHr(HResult bdkHResult)
        {
            BdkError bdkErr = new BdkError(bdkHResult);
            return bdkErr.XonlineHResult;
        }

        public HResult BdkHResult
        {
            get { return bdkHr; }
        }
        public HResult XonlineHResult
        {
            get { return xonlineHr; }
        }

        public string Message
        {
            get { return message; }
        }

        public BdkError(HResult bdkHr)
        {
            HResult hr;
            HResult dmpHr;
            string err = string.Empty;

            if ( BdkExceptionUtil.MapDMPError(bdkHr, out dmpHr) )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "BdkError: BDK error: " + bdkHr.ToString() + " translates to DMP hr = " + dmpHr.ToString() );

                this.bdkHr = bdkHr;
                this.xonlineHr = dmpHr;
                this.message = err;

                return;
            }

            switch ( bdkHr )
            {
            case BdkError.BDK_E_AVS_FAILED:                         // 0x8004760c
            case BdkError.BDK_E_INVALID_CVM_CODE:                   // 0x800476e3
            case BdkError.BDK_E_UNEXPECTED_CVM_RESPONSE_CODE:       // 0x800476e8
            case BdkError.BDK_E_CVM_FAILED:                         // 0x800476ed
            case BdkError.BDK_E_FREQUENCY_CHECK_FAILED:             // 0x800476f2
                hr = XHResult.XONLINE_E_BILLING_AUTHORIZATION_FAILED;
                err = "The authorization failed due to an AVS or CVM-related error.";
                break;

                // The console does not have a good error message localized for
                // the BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE that is returned
                // if a German user attempts to purchase a GonD offer using a
                // direct debit payment instrument. In order to provide the best
                // message possible for the user, map this error to the code returned
                // when BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS is encountered as that
                // string is the best current match as of Geneva.
            case BdkError.BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE:    // 0x800475c8
                hr = XHResult.XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_STATUS;
                err = "Payment instrument exists or the payment instrument status is invalid or does not allow the operation.";
                break;
                
            default:
                BdkErrorDetail bdkErr = GetErrorDetail(bdkHr);
                if ( bdkErr == null )
                {
                    hr = XHResult.XONLINE_E_BILLING_UNKNOWN_ERROR;
                    err = string.Format("Unrecognized SCS hr = ({0}), translating to hr = {1}", bdkHr, hr);
                }
                else
                {
                    hr = bdkErr.XonHResult;
                    err = bdkErr.Message;
                }
                break;
            }

            // assign the member variables
            this.bdkHr = bdkHr;
            this.xonlineHr = hr;
            this.message = err;
        }

        public static bool IsUserError(HResult hr)
        {
            return Array.IndexOf(BillingConfig.NonBillingUserErrors, BdkError.BdkToXonlineHr(hr)) == -1;
        }

        public static BdkErrorDetail GetErrorDetail(HResult hr)
        {
            try
            {
                return _errorDetails[hr];
            }
            catch (KeyNotFoundException)
            {
                return null;
            }
        }

        public static void SetErrorDetail(HResult hr, BdkErrorDetail ed)
        {
            _errorDetails[hr] = ed;
        }

        public static void SetErrorDetail(HResult bdkHr, string message, bool retryable, HResult xonHr)
        {
            _errorDetails[bdkHr] = new BdkErrorDetail(bdkHr, message, retryable, xonHr);
        }

        public static WebHeaderCollection CreateInjectedScsErrorHeader(string scsApi, HResult bdkHr)
        {
            string scsErrorHeader = scsApi + ":" + bdkHr.ToString();

            if ( bdkHr != XHResult.XONLINE_E_ACCOUNTS_BILLING_PROVIDER_TIMEOUT )
            {
                BdkErrorDetail errDetail = GetErrorDetail(bdkHr);
                if ( errDetail == null )
                {
                    scsErrorHeader += ":" + "Unrecognized SCS hr (" + bdkHr + ")";
                }
                else
                {
                    scsErrorHeader += errDetail.Message;
                }
            }

            WebHeaderCollection scsErrorHeaders = new WebHeaderCollection();
            scsErrorHeaders.Add("InjectedScsError", scsErrorHeader);

            return scsErrorHeaders;
        }

        public const uint DMP_E_REQUEST_CANNOT_BE_COMPLETED = 0x8004fa08;
        public const uint DMP_E_STATUS_UNREGISTERED = 0x8004fa09;
        public const uint DMP_E_INSUFFICIENT_BALANCE = 0x8004fa0c;
        public const uint DMP_E_PROMO_EXPIRED = 0x8004fa14;
        public const uint DMP_E_MAX_BALANCE_EXCEEDED = 0x8004fa19;
        public const uint DMP_E_MAX_ACQUISITION_EXCEEDED = 0x8004fa1a;
        public const uint DMP_E_MAX_CONSUMPTION_EXCEEDED = 0x8004fa1b;
        public const uint DMP_E_NO_MORE_PROMO_POINTS = 0x8004fa1c;
        public const uint DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED = 0x8004fa3f;

        private HResult xonlineHr;
        private HResult bdkHr;
        private string  message = string.Empty;

        private static Dictionary<uint,BdkErrorDetail> _errorDetails;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BannerTypes.cs ===
/*
 * BannerTypes.cs
 *
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.
 *
 * Description: basic types used by banners
 *
 */

using xonline.common.offer;

namespace xonline.common.billing
{
    public enum ApplyVec : byte
    {
        NONE = 0,
        OWNERS = 1,
        NON_OWNERS = 2,
        BOTH = OWNERS | NON_OWNERS
    }

    //
    // hard code tier numbers - banners will not support
    // new tiers without recompiling code.
    // recompiling for adding tiers can be deployed without
    // rebuilding database as long as the existing TierBit
    // assignment is maintained. For example, TierEnum.Silver
    // should always map to LSB (0x01).
    //
    public class TierBit
    {
        public const byte Silver = 0x01;
        public const byte Gold = 0x02;
        public const byte All = 0x0f;  // "all" as of today includes silver, gold, and two future tiers

        public static byte FromId(TierEnum tier)
        {
            byte tierBit;
            switch (tier)
            {
                case TierEnum.Silver:  // TODO: update /w TierEnum
                    tierBit=TierBit.Silver;
                    break;

                case TierEnum.Gold:  // TODO: update /w TierEnum
                    tierBit=TierBit.Gold;
                    break;

                case TierEnum.NewUser:
                    tierBit=0;
                    break;

                default:
                    tierBit=0;
                    break;
            }
            return tierBit;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\AccountUtil.cs ===
using System;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.common.billing
{
    public class AccountUtil
    {
        public static byte GetCreatedAccountType(ServiceTypeEnum serviceType, ClientTypeEnum clientType)
        {
            byte createdAccountType = User.XenonAccount;

            if ( serviceType == ServiceTypeEnum.XboxLive )
            {
                switch ( clientType )
                {
                case ClientTypeEnum.Xbox1:
                    createdAccountType = User.Xbox1Account;
                    break;
                case ClientTypeEnum.Xenon:
                    createdAccountType = User.XenonAccount;
                    break;
                case ClientTypeEnum.Panorama:
                    createdAccountType = User.PanoramaAccount;
                    break;
                case ClientTypeEnum.Web:
                    createdAccountType = User.XboxComAccount;
                    break;
                default:
                    Xom.Trace(XomAreaName.xuacs, LogLevel.L_ERROR, "AccountsUtil.GetCreatedAccountType: unhandled clientType: " + clientType + ", returning User.XenonAccount" );

                    createdAccountType = User.XenonAccount;
                    break;
                }
            }
            else if ( serviceType == ServiceTypeEnum.Zune )
            {
                createdAccountType = User.ZuneAccount;
            }
            else
            {
                Xom.Trace(XomAreaName.xuacs, LogLevel.L_ERROR, "AccountsUtil.GetCreatedAccountType: unhandled serviceType: " + serviceType + ", returning User.XenonAccount" );
            }

            Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "AccountsUtil.GetCreatedAccountType: serviceType: " + serviceType + ", clientType: " + clientType + " = createdAccountType: " + createdAccountType );

            return createdAccountType;
        }

        public static void PopulateAccountInfo(ref Account acct, ref ICreateAccountRequest req)
        {
            acct.FriendlyName = BillingProvider.FriendlyName;

            acct.IsBusinessAccount = false;
            acct.FirstName = req.FirstName.Trim();
            acct.LastName = req.LastName.Trim();
            acct.Email = req.Email.Trim();
            acct.CountryCode = req.CountryCode;

            PaymentInfo pay = new PaymentInfo();
            pay.PaymentInstrumentType = (PaymentInstrumentTypeEnum) req.PaymentInstrumentType;
            pay.FriendlyName = BillingProvider.FriendlyName;

            if ( pay.PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                pay.CreditCard.FromWireData(req.CreditCardInfo);

                if (AccountsConfig.AutoGenCC == true)
                {
                    // override the credit card number with a randomly generated one
                    string accountNumber = req.CreditCardInfo.accountNumber;
                    if (pay.CreditCard.CardType == CardTypeEnum.Visa && accountNumber == "4111111111111111")
                    {
                        accountNumber = AccountUtil.GenerateCCNumber();
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_WARNING, "Generated fake CC number in lieu of 4111111111111111: " + accountNumber );
                        pay.CreditCard.AccountNumber = accountNumber;
                    }
                }
            }
            else if ( pay.PaymentInstrumentType == PaymentInstrumentTypeEnum.DirectDebit )
            {
                pay.DirectDebit.FromWireData(req.DirectDebitInfo);
            }
            else if (pay.PaymentInstrumentType == PaymentInstrumentTypeEnum.Wholesale)
            {
                pay.Wholesale.FromWireData(req.WholesaleInfo);
            }

            if (req.PhoneInfo != null)
            {
                Phone ph = new Phone();
                ph.FromWireData(req.PhoneInfo);
                ph.CountryCode = req.CountryCode;

                pay.BillingPhone = ph;
                acct.UserPhone = ph;
            }

            if (req.AddressInfo != null)
            {
                Address addr = new Address();
                addr.FriendlyName = BillingProvider.FriendlyName;
                addr.FromWireData(req.AddressInfo);
                addr.CountryCode = req.CountryCode;

                pay.BillingAddress = addr;

                acct.UserAddress = addr;
            }

            acct.PayInfo = pay;
        }

        public static Account GetBillingAccount(User u)
        {
            Account acct = null;

            if (BillingProvider.IsDummyId(u.AccountId))
            {
                if (BillingProvider.IsLockedId(u.AccountId))
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER, "Billing account for user: 0x{0} is locked due to pending operation. Try again later.", true, u.Puid.ToString("x"));
                }

                // try getting info from queue instead
                BillingQueueItem bqi = BillingQueueItem.Load(u.Puid, false);
                if (bqi == null)
                {
                    throw new XRLException(HResult.XONLINE_E_BILLING_QUEUED_ACCOUNT_NOT_FOUND, XEvent.Id.BILLING_QUEUED_ACCOUNT_NOT_FOUND_105, "Couldn't load account info for user: 0x" + u.Puid.ToString("x"));
                }

                acct = bqi.Account;
            }
            else
            {
                if (BillingConfig.ConnectToBilling == false)
                {
                    throw new XRLException(HResult.XONLINE_E_BILLING_NOT_CONNECTED, XEvent.Id.BILLING_USERACCOUNT_NOT_CONNECTED_106, "XeGetAccountInfo called for an account stored in SCS, but ConnectToBilling is off!");
                }

                acct = new Account();
                acct.GetInfo(u.BillingPuid, u.AccountId, null);
            }

            return acct;
        }

        public static void UpsUpdateGamertag(User u)
        {
            if ( u.AccountType != User.XenonAccount )
            {
                Xom.Trace(XomAreaName.xuacs, LogLevel.L_HIGH, "UpsUpdateGamertag: called for non-Xenon user: 0x" + u.Puid.ToString("x") + ", ignoring...");
                return;
            }

            try
            {
                UpsUtil.UpdateGamertag(u.PassportPuid, u.GamerTag);
            }
            catch (Exception e)
            {
                // if update fails, then don't fail whole operation, but make
                // sure OPS is aware.  Log an event so they can  troubleshoot

                XEvent.Id eventId = (e is ExceptionWithEvent) ? ((ExceptionWithEvent) e).EventId : XEvent.Id.BILLING_ACCOUNTS_UPS_UPDATE_PROFILE_FAILED;
                Xom.NtEvent(eventId, e, "AccountsUtil.UpsUpdateGamertag: Error updating gamertag for passport puid = " + (Puid) u.PassportPuid);
            }
        }

        public static DateTime UpsGetBirthdate(ulong puid)
        {
            DateTime birthdate = DateTime.MinValue;

            // this wraps the UPS get birthdate and ignores  any
            // errors and returns the sentinel value of MinValue

            try
            {
                birthdate = UpsUtil.GetBirthdate(puid);
            }
            catch (Exception e)
            {
                XEvent.Id eventId = (e is ExceptionWithEvent) ? ((ExceptionWithEvent)e).EventId : XEvent.Id.XUACS_UPS_GET_BIRTHDATE_ERROR;
                Xom.NtEvent(eventId, e, "AccountsUtil.UpsGetBirthdate: Error retrieving birthdate for passport puid = " + (Puid) puid);
            }

            return birthdate;
        }

        public static string BuildLocale(ushort languageId, byte countryId)
        {
            string locale = "";
            int cultureId = Culture.GetCultureFromLanguageCountry(languageId, countryId);
            if ( cultureId == Int32.MaxValue )
            {
                string countryCode = CountryDictionary.CountryCode(countryId);
                locale = Locale.BuildValidLocale(languageId, countryCode);
            }
            else
            {
                try
                {
                    CultureInfo ci = new CultureInfo(cultureId);
                    locale = ci.Name;
                }
                catch (ArgumentException ae)
                {
                    Xom.Trace(XomAreaName.xuacs, LogLevel.L_HIGH, "AccountsUtil.BuildLocale: Culture.GetCultureFromLanguageCountry(" + languageId + ", " + countryId + ") returned culture id: " + cultureId + " which is not a valid .NET culture. CultureInfo returned ArgumentException: " + ae);

                    // fallback to the semi-broken language-based locale code
                    string countryCode = CountryDictionary.CountryCode(countryId);
                    locale = Locale.BuildValidLocale(languageId, countryCode);

                   Xom.Trace(XomAreaName.xuacs, LogLevel.L_HIGH, "AccountsUtil.BuildLocale: Locale.BuildValidLocale returned locale: " + locale);
                }
            }

            return locale;
        }

// There are several bugs associated to the reusing of billing accounts. For
// now we're going to create a new billing account every time. This is covered
// in bug 47481
#if false
        internal static void FindBillableAccount(User u, bool isXonWatch, string locale, out string acctId, out string acctPayInfoId)
        {
            FindBillableAccount(u.BillingPuid, isXonWatch, locale, out acctId, out acctPayInfoId);
        }

        internal static void FindBillableAccount(ulong billingPuid, bool isXonWatch, string locale, out string acctId, out string acctPayInfoId)
        {
            acctId = "";
            acctPayInfoId = "";


            // bail now if not connected to billing or XonWatch is running
            if ( BillingConfig.ConnectToBilling == false || isXonWatch )
            {
                return;
            }

            BillingProvider bp = new BillingProvider();

            uint puidHigh;
            uint puidLow;
            string errorXml;
            int hasMoreRows;
            int accountInfoCount;
            string accountInfoSetXml;

            Int64Convert.ToUintPair((long)billingPuid, out puidHigh, out puidLow);

            try
            {
                bp.GetAccountIdFromAdminPUID(
                    0x1, 0x1,
                    (int) puidHigh, (int) puidLow,
                    true,
                    5,
                    out errorXml,
                    out hasMoreRows,
                    out accountInfoCount,
                    out accountInfoSetXml);
            }
            catch (Exception e)
            {
                if( BillingProviderException.IsBillingError(e) )
                {
                    throw new BillingProviderException(e);
                }
                else
                {
                    throw;  // some SOAP connection error; keep it propagating.
                }
            }

            Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GetAccountIdFromAdminPUID: accountInfoSetXml: " + accountInfoSetXml);

            AccountInfoSet accountInfoSet = new AccountInfoSet();
            accountInfoSet.FromXml(accountInfoSetXml, "AccountInfoSet");

            // if an account exists for this puid, select the first account id
            if ( accountInfoSet.AccountInfoList != null && accountInfoSet.AccountInfoList.Count > 0 )
            {
                Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GetAccountIdFromAdminPUID: returned " + accountInfoSet.AccountInfoList.Count + " accounts");

                acctId = null;
                for (int i=0; i < accountInfoSet.AccountInfoList.Count; i++)
                {
                    Account a = (Account) accountInfoSet.AccountInfoList[i];

                    Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GetAccountIdFromAdminPUID: account id: " + a.Id + " has a status of: " + a.AccountStatusInfo + " and a locale of: " + a.Locale);

                    if ( a.AccountStatusInfo == "ACTIVE" && String.Compare(a.Locale, locale, true) == 0)
                    {
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GetAccountIdFromAdminPUID: using account id: " + a.Id);
                        acctId = a.Id;
                        break;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GetAccountIdFromAdminPUID: skipping account id: " + a.Id + " with status: " + a.AccountStatusInfo + " and locale: " + a.Locale);
                    }
                }

                if ( acctId != null && acctId != "" )
                {
                    // try and find a payment instrument for the account
                    PaymentInstrumentInfoSet payInfoSet = PaymentInstrumentInfoSet.GetPaymentInstruments(billingPuid, acctId);

                    if ( payInfoSet.PaymentInstrumentInfoList.Count > 0 )
                    {
                        PaymentInfo pi = (PaymentInfo) payInfoSet.PaymentInstrumentInfoList[0];
                        Debug.Assert( pi.Status == PaymentInstrumentStatusEnum.Good );

                        acctPayInfoId = pi.Id;
                    }

                    Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "FindBillableAccount: acctId: " + acctId + ", acctPayInfoId: " + acctPayInfoId);
                }
            }
        }
#endif

        public static uint VerifyAddressInfo(byte countryId, AddressInfoData addressInfo)
        {
            Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "VerifyAddressInfo: verifying address for countryId:" + countryId.ToString() + "\r\n" + addressInfo.ToString());

            Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "VerifyAddressInfo: address verified.");

            return HResult.S_OK;
        }

        public static string GenerateCCNumber()
        {
            int n;
            int pos;        // left->right 0-based char position
            int sum;        // checksum
            StringBuilder strB = new StringBuilder(16);
            Random rand = new Random();

            strB.Append("4");
            sum = 8;

            for (pos= 1; pos < 15; pos++)
            {
                n = rand.Next(10);

                strB.Append(n);

                if (pos % 2 == 0) n *= 2;
                if (n >= 10) n -= 9;

                sum += n;
            }

            int check = 10 - (sum % 10);
            if (check == 10) check = 0;
            strB.Append(check);

            return strB.ToString();
        }

        public static CreditCardInfoData GenerateFakeCCInfo()
        {
            CreditCardInfoData cci = new CreditCardInfoData();
            cci.cardType = (byte) CardTypeEnum.Visa;
            cci.accountHolderName = "Joe Blow";
            cci.accountNumber = GenerateCCNumber();
            cci.expirationDate = new DateTime(DateTime.UtcNow.Year + 3, 1, 1);

            return cci;
        }

        public static AddressInfoData GenerateFakeAddress(byte countryId)
        {
            AddressInfoData ai = new AddressInfoData();

            switch (countryId)
            {
            case 5:  // AT
                {
                    ai.street1 = "Liechtenstienstrabe 89";
                    ai.city = "Vienna";
                    ai.postalCode = "1090";
                }
                break;
            case 6:  // AU
                {
                    ai.street1 = "7 Haas";
                    ai.city = "Broome";
                    ai.state = "WA";
                    ai.postalCode = "6725";
                }
                break;
            case 8:  // BE
                {
                    ai.street1 = "20 Place Rogier";
                    ai.city = "Brussels";
                    ai.postalCode = "1210";
                }
                break;
            case 16: // CA
                {
                    ai.street1 = "1348 Robson Street";
                    ai.city = "Vancouver";
                    ai.state = "BC";
                    ai.postalCode = "V6E 1C5";
                }
                break;
            case 18: // CH
                {
                    ai.street1 = "TrockMatt 6c";
                    ai.city = "Othmarsingen";
                    ai.postalCode = "5504";
                }
                break;
            case 24: // DE
                {
                    ai.street1 = "111 Foo";
                    ai.city = "Mnchen";
                    ai.postalCode = "80788";
                }
                break;
            case 25: // DK
                {
                    ai.street1 = "Gammel Strand 50";
                    ai.city = "Kbenhavn";
                    ai.postalCode = "1202";
                }
                break;
            case 31: // ES
                {
                    ai.street1 = "Grand Via 12";
                    ai.city = "Madrid";
                    ai.postalCode = "28013";
                }
                break;
            case 32: // FI
                {
                    ai.street1 = "Pohjoinen Rautatiekatu 23";
                    ai.city = "Helsinki";
                    ai.postalCode = "00100";
                }
                break;
            case 34: // FR
                {
                    ai.street1 = "15 rue Edouard Manet";
                    ai.city = "Paris";
                    ai.postalCode = "75013";
                }
                break;
            case 35: // GB
                {
                    ai.street1 = "87-135 Brompton Road";
                    ai.street2 = "Knightsbridge";
                    ai.city = "London";
                    ai.postalCode = "SW1X 7XL";
                }
                break;
            case 39: // HK
                {
                    ai.street1 = "Salisbury Road";
                    ai.city = "Kowloon";
                }
                break;
            case 44: // IE
                {
                    ai.street1 = "4 Chapel Hill";
                    ai.city = "Kildaire";
                    ai.state = "Kildaire";
                }
                break;
            case 50: // IT
                {
                    ai.street1 = "Via A. Lamarmora 28";
                    ai.city = "Firenze";
                    ai.postalCode = "50121";
                }
                break;
            case 53: // JP
                {
                    ai.street1 = "\x1753415361677F89";
                    ai.city = "\x2D674C5E025E17533A53";
                    ai.state = "\x1753776D5390";
                    ai.postalCode = "0010010";
                }
                break;
            case 56: // KR
                {
                    ai.street1 = "123 Elm St.";
                    ai.city = "Seoul";
                    ai.postalCode = "110-700";
                }
                break;
            case 71: // MX
                {
                    ai.street1 = "Paseo de los cocoteros";
                    ai.city = "Nuevo Vallarta";
                    ai.state = "NAY";
                    ai.postalCode = "63735";
                }
                break;
            case 74: // NL
                {
                    ai.street1 = "Nieuwezijds Voorburgwal 5";
                    ai.city = "Amsterdam";
                    ai.postalCode = "1012 RC";
                }
                break;
            case 75: // NO
                {
                    ai.street1 = "Ruths Vei 25 B";
                    ai.city = "Oslo";
                    ai.postalCode = "0980";
                }
                break;
            case 76: // NZ
                {
                    ai.street1 = "Queen Street";
                    ai.city = "Methven";
                    ai.postalCode = "8353";
                }
                break;
            case 90: // SE
                {
                    ai.street1 = "Norra Vallgaton 62";
                    ai.city = "Malmo";
                    ai.postalCode = "20180";
                }
                break;
            case 91: // SG
                {
                    ai.street1 = "Joo Chait Road";
                    ai.city = "Singapore";
                    ai.postalCode = "427373";
                }
                break;
            case 101: // TW
                {
                    ai.street1 = "Pei Ta Road";
                    ai.city = "Hsinchu";
                    ai.postalCode = "300";
                }
                break;
            case 103: // US
            default:
                {
                    ai.street1 = "123 Main St.";
                    ai.street2 = "Apt. #321";
                    ai.state = "AK";
                    ai.city = "Eek";
                    ai.postalCode = "99578";
                }
                break;
            }
            return ai;
        }

        public static PhoneInfoData GenerateFakePhone()
        {
            PhoneInfoData pi = new PhoneInfoData();
            pi.phonePrefix = "888";
            pi.phoneNumber = "5551212";

            return pi;
        }

        public static HResult GenerateUniqueOfflineXuid(ulong passportPuid, out ulong offlineXuid)
        {
            HResult hr;
            int i = 0;

            do {
                offlineXuid = GenerateOfflineXuid( passportPuid );
                hr = CheckOfflineXuid( offlineXuid );
                i++;
            } while ( HResult.XONLINE_E_ACCOUNTS_OFFLINE_XUID_ALREADY_USED == hr && i < 1000);

            return hr;
        }

        public static ulong GenerateOfflineXuid(ulong passportPuid)
        {
            // The Xenon clients create offline Xuids as follows:
            //
            //    0xE XXXXX YY CCCCCCCC
            //
            //    XXXXX: 20 bit sequence number (stored in flash settings)
            //    YY: 1 byte random number
            //    CCCCCCCC: bottom 4 bytes of MAC address
            //
            // The offline XUIDS created by the service will be similar
            // and look as follows:
            //
            //    XXXXX: high bit of 1 plus 19 random bits
            //    YY: 1 byte random number
            //    CCCCCCCC: bottom 4 bytes of user Passport puid
            //
            RandomNumberGenerator rng = RandomNumberGenerator.Create();

            // start with 8 random bytes
            byte[] offlineXuidBytes = new byte[8];
            rng.GetBytes(offlineXuidBytes);

            // the high nibble should be 0xE
            offlineXuidBytes[7] = (byte)((offlineXuidBytes[7] | 0xE0) & 0xEF);

            // the high bit of the second nibble should be 1
            offlineXuidBytes[7] |= 0x08;

            ulong offlineXuid = BitConverter.ToUInt64(offlineXuidBytes, 0);

            // use the low 4 bytes of the passport puid as the low 4 bytes of the offline xuid
            offlineXuid = (offlineXuid & 0xFFFFFFFF00000000) | (passportPuid & 0x00000000FFFFFFFF);

            Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "GenerateOfflineXuid: generated: 0x" + offlineXuid.ToString("X") );

            return offlineXuid;
        }

        public static HResult CheckOfflineXuid(ulong xuid)
        {
            HResult hr = HResult.S_OK;

            if (xuid == 0)
            {
                // don't bother checking, it's always ok
                return hr;
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "p_xuacs_check_offline_xuid";
                ws.SetHashVal(xuid);

                ws.AddParameter("@bi_offline_xuid", xuid);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                ws.ExecuteNonQuery();

                hr = (uint) ws.GetIntParameter("@RETVAL");
            }

            return hr;
        }

        public static void RegisterOfflineXuid(ulong offlineXuid, ulong onlineXuid)
        {
            if (offlineXuid == 0)
            {
                // nothing to do
                return;
            }

            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_xuacs_register_offline_xuid";
                    ws.SetHashVal(offlineXuid);

                    ws.AddParameter("@bi_offline_xuid", offlineXuid);
                    ws.AddParameter("@bi_user_id", onlineXuid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }
            }
            catch (Exception e)
            {
                // this is a best attempt thing.   If it fails we don't want to fail account creation,
                // just log it and move on.
                Xom.NtEvent(XEvent.Id.BILLING_COMM_5, e, "calling p_xuacs_register_offline_xuid(" + offlineXuid + ") failed!!");
            }
        }
        public static void VerifyDashboardTitleIdOrPc()
        {
            if (SGInfo.IsPc()) return;
            SGInfo.VerifyDashboardTitleId();
        }

        public static void CopyBillingPIIFromParent(User child, User parent)
        {
            // This copies enough PII from the parent to allow a child to make purchases using points.

            Account acctChild = GetBillingAccount(child);
            if (!acctChild.IsLightweight())
            {
                // If the child already has enough PII to purchase, we don't need to do anything.
                return;
            }

            Account acctParent = GetBillingAccount(parent);
            if (acctParent.IsLightweight())
            {
                // If the parent doesn't have enough PII to make purchases, abort.
                return;
            }

            if (string.IsNullOrEmpty(acctChild.FirstName) || string.IsNullOrEmpty(acctChild.LastName))
            {
                acctChild.FirstName = acctParent.FirstName;
                acctChild.LastName = acctParent.LastName;
            }

            if (acctChild.UserAddress == null || string.IsNullOrEmpty(acctChild.UserAddress.Street1))
            {
                acctChild.UserAddress = new Address();
                acctChild.UserAddress.FriendlyName = BillingProvider.FriendlyName;
                acctChild.UserAddress.CountryCode = CountryDictionary.CountryCode(child.CountryId);

                acctChild.UserAddress.Street1 = acctParent.UserAddress.Street1;
                acctChild.UserAddress.Street2 = acctParent.UserAddress.Street2;
                acctChild.UserAddress.District = acctParent.UserAddress.District;
                acctChild.UserAddress.City = acctParent.UserAddress.City;
                acctChild.UserAddress.StateProvince = acctParent.UserAddress.StateProvince;
                acctChild.UserAddress.PostalCode = acctParent.UserAddress.PostalCode;
            }

            if (acctChild.UserPhone == null || string.IsNullOrEmpty(acctChild.UserPhone.PhoneNumber))
            {
                acctChild.UserPhone = acctParent.UserPhone;
            }

            if (string.IsNullOrEmpty(acctChild.Email))
            {
                acctChild.Email = acctParent.Email;
            }

            acctChild.UpdateWithoutPayInfo(child.BillingPuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Address.cs ===
using System;
using System.Diagnostics;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;


namespace xonline.common.billing
{

public class Address
{
    // input for creation of account
    public string   FriendlyName;
    public string   Street1;
    public string   Street2;
    public string   Street3;
    public string   City;
    public string   District;
    public string   StateProvince;
    public string   PostalCode;
    public string   CountryCode;

    // output on GetInfo
    public string   AddressId;

    public Address()
    {
    }

    public void FromXml(string xml, string rootNodeName)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        xmlReader.MoveToContent();

        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                (xmlReader.Name == rootNodeName))
            {
                xmlReader.Skip();
                break;
            }

            if (xmlReader.NodeType != XmlNodeType.Element)
            {
                xmlReader.Skip();
                continue;
            }

            switch (xmlReader.Name)
            {
                case "AddressId":
                   AddressId = xmlReader.ReadElementString();
                   break;

                case "FriendlyName":
                    FriendlyName = xmlReader.ReadElementString();
                    break;

                case "Street1":
                    Street1 = xmlReader.ReadElementString();
                    break;

                case "Street2":
                    Street2 = xmlReader.ReadElementString();
                    break;

                case "Street3":
                    Street3 = xmlReader.ReadElementString();
                    break;

                case "District":
                    District = xmlReader.ReadElementString();
                    break;

                case "City":
                    City = xmlReader.ReadElementString();
                    break;

                case "State":
                    StateProvince = xmlReader.ReadElementString();
                    break;

                case "PostalCode":
                    PostalCode = xmlReader.ReadElementString();
                    // MASSIVE KLUDGE: Bug #26032
                    // As of XR2, SPS returns empty postal codes back
                    // as hyphens.  So when presented with a postal
                    // code that is simply a hypen, replace it with
                    // an empty string.  This prevents unexpected
                    // problems in account recovery, etc.
                    if ( PostalCode == "-" )
                    {
                        PostalCode = String.Empty;
                    }
                    break;

                case "CountryCode":
                    CountryCode = xmlReader.ReadElementString();
                    break;

                default:
                    if (xmlReader.Name == rootNodeName)
                    {
                        // advance to the first inner element
                        xmlReader.ReadStartElement();
                        break;
                    }

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Address: Unrecognized Xml element: " + xmlReader.Name );
                    xmlReader.Skip();
                    break;
            }
        }
    }


    public string ToXml(string rootNodeName)
    {
        StringBuilder xmlBldr = new StringBuilder();
        ToXml(xmlBldr, rootNodeName);
        return xmlBldr.ToString();
    }

    public void ToXml(StringBuilder xmlBldr, string rootNodeName)
    {
        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<" + (rootNodeName == null ? "AddressInfo" : rootNodeName) + ">");

        if (AddressId != null)
        {
            xmlBldr.Append("<AddressId>");
            xmlBldr.Append(XmlCleanser.Cleanup(AddressId));
            xmlBldr.Append("</AddressId>");
        }

        if (FriendlyName != null)
        {
            xmlBldr.Append("<FriendlyName>");
            xmlBldr.Append(XmlCleanser.Cleanup(FriendlyName));
            xmlBldr.Append("</FriendlyName>");
        }

        if (Street1 != null)
        {
            xmlBldr.Append("<Street1>");
            xmlBldr.Append(XmlCleanser.Cleanup(Street1));
            xmlBldr.Append("</Street1>");
        }

        if (Street2 != null)
        {
            xmlBldr.Append("<Street2>");
            xmlBldr.Append(XmlCleanser.Cleanup(Street2));
            xmlBldr.Append("</Street2>");
        }

        if (Street3 != null)
        {
            xmlBldr.Append("<Street3>");
            xmlBldr.Append(XmlCleanser.Cleanup(Street3));
            xmlBldr.Append("</Street3>");
        }

        if (City != null)
        {
            xmlBldr.Append("<City>");
            xmlBldr.Append(XmlCleanser.Cleanup(City));
            xmlBldr.Append("</City>");
        }

        if (District != null)
        {
            xmlBldr.Append("<District>");
            xmlBldr.Append(XmlCleanser.Cleanup(District));
            xmlBldr.Append("</District>");
        }

        if (StateProvince != null)
        {
            xmlBldr.Append("<State>");
            xmlBldr.Append(XmlCleanser.Cleanup(StateProvince));
            xmlBldr.Append("</State>");
        }
        
        xmlBldr.Append("<CountryCode>");
        xmlBldr.Append(XmlCleanser.Cleanup(CountryCode));
        xmlBldr.Append("</CountryCode>");

        if (PostalCode != null)
        {
            xmlBldr.Append("<PostalCode>");
            xmlBldr.Append(XmlCleanser.Cleanup(PostalCode));
            xmlBldr.Append("</PostalCode>");
        }
        else
        {
            xmlBldr.Append("<PostalCode/>");
        }

        xmlBldr.Append("</" + (rootNodeName == null ? "AddressInfo" : rootNodeName) + ">");
    }

    // Returns a new instance of AddressInfoData populated with data from
    // the current address instance.
    public AddressInfoData ToWireData()
    {
        AddressInfoData addressInfo = new AddressInfoData();

        addressInfo.street1 = Street1;
        addressInfo.street2 = Street2;
        addressInfo.city = City;
        addressInfo.district = District;
        addressInfo.state = StateProvince;
        addressInfo.postalCode = PostalCode;

        return addressInfo;
    }

    // Populates Address property data with data from the given AddressInfoData
    // instance.
    public void FromWireData(AddressInfoData addressInfo)
    {
        Street1 = addressInfo.street1;
        Street2 = addressInfo.street2;
        City = addressInfo.city;
        District = addressInfo.district;
        StateProvince = addressInfo.state;
        PostalCode = addressInfo.postalCode;
    }

    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields(bool isUpdate)
    {
        if (FriendlyName == null)   throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_FRIENDLY_NAME_NOT_FOUND_ERROR, "Missing Address.FriendlyName");
        if (Street1 == null)        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_STREET_1_NOT_FOUND_ERROR, "Missing Address.Street1");
        if (City == null)           throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_CITY_NOT_FOUND_ERROR, "Missing Address.City");
        if (CountryCode == null)    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_COUNTRY_CODE_NOT_FOUND_ERROR, "Missing Address.CountryCode");

        /*
        if (isUpdate)
        {
            if (Id == 0)       throw new Exception("Missing Address.Id");
        }
        */

        // 18854: SPS doesn't recgonize Nunavut, CA, so we replace it with NT (northern territories) for now
        if (CountryCode == "CA" && StateProvince == "NU")
        {
            StateProvince = "NT";
        }


    }


    public override string ToString()
    {
        string a;

        a = "FriendlyName: " + FriendlyName +
            "\nAddressId: " + AddressId +
            "\nStreet1: " + Street1 +
            "\nStreet2: " + Street2 +
            "\nStreet3: " + Street3 +
            "\nCity: " + City +
            "\nDistrict: " + District +
            "\nState/Province: " + StateProvince +
            "\nPostalCode: " + PostalCode +
            "\nCountryCode: " + CountryCode;

        return a;
    }


}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BdkWrapper.cs ===
//
// BdkWrapper.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;


using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;

using BDKWSDL;

[assembly: XomAreaDefinition(XomAreaName.spslog)]

namespace xonline.common.billing
{
    public enum SessionClientType : int
    {
        Xbox1Console   = 0,
        XenonConsole   = 1,
        LiveService    = 2,
    }

    public class InjectedError
    {
        public InjectedError(string api, HResult hr, string message)
        {
            this.api = api;
            this.hr = hr;
            this.message = message;
        }

        public string  api;
        public HResult hr;
        public string  message;
    }

    public class SessionClientInfo
    {
        public string ipAddress;
        public string deviceType;
        public string deviceId;
        public string acceptLanguage;
        public string acceptCharset;
        public string requestHeaderDate;
        public string userAgent;
        public string xForwardedFor;
    }

    public partial class BdkWrapper : BDKWSDL.bdk
    {
        protected enum APIResultEnum
        {
            Success,
            FailFast,
            Failed,
            Timeout
        }

        public BdkWrapper() : base()
        {
            Init();
            
            this.Timeout = BillingConfig.BillingTimeout;
        }

        private static volatile bool _initialized = false;
        private static object _lockObject = new object();

        public static void Init()
        {
            if (_initialized == false)
            {
                lock (_lockObject)
                {
                    if (_initialized == false)
                    {
                        // Initialize ScsFailure behavior injection
                        ScsFailure.Init();

                        InitializeFastFail();

                        _initialized = true;
                    }
                }
            }
        }

        public const string FastFailSCSCreditCard    = "SCSCreditCard";
        public const string FastFailSCSNonCreditCard = "SCSNonCreditCard";

        protected static FastFailTracker GetFastFailTracker(string api)
        {
            APIResultEnum result = APIResultEnum.Success;

            return GetFastFailTracker(api, ref result);
        }

        protected static FastFailTracker GetFastFailTracker(string api, ref APIResultEnum result)
        {
            Init();

            bool isCreditCardApi = false;

            if ( string.IsNullOrEmpty(api) )
                throw new ArgumentException("api");

            try {
                FastFailTracker tracker;

                if (_scsCreditCardAuthApis != null && _scsCreditCardAuthApis[api] != null)
                {
                    isCreditCardApi = true;
                    tracker = new FastFailTracker(FastFailSCSCreditCard);
                }
                else
                    tracker = new FastFailTracker(FastFailSCSNonCreditCard);

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "GetFastFailTracker: api: " + api + " is not blocked." );

                return tracker;
            }
            catch (FastFailException inner)
            {
                string msg = "GetFastFailTracker: api:" + api + " is blocked due to fast-fail of " + (isCreditCardApi ? "non-" : "") + "Citibank-dependent billing apis.";
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, msg );

                BillingCounters.Current(null).BlockedCallsPerSecond.Increment();
                BillingCounters.Current(null).BlockedCallsTotal.Increment();

                BillingCounters.Current(api).BlockedCallsPerSecond.Increment();
                BillingCounters.Current(api).BlockedCallsTotal.Increment();

                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    inner,
                    "bdk." + api + " call blocked due to previous timeout!");
            }
        }

        protected void HandleTimeout(string apiName)
        {
            BillingCounters.Current(null).TimeoutsPerSecond.Increment();
            BillingCounters.Current(null).TimeoutsTotal.Increment();

            BillingCounters.Current(apiName).TimeoutsPerSecond.Increment();
            BillingCounters.Current(apiName).TimeoutsTotal.Increment();
        }

#region
        const int maxInputParameters  = 20;
        const int maxOutputParameters = 6;

        private static string FormatParamsString(string[] inParams, string[] outParams)
        {
            string logstr = string.Empty;

            if ( inParams != null )
            {
                logstr += String.Join("|", inParams) + "|";

                if (inParams.Length < maxInputParameters)
                {
                    logstr.PadRight(maxInputParameters - inParams.Length, '|');
                }
            }

            if ( outParams != null )
            {
                logstr += String.Join("|", outParams) + "|";

                if (outParams.Length < maxOutputParameters)
                {
                    logstr.PadRight(maxOutputParameters - outParams.Length, '|');
                }
            }

            return logstr;
        }

        private static string FormatParamsString(string[] inParams)
        {
            return FormatParamsString(inParams, null);
        }
#endregion

        protected void HandlePerfCountersBegin(string apiName)
        {
            BillingCounters.Current(null).CallsPerSecond.Increment();
            BillingCounters.Current(null).CallsTotal.Increment();

            BillingCounters.Current(apiName).CallsPerSecond.Increment();
            BillingCounters.Current(apiName).CallsTotal.Increment();
        }

        protected void HandlePerfCountersEnd(string apiName, APIResultEnum result, XomRequestTimeElapsed timeElapsed)
        {
            BillingCounters.Current(null).CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            BillingCounters.Current(null).CallsTimeBase.Increment();

            BillingCounters.Current(apiName).CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            BillingCounters.Current(apiName).CallsTimeBase.Increment();

            if (result != APIResultEnum.Success && result != APIResultEnum.FailFast)
            {
                BillingCounters.Current(null).CallsFailedPerSecond.Increment();
                BillingCounters.Current(null).CallsFailedTotal.Increment();

                BillingCounters.Current(apiName).CallsFailedPerSecond.Increment();
                BillingCounters.Current(apiName).CallsFailedTotal.Increment();
            }
        }

        protected static string SanitizeXmlInputParameter(string inParam)
        {
            string[][] sanitizations = new string[][]
            {
                new string[] { "/scs:PaymentInstrumentInfo/*/scs:EncryptedAccountNumber", "****************" },
                new string[] { "/scs:PaymentInstrumentInfo/scs:CreditCardInfo/scs:EncryptedCVMCode", "***" },
            };

            if ( string.IsNullOrEmpty(inParam) || sanitizations == null )
            {
                return inParam;
            }

            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(inParam);

                XmlNamespaceManager nsm = new XmlNamespaceManager(xmlDoc.NameTable);
                nsm.AddNamespace("scs", "urn:schemas-microsoft-com:billing-data");

                for (int i=0; i < sanitizations.Length; i++)
                {
                    string xpath = sanitizations[i][0];
                    string replacement = sanitizations[i][1];

                    XmlNodeList nodes = xmlDoc.SelectNodes(xpath, nsm);
                    if ( nodes != null && nodes.Count > 0 )
                    {
                        foreach (XmlNode node in nodes)
                        {
                            if ( !string.IsNullOrEmpty(node.InnerText) )
                            {
                                node.InnerText = replacement;
                            }
                        }
                    }
                }

                return xmlDoc.OuterXml;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "SanitizeXmlInputParameter: inParam=" + inParam + ": resulted in exception: " + e );

                return inParam;
            }
        }

        protected void LogApiCall(string apiName, APIResultEnum result, long millisecondsElapsed, string [] inParams, string [] outParams, string scsErrorDetails)
        {
            string resultString;
            switch (result)
            {
                case APIResultEnum.Success:
                    resultString = "Success";
                    break;

                case APIResultEnum.FailFast:
                    resultString = "FailFast";
                    break;

                case APIResultEnum.Failed:
                    resultString = "Failed";
                    break;

                case APIResultEnum.Timeout:
                    resultString = "Timeout";
                    break;

                default:
                    resultString = "Unknown";
                    break;
            }

            string szLog = string.Join("|", new string []
            {
                apiName,
                resultString,
                millisecondsElapsed.ToString(),
                string.Join("|", inParams),
                result == APIResultEnum.Success ? string.Join("|", outParams) : "Failed",
                scsErrorDetails == null ? "" : scsErrorDetails
            });

            Xom.Log(XomAreaName.spslog, szLog);
        }

        protected static void LogUserContextualInfo(BDKWSDL.UserContextualInfoSoapHeader hdr)
        {
            if ( hdr == null )
            {
                return;
            }

            string szLog = string.Join("|", new string []
            {
                "UserContextualInfoSoapHeader",
                GetSessionBdkApi(),
                hdr.IPAddress ?? "",
                hdr.DeviceType ?? "",
                hdr.DeviceId ?? "",
                hdr.AcceptLanguage ?? "",
                hdr.AcceptCharset ?? "",
                hdr.UserAgent ?? "",
                hdr.XForwardedFor ?? "",
            });

            Xom.Log(XomAreaName.spslog, szLog);
        }
#region
        private static Hashtable _scsCreditCardAuthApis = null;

        // resource strings to use with FastFailHelper
        protected static string CreditCardAuthApi = "CreditCardAuthApi";
        protected static string NonCreditCardAuthApi = "NonCreditCardAuthApi";

        protected static void InitializeFastFail()
        {
            FastFailResourceConfig defaultConfig;

            // initialize the list of APIs that perform credit card auth
            InitializeCreditCardAuthApis();

            defaultConfig = FastFailBillingDefaults.GetConfiguration();

            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, FastFailSCSCreditCard);
            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, FastFailSCSNonCreditCard);
        }

        protected static void InitializeCreditCardAuthApis()
        {
            Hashtable ccApis = new Hashtable();

            string[] creditCardAuthApiList = Config.GetMultiSetting(MultiSetting.scs_creditCardAuthApis);

            foreach (string api in creditCardAuthApiList)
            {
                try
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "InitializeCreditCardAuthApis: adding credit card auth api: " + api );
                    ccApis.Add(api, api);
                }
                catch (System.ArgumentException ae)
                {
                    string errMsg = "InitializeCreditCardAuthApis: caught ArgumentException trying to add api: " + api + " to _scsCreditCardAuthApi hashtable.  Check t_multisettings for duplicate values!";

                    Xom.NtEvent( XEvent.Id.BDK_BLOCKING_SCS_APIS_BAD_MULTISETTING, ae, errMsg);
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, errMsg );
                }
            }

            _scsCreditCardAuthApis = ccApis;
        }
#endregion

#region
        // regular expression to identify URLs -- not too strict as a more pedantic
        // URL regular expression wouldn't allow for our intranet URLs used by the STF
        // code for emulators (i.e. http://emulator-box)
        private static Regex _urlRegex = new Regex(
            @"^(https?://)([0-9a-z].*)",
            RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase
        );

        private const string _behaviorInjectionKey = "BEHAVIOR_INJECTIONS";

        // If BillingConfig.AllowUrlOverrideInRequest is set, this TLS can be used
        // to redirect billing requests to an alternate Url on a request (or
        // thread) basis
        [ThreadStaticAttribute]
        private static string _tlsSessionAlternateUrl = null;

        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateUrl()
        {
            Init();

            _tlsSessionAlternateUrl = null;
        }

        // Set the session alternate Url.
        public static void SetSessionAlternateUrl(string url)
        {
            Init();

            // if the url doesn't look like a url, treat it as BehaviorInjection headers
            if ( _urlRegex.IsMatch(url) )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, string.Format("BdkWrapper.SetSessionAlternateUrl: using AlternateUrl: {0}...", url));

                _tlsSessionAlternateUrl = url;
            }
            else if ( url.StartsWith(_behaviorInjectionKey+":") )
            {
                // header value itself follows "BEHAVIOR_INJECTIONS:" key
                string biHeader = url.Substring(_behaviorInjectionKey.Length+1);

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, string.Format("BdkWrapper.SetSessionAlternateUrl: adding BehaviorInjection headers: {0}...", biHeader));

                // construct a NameValueCollection and add it as the BehaviorInjections
                NameValueCollection nvc = new NameValueCollection();
                nvc.Add(_behaviorInjectionKey, biHeader);
                RequestHeaderBehaviorInjectionMgr.AddBehaviorInjections(nvc);
            }
        }

        // Get the session alternate Url
        public static string GetSessionAlternateUrl()
        {
            Init();

            return _tlsSessionAlternateUrl;
        }
#endregion

#region
        // In order to support different SCS timeout settings for Xbox1 vs.
        // Xenon consoles as well as different timeouts for calls made by
        // tools and the Xbox Live service, this TLS can be used to indicate
        // the client type.
        [ThreadStaticAttribute]
        private static int _tlsSessionClientType = 0;

        public static void ResetSessionClientType()
        {
            Init();

            _tlsSessionClientType = 0;

            // make sure SessionClientInfo is also cleared
            ResetSessionClientInfo();
        }

        public static void SetSessionClientType(int clientType)
        {
            Init();

            _tlsSessionClientType = clientType;
        }

        public static void SetSessionClientType(SessionClientType clientType)
        {
            SetSessionClientType((int)clientType);
        }

        public static void SetSessionClientType(SGInfo sg)
        {
            if ( sg != null )
            {
                if ( sg._IsXbox360() || sg._IsPc() )
                {
                    SetSessionClientType((int)SessionClientType.XenonConsole);
                }
                else if ( sg._IsInternal() )
                {
                    SetSessionClientType((int)SessionClientType.LiveService);
                }
                else
                {
                    SetSessionClientType((int)SessionClientType.Xbox1Console);
                }
            }
            else
            {
                SetSessionClientType((int)SessionClientType.Xbox1Console);
            }

            // make sure SessionClientInfo is also populated
            SetSessionClientInfo(sg);
        }

        public static int GetSessionClientType()
        {
            Init();

            return _tlsSessionClientType;
        }
#endregion

#region
        // In order to support passing IP address, device id, etc. to SCS,
        // this TLS can be used to track what is present in either SGInfo
        // or AAInfo
        [ThreadStaticAttribute]
        private static SessionClientInfo _tlsSessionClientInfo;

        public static void ResetSessionClientInfo()
        {
            Init();

            _tlsSessionClientInfo = null;
        }

        public static void SetSessionClientInfo(SessionClientInfo clientInfo)
        {
            Init();

            _tlsSessionClientInfo = clientInfo;
        }

        public static void SetSessionClientInfo(SGInfo sg)
        {
            if ( sg != null )
            {
                string ipAddress = string.Empty;
                string deviceId = string.Empty;
                string deviceType = string.Empty;

                ipAddress = sg.ClientIP.ToString();
                deviceId = sg.MachineId.ToString("x");

                if (sg._IsXbox360())
                    deviceType = "Xbox 360";
                else if (sg._IsXbox())
                    deviceType = "Xbox";
                else if (sg._IsPc())
                    deviceType = "Panorama";
                else if (sg._IsInternal())
                {
                    deviceType = "Service";
                    deviceId = null;
                }
                else
                    deviceType = "Unknown";

                SetSessionClientInfo(ipAddress, deviceId, deviceType);

            }
        }
        public static void SetSessionClientInfo(string ipAddress,string deviceId,string deviceType)
        {
            Init();

            SessionClientInfo clientInfo = new SessionClientInfo();
            clientInfo.ipAddress = ipAddress;
            clientInfo.deviceId = deviceId;
            clientInfo.deviceType = deviceType;
            _tlsSessionClientInfo = clientInfo;
        }

        public static void SetSessionClientInfo(AAInfo aaInfo)
        {
            Init();

            if ( aaInfo != null )
            {
                SessionClientInfo clientInfo = new SessionClientInfo();

                clientInfo.ipAddress = aaInfo.IpAddressInternet;
                clientInfo.deviceType = "IDCRL client";
                clientInfo.deviceId = aaInfo.PassportPuid.ToString("x");

                _tlsSessionClientInfo = clientInfo;
            }
        }

        public static SessionClientInfo GetSessionClientInfo()
        {
            return _tlsSessionClientInfo;
        }

        public void SetUserContextualData()
        {
            Init();

            SessionClientInfo clientInfo = GetSessionClientInfo();

            if ( clientInfo == null )
            {
                return;
            }

            BDKWSDL.UserContextualInfoSoapHeader hdr = new BDKWSDL.UserContextualInfoSoapHeader();
            hdr.IPAddress = clientInfo.ipAddress;
            hdr.DeviceType = clientInfo.deviceType;
            hdr.DeviceId = clientInfo.deviceId;
            hdr.AcceptLanguage = clientInfo.acceptLanguage;
            hdr.AcceptCharset = clientInfo.acceptCharset;
            hdr.UserAgent = clientInfo.userAgent;
            hdr.XForwardedFor = clientInfo.xForwardedFor;

            //Only set the fraud session id if the caller provided a value was via SetFraudSessionId
            if (!String.IsNullOrEmpty(_fraudSessionId))
            {
                hdr.THM_session_id = _fraudSessionId;
            }

            this.UserContextualInfoSoapHeaderValue = hdr;
        }
#endregion

#region

        [ThreadStaticAttribute]
        private static string _fraudSessionId = String.Empty;

        public static void ResetFraudSessionId()
        {
            Init();

            _fraudSessionId = String.Empty;
        }

        public static void SetFraudSessionId(string fraudSessionId)
        {
            Init();

            _fraudSessionId = fraudSessionId;
        }

        public static string GetFraudSessionId()
        {
            Init();

            return _fraudSessionId;
        }
#endregion

#region

        [ThreadStaticAttribute]
        private static string _tlsSessionBdkApi = null;

        public static void ResetSessionBdkApi()
        {
            Init();

            _tlsSessionBdkApi = null;
        }

        public static void SetSessionBdkApi(string api)
        {
            Init();

            _tlsSessionBdkApi = api;
        }

        public static string GetSessionBdkApi()
        {
            Init();

            return _tlsSessionBdkApi;
        }
#endregion

#region
        [ThreadStaticAttribute]
        private static InjectedError _tlsSessionInjectedError = null;

        public static void ResetSessionInjectedError()
        {
            Init();

            _tlsSessionInjectedError = null;
        }

        public static void SetSessionInjectedError(string api, HResult hr, string message)
        {
            Init();

            _tlsSessionInjectedError = new InjectedError( api, hr, message );
        }

        public static InjectedError GetSessionInjectedError()
        {
            Init();

            return _tlsSessionInjectedError;
        }

        public static ScsFailure.PostCallDelegate HandleSessionInjectedError(string api, ref int timeout)
        {
            return HandleSessionInjectedError(api, null, ref timeout);
        }

        public static ScsFailure.PostCallDelegate HandleSessionInjectedError(string api, string[] inParams, ref int timeout)
        {
            Init();

            ScsFailure.PostCallDelegate postCall;

            // first, handle injections from the BehaviorInjection framework
            postCall = ScsFailure.HandleBehaviorInjection(api, ref timeout);

            // next, try to handle any old-school error injections that are present
            InjectedError err = GetSessionInjectedError();
            if ( err != null && err.api == api && HResult.Failed(err.hr) )
            {
                if ( err.hr == HResult.XONLINE_E_ACCOUNTS_BILLING_PROVIDER_TIMEOUT )
                {
                    int apiTimeout = 0;
                    try
                    {
                        apiTimeout = BillingConfig.GetApiTimeout(api);
                    } catch (Exception e)
                    {
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "HandleSessionInjectedError: error finding timeout value for api " + api + ", exception: " + e );
                    }

                    throw new System.ServiceProcess.TimeoutException(api + " timeout failure!  Waited " + apiTimeout + " ms and no response." + (inParams == null ? "" : "  Input parameters: " + FormatParamsString(inParams)) + "  (This error was artificially injected through an HTTP header in the incoming request and was not the result of an actual SCS timeout)");
                }
                else
                {
                    string scsMessage = null;

                    BdkErrorDetail errDetail = BdkError.GetErrorDetail(err.hr);
                    if ( errDetail != null )
                    {
                        scsMessage = string.Format("<ErrorPackage><ErrorHResult>0x{0}</ErrorHResult><ErrorMessage>{1}</ErrorMessage><Retryable>{2}</Retryable>",
                            err.hr.ToString(),
                            (errDetail.Message == null ? "" : errDetail.Message),
                            (errDetail.Retryable ? "true" : "false"));
                    }
                    else
                    {
                        scsMessage =
                            "<ErrorPackage>" +
                            "<ErrorHResult>" + ((HResult) err.hr) + "</ErrorHResult>" +
                            "<ErrorMessage>" + (err.message == null ? "" : err.message) + "</ErrorMessage>";

                        // well-known and unfortunately hard-coded retryable SCS errors

                        if ((err.hr == HResult.XONLINE_E_BILLING_DECRYPTION_FAILURE) ||
                            (err.hr == HResult.XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_FAILED) ||
                            (err.hr == HResult.XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_TIMEOUT) ||
                            (err.hr == HResult.XONLINE_E_BILLING_DD_GC_RETURNED_NOK_RESULT) ||
                            (err.hr == HResult.XONLINE_E_BILLING_TOKEN_ALREADY_DELIVERED) ||
                            (err.hr == HResult.XONLINE_E_BILLING_MPF_CALL_FAILED) ||
                            (err.hr == HResult.XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE) ||
                            (err.hr == HResult.XONLINE_E_DMP_E_MAX_BALANCE_EXCEEDED) ||
                            (err.hr == HResult.XONLINE_E_DMP_E_UNKNOWN_ERROR))
                        {
                            scsMessage += "<Retryable>true<Retryable>";
                        }
                    }

                    scsMessage +=
                            "<InjectedErrorDisclaimer>This error was artificially injected due to an HTTP header in the incoming request and was not generated by SCS</InjectedErrorDisclaimer>" +
                            "</ErrorPackage>";

                        throw new SoapException(scsMessage, SoapException.ClientFaultCode);
                }
            }

            return postCall;
        }
#endregion

#region
        // helper methods for building, serializing, and deserializing XML used for calling
        // CalculateTax, SubmitOrder, and OffsetOrder

        /// <summary>
        /// Build CallerInfoXml fragment from given puid.</summary>
        /// <param name="requesterPuid">The user's billing puid (typically the LiveId)</param>
        public static string GetCallerInfoXml(ulong requesterPuid)
        {
            const string callerInfoXmlTemplate =
                "<bdk:CallerInfo xmlns:bdk=\"urn:schemas-microsoft-com:billing-data\">" +
                  "<bdk:DelegateId>0</bdk:DelegateId>" +
                  "<bdk:RequesterId>{0}</bdk:RequesterId>" +
                  "<bdk:OnBehalfOfPartner>00000000-0000-0000-0000-000000000000</bdk:OnBehalfOfPartner>" +
                  "<bdk:IdentityType>PUID</bdk:IdentityType>" +
                "</bdk:CallerInfo>";

            string callerInfoXml = string.Format(callerInfoXmlTemplate, requesterPuid.ToString("d"));

            return callerInfoXml;
        }

        /// <summary>
        /// Build OrderDetailXml fragment to be used calling SubmitOrder.</summary>
        /// <param name="offerInfoList">The OfferInfo used to build the ItemEntry node.</param>
        /// <param name="orderId">Orderid of the submit order request</param>
        /// <param name="purchaseOrigin">internal or external platform type</param>
        /// <param name="timestamp">time stamp of transaction</param>
        public static string GetOrderDetailXml(DateTime timestamp, Guid orderId, List<OfferInfo> offerInfoList,byte purchaseOrigin)
        {
            Debug.Assert( offerInfoList != null );
            Debug.Assert( offerInfoList.Count > 0 );

            
            const string itemEntryXmlTemplate =
                    "<bdk:ItemEntry>" +
                      "<bdk:ItemExternalId>{0}</bdk:ItemExternalId>" +
                      "<bdk:ItemName>{1}</bdk:ItemName>" +
                      "<bdk:ItemDescription>{2}</bdk:ItemDescription>" +
                      "<bdk:ItemCategory>{3}</bdk:ItemCategory>" +
                      "<bdk:ItemType>PURCHASE</bdk:ItemType>" +
                      "<bdk:RevenueSKU>{4}</bdk:RevenueSKU>" +
                      "<bdk:ProductType>OnlineDownload</bdk:ProductType>" +
                      "<bdk:UnitPrice>{5}</bdk:UnitPrice>" +
                      "<bdk:Quantity>1</bdk:Quantity>" +
                      "<bdk:IsTaxIncluded>{6}</bdk:IsTaxIncluded>" +
                    "</bdk:ItemEntry>";

            const string orderAttributeXmlTemplate =
                   "<bdk:OrderAttribute>" +
                        "<bdk:Namespace/> " +
                        "<bdk:Name>ProductGuid</bdk:Name>" +
                        "<bdk:Value>{0}</bdk:Value>" +
                    "</bdk:OrderAttribute>";

            string orderAttributeXml = string.Empty;

            if(purchaseOrigin==(byte)DMPPurchaseOrigin.Xbox360 || purchaseOrigin==(byte)DMPPurchaseOrigin.XboxDotCom)
            {
                orderAttributeXml=string.Format(orderAttributeXmlTemplate, Config.GetSetting(Setting.xbos_xbox360OrderAttributeGuid));
            }
            else if(purchaseOrigin==(byte)DMPPurchaseOrigin.GamesForWindowsDotCom || purchaseOrigin==(byte)DMPPurchaseOrigin.GamesForWindows)
            {
                orderAttributeXml=string.Format(orderAttributeXmlTemplate, Config.GetSetting(Setting.xbos_gfwlOrderAttributeGuid));
            }

            const string orderDetailXmlTemplate =
                "<bdk:OrderDetail xmlns:bdk=\"urn:schemas-microsoft-com:billing-data\">" +
                  "<bdk:Timestamp>{0}</bdk:Timestamp>" +
                  "<bdk:BillingMode>ImmediateSettle</bdk:BillingMode>" +
                  "<bdk:ExternalId>{1}</bdk:ExternalId>" +
                  "<bdk:Description>Description</bdk:Description>" +
                  "<bdk:Currency>{2}</bdk:Currency>" +
                  "<bdk:ItemEntrySet>" +
                    "{3}" +
                  "</bdk:ItemEntrySet>" +
                  "<bdk:OrderAttributeSet>" +
                    "{4}" +
                  "</bdk:OrderAttributeSet>" +
                "</bdk:OrderDetail>";

            StringBuilder itemEntrySetXml = new StringBuilder();
            foreach (OfferInfo offerInfo in offerInfoList)
            {
                bool isTaxIncluded = Offer.IsTaxIncludedInPrices((TaxTypeEnum)offerInfo.taxTypeId);

                string isTaxIncludedText = isTaxIncluded.ToString().ToLower();

                string itemEntryXml = string.Format(itemEntryXmlTemplate,
                    offerInfo.offerId.ToString(),
                    HttpUtility.HtmlEncode(offerInfo.reducedTitle.Trim()),
                    HttpUtility.HtmlEncode(offerInfo.reducedTitle.Trim()),
                    HttpUtility.HtmlEncode(offerInfo.mediaType.Trim()),
                    HttpUtility.HtmlEncode(offerInfo.sku.Trim()),
                    offerInfo.currencyPrice.ToString("#.##"),
                    isTaxIncluded.ToString().ToLower() // isTaxIncludedText
                );

                itemEntrySetXml.Append(itemEntryXml);
            }

            string orderDetailXml = string.Format(orderDetailXmlTemplate,
                timestamp.ToString("s"),
                orderId.ToString(),
                offerInfoList[0].currencyCode,
                itemEntrySetXml.ToString(),
                orderAttributeXml
                );

            return orderDetailXml;
        }

        /// <summary>
        /// Build OrderDetailXml fragment to be used calling OffsetOrder.</summary>
        /// <param name="orderId">The OrderId returned by the original call to SubmitOrder.</param>
        public static string GetOffsetOrderDetailXml(string externalId, string currencyCode, long orderId)
        {
            const string offsetOrderDetailXmlTemplate =
                "<bdk:OrderDetail xmlns:bdk=\"urn:schemas-microsoft-com:billing-data\">" +
                  "<bdk:Timestamp>{0}</bdk:Timestamp>" +
                  "<bdk:BillingMode>RefundOrCancel</bdk:BillingMode>" +
                  "<bdk:ExternalId>{1}</bdk:ExternalId>" +
                  "<bdk:Description>SubmitOrder call timed out and no license was granted to user. Calling OffsetOrder to credit user for ungranted license.</bdk:Description>" +
                  "<bdk:Currency>{2}</bdk:Currency>" +
                  "<bdk:OriginalOrderId>{3}</bdk:OriginalOrderId>" +
                  "<bdk:OrderAttributeSet>" +
                    "<bdk:OrderAttribute>" +
                      "<bdk:Name>FinancialReportingCode</bdk:Name>" +
                      "<bdk:Value>{4}</bdk:Value>" +
                    "</bdk:OrderAttribute>" +
                  "</bdk:OrderAttributeSet>" +
                "</bdk:OrderDetail>";

            DateTime now = DateTime.UtcNow;

            string offsetOrderDetailXml = string.Format(offsetOrderDetailXmlTemplate,
                now.ToString("s"),
                externalId,
                currencyCode,
                orderId.ToString("d"),
                Config.GetSetting(Setting.billing_offsetOrderFinancialReportingCode)
                );

            return offsetOrderDetailXml;
        }

        [XmlType(Namespace = "urn:schemas-microsoft-com:billing-data")]
        public class CorrelationInfo
        {
            public string DisplayInfo;
            public string CorrelationData;
        }

        [XmlType(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [XmlRoot(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class OrderReceipt
        {
            public long OrderId;
            public string OrderPaymentStatus;
            public decimal TotalAmount;
            public decimal TotalTaxAmount;
            public bool IsTaxIncluded;
            public string PaymentInstrumentId;
            public CorrelationInfo CorrelationInfo;
        }

        public static OrderReceipt GetOrderReceiptFromXml(string orderReceiptXml)
        {
            XmlSerializer ser = new XmlSerializer(typeof(OrderReceipt));

            StringReader sr = new StringReader(orderReceiptXml);

            OrderReceipt r = (OrderReceipt)ser.Deserialize(sr);

            return r;
        }

        /// <summary>
        /// Build CorrelationInfoXml fragment from OrderReceipt.</summary>
        /// <param name="requesterPuid">The user's billing puid (typically the LiveId)</param>
        public static string GetCorrelationInfoXml(OrderReceipt orderReceipt)
        {
            Debug.Assert(orderReceipt != null);
            Debug.Assert(orderReceipt.CorrelationInfo != null);
            Debug.Assert(orderReceipt.CorrelationInfo.DisplayInfo != null);
            Debug.Assert(orderReceipt.CorrelationInfo.CorrelationData != null);

            const string correlationInfoXmlTemplate =
                "<bdk:CorrelationInfo xmlns:bdk=\"urn:schemas-microsoft-com:billing-data\">" +
                  "<bdk:DisplayInfo>{0}</bdk:DisplayInfo>" +
                  "<bdk:CorrelationData>{1}</bdk:CorrelationData>" +
                "</bdk:CorrelationInfo>";

            string correlationInfoXml = string.Format(correlationInfoXmlTemplate, orderReceipt.CorrelationInfo.DisplayInfo, orderReceipt.CorrelationInfo.CorrelationData);

            return correlationInfoXml;
        }

        public static string GetCommentInfoXml()
        {
            string commentInfoXmlTemplate =
                "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                  "<CommentCode>{0}</CommentCode>" +
                  "<CommentText>SubmitOrder call timed out and no license was granted to user. Calling OffsetOrder to credit user for ungranted license.</CommentText>" +
                "</CommentInfo>";

            string commentInfoXml = string.Format(commentInfoXmlTemplate, Config.GetSetting(Setting.billing_offsetOrderCommentInfoCommentCode));

            return commentInfoXml;
        }
#endregion

#region
        public static void CalculateTax(ulong puid, string accountId, string orderDetailXml, out string returnOrderDetailXml)
        {
            const string apiVersion = "1.0";

            string callerInfoXml = GetCallerInfoXml(puid);

            BillingProvider bdk = new BillingProvider();

            bdk.CalculateTax(apiVersion, callerInfoXml, accountId, null, orderDetailXml, out returnOrderDetailXml);
        }

        public static void SubmitOrder(ulong puid, Guid trackingGuid, string paymentInstrumentId, string orderDetailXml, out string orderReceiptXml)
        {
            const string apiVersion = "1.0";

            string callerInfoXml = GetCallerInfoXml(puid);

            BillingProvider bdk = new BillingProvider();

            bdk.SubmitOrder(apiVersion, trackingGuid, callerInfoXml, paymentInstrumentId, null /* piXml */, orderDetailXml, out orderReceiptXml);
        }

        public static void OffsetOrder(ulong puid, Guid trackingGuid, string paymentInstrumentId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, out string orderReceiptXml)
        {
            const string apiVersion = "1.0";

            string callerInfoXml = GetCallerInfoXml(puid);

            BillingProvider bdk = new BillingProvider();

            bdk.OffsetOrder(apiVersion, trackingGuid, callerInfoXml, paymentInstrumentId, correlationInfoXml, orderDetailXml, commentInfoXml, out orderReceiptXml);
        }

#endregion
    }
} // namespace
namespace BDKWSDL
{
    public partial class UserContextualInfoSoapHeader
    {
        public string THM_session_id
        {
            get;
            set;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BdkErrorAutoGen.cs ===
//
// BdkErrorAutoGen.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This is an auto-generated file. Please don't modify directly.
//
// This file defines constants for all of the BDK errors returned by SCS APIs and
// indicates whether the error is retryable and includes the supplied description.
//
// It is generated from the BdkError.xml file referenced by $(SCS_BDK_ERROR_XML) in
// build\sources.all (typically this will be public\ext\xonline-ext\SCS\$(SCS_SDK)\inc).
//

using System;

namespace xonline.common.billing
{

    public partial class BdkError
    {
         public const uint BDK_E_BAN_NULL_INPUT_PARAMETER = 0x80047594;
         public const uint BDK_E_ALREADY_BANNED = 0x80047599;
         public const uint BDK_E_NOT_BANNED = 0x8004759E;
         public const uint BDK_E_BANNEDPERSON = 0x800475BC;
         public const uint BDK_E_COUNTRY_CURRENCY_PI_MISMATCH = 0x800475C1;
         public const uint BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x800475C8;
         public const uint BDK_E_INVALID_CREDIT_CARD_TYPE = 0x800475CB;
         public const uint BDK_E_DECRYPTION_FAILURE = 0x800475D0;
         public const uint BDK_E_BANNED_PAYMENT_INSTRUMENT = 0x800475C6;
         public const uint BDK_E_INVALID_DD_ACCOUNT = 0x800475E4;
         public const uint BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 0x800475E9;
         public const uint BDK_E_INVALID_CREDIT_CARD_NUMBER = 0x80047530;
         public const uint BDK_E_CREDIT_CARD_EXPIRED = 0x80047531;
         public const uint BDK_E_AVS_FAILED = 0x8004760C;
         public const uint BDK_E_NO_AVS_RESULT = 0x8004760D;
         public const uint BDK_E_AUTHORIZATION_FAILED = 0x80047611;
         public const uint BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED = 0x8004761B;
         public const uint BDK_E_DD_INVALID_COUNTRY = 0x8004762F;
         public const uint BDK_E_DD_INVALID_ACCOUNT_FORMAT = 0x80047634;
         public const uint BDK_E_DD_INVALID_BANKCODE_FORMAT = 0x80047639;
         public const uint BDK_E_DD_INVALID_BRANCHCODE_FORMAT = 0x8004763E;
         public const uint BDK_E_DD_INVALID_CHECKDIGIT_FORMAT = 0x80047643;
         public const uint BDK_E_DD_ACCOUNT_MISSING = 0x80047648;
         public const uint BDK_E_DD_BANKCODE_MISSING = 0x8004764D;
         public const uint BDK_E_DD_BRANCHCODE_MISSING = 0x80047652;
         public const uint BDK_E_DD_CHECKDIGIT_MISSING = 0x80047657;
         public const uint BDK_E_DD_ERROR_IN_FIELDS = 0x8004765C;
         public const uint BDK_E_DD_INVALID_ACCOUNT_VALUE = 0x80047661;
         public const uint BDK_E_DD_INVALID_BANKCODE_VALUE = 0x80047666;
         public const uint BDK_E_DD_INVALID_BRANCHCODE_VALUE = 0x8004766B;
         public const uint BDK_E_DD_INVALID_CHECKDIGIT_VALUE = 0x80047670;
         public const uint BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME = 0x8004767A;
         public const uint BDK_E_DD_UNKNOWN_PROVIDER_FAILURE = 0x8004771F;
         public const uint BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x8004767F;
         public const uint BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER = 0x80047680;
         public const uint BDK_E_INVALID_INITIATE_TRANSACTION_RESULT = 0x80047681;
         public const uint BDK_E_INVALID_WHOLESALE_PARTNER = 0x80047684;
         public const uint BDK_E_PI_NOT_SUPPORTED = 0x80047693;
         public const uint BDK_E_UPS_NOT_UPDATED = 0x8004769D;
         public const uint BDK_E_DD_UNSUPPORTED = 0x800476A2;
         public const uint BDK_E_DD_MPF_NON_XML_RESPONSE = 0x800476A7;
         public const uint BDK_E_DD_MPF_INCORRECT_XML_FORMAT = 0x800476AC;
         public const uint BDK_E_DD_GC_NON_XML_RESPONSE = 0x800476B1;
         public const uint BDK_E_DD_GC_INCORRECT_XML_FORMAT = 0x800476B6;
         public const uint BDK_E_DD_GC_RETURNED_NOK_RESULT = 0x800476BB;
         public const uint BDK_E_DD_GC_CHECK_INCOMPLETE = 0x800476C0;
         public const uint BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED = 0x800476C5;
         public const uint BDK_E_DD_GC_XML_INVALID_CHECK_RESULT = 0x800476CA;
         public const uint BDK_E_DD_GC_INVALID_RFBANKCODE = 0x800476CF;
         public const uint BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x800476D9;
         public const uint BDK_E_INVALID_BAN_REASON_CODE = 0x800476DE;
         public const uint BDK_E_INVALID_CVM_CODE = 0x800476E3;
         public const uint BDK_E_UNEXPECTED_CVM_RESPONSE_CODE = 0x800476E8;
         public const uint BDK_E_CVM_FAILED = 0x800476ED;
         public const uint BDK_E_IMMEDIATE_SETTLEMENT_FAILURE = 0x800476EE;
         public const uint BDK_E_FREQUENCY_CHECK_FAILED = 0x800476F2;
         public const uint BDK_E_DD_INVALID_MERCHANT_INDEX = 0x800476F7;
         public const uint BDK_E_DD_DUPLICATE_MRN = 0x800476FC;
         public const uint BDK_E_DD_UNKNOWN_VALIDATION_FAILURE = 0x80047701;
         public const uint BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL = 0x80047706;
         public const uint BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL = 0x8004770B;
         public const uint BDK_E_DD_RISK_DECLINE = 0x80047715;
         public const uint BDK_E_UNABLE_TO_VALIDATE_TAX_ID = 0x80047724;
         public const uint BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED = 0x80047729;
         public const uint BDK_E_EXTERNAL_VENDOR_ERROR = 0x8004772E;
         public const uint BDK_E_ALREADY_IN_SPECIFIED_STATE = 0x80049C41;
         public const uint BDK_E_MISSING_SEARCH_CRITERIA = 0x80049C44;
         public const uint BDK_E_REQUIRED_FIELD_MISSING = 0x80049C45;
         public const uint BDK_E_ACTIVE_SUBSCRIPTIONS = 0x80049C46;
         public const uint BDK_E_UNEXPECTED_FIELD = 0x80049C47;
         public const uint BDK_E_INVALID_ACCOUNT_SOUCE = 0x80049C4D;
         public const uint BDK_E_INVALID_CREATION_DATE = 0x80049C4E;
         public const uint BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS = 0x80049C55;
         public const uint BDK_E_GENERATE_NEXT_ID = 0x80049C59;
         public const uint BDK_E_INVALID_STATE_FOR_COUNTRY = 0x80049C5F;
         public const uint BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 0x80049C61;
         public const uint BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 0x80049C62;
         public const uint BDK_E_INVALID_BILLABLE_ACCOUNT_ID = 0x80049CC2;
         public const uint BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 0x80049CC7;
         public const uint BDK_E_INVALID_PHONE_TYPE = 0x80049CD6;
         public const uint BDK_E_INVALID_OFFERING_ID = 0x80049CE5;
         public const uint BDK_E_INVALID_PURCHASE_INPUT_DATA = 0x80049CE6;
         public const uint BDK_E_PUID_MISSING_ATTRIBUTE = 0x80049CE7;
         public const uint BDK_E_INVALID_COUNTRY_CODE = 0x80049CEA;
         public const uint BDK_E_INVALID_ADDRESS_ID = 0x80049CEF;
         public const uint BDK_E_INVALID_PAYMENT_METHOD_ID = 0x80049CF9;
         public const uint BDK_E_PI_EXECEED_MAX_OWNER_SHIP = 0x80049D03;
         public const uint BDK_E_SUBSCRIPTION_ALREADY_CANCELED = 0x80049D08;
         public const uint BDK_E_DELAYED_EXPIRE_ALREADY_PENDING = 0x80049D0A;
         public const uint BDK_E_DELAYED_EXPIRE_NOT_PENDING = 0x80049D0B;
         public const uint BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED = 0x80049D0C;
         public const uint BDK_E_INVALID_CANCEL_DATE = 0x80049D09;
         public const uint BDK_E_INVALID_SUBSCRIPTION_ID = 0x80049D0D;
         public const uint BDK_E_INVALID_PERIOD_TO_PROCESS = 0x80049D2B;
         public const uint BDK_E_INVALID_SUBSCRIPTION_STATUS = 0x80049D3A;
         public const uint BDK_E_NON_ACTIVE_ACCOUNT = 0x80049D94;
         public const uint BDK_E_VATID_DOESNOTHAVEEXPDATE = 0x80049D95;
         public const uint BDK_E_TAXID_EXPDATE = 0x80049D96;
         public const uint BDK_E_INVALID_TAX_EXEMPT_TYPE = 0x80049D97;
         public const uint BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID = 0x80049D98;
         public const uint BDK_E_NO_ACTIVE_SUBSCRIPTION = 0x80049D99;
         public const uint BDK_E_INVALID_SERVICE_INSTANCE = 0x80049D9E;
         public const uint BDK_E_ADD_USER_TO_SERVICE_INSTANCE = 0x80049DA3;
         public const uint BDK_E_INVALID_BILLABLEACCTSTATUS = 0x80049DA8;
         public const uint BDK_E_SERVICE_INSTANCES_NONE = 0x80049DBC;
         public const uint BDK_E_ACCOUNT_CLOSED = 0x80049DD1;
         public const uint BDK_E_BILLINGPERIOD_PAST = 0x80049DD6;
         public const uint BDK_E_INVALID_ADJUSTMENTGUID = 0x80049DD7;
         public const uint BDK_E_INVALID_ADJUSMENT_FOR_PERIOD = 0x80049DD8;
         public const uint BDK_E_ADJUSTMENT_TOOBIG = 0x80049DD9;
         public const uint BDK_E_ADJUSTMENT_TOOSMALL = 0x80049DDB;
         public const uint BDK_E_INVALID_LOCALE = 0x80049DE5;
         public const uint BDK_E_INVALID_CUSTOMER_TYPE = 0x80049DE6;
         public const uint BDK_E_INVALID_CURRENCY = 0x80049DE7;
         public const uint BDK_E_DATE_EXPIRED = 0x80049DE8;
         public const uint BDK_E_GUID_EXISTS = 0x80049DEA;
         public const uint BDK_E_INVALID_VIOLATION_ID = 0x80049DEC;
         public const uint BDK_E_MISSING_VIOLATION_ID = 0x80049DED;
         public const uint BDK_E_NEEDTODEPROVISION = 0x80049DEF;
         public const uint BDK_E_PARTIALCONV_INITIATED = 0x80049DF0;
         public const uint BDK_E_CANNOT_UPDATE_CURRENCY = 0x80049DF1;
         public const uint BDK_E_PARTIALCONV_EXPECTED = 0x80049DF2;
         public const uint BDK_E_INVALID_CATEGORY_NAME = 0x80049DF3;
         public const uint BDK_E_OFFERING_NOT_PURCHASEABLE = 0x80049DF5;
         public const uint BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 0x80049DF6;
         public const uint BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80049DF7;
         public const uint BDK_E_INVALID_DATE = 0x80049DF8;
         public const uint BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP = 0x80049DF9;
         public const uint BDK_E_INVALID_RESOURCE_ID = 0x80049E02;
         public const uint BDK_E_UNIT_OF_MEASURE_MISMATCH = 0x80049E03;
         public const uint BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE = 0x80049E04;
         public const uint BDK_E_INVALID_OFFERING_FOR_LOCALE = 0x80049E05;
         public const uint BDK_E_NOT_A_BASE_OFFERING = 0x80049E06;
         public const uint BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80049E08;
         public const uint BDK_E_INVALID_OFFERING_FOR_COUNTRY = 0x80049E09;
         public const uint BDK_E_MEG_CONFLICT = 0x80049E0A;
         public const uint BDK_E_INVALID_ACCOUNT_STATUS = 0x80049E16;
         public const uint BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST = 0x80049E1B;
         public const uint BDK_E_EXISTING_BILLING_ACTIVITY = 0x80049E1C;
         public const uint BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 0x80049E20;
         public const uint BDK_E_PRIMARY_PHONE_REQUIRED = 0x80049E25;
         public const uint BDK_E_EMAIL_REQUIRED = 0x80049E2A;
         public const uint BDK_E_ACCOUNT_NOT_CLOSED = 0x80049E2B;
         public const uint BDK_E_INVALID_VIOLATION = 0x80049E13;
         public const uint BDK_E_SUBSCRIPTION_IS_CANCELLED = 0x80049E14;
         public const uint BDK_E_NO_VIOLATION = 0x80049E15;
         public const uint BDK_E_EXISTS_VIOLATION = 0x80049E17;
         public const uint BDK_E_INVALID_SERVICE_COMPONENT_ID = 0x80049E32;
         public const uint BDK_E_END_DATE_IN_THE_PAST = 0x80049E33;
         public const uint BDK_E_END_DATE_BEYOND_MAX = 0x80049E34;
         public const uint BDK_E_VIOLATION_ALREADY_SET = 0x80049E3E;
         public const uint BDK_E_NO_VIOLATION_SET = 0x80049E43;
         public const uint BDK_E_INVALID_CONVERSION = 0x80049E4D;
         public const uint BDK_E_SUBS_NOT_INTERMEDIATE = 0x80049E4E;
         public const uint BDK_E_OFFERING_NOT_PUBLISHED = 0x80049E52;
         public const uint BDK_E_CONVERSION_NEEDTODEPROVISION = 0x80049E53;
         public const uint BDK_E_INVALID_MANDATE_STATUS = 0x80049E57;
         public const uint BDK_E_PI_ALREADY_GOOD = 0x80049E61;
         public const uint BDK_E_PI_ALREADY_DECLINED = 0x80049E66;
         public const uint BDK_E_PI_IS_DISABLED = 0x80049E6B;
         public const uint BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED = 0x80049E70;
         public const uint BDK_E_INVALID_INVOICE_INFO_XML = 0x80049E71;
         public const uint BDK_E_MAX_PI_PER_ACCOUNT_REACHED = 0x8004AD81;
         public const uint BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH = 0x80049E77;
         public const uint BDK_E_ERROR_OCCURRED_TRY_LATER = 0x80049E78;
         public const uint BDK_E_ERROR_OCCURRED = 0x80049E79;
         public const uint BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80049E7F;
         public const uint BDK_E_INVALID_OFFERING_GUID = 0x80049E84;
         public const uint BDK_E_OFFERING_REQUIRES_PI = 0x80049E89;
         public const uint BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST = 0x80049E93;
         public const uint BDK_E_INVALID_AMOUNT_FOR_CURRENCY = 0x80049E99;
         public const uint BDK_E_INVALID_EMAIL_ADDRESS = 0x80049EA2;
         public const uint BDK_E_INVALID_TAX_EXEMPT_STATUS = 0x80049EAC;
         public const uint BDK_E_NO_VALID_TAX_EXEMPTION = 0x80049EAD;
         public const uint BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE = 0x80049EB1;
         public const uint BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 0x80049EB6;
         public const uint BDK_E_INVALID_START_PERIOD = 0x80049EC4;
         public const uint BDK_E_INVALID_END_PERIOD = 0x80049EC5;
         public const uint BDK_E_INVALID_DETAILEDLEVEL = 0x80049EC6;
         public const uint BDK_E_EXCEED_DATERANGE_LIMIT = 0x80049EC7;
         public const uint BDK_E_WRONG_DATERANGE = 0x80049EC8;
         public const uint BDK_E_INVALID_BEGIN_DATE = 0x80049EC9;
         public const uint BDK_E_INVALID_END_DATE = 0x80049ECB;
         public const uint BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE = 0x80049ECC;
         public const uint BDK_E_COMPUTE_ONLY = 0x80049ECA;
         public const uint BDK_E_MISSED_PROCESSING_PERIOD = 0x80049F33;
         public const uint BDK_E_SUBSCRIPTION_NOT_EXPIRED = 0x80049F43;
         public const uint BDK_E_TOOLATE_REINSTATE = 0x80049F44;
         public const uint BDK_E_EXTRA_REFERRAL_DATA = 0x80049F47;
         public const uint BDK_E_NO_REFERRAL_UPDATES_ALLOWED = 0x80049F4C;
         public const uint BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS = 0x80049F4D;
         public const uint BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS = 0x80049F4E;
         public const uint BDK_E_INVALID_COBRAND = 0x80049F56;
         public const uint BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 0x80049F65;
         public const uint BDK_E_HCI_NOT_VALID = 0x80049F83;
         public const uint BDK_E_CANT_STOP_TAIWAN_TAXINV = 0x80049F85;
         public const uint BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80049FB5;
         public const uint BDK_E_INVALID_TOKEN_TYPE = 0x8004A00A;
         public const uint BDK_E_TOKEN_NOT_VALID_FOR_OFFERING = 0x8004A04B;
         public const uint BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT = 0x8004A04C;
         public const uint BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED = 0x8004A00B;
         public const uint BDK_E_INSERTING_USER_TOKEN_HASH = 0x8004A00C;
         public const uint BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED = 0x8004A06E;
         public const uint BDK_E_TOKEN_CLASS_INVALID = 0x8004A073;
         public const uint BDK_E_INPUT_FILTER_XML_MISSING = 0x8004A074;
         public const uint BDK_E_TOKEN_CLASS_NOT_FOUND = 0x800413AB;
         public const uint BDK_E_INVALID_INPUT_FILTER_XML = 0x8004A075;
         public const uint BDK_E_PI_CANNOT_BE_SPECIFIED = 0x8004A078;
         public const uint BDK_E_SUBSCRIPTION_NOT_PREPAID = 0x8004A07D;
         public const uint BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO = 0x8004A082;
         public const uint BDK_E_INVALID_NUMBER_OF_DAYS = 0x8004A087;
         public const uint BDK_E_INVALID_NUMBER_OF_MONTHS = 0x8004A088;
         public const uint BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX = 0x8004A08C;
         public const uint BDK_E_PREPAID_TOKEN_IS_REQUIRED = 0x8004A096;
         public const uint BDK_E_TERM_COMMIT_EXISTS = 0x8004A09B;
         public const uint BDK_E_TOKEN_NOT_APPLICABLE = 0x8004A0A0;
         public const uint BDK_E_TOKEN_RENEWAL_PRESENT = 0x8004A0A5;
         public const uint BDK_E_EXCEEDS_MAXIMUM_DURATION = 0x8004A0FA;
         public const uint BDK_E_CONVERSION_CREDITS_NOT_ENABLED = 0x8004A104;
         public const uint BDK_E_INVALID_USERROLE_FOR_ADDPI = 0x8004A10E;
         public const uint BDK_E_BLACKLIST_ACTION_NOT_PERFORMED = 0x8004A0AA;
         public const uint BDK_E_INVALID_SUBSCRIPTION_ACTION = 0x8004A0AF;
         public const uint BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 0x8004A0B9;
         public const uint BDK_E_INVALID_LEN_PART_NUMBER = 0x8004A0BE;
         public const uint BDK_E_INVALID_LEN_SAP_CUST_NAME = 0x8004A0C3;
         public const uint BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME = 0x8004A0C8;
         public const uint BDK_E_INSERING_TOKEN_CLASS_PARTNER = 0x8004A0CD;
         public const uint BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 0x8004A0D2;
         public const uint BDK_E_TOKEN_ALREADY_DELIVERED = 0x8004148D;
         public const uint BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID = 0x80049DDA;
         public const uint BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE = 0x80049DDF;
         public const uint BDK_E_DISTRIBUTION_PROGRAM_INACTIVE = 0x80049DE9;
         public const uint BDK_E_INSERTING_RECONCILE_HISTORY = 0x800414BE;
         public const uint BDK_E_TOKEN_ALREADY_ISSUED = 0x800414C3;
         public const uint BDK_E_TOKEN_ALREADY_UNISSUED = 0x800414C8;
         public const uint BDK_E_TOKEN_ISSUE_UPDATE = 0x800414CD;
         public const uint BDK_E_INVALID_COMBINATION = 0x800414D2;
         public const uint BDK_E_INVALID_REPLACEMENT_REASON_CODE = 0x800414D7;
         public const uint BDK_E_MAX_REPLACEMENT_REACHED = 0x800414DC;
         public const uint BDK_E_TOKEN_REPLACEMENT_FAILED = 0x800414E1;
         public const uint BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE = 0x800414E6;
         public const uint BDK_E_SIGNATURE_TOKEN_MISMATCH = 0x800414EB;
         public const uint BDK_E_INVALID_STATUS_NAME = 0x800414F0;
         public const uint BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS = 0x800414F5;
         public const uint BDK_E_ALREADY_REPLACED_TOKEN = 0x800414FA;
         public const uint BDK_E_TOKEN_ACTION_ACCESS_DENIED = 0x800414FF;
         public const uint BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR = 0x8004A604;
         public const uint BDK_E_BAD_BEGIN_BILLING_PERIOD = 0x8004A609;
         public const uint BDK_E_INVALID_END_BILLING_PERIOD = 0x8004A60E;
         public const uint BDK_E_BILLING_PERIOD_NEGATIVE = 0x8004A613;
         public const uint BDK_E_BAD_START_END_BILLING_PERIOD = 0x8004A618;
         public const uint BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 0x8004A61D;
         public const uint BDK_E_NO_NON_NULL_PARAMS = 0x8004A622;
         public const uint BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD = 0x8004A627;
         public const uint BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 0x8004A62C;
         public const uint BDK_E_MISMATCH_SUB_ID_OFFER_GUID = 0x8004A6FE;
         public const uint BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE = 0x8004A70D;
         public const uint BDK_E_INVALID_POLICY_ID = 0x80049F88;
         public const uint BDK_E_OFFERING_PI_COUNTRY_MISMATCH = 0x80049F89;
         public const uint BDK_E_INSERT_AGREEMENT_SIGNATURE = 0x80049F8D;
         public const uint BDK_E_AGREEMENT_ALREADY_SIGNED = 0x80049F92;
         public const uint BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY = 0x80049F9C;
         public const uint BDK_E_POLICY_DEAL_VERSION_MISMATCH = 0x80049F9E;
         public const uint BDK_E_POLICY_DEAL_COUNTRY_MISMATCH = 0x80049FA1;
         public const uint BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE = 0x8004A6D1;
         public const uint BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW = 0x8004A6D6;
         public const uint BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 0x8004A6E5;
         public const uint BDK_E_INVALID_TECERTIFICATENUMBER = 0x8004A6EA;
         public const uint BDK_E_NO_WHOLESALE_TO_WHOLESALE = 0x8004A708;
         public const uint BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 0x8004A712;
         public const uint BDK_E_INVALID_RENEWAL = 0x8004A71C;
         public const uint BDK_E_ERROR_PHONE_STRING_TOOLONG = 0x8004A721;
         public const uint BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED = 0x8004A72B;
         public const uint BDK_E_LAST_ADMIN_ROLE = 0x8004C3C3;
         public const uint BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN = 0x8004C3C4;
         public const uint BDK_E_UPDATING_MEMBERNAME = 0x8004C3C8;
         public const uint BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED = 0x8004C3CD;
         public const uint BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED = 0x8004C3CE;
         public const uint PROVISION_E_MALFORMED_REQUEST = 0x8004AB7D;
         public const uint PROVISION_E_WRONG_INPUT_PARAMETERS = 0x8004AB7E;
         public const uint PROVISION_E_MPF_CALL_FAILED = 0x8004AB7F;
         public const uint PROVISION_E_XML_OPERATION_ERROR = 0x8004AB80;
         public const uint PROVISION_E_MPF_CREATE = 0x8004AB81;
         public const uint PROVISION_E_CREATION = 0x8004AB82;
         public const uint BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS = 0x8004ABA2;
         public const uint BDK_E_DBBADZIP = 0x8004ABA3;
         public const uint BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 0x8004ABA4;
         public const uint BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x8004ABA5;
         public const uint BDK_E_ACCT_ALREADY_REFERRED = 0x8004ABCE;
         public const uint BDK_E_REWARD_OFFER_NOT_PURCHASABLE = 0x8004ABDA;
         public const uint BDK_E_AGREEMENT_NOT_SIGNED = 0x8004AC79;
         public const uint BDK_E_ITEM_VIOLATION_EXISTS = 0x8004AC7A;
         public const uint BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION = 0x8004AC7B;
         public const uint BDK_E_PENDING_TRANSACTION = 0x8004AC7C;
         public const uint BDK_E_INCREMENT_TOTAL = 0x80044E39;
         public const uint BDK_E_RES_NOT_BELONG_TO_OBJECT = 0x80044E57;
         public const uint BDK_E_DECLINING_BALANCE = 0x80044E5C;
         public const uint BDK_E_DUPLICATE_TRACKING_GUID = 0x80044E75;
         public const uint BDK_E_INVALID_EXPIRATION_DATE = 0x80044EA7;
         public const uint BDK_E_UNKNOWN_MANDATE_STATUS = 0x80044EAC;
         public const uint BDK_E_INVALID_PAYMENT_METHOD_TYPE = 0x80044EB2;
         public const uint BDK_E_INVALID_CURRENCY2 = 0x80044EC0;
         public const uint BDK_E_INVALID_AMOUNT = 0x80044EFC;
         public const uint BDK_E_INVALID_BILLING_PERIOD = 0x80044F42;
         public const uint BDK_E_INVALID_ANNIV = 0x80044F9C;
         public const uint BDK_E_INVALID_LINEITEM_ID = 0x80044FF6;
         public const uint BDK_E_INVALID_EVENT_TYPE = 0x8004501E;
         public const uint BDK_E_LINE_ITEM_ID_NOT_OPEN = 0x80045046;
         public const uint BDK_E_LINEITEM_ALREADY_OFFSET = 0x8004504B;
         public const uint BDK_E_LINEITEM_ALREADY_CHARGED_BACK = 0x8004504D;
         public const uint BDK_E_INVALID_OFFSET_AMOUNT = 0x80045050;
         public const uint BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED = 0x80045055;
         public const uint BDK_E_AMOUNT_NOT_COLLECTED_YET = 0x8004505A;
         public const uint BDK_E_CANNOT_OFFSET_ZERO_AMOUNT = 0x8004505F;
         public const uint BDK_E_AMOUNT_IN_PROCESS = 0x80045064;
         public const uint BDK_E_INVALID_CREDIT_AMOUNT = 0x80045082;
         public const uint BDK_E_CREDIT_AMOUNT_OVER_LIMIT = 0x80045083;
         public const uint BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2 = 0x80045084;
         public const uint BDK_E_DUPLICATE_EVENT_ID = 0x80045091;
         public const uint BDK_E_OFFSET_IMM_SETTLE_IN_PROG = 0x8004509B;
         public const uint BDK_E_SA_IN_STATE_UNOFFSETABLE = 0x800450A5;
         public const uint BDK_E_SA_IN_STATE_UNESCHEATABLE = 0x800450A6;
         public const uint BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 0x800450AA;
         public const uint BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x800450AF;
         public const uint BDK_E_PI_IN_DECLINE = 0x800450C8;
         public const uint BDK_E_SA_IN_INTERMEDIATE_STATUS = 0x800451D1;
         public const uint BDK_E_INVALID_SETTLEMENT_AMOUNT_ID = 0x800451D6;
         public const uint BDK_E_MISMATCH_RATED_USAGE_TOTAL = 0x800451E5;
         public const uint BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 0x800451BD;
         public const uint BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 0x800451EA;
         public const uint BDK_E_REFUND_LINEITEM_NOT_SETTLED = 0x80045217;
         public const uint BDK_E_RESOURCE_BALANCE_INACTIVE = 0x80045226;
         public const uint BDK_E_INVALID_NUMBER_OF_UNITS = 0x80045235;
         public const uint BDK_E_INVALID_USAGE_CATEGORY = 0x8004523A;
         public const uint BDK_E_INSUFFICIENT_PREPAID_BALANCE = 0x8004523F;
         public const uint BDK_E_INVALID_FINANCIAL_REASON_CODE = 0x80045262;
         public const uint BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED = 0x80045267;
         public const uint BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 0x80045276;
         public const uint BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET = 0x8004527B;
         public const uint BDK_E_EVENT_ACTION_NOT_OFFSETTABLE = 0x80045280;
         public const uint BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 0x80045285;
         public const uint BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 0x8004528A;
         public const uint BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE = 0x800452AD;
         public const uint BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER = 0x800455FA;
         public const uint BDK_E_TRANSACTION_NOT_EXIST = 0x80045609;
         public const uint BDK_E_INVALID_CUMULATIVE_AMOUNT = 0x80045613;
         public const uint BDK_E_TRANSACTION_EVENT_UNKNOWN = 0x80045618;
         public const uint BDK_E_TRANSACTION_EVENT_INCONSISTENT = 0x8004561D;
         public const uint BDK_E_INVALID_SEQUENCE_NUMBER = 0x80045622;
         public const uint BDK_E_INVALID_VENDOR_TRANSACTION_ID = 0x80045627;
         public const uint BDK_E_INVALID_REJECTION_REASON_CODE = 0x8004562C;
         public const uint BDK_E_INVALID_TRANSACTION_STATUS = 0x80045659;
         public const uint BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT = 0x8004566D;
         public const uint BDK_E_UNKNOWN_MERCHANT_ID = 0x80045677;
         public const uint BDK_E_TRANSACTION_ALREADY_CANCELLED = 0x8004567C;
         public const uint BDK_E_PMN_INSERT_FAILURE = 0x800461BC;
         public const uint BDK_E_BADSAMECARDUSEDMULTIPLETIMES = 0x800461D0;
         public const uint BDK_E_PI_ALREADY_ON_ACCOUNT = 0x800461DF;
         public const uint BDK_E_PUID_ROLE_LIMIT_EXCEEDED = 0x800461E4;
         public const uint BDK_E_TOOMANY_FDE_PURCHASES = 0x800461E5;
         public const uint BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED = 0x8004620C;
         public const uint BDK_E_NOPERMISSION = 0x80042711;
         public const uint BDK_E_CANNOT_REMOVE_SELF = 0x80042712;
         public const uint BDK_E_BADXML = 0x80042713;
         public const uint BDK_E_INVALIDCOMMENTSIZE = 0x80042714;
         public const uint BDK_E_BADCANCELMODE = 0x80042715;
         public const uint BDK_E_INVALID_BUF_SIZE = 0x80042716;
         public const uint BDK_E_INVALID_ROLE = 0x80042717;
         public const uint BDK_E_INVALID_PPORT_ID = 0x80042718;
         public const uint BDK_E_INVALID_ARG = 0x8004271A;
         public const uint BDK_E_UNKNOWN_SERVER_FAILURE = 0x8004271F;
         public const uint BDK_E_INVALID_STATUS_VALUE = 0x80042720;
         public const uint BDK_E_INVALID_FILTER = 0x80042721;
         public const uint BDK_E_MISSING_CATEGORY = 0x80042722;
         public const uint BDK_E_FIELD_TOO_SHORT = 0x80042723;
         public const uint BDK_E_FIELD_TOO_LONG = 0x80042724;
         public const uint BDK_E_BADZIP = 0x80042725;
         public const uint BDK_E_ONLYONENODE = 0x80042726;
         public const uint BDK_E_INVALID_FIELD_LENGTH = 0x80042727;
         public const uint BDK_E_CSR_AUTHZ_FAILED = 0x80042728;
         public const uint BDK_E_NOT_ACCOUNT_ADMIN = 0x80042729;
         public const uint BDK_E_DELEGATE_ID_UNSPECIFIED = 0x8004272A;
         public const uint BDK_E_REQUESTER_ID_UNSPECIFIED = 0x8004272B;
         public const uint BDK_E_INVALID_FLAG_VALUE = 0x8004272C;
         public const uint BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION = 0x8004272D;
         public const uint BDK_E_INVALID_OBJECT_ID = 0x8004272E;
         public const uint BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH = 0x8004272F;
         public const uint BDK_E_INVALID_LASTNAME_FIELD_LENGTH = 0x80042730;
         public const uint BDK_E_INVALID_ADDRESS_FIELD_LENGTH = 0x80042731;
         public const uint BDK_E_PARTNERNOTINBILLING = 0x80042738;
         public const uint BDK_E_RATING_FAILURE = 0x8004273D;
         public const uint BDK_SVR2_STARTED = 0x80042742;
         public const uint BDK_CSR_API_CALL_MADE = 0x80042743;
         public const uint BDK_E_CSR_CALL_FROM_NONCSR = 0x80042744;
         public const uint BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS = 0x8004274C;
         public const uint BDK_E_TRANS_BALANCE_TO_PI_INVALID = 0x80042751;
         public const uint BDK_E_TRANS_BALANCE_TO_SAME_PI = 0x80042756;
         public const uint BDK_E_TRANS_BALANCE_NOT_ALLOW = 0x8004275B;
         public const uint BDK_E_INTERNAL_ERROR = 0x80042760;
         public const uint BDK_E_OUTSTANDING_BALANCE = 0x80042765;
         public const uint BDK_E_INVALID_REFERRALDATA_XML = 0x8004276A;
         public const uint BDK_E_INVALID_GUID = 0x8004276F;
         public const uint E_UNSUPPORTED_PAYMENT_INSTRUMENT = 0x80042774;
         public const uint BDK_E_SUBSCRIPTION_INACTIVE = 0x80042779;
         public const uint BDK_E_INVALID_PM_FOR_STOP_PAYMENTS = 0x8004277E;
         public const uint BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 0x80042783;
         public const uint BDK_E_FIELD_NOT_UPDATEABLE = 0x80042788;
         public const uint BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 0x8004278D;
         public const uint BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT = 0x8004278E;
         public const uint BDK_E_PAYMENT_METHOD_NO_LONGER_VALID = 0x8004278F;
         public const uint BDK_E_PROCESS_USAGE_EVENTS = 0x80042790;
         public const uint BDK_E_WRONG_OBJECT_ID_TYPE = 0x80042791;
         public const uint BDK_E_INVALID_PHONE_VALUE = 0x80042792;
         public const uint BDK_E_INVALID_AMOUNT_VALUE = 0x80042797;
         public const uint BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE = 0x80042793;
         public const uint BDK_E_INTERNAL_ADD_COMMENT_FAILED = 0x80042794;
         public const uint BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE = 0x80042795;
         public const uint BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS = 0x8004279C;
         public const uint BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE = 0x800427A6;
         public const uint BDK_E_INVALID_TELENUMERIC_STRING = 0x800427B0;
         public const uint BDK_E_NO_MATCH = 0x800427BA;
         public const uint BDK_E_MULTIPLE_MATCHES = 0x800427C4;
         public const uint BDK_E_BAD_PUID = 0x800427CE;
         public const uint BDK_E_BAD_OBJECT_ID_LENGTH = 0x800427D9;
         public const uint BDK_E_END_PERIOD_LESS_THAN_START_PERIOD = 0x800427DA;
         public const uint BDK_E_BAD_BILLING_PERIOD_LENGTH = 0x800427DB;
         public const uint BDK_E_BAD_RETURN_STATEMENT_SET = 0x800427DC;
         public const uint BDK_E_INVALID_USAGE_EVENT_DATE = 0x800427DF;
         public const uint BDK_E_NULL_DEFAULT_BILLING_PERIOD = 0x800427E0;
         public const uint BDK_E_BAD_START_BILLING_PERIOD = 0x800427E1;
         public const uint BDK_E_BAD_END_BILLING_PERIOD = 0x800427E2;
         public const uint BDK_E_NEW_DUE_DATE_IS_PAST = 0x800427E7;
         public const uint BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED = 0x800427EC;
         public const uint BDK_E_NO_NEW_DUE_DATE_SPECIFIED = 0x800427F1;
         public const uint BDK_E_INVALID_TRANSACTION_TYPE = 0x800427F6;
         public const uint BDK_E_INVALID_REASON_CODE = 0x800427FB;
         public const uint BDK_E_GROUP_SID_INITIALIZATION_FAILED = 0x8004280B;
         public const uint BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI = 0x8004280C;
         public const uint BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT = 0x8004280D;
         public const uint BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT = 0x8004280E;
         public const uint BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 0x8004280F;
         public const uint BDK_E_FAILED_TO_CREATE_MAIL_RECORD = 0x80042810;
         public const uint BDK_E_MSNIA_LATE_USAGE = 0x80042811;
         public const uint BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB = 0x80042812;
         public const uint BDK_E_INVALID_REFERRAL_OFFER = 0x8004ABCC;
         public const uint BDK_E_REWARD_REFERRAL_XML_REQUIRED = 0x80042813;
         public const uint BDK_E_REFERRER_NOT_IN_SYSTEM = 0x80042814;
         public const uint BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 0x80042815;
         public const uint BDK_E_REFERRER_NOT_ACTIVE = 0x80042816;
         public const uint BDK_E_CANNOT_REFER_SELF = 0x80042817;
         public const uint BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 0x80042818;
         public const uint BDK_E_INVALID_REWARD_REFFERAL_SCHEMA = 0x80042819;
         public const uint BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 0x8004281A;
         public const uint BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 0x8004281B;
         public const uint BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED = 0x8004281C;
         public const uint BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM = 0x8004281D;
         public const uint BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 0x8004281E;
         public const uint BDK_E_REPORT_USAGE_WITH_PREPAID = 0x8004281F;
         public const uint BDK_E_NO_USAGE_EVENT_REPORTED = 0x80042820;
         public const uint BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 0x80042821;
         public const uint BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 0x80042822;
         public const uint BDK_E_INVALID_REDIRECT_INPUTINFO_XML = 0x80042823;
         public const uint BDK_E_TRANSACTION_NOT_CANCELLABLE = 0x80042824;
         public const uint BDK_E_NO_CDS_FOUND = 0x80042825;
         public const uint BDK_E_INVALID_CHARGE_DESCRIPTOR = 0x80042826;
         public const uint BDK_E_INVALID_WHOLESALEPI = 0x800428A0;
         public const uint BDK_E_NOT_BOBOPARTNER = 0x800428A1;
         public const uint BDK_E_INVALID_BOBOPARTNER = 0x800428A2;
         public const uint BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE = 0x800428FA;
         public const uint BDK_E_ENTITLEMENT_VALIDATION_FAILED = 0x800428FB;
         public const uint BDK_E_INVALID_ENTITLEMENT_ENDPOINT = 0x800428FC;
         public const uint BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT = 0x80049D57;
         public const uint BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF = 0x80042828;
         public const uint BDK_E_TAXWARE_FAILURE = 0x8004EA60;
         public const uint BDK_E_ADDRESS_VALIDATION_FAILURE = 0x8004EA61;
         public const uint BDK_E_ZIP_INVALID = 0x8004EA6B;
         public const uint BDK_E_STATE_INVALID = 0x8004EA6C;
         public const uint BDK_E_ZIP_CITY_MISSING = 0x8004EA6D;
         public const uint BDK_E_STATE_ZIP_INVALID = 0x8004EA6E;
         public const uint BDK_E_STATE_CITY_INVALID = 0x8004EA6F;
         public const uint BDK_E_STATE_ZIP_CITY_INVALID = 0x8004EA70;
         public const uint BDK_E_STATE_ZIP_CITY_INVALID2 = 0x8004EA71;
         public const uint BDK_E_STATE_ZIP_CITY_INVALID3 = 0x8004EA72;
         public const uint BDK_E_STATE_ZIP_CITY_INVALID4 = 0x8004EA73;
         public const uint BDK_E_MULTIPLE_COUNTIES_FOUND = 0x8004EA7D;
         public const uint BDK_E_ZIP_INVALID_FOR_ENTERED_STATE = 0x8004EA7E;
         public const uint BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES = 0x8004EA89;
         public const uint BDK_E_MULTIPLE_CITIES_FOUND = 0x8004EA8A;
         public const uint BDK_E_BAD_CITYNAME_LENGTH = 0x8004EA8B;
         public const uint BDK_E_BAD_COUNTRYCODE_LENGTH = 0x8004EA8C;
         public const uint BDK_E_BAD_STATECODE_LENGTH = 0x8004EA8D;
         public const uint BDK_E_BAD_ZIPCODE_LENGTH = 0x8004EA8E;
         public const uint BDK_E_BAD_PRODUCTCODE_LENGTH = 0x8004EA8F;
         public const uint BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH = 0x8004EA90;
         public const uint BDK_E_BAD_TRANSACTIONDATE_LENGTH = 0x8004EA91;
         public const uint BDK_E_BAD_VATREGISTRATION_LENGTH = 0x8004EA92;
         public const uint BDK_E_BAD_CURRENCYCODE_LENGTH = 0x8004EA93;
         public const uint BDK_E_BAD_WTCODE_LENGTH = 0x8004EA94;
         public const uint BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 0x8004EA95;
         public const uint BDK_E_INVALID_VATID_FORMAT = 0x8004EA97;
         public const uint BDK_E_INVALID_VATID_INVALID = 0x8004EA98;
         public const uint BDK_E_UNSUPPORTED_CHAR_EXIST = 0x8004EA9C;
         public const uint BDK_E_ERROR_COUNTRYCODE_MISMATCH = 0x8004EAA1;
         public const uint BDK_E_ERROR_COUNTRYCODE_REQUIRED = 0x8004EAA6;
         public const uint BDK_E_INVALID_TOKEN_SPECIFIED = 0x8004138D;
         public const uint BDK_E_TOKEN_ALREADY_BLACKLISTED = 0x80041392;
         public const uint BDK_E_TOKEN_ALREADY_UNBLACKLISTED = 0x80041393;
         public const uint BDK_E_TOKEN_BLACKLISTED = 0x800413BF;
         public const uint BDK_E_TOKEN_RANGE_BLACKLISTED = 0x800413C4;
         public const uint BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x800413C9;
         public const uint BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL = 0x800413CE;
         public const uint BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 0x800413CF;
         public const uint BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 0x800413D3;
         public const uint BDK_E_TOKEN_EXPIRED = 0x800413F1;
         public const uint BDK_E_TOKEN_NOT_STARTED = 0x800413F6;
         public const uint BDK_E_TOKEN_RANGE_NOT_ACTIVE = 0x800413FB;
         public const uint BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE = 0x8004141E;
         public const uint BDK_E_TRACKING_GUID_NODATA = 0x8004145A;
         public const uint BDK_E_DUPLICATE_TOKEN_TRACKING_GUID = 0x8004145F;
         public const uint BDK_E_ALREADY_ACTIVATED = 0x8004146E;
         public const uint BDK_E_INVALID_COMMITTED_STATUS = 0x80041470;
         public const uint BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 0x80041473;
         public const uint BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 0x80041478;
         public const uint BDK_E_TOKEN_CONSUMED = 0x8004147D;
         public const uint BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 0x80041482;
         public const uint BDK_E_INVALID_EXTERNAL_REFERENCE_ID = 0x80041483;
         public const uint BDK_E_TOKEN_ALREADY_DEACTIVATED = 0x80041487;
         public const uint BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH = 0x80041491;
         public const uint ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID = 0x80041496;
         public const uint BDK_E_INVALID_BOOKMARK = 0x80041484;
         public const uint BDK_E_INVALID_MAX = 0x80041485;
         public const uint BDK_E_INTERNAL_ERROR_TOKEN = 0x80041455;
         public const uint BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 0x8004CD14;
         public const uint BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 0x8004CD46;
         public const uint BDK_E_CANCELREFUND_OFFSET_OF_OFFSET = 0x8004CD78;
         public const uint BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 0x8004CDAA;
         public const uint BDK_E_INVALID_SESSION_KEY = 0x8004768E;
         public const uint BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID = 0x8004A0B4;
         public const uint BDK_E_PRODUCT_KEY_NOT_AVAILABLE = 0x80041488;
         public const uint BDK_E_PIN_OR_SEQ_REQUIRED = 0x80041489;
         public const uint BDK_E_INPUT_PARAM_MALFORMED = 0x8004148A;
         public const uint BDK_E_INVALID_ADJUSTMENT_OFFSET = 0x8004CDB7;
         public const uint BDK_E_INVALID_ITEM_INSTANCE_ID = 0x8004CDDC;
         public const uint BDK_E_INVALID_REVERSE_REASON = 0x8004CDDD;
         public const uint BDK_E_TOO_MANY_ITEMS_IN_PURCHASE = 0x8004CDE0;
         public const uint BDK_E_INVALID_OFFERING_TYPE = 0x8004CDE1;
         public const uint BDK_E_PRICE_IS_NEGATIVE = 0x8004CDE2;
         public const uint BDK_E_DYNAMIC_PRICE_CONFIGURATION = 0x8004CDE3;
         public const uint BDK_E_DMP_MAX_BALANCE_EXCEEDED = 0x8004CDE4;
         public const uint BDK_E_CURRENCY_MISSING = 0x8004CDE5;
         public const uint BDK_E_PENDING_ITEM_PURCHASE = 0x8004CDE6;
         public const uint BDK_E_DMP_FLOW_NOT_ENABLED = 0x8004CDE7;
         public const uint BDK_E_ITEM_ALREADY_REVERSED = 0x8004CDE8;
         public const uint BDK_E_ITEM_NOT_FULFILLED = 0x8004CDE9;
         public const uint BDK_E_DMP_UNKNOWN_ERROR = 0x8004CDEA;
         public const uint BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE = 0x8004CDEC;
         public const uint BDK_E_INVALID_CANCEL_TRANSACTION_RESULT = 0x8004CDED;
         public const uint BDK_E_CVM_MISSING = 0x8004CDEE;
         public const uint BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL = 0x8004CDEF;
         public const uint BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH = 0x8004CDF0;
         public const uint BDK_E_DONOR_BENEFICIARY_SAME = 0x8004CDF1;
         public const uint BDK_E_RENEWAL_DOES_NOT_EXISTS = 0x8004AC9A;
         public const uint BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS = 0x8004AC9C;
         public const uint BDK_E_INVALID_DISCOUNT = 0x8004ACAD;
         public const uint BDK_E_INSERT_DISCOUNT = 0x8004ACB2;
         public const uint BDK_E_DISCOUNT_ALREADY_APPLIED = 0x8004ACB7;
         public const uint BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN = 0x8004ACBC;
         public const uint BDK_E_DISCOUNT_TOKEN = 0x8004ACC1;
         public const uint BDK_E_INSERT_DISCOUNT_LOCALIZE = 0x8004ACC6;
         public const uint BDK_E_DISCOUNT_USAGE_EXCEEDED = 0x8004ACCB;
         public const uint BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH = 0x8004ACD0;
         public const uint BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER = 0x8004AD18;
         public const uint BDK_E_NULL_CATEGORY = 0x8004AC62;
         public const uint BDK_E_NULL_ACCOUNTID = 0x8004AC63;
         public const uint BDK_E_NULL_SUBSCRIPTIONREFID = 0x8004AC64;
         public const uint BDK_E_INVALID_SURVEYRESULTCODE = 0x8004AC65;
         public const uint BDK_E_CD_NOTFOUND = 0x8004AC66;
         public const uint BDK_E_INVALID_ACCOUNTID = 0x8004AC67;
         public const uint BDK_E_INVALID_ANONYMOUS_INFO_XML = 0x8004AC68;
         public const uint BDK_E_UNSUPPORTED_OBJECT_TYPE = 0x8004AC69;
         public const uint BDK_E_INVALID_PHONE_XML = 0x8004AC6A;
         public const uint BDK_E_INVALID_REQUESTOR_INFO = 0x8004AC6C;
         public const uint BDK_E_PENDING_TRANSACTIONS = 0x8004ACAA;
         public const uint BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH = 0x800452D0;
         public const uint BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS = 0x800452D5;
         public const uint BDK_E_PARTIAL_CHAREGBACK = 0x800452D8;
         public const uint BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL = 0x800452DA;
         public const uint BDK_E_INVALID_CHARGEBACK_DATE = 0x800452E9;
         public const uint BDK_E_INVALID_CHARGEBACK_AMOUNT = 0x800452EE;
         public const uint BDK_E_ALREADY_OFFSET_TAX = 0x800452F1;
         public const uint BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED = 0x80049CEB;
         public const uint BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT = 0x8004CE4F;
         public const uint BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT = 0x8004CE50;
         public const uint BDK_E_ZERO_ADDRESSES_BY_MAPPOINT = 0x8004CE51;
         public const uint BDK_E_UNKNOWN_ERROR = 0x8004CE52;
         public const uint BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR = 0x8004ACA4;
         public const uint BDK_E_INVALID_ADDRESSINFOXML = 0x8004CE54;
         public const uint BDK_E_POST_BOX_ERROR_MAPPOINT = 0x8004CE55;
         public const uint BDK_E_MAPPOINT_CONNECTION_MAPPOINT = 0x8004CE56;
         public const uint BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS = 0x8004D818;
         public const uint BDK_E_CHARGEBACK_NOT_FOUND = 0x8004D81D;
         public const uint BDK_E_CHARGEBACK_NOT_MATCH = 0x8004D827;
         public const uint BDK_E_DOUBLE_CHARGEBACK = 0x8004D836;
         public const uint BDK_E_INVALID_CHARGEBACK_LINEITEM_ID = 0x8004D83B;
         public const uint BDK_E_INVALID_CHARGEBACK_REVERSAL_ID = 0x8004D84A;
         public const uint BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID = 0x8004D84F;
         public const uint BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID = 0x8004D854;
         public const uint BDK_E_INVALID_LINEITEM_TYPE = 0x8004D859;
         public const uint BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL = 0x8004D868;
         public const uint BDK_E_COUNTRY_NOT_SUPPORTED = 0x8004ACA5;
         public const uint BDK_E_COUNTRY_MAPPOINT_DISABLED = 0x8004ACA6;
         public const uint BDK_E_INVALID_PARAMETER = 0x8004ACA7;
         public const uint BDK_E_INVALID_CHARGEBACK_ID = 0x8004283C;
         public const uint BDK_E_CHARGEBACK_PROCESSING_FAILURE = 0x8004283D;
         public const uint BDK_E_INVALID_MERCHANT_REFERENCE = 0x8004283E;
         public const uint BDK_E_CHARGEBACK_INFO_MISSING = 0x8004283F;
         public const uint BDK_E_RECORD_CHARGEBACK_FAILED = 0x80042840;
         public const uint BDK_E_DOUBLE_CHARGEBACK_REVERSAL = 0x80042841;
         public const uint BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK = 0x80042842;
         public const uint BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION = 0x80042843;
         public const uint BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED = 0x80042844;
         public const uint BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING = 0x80042845;
         public const uint BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER = 0x80042846;
         public const uint BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL = 0x80042847;
         public const uint BDK_E_PROFILE_ALREADY_EXISTS = 0x80042848;
         public const uint BDK_E_PROFILE_DOES_NOT_EXIST = 0x80042849;
         public const uint BDK_E_ACCOUNT_WITHOUT_ADDRESS = 0x8004284A;
         public const uint BDK_E_NO_PAYOUT_PREFERENCE = 0x8004284B;
         public const uint BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE = 0x8004284C;
         public const uint BDK_E_INVALID_PAYUSERINFOXML = 0x8004284D;
         public const uint BDK_E_INVALID_USERPROFILEXML = 0x8004284E;
         public const uint BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID = 0x8004284F;
         public const uint BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED = 0x80042850;
         public const uint BDK_E_RIME_REJECTED = 0x80042851;
         public const uint BDK_E_RIME_INVALID_VALUE = 0x80042852;
         public const uint BDK_E_REFERRAL_CODE_NOT_FOUND = 0x8004AC59;
         public const uint ERROR_MISSING_PROV_INFO = 0x8004D2FD;
         public const uint BDK_E_INVALID_RESOURCE_TYPE = 0x8004AC5A;
         public const uint BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED = 0x80044E2A;
         public const uint BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED = 0x80044E2B;
         public const uint BDK_E_ENCRYPTION_FAILURE = 0x80044E2C;
         public const uint BDK_E_DMP_FIRST = 0x8004FA00;
         public const uint BDK_E_DMP_LAST = 0x8004FDE7;
         public const uint BDK_E_INVALID_TARGET_USER_INFORMATION = 0x80047918;
         public const uint BDK_E_INVALID_DELEGATE_USER_INFORMATION = 0x80047919;
         public const uint BDK_E_INVALID_SOURCE_USER_INFORMATION = 0x8004791A;
         public const uint BDK_E_INVALID_TRANSACTION_INFORMATION = 0x8004791B;
         public const uint BDK_E_NO_MATCHING_TRANSACTION = 0x8004791C;
         public const uint BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION = 0x8004791D;
         public const uint BDK_E_NO_MATCHING_PENDING_TRANSACTION = 0x8004791E;
         public const uint BDK_E_ORDER_LAYER_FIRST = 0x8004DAC1;
         public const uint BDK_E_ORDER_LAYER_LAST = 0x8004DEA8;
         public const uint BDK_E_TRANSACTION_LAYER_FIRST = 0x8004DEA9;
         public const uint BDK_E_TRANSACTION_LAYER_LAST = 0x8004E290;
         public const uint SCS_E_CERT_INAVLID = 0x8004E678;
         public const uint SCS_E_INAVLID_CALLING_PARTNER = 0x8004E679;
         public const uint BDK_E_RISK_EVALUATION_FAILED = 0x8004FDE9;
         public const uint BDK_E_RISK_EVALUATION_EXCEPTION = 0x8004FDEA;
         public const uint BDK_E_RISK_EVALUATION_UNDEFINED = 0x8004FDEB;
         public const uint BDK_E_RISK_CONFIGURATION_ERROR = 0x8004FDEC;
         public const uint BDK_E_RISK_NEXT = 0x8004FDED;
         public const uint BDK_E_DAV_APARTMENT = 0x8004FE4C;
         public const uint BDK_E_DAV_INSUFFICIENT = 0x8004FE4D;
         public const uint BDK_E_DAV_ID = 0x8004FE4E;
         public const uint BDK_E_DAV_MULTIPLE = 0x8004FE4F;
         public const uint BDK_E_DAV_POBOX = 0x8004FE50;
         public const uint BDK_E_DAV_ROUTE = 0x8004FE51;
         public const uint BDK_E_DAV_STREET = 0x8004FE52;
         public const uint BDK_E_DAV_POSTAL = 0x8004FE53;
         public const uint BDK_E_DAV_GENERAL = 0x8004FE54;
         public const uint BDK_E_DAV_MISSING_DATA = 0x8004FE55;
         public const uint BDK_E_DAV_INVALID_DATA = 0x8004FE56;
         public const uint BDK_E_DAV_SYSTEM_FAILURE = 0x8004FE57;
         public const uint BDK_E_DAV_TIMEOUT = 0x8004FE58;
         public const uint BDK_E_DAV_DISABLED = 0x8004FE59;
         public const uint BDK_E_RISK_LAST = 0x8004FFFF;
         public const uint BDK_E_RISK_CVV_E_REENTRY_REQUIRED = 0x8004FDF0;
         public const uint BDK_E_RISK_CVV_E_REENTRY_FAILED_RETRYABLE = 0x8004FDF1;
         public const uint BDK_E_RISK_CVV_E_REENTRY_FAILED_NONRETRYABLE = 0x8004FDF2;
     

        public static void InitializeErrorDetails()
        {
            SetErrorDetail(BDK_E_BAN_NULL_INPUT_PARAMETER, "Null input parameter passed to a \"ban\" API.", false, 0x80167594);
            SetErrorDetail(BDK_E_ALREADY_BANNED, "Already banned.", false, 0x80167599);
            SetErrorDetail(BDK_E_NOT_BANNED, "Not banned.", false, 0x8016759E);
            SetErrorDetail(BDK_E_BANNEDPERSON, "This account is banned.", false, 0x801675BC);
            SetErrorDetail(BDK_E_COUNTRY_CURRENCY_PI_MISMATCH, "Country/currency/payment instrument type mismatch.", false, 0x801675C1);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE, "Invalid payment instrument type.", false, 0x801675C8);
            SetErrorDetail(BDK_E_INVALID_CREDIT_CARD_TYPE, "Invalid credit card type.", false, 0x801675CB);
            SetErrorDetail(BDK_E_DECRYPTION_FAILURE, "Decryption failed. Verify that data is encrypted correctly.", true, 0x801675D0);
            SetErrorDetail(BDK_E_BANNED_PAYMENT_INSTRUMENT, "Payment instrument is banned.", false, 0x801675C6);
            SetErrorDetail(BDK_E_INVALID_DD_ACCOUNT, "Direct debit account validation failed.", false, 0x801675E4);
            SetErrorDetail(BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24, "Concatenated direct debit account number exceeds 24 characters.", false, 0x801675E9);
            SetErrorDetail(BDK_E_INVALID_CREDIT_CARD_NUMBER, "Invalid credit card number.", false, 0x80167530);
            SetErrorDetail(BDK_E_CREDIT_CARD_EXPIRED, "Credit card has already expired.", false, 0x80167531);
            SetErrorDetail(BDK_E_AVS_FAILED, "Address verification failed.", false, 0x8016760C);
            SetErrorDetail(BDK_E_NO_AVS_RESULT, "Address verification through AVS did not provide a result.", false, 0x8016760D);
            SetErrorDetail(BDK_E_AUTHORIZATION_FAILED, "Payment Instrument authorization failed.", false, 0x80167611);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED, "Unable to connect to payment provider.", true, 0x8016761B);
            SetErrorDetail(BDK_E_DD_INVALID_COUNTRY, "Invalid country code.", false, 0x8016762F);
            SetErrorDetail(BDK_E_DD_INVALID_ACCOUNT_FORMAT, "Invalid account format.", false, 0x80167634);
            SetErrorDetail(BDK_E_DD_INVALID_BANKCODE_FORMAT, "Invalid bank code format.", false, 0x80167639);
            SetErrorDetail(BDK_E_DD_INVALID_BRANCHCODE_FORMAT, "Invalid branch code format.", false, 0x8016763E);
            SetErrorDetail(BDK_E_DD_INVALID_CHECKDIGIT_FORMAT, "Invalid check digit format.", false, 0x80167643);
            SetErrorDetail(BDK_E_DD_ACCOUNT_MISSING, "Account missing.", false, 0x80167648);
            SetErrorDetail(BDK_E_DD_BANKCODE_MISSING, "Bank code missing.", false, 0x8016764D);
            SetErrorDetail(BDK_E_DD_BRANCHCODE_MISSING, "Branch code missing.", false, 0x80167652);
            SetErrorDetail(BDK_E_DD_CHECKDIGIT_MISSING, "Check digit missing.", false, 0x80167657);
            SetErrorDetail(BDK_E_DD_ERROR_IN_FIELDS, "Some fields have errors.", false, 0x8016765C);
            SetErrorDetail(BDK_E_DD_INVALID_ACCOUNT_VALUE, "Invalid account code.", false, 0x80167661);
            SetErrorDetail(BDK_E_DD_INVALID_BANKCODE_VALUE, "Invalid bank code.", false, 0x80167666);
            SetErrorDetail(BDK_E_DD_INVALID_BRANCHCODE_VALUE, "Invalid branch code.", false, 0x8016766B);
            SetErrorDetail(BDK_E_DD_INVALID_CHECKDIGIT_VALUE, "Invalid check digit.", false, 0x80167670);
            SetErrorDetail(BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME, "Account holder name not specified or it exceeds 35 characters.", false, 0x8016767A);
            SetErrorDetail(BDK_E_DD_UNKNOWN_PROVIDER_FAILURE, "Soap call to provider failed.", false, 0x8016771F);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT, "Payment provider connection timed out.", true, 0x8016767F);
            SetErrorDetail(BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER, "Transaction declined by payment provider.", true, 0x80167680);
            SetErrorDetail(BDK_E_INVALID_INITIATE_TRANSACTION_RESULT, "Payment provider error.", true, 0x80167681);
            SetErrorDetail(BDK_E_INVALID_WHOLESALE_PARTNER, "The wholesale partner specified is invalid.", false, 0x80167684);
            SetErrorDetail(BDK_E_PI_NOT_SUPPORTED, "PI Not Supported in this version", false, 0x80167693);
            SetErrorDetail(BDK_E_UPS_NOT_UPDATED, "A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.", false, 0x8016769D);
            SetErrorDetail(BDK_E_DD_UNSUPPORTED, "This branch will not support Direct Debit transactions.", false, 0x801676A2);
            SetErrorDetail(BDK_E_DD_MPF_NON_XML_RESPONSE, "Internal error, Return from MPF is not in XML format.", false, 0x801676A7);
            SetErrorDetail(BDK_E_DD_MPF_INCORRECT_XML_FORMAT, "Internal error, Return XML from MPF is not in correct format.", false, 0x801676AC);
            SetErrorDetail(BDK_E_DD_GC_NON_XML_RESPONSE, "Global Collect error, Return from Global Collect is not in XML format.", false, 0x801676B1);
            SetErrorDetail(BDK_E_DD_GC_INCORRECT_XML_FORMAT, "Global Collect error, Return XML from Global Collect is not in correct format.", false, 0x801676B6);
            SetErrorDetail(BDK_E_DD_GC_RETURNED_NOK_RESULT, "Global collect failed to process this request, returned NOT OK result.", true, 0x801676BB);
            SetErrorDetail(BDK_E_DD_GC_CHECK_INCOMPLETE, "Direct Debit account Check performed by Global Collect is not complete for this account.", false, 0x801676C0);
            SetErrorDetail(BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED, "Global Collect error, Return XML from Global Collect is not in correct format. Error in CHECKSPERFORMED node of the return XML.", false, 0x801676C5);
            SetErrorDetail(BDK_E_DD_GC_XML_INVALID_CHECK_RESULT, "Global Collect error, Return XML from Global Collect is not in correct format. Data within CHECKSPERFORMED nodes are invalid.", false, 0x801676CA);
            SetErrorDetail(BDK_E_DD_GC_INVALID_RFBANKCODE, "Global collect returned non null Reformatted Bank Code though the input Bank code was blank.", false, 0x801676CF);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS, "Invalid payment instrument details.", false, 0x801676D9);
            SetErrorDetail(BDK_E_INVALID_BAN_REASON_CODE, "Invalid ban reason code.", false, 0x801676DE);
            SetErrorDetail(BDK_E_INVALID_CVM_CODE, "Invalid encrypted CVM code.", false, 0x801676E3);
            SetErrorDetail(BDK_E_UNEXPECTED_CVM_RESPONSE_CODE, "Unexpected CVM response code.", false, 0x801676E8);
            SetErrorDetail(BDK_E_CVM_FAILED, "CVM check failed.", false, 0x801676ED);
            SetErrorDetail(BDK_E_IMMEDIATE_SETTLEMENT_FAILURE, "Immediate settlement failed", false, 0x801676EE);
            SetErrorDetail(BDK_E_FREQUENCY_CHECK_FAILED, "Frequency check failed.", false, 0x801676F2);
            SetErrorDetail(BDK_E_DD_INVALID_MERCHANT_INDEX, "Invalid merchant index.", false, 0x801676F7);
            SetErrorDetail(BDK_E_DD_DUPLICATE_MRN, "Duplicate merchant reference.", false, 0x801676FC);
            SetErrorDetail(BDK_E_DD_UNKNOWN_VALIDATION_FAILURE, "Account validation failed.", false, 0x80167701);
            SetErrorDetail(BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL, "Bank account type may not be specified for this country.", false, 0x80167706);
            SetErrorDetail(BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL, "Bank account type is required for this country.", false, 0x8016770B);
            SetErrorDetail(BDK_E_DD_RISK_DECLINE, "Risk check failed.", false, 0x80167715);
            SetErrorDetail(BDK_E_UNABLE_TO_VALIDATE_TAX_ID, "Unable to validate the tax ID.", false, 0x80167724);
            SetErrorDetail(BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED, "Number of updates allowed in a period has exceeded the maximum limit.", false, 0x80167729);
            SetErrorDetail(BDK_E_EXTERNAL_VENDOR_ERROR, "External vendor error.", true, 0x8016772E);
            SetErrorDetail(BDK_E_ALREADY_IN_SPECIFIED_STATE, "Object is already in the specified state.", false, 0x80169C41);
            SetErrorDetail(BDK_E_MISSING_SEARCH_CRITERIA, "Required search criteria field missing. Either a phone number or both first name and last name is required.", false, 0x80169C44);
            SetErrorDetail(BDK_E_REQUIRED_FIELD_MISSING, "Required field missing.", false, 0x80169C45);
            SetErrorDetail(BDK_E_ACTIVE_SUBSCRIPTIONS, "The account has subscriptions.", false, 0x80169C46);
            SetErrorDetail(BDK_E_UNEXPECTED_FIELD, "Unexpected field", false, 0x80169C47);
            SetErrorDetail(BDK_E_INVALID_ACCOUNT_SOUCE, "Invalid account source.", false, 0x80169C4D);
            SetErrorDetail(BDK_E_INVALID_CREATION_DATE, "Creation date/time cannot be later than current date/time.", false, 0x80169C4E);
            SetErrorDetail(BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS, "No more tax exemptions are allowed for this account.", false, 0x80169C55);
            SetErrorDetail(BDK_E_GENERATE_NEXT_ID, "Generating next ID.", false, 0x80169C59);
            SetErrorDetail(BDK_E_INVALID_STATE_FOR_COUNTRY, "State invalid for the country.", false, 0x80169C5F);
            SetErrorDetail(BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH, "Country for address provided does not match existing country for account.", false, 0x80169C61);
            SetErrorDetail(BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH, "The offering requested is not available in the country of this account.", false, 0x80169C62);
            SetErrorDetail(BDK_E_INVALID_BILLABLE_ACCOUNT_ID, "Invalid account.", false, 0x80169CC2);
            SetErrorDetail(BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID, "Invalid account status.", false, 0x80169CC7);
            SetErrorDetail(BDK_E_INVALID_PHONE_TYPE, "Invalid phone type.", false, 0x80169CD6);
            SetErrorDetail(BDK_E_INVALID_OFFERING_ID, "Invalid offering.", false, 0x80169CE5);
            SetErrorDetail(BDK_E_INVALID_PURCHASE_INPUT_DATA, "The combination of data passed to PurchaseOffering is invalid for the scenario.", false, 0x80169CE6);
            SetErrorDetail(BDK_E_PUID_MISSING_ATTRIBUTE, "UPS profile is missing either FirstName, LastName, Country or PMN", false, 0x80169CE7);
            SetErrorDetail(BDK_E_INVALID_COUNTRY_CODE, "Invalid country code.", false, 0x80169CEA);
            SetErrorDetail(BDK_E_INVALID_ADDRESS_ID, "Invalid address ID.", false, 0x80169CEF);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_METHOD_ID, "Invalid payment instrument ID.", false, 0x80169CF9);
            SetErrorDetail(BDK_E_PI_EXECEED_MAX_OWNER_SHIP, "Cannot exceed max ownership for the payment instrument.", false, 0x80169D03);
            SetErrorDetail(BDK_E_SUBSCRIPTION_ALREADY_CANCELED, "Subscription is already cancelled.", false, 0x80169D08);
            SetErrorDetail(BDK_E_DELAYED_EXPIRE_ALREADY_PENDING, "A delayed expire request is already pending and should not be requested again.", false, 0x80169D0A);
            SetErrorDetail(BDK_E_DELAYED_EXPIRE_NOT_PENDING, "A delayed expire is not pending and cannot be undone.", false, 0x80169D0B);
            SetErrorDetail(BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED, "A delayed expire is not support unless the subscription is active with no term commits.", false, 0x80169D0C);
            SetErrorDetail(BDK_E_INVALID_CANCEL_DATE, "The value specified for the cancel option/date should be DELAYED_EXPIRE, UNDO_DELAYED_EXPIRE, IMMEDIATE_EXPIRE or IMMEDIATE_CANCEL.", false, 0x80169D09);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_ID, "Invalid subscription ID.", false, 0x80169D0D);
            SetErrorDetail(BDK_E_INVALID_PERIOD_TO_PROCESS, "Invalid period.", false, 0x80169D2B);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_STATUS, "Invalid subscription status or invalid operation for the status.", false, 0x80169D3A);
            SetErrorDetail(BDK_E_NON_ACTIVE_ACCOUNT, "Account is inactive.", false, 0x80169D94);
            SetErrorDetail(BDK_E_VATID_DOESNOTHAVEEXPDATE, "VATIDs do not have an expiration date.", false, 0x80169D95);
            SetErrorDetail(BDK_E_TAXID_EXPDATE, "Expiration date was not specified.", false, 0x80169D96);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_TYPE, "Invalid tax exemption type.", false, 0x80169D97);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID, "Invalid Tax Exempt Billable Account Id specified.", false, 0x80169D98);
            SetErrorDetail(BDK_E_NO_ACTIVE_SUBSCRIPTION, "No active subscription for adding a service instance.", false, 0x80169D99);
            SetErrorDetail(BDK_E_INVALID_SERVICE_INSTANCE, "Invalid service instance for adding a new user.", false, 0x80169D9E);
            SetErrorDetail(BDK_E_ADD_USER_TO_SERVICE_INSTANCE, "Failed to add a new user to a service instance.", false, 0x80169DA3);
            SetErrorDetail(BDK_E_INVALID_BILLABLEACCTSTATUS, "Status change not allowed.", false, 0x80169DA8);
            SetErrorDetail(BDK_E_SERVICE_INSTANCES_NONE, "No service instances available for the billable account.", false, 0x80169DBC);
            SetErrorDetail(BDK_E_ACCOUNT_CLOSED, "Account is already closed.", false, 0x80169DD1);
            SetErrorDetail(BDK_E_BILLINGPERIOD_PAST, "Period is already past.", false, 0x80169DD6);
            SetErrorDetail(BDK_E_INVALID_ADJUSTMENTGUID, "Invalid adjustment GUID.", false, 0x80169DD7);
            SetErrorDetail(BDK_E_INVALID_ADJUSMENT_FOR_PERIOD, "Adjustment not applicable to the specified period.", false, 0x80169DD8);
            SetErrorDetail(BDK_E_ADJUSTMENT_TOOBIG, "Adjustment amount is too large.", false, 0x80169DD9);
            SetErrorDetail(BDK_E_ADJUSTMENT_TOOSMALL, "Adjustment amount is too small.", false, 0x80169DDB);
            SetErrorDetail(BDK_E_INVALID_LOCALE, "Invalid locale.", false, 0x80169DE5);
            SetErrorDetail(BDK_E_INVALID_CUSTOMER_TYPE, "Invalid customer type.", false, 0x80169DE6);
            SetErrorDetail(BDK_E_INVALID_CURRENCY, "Invalid currency.", false, 0x80169DE7);
            SetErrorDetail(BDK_E_DATE_EXPIRED, "Date is already expired.", false, 0x80169DE8);
            SetErrorDetail(BDK_E_GUID_EXISTS, "GUID already exists.", false, 0x80169DEA);
            SetErrorDetail(BDK_E_INVALID_VIOLATION_ID, "Invalid violation ID.", false, 0x80169DEC);
            SetErrorDetail(BDK_E_MISSING_VIOLATION_ID, "Violation ID is required.", false, 0x80169DED);
            SetErrorDetail(BDK_E_NEEDTODEPROVISION, "De-provision service instances before proceeding.", false, 0x80169DEF);
            SetErrorDetail(BDK_E_PARTIALCONV_INITIATED, "Partial conversion is already initiated.", false, 0x80169DF0);
            SetErrorDetail(BDK_E_CANNOT_UPDATE_CURRENCY, "The currency of the account cannot be updated.", false, 0x80169DF1);
            SetErrorDetail(BDK_E_PARTIALCONV_EXPECTED, "Subscription is expected to be in the partial state.", false, 0x80169DF2);
            SetErrorDetail(BDK_E_INVALID_CATEGORY_NAME, "Invalid category. Valid category name has a size limit of 50 characters.", false, 0x80169DF3);
            SetErrorDetail(BDK_E_OFFERING_NOT_PURCHASEABLE, "Offering cannot be purchased.", false, 0x80169DF5);
            SetErrorDetail(BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH, "Offering currency does not match account currency.", false, 0x80169DF6);
            SetErrorDetail(BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH, "Offering does not support payment instrument type.", false, 0x80169DF7);
            SetErrorDetail(BDK_E_INVALID_DATE, "Invalid date.", false, 0x80169DF8);
            SetErrorDetail(BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP, "Cannot exceed max ownership for the offering.", false, 0x80169DF9);
            SetErrorDetail(BDK_E_INVALID_RESOURCE_ID, "Invalid resource ID.", false, 0x80169E02);
            SetErrorDetail(BDK_E_UNIT_OF_MEASURE_MISMATCH, "Unit of measure reported in the usage event does not match the one in SPS.", false, 0x80169E03);
            SetErrorDetail(BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE, "Event date is before the subscription purchase date.", false, 0x80169E04);
            SetErrorDetail(BDK_E_INVALID_OFFERING_FOR_LOCALE, "Offering invalid for the locale.", false, 0x80169E05);
            SetErrorDetail(BDK_E_NOT_A_BASE_OFFERING, "Offering is not a base offering.", false, 0x80169E06);
            SetErrorDetail(BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH, "There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.", false, 0x80169E08);
            SetErrorDetail(BDK_E_INVALID_OFFERING_FOR_COUNTRY, "Offering is invalid for Country.", false, 0x80169E09);
            SetErrorDetail(BDK_E_MEG_CONFLICT, "The offering requested conflicts with an existing subscription on this account.", false, 0x80169E0A);
            SetErrorDetail(BDK_E_INVALID_ACCOUNT_STATUS, "Account state does not allow this operation.", false, 0x80169E16);
            SetErrorDetail(BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST, "Payment instrument has active subscriptions.", false, 0x80169E1B);
            SetErrorDetail(BDK_E_EXISTING_BILLING_ACTIVITY, "The account has billing charges.", false, 0x80169E1C);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION, "Subscription is in an invalid state for this operation.", false, 0x80169E20);
            SetErrorDetail(BDK_E_PRIMARY_PHONE_REQUIRED, "Primary phone required for payment instruments.", false, 0x80169E25);
            SetErrorDetail(BDK_E_EMAIL_REQUIRED, "Account requires an e-mail address for this operation.", false, 0x80169E2A);
            SetErrorDetail(BDK_E_ACCOUNT_NOT_CLOSED, "To perform this operation, the account should be closed.", false, 0x80169E2B);
            SetErrorDetail(BDK_E_INVALID_VIOLATION, "Invalid violation ID.", false, 0x80169E13);
            SetErrorDetail(BDK_E_SUBSCRIPTION_IS_CANCELLED, "Subscription is cancelled and cannot change status.", false, 0x80169E14);
            SetErrorDetail(BDK_E_NO_VIOLATION, "Subscription has no violations.", false, 0x80169E15);
            SetErrorDetail(BDK_E_EXISTS_VIOLATION, "Subscription has violations.", false, 0x80169E17);
            SetErrorDetail(BDK_E_INVALID_SERVICE_COMPONENT_ID, "Invalid Service Component Id was passed.", false, 0x80169E32);
            SetErrorDetail(BDK_E_END_DATE_IN_THE_PAST, "End date is already past.", false, 0x80169E33);
            SetErrorDetail(BDK_E_END_DATE_BEYOND_MAX, "End date passed in is later than the latest allowable end date for this subscription.", false, 0x80169E34);
            SetErrorDetail(BDK_E_VIOLATION_ALREADY_SET, "Violation is already set.", false, 0x80169E3E);
            SetErrorDetail(BDK_E_NO_VIOLATION_SET, "Violation ID not set.", false, 0x80169E43);
            SetErrorDetail(BDK_E_INVALID_CONVERSION, "Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew).", false, 0x80169E4D);
            SetErrorDetail(BDK_E_SUBS_NOT_INTERMEDIATE, "Subscription is not in the partial state.", false, 0x80169E4E);
            SetErrorDetail(BDK_E_OFFERING_NOT_PUBLISHED, "Offering is not published.", false, 0x80169E52);
            SetErrorDetail(BDK_E_CONVERSION_NEEDTODEPROVISION, "Service instances must be de-provisioned to proceed.", false, 0x80169E53);
            SetErrorDetail(BDK_E_INVALID_MANDATE_STATUS, "Invalid mandate status.", false, 0x80169E57);
            SetErrorDetail(BDK_E_PI_ALREADY_GOOD, "Payment instrument status is already GOOD.", false, 0x80169E61);
            SetErrorDetail(BDK_E_PI_ALREADY_DECLINED, "Payment instrument status is already DECLINED.", false, 0x80169E66);
            SetErrorDetail(BDK_E_PI_IS_DISABLED, "Payment instrument status is DISABLED and cannot be changed.", false, 0x80169E6B);
            SetErrorDetail(BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED, "SAP Number is required for Invoice PI.", false, 0x80169E70);
            SetErrorDetail(BDK_E_INVALID_INVOICE_INFO_XML, "Invoice XML was invalid.", false, 0x80169E71);
            SetErrorDetail(BDK_E_MAX_PI_PER_ACCOUNT_REACHED, "Max Limit for this PI Type within account reached.", false, 0x8016AD81);
            SetErrorDetail(BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH, "PI country does not match Account country.", false, 0x80169E77);
            SetErrorDetail(BDK_E_ERROR_OCCURRED_TRY_LATER, "An error occured. Try again later.", false, 0x80169E78);
            SetErrorDetail(BDK_E_ERROR_OCCURRED, "An error occured.", false, 0x80169E79);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS, "Payment instrument exists or the payment instrument status is invalid or does not allow the operation.", false, 0x80169E7F);
            SetErrorDetail(BDK_E_INVALID_OFFERING_GUID, "Invalid offering GUID.", false, 0x80169E84);
            SetErrorDetail(BDK_E_OFFERING_REQUIRES_PI, "Offering requires a payment instrument.", false, 0x80169E89);
            SetErrorDetail(BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST, "Offering cannot be purchased because it has delayed provisioning components.", false, 0x80169E93);
            SetErrorDetail(BDK_E_INVALID_AMOUNT_FOR_CURRENCY, "Invalid currency format.", false, 0x80169E99);
            SetErrorDetail(BDK_E_INVALID_EMAIL_ADDRESS, "Invalid e-mail address.", false, 0x80169EA2);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_STATUS, "Invalid tax exemption status.", false, 0x80169EAC);
            SetErrorDetail(BDK_E_NO_VALID_TAX_EXEMPTION, "No valid tax exemption certificates exist for the account.", false, 0x80169EAD);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE, "Invalid tax exemption status change.", false, 0x80169EB1);
            SetErrorDetail(BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS, "The status of the old payment instrument does not allow this operation.", false, 0x80169EB6);
            SetErrorDetail(BDK_E_INVALID_START_PERIOD, "The specified start period is invalid.", false, 0x80169EC4);
            SetErrorDetail(BDK_E_INVALID_END_PERIOD, "The specified end period is invalid.", false, 0x80169EC5);
            SetErrorDetail(BDK_E_INVALID_DETAILEDLEVEL, "The specified Detailed level is invalid.", false, 0x80169EC6);
            SetErrorDetail(BDK_E_EXCEED_DATERANGE_LIMIT, "Difference between BeginDate and EndDate is more than 6 months", false, 0x80169EC7);
            SetErrorDetail(BDK_E_WRONG_DATERANGE, "Begin Date can never be greater than EndDate", false, 0x80169EC8);
            SetErrorDetail(BDK_E_INVALID_BEGIN_DATE, "Begin date is not valid", false, 0x80169EC9);
            SetErrorDetail(BDK_E_INVALID_END_DATE, "End date is not valid", false, 0x80169ECB);
            SetErrorDetail(BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE, "End date is greater than the current date", false, 0x80169ECC);
            SetErrorDetail(BDK_E_COMPUTE_ONLY, "SPS is in compute-only mode.", false, 0x80169ECA);
            SetErrorDetail(BDK_E_MISSED_PROCESSING_PERIOD, "Detected that month(s) were missed in periodic processing.", false, 0x80169F33);
            SetErrorDetail(BDK_E_SUBSCRIPTION_NOT_EXPIRED, "Subscription is not expired.", false, 0x80169F43);
            SetErrorDetail(BDK_E_TOOLATE_REINSTATE, "Subscription can no longer be reinstated.", false, 0x80169F44);
            SetErrorDetail(BDK_E_EXTRA_REFERRAL_DATA, "Only a single Referral node may be passed in to this API.", false, 0x80169F47);
            SetErrorDetail(BDK_E_NO_REFERRAL_UPDATES_ALLOWED, "bstrReferralIDSetXML parameter must be left empty for this API.", false, 0x80169F4C);
            SetErrorDetail(BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS, "Cannot schedule a new renewal because there exists already a free renewal on the subscription.", false, 0x80169F4D);
            SetErrorDetail(BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS, "Cannot convert a deal with multiple components with delayed provisioning.", false, 0x80169F4E);
            SetErrorDetail(BDK_E_INVALID_COBRAND, "The specified cobrand is invalid.", false, 0x80169F56);
            SetErrorDetail(BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION, "This operation is not valid for wholesale subscriptions.", false, 0x80169F65);
            SetErrorDetail(BDK_E_HCI_NOT_VALID, "HCI not valid for Account Id.", false, 0x80169F83);
            SetErrorDetail(BDK_E_CANT_STOP_TAIWAN_TAXINV, "Taiwan users cannot opt out of hard copy tax invoices.", false, 0x80169F85);
            SetErrorDetail(BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS, "Adjusting a resource balance is not allowed for subscriptions that are not active.", false, 0x80169FB5);
            SetErrorDetail(BDK_E_INVALID_TOKEN_TYPE, "The type of the token specified was invalid.", false, 0x8016A00A);
            SetErrorDetail(BDK_E_TOKEN_NOT_VALID_FOR_OFFERING, "The token Id specified is not valid for the given offering.", false, 0x8016A04B);
            SetErrorDetail(BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT, "Deal Token mapping currently not present in the system to be marked as invalid.", false, 0x8016A04C);
            SetErrorDetail(BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED, "Maximum consumption count per user reached.", false, 0x8016A00B);
            SetErrorDetail(BDK_E_INSERTING_USER_TOKEN_HASH, "Error in inserting a new row in table user_token_hash.", false, 0x8016A00C);
            SetErrorDetail(BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED, "A token Id and a payment instrument Id cannot both be specified.", false, 0x8016A06E);
            SetErrorDetail(BDK_E_TOKEN_CLASS_INVALID, "The token class is invalid or does not exist.", false, 0x8016A073);
            SetErrorDetail(BDK_E_INPUT_FILTER_XML_MISSING, "The Input TokenClass Restriction Info Filter is Missing.", false, 0x8016A074);
            SetErrorDetail(BDK_E_TOKEN_CLASS_NOT_FOUND, "Unable to find the token mapping to the specified token class.", false, 0x801613AB);
            SetErrorDetail(BDK_E_INVALID_INPUT_FILTER_XML, "Invalid TokenClass Restriction Info Filter.", false, 0x8016A075);
            SetErrorDetail(BDK_E_PI_CANNOT_BE_SPECIFIED, "A payment instrument cannot be specified.", false, 0x8016A078);
            SetErrorDetail(BDK_E_SUBSCRIPTION_NOT_PREPAID, "The subscription specified is not a PrePaid subscription.", false, 0x8016A07D);
            SetErrorDetail(BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO, "The total number of extended days cannot be less than zero.", false, 0x8016A082);
            SetErrorDetail(BDK_E_INVALID_NUMBER_OF_DAYS, "The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.", false, 0x8016A087);
            SetErrorDetail(BDK_E_INVALID_NUMBER_OF_MONTHS, "The number of months specified is invalid, possibly because it is negative.", false, 0x8016A088);
            SetErrorDetail(BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX, "The total number of extended days is greater than the maximum allowed for the current subscription.", false, 0x8016A08C);
            SetErrorDetail(BDK_E_PREPAID_TOKEN_IS_REQUIRED, "The deal specified requires a valid Prepaid Token Id to be specified.", false, 0x8016A096);
            SetErrorDetail(BDK_E_TERM_COMMIT_EXISTS, "There are remaining cycles on the current term commit.", false, 0x8016A09B);
            SetErrorDetail(BDK_E_TOKEN_NOT_APPLICABLE, "The specified token cannot be used for the current operation.", false, 0x8016A0A0);
            SetErrorDetail(BDK_E_TOKEN_RENEWAL_PRESENT, "Renewal cannot be scheduled if there is already a token based renewal present.", false, 0x8016A0A5);
            SetErrorDetail(BDK_E_EXCEEDS_MAXIMUM_DURATION, "Error subscription duration exceeds max duration.", false, 0x8016A0FA);
            SetErrorDetail(BDK_E_CONVERSION_CREDITS_NOT_ENABLED, "Error conversion credits were applied but the offer does not support conversion credits.", false, 0x8016A104);
            SetErrorDetail(BDK_E_INVALID_USERROLE_FOR_ADDPI, "Only BillableAccountAdmin can add the PI.", false, 0x8016A10E);
            SetErrorDetail(BDK_E_BLACKLIST_ACTION_NOT_PERFORMED, "BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.", false, 0x8016A0AA);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_ACTION, "BlacklistToken was called with invalid bstrSubscriptionAction parameter.", false, 0x8016A0AF);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND, "Invalid distribution channel specified for token class part number.", false, 0x8016A0B9);
            SetErrorDetail(BDK_E_INVALID_LEN_PART_NUMBER, "Invalid length for token class part number.", false, 0x8016A0BE);
            SetErrorDetail(BDK_E_INVALID_LEN_SAP_CUST_NAME, "nvalid length for SAP customer name.", false, 0x8016A0C3);
            SetErrorDetail(BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME, "Invalid length for Support Vendor name.", false, 0x8016A0C8);
            SetErrorDetail(BDK_E_INSERING_TOKEN_CLASS_PARTNER, "Failed while inserting in partner_token_class table.", false, 0x8016A0CD);
            SetErrorDetail(BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS, "Token Part Number is currently associated with other token class please remove the association from the other token class and try again.", false, 0x8016A0D2);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_DELIVERED, "A token is being delivered to the same service instance at this moment. Please retry.", true, 0x8016148D);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID, "A Token passed in does not have an associated Distribution batch.", true, 0x80169DDA);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE, "A Distribution Batch associated with the passed in Token is in inactive state.", true, 0x80169DDF);
            SetErrorDetail(BDK_E_DISTRIBUTION_PROGRAM_INACTIVE, "A Distribution Program is in inactive state.", true, 0x80169DE9);
            SetErrorDetail(BDK_E_INSERTING_RECONCILE_HISTORY, "Failed while inserting in reconcile_history table.", false, 0x801614BE);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_ISSUED, "Specified Token is already issued.", false, 0x801614C3);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_UNISSUED, "Specified Token is already unissued, can not unissue the same token again.", false, 0x801614C8);
            SetErrorDetail(BDK_E_TOKEN_ISSUE_UPDATE, "Failed to update the token issue status in token_instance table.", false, 0x801614CD);
            SetErrorDetail(BDK_E_INVALID_COMBINATION, "The input parameter combination does not match the system.", false, 0x801614D2);
            SetErrorDetail(BDK_E_INVALID_REPLACEMENT_REASON_CODE, "Invalid Replacement Reason code specified.", false, 0x801614D7);
            SetErrorDetail(BDK_E_MAX_REPLACEMENT_REACHED, "The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value.", false, 0x801614DC);
            SetErrorDetail(BDK_E_TOKEN_REPLACEMENT_FAILED, "Token Replacement failed due to unknown error.", false, 0x801614E1);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE, "Failed to update Token Distribution status.", false, 0x801614E6);
            SetErrorDetail(BDK_E_SIGNATURE_TOKEN_MISMATCH, "Signature does not belong to specified Token.", false, 0x801614EB);
            SetErrorDetail(BDK_E_INVALID_STATUS_NAME, "Invalid Token Staus Name specified.", false, 0x801614F0);
            SetErrorDetail(BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS, "Invalid distribution status to issue token.", false, 0x801614F5);
            SetErrorDetail(BDK_E_ALREADY_REPLACED_TOKEN, "Specified token is replaced token, can not provide replacement for Replaced Token.", false, 0x801614FA);
            SetErrorDetail(BDK_E_TOKEN_ACTION_ACCESS_DENIED, "Invalid Partner specified or the partner does not have permission to take action on specified token.", false, 0x801614FF);
            SetErrorDetail(BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR, "Value for returnStatementSet parameter must be 0, 1, or 2.", false, 0x8016A604);
            SetErrorDetail(BDK_E_BAD_BEGIN_BILLING_PERIOD, "The begin billing period is not valid for this account.", false, 0x8016A609);
            SetErrorDetail(BDK_E_INVALID_END_BILLING_PERIOD, "The end billing period is not valid for this account.", false, 0x8016A60E);
            SetErrorDetail(BDK_E_BILLING_PERIOD_NEGATIVE, "The billing period value cannot be negative.", false, 0x8016A613);
            SetErrorDetail(BDK_E_BAD_START_END_BILLING_PERIOD, "The end period must be greater than start period.", false, 0x8016A618);
            SetErrorDetail(BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE, "The account history date cannot be greater than the current date.", false, 0x8016A61D);
            SetErrorDetail(BDK_E_NO_NON_NULL_PARAMS, "Cannot pass null for all parameters.", false, 0x8016A622);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD, "The billing period value must be of the format YYYYMM (Y representing the year and M representing month).", false, 0x8016A627);
            SetErrorDetail(BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION, "The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration).", false, 0x8016A62C);
            SetErrorDetail(BDK_E_MISMATCH_SUB_ID_OFFER_GUID, "The offering guid passed in does not match offering guid on subscription.", false, 0x8016A6FE);
            SetErrorDetail(BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE, "The event time stamp is too far in future.", false, 0x8016A70D);
            SetErrorDetail(BDK_E_INVALID_POLICY_ID, "The policy GuidID/Version combination supplied does not exist.", false, 0x80169F88);
            SetErrorDetail(BDK_E_OFFERING_PI_COUNTRY_MISMATCH, "The offering specified does not support the country of payment instrument being used.", false, 0x80169F89);
            SetErrorDetail(BDK_E_INSERT_AGREEMENT_SIGNATURE, "Error inserting into table agreement_signature.", false, 0x80169F8D);
            SetErrorDetail(BDK_E_AGREEMENT_ALREADY_SIGNED, "Agreement for this subscription has already been signed by this user at a different time.", false, 0x80169F92);
            SetErrorDetail(BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY, "The specified policy has not been localized in the specified locale.", false, 0x80169F9C);
            SetErrorDetail(BDK_E_POLICY_DEAL_VERSION_MISMATCH, "The policy specified is valid but the version is incorrect.", false, 0x80169F9E);
            SetErrorDetail(BDK_E_POLICY_DEAL_COUNTRY_MISMATCH, "The policy specified exists but is not valid on the deal/country combination of the supplied subscription.", false, 0x80169FA1);
            SetErrorDetail(BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE, "The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed.", false, 0x8016A6D1);
            SetErrorDetail(BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW, "A payment instrument cannot specified when the conversion mode is RENEW.", false, 0x8016A6D6);
            SetErrorDetail(BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING, "Renewing from a perpetual offering is not allowed.", false, 0x8016A6E5);
            SetErrorDetail(BDK_E_INVALID_TECERTIFICATENUMBER, "Tax Exempt Certificate Number is invalid.", false, 0x8016A6EA);
            SetErrorDetail(BDK_E_NO_WHOLESALE_TO_WHOLESALE, "Conversions between wholesale offers are not allowed.", false, 0x8016A708);
            SetErrorDetail(BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS, "The status of the new payment instrument specified does not allow this operation.", false, 0x8016A712);
            SetErrorDetail(BDK_E_INVALID_RENEWAL, "Renewal does not exist.", false, 0x8016A71C);
            SetErrorDetail(BDK_E_ERROR_PHONE_STRING_TOOLONG, "The length of phone number is greater than expected.", false, 0x8016A721);
            SetErrorDetail(BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED, "The calling partner does not have access to the token class.", false, 0x8016A72B);
            SetErrorDetail(BDK_E_LAST_ADMIN_ROLE, "Last administrator role on the account cannot be removed.", false, 0x8016C3C3);
            SetErrorDetail(BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN, "The PUID is already being used as BillableAccountAdmin.", false, 0x8016C3C4);
            SetErrorDetail(BDK_E_UPDATING_MEMBERNAME, "Error updating member name.", false, 0x8016C3C8);
            SetErrorDetail(BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED, "Object can have a maximum of 2000 roles.", false, 0x8016C3CD);
            SetErrorDetail(BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED, "The allowable number of the delegate admins for an account has reached its limit.", false, 0x8016C3CE);
            SetErrorDetail(PROVISION_E_MALFORMED_REQUEST, "Provisioning: Provision request malformed.", false, 0x8016AB7D);
            SetErrorDetail(PROVISION_E_WRONG_INPUT_PARAMETERS, "Provisioning: Wrong input parameters.", false, 0x8016AB7E);
            SetErrorDetail(PROVISION_E_MPF_CALL_FAILED, "Provisioning: Microsoft Provisioning Framework call failed. %1", true, 0x8016AB7F);
            SetErrorDetail(PROVISION_E_XML_OPERATION_ERROR, "Provisioning: Error during XML manipulation. %1", false, 0x8016AB80);
            SetErrorDetail(PROVISION_E_MPF_CREATE, "Provisioning: MPF client instantiation failed. %1", false, 0x8016AB81);
            SetErrorDetail(PROVISION_E_CREATION, "Provisioning: General error in startup code. %1", false, 0x8016AB82);
            SetErrorDetail(BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS, "The number of service instances in the provisioning request exceeds the configured limit.", false, 0x8016ABA2);
            SetErrorDetail(BDK_E_DBBADZIP, "Invalid ZIP code.", false, 0x8016ABA3);
            SetErrorDetail(BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS, "The account has subscription(s) in non-cancelled state that require information that you are attempting to remove.", false, 0x8016ABA4);
            SetErrorDetail(BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED, "The account requires additional attributes before performing the operation.", false, 0x8016ABA5);
            SetErrorDetail(BDK_E_ACCT_ALREADY_REFERRED, "The referrer has already reffered the customer to this offer.", false, 0x8016ABCE);
            SetErrorDetail(BDK_E_REWARD_OFFER_NOT_PURCHASABLE, "There are no reward offers currently available in the system.", false, 0x8016ABDA);
            SetErrorDetail(BDK_E_AGREEMENT_NOT_SIGNED, "Need to sign the agreement before continuing with the call.", false, 0x8016AC79);
            SetErrorDetail(BDK_E_ITEM_VIOLATION_EXISTS, "The user has a violation on their payment instrument.", false, 0x8016AC7A);
            SetErrorDetail(BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION, "Title and/or category is not allowed for this offer.", false, 0x8016AC7B);
            SetErrorDetail(BDK_E_PENDING_TRANSACTION, "Account has a pending transaction.", false, 0x8016AC7C);
            SetErrorDetail(BDK_E_INCREMENT_TOTAL, "Cannot update total.", false, 0x80164E39);
            SetErrorDetail(BDK_E_RES_NOT_BELONG_TO_OBJECT, "Resource does not belong to this object id.", false, 0x80164E57);
            SetErrorDetail(BDK_E_DECLINING_BALANCE, "Payment instrument on the current subscription has a declining balance.", false, 0x80164E5C);
            SetErrorDetail(BDK_E_DUPLICATE_TRACKING_GUID, "Duplicate tracking GUID.", false, 0x80164E75);
            SetErrorDetail(BDK_E_INVALID_EXPIRATION_DATE, "Invalid credit card expiration date.", false, 0x80164EA7);
            SetErrorDetail(BDK_E_UNKNOWN_MANDATE_STATUS, "Invalid mandate status.", false, 0x80164EAC);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_METHOD_TYPE, "Payment method of this type can't support the action", false, 0x80164EB2);
            SetErrorDetail(BDK_E_INVALID_CURRENCY2, "Invalid input currency.", false, 0x80164EC0);
            SetErrorDetail(BDK_E_INVALID_AMOUNT, "Invalid amount passed in as argument.", false, 0x80164EFC);
            SetErrorDetail(BDK_E_INVALID_BILLING_PERIOD, "Invalid billing period.", false, 0x80164F42);
            SetErrorDetail(BDK_E_INVALID_ANNIV, "Invalid billing anniversary date.", false, 0x80164F9C);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_ID, "Invalid line item ID.", false, 0x80164FF6);
            SetErrorDetail(BDK_E_INVALID_EVENT_TYPE, "The event type of the line item is invalid for this operation.", false, 0x8016501E);
            SetErrorDetail(BDK_E_LINE_ITEM_ID_NOT_OPEN, "Line item ID not associated with an open record.", false, 0x80165046);
            SetErrorDetail(BDK_E_LINEITEM_ALREADY_OFFSET, "Line item has already been offset.", false, 0x8016504B);
            SetErrorDetail(BDK_E_LINEITEM_ALREADY_CHARGED_BACK, "Line item has already been Charged back.", false, 0x8016504D);
            SetErrorDetail(BDK_E_INVALID_OFFSET_AMOUNT, "Offset amount must be greater than zero but less than or equal to original amount. %1", false, 0x80165050);
            SetErrorDetail(BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED, "Cannot offset line item that is soft- or hard-declined.", false, 0x80165055);
            SetErrorDetail(BDK_E_AMOUNT_NOT_COLLECTED_YET, "Amount has not been collected, so it cannot be offset and immediately settled.", false, 0x8016505A);
            SetErrorDetail(BDK_E_CANNOT_OFFSET_ZERO_AMOUNT, "Cannot offset line item amount of zero.", false, 0x8016505F);
            SetErrorDetail(BDK_E_AMOUNT_IN_PROCESS, "The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.", false, 0x80165064);
            SetErrorDetail(BDK_E_INVALID_CREDIT_AMOUNT, "Credit amount should not be zero.", false, 0x80165082);
            SetErrorDetail(BDK_E_CREDIT_AMOUNT_OVER_LIMIT, "Credit amount should not exceed the limit.", false, 0x80165083);
            SetErrorDetail(BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2, "Invalid amount for currency (JPY or KRW).", false, 0x80165084);
            SetErrorDetail(BDK_E_DUPLICATE_EVENT_ID, "Same event id already been used, please create a new event id and retry.", false, 0x80165091);
            SetErrorDetail(BDK_E_OFFSET_IMM_SETTLE_IN_PROG, "Line items in the immediate_settle_in_progress state cannot be offset.", false, 0x8016509B);
            SetErrorDetail(BDK_E_SA_IN_STATE_UNOFFSETABLE, "Line item with this settlement amount status cannot be offset.", false, 0x801650A5);
            SetErrorDetail(BDK_E_SA_IN_STATE_UNESCHEATABLE, "this settlement amount status cannot be escheated.", false, 0x801650A6);
            SetErrorDetail(BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL, "Offset amount should never exceed the original item amount.", false, 0x801650AA);
            SetErrorDetail(BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS, "The subscription is not active. The resource usage event is still being reported for the subscription.", false, 0x801650AF);
            SetErrorDetail(BDK_E_PI_IN_DECLINE, "the payment instrument already has declines on it", false, 0x801650C8);
            SetErrorDetail(BDK_E_SA_IN_INTERMEDIATE_STATUS, "The operation is not allowed when there are Settlement Amounts in intermediate status.", false, 0x801651D1);
            SetErrorDetail(BDK_E_INVALID_SETTLEMENT_AMOUNT_ID, "The specified settlement amount id is invalid.", false, 0x801651D6);
            SetErrorDetail(BDK_E_MISMATCH_RATED_USAGE_TOTAL, "This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.", false, 0x801651E5);
            SetErrorDetail(BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2, "Value for returnStatementSet parameter must be 0, 1, or 2.", false, 0x801651BD);
            SetErrorDetail(BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE, "%1", false, 0x801651EA);
            SetErrorDetail(BDK_E_REFUND_LINEITEM_NOT_SETTLED, "Refund failed - line item was offset but original line item was never settled.", false, 0x80165217);
            SetErrorDetail(BDK_E_RESOURCE_BALANCE_INACTIVE, "Specified resource balance has already been billed.", false, 0x80165226);
            SetErrorDetail(BDK_E_INVALID_NUMBER_OF_UNITS, "Usage category does not exist for this resource.", false, 0x80165235);
            SetErrorDetail(BDK_E_INVALID_USAGE_CATEGORY, "Usage category does not exist for this resource.", false, 0x8016523A);
            SetErrorDetail(BDK_E_INSUFFICIENT_PREPAID_BALANCE, "The prepaid resource balance is not sufficient for this usage event.", false, 0x8016523F);
            SetErrorDetail(BDK_E_INVALID_FINANCIAL_REASON_CODE, "Financial reason code does not exist.", false, 0x80165262);
            SetErrorDetail(BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED, "Offset of offset is not permitted through this API.", false, 0x80165267);
            SetErrorDetail(BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT, "If offset is not to be shown by getstatement, the offset amount must match the original amount.", false, 0x80165276);
            SetErrorDetail(BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET, "Invalid financial reason code passed for the offset usage API.", false, 0x8016527B);
            SetErrorDetail(BDK_E_EVENT_ACTION_NOT_OFFSETTABLE, "The line item is associated with a non-offsettable event action.", false, 0x80165280);
            SetErrorDetail(BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED, "Action is not permitted for immediate settle of usage offers.", false, 0x80165285);
            SetErrorDetail(BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE, "Resource offset is only allowed for usage.", false, 0x8016528A);
            SetErrorDetail(BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE, "Invalid Tax Refund Code.", false, 0x801652AD);
            SetErrorDetail(BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER, "The transaction confirmation number is already used on the account.", false, 0x801655FA);
            SetErrorDetail(BDK_E_TRANSACTION_NOT_EXIST, "The transaction does not exist.", false, 0x80165609);
            SetErrorDetail(BDK_E_INVALID_CUMULATIVE_AMOUNT, "Invalid combination of cumulative authorized amount and cumulative reversed amount.", false, 0x80165613);
            SetErrorDetail(BDK_E_TRANSACTION_EVENT_UNKNOWN, "The transaction event code is unknown.", false, 0x80165618);
            SetErrorDetail(BDK_E_TRANSACTION_EVENT_INCONSISTENT, "The transaction event code is not consistent.", false, 0x8016561D);
            SetErrorDetail(BDK_E_INVALID_SEQUENCE_NUMBER, "Invalid sequence number reported in transaction event.", false, 0x80165622);
            SetErrorDetail(BDK_E_INVALID_VENDOR_TRANSACTION_ID, "Invalid vendor internal transaction id.", false, 0x80165627);
            SetErrorDetail(BDK_E_INVALID_REJECTION_REASON_CODE, "Invalid rejection reason code.", false, 0x8016562C);
            SetErrorDetail(BDK_E_INVALID_TRANSACTION_STATUS, "Invalid transaction status.", false, 0x80165659);
            SetErrorDetail(BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT, "Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount.", false, 0x8016566D);
            SetErrorDetail(BDK_E_UNKNOWN_MERCHANT_ID, "Invalid merchant id.", false, 0x80165677);
            SetErrorDetail(BDK_E_TRANSACTION_ALREADY_CANCELLED, "Transaction has already been cancelled.", false, 0x8016567C);
            SetErrorDetail(BDK_E_PMN_INSERT_FAILURE, "Passport member name could not be added.", false, 0x801661BC);
            SetErrorDetail(BDK_E_BADSAMECARDUSEDMULTIPLETIMES, "Payment card number has been used multiple times.", false, 0x801661D0);
            SetErrorDetail(BDK_E_PI_ALREADY_ON_ACCOUNT, "Payment instrument already assigned to account.", false, 0x801661DF);
            SetErrorDetail(BDK_E_PUID_ROLE_LIMIT_EXCEEDED, "Passport ID can have a maximum of 100 roles.", false, 0x801661E4);
            SetErrorDetail(BDK_E_TOOMANY_FDE_PURCHASES, "Too many fraud enticing purchases on the payment instrument", false, 0x801661E5);
            SetErrorDetail(BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED, "Passport PUIDs associated with this tax Id has already reaches the maximum limit.", false, 0x8016620C);
            SetErrorDetail(BDK_E_NOPERMISSION, "Access denied.", false, 0x80162711);
            SetErrorDetail(BDK_E_CANNOT_REMOVE_SELF, "Cannot remove self from object.", false, 0x80162712);
            SetErrorDetail(BDK_E_BADXML, "XML is either malformed or incorrect for this API.", false, 0x80162713);
            SetErrorDetail(BDK_E_INVALIDCOMMENTSIZE, "Comment text length must be between 1 and 512 characters.", false, 0x80162714);
            SetErrorDetail(BDK_E_BADCANCELMODE, "Invalid cancellation mode.", false, 0x80162715);
            SetErrorDetail(BDK_E_INVALID_BUF_SIZE, "Input parameter is the wrong size.", false, 0x80162716);
            SetErrorDetail(BDK_E_INVALID_ROLE, "Invalid role.", false, 0x80162717);
            SetErrorDetail(BDK_E_INVALID_PPORT_ID, "Invalid Passport ID.", false, 0x80162718);
            SetErrorDetail(BDK_E_INVALID_ARG, "Invalid argument.", false, 0x8016271A);
            SetErrorDetail(BDK_E_UNKNOWN_SERVER_FAILURE, "Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.", true, 0x8016271F);
            SetErrorDetail(BDK_E_INVALID_STATUS_VALUE, "Status must be ENABLED or SUSPENDED.", false, 0x80162720);
            SetErrorDetail(BDK_E_INVALID_FILTER, "Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.", false, 0x80162721);
            SetErrorDetail(BDK_E_MISSING_CATEGORY, "Missing category.", false, 0x80162722);
            SetErrorDetail(BDK_E_FIELD_TOO_SHORT, "Input field is too short.", false, 0x80162723);
            SetErrorDetail(BDK_E_FIELD_TOO_LONG, "Input field is too long.", false, 0x80162724);
            SetErrorDetail(BDK_E_BADZIP, "Invalid ZIP code.", false, 0x80162725);
            SetErrorDetail(BDK_E_ONLYONENODE, "Only one of these nodes should be passed.", false, 0x80162726);
            SetErrorDetail(BDK_E_INVALID_FIELD_LENGTH, "Input field length does not meet requirement.", false, 0x80162727);
            SetErrorDetail(BDK_E_CSR_AUTHZ_FAILED, "Only customer service representatives can invoke this API.", false, 0x80162728);
            SetErrorDetail(BDK_E_NOT_ACCOUNT_ADMIN, "Caller is not an account administrator.", false, 0x80162729);
            SetErrorDetail(BDK_E_DELEGATE_ID_UNSPECIFIED, "Delegate ID entered was invalid or not specified.", false, 0x8016272A);
            SetErrorDetail(BDK_E_REQUESTER_ID_UNSPECIFIED, "Requester Passport ID must be specified.", false, 0x8016272B);
            SetErrorDetail(BDK_E_INVALID_FLAG_VALUE, "Boolean value must be 0 or 1", false, 0x8016272C);
            SetErrorDetail(BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION, "Subscription service instance is inactive.", false, 0x8016272D);
            SetErrorDetail(BDK_E_INVALID_OBJECT_ID, "Invalid object.", false, 0x8016272E);
            SetErrorDetail(BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH, "Input field length of first name does not meet requirement.", false, 0x8016272F);
            SetErrorDetail(BDK_E_INVALID_LASTNAME_FIELD_LENGTH, "Input field length of last name does not meet requirement.", false, 0x80162730);
            SetErrorDetail(BDK_E_INVALID_ADDRESS_FIELD_LENGTH, "Input field length of address does not meet requirement.", false, 0x80162731);
            SetErrorDetail(BDK_E_PARTNERNOTINBILLING, "Calling partner is not registered in SPS database.", false, 0x80162738);
            SetErrorDetail(BDK_E_RATING_FAILURE, "Rating error has occurred. Check the event log and the tracer.", false, 0x8016273D);
            SetErrorDetail(BDK_SVR2_STARTED, "BDKSVR2 started.", false, 0x80162742);
            SetErrorDetail(BDK_CSR_API_CALL_MADE, "CSR call made.", false, 0x80162743);
            SetErrorDetail(BDK_E_CSR_CALL_FROM_NONCSR, "CSR call attempt by non-CSR caller.", false, 0x80162744);
            SetErrorDetail(BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS, "\"From\" and \"to\" payment instrument are not on the same account in TransferBalance.", false, 0x8016274C);
            SetErrorDetail(BDK_E_TRANS_BALANCE_TO_PI_INVALID, "Invalid \"to\" payment instrument in TransferBalance.", false, 0x80162751);
            SetErrorDetail(BDK_E_TRANS_BALANCE_TO_SAME_PI, "Cannot transfer to same payment instrument in TransferBalance.", false, 0x80162756);
            SetErrorDetail(BDK_E_TRANS_BALANCE_NOT_ALLOW, "Cannot transfer balances between payment instrument types.", false, 0x8016275B);
            SetErrorDetail(BDK_E_INTERNAL_ERROR, "Internal database inconsistencies detected.", false, 0x80162760);
            SetErrorDetail(BDK_E_OUTSTANDING_BALANCE, "Payment instrument has outstanding balance.", false, 0x80162765);
            SetErrorDetail(BDK_E_INVALID_REFERRALDATA_XML, "Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).", false, 0x8016276A);
            SetErrorDetail(BDK_E_INVALID_GUID, "Invalid GUID.", false, 0x8016276F);
            SetErrorDetail(E_UNSUPPORTED_PAYMENT_INSTRUMENT, "Payment instrument type not supported for SettleBalance.", false, 0x80162774);
            SetErrorDetail(BDK_E_SUBSCRIPTION_INACTIVE, "Subscription is inactive.", false, 0x80162779);
            SetErrorDetail(BDK_E_INVALID_PM_FOR_STOP_PAYMENTS, "Payments can only be stopped for credit card and direct debit transactions.", false, 0x8016277E);
            SetErrorDetail(BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS, "Excessive number of usage events reported in one ReportUsageEvent() call.", false, 0x80162783);
            SetErrorDetail(BDK_E_FIELD_NOT_UPDATEABLE, "Field cannot be updated.", false, 0x80162788);
            SetErrorDetail(BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED, "Calling CancelSubscription with an end date and in compute-only mode is not supported.", false, 0x8016278D);
            SetErrorDetail(BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT, "The SETTLE event should be the last event in the event list for ImportSettleBillingItems.", false, 0x8016278E);
            SetErrorDetail(BDK_E_PAYMENT_METHOD_NO_LONGER_VALID, "Line item payment method is no longer valid.", false, 0x8016278F);
            SetErrorDetail(BDK_E_PROCESS_USAGE_EVENTS, "Failed to process all usage events.", false, 0x80162790);
            SetErrorDetail(BDK_E_WRONG_OBJECT_ID_TYPE, "Object ID does not contain account and subscription information.", false, 0x80162791);
            SetErrorDetail(BDK_E_INVALID_PHONE_VALUE, "Field contains invalid characters for a phone number.", false, 0x80162792);
            SetErrorDetail(BDK_E_INVALID_AMOUNT_VALUE, "Invalid amount.", false, 0x80162797);
            SetErrorDetail(BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE, "Payment instrument ID and line item ID do not match.", false, 0x80162793);
            SetErrorDetail(BDK_E_INTERNAL_ADD_COMMENT_FAILED, "InternalAddComment failed. Escalate error to SPG development.", false, 0x80162794);
            SetErrorDetail(BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE, "Immediate settle flag value not supported.", false, 0x80162795);
            SetErrorDetail(BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS, "No eligible records were found for this call.", false, 0x8016279C);
            SetErrorDetail(BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE, "Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.", false, 0x801627A6);
            SetErrorDetail(BDK_E_INVALID_TELENUMERIC_STRING, "The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.", false, 0x801627B0);
            SetErrorDetail(BDK_E_NO_MATCH, "There are no matches for the requested information.", false, 0x801627BA);
            SetErrorDetail(BDK_E_MULTIPLE_MATCHES, "There are multiple matches for the requested information.", false, 0x801627C4);
            SetErrorDetail(BDK_E_BAD_PUID, "PUID entered was invalid.", false, 0x801627CE);
            SetErrorDetail(BDK_E_BAD_OBJECT_ID_LENGTH, "ObjectId length must be 16.", false, 0x801627D9);
            SetErrorDetail(BDK_E_END_PERIOD_LESS_THAN_START_PERIOD, "Start period can never be greater than End period.", false, 0x801627DA);
            SetErrorDetail(BDK_E_BAD_BILLING_PERIOD_LENGTH, "Billing period length must be 6.", false, 0x801627DB);
            SetErrorDetail(BDK_E_BAD_RETURN_STATEMENT_SET, "Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.", false, 0x801627DC);
            SetErrorDetail(BDK_E_INVALID_USAGE_EVENT_DATE, "The usage event date specified was invalid.  One possible reason is that it is too far in the future.", false, 0x801627DF);
            SetErrorDetail(BDK_E_NULL_DEFAULT_BILLING_PERIOD, "The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.", false, 0x801627E0);
            SetErrorDetail(BDK_E_BAD_START_BILLING_PERIOD, "The start billing period is less than the currently available billing period.", false, 0x801627E1);
            SetErrorDetail(BDK_E_BAD_END_BILLING_PERIOD, "The end billing period is less than the currently available billing period.", false, 0x801627E2);
            SetErrorDetail(BDK_E_NEW_DUE_DATE_IS_PAST, "The new due date is in the past", false, 0x801627E7);
            SetErrorDetail(BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED, "The new due date is more than MAXIMUM DELAY days in the future than the original due date", false, 0x801627EC);
            SetErrorDetail(BDK_E_NO_NEW_DUE_DATE_SPECIFIED, "If the applydeclineEffect is off, we need a new due date specified", false, 0x801627F1);
            SetErrorDetail(BDK_E_INVALID_TRANSACTION_TYPE, "Invalid transaction type", false, 0x801627F6);
            SetErrorDetail(BDK_E_INVALID_REASON_CODE, "Invalid reason code", false, 0x801627FB);
            SetErrorDetail(BDK_E_GROUP_SID_INITIALIZATION_FAILED, "Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.", false, 0x8016280B);
            SetErrorDetail(BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI, "This operation is not valid for wholesale payment instruments.", false, 0x8016280C);
            SetErrorDetail(BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT, "This operation is not valid for direct debit payment instrument.", false, 0x8016280D);
            SetErrorDetail(BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT, "Adjustment amount exceeds the resource credit limit.", false, 0x8016280E);
            SetErrorDetail(BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS, "Adjusting a resource balance is not allowed for subscriptions that are not active.", false, 0x8016280F);
            SetErrorDetail(BDK_E_FAILED_TO_CREATE_MAIL_RECORD, "Failed to create mail record for account: %1.", false, 0x80162810);
            SetErrorDetail(BDK_E_MSNIA_LATE_USAGE, "This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.", false, 0x80162811);
            SetErrorDetail(BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB, "Failed to write asynchronous immediate settlement failure into the audit db for account: %1.", false, 0x80162812);
            SetErrorDetail(BDK_E_INVALID_REFERRAL_OFFER, "This offering is not configured as a referral offer.", false, 0x8016ABCC);
            SetErrorDetail(BDK_E_REWARD_REFERRAL_XML_REQUIRED, "Reward referral XML is required as this is a referral based offer.", false, 0x80162813);
            SetErrorDetail(BDK_E_REFERRER_NOT_IN_SYSTEM, "Referral PUID not found.", false, 0x80162814);
            SetErrorDetail(BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER, "Referrer has exceeded the max number of referrals configured on the offer.", false, 0x80162815);
            SetErrorDetail(BDK_E_REFERRER_NOT_ACTIVE, "The referrer does not have an Active or Locked account in the system.", false, 0x80162816);
            SetErrorDetail(BDK_E_CANNOT_REFER_SELF, "The referrer cannot refer self for the offer.", false, 0x80162817);
            SetErrorDetail(BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL, "The referral xml has reward referral info but the offer is not configured for reward referrals.", false, 0x80162818);
            SetErrorDetail(BDK_E_INVALID_REWARD_REFFERAL_SCHEMA, "The reward referral schema in the referral xml is invalid.", false, 0x80162819);
            SetErrorDetail(BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER, "The referrer does not have any eligible offers configured for the reward.", false, 0x8016281A);
            SetErrorDetail(BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS, "Invalid mandate status for SettleBalance.", false, 0x8016281B);
            SetErrorDetail(BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED, "More than one usage event reported to ReportSingleUsageEvent API", false, 0x8016281C);
            SetErrorDetail(BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM, "The reported usage is below the threshold in immediate settle usage.", false, 0x8016281D);
            SetErrorDetail(BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE, "ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.", false, 0x8016281E);
            SetErrorDetail(BDK_E_REPORT_USAGE_WITH_PREPAID, "ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.", false, 0x8016281F);
            SetErrorDetail(BDK_E_NO_USAGE_EVENT_REPORTED, "ReportSingleUsage cannot be used with empty event set.", false, 0x80162820);
            SetErrorDetail(BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT, "The payment instrument type does not support immediate settlements", false, 0x80162821);
            SetErrorDetail(BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH, "The reported resource and unit of measure do not match.", false, 0x80162822);
            SetErrorDetail(BDK_E_INVALID_REDIRECT_INPUTINFO_XML, "Invalid  data passed in RedirectInputInfoXML node.", false, 0x80162823);
            SetErrorDetail(BDK_E_TRANSACTION_NOT_CANCELLABLE, "Transaction cannot be cancelled.", false, 0x80162824);
            SetErrorDetail(BDK_E_NO_CDS_FOUND, "No CDs found.", false, 0x80162825);
            SetErrorDetail(BDK_E_INVALID_CHARGE_DESCRIPTOR, "Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length", false, 0x80162826);
            SetErrorDetail(BDK_E_INVALID_WHOLESALEPI, "This Wholesale payment instrument has no related wholesale partner.", false, 0x801628A0);
            SetErrorDetail(BDK_E_NOT_BOBOPARTNER, "This partner is not BOBO wholesale partner.", false, 0x801628A1);
            SetErrorDetail(BDK_E_INVALID_BOBOPARTNER, "This BOBO wholesale partner has no entitle endpoint.", false, 0x801628A2);
            SetErrorDetail(BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE, "The entitlement endpoint web service could not be reached", false, 0x801628FA);
            SetErrorDetail(BDK_E_ENTITLEMENT_VALIDATION_FAILED, "The entitlement endpoint returned a validation failure", false, 0x801628FB);
            SetErrorDetail(BDK_E_INVALID_ENTITLEMENT_ENDPOINT, "The entitlement endpoint is invalid", false, 0x801628FC);
            SetErrorDetail(BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT, "Calling partner does not have permissions to access the sandboxed object", false, 0x80169D57);
            SetErrorDetail(BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF, "Calling partner does not have permissions to call on behalf of this partner", false, 0x80162828);
            SetErrorDetail(BDK_E_TAXWARE_FAILURE, "Taxware error. Check the event log and the tracer.", false, 0x8016EA60);
            SetErrorDetail(BDK_E_ADDRESS_VALIDATION_FAILURE, "Address validation error. Check the event log and the tracer.", false, 0x8016EA61);
            SetErrorDetail(BDK_E_ZIP_INVALID, "VERAZIP: Invalid ZIP code.", false, 0x8016EA6B);
            SetErrorDetail(BDK_E_STATE_INVALID, "VERAZIP: Invalid state code.", false, 0x8016EA6C);
            SetErrorDetail(BDK_E_ZIP_CITY_MISSING, "VERAZIP: Missing ZIP code or city name.", false, 0x8016EA6D);
            SetErrorDetail(BDK_E_STATE_ZIP_INVALID, "VERAZIP: Invalid state code/ZIP code combination.", false, 0x8016EA6E);
            SetErrorDetail(BDK_E_STATE_CITY_INVALID, "VERAZIP: Invalid state code/city name combination.", false, 0x8016EA6F);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID, "VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.", false, 0x8016EA70);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID2, "VERAZIP: Invalid state code/ZIP code/city name combination.", false, 0x8016EA71);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID3, "VERAZIP: Invalid state code/ZIP code/city name combination.", false, 0x8016EA72);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID4, "VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.", false, 0x8016EA73);
            SetErrorDetail(BDK_E_MULTIPLE_COUNTIES_FOUND, "VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.", false, 0x8016EA7D);
            SetErrorDetail(BDK_E_ZIP_INVALID_FOR_ENTERED_STATE, "VERAZIP: Invalid state code for ZIP code. Changed to correct state code.", false, 0x8016EA7E);
            SetErrorDetail(BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES, "VERAZIP: ZIP code has multiple city names.", false, 0x8016EA89);
            SetErrorDetail(BDK_E_MULTIPLE_CITIES_FOUND, "VERAZIP: City has multiple ZIP codes.", false, 0x8016EA8A);
            SetErrorDetail(BDK_E_BAD_CITYNAME_LENGTH, "Incorrect city name length.", false, 0x8016EA8B);
            SetErrorDetail(BDK_E_BAD_COUNTRYCODE_LENGTH, "Incorrect country code length.", false, 0x8016EA8C);
            SetErrorDetail(BDK_E_BAD_STATECODE_LENGTH, "Incorrect code length for state or province.", false, 0x8016EA8D);
            SetErrorDetail(BDK_E_BAD_ZIPCODE_LENGTH, "Incorrect zip code length.", false, 0x8016EA8E);
            SetErrorDetail(BDK_E_BAD_PRODUCTCODE_LENGTH, "Incorrect product code length.", false, 0x8016EA8F);
            SetErrorDetail(BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH, "Incorrect business location code length.", false, 0x8016EA90);
            SetErrorDetail(BDK_E_BAD_TRANSACTIONDATE_LENGTH, "Incorrect transaction date length.", false, 0x8016EA91);
            SetErrorDetail(BDK_E_BAD_VATREGISTRATION_LENGTH, "Incorrect VAT registration length.", false, 0x8016EA92);
            SetErrorDetail(BDK_E_BAD_CURRENCYCODE_LENGTH, "Incorrect currency code length.", false, 0x8016EA93);
            SetErrorDetail(BDK_E_BAD_WTCODE_LENGTH, "Incorrect WorldTax code length.", false, 0x8016EA94);
            SetErrorDetail(BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP, "Invalid input parameter passed to TaxWare or VeraZip.", false, 0x8016EA95);
            SetErrorDetail(BDK_E_INVALID_VATID_FORMAT, "The Vat ID provided is of invalid format.", false, 0x8016EA97);
            SetErrorDetail(BDK_E_INVALID_VATID_INVALID, "The Vat ID provided is invalid.", false, 0x8016EA98);
            SetErrorDetail(BDK_E_UNSUPPORTED_CHAR_EXIST, "Input string contains unsupported characters.", false, 0x8016EA9C);
            SetErrorDetail(BDK_E_ERROR_COUNTRYCODE_MISMATCH, "Country code in Address does not match with the country code in Account Info.", false, 0x8016EAA1);
            SetErrorDetail(BDK_E_ERROR_COUNTRYCODE_REQUIRED, "A Country code is required in Account Info.", false, 0x8016EAA6);
            SetErrorDetail(BDK_E_INVALID_TOKEN_SPECIFIED, "Token passed is Invalid.", false, 0x8016138D);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_BLACKLISTED, "The token is already blacklisted.", false, 0x80161392);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_UNBLACKLISTED, "The token is already un-blacklisted.", false, 0x80161393);
            SetErrorDetail(BDK_E_TOKEN_BLACKLISTED, "The specified token has been blacklisted.", false, 0x801613BF);
            SetErrorDetail(BDK_E_TOKEN_RANGE_BLACKLISTED, "The specified token belongs to a blacklisted token range.", false, 0x801613C4);
            SetErrorDetail(BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED, "The usage for the specified token has been exceeded.", false, 0x801613C9);
            SetErrorDetail(BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL, "Token Expiry date not set as may be duration based token was not activated correctly.", false, 0x801613CE);
            SetErrorDetail(BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS, "Failed while consumption to create an entry in token_instance_deal_subscription table.", false, 0x801613CF);
            SetErrorDetail(BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT, "Not found non-active token range to be activated.", false, 0x801613D3);
            SetErrorDetail(BDK_E_TOKEN_EXPIRED, "The specified token has expired.", false, 0x801613F1);
            SetErrorDetail(BDK_E_TOKEN_NOT_STARTED, "The specified token cannot be used yet.", false, 0x801613F6);
            SetErrorDetail(BDK_E_TOKEN_RANGE_NOT_ACTIVE, "The specified token has not been activated yet.", false, 0x801613FB);
            SetErrorDetail(BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE, "The reason code specified is not valid.", false, 0x8016141E);
            SetErrorDetail(BDK_E_TRACKING_GUID_NODATA, "The specified action is in progress.", false, 0x8016145A);
            SetErrorDetail(BDK_E_DUPLICATE_TOKEN_TRACKING_GUID, "The specified tracking has already been used", false, 0x8016145F);
            SetErrorDetail(BDK_E_ALREADY_ACTIVATED, "The specified token has already been activated", false, 0x8016146E);
            SetErrorDetail(BDK_E_INVALID_COMMITTED_STATUS, "Committed status is not valid for this API.", false, 0x80161470);
            SetErrorDetail(BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION, "The description specified is not valid.", false, 0x80161473);
            SetErrorDetail(BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE, "Blacklist Effective date passed was prior to the order creation date.", false, 0x80161478);
            SetErrorDetail(BDK_E_TOKEN_CONSUMED, "The Token has been consumed.", false, 0x8016147D);
            SetErrorDetail(BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS, "Part Number specified for the token import is not a valid part number for the associated token class.", false, 0x80161482);
            SetErrorDetail(BDK_E_INVALID_EXTERNAL_REFERENCE_ID, "External reference id is too long or invalid.", false, 0x80161483);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_DEACTIVATED, "The token is already deactivated.", false, 0x80161487);
            SetErrorDetail(BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH, "Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.", false, 0x80161491);
            SetErrorDetail(ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID, "Null parameter was passed for Token Class GUID during token class access verification.", false, 0x80161496);
            SetErrorDetail(BDK_E_INVALID_BOOKMARK, "The argument specified is not a valid bookmark.", false, 0x80161484);
            SetErrorDetail(BDK_E_INVALID_MAX, "The max argument must be between 1 and 50.", false, 0x80161485);
            SetErrorDetail(BDK_E_INTERNAL_ERROR_TOKEN, "Internal inconsistency in Token Database.", false, 0x80161455);
            SetErrorDetail(BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD, "Unable to retrieve event ID and billing impact for event.", false, 0x8016CD14);
            SetErrorDetail(BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT, "Unable to find line item matching event.", false, 0x8016CD46);
            SetErrorDetail(BDK_E_CANCELREFUND_OFFSET_OF_OFFSET, "Cannot process if there is an offset of an offset.", false, 0x8016CD78);
            SetErrorDetail(BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE, "This can't happen, both line item and related line item in the active list.", false, 0x8016CDAA);
            SetErrorDetail(BDK_E_INVALID_SESSION_KEY, "The session key passed in does not pass validation checks.", false, 0x8016768E);
            SetErrorDetail(BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID, "This object ID is not entitled to get a deliverable token.", false, 0x8016A0B4);
            SetErrorDetail(BDK_E_PRODUCT_KEY_NOT_AVAILABLE, "The token cannot be issued, either because the database is unavailable or there are no more unused tokens.", false, 0x80161488);
            SetErrorDetail(BDK_E_PIN_OR_SEQ_REQUIRED, "Either PIN or Sequence number is required as input parameter to validate Token.", false, 0x80161489);
            SetErrorDetail(BDK_E_INPUT_PARAM_MALFORMED, "Either Token Class Guid or Signature or Part Number should be specified for validating Token.", false, 0x8016148A);
            SetErrorDetail(BDK_E_INVALID_ADJUSTMENT_OFFSET, "The offset must be between -1 and 365 inclusive.", false, 0x8016CDB7);
            SetErrorDetail(BDK_E_INVALID_ITEM_INSTANCE_ID, "Invalid item instance ID.", false, 0x8016CDDC);
            SetErrorDetail(BDK_E_INVALID_REVERSE_REASON, "Invalid reason for reverse operation.", false, 0x8016CDDD);
            SetErrorDetail(BDK_E_TOO_MANY_ITEMS_IN_PURCHASE, "Only 1 item can be purchased at once.", false, 0x8016CDE0);
            SetErrorDetail(BDK_E_INVALID_OFFERING_TYPE, "PurchaseItem accepts only offers that are configured for item, PurchaseSubscription accepts only subscription offers and the account must be specified, or free trial offer and account must not be specified.", false, 0x8016CDE1);
            SetErrorDetail(BDK_E_PRICE_IS_NEGATIVE, "The price specified must be a positive value.", false, 0x8016CDE2);
            SetErrorDetail(BDK_E_DYNAMIC_PRICE_CONFIGURATION, "Cannot pass in a price and/or currency because it is configured on the item.", false, 0x8016CDE3);
            SetErrorDetail(BDK_E_DMP_MAX_BALANCE_EXCEEDED, "The maximum allowable DMP point balance is exceeded.", true, 0x8016CDE4);
            SetErrorDetail(BDK_E_CURRENCY_MISSING, "Calling partner needs to add a currency because it is not pre-configured.", false, 0x8016CDE5);
            SetErrorDetail(BDK_E_PENDING_ITEM_PURCHASE, "The user already has a pending purchase for for this item that must first be cancelled or completed.", false, 0x8016CDE6);
            SetErrorDetail(BDK_E_DMP_FLOW_NOT_ENABLED, "Unable to talk to DMP system.", true, 0x8016CDE7);
            SetErrorDetail(BDK_E_ITEM_ALREADY_REVERSED, "Item has been already reversed.", false, 0x8016CDE8);
            SetErrorDetail(BDK_E_ITEM_NOT_FULFILLED, "Reversing an item that has not been fulfilled.", false, 0x8016CDE9);
            SetErrorDetail(BDK_E_DMP_UNKNOWN_ERROR, "Unknown DMP error has occurred.", true, 0x8016CDEA);
            SetErrorDetail(BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE, "Payment method type does not support operation.", false, 0x8016CDEC);
            SetErrorDetail(BDK_E_INVALID_CANCEL_TRANSACTION_RESULT, "Redirect vendor returned an invalid CancelTransaction result.", false, 0x8016CDED);
            SetErrorDetail(BDK_E_CVM_MISSING, "CVM code Missing", false, 0x8016CDEE);
            SetErrorDetail(BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL, "A fre Trial cannot be purchased using an account. Use only the PUID", false, 0x8016CDEF);
            SetErrorDetail(BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH, "Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch", false, 0x8016CDF0);
            SetErrorDetail(BDK_E_DONOR_BENEFICIARY_SAME, "The donor and the beneficiary are the same.", false, 0x8016CDF1);
            SetErrorDetail(BDK_E_RENEWAL_DOES_NOT_EXISTS, "The renewal does not exists.", false, 0x8016AC9A);
            SetErrorDetail(BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS, "The token schedule rennewal exists for this offer.", false, 0x8016AC9C);
            SetErrorDetail(BDK_E_INVALID_DISCOUNT, "Specified Discount is invalid.", false, 0x8016ACAD);
            SetErrorDetail(BDK_E_INSERT_DISCOUNT, "Could not insert into a discount table.", false, 0x8016ACB2);
            SetErrorDetail(BDK_E_DISCOUNT_ALREADY_APPLIED, "Only one discount permitted per subscription.", false, 0x8016ACB7);
            SetErrorDetail(BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN, "Token is a discount coupon yet no discount was passed.", false, 0x8016ACBC);
            SetErrorDetail(BDK_E_DISCOUNT_TOKEN, "Token is a discount coupon and cannot be associated with a deal.", false, 0x8016ACC1);
            SetErrorDetail(BDK_E_INSERT_DISCOUNT_LOCALIZE, "Failed to insert record into discount_localize table.", false, 0x8016ACC6);
            SetErrorDetail(BDK_E_DISCOUNT_USAGE_EXCEEDED, "Per Account Usage limit was exceeded for discount.", false, 0x8016ACCB);
            SetErrorDetail(BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH, "Token class and discount are not a valid combination.", false, 0x8016ACD0);
            SetErrorDetail(BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER, "Partner does not have access to the specified customer type", false, 0x8016AD18);
            SetErrorDetail(BDK_E_NULL_CATEGORY, "Category should not be null.", false, 0x8016AC62);
            SetErrorDetail(BDK_E_NULL_ACCOUNTID, "Account ID cannot be null.", false, 0x8016AC63);
            SetErrorDetail(BDK_E_NULL_SUBSCRIPTIONREFID, "Subscription Ref ID cannot be null.", false, 0x8016AC64);
            SetErrorDetail(BDK_E_INVALID_SURVEYRESULTCODE, "Invalid Survey Result Code.", false, 0x8016AC65);
            SetErrorDetail(BDK_E_CD_NOTFOUND, "CD not found.", false, 0x8016AC66);
            SetErrorDetail(BDK_E_INVALID_ACCOUNTID, "Invalid Account ID.", false, 0x8016AC67);
            SetErrorDetail(BDK_E_INVALID_ANONYMOUS_INFO_XML, "Invalid AnonymousInfo Xml.", false, 0x8016AC68);
            SetErrorDetail(BDK_E_UNSUPPORTED_OBJECT_TYPE, "Unsupported object type.", false, 0x8016AC69);
            SetErrorDetail(BDK_E_INVALID_PHONE_XML, "Invalid Phone XML.", false, 0x8016AC6A);
            SetErrorDetail(BDK_E_INVALID_REQUESTOR_INFO, "Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters.", false, 0x8016AC6C);
            SetErrorDetail(BDK_E_PENDING_TRANSACTIONS, "There are pending transactions on this deal or subscription.", false, 0x8016ACAA);
            SetErrorDetail(BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH, "The lineitem id and settlement id do not match", false, 0x801652D0);
            SetErrorDetail(BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS, "Invalid original charge details", false, 0x801652D5);
            SetErrorDetail(BDK_E_PARTIAL_CHAREGBACK, "Partial Chargeback cannot be Processed", false, 0x801652D8);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL, "Invalid lineitem id for reversal", false, 0x801652DA);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_DATE, "Invalid chargeback date. Chargeback date must greater or equals to original settlement date", false, 0x801652E9);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_AMOUNT, "Invalid chargeback amount.", false, 0x801652EE);
            SetErrorDetail(BDK_E_ALREADY_OFFSET_TAX, "Tax was already offset for this line item.", false, 0x801652F1);
            SetErrorDetail(BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED, "mappoint is not enabled for the country code.", false, 0x80169CEB);
            SetErrorDetail(BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT, "SCS had error connecting to mappoint due to some network problems.", true, 0x8016CE4F);
            SetErrorDetail(BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT, "SCS had some internal error connecting that is preventing connection to mappoint.", true, 0x8016CE50);
            SetErrorDetail(BDK_E_ZERO_ADDRESSES_BY_MAPPOINT, "Mappoint returned 0 addresses.", false, 0x8016CE51);
            SetErrorDetail(BDK_E_UNKNOWN_ERROR, "UNKNOWN ERROR in MAPPOINT API.", true, 0x8016CE52);
            SetErrorDetail(BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR, "UNKNOWN ERROR ENCOUNTERED.", true, 0x8016ACA4);
            SetErrorDetail(BDK_E_INVALID_ADDRESSINFOXML, "Invalid AddressInfo Xml.", true, 0x8016CE54);
            SetErrorDetail(BDK_E_POST_BOX_ERROR_MAPPOINT, "Mappoint does not support Post Box Addresses currently.", false, 0x8016CE55);
            SetErrorDetail(BDK_E_MAPPOINT_CONNECTION_MAPPOINT, "The connection to Mappoint has timed out.", true, 0x8016CE56);
            SetErrorDetail(BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS, "Invalid Chargeback details provided as input", false, 0x8016D818);
            SetErrorDetail(BDK_E_CHARGEBACK_NOT_FOUND, "Chargeback id not found", false, 0x8016D81D);
            SetErrorDetail(BDK_E_CHARGEBACK_NOT_MATCH, "Chargeback id did not match", false, 0x8016D827);
            SetErrorDetail(BDK_E_DOUBLE_CHARGEBACK, "Double chargeback", false, 0x8016D836);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_LINEITEM_ID, "Invalid chargebacklineitem id", false, 0x8016D83B);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_REVERSAL_ID, "Invalid reversal chargeback id", false, 0x8016D84A);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID, "Invalid chargeback for reversal chargeback id", false, 0x8016D84F);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID, "invalid lineitem id for chargeback id", false, 0x8016D854);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_TYPE, "invalid lineitem id", false, 0x8016D859);
            SetErrorDetail(BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL, "Double chargeback for reversal", false, 0x8016D868);
            SetErrorDetail(BDK_E_COUNTRY_NOT_SUPPORTED, "The country of the address is not supported at this time", false, 0x8016ACA5);
            SetErrorDetail(BDK_E_COUNTRY_MAPPOINT_DISABLED, "SCS has temporarily disabled MAPPOINT support for this country", false, 0x8016ACA6);
            SetErrorDetail(BDK_E_INVALID_PARAMETER, "The input parameter is incorrect", true, 0x8016ACA7);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_ID, "Invalid ChargebackID Generation.", false, 0x8016283C);
            SetErrorDetail(BDK_E_CHARGEBACK_PROCESSING_FAILURE, "Error when Chargeback Processing Failure.", false, 0x8016283D);
            SetErrorDetail(BDK_E_INVALID_MERCHANT_REFERENCE, "Invalid Merchant Reference Number.", false, 0x8016283E);
            SetErrorDetail(BDK_E_CHARGEBACK_INFO_MISSING, "Error when any input details missing.", false, 0x8016283F);
            SetErrorDetail(BDK_E_RECORD_CHARGEBACK_FAILED, "Error while recording chargeback/reversal in Chargeback History table.", false, 0x80162840);
            SetErrorDetail(BDK_E_DOUBLE_CHARGEBACK_REVERSAL, "Double Chargeback Reversal", false, 0x80162841);
            SetErrorDetail(BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK, "Chargeback Processing Reversal", false, 0x80162842);
            SetErrorDetail(BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION, "Payment instrument not associated with subscription", false, 0x80162843);
            SetErrorDetail(BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED, "Subscription already converted or renewed", false, 0x80162844);
            SetErrorDetail(BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING, "Merchant Reference Number missing", false, 0x80162845);
            SetErrorDetail(BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER, "Invalid Encrypt Account number", false, 0x80162846);
            SetErrorDetail(BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL, "Subscription has been scheduled to renew", false, 0x80162847);
            SetErrorDetail(BDK_E_PROFILE_ALREADY_EXISTS, "Account holder's profile already exists.", false, 0x80162848);
            SetErrorDetail(BDK_E_PROFILE_DOES_NOT_EXIST, "Account holder's profile does not exist.", false, 0x80162849);
            SetErrorDetail(BDK_E_ACCOUNT_WITHOUT_ADDRESS, "Account does not have an address associated with it.", false, 0x8016284A);
            SetErrorDetail(BDK_E_NO_PAYOUT_PREFERENCE, "Payout preference (default) is not set.", false, 0x8016284B);
            SetErrorDetail(BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE, "Payout preference (default) can not be deleted.", false, 0x8016284C);
            SetErrorDetail(BDK_E_INVALID_PAYUSERINFOXML, "Invalid PayUserInfo XML.", false, 0x8016284D);
            SetErrorDetail(BDK_E_INVALID_USERPROFILEXML, "Invalid UserProfile XML.", false, 0x8016284E);
            SetErrorDetail(BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID, "Account ID must not be specified.", false, 0x8016284F);
            SetErrorDetail(BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED, "Description length exceeded", false, 0x80162850);
            SetErrorDetail(BDK_E_RIME_REJECTED, "RiME returns \"Rejected\"", false, 0x80162851);
            SetErrorDetail(BDK_E_RIME_INVALID_VALUE, "Invalid Values were sent to RiME", false, 0x80162852);
            SetErrorDetail(BDK_E_REFERRAL_CODE_NOT_FOUND, "Referral code not found in SCS database", false, 0x8016AC59);
            SetErrorDetail(ERROR_MISSING_PROV_INFO, "There is no existing provisioning information to complete this call", false, 0x8016D2FD);
            SetErrorDetail(BDK_E_INVALID_RESOURCE_TYPE, "Invalid Resource Type", false, 0x8016AC5A);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED, "fail when submit to payment provider", false, 0x80164E2A);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED, "declined when submit to payment provider", false, 0x80164E2B);
            SetErrorDetail(BDK_E_ENCRYPTION_FAILURE, "fail to encrypt file", false, 0x80164E2C);
            SetErrorDetail(BDK_E_DMP_FIRST, "BDK_E_DMP_FIRST", false, 0x8016FA00);
            SetErrorDetail(BDK_E_DMP_LAST, "BDK_E_DMP_LAST", false, 0x8016FDE7);
            SetErrorDetail(BDK_E_INVALID_TARGET_USER_INFORMATION, "Invalid target user information specified", false, 0x80167918);
            SetErrorDetail(BDK_E_INVALID_DELEGATE_USER_INFORMATION, "Invalid delegate user information", false, 0x80167919);
            SetErrorDetail(BDK_E_INVALID_SOURCE_USER_INFORMATION, "Invalid source information", false, 0x8016791A);
            SetErrorDetail(BDK_E_INVALID_TRANSACTION_INFORMATION, "Invalid transaction Id", false, 0x8016791B);
            SetErrorDetail(BDK_E_NO_MATCHING_TRANSACTION, "Transaction information passed in does not match the information stored", false, 0x8016791C);
            SetErrorDetail(BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION, "Unable to find transaction in PENDING_PAYOUT state matching the input parameters", false, 0x8016791D);
            SetErrorDetail(BDK_E_NO_MATCHING_PENDING_TRANSACTION, "Unable to find transaction in PENDING state matching the input parameters", false, 0x8016791E);
            SetErrorDetail(BDK_E_ORDER_LAYER_FIRST, "BDK_E_ORDER_LAYER_FIRST", false, 0x8016DAC1);
            SetErrorDetail(BDK_E_ORDER_LAYER_LAST, "BDK_E_ORDER_LAYER_LAST", false, 0x8016DEA8);
            SetErrorDetail(BDK_E_TRANSACTION_LAYER_FIRST, "BDK_E_TRANSACTION_LAYER_FIRST", false, 0x8016DEA9);
            SetErrorDetail(BDK_E_TRANSACTION_LAYER_LAST, "BDK_E_TRANSACTION_LAYER_LAST", false, 0x8016E290);
            SetErrorDetail(SCS_E_CERT_INAVLID, "SCS_E_CERT_INAVLID", false, 0x8016E678);
            SetErrorDetail(SCS_E_INAVLID_CALLING_PARTNER, "SCS_E_INAVLID_CALLING_PARTNER", false, 0x8016E679);
            SetErrorDetail(BDK_E_RISK_EVALUATION_FAILED, "BDK_E_RISK_EVALUATION_FAILED", false, 0x8016FDE9);
            SetErrorDetail(BDK_E_RISK_EVALUATION_EXCEPTION, "BDK_E_RISK_EVALUATION_EXCEPTION", false, 0x8016FDEA);
            SetErrorDetail(BDK_E_RISK_EVALUATION_UNDEFINED, "BDK_E_RISK_EVALUATION_UNDEFINED", false, 0x8016FDEB);
            SetErrorDetail(BDK_E_RISK_CONFIGURATION_ERROR, "BDK_E_RISK_CONFIGURATION_ERROR", false, 0x8016FDEC);
            SetErrorDetail(BDK_E_RISK_NEXT, "BDK_E_RISK_NEXT", false, 0x8016FDED);
            SetErrorDetail(BDK_E_DAV_APARTMENT, "Apartment number missing or not found", false, 0x8016FE4C);
            SetErrorDetail(BDK_E_DAV_INSUFFICIENT, "Insufficient address information", false, 0x8016FE4D);
            SetErrorDetail(BDK_E_DAV_ID, "House number or PO box not found", false, 0x8016FE4E);
            SetErrorDetail(BDK_E_DAV_MULTIPLE, "Multiple address matches found", false, 0x8016FE4F);
            SetErrorDetail(BDK_E_DAV_POBOX, "PO box identifier out of range", false, 0x8016FE50);
            SetErrorDetail(BDK_E_DAV_ROUTE, "Route service identified out of range", false, 0x8016FE51);
            SetErrorDetail(BDK_E_DAV_STREET, "Street name not found", false, 0x8016FE52);
            SetErrorDetail(BDK_E_DAV_POSTAL, "Postal code not found", false, 0x8016FE53);
            SetErrorDetail(BDK_E_DAV_GENERAL, "Genreal address error", false, 0x8016FE54);
            SetErrorDetail(BDK_E_DAV_MISSING_DATA, "Missing required address field(s)", false, 0x8016FE55);
            SetErrorDetail(BDK_E_DAV_INVALID_DATA, "Invalid address field(s)", false, 0x8016FE56);
            SetErrorDetail(BDK_E_DAV_SYSTEM_FAILURE, "System failure during address check", false, 0x8016FE57);
            SetErrorDetail(BDK_E_DAV_TIMEOUT, "Timeout during DAV check", false, 0x8016FE58);
            SetErrorDetail(BDK_E_DAV_DISABLED, "Delivery Address Verification system is not available at this time", false, 0x8016FE59);
            SetErrorDetail(BDK_E_RISK_LAST, "BDK_E_RISK_LAST", false, 0x8016FFFF);
            SetErrorDetail(BDK_E_RISK_CVV_E_REENTRY_REQUIRED, "CVV reentry required", true, 0x8016FDF0);
            SetErrorDetail(BDK_E_RISK_CVV_E_REENTRY_FAILED_RETRYABLE, "CVV reentry retryable failure", true, 0x8016FDF1);
            SetErrorDetail(BDK_E_RISK_CVV_E_REENTRY_FAILED_NONRETRYABLE, "CVV reentry non retryable failure", false, 0x8016FDF2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BillingExceptions.cs ===
//
// BillingExceptions.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;

namespace xonline.common.billing
{
    public class BillingException : Exception {
        public BillingException(string message)
            : base(message)
        {
        }

        public BillingException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }

    public class CultureException : BillingException
    {
        private int _cultureId = 0;

        public CultureException(string message)
            : base(message)
        {
        }

        public CultureException(int cultureId)
            : base("No culture for id " + cultureId)
        {
            _cultureId = cultureId;
        }

        public CultureException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        public CultureException(int cultureId, Exception innerException)
            : base("No culture for id " + cultureId, innerException)
        {
            _cultureId = cultureId;
        }

        public int CultureId
        {
            get { return _cultureId; }
        }
    }

    public class LanguageException : BillingException
    {
        private int _languageId;

        public LanguageException(int languageId)
            : base("No language for id " + languageId)
        {
            _languageId = languageId;
        }

        public LanguageException(int languageId, Exception innerException)
            : base("No language for id  " + languageId, innerException)
        {
            _languageId = languageId;
        }

        public int LanguageId
        {
            get { return _languageId; }
        }
    }

    public class CountryException : BillingException
    {
        private int _countryId;

        public CountryException(int countryId)
            : base("No country for id  " + countryId)
        {
            _countryId = countryId;
        }

        public CountryException(int countryId, Exception innerException)
            : base("No country for id  " + countryId, innerException)
        {
            _countryId = countryId;
        }

        public int CountryId
        {
            get { return _countryId; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BillingConfig.cs ===
//
// BillingConfig.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//

using System;
using System.Reflection;
using System.Net;
//using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.bcfgtrace)]

namespace xonline.common.billing
{
    public class BillingConfig
    {
        // master on-off switch for communicating with SCS
        // defualts to true
        public static bool ConnectToBilling
        {
            get
            {
                bool val = Config.GetBoolSetting(Setting.billing_connectToBilling);

                if (val == false)
                {
#if DEBUG || STRESS
                  Xom.NtEvent( XEvent.Id.COMMON_CONFIG_0, "Connection to SCS has been turned OFF via config database. "
                        + "This should NEVER happen in production." );
#else
                    if ( Config.IsTestEnvironment() == false )
                    {
                      Xom.NtEvent( XEvent.Id.COMMON_CONFIG_1, "billing_connectToBilling=no in config database, however this is NOT ALLOWED in retail builds in non-test environments and will be ignored. (compile with STRESS or DEBUG defined to force the setting to work)" );
                        val = true;
                    }
#endif
                }

                return val;
            }
        }

        // queue billing info if SCS is down or ConnectToBilling == false?
        // defaults to true
        public static bool QueueUserBillingInfo
        {
            get
            {
                return Config.GetBoolSetting(Setting.billing_queueUserBillingInfo);
            }
        }

        // pump the billing queue?
        // defaults to true
        public static bool PumpUserBillingInfoQueue
        {
            get
            {
                return Config.GetBoolSetting(Setting.billing_pumpUserBillingInfoQueue);
            }
        }

        // how often? (minutes)
        // defaults to 10
        public static uint PumpUserBillingInfoQueueInterval
        {
            get
            {
                uint val = 10;

                try
                {
                    val = Config.GetUIntSetting(Setting.billing_pumpUserBillingInfoQueueInterval);
                }
                catch (Exception e)
                {
                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_2, e, "Couldn't parse PumpUserBillingInfoQueueInterval ('" + val + "')!  Using default of 10.");
                }

                return val;
            }
        }

        // how long to wait for SCS?
        public static int BillingTimeout
        {
            get
            {
                int val = 30000;
                try
                {
                    val = 1000 * Config.GetIntSetting(Setting.billing_timeout);
                }
                catch (Exception e)
                {
                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_3, e, "Couldn't parse Setting.billing_timeout!  Defaulting to {0}.", val);
                }

                return val;
            }
        }

        // how long to wait after a timeout before talking to SCS again?
        public static int BillingTimeoutBlockInterval
        {
            get
            {
                int val = 3000;
                try
                {
                    val = 1000 * Config.GetIntSetting(Setting.billing_timeoutBlockInterval);
                }
                catch (Exception e)
                {
                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_4, e, "Couldn't parse Setting.billing_timeoutBlockInterval!  Defaulting to {0}.", val);
                }

                return val;
            }
        }


        // what errors are non-user errors?  these will show up in the eventlog and, if QueueUserBillingInfo is on, result in
        // the account info being queued and the error being hidden from the user.
        // defaults listed in GetDefaultNonUserErrors()
        public static uint[] NonBillingUserErrors
        {
            get
            {
                Init();

                return _nonBillingUserErrors;
            }
        }

        private static uint[] _nonBillingUserErrors = null;


        // the maximum number of concurrent outbound connections allowed from this server to SCS.
        // a value of zero here means that BillingProvider will use the .net default value.
        //
        public static uint BillingConnectionLimit
        {
            get
            {
                uint val = 0;

                try
                {
                    val = Config.GetUIntSetting(Setting.billing_connectionLimit);
                }
                catch (Exception e)
                {
                    val = 0;

                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_5, e,
                        "Couldn't parse Setting.billing_connectionLimit.  Using .NET default of {0}.", ServicePointManager.DefaultConnectionLimit
                    );
                }

                if (val > 0x7FFFFFFF)
                {
                    val = 0;

                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_6,
                        "Setting.billing_connectionLimit is too big. Using .NET default of {0}.", ServicePointManager.DefaultConnectionLimit
                    );
                }

                return val;
            }
        }

        public static bool AllowUrlOverrideInRequest
        {
            get
            {
                bool val = Config.GetBoolSetting(Setting.billing_allowUrlOverrideInRequest);
                if ( val == true && Config.IsTestEnvironment() == false )
                {
                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_9, "billing_allowUrlOverrideInRequest=true in config database, however this is NOT ALLOWED in non-test environments and will be ignored." );
                    val = false;
                }

                return val;
            }
        }

        public static bool AllowInjectedScsErrorInRequest
        {
            get
            {
                bool val = Config.GetBoolSetting(Setting.billing_allowInjectedScsErrorInRequest);

                if ( val == true && Config.IsTestEnvironment() == false )
                {
#if DEBUG || STRESS
                  Xom.NtEvent( XEvent.Id.COMMON_CONFIG_10, "billing_allowInjectedScsErrorInRequest=true in non-test environent (" + Config.Environment.Trim() + ") specified!!   Allowing due to DEBUG or STRESS build." );
#else
                  Xom.NtEvent( XEvent.Id.COMMON_CONFIG_11, "billing_allowInjectedScsErrorInRequest=true in config database, however this is NOT ALLOWED in non-test environments and will be ignored." );
                    val = false;
#endif
                }

                return val;
            }
        }

        static BillingConfig()
        {
            try
            {
                Init();
            }
            catch (Exception)
            {
            }
        }

        private static volatile bool _initialized = false;
        private static object _lockObject = new object();

        public static void Init()
        {
            if (_initialized == false)
            {
                lock (_lockObject)
                {
                    if (_initialized == false)
                    {
                        InitNonUserBillingErrors();

                        _initialized = true;
                    }
                }
            }
        }

        private static void InitNonUserBillingErrors()
        {
            if (BillingConfig.ConnectToBilling == false && BillingConfig.PumpUserBillingInfoQueue == true)
            {
                Xom.NtEvent( XEvent.Id.MC_BAD_CONFIG_DATA_1, "ConnectToBilling turned off will prevent PumpUserBillingInfoQueue from doing anything.");
            }

            string[] vals = Config.GetMultiSetting(MultiSetting.billing_nonUserBillingErrors);
            if ( vals != null && vals.Length > 0 )
            {
                uint[] nonUserErrors = new uint[vals.Length];

                try
                {
                    Type hrt = typeof(HResult);

                    for (int i = 0; i < vals.Length; i++)
                    {
                        FieldInfo f = hrt.GetField(vals[i].Trim());
                        if (f == null)
                        {
                            Xom.NtEvent( XEvent.Id.MC_BAD_CONFIG_DATA_2, "Unknown hresult ('" + vals[i] + "')!\r\n");
                            continue;
                        }
                        nonUserErrors[i] = (uint)f.GetValue(null);

                        Xom.Trace(XomAreaName.bcfgtrace, LogLevel.L_NORMAL, "BillingConfig: NonUserBillingError: " + vals[i]);
                    }

                    _nonBillingUserErrors = nonUserErrors;
                }
                catch(Exception e)
                {
                    Xom.NtEvent( XEvent.Id.COMMON_CONFIG_14, e, "Error parsing NonBillingUserErrors.");
                    _nonBillingUserErrors = GetDefaultNonUserErrors();
                }
            }
            else
            {
                _nonBillingUserErrors = GetDefaultNonUserErrors();
            }
        }

        private static uint[] GetDefaultNonUserErrors()
        {
            return new uint[] {
                HResult.XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_FAILED,
                HResult.XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_TIMEOUT,
                HResult.XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE,
                HResult.XONLINE_E_BILLING_TAXWARE_FAILURE,
                HResult.XONLINE_E_BILLING_ADDRESS_VALIDATION_FAILURE,
                HResult.XONLINE_E_BILLING_NOPERMISSION
            };
        }


        public static int GetApiTimeout(string apiName)
        {
            int ms = BillingTimeout;

            apiName = apiName.Trim();

            InjectedError err = BillingProvider.GetSessionInjectedError();
            if ( err != null && apiName.Equals(err.api, StringComparison.OrdinalIgnoreCase) && HResult.Succeeded(err.hr) )
            {
                ms = (int) (uint) err.hr;
                Xom.Trace(XomAreaName.bcfgtrace, LogLevel.L_HIGH, "BillingConfig.GetApiTimeout: using injected timeout of: " + ms.ToString("d") + " ms.");
                return ms;
            }

            string settingName = "billing_" + apiName + "Timeout";

            int clientType = BillingProvider.GetSessionClientType();

            if ( clientType == (int) SessionClientType.Xbox1Console )
            {
                settingName += "_Xbox1";
            }
            else if ( clientType == (int) SessionClientType.LiveService )
            {
                settingName += "_LiveService";
            }

            try
            {
                Type t = typeof(Setting);

                // find the const field defined for this setting name
                FieldInfo fi = t.GetField(settingName, BindingFlags.Static | BindingFlags.Public | BindingFlags.IgnoreCase);

                if ( fi == null )
                {
                    Xom.Trace(XomAreaName.bcfgtrace, LogLevel.L_HIGH, string.Format("BillingConfig.GetApiTimeout: no definition found for Setting.{0}; using default billing timeout of: {1} ms.", settingName, ms));
                    return ms;
                }

                string fieldName = (string) fi.GetValue(null);

                string settingValue = Config.GetSetting(fieldName);

                ms = XmlSafeConvert.ToInt32(settingValue) * 1000;

                Xom.Trace(XomAreaName.bcfgtrace, LogLevel.L_LOW, string.Format("BillingConfig.GetApiTimeout: Setting.{0}: found timeout of: {1} ms.", fieldName, ms));
                return ms;
            }
            catch (Exception e)
            {
                string msg = string.Format("BillingConfig.GetApiTimeout: exception encountered attempting to reflect Setting.{0}; using default billing timeout of: {1} ms.\r\nException: {2}", settingName, ms, e.ToString());
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_15, e, msg);
                Xom.Trace(XomAreaName.bcfgtrace, LogLevel.L_HIGH, msg);
                return ms;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BillingPerf.cs ===
using System.Diagnostics;
using xonline.common.mgmt;

namespace xonline.common.billing
{

    [XomPerformanceCounterCategoryAttr( "Partner: Billing", "Xbox Live Billing counters", true )]
    public class BillingCounters : XomPerformanceCounterCategory
    {
        static private BillingCounters _instance = new BillingCounters();
        static public  BillingCounters Current(string api)
        {
            if (api == null)
            {
                api = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (BillingCounters)_instance.GetInstance(api);
        }


        [XomPerformanceCounterAttr(
            "Billing API requests/sec",
            "Billing SOAP API requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsPerSecond;

        [XomPerformanceCounterAttr(
            "Billing API requests total",
            "Total Billing SOAP API requests made in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsTotal;

        [XomPerformanceCounterAttr(
            "Billing API failures/sec",
            "Number of unsuccessful results returned per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsFailedPerSecond;

        [XomPerformanceCounterAttr(
            "Billing API total failures",
            "Total number unsuccessful results returned in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsFailedTotal;

        [XomPerformanceCounterAttr(
            "Billing API timeouts/sec",
            "Number of timeouts making Billing SOAP API calls per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TimeoutsPerSecond;

        [XomPerformanceCounterAttr(
            "Billing API total timeouts",
            "Total number of timeouts making Billing SOAP API calls in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TimeoutsTotal;

        [XomPerformanceCounterAttr(
            "Billing API blocked calls/sec",
            "Number of Billing SOAP API calls blocked per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BlockedCallsPerSecond;

        [XomPerformanceCounterAttr(
            "Billing API total blocked calls",
            "Total number of Billing SOAP API calls blocked per second in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter BlockedCallsTotal;




        [XomPerformanceCounterAttr(
            "Avg. execution time",
            "Average time taken to execute SOAP requests against Billing",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter CallsTime;

        [XomPerformanceCounterAttr(
            "Avg. execution time base",
            "Base average time taken to execute SOAP requests against Billing",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter CallsTimeBase;
    }


    [XomPerformanceCounterCategoryAttr( "Partner: Billing Queue", "Xbox Live Billing Queue counters", true )]
    public class BillingQueueCounters : XomPerformanceCounterCategory
    {
        static public BillingQueueCounters Current = new BillingQueueCounters();

        [XomPerformanceCounterAttr(
            "Accounts added/second",
            "Accounts added to the queue per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AddsPerSecond;

        [XomPerformanceCounterAttr(
            "Accounts added total",
            "Total number of accounts added to the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AddsTotal;


        [XomPerformanceCounterAttr(
            "Accounts added avg. exec time",
            "Average time taken to add accounts to the billing queue",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AddsExecTime;

        [XomPerformanceCounterAttr(
            "Accounts added avg. exec time base",
            "Base average time taken to add accounts to the billing queue",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AddsExecTimeBase;


        [XomPerformanceCounterAttr(
            "Accounts pending total",
            "Total number of accounts pending creation in the current AppDomain.  " +
            "This value represents the last known size of the queue, and won't include " +
            "activity by other servers which affect the pending size.  Value is updated " +
            "only while the queue pump executes.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PendingTotal;

        [XomPerformanceCounterAttr(
            "Accounts created/second",
            "Number of queued accounts being created per second.  " +
            "Includes accounts which fail due to user error (i.e. BAD_ZIP).",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CreatedPerSecond;

        [XomPerformanceCounterAttr(
            "Accounts created total",
            "Total number of queued accounts created in the current AppDomain.  " +
            "Includes accounts which fail due to user error (i.e. BAD_ZIP).",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CreatedTotal;

        [XomPerformanceCounterAttr(
            "Accounts created avg. exec time",
            "Average time taken to create an account from the billing queue",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter CreateExecTime;

        [XomPerformanceCounterAttr(
            "Accounts created avg. exec time base",
            "Base average time taken to create an account from the billing queue",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter CreateExecTimeBase;



        [XomPerformanceCounterAttr(
            "Pump runs total",
            "Total times the queue pump has attempted to empty the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PumpRunsTotal;

        [XomPerformanceCounterAttr(
            "Pump avg. execution time",
            "Average time taken to pump the billing queue",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter PumpRunTime;

        [XomPerformanceCounterAttr(
            "Pump avg. execution time base",
            "Base average time taken to pump the billing queue",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter PumpRunTimeBase;

    }

    [XomPerformanceCounterCategoryAttr( "Partner: SCS PurchaseItem Queue", "Xbox Live SCS::PurchaseItem Queue Counters", true )]
    public class ScsQueueCounters : XomPerformanceCounterCategory
    {
        static public ScsQueueCounters Counters = new ScsQueueCounters();

        [XomPerformanceCounterAttr(
            "Scs::PurchaseItem attempts/second",
            "Scs::PurchaseItem attempts/second made by the Scs queue worker thread",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PurchaseItemAttemptsPerSecond;

        [XomPerformanceCounterAttr(
            "Scs::PurchaseItem attempts total",
            "Scs::PurchaseItem attempts total made by the Scs queue worker thread in this App Domain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PurchaseItemAttemptsTotal;

        [XomPerformanceCounterAttr(
            "Number of pending cancelable purchases",
            "Total number of purchases that need to be retried.  " +
            "This value represents the last known number, and won't include " +
            "activity by other servers which affect the pending size.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PurchaseItemPendingTotal;

        [XomPerformanceCounterAttr(
            "Scs::PurchaseItem pump runs total",
            "Total times the Scs::PurchaseItem pump has attempted to empty the queue in the current App Domain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PurchaseItemPumpRunsTotal;

        [XomPerformanceCounterAttr(
            "Scs::PurchaseItem Pump avg. execution time",
            "Average time taken to pump the Scs::PurchaseItem queue on all UODB partitions",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter PurchaseItemPumpRunTime;

        [XomPerformanceCounterAttr(
            "Scs::PurchaseItem Pump avg. execution time base",
            "Base average time taken to pump the Scs::PurchaseItem queue on all UODB partitions",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter PurchaseItemPumpRunTimeBase;
    }


    [XomPerformanceCounterCategoryAttr( "Partner: SwitchUserPassport Queue", "Xbox Live SwitchUserPassport Queue counters", true )]
    public class SwitchUserPassportQueueCounters : XomPerformanceCounterCategory
    {
        static public SwitchUserPassportQueueCounters Current = new SwitchUserPassportQueueCounters();

        [XomPerformanceCounterAttr(
            "Users added/second",
            "Users added to the queue per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AddsPerSecond;

        [XomPerformanceCounterAttr(
            "Users added total",
            "Total number of users added to the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AddsTotal;

        [XomPerformanceCounterAttr(
            "Users pending total",
            "Total number of users with interrupted Passport switch operations in the " +
            " current AppDomain.  This value represents the last known size of the queue " +
            " and won't include activity by other servers which affect the pending size.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PendingTotal;

        [XomPerformanceCounterAttr(
            "Users processed total",
            "Total number of users processed from the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ProcessedTotal;

        [XomPerformanceCounterAttr(
            "Pump runs total",
            "Total times the queue pump has attempted to empty the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PumpRunsTotal;

        [XomPerformanceCounterAttr(
            "Pump avg. execution time",
            "Average time taken to pump the SwitchUserPassport queue",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter PumpRunTime;

        [XomPerformanceCounterAttr(
            "Pump avg. execution time base",
            "Base average time taken to pump the SwitchUserPassport queue",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter PumpRunTimeBase;

    }

    [XomPerformanceCounterCategoryAttr( "Partner: XeReplaceUserPassport Queue", "Xbox Live XeReplaceUserPassport Queue counters", true )]
    public class XeReplaceUserPassportQueueCounters : XomPerformanceCounterCategory
    {
        static public XeReplaceUserPassportQueueCounters Current = new XeReplaceUserPassportQueueCounters();

        [XomPerformanceCounterAttr(
            "Users pending total",
            "Total number of users with interrupted Passport switch operations in the " +
            " current AppDomain.  This value represents the last known size of the queue " +
            " and won't include activity by other servers which affect the pending size.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PendingTotal;

        [XomPerformanceCounterAttr(
            "Users processed total",
            "Total number of users processed from the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ProcessedTotal;

        [XomPerformanceCounterAttr(
            "Pump runs total",
            "Total times the queue pump has attempted to empty the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PumpRunsTotal;

    }

    [XomPerformanceCounterCategoryAttr( "Partner: GraduateUser Queue", "Xbox Live GraduateUser Queue counters", true )]
    public class GraduateUserQueueCounters : XomPerformanceCounterCategory {
        static public GraduateUserQueueCounters Current = new GraduateUserQueueCounters();

        [XomPerformanceCounterAttr(
            "Users added/second",
            "Users added to the queue per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AddsPerSecond;

        [XomPerformanceCounterAttr(
            "Users added total",
            "Total number of users added to the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AddsTotal;

        [XomPerformanceCounterAttr(
            "Users pending total",
            "Total number of users with interrupted Passport switch operations in the " +
            " current AppDomain.  This value represents the last known size of the queue " +
            " and won't include activity by other servers which affect the pending size.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PendingTotal;

        [XomPerformanceCounterAttr(
            "Users processed total",
            "Total number of users processed from the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ProcessedTotal;

        [XomPerformanceCounterAttr(
            "Pump runs total",
            "Total times the queue pump has attempted to empty the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PumpRunsTotal;

        [XomPerformanceCounterAttr(
            "Pump avg. execution time",
            "Average time taken to pump the GraduateUser queue",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter PumpRunTime;

        [XomPerformanceCounterAttr(
            "Pump avg. execution time base",
            "Base average time taken to pump the GraduateUser queue",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter PumpRunTimeBase;

    }

    // @@@kgoodier Is this perf category really shared?
    [XomPerformanceCounterCategoryAttr("UserAccount FD: SetNoAgeOut", "Xbox Live Passport Proxy", true)]
    public class SetNoAgeOutQueueCounters : XomPerformanceCounterCategory
    {
        static public SetNoAgeOutQueueCounters Current = new SetNoAgeOutQueueCounters();

        [XomPerformanceCounterAttr(
            "Users added/second",
            "Users added to the queue per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AddsPerSecond;

        [XomPerformanceCounterAttr(
            "Users added total",
            "Total number of users added to the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AddsTotal;

        [XomPerformanceCounterAttr(
            "Users pending total",
            "Total number of users with interrupted set no age out operations in the " +
            " current AppDomain.  This value represents the last known size of the queue " +
            " and won't include activity by other servers which affect the pending size.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PendingTotal;

        [XomPerformanceCounterAttr(
            "Users processed total",
            "Total number of users processed from the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ProcessedTotal;

        [XomPerformanceCounterAttr(
            "Pump runs total",
            "Total times the queue has run to empty the queue in the current AppDomain",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RunsTotal;

        [XomPerformanceCounterAttr(
            "Run avg. execution time",
            "Average time taken to run the SetNoAgeOut queue",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter RunTime;

        [XomPerformanceCounterAttr(
            "Run avg. execution time base",
            "Base average time taken to run the SetNoAgeOut queue",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter PumpRunTimeBase;
    }


    [XomPerformanceCounterCategoryAttr("Partner: CTP", "Xbox Live CTP Transaction counters", true)]
    public class CTPTransactionCounters : XomPerformanceCounterCategory
    {
        static private CTPTransactionCounters _instance = new CTPTransactionCounters();
        static public CTPTransactionCounters Current(string api)
        {
            if (api == null)
            {
                api = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (CTPTransactionCounters)_instance.GetInstance(api);
        }

        [XomPerformanceCounterAttr(
            "CTP API requests/sec",
            "CTP SOAP API requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsPerSecond;

        [XomPerformanceCounterAttr(
            "CTP API requests total",
            "Total CTP SOAP API requests made in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsTotal;

        [XomPerformanceCounterAttr(
            "CTP API failures/sec",
            "Number of unsuccessful results returned per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsFailedPerSecond;

        [XomPerformanceCounterAttr(
            "CTP API total failures",
            "Total number unsuccessful results returned in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsFailedTotal;

        [XomPerformanceCounterAttr(
            "CTP API timeouts/sec",
            "Number of timeouts making CTP SOAP API calls per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TimeoutsPerSecond;

        [XomPerformanceCounterAttr(
            "CTP API total timeouts",
            "Total number of timeouts making CTP SOAP API calls in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TimeoutsTotal;

        [XomPerformanceCounterAttr(
            "CTP API blocked calls/sec",
            "Number of CTP SOAP API calls blocked per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BlockedCallsPerSecond;

        [XomPerformanceCounterAttr(
            "CTP API total blocked calls",
            "Total number of CTP SOAP API calls blocked per second in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter BlockedCallsTotal;


        [XomPerformanceCounterAttr(
            "Avg. execution time",
            "Average time taken to execute SOAP requests against CTP",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter CallsTime;

        [XomPerformanceCounterAttr(
            "Avg. execution time base",
            "Base average time taken to execute SOAP requests against CTP",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter CallsTimeBase;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BillingProviderException.cs ===
// WARNING WARNING WARNING WARNING WARNING WARNING
// ****************************************************
//
//                  DO NOT EDIT THIS FILE
// it has been generated from BillingProviderException.template.   edit that file instead.
//
// ****************************************************
// WARNING WARNING WARNING WARNING WARNING WARNING
//
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SCS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Web.Services.Protocols;
using System.Xml;

using xonline.common.mgmt;
using xonline.common.service;

using XHResult = xonline.common.service.HResult;

namespace xonline.common.billing
{

    /// <summary>
    /// BillingProviderException: Takes exceptions from the billing system, parses their XML, and wraps them up!
    /// </summary>
    public abstract class BillingProviderException : System.Exception, ExceptionWithHResult, IRetryableException
    {
        protected string  _Message;
        protected bool    _Retryable;
        protected HResult _bdkHResult;
        protected HResult _XonlineHResult;

        protected BillingProviderException(Exception e, HResult bdkHResult, string message, bool isRetryable) : base ("", e)
        {
            _Message = message;

            _Retryable = isRetryable;

            _bdkHResult = bdkHResult;

            _XonlineHResult = BdkError.BdkToXonlineHr(bdkHResult);
        }

        public override string Message
        {
            get { return _Message; }
        }

        public new HResult HResult
        {
            get { return _XonlineHResult; }
            set { _XonlineHResult = value; }
        }

        public HResult BdkHResult
        {
            get { return _bdkHResult; }
            set { _bdkHResult = value; }
        }

        public HResult XonlineHResult
        {
            get { return HResult; }
            set { HResult = value; }
        }

        public bool IsUserError
        {
            get { return Array.IndexOf(BillingConfig.NonBillingUserErrors, (uint)HResult) == -1; }
        }

        public bool IsRetryable
        {
            get { return _Retryable; }
        }

        public string BillingApi
        {
            get { return BdkWrapper.GetSessionBdkApi(); }
        }

        public static HResult ToHResult(Exception e, HResult hr)
        {
            if ( e is ExceptionWithHResult)
            {
                hr = ((ExceptionWithHResult)e).HResult;
            }

            return hr;
        }
    }

    public class NonUserBillingException : BillingProviderException, ExceptionWithEvent
    {
        protected XEvent.Id _EventId;

        public NonUserBillingException(Exception e, HResult bdkHResult, string message, bool isRetryable) : base(e, bdkHResult, message, isRetryable)
        {
            _EventId = XEvent.Id.SCS_NON_USER_EXCEPTION;
        }

        public XEvent.Id EventId
        {
            get { return _EventId; }
            set { _EventId = value; }
        }
    }

    public class UserBillingException : BillingProviderException, ExceptionWithoutEvent
    {
        public UserBillingException(Exception e, HResult bdkHResult, string message, bool isRetryable) : base(e, bdkHResult, message, isRetryable)
        {
        }
    }

    public class BdkExceptionUtil
    {
        public static void ParseBdkException(Exception e, out HResult hr, out string message, out bool isRetryable)
        {
            hr = HResult.E_FAIL;
            message = string.Empty;
            isRetryable = false;

            try
            {
                if ( !string.IsNullOrEmpty(e.Message) )
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Error from SCS: " + e.Message );

                    XmlTextReader xmlReader = new XmlTextReader(new StringReader(e.Message));

                    xmlReader.ReadStartElement("ErrorPackage");
                    xmlReader.ReadStartElement("ErrorHResult");
                    hr = HResult.Parse(xmlReader.ReadString());

                    xmlReader.ReadEndElement();
                    xmlReader.ReadStartElement("ErrorMessage");
                    message = xmlReader.ReadString();
                    xmlReader.ReadEndElement();

                    // SCS 4.0 won't have the <Retryable> element so don't
                    // raise an error if an XmlException is thrown
                    try
                    {
                        xmlReader.ReadStartElement("Retryable");
                        string retryable = xmlReader.ReadString();
                        isRetryable = retryable == "true";
                        xmlReader.ReadEndElement();
                    }
                    catch (XmlException)
                    {
                    }

                    // ignore the rest of the stuff.
                }
            }
            catch
            {
                // oh well, we tried.  keep around the original stuff.
                hr = HResult.E_FAIL;
                message = e.Message;
            }
        }

        public static bool IsBillingError(Exception e)
        {
            if ( e is SoapException && !string.IsNullOrEmpty(e.Message) )
            {
                return e.Message.StartsWith("<ErrorPackage><ErrorHResult>0x");
            }
            return false;
        }

        public static bool IsUserError(HResult bdkHResult)
        {
            HResult xonlineHr = BdkError.BdkToXonlineHr(bdkHResult);

            return Array.IndexOf(BillingConfig.NonBillingUserErrors, (uint)xonlineHr) == -1;
        }

        public static BillingProviderException CreateBillingProviderException(Exception e)
        {
            HResult bdkHResult;
            string message;
            bool isRetryable;

            ParseBdkException(e, out bdkHResult, out message, out isRetryable);

            if ( IsUserError(bdkHResult) )
            {
                return new UserBillingException(e, bdkHResult, message, isRetryable);
            }
            else
            {
                return new NonUserBillingException(e, bdkHResult, message, isRetryable);
            }
        }

        public static bool MapDMPError(HResult hr, out HResult dmpHR)
        {
            dmpHR = 0;

            // check for a DMP-specific error code
            if (0x8004FA00 <= hr && hr <= 0x8004FDE7)
            {
                uint DMPExternalErrorCode = hr - 0x8004FA00;
                switch (DMPExternalErrorCode)
                {
                case 8:
                    dmpHR = XHResult.XONLINE_E_DMP_E_REQUEST_CANNOT_BE_COMPLETED;
                    break;

                case 9:
                    dmpHR = XHResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED;
                    break;

                case 12:
                    dmpHR = XHResult.XONLINE_E_DMP_E_INSUFFICIENT_BALANCE;
                    break;

                case 20:
                    dmpHR = XHResult.XONLINE_E_DMP_E_PROMO_EXPIRED;
                    break;

                case 25:
                    dmpHR = XHResult.XONLINE_E_DMP_E_MAX_BALANCE_EXCEEDED;
                    break;

                case 26:
                    dmpHR = XHResult.XONLINE_E_DMP_E_MAX_ACQUISITION_EXCEEDED;
                    break;

                case 27:
                    dmpHR = XHResult.XONLINE_E_DMP_E_MAX_CONSUMPTION_EXCEEDED;
                    break;

                case 28:
                    dmpHR = XHResult.XONLINE_E_DMP_E_NO_MORE_PROMO_POINTS;
                    break;

                case 34:
                    dmpHR = XHResult.XONLINE_E_DMP_E_PROMOTION_LIMIT_LIFE_MAX;
                    break;

                case 0x3f:
                    dmpHR = XHResult.XONLINE_E_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED;
                    break;

                default:
                    dmpHR = XHResult.XONLINE_E_DMP_E_UNKNOWN_ERROR;
                    break;
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// This utility method translates an SCS HRESULT into an XONLINE-appropriate HRESULT,
        /// and logs integrity and other issues in the event logs.  Used in catch clauses.
        /// </summary>
        /// <param name="e">the billing exception</param>
        /// <returns></returns>
        public static HResult BDKtoXOFF(BillingProviderException e)
        {
            HResult hr;
            HResult outHr;
            HResult dmpHr;

            if (MapDMPError(e.HResult, out dmpHr))
                return dmpHr;

            // grab just the low 2 bytes for errors.
            hr = e.HResult & 0xFFFF;

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "BdkException.BDKtoXOFF: Translating BDK error " + hr + "..." );

            // check for ranges
            if(hr == 30145 || hr == 30165 || (hr >= 30210 && hr <= 30225))
            {
                outHr = XHResult.XONLINE_E_ACCOUNTS_BAD_CREDIT_CARD;
                goto Exit;
            }
            if(hr == 40031 || hr == 10021 || (hr >= 60000 && hr <= 60046))
            {
                outHr = XHResult.XONLINE_E_ACCOUNTS_BAD_BILLING_ADDRESS;
                goto Exit;
            }
            switch(hr)
            {

                //
                //  The following 4 HRESULTs are "special" billing errors that are passed directly to the client
                //  intact. (#18773 -benzotto)
                //
            case 30225:
                outHr = XHResult.XONLINE_E_BILLING_AUTHORIZATION_FAILED;
                break;
            case 30001:
                outHr = XHResult.XONLINE_E_BILLING_CREDIT_CARD_EXPIRED;
                break;
            case 40340:
                outHr = XHResult.XONLINE_E_BILLING_NON_ACTIVE_ACCOUNT;
                break;
            case 40575:
                outHr = XHResult.XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_STATUS;
                break;

                //
                //  Back to our regularly-scheduled result thunking.
                //

            case 30140:
                outHr = XHResult.XONLINE_E_ACCOUNTS_ACCOUNT_BANNED;      // account is banned
                break;
            case 30105:
                outHr = XHResult.XONLINE_E_ACCOUNTS_ACCOUNT_BANNED;      // account is banned
                break;
            case 40130:
                outHr = XHResult.XOFF_E_PURCHASE_DENIED;
                break;
            case 40165:
                outHr = XHResult.XOFF_E_INVALID_OFFER_ID;
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_18, e, "Integrity error: Invalid SCS Deal ID.");
                break;
            case 40200:
                outHr = XHResult.XOFF_E_NOTHING_TO_CANCEL;
                Xom.NtEvent( XEvent.Id.COMMON_CODE_2, e, "Integrity error: Subscription in SCS already cancelled.");
                break;
            case 40205:
                outHr = XHResult.XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ID;
                Xom.NtEvent( XEvent.Id.MC_SPS_INVALID_SUBSCRIPTION_ID, e, "Integrity error: Invalid Subscription ID.");
                break;
            case 40437:
                outHr = XHResult.XOFF_E_PURCHASE_DENIED;
                break;
            case 40438:
                outHr = XHResult.XOFF_E_INELIGIBLE_FOR_OFFER;
                Xom.NtEvent( XEvent.Id.MC_SPS_INELIGIBLE_FOR_OFFER, e, "Integrity error: Currency Mismatch\n");
                break;
            case 40441:
                outHr = XHResult.XOFF_E_ALREADY_OWN_MAX;     // can't buy more than the max!
                break;
            case 40453:
                outHr = XHResult.XOFF_E_INELIGIBLE_FOR_OFFER;
                Xom.NtEvent( XEvent.Id.MC_SPS_INELIGIBLE_FOR_OFFER_1, e, "Integrity error: Offering doesn't exist for this locale.");
                break;
            case 40470:
                outHr = XHResult.XOFF_E_PURCHASE_DENIED;     // standard purchase denied.
                break;
            case 40471:
                outHr = XHResult.XOFF_E_PURCHASE_DENIED;     // violation on this account.
                break;
            case 10008:
                outHr = XHResult.XOFF_E_INVALID_USER;
                Xom.NtEvent(XEvent.Id.MC_SPS_INVALID_PUID, e, "Integrity error: Invalid PUID.");
                break;
            case 10011:
                outHr = XHResult.XOFF_E_PURCHASE_DENIED;     // balance in declines
                break;
            case 40580:
                outHr = XHResult.XOFF_E_INVALID_OFFER_ID;
              Xom.NtEvent( XEvent.Id.MC_SPS_INVALID_OFFER_ID, e, "Integrity error: Invalid offering GUID.");
                break;
            case 11014:
                outHr = XHResult.XOFF_E_INVALID_OFFER_ID;
              Xom.NtEvent( XEvent.Id.MC_SPS_INVALID_OFFER_ID_1, e, "Integrity error: Invalid offering GUID.");
                break;
            case 25040:
                outHr = XHResult.XONLINE_E_ACCOUNTS_BAD_CREDIT_CARD;
                break;

            default:
                // This isn't one of the recognized SCS errors commonly associated with purchasing.  If the error
                // has a specific XONLINE_E_BILLING hr associated with it, return that instead.  If not, then
                // XOFF_E_BILLING_SERVER_ERROR will be returned.
                outHr = BdkError.BdkToXonlineHr(e);
                break;
            }

            Exit:
            return outHr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BillingProvider.cs ===
//
// BillingProvider.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SCS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using Billing.PSO;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.mgmt;
using xonline.common.utilities2;

[assembly: XomAreaDefinition(XomAreaName.spstrace)]

namespace xonline.common.billing
{
    public class BillingProvider : BdkWrapper
    {
        // master on-off switch for communicating with SCS,
        // and the random number generator for doing random IDs.
        private static Random _random = new Random();

        // prefix for all dummy IDs.  Because the real IDs are base-64 encoded, this dummy
        // prefix uses the $ character (which is NOT in the base-64 set) as a definitive
        // marker for phony strings.
        private const string DUMMY_ID_PREFIX       = "$XBOX!";
        private const string DUMMY_USER_PREFIX     = DUMMY_ID_PREFIX + "USER";
        private const string DUMMY_XONWATCH_PREFIX = DUMMY_ID_PREFIX + "WTCH";
        private const string DUMMY_XBOXCOM_PREFIX  = DUMMY_ID_PREFIX + ".COM";
        private const string DUMMY_LOCK_PREFIX     = DUMMY_ID_PREFIX + "LOCK";

        // data that persists across all connections
        public static string WsdlLocation
        {
            get
            {
                Init();

                string bdkUrl = Config.GetSetting(Setting.billing_bdkUrl);

                if ( string.IsNullOrEmpty(bdkUrl) )
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_82, "The billing_bdkUrl setting is not configured");
                }

                return bdkUrl;
            }
        }

        public static PsoEncrypterClass GetPsoEncrypter()
        {
            Init();

            // instantiate a new instance of PsoEncrypterClass to avoid
            // thread-safety issues with pso.dll (see LSG #6916)
            PsoEncrypterClass psoEncrypter = new PsoEncrypterClass();
            psoEncrypter.Initialize();
            if ( psoEncrypter.ErrorCode != 0x0 )
            {
                throw new Exception(string.Format("SCS PsoEncrypterClass.Initialize failed with error: 0x{0} ({1}", psoEncrypter.ErrorCode, psoEncrypter.ErrorDescription));
            }
            return psoEncrypter;
        }

        public static string Key
        {
            get
            {
                Init();

                return _key;
            }
        }

        // hard-coded string used as FriendlyName for all of our billing objects within SCS
        public static string FriendlyName
        {
            get { return "XBOX Live"; }
        }

        private static X509Certificate _clientCert;
        private static string _key;
        private static bool _initialized = false;
        private static bool _eventHandlersInitalized = false;
        private static object syncObject = new object();

        public new static void Init()
        {
            BdkWrapper.Init();

            if ( _initialized == false )
            {
                lock (syncObject)
                {
                    if ( _initialized == false )
                    {
                        if (BillingConfig.ConnectToBilling == true)
                        {
                            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingProvider.Init: loading DMP certificate..." );
                            GetClientCertificate();
                        }
                        else
                        {
                            Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "BillingProvider.Init: bypassing DMP certificate because connectToBilling=false..." );
                        }
                    }

                    // _eventHandlersInitalized should only ever be assigned during Init
                    if ( _eventHandlersInitalized == false )
                    {
                        XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(BillingProvider.OnControlRequest);

                        _eventHandlersInitalized = true;
                    }

                    _initialized = true;
                }
            }
        }


        // constructor
        public BillingProvider() : base()
        {
            Init();

            this.Url = WsdlLocation;

            this.PreAuthenticate = true;

            // set the proxy (if any) to use
            string proxyServer = Config.GetSetting(Setting.billing_proxy);
            if ( string.IsNullOrEmpty(proxyServer) )
            {
                this.Proxy = new WebProxy();
            }
            else
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingProvider.ctor: using proxy server: " + proxyServer + "..." );
                this.Proxy = new WebProxy(proxyServer, true);
            }

            // add the DMP cert to ClientCertificates
            if (BillingConfig.ConnectToBilling == true)
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingProvider.ctor: adding DMP certificate to list..." );

                GetClientCertificate();

                ClientCertificates.Add(_clientCert);
            }
            else
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "BillingProvider.ctor: bypassing adding DMP certificate because connectToBilling=false..." );
            }

            // Override URL if that's what we're supposed to do
            OverrideUrl();

            if(BillingConfig.BillingConnectionLimit > 0)
            {
                ServicePointManager.DefaultConnectionLimit = (int)BillingConfig.BillingConnectionLimit;
            }

            this.Timeout = BillingConfig.BillingTimeout;

            this.InitBillingKey();
        }

        public void InitBillingKey()
        {
            // if we cannot talk to SCS, we cannot encrypt
            if (BillingConfig.ConnectToBilling == false)
            {
                return;
            }

            // we need to go and get the latest key, unless perchance this instance has it already
            if (BillingProvider.Key == null)
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingProvider.InitBillingKey: retrieving billing key from SCS..." );

                string keyXml;
                string resultXml;

                this.GetKey(1, 1, "89BA9D19-9A04-4A15-A2A3-AF881B10FF53", out resultXml, out keyXml);

                // parse off the XML wrapper.
                using (XmlTextReader reader = new XmlTextReader(new StringReader(keyXml)))
                {
                    while(reader.Name != "Data") { reader.Read(); }

                    _key = reader.ReadElementString();
                }
            }
            else
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingProvider.InitBillingKey: billing key previously loaded from SCS." );
            }
        }

        // used to encrypt credit card numbers.
        public string EncryptNumber(string clearText)
        {
            string encryptedData;

            // If we shouldn't talk with billing, we can't encyrpt.  just return the raw text.
            if (BillingConfig.ConnectToBilling == false)
            {
                return clearText;
            }


            // make sure the billing key has been initialized
            if ( BillingProvider.Key == null )
            {
                InitBillingKey();
            }

            PsoEncrypterClass psoEncrypter = null;

            try
            {
                // now do the encryption
                psoEncrypter = GetPsoEncrypter();

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "Encrypting account number..." );

                encryptedData = psoEncrypter.Encrypt(clearText, BillingProvider.Key);

                if (psoEncrypter.ErrorCode != 0x0)
                {
                    throw new Exception(string.Format("SCS PsoEncrypterClass.Encrypt failed with error: 0x{0} ({1}", psoEncrypter.ErrorCode, psoEncrypter.ErrorDescription));
                }

                clearText = null;           // this object should go away ASAP!

                return encryptedData;
            }
            finally
            {
                if ( psoEncrypter != null )
                {
                    Marshal.ReleaseComObject(psoEncrypter);
                    psoEncrypter = null;
                }
            }
        }

        // used to derive the billing account id from a billing object id
        // (service instance id, subscription id, etc.)
        public static string ObjectIdToAccountId(string objectId)
        {
            string accountId = null;

            if ( BillingConfig.ConnectToBilling == false )
            {
                accountId = GenerateDummyId();
            }
            else
            {
                PsoEncrypterClass psoEncrypter = null;

                try
                {
                    psoEncrypter = GetPsoEncrypter();

                    accountId = psoEncrypter.ConvertObjectIDToAcctID(objectId);

                    // a failure above should have resulted in a COMException but just in case...
                    if ( psoEncrypter.ErrorCode != 0x0 )
                    {
                        throw new Exception(string.Format("SCS PsoEncrypterClass.ConvertObjectIDToAcctID failed with error: 0x{0} ({1}", psoEncrypter.ErrorCode, psoEncrypter.ErrorDescription));
                    }
                }
                finally
                {
                    if ( psoEncrypter != null )
                    {
                        Marshal.ReleaseComObject(psoEncrypter);
                        psoEncrypter = null;
                    }
                }
            }

            return accountId;
        }

        // Because the account id can be derived from the payment instrument id, it is possible
        // to validate payment instrument ids passed to XeOfferPurchase, PurchaseBillingOffer, etc.
        // without contacting SCS.
        public static void VerifyPaymentInstrumentId(string paymentInstrumentId, string accountId)
        {
            try
            {
                string derivedAccountId = BillingProvider.ObjectIdToAccountId(paymentInstrumentId);
                if ( derivedAccountId != accountId )
                {
                    throw new XRLException(HResult.XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_ID, XEvent.Id.PURCHASE_OFFERS_INVALID_ARG, string.Format("The paymentInstrumentId: {0} does not match the billing accountId: {1}  This may be the result of a hack attempt!", paymentInstrumentId, accountId));
                }
                else
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, string.Format("VerifyPaymentInstrumentId: paymentInstrumentId: {0} matches accountId: {1}", paymentInstrumentId, accountId));
                }
            }
            catch (COMException ce)
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "Caught COMException: hr = " + ((HResult) (uint) ce.ErrorCode) + ", exception: " + ce.ToString());

                throw new XRLException(HResult.XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_ID, XEvent.Id.PURCHASE_OFFERS_INVALID_ARG, string.Format("Failed to derive accountId from paymentInstrumentId: {0}  This error indicates the paymentInstrumentId was invalid and may be the result of a hack attempt!", paymentInstrumentId));
            }
        }

        // used to derive the subscription id from a service instance id
        public static string ServiceInstanceIdToSubscriptionId(string instanceId)
        {
            string subscriptionId = null;

            if ( BillingConfig.ConnectToBilling == false )
            {
                subscriptionId = "";
            }
            else
            {
                PsoEncrypterClass psoEncrypter = null;
                try
                {
                    psoEncrypter = GetPsoEncrypter();

                    subscriptionId = psoEncrypter.ConvertServiceRefIDToSubID(instanceId);

                    // a failure above should have resulted in a COMException but just in case...
                    if ( psoEncrypter.ErrorCode != 0x0 )
                    {
                        throw new Exception(string.Format("SCS PsoEncrypterClass.ConvertServiceRefIDToSubID failed with error: 0x{0} ({1}", psoEncrypter.ErrorCode, psoEncrypter.ErrorDescription));
                    }
                }
                finally
                {
                    if ( psoEncrypter != null )
                    {
                        Marshal.ReleaseComObject(psoEncrypter);
                        psoEncrypter = null;
                    }
                }
            }

            return subscriptionId;
        }

        // used to generate 16-character ID strings when not actually talking to billing.
        // all strings will begin with "XONLINE!" to hopefully set them apart.
        public static string GenerateDummyId()
        {
            return GenerateDummyId(false);
        }

        public static string GenerateDummyId(bool isXonWatch)
        {
            string prefix = isXonWatch ? DUMMY_XONWATCH_PREFIX : DUMMY_USER_PREFIX;
            return GenerateDummyAccountId(prefix);
        }

        public static string GenerateXboxComId()
        {
            return GenerateDummyAccountId(DUMMY_XBOXCOM_PREFIX);
        }

        public static string GenerateLockedAccountId()
        {
            return GenerateDummyAccountId(DUMMY_LOCK_PREFIX);
        }

        public static string GenerateDummyAccountId(string prefix)
        {
            Init();

            StringBuilder id = new StringBuilder(prefix);

            // generate 6 more characters.
            for( int i = 0; i < 6; i++ )
            {
                // new character between 'A' and 'z'
                id.Append((char)_random.Next(65, 122));
            }

            return id.ToString();
        }

        /// <summary>
        /// Predicate function to determine whether an ID is valid or a dummy one that we
        /// generated with the above function.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public static bool IsDummyId(string id)
        {
            return (id.StartsWith(DUMMY_ID_PREFIX));
        }
        public static bool IsXonWatchId(string id)
        {
            return (id.StartsWith(DUMMY_XONWATCH_PREFIX));
        }
        public static bool IsXboxComId(string id)
        {
            return (id.StartsWith(DUMMY_XBOXCOM_PREFIX));
        }
        public static bool IsLockedId(string id)
        {
            return (id.StartsWith(DUMMY_LOCK_PREFIX));
        }

        // If BillingConfig.AllowUrlOverrideInRequest is set, this will look at
        // the _tlsSessionAlternateUrl of the thread to see if we should use
        // a different URL
        private void OverrideUrl()
        {
            if ( BillingConfig.AllowUrlOverrideInRequest )
            {
                string alternateUrl = GetSessionAlternateUrl();
                if( string.IsNullOrEmpty(alternateUrl) == false )
                {
                    this.Url = alternateUrl;
                }
            }
        }

        /// <summary>
        /// Gets the DMP client certificate
        /// </summary>
        private static void GetClientCertificate()
        {
            // NOTE:
            // this method is called as part of Init so Init() should NOT be called here

            string clientCertSubject = Config.GetSetting(Setting.dmp_clientCertSubject);
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingProvider.GetClientCertificate: authenticating with certificate for: " + clientCertSubject);

            if ( _clientCert == null )
            {
                _clientCert = CertUtil.GetLocalMachineCertificate(clientCertSubject);
            }
        }


        /// <summary>
        /// Gets the URL of the BDK WSDL from config setting
        /// </summary>
        public static string BdkUrl
        {
            get
            {
                Init();

                string bdkUrl = Config.GetSetting(Setting.billing_bdkUrl);
                if ( bdkUrl == null || bdkUrl == string.Empty )
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_83, "The billing_bdkUrl setting is not configured");

                return bdkUrl;
            }
        }



        public void UpdatePMN (ulong ownerId, ulong userId, string accountId, string ownerPMN, string userPMN)
        {
            uint userHigh, ownerHigh;
            uint userLow,  ownerLow;
            string errorXml, roleXml;

            Int64Convert.ToUintPair((long)ownerId, out ownerHigh, out ownerLow);

            // do extra work if a juvenile account. (#23679)
            //
            // the only way to update a PMN with a User role in SCS 2.5 is to re-provision
            // an existing service component with the new PMN. So that's what we do here.
            //
            // note that this is kludgy-- it takes advantage of a side effect of the provisioning
            // call.  the actual result of the provisioning call, which is to generate a call to
            // our billing callback server, must be a no-op.  it is currently, whereby we will
            // throw away incoming ProvisionService requests after flagging the transaction as done.
            // in this case, the transaction will already be flagged as done, so it is a no-op.
            // it should definitely stay that way while this scenario needs to be supported.
            //
            if (ownerId != userId)
            {
                string siid, scid;
                HResult hr;
                ServiceInstance serviceSet = new ServiceInstance();

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Updating PMN for USER 0x" + userId.ToString("x") );
                Int64Convert.ToUintPair((long)userId, out userHigh, out userLow);

                //
                // Get a service instance ID to use
                //
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {

                    ws.ClearParameters();
                    ws.SetHashVal(userId);
                    ws.StoredProc = "dbo.p_xuacs_get_one_service_instance";

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter("@userpuid", userId);
                    ws.AddParameter(ParamType.OUTPUT, "@instanceid", "", 16);   // service instance ID
                    ws.AddParameter(ParamType.OUTPUT, "@componentid", "", 36);   // service component ID

                    // call the procedure
                    ws.ExecuteNonQuery();

                    hr = (uint)ws.GetIntParameter("@RETVAL");

                    if ( HResult.Failed(hr) )
                    {
                        throw new Exception("Database or data failure: Could not retrieve any valid service instance ID\n" +
                            "from the UODB for this user.  Could not change gamertag.\n" +
                            "hr = " + hr + "\n" +
                            "user PUID  = 0x" + userId.ToString("x") + "\n" +
                            "owner PUID = 0x" + ownerId.ToString("x"));
                    }

                    siid = ws.GetStringParameter("@instanceid");
                    scid = ws.GetStringParameter("@componentid");
                }

                if ( string.IsNullOrEmpty(siid) || string.IsNullOrEmpty(scid) )
                {
                    throw new Exception("Bad UODB data: Could not retrieve a valid service instance ID\n" +
                        "for this user, or else no valid Service Component ID.  \n" +
                        "Could not change gamertag. siid = '" + siid + "' scid = '" + scid + "'\n" +
                        "user PUID  = 0x" + userId.ToString("x") + "\n" +
                        "owner PUID = 0x" + ownerId.ToString("x"));
                }

                // now set the inputs for provisioning
                serviceSet.ServiceInstanceId = siid;
                serviceSet.ServiceComponentId = scid;
                serviceSet.PuidHigh = (int)userHigh;
                serviceSet.PuidLow  = (int)userLow;
                serviceSet.PMN      = userPMN;
                serviceSet.Role     = "User";
                serviceSet.Details  = "&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;";
                serviceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
                serviceSet.InstanceFriendlyName = userPMN;

                // make sure we have enough information
                serviceSet.ValidateFields();

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Provisioning with the following: " + serviceSet.ToXml("ServiceInstanceSet") );
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Calling SCS's ProvisionServices method via SOAP..." );

                // now we can make an actual provisioning call.
                this.ProvisionServices(0x0, 0x0, (int)ownerHigh, (int)ownerLow, serviceSet.ToXml("ServiceInstanceSet"), out errorXml);

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, ".. succeeded in sps!" );
            }

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "Updating PMN for OWNER 0x" + ownerId.ToString("x") );

            roleXml = "<RoleAssignment xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                "<Role>BillableAccountAdmin</Role>" +
                "<PUIDHigh>" + (int)ownerHigh + "</PUIDHigh>" +
                "<PUIDLow>" + (int)ownerLow + "</PUIDLow>" +
                "<PMN>" + ownerPMN + "</PMN></RoleAssignment>";

            this.AddRoleAssignment(0, 0, (int)ownerHigh, (int)ownerLow, accountId, roleXml, out errorXml);

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, ".. succeeded in sps!" );
        }

        //
        // Control stuff
        //

        internal static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage("BillingProvider help:\r\n  TestConnection\r\n\r\n", args.RequestId);
                        args.Handled = true;
                        break;

                    case "testconnection":
                        // make sure billing is enabled before doing anything
                        if ( false == BillingConfig.ConnectToBilling )
                        {
                            XomControlConnection.SendMessage("BillingProvider -- unable to test billing connection because billing_connectToBilling is disabled.\r\n\r\n", args.RequestId);
                            args.Handled = true;
                            return;
                        }

                        // Use longer SCS timeout values because these calls are
                        // initiated from the server rather than an Xbox client.
                        BillingProvider.SetSessionClientType(SessionClientType.LiveService);

                        XomControlConnection.SendMessage(ProcessTestConnectionRequest(args), args.RequestId);
                        args.Handled = true;
                        break;

                    case "bpencrypt":
                        // make sure billing is enabled before doing anything
                        if ( false == BillingConfig.ConnectToBilling )
                        {
                            XomControlConnection.SendMessage("BillingProvider -- unable to encrypt with billing key because billing_connectToBilling is disabled.\r\n\r\n", args.RequestId);
                            args.Handled = true;
                            return;
                        }

                        // Use longer SCS timeout values because these calls are
                        // initiated from the server rather than an Xbox client.
                        BillingProvider.SetSessionClientType(SessionClientType.LiveService);

                        string plainText = ( args.CommandArgs.Length > 0 ) ? args.CommandArgs[0] : "foobar";
                        BillingProvider bp = new BillingProvider();
                        string cipherText = bp.EncryptNumber(plainText);
                        XomControlConnection.SendMessage(string.Format("BillingProvider.EncryptNumber({0}) = {1}\r\n\r\n", plainText, cipherText), args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }


        internal static string ProcessTestConnectionRequest(ControlRequestEventArgs args)
        {
            StringBuilder strB = new StringBuilder();

            BillingProvider prov;

            try
            {
                strB.Append("Creating billing provider object...");

                prov = new BillingProvider();

                strB.Append( "success!\r\n\r\n" );
            }
            catch (Exception eInitialize)
            {
                strB.Append( "failure!!!\r\n " + eInitialize.ToString() );
                goto Cleanup;
            }

            try
            {
                string outStr;

                strB.Append( "Running testconnection against\r\n    " + WsdlLocation + "\r\n..." );

                prov.TestConnection( "Testing 1, 2, 3..!\r\n", out outStr );

                strB.Append( "success!\r\n" + outStr + "");
            }
            catch (Exception eTest)
            {
                strB.Append( "failure: " + eTest.ToString()  );
            }

            Cleanup:
                strB.Append("\r\n\r\n");
            return strB.ToString();
        }

    } // billingprovider class

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ConsoleIdUtil.cs ===
using System;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.sql.webstore;
using xonline.common.service;

using xonline.server.xmachine.fd.soap;

namespace xonline.common.utilities
{
    public class ConsoleIdUtil
    {
        // GetConsoleIdFromMachineId
        // This function uses UODB to resolve a machine id to its corresponding
        // console id
        //
        // Parameters:
        //  machineId - the machine id to be looked up
        // Return:
        //  consoleId
        public static string GetXbox360ConsoleIdStringFromMachineId(
            UInt64 machineId
        )
        {
            MachinePuidInfo[]  machinePuidInfo = null;
            ulong[]            requestedPuids  = new ulong[1];
            XMachineSoapClient connection      = new XMachineSoapClient();

            requestedPuids[0] = machineId;
            machinePuidInfo = connection.LookupConsoleIdsByMachinePuids(
                requestedPuids
                );

            if (machinePuidInfo == null || machinePuidInfo.Length == 0)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_LOGON_MISSING_CONSOLE_ID,
                    "Cannot find ConsoleId for " + (Puid) machineId
                    );
            }
            return machinePuidInfo[0].ConsoleId;
        }

        public static UInt64 GetConsoleIdFromMachineId(
            UInt64 machineId,
            byte platformType
        )
        {
            if (platformType == XOn.XPLT_PC)
            {
                return machineId & ~0xFFFF000000000000;
            }

            else if (platformType == XOn.XPLT_XBOX360)
            {
                return ConvertConsoleIdFromDecimalStringToUInt64(GetXbox360ConsoleIdStringFromMachineId(machineId));
            }

            else
            {
                throw new ArgumentException(
                    String.Format("GetConsoleIdFromMachineId only supports Xon.XPLT_PC ({0}) and Xon.XPLT_XBOX360 ({1}) for platformType, but you passed {2}",
                        XOn.XPLT_PC, XOn.XPLT_XBOX360, platformType),
                    "platformType");
            }

        }


        // ConvertConsoleIdFromDecimalStringToUInt64
        // The console id is stored in the database using the following
        // format: XE.DDDDDDDDDDDC where Ds are decimal digits and C
        // is the checksum of the decimal digits. The binary version
        // of the console id, which is what we're interested in, uses 5
        // bytes: 4 bytes and one nible for the decimal digits and the
        // remainining nibble for the checksum.
        //
        // Parameters:
        //  str - console id in decimal format
        // Return
        //  consoleId
        public static UInt64 ConvertConsoleIdFromDecimalStringToUInt64(string str)
        {
            // The console id is stored in the database using the following
            // format: XE.DDDDDDDDDDDC where Ds are decimal digits and C
            // is the checksum of the decimal digits. The binary version
            // of the console id, which is what we're interested in, uses 5
            // bytes: 4 bytes and one nible for the decimal digits and the
            // remainining nibble for the checksum.

            byte digit;
            char c;

            // Remove prefix and trailing spaces
            str = str.Trim().ToUpper();

            if(str.Length != 15 ||
              !str.StartsWith(XENON_PREFIX))
            {
                throw new Exception("Invalid console-id: "+str);
            }

            str = str.Remove(0, 3);

            // Convert significant digits
            UInt64 consoleId = 0;
            UInt32 checksum  = 0;

            for(int i=0; i < str.Length-1; i++)
            {
                c = str[i];

                if(c < '0' || c > '9')
                    throw new Exception("Invalid console-id: "+str);

                digit = (byte)(c - '0');
                consoleId = (consoleId * 10) + digit;
                checksum += digit;
            }

            // Verify id range
            if(consoleId == 0 || consoleId > 0x0FFFFFFFFF)
                throw new Exception("Invalid console-id: "+str);

            // Verify checksum
            checksum %= 10;
            digit = (byte)(str[str.Length-1] - '0');
            if((byte)checksum != digit)
                throw new Exception("Invalid console-id: "+str);

            // Build console id by incorporating the checksum nibble and
            // applying the console-id mask

            consoleId = ((consoleId << 4) | checksum) | XOn.XboxId.XenonConsoleBase;

            return consoleId;
        }

        // ConvertConsoleIdFromUInt64ToDecimalString
        // Same as ConvertConsoleIdFromDecimalStringToUInt64 but inverse operation.
        //  - consoleId: 64-bit console id
        // Returns:
        //  String using format XE.DDDDDDDDDDDC
        //
        public static string ConvertConsoleIdFromUInt64ToDecimalString(UInt64 consoleId)
        {
            string fmtcid = 
                XENON_PREFIX +
                ((consoleId >>4) & 0xFFFFFFFFF).ToString().PadLeft(11, '0') +
                (consoleId & 0xF).ToString();

            return fmtcid;
        }

        // ConvertConsoleIdFromByteArrayToDecimalString
        // Same as ConvertConsoleIdFromUInt64ToDecimalString but takes console byte array input.
        //  - consoleId: byte array (should be size CONSOLE_ID_SIZE
        // Returns:
        //  String using format XE.DDDDDDDDDDDC
        //
        public static string ConvertConsoleIdFromByteArrayToDecimalString(byte[] consoleId)
        {
            const int CONSOLE_ID_SIZE = 5;
            if ( CONSOLE_ID_SIZE != consoleId.Length )
            {
                throw new Exception( "Invalid console-id: CONSOLE_ID_SIZE != consoleId.Length"  );
            }
            
            UInt64 certificateConsoleId = 0;
            for ( int i = 0; i < CONSOLE_ID_SIZE; i++ )
            {
                certificateConsoleId <<= 8;
                certificateConsoleId |= consoleId[i];
            }
            
            return ConvertConsoleIdFromUInt64ToDecimalString( certificateConsoleId );
        }

        // TrimConsoleIdPrefix
        //  Trims the prefix from the string-version of a console-id 
        // Param:   string using format 'XX.DDDDDDDDDDDC'
        // Returns: string using format 'DDDDDDDDDDDC'
        public static string TrimConsoleIdPrefix(string consoleId)
        {
            if (IsValidPrefix(consoleId))
            {
                consoleId = consoleId.Substring(PREFIX_LENGTH);
            }
            return consoleId;
        }

        public static string AddConsoleIdPrefix(string consoleId, byte platformType)
        {
            // Make sure that there is no prefix already
            consoleId = TrimConsoleIdPrefix(consoleId);

            switch (platformType)
            {
            case XOn.XPLT_XBOX360:
                consoleId = XENON_PREFIX + consoleId;
                break;
            case XOn.XPLT_PC:
                consoleId = PC_PREFIX + consoleId;
                break;
            case XOn.XPLT_MOBILE:
                consoleId = MOBILE_PREFIX + consoleId;
                break;
            default:
                throw new ArgumentException(
                    String.Format(
                        "AddConsoleIdPrefix does not support platformType: {0}",
                        platformType
                        ),
                        "platformType"
                    );
            }
            return consoleId;
        }

        public static bool IsXenonPrefix(string consoleId)
        {
            if (IsValidPrefix(consoleId))
            {
                return consoleId.StartsWith(XENON_PREFIX);
            }
            return false;
        }

        public static bool IsPcPrefix(string consoleId)
        {
            if (IsValidPrefix(consoleId))
            {
                return consoleId.StartsWith(PC_PREFIX);
            }
            return false;
        }

        public static bool IsMobilePrefix(string consoleId)
        {
            if (IsValidPrefix(consoleId))
            {
                return consoleId.StartsWith(MOBILE_PREFIX);
            }
            return false;
        }

        public static bool IsValidPrefix(string consoleId)
        {
            if (String.IsNullOrEmpty(consoleId) == false &&
                consoleId.Length                >  PREFIX_LENGTH &&
                consoleId[PREFIX_OFFSET]        == '.')
            {
                return true;
            }
            return false;
        }

        // Routines to obtain a MachinePuid from a ConsoleID have been moved
        // to common\marketplace\machine\machine.cs

        private const string XENON_PREFIX  = "XE.";
        private const string PC_PREFIX     = "PC.";
        private const string MOBILE_PREFIX = "WM.";
        private const int    PREFIX_LENGTH = 3;
        private const int    PREFIX_OFFSET = 2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\BillingQueue.cs ===
using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Diagnostics;
using System.Security.Principal;

using Microsoft.Webstore.WstClient;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.mgmt;
using xonline.common.utilities;

[assembly: XomAreaDefinition(XomAreaName.spsqueuetrace)]

namespace xonline.common.billing
{

    public enum BillingQueueStatus
    {
        XboxComUser         = -2,
        XonWatchUser        = -1,
        Pending             =  0,
        InProgress          =  1,
        RequiresMaintenance =  2
    }


    public class BillingQueueItem
    {
        // @@slamb: Schema hack.   for some reason both the bin_payment_info and bin_iv fields of t_user_billing_queue were declared as varbinary(1984).
        //      bin_payment_info needs to be bigger, but bin_iv only needs 16.  so bytes 17..1984 of bin_iv contain overflow for bin_payment_info
        //
        public const int MAX_PAYINFO_BYTES         = 1984;
        public const int IV_BYTES                  = 16;
        public const int MAX_IV_BYTES              = 1984;
        public const int MAX_DATA_BYTES            = MAX_PAYINFO_BYTES + MAX_IV_BYTES - IV_BYTES;
        public const int MAX_ACCOUNT_XML_CHARS     = 3000;


        public static BillingQueueItem Load(ulong userPuid, bool changeToInProgress)
        {
            HResult hr;

            BillingQueueItem bqi = new BillingQueueItem();
            bqi.UserPuid = userPuid;

            byte[] actualIv;
            byte[] actualEncData;

            UTF7Encoding utfEnc = new UTF7Encoding(true);
            ASCIIEncoding ascEnc = new ASCIIEncoding();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_dequeue_billing_info";
                ws.SetHashVal(userPuid);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@ti_is_inprogress", (byte)(changeToInProgress == true ? 1 : 0));
                ws.AddParameter(ParamType.OUTPUT, "@bi_owner_puid", bqi.OwnerPuid);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_passport_puid", bqi.UserPassportPuid);
                ws.AddParameter(ParamType.OUTPUT, "@bi_owner_passport_puid", bqi.OwnerPassportPuid);
                ws.AddParameter(ParamType.OUTPUT, "@ti_account_type", bqi.AccountType);
                ws.AddParameter(ParamType.OUTPUT, "@bi_base_offer_id", bqi.OfferId);
                ws.AddParameter(ParamType.OUTPUT, "@vc_billing_offer_id", bqi.BillingOfferId, 36);
                ws.AddParameter(ParamType.OUTPUT, "@vc_billing_token", bqi.BillingToken, 1000);
                ws.AddParameter(ParamType.OUTPUT, "@vc_guid", "", 64);                  // guid
                ws.AddParameter(ParamType.OUTPUT, "@vc_purchase_guid", "", 64);                  // purchase guid
                ws.AddParameter(ParamType.OUTPUT, "@vc_account_info", "", 3000);                // account info xml
                ws.AddParameter(ParamType.OUTPUT, "@si_kek_version", (short)0);                // kek version number
                ws.AddParameter(ParamType.OUTPUT, "@bin_payment_iv", (new byte[1984]), 1984);      // iv for the encrypted payload
                ws.AddParameter(ParamType.OUTPUT, "@bin_payment_info", (new byte[1984]), 1984);      // encrypted payment info xml
                ws.AddParameter(ParamType.OUTPUT, "@si_payment_info_type", (short)bqi.PaymentInstrumentType); // payment instrument type
                ws.AddParameter(ParamType.OUTPUT, "@si_queue_status", (short)bqi.Status);
                ws.AddParameter(ParamType.OUTPUT, "@vc_alternate_url", "", 256);
                ws.AddParameter(ParamType.OUTPUT, "@vc_alternate_dmp_url", "", 256);
                ws.AddParameter(ParamType.OUTPUT, "@vc_billing_api", "", 64);
                ws.AddParameter(ParamType.OUTPUT, "@i_billing_hr", (int)bqi.BillingHResult);
                ws.AddParameter(ParamType.OUTPUT, "@i_xonline_hr", (int)bqi.XonlineHResult);
                ws.AddParameter(ParamType.OUTPUT, "@vc_billing_error_xml", bqi.BillingErrorXml, 4000);
                ws.AddParameter(ParamType.OUTPUT, "@vc_ip_address", string.Empty, 16);
                ws.AddParameter(ParamType.OUTPUT, "@vc_device_id", string.Empty, 64);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (hr != HResult.S_OK) return null;

                bqi.OwnerPuid = (ulong)ws.GetLongParameter("@bi_owner_puid");
                bqi.UserPassportPuid = (ulong)ws.GetLongParameter("@bi_user_passport_puid");
                bqi.OwnerPassportPuid = (ulong)ws.GetLongParameter("@bi_owner_passport_puid");
                bqi.AccountType = (byte)ws.GetByteParameter("@ti_account_type");
                bqi.OfferId = (ulong)ws.GetLongParameter("@bi_base_offer_id");
                bqi.BillingOfferId = ws.GetStringParameter("@vc_billing_offer_id");
                bqi.BillingToken = ws.GetStringParameter("@vc_billing_token");
                bqi.Guid = ws.GetStringParameter("@vc_guid");
                bqi.PurchaseGuid = ws.GetStringParameter("@vc_purchase_guid");
                bqi.AccountInfoXml = utfEnc.GetString(ascEnc.GetBytes(ws.GetStringParameter("@vc_account_info")));
                bqi.KeyEncryptionKeyVersion = (int)ws.GetShortParameter("@si_kek_version");
                actualIv = ws.GetByteArrayParameter("@bin_payment_iv");
                actualEncData = ws.GetByteArrayParameter("@bin_payment_info");
                bqi.PaymentInstrumentType = (PaymentInstrumentTypeEnum)ws.GetShortParameter("@si_payment_info_type");
                bqi.Status = (BillingQueueStatus)ws.GetShortParameter("@si_queue_status");
                bqi.AlternateUrl = ws.GetStringParameter("@vc_alternate_url");

                if(bqi.AlternateUrl == string.Empty)
                    bqi.AlternateUrl = null;

                bqi.AlternateDmpUrl = ws.GetStringParameter("@vc_alternate_dmp_url");
                if (bqi.AlternateDmpUrl == string.Empty)
                    bqi.AlternateDmpUrl = null;

                bqi.BillingApi = ws.GetStringParameter("@vc_billing_api");
                bqi.BillingHResult = (uint) ws.GetIntParameter("@i_billing_hr");
                bqi.XonlineHResult = (uint) ws.GetIntParameter("@i_xonline_hr");
                bqi.BillingErrorXml = ws.GetStringParameter("@vc_billing_error_xml");
                bqi.IpAdress = ws.GetStringParameter("@vc_ip_address");
                bqi.DeviceId = ws.GetStringParameter("@vc_device_id");

            }

            bqi._isNew = false;

            bqi.EncryptedPayInfoIV = new byte[IV_BYTES];
            Array.Copy(actualIv, bqi.EncryptedPayInfoIV, IV_BYTES);

            bqi.EncryptedPayInfoXml = new byte[MAX_DATA_BYTES];
            Array.Copy(actualEncData, bqi.EncryptedPayInfoXml, actualEncData.Length);
            Array.Copy(actualIv, IV_BYTES, bqi.EncryptedPayInfoXml, actualEncData.Length, MAX_IV_BYTES - IV_BYTES);

            return bqi;
        }

        public ulong UserPuid;
        public ulong OwnerPuid;
        public ulong UserPassportPuid;
        public ulong OwnerPassportPuid;
        public byte AccountType;
        public ulong OfferId;
        public string BillingOfferId;
        public string BillingToken;
        public string Guid;
        public string PurchaseGuid;
        public BillingQueueStatus Status;
        public string AlternateUrl;
        public string AlternateDmpUrl;

        public string AccountInfoXml;
        public PaymentInstrumentTypeEnum PaymentInstrumentType;
        public byte[] EncryptedPayInfoXml;
        public byte[] EncryptedPayInfoIV;
        public int    KeyEncryptionKeyVersion;

        public string BillingApi;
        public uint   BillingHResult;
        public uint   XonlineHResult;
        public string BillingErrorXml;
        public string IpAdress;
        public string DeviceId;

        public void Save()
        {
            byte[] actualIv;
            byte[] actualEncData;
            string encodedAccountInfoXml;


            if (EncryptedPayInfoIV.Length != IV_BYTES)
            {
                throw new Exception("Unexpected iv size from KEKCryptoMgr.EncryptWithKEK()!   Expected: " + IV_BYTES + "   Acutal: " + EncryptedPayInfoIV.Length);
            }

            if (EncryptedPayInfoXml.Length > MAX_DATA_BYTES)
            {
                throw new Exception("Encrypted data too large to be saved in existing fields!  Max: " + MAX_DATA_BYTES + "  Actual: " + EncryptedPayInfoXml.Length);
            }

            // copy over iv to the full-sized field
            actualIv = new byte[MAX_IV_BYTES];
            Array.Copy(EncryptedPayInfoIV, actualIv, IV_BYTES);

            // copy over payInfo to the full-sized field
            actualEncData = new byte[MAX_PAYINFO_BYTES];
            Array.Copy(EncryptedPayInfoXml, actualEncData, Math.Min(EncryptedPayInfoXml.Length, MAX_PAYINFO_BYTES));

            if (EncryptedPayInfoXml.Length > MAX_PAYINFO_BYTES)
            {
                // payinfo field too small, copy the remainder to unused portion of IV
                Array.Copy(EncryptedPayInfoXml, MAX_PAYINFO_BYTES, actualIv, IV_BYTES, EncryptedPayInfoXml.Length - MAX_PAYINFO_BYTES);
            }


            UTF7Encoding utfEnc = new UTF7Encoding(true);
            ASCIIEncoding ascEnc = new ASCIIEncoding();

            encodedAccountInfoXml = ascEnc.GetString(utfEnc.GetBytes(AccountInfoXml));
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User: " + UserPuid + ", original account xml size: " + AccountInfoXml.Length + "  encoded size: " + encodedAccountInfoXml.Length);
            if (encodedAccountInfoXml.Length > MAX_ACCOUNT_XML_CHARS)
            {
                throw new Exception("Encoded AccountXml too large!   Max: " + MAX_ACCOUNT_XML_CHARS + "   Actual: " + encodedAccountInfoXml.Length);
            }



            Debug.Assert(_isNew == false);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_xuacs_set_queued_billing_info";

                ws.SetHashVal(UserPuid);
                ws.AddParameter("@bi_user_puid", UserPuid);
                ws.AddParameter("@bi_owner_puid", OwnerPuid);
                ws.AddParameter("@bi_user_passport_puid", UserPassportPuid);
                ws.AddParameter("@bi_owner_passport_puid", OwnerPassportPuid);
                ws.AddParameter("@ti_account_type", AccountType);
                ws.AddParameter("@bi_base_offer_id", OfferId);
                ws.AddParameter("@vc_billing_offer_id", BillingOfferId);
                ws.AddParameter("@vc_billing_token", BillingToken);
                ws.AddParameter("@vc_guid", Guid);
                ws.AddParameter("@vc_purchase_guid", PurchaseGuid);
                ws.AddParameter("@vc_account_info", encodedAccountInfoXml);
                ws.AddParameter("@si_kek_version", KeyEncryptionKeyVersion);
                ws.AddParameter("@bin_iv", actualIv);
                ws.AddParameter("@bin_payment_info", actualEncData);
                ws.AddParameter("@si_payment_info_type", (short)PaymentInstrumentType);
                ws.AddParameter("@si_queue_status", (short)Status);
                ws.AddParameter("@vc_billing_api", BillingApi);
                ws.AddParameter("@i_billing_hr", (int)BillingHResult);
                ws.AddParameter("@vc_billing_error_xml", BillingErrorXml);
                ws.AddParameter("@i_xonline_hr", (int)XonlineHResult);
                ws.AddParameter("@vc_ip_address", IpAdress);
                ws.AddParameter("@vc_device_id", DeviceId);

                ws.ExecuteNonQuery();
            }
        }


        public Account Account
        {
            get
            {
                byte[] rawBytes;
                UTF8Encoding enc = new UTF8Encoding();
                Account acct = new Account();
                acct.FromXml(AccountInfoXml, "AccountInfo");

                // When loading the account from SCS, the UserPhone ends up
                // non-null but initialzed to empty data.  Make the billing
                // queue case consistent with SCS.
                if ( acct.UserPhone == null )
                {
                    acct.UserPhone = new Phone();
                }

                KEKCryptoMgr.DecryptWithKEK( KeyEncryptionKeyVersion, EncryptedPayInfoIV, EncryptedPayInfoXml, out rawBytes );

                acct.PayInfo = new PaymentInfo();

                if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.None )
                {
                    acct.PayInfo.PaymentInstrumentType = PaymentInstrumentType;
                }
                else
                {
                    acct.PayInfo.FromXml( enc.GetString(rawBytes), "PaymentInstrumentInfo");
                }

                // If a CVM code is present, clear it now as it is not allowable to store it.
                // SCS will not fail authorization if the CVM code is missing so at worst, there
                // may be a false positive authorization for someone who got queued.
                if ( acct.PayInfo != null && acct.PayInfo.CreditCard != null )
                {
                    acct.PayInfo.CreditCard.EncryptedCvmCode = null;

                    if ( !string.IsNullOrEmpty(acct.PayInfo.CreditCard.CvmCode) )
                    {
                        acct.PayInfo.CreditCard.CvmCode = "";
                    }
                }

                return acct;
            }

            set
            {
                Account acct = (Account)value;
                AccountInfoXml = acct.ToXml();

                // encrypt the XML payload.
                KeyEncryptionKeyVersion = KEKCryptoMgr.GetKeyVersion();

                KEKCryptoMgr.EncryptWithKEK( KeyEncryptionKeyVersion, GetPayInfoBytes(acct.PayInfo.ToXml("PaymentInstrumentInfo")), out EncryptedPayInfoIV, out EncryptedPayInfoXml);
            }
        }

        public static byte[] GetPayInfoBytes(string payInfo)
        {
            UTF8Encoding enc = new UTF8Encoding();
            byte[] usedBytes;
            byte[] paddedBytes;

            usedBytes = enc.GetBytes(payInfo);
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "EncryptedPayInfoXml bytes used: " + usedBytes.Length + "   original string length: " + payInfo.Length);
            if (usedBytes.Length > MAX_DATA_BYTES)
            {
                throw new XRLException(HResult.XONLINE_E_OFFERING_PAYMENT_INFO_TOO_LONG, XEvent.Id.COMMON_BILLING_CODE_219, "UTF8-Encoded string exceeds max length of " + MAX_DATA_BYTES + " bytes!  the bin_account_info column in t_user_billing_queue is too small.  actual length = " + usedBytes.Length);
            }


            // @@slamb: Schema hack.  wsreader returns the max number of bytes avilable in a varbinary field, not just the number used.
            paddedBytes = new byte[MAX_DATA_BYTES];
            Array.Copy(usedBytes, paddedBytes, usedBytes.Length);

            return paddedBytes;
        }


        public bool CreateInBilling(User u)
        {
            bool isCxnOk = true;
            Price price;
            string subscriptionId = "";
            string serviceInstanceId = "";
            string acctPayInfoId = "";
            ulong billingPuid;

            if ( AccountType == User.Xbox1Account )
            {
                billingPuid = OwnerPuid;
            }
            else
            {
                billingPuid = UserPassportPuid;
            }

            try
            {
                // create account, if necessary
                //
                if (BillingProvider.IsDummyId(u.AccountId))
                {
                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User: " + u.Puid + ", Attempting to create account for puid 0x" + u.Puid.ToString("X8") + " in SCS...");

                    // innocent until proven guilty.. (20165)
                    u.BillingAccountStatus = HResult.S_OK;

                    Account acct = this.Account;
                    acct.CountryCode = CountryDictionary.CountryCode(u.CountryId);

                    //
                    // If the user ended up in the queue with a payment instrument
                    // specified but no account number, flag that now.
                    //
                    // A combination of client and server bugs resulted in an
                    // exploit where a user could create a perma-queued account
                    // in a 12 month offer without specifying a credit card.
                    //
                    if ( acct.PayInfo != null )
                    {
                        PaymentInstrumentTypeEnum piType = acct.PayInfo.PaymentInstrumentType;
                        if ( piType == PaymentInstrumentTypeEnum.CreditCard || piType == PaymentInstrumentTypeEnum.DirectDebit )
                        {
                            string accountNumber;
                            string encryptedAccountNumber;

                            if ( piType == PaymentInstrumentTypeEnum.CreditCard )
                            {
                                accountNumber = acct.PayInfo.CreditCard.AccountNumber;
                                encryptedAccountNumber = acct.PayInfo.CreditCard.EncryptedAccountNumber;
                            }
                            else
                            {
                                accountNumber = acct.PayInfo.DirectDebit.AccountNumber;
                                encryptedAccountNumber = acct.PayInfo.DirectDebit.EncryptedAccountNumber;
                            }

                            // if the accountNumber is empty, encryptedAccountNumber must be populated
                            if ( string.IsNullOrEmpty(accountNumber) && string.IsNullOrEmpty(encryptedAccountNumber) )
                            {
                                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_HIGH, "BillingQueueItem.CreateInBillingProvider: user: 0x" + u.Puid.ToString("X") + " has an empty account number.  This should have been caught by the client!");

                                u.BillingAccountStatus = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                                u.Save();

                                this.XonlineHResult = u.BillingAccountStatus;
                                this.Status = BillingQueueStatus.RequiresMaintenance;
                                this.Save();

                                return true;
                            }
                        }
                    }

                    acct.CreateInBillingProvider(billingPuid, u.BillingOwnerPMN, this.Guid);

                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + u.Puid + ", Created account for gamertag: " + u.GamerTag + ", puid: 0x" + billingPuid.ToString("X") + " (acct id: " + acct.Id + ")!");

                    // save the payment instrument id, if any
                    acctPayInfoId = acct.PaymentInstrumentId;

                    // save updated account info to uodb
                    //
                    u.AccountId = acct.Id;
                    u.Save();
                }
                else
                {
                    // find the payment instrument (if any) used when creating
                    // the account
                    PaymentInstrumentInfoSet payInfoSet = PaymentInstrumentInfoSet.GetPaymentInstruments(u.BillingPuid, u.AccountId, false);

                    if ( payInfoSet.PaymentInstrumentInfoList.Count > 0 )
                    {
                        PaymentInfo pi = (PaymentInfo) payInfoSet.PaymentInstrumentInfoList[0];
                        acctPayInfoId = pi.Id;
                    }
                }

                Offer o = Offer.CreateInstance(OfferId);

                string billingToken = o.IsXenonOffer ? BillingToken : "";

                // for Xenon offers, if a token is present, use it and don't
                // send a payment instrument id
                if ( o.IsXenonOffer && billingToken != null && billingToken.Length > 0 )
                {
                    acctPayInfoId = "";
                }

                // base subscription purchase
                //
                if ( BillingOfferId != null && BillingOfferId != "" )
                {
                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + u.Puid + ", Attempting to purchase base subscription (0x" + OfferId.ToString("X8") + ") for puid 0x" + u.Puid.ToString("X8") + " in SCS...");

                    if ( u.AccountType == User.Xbox1Account )
                    {
                        Offering.Purchase(BillingOfferId,
                            (long)u.BillingPuid,
                            (long)u.Puid,
                            u.BillingPMN,
                            u.AccountId,
                            false,
                            acctPayInfoId,
                            PurchaseGuid,
                            null,
                            out price,
                            out subscriptionId,
                            out serviceInstanceId);
                    }
                    else if ( u.AccountType == User.XenonAccount )
                    {
                        Offering.PurchaseEx(
                            BillingOfferId,
                            u.BillingPuid,
                            u.Puid,
                            u.BillingPMN,         // always the User's PMN
                            u.AccountId,
                            acctPayInfoId,
                            billingToken,
                            PurchaseGuid,
                            o.ServiceComponentId, // expected service component id
                            out price,
                            out subscriptionId,
                            out serviceInstanceId);

                        // if any reward is associated with the offer,
                        // process it now
                        if ( o.HasReward(u.CountryId, (int)TierEnum.NewUser) )
                        {
                            Debug.Assert( u.BillingPuid == u.PassportPuid );

                            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW,
                                "BillingQueueItem.CreateInBilling: offer: 0x" + o.OfferId.ToString("X") +
                                " has reward id: " + o.RewardId(u.CountryId, u.Tier) +
                                " associated with it.  Processing now for user: 0x" + u.Puid.ToString("X") +
                                " (Passport puid: 0x" + u.BillingPuid.ToString("X") + ")");

                            if ( !string.IsNullOrEmpty(AlternateDmpUrl) )
                            {
                                DMPTransactionWrapper.SetSessionAlternateUrl(AlternateDmpUrl);
                            }

                            DMPClient dmpClient = new DMPClient(u.CountryId);

                            dmpClient.ProcessSubscriptionReward(
                                u.Puid,
                                u.BillingPuid,
                                u.MachinePuid,
                                o.OfferId,
                                u.CountryId,
                                Culture.GetCultureFromLanguageCountry((ushort)u.LanguageId, u.CountryId),
                                (int)TierEnum.NewUser
                                );
                        }
                     }
                }
                else
                {
                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + u.Puid + ", Base subscription (0x" + OfferId.ToString("X8") + ") has no SCS billing offering.  Skipping Offering.Purchase call for for puid 0x" + u.Puid.ToString("X8") + " in SCS...");
                }

                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + u.Puid + ", Purchased offering, updating UODB ...");

                // update uodb w/ service instance id
                //
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xuacs_set_sub_instance_id";
                    ws.SetHashVal(u.Puid);

                    ws.AddParameter("@bi_user_puid", u.Puid);
                    ws.AddParameter("@bi_offer_id", OfferId);
                    ws.AddParameter("@vc_svc_instance_id", serviceInstanceId);

                    ws.ExecuteNonQuery();
                    AuditStream.Write(u.Puid, AuditSubsystem.XUACS, ws, string.Empty);
                }


                // record transaction
                //
                Transaction.RecordNewAccount(OwnerPuid, subscriptionId, u.AccountId, u.MachinePuid);


                // all done, remove from queue
                //
                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + u.Puid + ", Removing from queue..");

                BillingQueue.DeleteFromQueue(u.Puid);

                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + u.Puid + ", Done!");

                BillingQueueCounters.Current.CreatedTotal.Increment();
                BillingQueueCounters.Current.CreatedPerSecond.Increment();

                BillingQueueCounters.Current.PendingTotal.Decrement();

                isCxnOk = true;
            }
            catch (Exception e)
            {
                if (e is BillingProviderException)
                {
                    BillingProviderException bpe = (BillingProviderException)e;
                    this.BillingApi = bpe.BillingApi;
                    this.BillingHResult = bpe.BdkHResult;
                    this.BillingErrorXml = bpe.Message;
                    this.XonlineHResult = bpe.XonlineHResult;
                    this.Status = BillingQueueStatus.RequiresMaintenance;
                    this.Save();

                    if ( bpe.IsUserError )
                    {
                        Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_NORMAL, "User " + u.Puid + ", BillingQueue.CreateInBilling: Error from SCS::" + bpe.BillingApi + " trying to create queued account 0x" + u.Puid.ToString("X") + " ('" + u.GamerTag + "')!\r\n" + bpe.ToString());

                        u.BillingAccountStatus = bpe.XonlineHResult;
                        u.Save();

                        BillingQueueCounters.Current.CreatedTotal.Increment();
                        BillingQueueCounters.Current.CreatedPerSecond.Increment();

                        //
                        // Errors that we believe are user-correctable should not
                        // suspend processing of the billing queue.
                        //
                        isCxnOk = true;
                    }
                    else
                    {
                        Xom.NtEvent( XEvent.Id.COMMON_CODE_7, bpe, "BillingQueue.CreateInBilling: Error from SCS::" + bpe.BillingApi + " trying to create queued account 0x" + u.Puid.ToString("X") + " ('" + u.GamerTag + "').");

                        //
                        // If SCS says the error from SCS is a retryable error,
                        // that typically means there is a transient outage on
                        // their side.  In that case, queue processing should be
                        // suspended.
                        //
                        // If the error is non-retryable error, it is likely
                        // something specific to that user's account or
                        // subscription data and shouldn't block other queued
                        // entries from being processed.
                        //
                        if ( bpe.IsRetryable )
                        {
                            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_HIGH, "BillingQueue.CreateInBilling: encountered retryable error " + bpe.HResult.ToString() + " from SCS::" + bpe.BillingApi + " for queued user 0x" + u.Puid.ToString("X") + " ('" + u.GamerTag + "').  Suspending billing queue processing...\r\nException: " + bpe);

                            isCxnOk = false;
                        }
                        else
                        {
                            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_HIGH, "BillingQueue.CreateInBilling: encountered non-retryable error " + bpe.HResult.ToString() + " from SCS::" + bpe.BillingApi + " for queued user 0x" + u.Puid.ToString("X") + " ('" + u.GamerTag + "').  Queue processing will continue.\r\nException:" + bpe);
                            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_HIGH, "BillingQueue.CreateInBilling: encountered non-retryable error from SCS while attempting to call: " + bpe.BillingApi + ".  Queue processing will continue.\r\nException: " + bpe);

                            isCxnOk = true;
                        }
                    }
                }
                //If the error is a client Exception from passport, then go ahead and process the remaining Queues
                else if(e is PassportClientException)
                {
                    PassportClientException passportException= (PassportClientException)e;

                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_HIGH, "BillingQueue.CreateInBilling: Error trying to get Passport details; hr = " + passportException.InternalHResult.ToString() + " for Queued user 0x" + u.Puid.ToString("X") + " ('" + u.GamerTag + "')!\r\n" + passportException.ToString()+ "Queue processing will continue.\r\nException: " + passportException);
                    Xom.NtEvent( XEvent.Id.COMMON_CODE_7, passportException, "BillingQueue.CreateInBilling: Error trying to get Passport details for user = " + (Puid) u.Puid + " ('" + u.GamerTag + "').");
                    isCxnOk=true;
                }
                else
                {
                    Xom.NtEvent( XEvent.Id.COMMON_CODE_7, e, "BillingQueue.CreateInBilling: Error trying to create queued user = " + (Puid) u.Puid + " ('" + u.GamerTag + "').");

                    this.BillingApi = "";
                    this.BillingHResult = 0;
                    this.BillingErrorXml = "";
                    this.XonlineHResult = BillingProviderException.ToHResult(e, HResult.XONLINE_E_ACCOUNTS_CREATE_ACCOUNT_ERROR);
                    isCxnOk = false;
                }
            }

            return isCxnOk;
        }


        private bool _isNew = true;
    }



    public class BillingQueue
    {
        static BillingQueue()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(BillingQueue.OnControlRequest);
        }

        public static void Add(ulong userPuid, ulong ownerPuid, ulong userPassportPuid, ulong ownerPassportPuid, byte accountType, ulong offerId, string billingOfferId, string billingToken, string guid, string purchGuid, Account acct, BillingQueueStatus status, string alternateUrl, string alternateDmpUrl, string billingApi, uint billingHResult, uint xonlineHResult, string billingErrorXml)
        {
            byte[] actualEncData;
            byte[] actualIv;
            byte[] iv;
            byte[] encData;
            string encodedAccountXml;
            string ipAddress=string.Empty;
            string deviceId = string.Empty;

            //Check the AAInfo and if ActiveAuth is available.
            if (AAInfo.IsActiveAuthAvailable)
            {
                AAInfo aa = AAInfo.Current;
                ipAddress = aa.IpAddressInternet;
                deviceId = aa.XblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_deviceid);
            }
            else if (SGInfo.Current != null)
            {
                ipAddress = SGInfo.Current.ClientIP.ToString();
                deviceId = SGInfo.Current.MachineId.ToString("x");
            }

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            UTF7Encoding utfEnc = new UTF7Encoding(true);
            ASCIIEncoding ascEnc = new ASCIIEncoding();
            string accountXml;


            Debug.Assert( billingToken != null );

            // If a CVM code is present, clear it now it is not allowable to store it.
            // SCS will not fail authorization if the CVM code is missing so at worst, there
            // may be a false positive authorization for someone who got queued.
            if ( acct != null && acct.PayInfo != null && acct.PayInfo.CreditCard != null )
            {
                acct.PayInfo.CreditCard.EncryptedCvmCode = null;

                if ( !string.IsNullOrEmpty(acct.PayInfo.CreditCard.CvmCode) )
                {
                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "BillingQueue.Add: removing CVM code from account info");
                    acct.PayInfo.CreditCard.CvmCode = "";
                }
            }

            accountXml = acct.ToXml();
            encodedAccountXml = ascEnc.GetString(utfEnc.GetBytes(accountXml));
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "User " + userPuid + ", original account xml size: " + accountXml.Length + "  encoded size: " + encodedAccountXml.Length);

            if (encodedAccountXml.Length > BillingQueueItem.MAX_ACCOUNT_XML_CHARS)
            {
                throw new Exception("Encoded AccountXml too large!   Max: " + BillingQueueItem.MAX_ACCOUNT_XML_CHARS + "   Actual: " + encodedAccountXml.Length);
            }



            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_queue_billing_info";
                ws.SetHashVal(userPuid);

                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_owner_puid", ownerPuid);
                ws.AddParameter("@bi_user_passport_puid", userPassportPuid);
                ws.AddParameter("@bi_owner_passport_puid", ownerPassportPuid);
                ws.AddParameter("@ti_account_type", accountType);
                ws.AddParameter("@bi_offer_id", offerId);
                ws.AddParameter("@vc_billing_offer_id", billingOfferId);
                ws.AddParameter("@vc_billing_token", billingToken);
                ws.AddParameter("@vc_guid", guid);
                ws.AddParameter("@vc_purchase_guid", purchGuid);
                ws.AddParameter("@vc_account_info", encodedAccountXml);
                ws.AddParameter("@vc_billing_api", billingApi);
                ws.AddParameter("@i_billing_hr", (int) billingHResult);
                ws.AddParameter("@vc_billing_error_xml", billingErrorXml);
                ws.AddParameter("@i_xonline_hr", (int) xonlineHResult);
                ws.AddParameter("@vc_ip_address", ipAddress);
                ws.AddParameter("@vc_device_id", deviceId);

                // encrypt the information and send it on the wire.
                KEKCryptoMgr.EncryptWithKEK( KEKCryptoMgr.GetKeyVersion(), BillingQueueItem.GetPayInfoBytes(acct.PayInfo.ToXml("PaymentInstrumentInfo")), out iv, out encData );

                if (iv.Length != BillingQueueItem.IV_BYTES)
                {
                    throw new Exception("Unexpected iv size from KEKCryptoMgr.EncryptWithKEK()!   Expected: " + BillingQueueItem.IV_BYTES + "   Actual: " + iv.Length);
                }

                if (encData.Length > BillingQueueItem.MAX_DATA_BYTES)
                {
                    throw new Exception("Encrypted data too large to be saved in existing fields!  Max: " + BillingQueueItem.MAX_DATA_BYTES + "  Actual: " + encData.Length);
                }

                actualIv = new byte[BillingQueueItem.MAX_IV_BYTES];
                Array.Copy(iv, actualIv, BillingQueueItem.IV_BYTES);

                actualEncData = new byte[BillingQueueItem.MAX_PAYINFO_BYTES];
                Array.Copy(encData, actualEncData, Math.Min(encData.Length, BillingQueueItem.MAX_PAYINFO_BYTES));

                if (encData.Length > BillingQueueItem.MAX_PAYINFO_BYTES)
                {
                    // payinfo field too small, copy the remainder to unused portion of IV
                    Array.Copy(encData, BillingQueueItem.MAX_PAYINFO_BYTES, actualIv, BillingQueueItem.IV_BYTES, encData.Length - BillingQueueItem.MAX_PAYINFO_BYTES);
                }


                ws.AddParameter("@si_kek_version", KEKCryptoMgr.GetKeyVersion());
                ws.AddParameter("@bin_payment_iv", actualIv);
                ws.AddParameter("@bin_payment_info", actualEncData);
                ws.AddParameter("@si_payment_info_type", (short)acct.PayInfo.PaymentInstrumentType);
                ws.AddParameter("@si_queue_status", (short)status);
                ws.AddParameter("@vc_alternate_url", alternateUrl != null ? alternateUrl : string.Empty);
                ws.AddParameter("@vc_alternate_dmp_url", alternateDmpUrl != null ? alternateDmpUrl : string.Empty);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }

            BillingQueueCounters.Current.AddsPerSecond.Increment();
            BillingQueueCounters.Current.AddsTotal.Increment();
            BillingQueueCounters.Current.AddsExecTime.IncrementBy(timeElapsed.TimeElapsed);
            BillingQueueCounters.Current.AddsExecTimeBase.Increment();
        }



        public static void StartPump()
        {
            if (BillingConfig.PumpUserBillingInfoQueue &&
                BillingConfig.ConnectToBilling)
            {
                WindowsIdentity id = WindowsIdentity.GetCurrent();
                ThreadPool.QueueUserWorkItem(new WaitCallback(PumpFunc), id);
            }



        }

        public static void StopPump()
        {
            _isStopped = true;

            if (_timer != null)
            {
                _timer.Dispose();
                _timer = null;
            }
        }


        public static void PumpFunc(object o)
        {
            ulong userPuid = 0;
            ulong[] userQueue;
            WindowsIdentity id = (WindowsIdentity)o;
            WindowsImpersonationContext impctx = null;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            XomRequestTimeElapsed createTimeElapsed;


            BillingQueueCounters.Current.PumpRunsTotal.Increment();

            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "++++++++" + DateTime.Now.ToString() + "++++++++" );
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "Queue pump initiated" );
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "" );



            try
            {
                if (id.IsSystem == false)
                {
                    // impersonate the thread that started this
                    impctx = id.Impersonate();
                }

                // Reset any stale users that may be stuck in the processing
                // state due to an AppDomain reset
                BillingQueue.ResetStaleQueuedItems();

                // get the list of queued users
                //
                userQueue = BillingQueue.GetPendingQueue();
                BillingQueueCounters.Current.PendingTotal.RawValue = userQueue.Length;

                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "Found " + userQueue.Length + " queued users.");
#if DEBUG
                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "BillingQueue.PumpFunc: pending queue entries:" );

                for (int i=0; i < userQueue.Length; i++)
                {
                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "    0x" + userQueue[i].ToString("X"));
                }
#endif

                // try writing each user to SCS
                //
                for (int i = 0; i < userQueue.Length; i++)
                {
                    if (_isStopped == true)
                    {
                        Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "Aborting queue loop..");
                        return;
                    }

                    userPuid = userQueue[i];

                    BillingQueueItem bqi = BillingQueueItem.Load(userPuid, true);

                    if (bqi == null)
                    {
                        BillingQueueCounters.Current.PendingTotal.Decrement();
                        continue;
                    }

                    // reset thread-local alternate URL, behavior injection, etc.
                    ResetQueueThreadSessionState();

                    //set the session clientInfo.We dont capture Device type in queue and hence we dont need it when setting session clientInfo
                    BillingProvider.SetSessionClientInfo(bqi.IpAdress, bqi.DeviceId, string.Empty);

                    // If entry in the queue has an alternate Url (for test
                    // purposes), use it in our next billing calls
                    if ( !string.IsNullOrEmpty(bqi.AlternateUrl) )
                    {
                        BillingProvider.SetSessionAlternateUrl(bqi.AlternateUrl);
                    }

                    createTimeElapsed = new XomRequestTimeElapsed();

                    User u = new User();
                    u.Load(userPuid);

                    // most auditing happens through a front door,  not a
                    // worker thread.  prime this thread with  user  puid

                    AuditStream.WriteOptional(
                        u.Puid, AuditSubsystem.XUACS, "BillingQueue", string.Empty
                    );

                    try {
                        if ( !bqi.CreateInBilling(u) )
                        {
                            break;
                        }
                    }
                    finally {
                        // and then flush any work audited on this thread
                        AuditStream.Cleanup(/* flush = */ true);
                    }

                    BillingQueueCounters.Current.CreateExecTime.IncrementBy(createTimeElapsed.TimeElapsed);
                    BillingQueueCounters.Current.CreateExecTimeBase.Increment();
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.MC_SPS_QUEUE_ERROR, e, "Failure in queue pump.");
            }

            try
            {
                if (impctx != null)
                {
                    impctx.Undo();
                }

            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.MC_SPS_QUEUE_ERROR_1, e, "Failure undoing impersonation");
            }

            ResetPumpTimer(id);


            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "Queue pump complete" );
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "+++++++++" + DateTime.Now.ToString() + "++++++++" );
            Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "" );

            BillingQueueCounters.Current.PumpRunTime.IncrementBy(timeElapsed.TimeElapsed);
            BillingQueueCounters.Current.PumpRunTimeBase.Increment();
        }

        private class QueueRetriesTimestamp : IComparable
        {
            public int numRetries;
            public DateTime timestamp;

            public int CompareTo(object obj)
            {
                if (obj is QueueRetriesTimestamp)
                {
                    QueueRetriesTimestamp qrt = (QueueRetriesTimestamp) obj;
                    if ( this.numRetries == qrt.numRetries )
                    {
                        return timestamp.CompareTo(qrt.timestamp);
                    }
                    return numRetries.CompareTo(qrt.numRetries);
                }

                throw new ArgumentException("object is not QueueRetriesTimestamp");
            }
        }

        internal static ulong[] GetPendingQueue()
        {
            ArrayList puidList = new ArrayList();
            ArrayList qrtList = new ArrayList();

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    try
                    {
                        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                        {
                            ws.StoredProc = "dbo.p_xuacs_get_queued_billing_info_users";
                            ws.PhysicalPartition = i;

                            using (WstDataReader rdr = ws.Execute())
                            {
                                while (rdr.Read())
                                {
                                    ulong userPuid = (ulong) rdr.GetInt64(0);
                                    puidList.Add(userPuid);

                                    QueueRetriesTimestamp qrt = new QueueRetriesTimestamp();
                                    qrt.numRetries = (int)rdr.GetInt32(1);
                                    qrt.timestamp = rdr.GetDateTime(2);
                                    qrtList.Add(qrt);
    #if DEBUG
                                    Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_LOW, "BillingQueue.GetPendingQueue: 0x" + userPuid.ToString("X") + "\t" + qrt.numRetries.ToString("d6") + "\t" + qrt.timestamp.ToString() );
    #endif
                                }
                            }
                        }
                    }

                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.BILLING_QUEUE_GET_PENDING_ERROR, e, "BillingQueue.GetPendingQueue(): Error accessing partition {0}.", i);
                    }
                }
            }

            //
            // Now we have the queue from all partitions, sort the whole list
            // by number of retries (least to most) and then by date (oldest
            // to newest).
            //
            ulong[] puids = (ulong[])puidList.ToArray(typeof(ulong));
            QueueRetriesTimestamp[] qrts = (QueueRetriesTimestamp[])qrtList.ToArray(typeof(QueueRetriesTimestamp));
            Array.Sort(qrts, puids);
            return puids;
        }

        public static void DeleteFromQueue(ulong puid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_xuacs_delete_queued_billing_info";
                ws.SetHashVal(puid);

                ws.AddParameter("@bi_user_puid", puid);

                ws.ExecuteNonQuery();
            }
        }


        private static void ResetPumpTimer(WindowsIdentity id)
        {
            try
            {
                if (_isStopped)
                {
                    return;
                }

                if (_timer == null)
                {
                    _timer = new Timer(new TimerCallback(PumpFunc), id, BillingConfig.PumpUserBillingInfoQueueInterval * 60 * 1000, Timeout.Infinite);
                }
                else
                {
                    _timer.Change(BillingConfig.PumpUserBillingInfoQueueInterval * 60 * 1000, Timeout.Infinite);
                }
            }
            catch (Exception e)
            {
               Xom.NtEvent( XEvent.Id.MC_SPS_QUEUE_ERROR_2, e, "Failure to reset the queue timer!!!!! THIS SHOULD NEVER HAPPEN!");
            }
        }

        // If an AppDomain reset happens while queued items are being prcessed,
        // they will be forever stuck in the processing state.  This method
        // resets any item that is in state 1 (processing) and more than 2
        // hours old to state 0 (pending).
        private static void ResetStaleQueuedItems()
        {
            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    try
                    {
                        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                        {
                            ws.StoredProc = "dbo.p_xuacs_reset_queued_billing_info";
                            ws.PhysicalPartition = i;

                            ws.ExecuteNonQuery();
                        }
                    }

                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.BILLING_QUEUE_RESET_ITEMS_ERROR, e,
                            "BillingQueue.ResetStaleQueuedItems(): Error accessing partition {0}.", i
                        );
                    }
                }
            }
        }

        private static void ResetQueueThreadSessionState()
        {
            // use longer SCS timeout values because these calls are server <-> server
            BdkWrapper.SetSessionClientType(SessionClientType.LiveService);

            // Reset any session alternate URL
            BdkWrapper.ResetSessionAlternateUrl();

            // Reset the SCS session client info (client IP address, etc.)
            BdkWrapper.ResetSessionClientInfo();

            // Reset per-session SCS error injection state
            BdkWrapper.ResetSessionInjectedError();

            // Reset any session alternate URL
            DMPTransactionWrapper.ResetSessionAlternateUrl();

            // In order to allow the existing AlternateUrl columns in the queue
            // tables to be overloaded to support behavior injections, resetting
            // the current thread's AlternateUrl must also clear any pending
            // BehaviorInjection headers as well
            RequestHeaderBehaviorInjectionMgr.ClearBehaviorInjections();
        }

        //
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();
            switch (args.Command)
            {
            case "help":
                XomControlConnection.SendMessage(
                    "BillingQueue help:\r\n" +
                    "  Dequeue -- Force the billing queue to start processing queued items\n\r\n\r",
                    args.RequestId);
                args.Handled = true;
                break;

            case "dq":
            case "dequeue":
                BillingQueue.PumpFunc(WindowsIdentity.GetCurrent());
                args.Handled = true;
                break;
            }
        }

        private static Timer _timer = null;
        private static bool _isStopped = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ContentUtil.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Net;
using System.Text;
using System.Transactions;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.utilities;
using xonline.common.musicnet;
using xonline.core.user;

using Microsoft.Webstore.WstClient;

[assembly: XomAreaDefinition(XomAreaName.contentutiltrace)]

namespace xonline.common.billing
{
    public class XeDMPUtil
    {
        public static XeGetPointsPurchaseStatusResponse GetPointsPurchaseStatus(
            XeGetPointsPurchaseStatusRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            XeGetPointsPurchaseStatusResponse response = new XeGetPointsPurchaseStatusResponse();

            response.statuses = DMPClient.p_dmp_get_transaction_status(request.userPuid,
                request.queries);

            return response;
        }
    }

    public class XeContentUtil
    {
        public static OfferPrice ReadOfferPrice(WstDataReader r, int cultureID)
        {
            Debug.Assert(r != null);
            if (r == null)
            {
                throw new ArgumentException("r");
            }

            OfferPrice price = new OfferPrice();

            price.paymentType = (ushort)r.GetInt32(0);
            price.wholePrice = r.GetInt32(1);
            price.fractionalPrice = r.GetInt32(2);

            ushort specificDetails = (ushort)r.GetInt16(3);
            price.taxType = Details.SpecificDetailsFlagsTaxType(specificDetails);

            price.priceText = Price.XeFormatPrice(price.paymentType, price.wholePrice,
                price.fractionalPrice, cultureID);
            price.priceTextLength = (ushort)price.priceText.Length;

            return price;
        }

        public static BasicContentInfo ReadBasicContentInfo(WstDataReader r)
        {
            Debug.Assert(r != null);
            if (r == null)
            {
                throw new ArgumentException("r");
            }

            BasicContentInfo info = new BasicContentInfo();

            info.offerID = (ulong)r.GetInt64(0);
            info.offerName = r.GetString(1);
            info.offerNameLength = (ushort)info.offerName.Length;
            info.sellText = r.GetString(2);
            info.sellTextLength = info.sellText.Length;
            info.titleName = r.GetString(3);
            if (info.titleName == null || info.titleName == string.Empty || info.titleName == "")
            {
                info.titleName = null;
                info.titleNameLength = 0;
            }
            else
            {
                info.titleNameLength = (ushort)info.titleName.Length;
            }
            info.offerType = (uint)r.GetInt32(4);
            info.titleCategory = (uint)r.GetInt32(5);
            info.tierRequired = (byte)r.GetInt32(6);
            info.gameRating = (ushort)r.GetInt32(7);
            info.titleID = (uint)r.GetInt32(8);
            info.packageSize = (uint)r.GetInt32(9);
            info.installSize = (uint)r.GetInt32(10);
            info.userHasViewed = ((uint)r.GetInt32(11)) == 0;
            info.userHasPurchased = ((uint)r.GetInt32(12)) == 1;
            info.contentId = new byte[XOn.XONLINE_CONTENT_ID_LEN];

            Offer offer = Offer.CreateInstance(info.offerID);
            info.isUnrestricted = offer.IsUnrestricted;

            if (r.GetBytes(13, 0, info.contentId, 0, (int)XOn.XONLINE_CONTENT_ID_LEN) != XOn.XONLINE_CONTENT_ID_LEN)
                throw new Exception("Failed to read content-id from row set");

            info.licenseMask = (uint)r.GetInt32(14);
            info.previewOfferID = (ulong)r.GetInt64(15);
            info.assetID = (uint)r.GetInt32(16);
            info.purchaseQuantity = (uint)r.GetInt32(17);
            info.maxStartDate = (System.DateTime)r.GetDateTime(19);
            info.isRecentContent = ((uint)r.GetInt32(20)) == 1;

            return info;
        }

        public static void GetUserLicenseContentData(WstDataReader r, ref BasicContentInfo[] infos)
        {
            Debug.Assert(r != null);
            if (r == null)
            {
                throw new ArgumentException("r");
            }

            Debug.Assert(infos != null);
            if (infos == null)
            {
                throw new ArgumentException("infos");
            }

            do
            {
                ulong offerID = (ulong)r.GetInt64(0);

                for (int iInfo = 0; iInfo < infos.Length; iInfo++)
                {
                    if (infos[iInfo] != null && infos[iInfo].offerID == offerID)
                    {
                        infos[iInfo].userHasPurchased = true;
                    }
                }
            }
            while (r.Read());
        }

        public static void GetUserViewedContentData(uint titleBitfilter, DateTime[] dtLastAccesses, ref BasicContentInfo[] infos)
        {
            Debug.Assert(dtLastAccesses != null);
            if (dtLastAccesses == null)
            {
                throw new ArgumentException("dtLastAccesses");
            }

            Debug.Assert(infos != null);
            if (infos == null)
            {
                throw new ArgumentException("infos");
            }

            for (int iInfo = 0; iInfo < infos.Length; iInfo++)
            {
                Debug.Assert(infos[iInfo] != null);
                if (infos[iInfo] == null)
                {
                    throw new ArgumentException("infos[" + iInfo + "]");
                }

                uint validBits = infos[iInfo].titleCategory & titleBitfilter;
                int iBit = 0;
                while (validBits != 0)
                {
                    if ((validBits & 1) != 0)
                    {
                        if (infos[iInfo].maxStartDate > dtLastAccesses[iBit])
                        {
                            infos[iInfo].userHasViewed = false;
                        }
                    }

                    iBit++;
                    validBits >>= 1;
                }
            }
        }


        public static void ReadOffersAndPrices(WstDataReader r, int cultureID, ref ushort cOffers, ref uint cTotalOffers, out BasicContentInfo[] infos)
        {
            Debug.Assert(r != null);
            if (r == null)
            {
                throw new ArgumentException("r");
            }

            //
            // This code is shared by both ContentEnumerate and ContentDetails for unpacking the resulting record sets.
            //  if you modify one of the stored procs, be sure to consider the impact on the other.
            //
            cOffers = (ushort)r.GetInt32(0);
            cTotalOffers = cOffers;

            infos = new BasicContentInfo[cOffers];

            r.NextResult();
            for (int i = 0; i < cOffers; i++)
            {
                r.Read();

                BasicContentInfo info = ReadBasicContentInfo(r);

                info.pricesLength = (byte)r.GetInt32(18);
                info.prices = new OfferPrice[info.pricesLength];

                infos[i] = info;
            }

            r.NextResult();     // record whether there is another rowset after this one to look at
            for (int i = 0; i < cOffers; i++)
            {
                BasicContentInfo info = infos[i];
                for (int p = 0; p < info.pricesLength; p++)
                {
                    r.Read();

                    ulong offerID = (ulong)r.GetInt64(4);
                    if (offerID != info.offerID)
                    {
                        throw new Exception("Offer prices in results of ContentEnumerate do not match expected results. This is likely an error in SQL.");
                    }

                    OfferPrice price = ReadOfferPrice(r, cultureID);

                    info.prices[p] = price;
                }
            }

            bool getTotal = r.NextResult();
            if (getTotal)
            {
                r.Read();
                cTotalOffers = (uint)r.GetInt32(0);
            }
        }

        public static BasicContentHistoryInfo ReadBasicContentHistoryInfo(WstDataReader r, ulong machinePuid)
        {
            Debug.Assert(r != null);
            if (r == null)
            {
                throw new ArgumentException("r");
            }

            BasicContentHistoryInfo info = new BasicContentHistoryInfo();

            info.offerID = (ulong)r.GetInt64(0);

            // will be blank for WMIS items
            info.offerName = r.GetString(1);
            if (info.offerName == null || info.offerName == string.Empty || info.offerName == "")
            {
                info.offerName = null;
                info.offerNameLength = 0;
            }
            else
            {
                info.offerNameLength = (ushort)info.offerName.Length;
            }

            // will be blank for WMIS items
            info.titleName = r.GetString(2);
            if (info.titleName == null || info.titleName == string.Empty || info.titleName == "")
            {
                info.titleName = null;
                info.titleNameLength = 0;
            }
            else
            {
                info.titleNameLength = (ushort)info.titleName.Length;
            }
            info.offerType = (uint)r.GetInt32(3);
            info.titleID = (uint)r.GetInt32(4);

            // get WMIS data
            info.wmid = new WMID();
            info.wmid.wmid = r.GetGuid(5).ToString();
            if (info.wmid.wmid == null || info.wmid.wmid == string.Empty || info.wmid.wmid == "")
            {
                info.wmid.wmid = null;
                info.wmid.wmidLength = 0;
            }
            else
            {
                info.wmid.wmidLength = (ushort)info.wmid.wmid.Length;
            }
            info.wmid.videoType = (uint)r.GetInt32(6);

            // Defaulted in SQL for now, some-day may be set for WMIS content that is in the history, but no long downloadable
            info.isAcquirable = ((uint)r.GetInt32(7)) == 1;

            if (info.offerID != 0)
            {
                Offer offer = Offer.CreateInstance(info.offerID);
                info.isUnrestricted = offer.IsUnrestricted;
            }
            else
            {
                // Some day WMIS offers may also set this value
                info.isUnrestricted = false;
            }

            int column = r.GetOrdinal("dt_expiration");
            info.licenseExpiration = r.IsDBNull(column) ? DateTime.MaxValue : r.GetDateTime(column);

            column = r.GetOrdinal("i_acknowledged");
            info.licenseAcknowledged = r.IsDBNull(column) ? false : (r.GetInt32(column) == 1);

            column = r.GetOrdinal("bi_machine_puid");
            info.licensedOnMachine = ((ulong)r.GetInt64(column)) == machinePuid;

            return info;
        }

        public static void ReadOffersAndWMIDs(WstDataReader r, int cultureID, ulong machinePuid, ref ushort cOffers, ref uint cTotalOffers, out BasicContentHistoryInfo[] infos)
        {
            Debug.Assert(r != null);
            if (r == null)
            {
                throw new ArgumentException("r");
            }

            //
            // This code is used by both ContentHistoryEnumerate for unpacking the resulting record sets.
            //
            cOffers = (ushort)r.GetInt32(0);
            cTotalOffers = cOffers;

            infos = new BasicContentHistoryInfo[cOffers];

            r.NextResult();
            for (int i = 0; i < cOffers; i++)
            {
                r.Read();

                BasicContentHistoryInfo info = ReadBasicContentHistoryInfo(r, machinePuid);

                infos[i] = info;
            }

            bool getTotal = r.NextResult();
            if (getTotal)
            {
                r.Read();
                cTotalOffers = (uint)r.GetInt32(0);
            }
        }
        public static ContentDetailsResponse GetDetails(ContentDetailsRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            int cultureID = Culture.GetCultureFromLanguageCountry(request.languageID, request.countryID);
            StringBuilder sb = new StringBuilder();

            // Format the offers string to pass to SQL
            int sortPosition = 0;
            if ((request.offers > 0) && (request.offerID == 0))
            {
                Debug.Assert(request.offerIDs != null);
                if (request.offerIDs == null)
                {
                    throw new ArgumentException("request.offerIDs");
                }

                foreach (ulong offerID in request.offerIDs)
                {
                    sb.Append(string.Format("<o i=\"{0}\" s=\"{1}\"/>",
                        ((long)offerID).ToString(), sortPosition));

                    sortPosition++;
                }
            }
            else
            {
                sb.Append(string.Format("<o i=\"{0}\" s=\"{1}\"/>",
                    ((long)request.offerID).ToString(), sortPosition));

                sortPosition++;
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(request.userPuid);

                ws.StoredProc = "dbo.p_xbos_content_details";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@i_country_id", request.countryID);
                ws.AddParameter("@i_culture_id", cultureID);
                ws.AddParameter("@bi_user_puid", request.userPuid);
                ws.AddParameter("@xml_offers", sb.ToString());
                ws.AddParameter("@i_num_offers", sortPosition);
                ws.AddParameter("@i_payment_type_id", request.paymentType);
                ws.AddParameter("@i_tier_required", request.tierRequired);
                ws.AddParameter("@i_rating_system_id", (int)request.ratingSystem);
                ws.AddParameter("@i_new_content_window_hours", (int)NewContentWindowHours);

                using (WstDataReader r = ws.Execute())
                {
                    ContentDetailsResponse results = new ContentDetailsResponse();

                    if (r.Read())
                    {
                        uint unused = 0;
                        ReadOffersAndPrices(r, cultureID, ref results.offersReturned, ref unused, out results.infos);

                        // For schema v1 requests, there is only 1 result. Fixup the response here.
                        if ((null != results.infos) && (results.infos.Length > 0))
                        {
                            results.basicInfo = results.infos[0];
                        }
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_96, msg);
                    }

                    return results;
                }
            }
        }

        public static int NewContentWindowHours
        {
            get
            {
                return Config.GetIntSetting(Setting.xbos_newContentWindowHours);
            }
        }

        private static CacheTable<string, ContentEnumerateResponse> _cache = new CacheTable<string, ContentEnumerateResponse>("ContentEnumerateCache", Config.GetUIntSetting(Setting.xbos_MaxCacheSize_ContentEnumerate));

        public static void FlushCache()
        {
            _cache.Flush();
        }

        public static void SetCacheSize(uint newSize)
        {
            _cache.MaxSize = newSize;
        }

        public static ContentEnumerateResponse Enumerate(ContentEnumerateRequest req)
        {
            Debug.Assert(req != null);
            if (req == null)
            {
                throw new ArgumentException("req");
            }

            int cultureID = Culture.GetCultureFromLanguageCountry(req.languageID, req.countryID);

            ContentEnumerateResponse results = null;
            User user = new User();
            user.Load(req.userPuid);

            // logic checks to match the pieces removed from the various flavors of this sql query.
            bool fCacheable = true;
            bool fCacheHit = false;
            string cacheKey = null;
            if (req.titleID == 0)
            {
                if (req.userHasPurchasedFilter)
                {
                    fCacheable = false;
                }
            }

            if (fCacheable)
            {
                cacheKey = string.Join("|", new string[]
                {
                    "CE",
                    req.countryID.ToString("d"),
                    cultureID.ToString("d"),
                    req.startingIndex.ToString("d"),
                    req.maxResults.ToString("d"),
                    req.gameRating.ToString("d"),
                    req.offerType.ToString("d"),
                    req.paymentType.ToString("d"),
                    req.tierRequired.ToString("d"),
                    req.titleID.ToString("x"),
                    req.titleCategories.ToString("x"),
                    req.newContentOnlyFilter ? "1" : "0",
                    req.matchRequiredTierFilter ? "1" : "0",
                    (req.offerType != (uint)OfferingTypeEnum.GamertagChange) ? "0" : user.FreeGamertagEligible.ToString(),
                    req.genreID.ToString("d")
                });

                ContentEnumerateResponse cacheValue = null;
                fCacheHit = _cache.TryGetValue(cacheKey, out cacheValue);

                if (fCacheHit)
                {
                    // copy the cache value for further use.
                    results = cacheValue.Copy();
                }
            }

            if (!fCacheHit)
            {
                int maxResults = req.maxResults;
                results = new ContentEnumerateResponse();

                // If we are looking for the free gamertag change offer, make sure we get at least 2 offers
                // so that we have both the free and paid offers.
                // The code below the stored proc will ensure we only return the free offer.
                if (OfferingTypeEnum.GamertagChange == (OfferingTypeEnum)req.offerType && 1 == user.FreeGamertagEligible && 1 == maxResults)
                {
                    maxResults++;
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    // Data is partitioned by user puid
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.SetHashVal(req.userPuid);

                    ws.StoredProc = "dbo.p_xbos_content_enumerate";

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter("@i_country_id", req.countryID);
                    ws.AddParameter("@i_culture_id", cultureID);
                    ws.AddParameter("@i_starting_index", req.startingIndex);
                    ws.AddParameter("@i_max_results", maxResults);
                    ws.AddParameter("@bi_user_puid", req.userPuid);

                    int ratingSystemId = RegionalRatings.GetRatingSystem(req.gameRating);
                    ws.AddParameter("@i_rating_system_id", ratingSystemId);

                    int ratingRank = RegionalRatings.GetRating(req.gameRating);
                    ws.AddParameter("@i_rating_rank", ratingRank);

                    ws.AddParameter("@i_offer_type_id", req.offerType);
                    ws.AddParameter("@i_payment_type_id", req.paymentType);
                    ws.AddParameter("@i_tier_required", req.tierRequired);

                    ws.AddParameter("@i_title_id", req.titleID);
                    ws.AddParameter("@i_title_bit_filter", req.titleCategories);

                    ws.AddParameter("@i_user_played_game_filter", (int)(req.userPlayedGameFilter == true ? 1 : 0));
                    ws.AddParameter("@i_user_has_purchased_filter", (int)(req.userHasPurchasedFilter == true ? 1 : 0));
                    ws.AddParameter("@i_new_content_only", (int)(req.newContentOnlyFilter ? 1 : 0));
                    ws.AddParameter("@i_new_content_window_hours", (int)NewContentWindowHours);
                    ws.AddParameter("@i_match_required_tier_filter", (int)(req.matchRequiredTierFilter ? 1 : 0));

                    ws.AddParameter("@i_genre_id", req.genreID);

                    bool partnernet = string.Compare(Config.Environment, "partnernet", true) == 0;
                    ws.AddParameter("@b_partner_net", (partnernet ? 1 : 0));
                    ws.AddParameter("@b_include_free_gamertag_offer ", (req.offerType != (uint)OfferingTypeEnum.GamertagChange) ? 0 : (int)user.FreeGamertagEligible);

                    using (WstDataReader r = ws.Execute())
                    {
                        if (r.Read())
                        {
                            ReadOffersAndPrices(r, cultureID, ref results.offersReturned, ref results.offersTotal, out results.infos);
                        }

                        r.Close();

                        HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                        if (HResult.Failed(hr))
                        {
                            string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                            throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_97, msg);
                        }

                    }
                }

                if (fCacheable)
                {
                    ContentEnumerateResponse cacheValue = results.Copy();

                    _cache[cacheKey] = cacheValue;
                }
            }

            if (OfferingTypeEnum.GamertagChange == (OfferingTypeEnum)req.offerType)
            {
                // Either return the free Gamertag change offer or the paid gamertag offers change offers but not both

                if (1 == user.FreeGamertagEligible)
                {
                    // Free offers only, if they exist

                    List<BasicContentInfo> listFreeGamertagOffers = new List<BasicContentInfo>();
                    foreach (BasicContentInfo info in results.infos)
                    {
                        if (Offer.IsFreeGamertagOffer(info.offerID))
                            listFreeGamertagOffers.Add(info);
                    }
                    if (0 < listFreeGamertagOffers.Count)
                    {
                        results.infos = listFreeGamertagOffers.ToArray();
                    }
                }
                else
                {
                    // Paid offers only

                    List<BasicContentInfo> listPaidGamertagOffers = new List<BasicContentInfo>();
                    foreach (BasicContentInfo info in results.infos)
                    {
                        if (!Offer.IsFreeGamertagOffer(info.offerID))
                            listPaidGamertagOffers.Add(info);
                    }
                    if (0 < listPaidGamertagOffers.Count)
                    {
                        results.infos = listPaidGamertagOffers.ToArray();
                    }
                    else
                    {
                        results.infos = new BasicContentInfo[0];
                    }
                }
                results.offersReturned = (ushort)results.infos.Length;
                results.offersTotal = (uint)results.infos.Length;
            }

            return results;
        }

        public static ContentHistoryEnumerateResponse Enumerate(ContentHistoryEnumerateRequest req)
        {
            Debug.Assert(req != null);
            if (req == null)
            {
                throw new ArgumentException("req");
            }

            int cultureID = Culture.GetCultureFromLanguageCountry(req.languageID, req.countryID);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(req.userPuid);

                ws.StoredProc = "dbo.p_xbos_content_history_enumerate";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@i_country_id", req.countryID);
                ws.AddParameter("@i_culture_id", cultureID);
                ws.AddParameter("@i_starting_index", req.startingIndex);
                ws.AddParameter("@i_max_results", req.maxResults);
                ws.AddParameter("@bi_user_puid", req.userPuid);
                ws.AddParameter("@bi_machine_puid", req.machinePuid);

                ws.AddParameter("@i_offer_type_id", req.offerType);
                ws.AddParameter("@i_content_is_acquirable_filter", (int)(req.isAcquirableOnlyFilter == true ? 1 : 0));

                using (WstDataReader r = ws.Execute())
                {
                    ContentHistoryEnumerateResponse results = new ContentHistoryEnumerateResponse();

                    if (r.Read())
                    {
                        ReadOffersAndWMIDs(r, cultureID, req.machinePuid, ref results.offersReturned, ref results.offersTotal, out results.infos);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_100, msg);
                    }

                    return results;
                }
            }
        }

        public static void UpdateAccessTimes(ContentUpdateAccessTimesRequest request)
        {
            UpdateAccessTimes(request, DateTime.UtcNow);
        }

        public static void UpdateAccessTimes(ContentUpdateAccessTimesRequest request, DateTime dtAccessTime)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(request.userPuid);

                ws.StoredProc = "dbo.p_xbos_update_access_times";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", request.userPuid);
                ws.AddParameter("@i_title_id", request.titleID);
                ws.AddParameter("@i_title_bit_filter", request.titleCategories);
                ws.AddParameter("@dt_last_access", dtAccessTime);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_101, msg);
                }
            }
        }

        public static XeContentAvailableResponse ContentAvailable(XeContentAvailableRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(request.userPuid);

                ws.StoredProc = "dbo.p_xbos_content_available";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", request.userPuid);
                ws.AddParameter("@i_title_id", request.titleID);
                ws.AddParameter("@i_country_id", request.countryID);
                ws.AddParameter("@i_tier_required", request.tierRequired);

                using (WstDataReader r = ws.Execute())
                {
                    XeContentAvailableResponse response = new XeContentAvailableResponse();

                    if (r.Read())
                    {
                        if (response.newOffersLength != 32 || response.totalOffersLength != 32)
                            throw new XRLException(HResult.XONLINE_E_PROTOCOL_MISMATCH, XEvent.Id.COMMON_BILLING_CODE_102, "ContentAvailable protocol mismatch");

                        response.newOffers = new uint[32];
                        for (int i = 0; i < 32; i++)
                        {
                            response.newOffers[i] = (uint)r.GetInt32(i);
                        }

                        r.NextResult();
                        r.Read();

                        response.totalOffers = new uint[32];
                        for (int i = 0; i < 32; i++)
                        {
                            response.totalOffers[i] = (uint)r.GetInt32(i);
                        }
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_103, msg);
                    }

                    return response;
                }
            }
        }
    }

    public class XeOfferPurchaseUtil
    {
        //
        // IsFreeXenonOffer is intended to be called by the various purchase APIs
        // to determine if an offer is "free" in the context of lightweight
        // accounts.
        //
        // Lightweight accounts should be prevented from purchasing offers that cost
        // points or currency using a payment instrument.
        //
        // Lightweight accounts should also be blocked from redeeming tokens with a
        // corresponding SCS offer because users may need to call customer support (CSR)
        // for assistance with their prepaid tokens and need to be identified.
        //
        // Lightweight accounts are, however, allowed to purchase free trial subscription
        // offers that have corresponding SCS offer ids.
        //
        public static bool IsFreeXenonOffer(Offer o, byte countryId, int tier, PaymentTypeEnum paymentType)
        {
            Debug.Assert(o != null);
            if (o == null)
            {
                throw new ArgumentException("o");
            }

            if (!o.IsXenonOffer)
            {
                throw new ArgumentException("invalid offer type!");
            }

            // find the SCS billing offer id associated with the offer
            string boid = o.BillingOfferId(countryId, tier, (int)paymentType);

            // only trial offers may have a billing offer id and be purchased by a lightweight
            // account
            if (!string.IsNullOrEmpty(boid))
            {
                return o.IsTrial;
            }

            // no billing offer id + token is fine for lightweight accounts
            if (paymentType == PaymentTypeEnum.Token)
            {
                return true;
            }

            // no billing offer id, no token --> payment type must be points
            // lightweight accounts can only purchase if price is 0
            Debug.Assert(paymentType == PaymentTypeEnum.Points);

            bool isFree = (paymentType == PaymentTypeEnum.Points) && o.OfferingIsFree(countryId, tier, (int)paymentType);

            return isFree;
        }

        public static void ValidateXenonUserForPurchase(User u, PaymentTypeEnum paymentType, bool isFreePurchase, bool blockLightweightAccounts, bool isLIVESubscriptionPurchase)
        {
            Debug.Assert(u != null);
            if (u == null)
            {
                throw new ArgumentException("u");
            }

            if (u.AccountType != User.XenonAccount)
            {
                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_NOT_XENON_USER, XEvent.Id.COMMON_BILLING_CODE_104,
                    "XeOfferPurchase: user 0x" + u.Puid.ToString("X") + " (" + u.GamerTag +
                    ") has an account type of: " + u.AccountType +
                    ".  Only Xenon accounts are permitted to call this API.");
            }

            // queued users have to wait until until they are dequeued
            if (BillingProvider.IsDummyId(u.AccountId))
            {
                string msg = string.Format("ValidateXenonUserForPurchase: user: 0x{0} is in the billing queue and has a dummy account id: {1}. The account must successfully dequeue before purchasing is allowed.", u.Puid.ToString("x"), u.AccountId);

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER, msg);
            }

            if (!isFreePurchase)
            {
                // If the paymentType is anything other than Token, verify the user has
                // the PURCHASE_CONTENT privilege.  Token purchases are allowed because
                // those have (presumably) been paid for already.
                if (paymentType != PaymentTypeEnum.Token)
                {
                    UserPrivileges up = new UserPrivileges(u.Puid);

                    //Do not require privileges if the user is purchasing a subscription
                    if (up[XOn.XPRIVILEGE_PURCHASE_CONTENT] != true && isLIVESubscriptionPurchase != true)
                    {
                        string msg = "XeOfferPurchase: user 0x" + u.Puid.ToString("X") + " (" + u.GamerTag +
                        ") is not allowed to make non-token purchases.  The user does not have the XPRIVILEGE_PURCHASE_CONTENT privilege";

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_OFFERING_PURCHASE_BLOCKED, msg);
                    }
                }

                if (blockLightweightAccounts)
                {
                    // since the content is not free, verify the user has the required PII for purchase
                    if (u.HasPiiForPurchase == false)
                    {
                        if (Account.IsLightweightAccount(u.Puid, u.BillingPuid, u.AccountId))
                        {
                            string msg = "ValidateXenonUserForPurchase: user 0x" + u.Puid.ToString("x") + " (" + u.GamerTag + ") has a lightweight account.  Additional PII is required to purchase.";

                            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                            throw new XRLExceptionWithoutEvent(
                                HResult.XONLINE_E_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED, msg);
                        }
                        else
                        {
                            u.HasPiiForPurchase = true;
                            u.Save();
                        }
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ValidateXenonUserForPurchase: bypassing lightweight account check...");
                }
            }
        }

        public static void ValidateXenonUserForPurchase(User u, PaymentTypeEnum paymentType, bool isFreePurchase, bool blockLightweightAccounts)
        {
            ValidateXenonUserForPurchase(u, paymentType, isFreePurchase, blockLightweightAccounts, false);
        }

        public static User ValidateXenonUserForPurchase(ulong userPuid, PaymentTypeEnum paymentType, bool isFreePurchase, bool blockLightweightAccounts)
        {
            // verify the user is in fact a Xenon user
            User u = new User();
            u.Load(userPuid);

            ValidateXenonUserForPurchase(u, paymentType, isFreePurchase, blockLightweightAccounts);

            return u;
        }

        public static void PurchaseSubscription(XeOfferPurchaseRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(request.offerIDs != null);
            if (request.offerIDs == null)
            {
                throw new ArgumentException("request.offerIDs");
            }

            HResult hr = HResult.S_OK;

            Offer o = Offer.CreateInstance(request.offerIDs[0]);
            bool tokenSubstitution = false;

            // make sure the offer is correctly flagged as a subscription
            if (!o.IsPerUser || (o.IsSubscription == false && o.IsRenewal == false && o.IsTrial == false))
            {
                throw new XRLException(HResult.XONLINE_E_OFFERING_INVALID_OFFER_TYPE, XEvent.Id.COMMON_BILLING_CODE_116,
                    "XeOfferPurchaseUtil.PurchaseSubscription: offer ID 0x" + o.OfferId.ToString("X") +
                    " is not correctly flagged as a subscription offer.  IsPerUser must be true and OfferType must be either Subscription or Renewal.  " +
                    "IsPerUser=" + o.IsPerUser.ToString() + ", OfferType=" + o.OfferType.ToString());
            }

            //If the trial count has expired then throw back an error and don't proceed further
            //do it only if the offer is base offer and not a music subscription
            if (o.IsTrial && o.IsBaseOffer && !o.IsMusicNetSubscription)
            {
                int trialCount = Machine.GetTrialCount(request.machinePuid);

                if (trialCount >= Config.GetIntSetting(Setting.billing_maxTrialCount))
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ACCOUNTS_REACHED_TRIAL_OFFER_LIMIT, "Trial count for the machine {0} exceeded", request.machinePuid.ToString("X"));
                }
            }

            // first let's make sure that what we have in UODB is synchronized with SCS
            XeSubscriptionUtil.ReconcileSubscriptions(request.userPuid);

            User u = new User();
            u.Load(request.userPuid);

            // if the user still doesn't have a MusicNet account, create it now
            if (o.IsMusicNetSubscription && !u.HasMusicnetAccount)
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "PurchaseSubscription: attempting to create MusicNet account for user: 0x" + u.Puid.ToString("x"));
                MusicnetClient.CreateMusicnetAccount(u);
            }


            // if the offer is for a live subscription, and if the user has an instanceID associated
            // with their base subscription, then this is a renewal
            bool renewSubscription = false;

            string instanceID;
            ulong offerID;
            int subscriptionStatusID;

            if (o.IsBaseOffer)
            {
                u.XeGetBaseSubscription(out instanceID, out offerID, out subscriptionStatusID);

                if (!string.IsNullOrEmpty(instanceID) && subscriptionStatusID != Subscription.CANCELED)
                {
                    renewSubscription = true;
                }
            }
            else
            {
                hr = u.GetSubscriptionFromServiceComponentId(o.ServiceComponentId, out instanceID, out offerID, out subscriptionStatusID);

                if (HResult.Succeeded(hr) && !string.IsNullOrEmpty(instanceID) && subscriptionStatusID != Subscription.CANCELED)
                {
                    renewSubscription = true;
                }
            }

            string paymentInstrumentID = null;
            string billingToken = null;
            string encryptedBillingToken = null;

            byte[] voucherHash = null;
            PaymentTypeEnum paymentType = (PaymentTypeEnum)request.paymentType;
            if (paymentType == PaymentTypeEnum.CreditCard)
                paymentInstrumentID = request.paymentInstrumentID;
            else if (paymentType == PaymentTypeEnum.Token)
            {
                voucherHash = ValidateVoucherForOffer(request);

                if (o.IsXbox1Offer)
                {
                    if (o.EquivalentXenonOfferId == 0)
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_INVALID_OFFER_TYPE, XEvent.Id.COMMON_BILLING_CODE_117,
                            "PurchaseSubscription: Xbox1 voucher provided (offer id 0x" + o.OfferId.ToString("X") + ") but no equivalent Xenon offer id found in UODB.  An offer relation between the Xbox1 offer and an equivalent Xenon offer must be present for Xbox1 vouchers to be used by Xenon consoles.");
                    }

                    string tokenSequenceNumber = string.Empty;

                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "PurchaseSubscription: Xbox1 voucher offer id 0x" + o.OfferId.ToString("X") + " will be substituted with equivalent Xenon offer id 0x" + o.EquivalentXenonOfferId.ToString("X"));

                    tokenSubstitution = true;

                    Offer xenonOffer = Offer.CreateInstance(o.EquivalentXenonOfferId);
                    VoucherUtil.GetUnactivatedBillingToken(xenonOffer.OfferId, out billingToken, out tokenSequenceNumber);

                    VoucherUtil.ActivateBillingToken(tokenSequenceNumber);

                    VoucherUtil.SetUnactivatedBillingTokenStatus(xenonOffer.OfferId, billingToken, (int)BillingTokenStatusEnum.Activated);

                    o = xenonOffer;
                }
                else
                {
                    billingToken = request.billingToken;
                }

                BillingProvider bdk = new BillingProvider();
                encryptedBillingToken = bdk.EncryptNumber(billingToken);
            }
            else
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_118,
                    "only SCG or token payment instruments can be used to purchase subscription renewals");
            }

            hr = o.IsOKToPurchase(request.countryID, request.tier, (int)request.paymentType);
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_119, "Offer.IsOKToPurchase failed");
            }

            if (BillingProvider.IsDummyId(u.AccountId))
            {
                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER, XEvent.Id.COMMON_BILLING_CODE_120,
                    "BillingProvider.IsDummyId(" + u.AccountId + ") returned true");
            }

            // Retrieving the PMN involves a call to Passport.  Make sure this happens
            // first so that if Passport is down, we fail the request here before adding
            // a dummy subscription row to t_subscriptions.
            string pmn = u.BillingPMN;

            Guid trackingGuid = Guid.NewGuid();

            if (renewSubscription)
            {
                PurchaseSubscriptionRenewal(request, u, offerID, instanceID, o, paymentInstrumentID, encryptedBillingToken, trackingGuid, pmn);
            }
            else
            {
                PurchaseNewSubscription(request, u, o, paymentInstrumentID, encryptedBillingToken, instanceID, offerID, subscriptionStatusID, trackingGuid, pmn);
            }

            if (paymentType == PaymentTypeEnum.Token)
            {
                // register the token usage (the one in the request... not the one which may have been substituted)
                hr = RegisterTokenUse(request.billingToken, voucherHash, request.userPuid);
                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_121, "Token usage registration in TokenDB failed");
                }

                // If an Xbox1 token was supplied and substituted with a
                // Xenon token, record that the token was consumed
                if (tokenSubstitution)
                {
                    VoucherUtil.SetUnactivatedBillingTokenStatus(o.OfferId, billingToken,
                        (int)BillingTokenStatusEnum.Consumed, request.userPuid);
                }
            }
            // if this was a trial offer, increment the number of trial
            // offers consumed by this console.
            //do it only if the offer is base offer and not a music subscription
            if (o.IsTrial && o.IsBaseOffer && !o.IsMusicNetSubscription)
            {
                Machine.IncrementTrialCount(request.machinePuid);
            }
        }

        internal static void PurchaseNewSubscription(XeOfferPurchaseRequest request, User u, Offer o, string paymentInstrumentId, string encryptedBillingToken, string baseInstanceId, ulong baseOfferId, int baseSubscriptionStatusId, Guid trackingGuid, string pmn)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(u != null);
            if (u == null)
            {
                throw new ArgumentException("u");
            }

            Debug.Assert(o != null);
            if (o == null)
            {
                throw new ArgumentException("o");
            }

            bool purchaseTimeout = false;

            //
            // There are two distinct cases here that need to be dealt with:
            //
            // (a) The user is a silver member who is purchasing an Xbox Live
            //     Gold subscription/membership
            // (b) The user is a gold or silver user purchasing a new game
            //     subscription/membership.
            //
            // The case of the Gold membership must be handled differently
            // because it's really an upgrade of their existing silver subscription
            // rather than a new subscription.
            //
            string tempID = string.Empty;

            Guid? catalogOfferId = null;

            Guid? catalogOfferInstanceId = null;

            if (Config.GetBoolSetting(Setting.billing_useCatalogSubscriptionOffers))
            {
                CatalogUtil.OfferIdToOfferInstanceId
                    (
                       o.OfferId
                     , (int)u.Tier
                     , u.CountryId
                     , request.paymentType
                     , out catalogOfferId
                     , out catalogOfferInstanceId
                     );
            }

            if (!o.IsBaseOffer && baseOfferId == 0)
            {
                //
                // Verify that the user doesn't have one if once-only policy is in effect
                //
                if (o.CanOnlyPurchaseOnce)
                {
                    if (o.GetInstances(u.Puid, request.machinePuid) > 0)
                    {
                        throw new XRLException(
                            HResult.XOFF_E_ALREADY_OWN_MAX, XEvent.Id.COMMON_BILLING_CODE_122,
                            "XeOfferPurchaseUtil.PurchaseSubscription: offer ID 0x" + o.OfferId.ToString("X") +
                            " allows a user to purhcase only one instance.  User 0x" + u.Puid.ToString("X") + " currently owns at least one instance.");
                    }
                }

                tempID = BillingProvider.GenerateDummyId(false);
                Offering.CommitPurchase(Offering.INITIAL_RECORD, u.Puid, request.machinePuid, o, "", tempID,catalogOfferId, catalogOfferInstanceId);
            }

            Price price;
            string subscriptionID = string.Empty;
            string serviceInstanceID = string.Empty;

            string billingOfferID = o.BillingOfferId(u.CountryId, u.Tier, (int)request.paymentType);


            if (!string.IsNullOrEmpty(billingOfferID))
            {
                DateTime postingDate = DateTime.UtcNow;

                try
                {
                    Offering.PurchaseEx(
                        billingOfferID,
                        u.BillingPuid,
                        u.Puid,
                        pmn,
                        u.AccountId,
                        paymentInstrumentId,
                        encryptedBillingToken,
                        trackingGuid.ToString(),
                        o.ServiceComponentId,
                        out price,
                        out subscriptionID,
                        out serviceInstanceID
                        );
                }
                catch (Exception e)
                {
                    if (e is System.ServiceProcess.TimeoutException || (e is WebException && FastFailHelper.ConsiderWebExceptionAsTimeout((WebException)e)))
                    {
                      Xom.NtEvent(XEvent.Id.COMMON_COMM_0, "SCS call to PurchaseOfferingEx and/or ProvisionServices "
                            +"SCS call to PurchaseOfferingEx and/or ProvisionServices "
                              + "has timed out! A subscription is in an indeterminate state but GRANTED POSSIBLY FOR"
                              + " FREE!! -- Follow up with SCG/MSNIA ops immediately!\n"
                            + "\tUser: " + u.GamerTag + " (0x" + u.Puid.ToString("x") + ")\n"
                            + "\tOffer: 0x" + request.offerIDs[0].ToString("x") + "\n\n" + e);
                        purchaseTimeout = true;
                    }
                    else if (e is BillingProviderException)
                    {
                        if (!o.IsBaseOffer)
                        {
                            Offering.CommitPurchase(Offering.DO_ROLLBACK, u.Puid, request.machinePuid, o, "", tempID,catalogOfferId,catalogOfferInstanceId);
                        }
                        throw;
                    }
                    else
                    {
                        throw;
                    }
                }

                //
                // Check here for potential misconfiguration of SCS offers.
                //
                if (o.IsPerUser && serviceInstanceID == "")
                {
                    Xom.NtEvent(XEvent.Id.COMMON_CONFIG_27, "A PER-USER offer (subscription) has no service instance ID! "
                          + "Chances are, LiveOffer has information that's different from what SCS knows.  Please verify "
                          + "consistency between the two data sets.  In particular, Xbox Live is using SCS offer " + billingOfferID
                        + " for Xbox offering Id 0x" + o.OfferId.ToString("X") + " in country " + CountryDictionary.CountryCode(u.CountryId)
                          + ".  Proceeding...\n\n");
                }

                //
                // If the offer is a MusicNet subscription offer and has a corresponding
                // MusicNet SKU, call MusicNet's AddSubscriptionOffer API now.
                if (o.IsMusicNetSubscription && o.MusicNetSku != string.Empty)
                {
                    if (o.IsTrial)
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "XeOfferPurchaseUtil.PurchaseSubscription: calling MusicNet.AddTrialSubscriptionOffer for user: 0x" + u.Puid.ToString("X") + " for MusicNet SKU: " + o.MusicNetSku);

                        try
                        {
                            MusicnetClient.AddTrialSubscriptionOffer(u.Puid, o.MusicNetSku, trackingGuid);
                        }
                        catch (Exception e)
                        {
                            // ignore the exception since the reconciliation code will correct it
                          Xom.NtEvent( XEvent.Id.MUSICNET_ADD_SUBSCRIPTION_OFFER_FAILED, "XeOfferPurchaseUtil.PurchaseSubscription: calling MusicNet.AddTrialSubscriptionOffer for user: 0x" + u.Puid.ToString("X") + " for MusicNet SKU: " + o.MusicNetSku + " failed.  Check Musicnet connectivity!\r\nException:\r\n" + e);
                        }
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "XeOfferPurchaseUtil.PurchaseSubscription: calling MusicNet.AddSubscriptionOffer for user: 0x" + u.Puid.ToString("X") + " for MusicNet SKU: " + o.MusicNetSku);

                        try
                        {
                            MusicnetClient.AddSubscriptionOffer(u.Puid, o.MusicNetSku, trackingGuid);
                        }
                        catch (Exception e)
                        {
                            // ignore the exception since the reconciliation code will correct it
                          Xom.NtEvent( XEvent.Id.MUSICNET_ADD_SUBSCRIPTION_OFFER_FAILED, "XeOfferPurchaseUtil.PurchaseSubscription: calling MusicNet.AddSubscriptionOffer for user: 0x" + u.Puid.ToString("X") + " for MusicNet SKU: " + o.MusicNetSku + " failed.  Check Musicnet connectivity!\r\nException:\r\n" + e);
                        }
                    }
                }
            }

            // if any reward is associated with the offer, process it now
            ProcessSubscriptionReward(request, u, o);

            //if ( o.IsBaseOffer || (baseInstanceId != null && baseInstanceId != string.Empty) )
            if (baseOfferId != 0)
            {
                RenewalUtil.MoveSubscription(
                    u.Puid,
                    baseOfferId,        // original offer ID returned by u.GetSubscriptionFromServiceComponentId
                    baseInstanceId,     // original instance ID returned by u.GetSubscriptionFromServiceComponentId
                    o.OfferId,          // new offer ID
                    serviceInstanceID,  // new service instance ID
                    catalogOfferId,
                    catalogOfferInstanceId,
                    DateTime.UtcNow);

                //
                // Update the subscription history with a record of this new offer
                //
                RenewalUtil.SetCurrentSubscriptionHistoryOffer(u.Puid, o.OfferId,catalogOfferId,catalogOfferInstanceId);

                // If the previous subscription is CANCELED, there will be no
                // EnableServices callback from SCS to change the state so it
                // must be moved from CANCELED to ENABLED now.
                if (baseSubscriptionStatusId == Subscription.CANCELED)
                {
                    u.SetSubscriptionStatusId(serviceInstanceID, Subscription.ENABLED);
                }
            }
            else
            {
                if (!purchaseTimeout)
                {
                    Offering.CommitPurchase(Offering.FINAL_COMMIT, u.Puid, request.machinePuid, o, serviceInstanceID, tempID,catalogOfferId,catalogOfferInstanceId);
                }
            }
        }

        internal static void PurchaseSubscriptionRenewal(XeOfferPurchaseRequest request, User u, ulong currOfferId, string currInstanceId, Offer o, string paymentInstrumentID, string encryptedBillingToken, Guid trackingGuid, string pmn)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(u != null);
            if (u == null)
            {
                throw new ArgumentException("u");
            }

            Debug.Assert(o != null);
            if (o == null)
            {
                throw new ArgumentException("o");
            }

            HResult hr;

            //
            // If the existing subscription has a pending cancellation, a
            // reinstatement (as opposed to a renenwal) will be performed
            // if the following conditions are true:
            //   (a) the renewal offer matches the existing offer
            //   (b) the offer is monthly
            //   (c) the offer has a fee associated with it (prepaid offers are tagged as free)
            //
            // Note that since a reinstatement of an existing subscription is
            // being performed, no validation of renewal paths is performed
            // as it there may not (correctly) be one present.
            //
            SubscriptionInfo origSubscriptionInfo = Subscription.GetSubscriptionInfo(u.BillingPuid, currInstanceId);

            uint currOfferDetails = Details.BuildDetailsFlagsNoTier(o, u.CountryId, (int)(PaymentTypeEnum.CreditCard | PaymentTypeEnum.Token));

            if (
                    origSubscriptionInfo.DelayedCancel == true
                 && currOfferId == o.OfferId
                 && Details.DetailsFlagsFrequency(currOfferDetails) == Details.MONTHLY
                 && Details.DetailsFlagsIsForFee(currOfferDetails)
               )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL,
                    "XeOfferPurchaseUtil.PurchaseSubscriptionRenewal: user: 0x" + u.Puid.ToString("X") +
                    ": subscription to offerId: 0x" + currOfferId.ToString("X") +
                    " flagged for DelayedCancel and is monthly subscription.  Attempting to cancel the delayed cancel... (id: " + origSubscriptionInfo.SubscriptionId +
                    ", instanceId: " + origSubscriptionInfo.Instance.ServiceInstanceId + ")...");

                // call CancelSubscription with a cancelDate of "UNDO_DELAYED_EXPIRE" to uncancel
                string cancelDate = "UNDO_DELAYED_EXPIRE";
                string trGuid = null;
                Offering.Cancel(currInstanceId, (long)u.BillingPuid, request.machinePuid, cancelDate, out trGuid);

                // unset the cancel-in-progress transaction flag since it is not really a cancel
                XeSubscriptionUtil.RollbackCancel(u.Puid, currOfferId, currInstanceId);

                return;
            }

            // validate the renewal path
            ulong origSubscriptionOfferID;
            string origSubscriptionInstanceID;
            int convertMode;

            hr = o.XeValidateRenewalPath(u.Puid, u.CountryId, u.Tier, (int)request.paymentType,
                                         out origSubscriptionOfferID, out origSubscriptionInstanceID, out convertMode);

            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_124, "Offer.XeValidateRenewalPath failed");
            }

            Debug.Assert(currOfferId == origSubscriptionOfferID);
            Debug.Assert(currInstanceId == origSubscriptionInstanceID);

            // SCS does not allow us to specify a new payment instrument id
            // when calling ConvertSubscriptionEx to schedule a renewal or
            // when converting from a billed offer to another billed offer.
            //
            // In order to change the payment instrument id in these cases,
            // renewal, first call UpdateSubscriptionInfo to change the
            // existing payment instrument id associated with the
            // subscription and then call ConvertSubscriptionEx.
            if (!string.IsNullOrEmpty(paymentInstrumentID) && paymentInstrumentID != origSubscriptionInfo.PaymentInstrumentId)
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW,
                         "XeOfferPurchaseUtil.PurchaseSubscription: changing payment instrument for subscription id: " + origSubscriptionInfo.SubscriptionId + " from: " + origSubscriptionInfo.PaymentInstrumentId + " to " + paymentInstrumentID + " (user 0x" + u.BillingPuid.ToString("X") + ", gamertag: " + u.GamerTag + ")");

                Subscription.UpdatePaymentInstrumentInfo(
                    u.BillingPuid,
                    pmn,
                    origSubscriptionInfo.ShippingAddressId,
                    Guid.NewGuid().ToString(),
                    origSubscriptionInfo.SubscriptionId,
                    origSubscriptionInfo.PaymentInstrumentId,
                    paymentInstrumentID);
            }

            // if the current subscription has a delayed cancel, remove it now, but for token renew, we shouldn't change the cancel status (Bug 188778)
            if ( (origSubscriptionInfo.DelayedCancel == true) && ((uint)PaymentTypeEnum.Token != request.paymentType) )
            {
                RemoveDelayedCancel(u, request.machinePuid, currInstanceId, currOfferId, origSubscriptionInfo);
            }

            try
            {
                //
                // There are only certain cases where a payment instrument
                // id is allowed and the logic for determining which cases
                // will allow one and which ones won't is not trivial.
                // Since we are confident that we don't have any cases
                // where conversions happen from prepaid to billed offers
                // (those should all be renewals), we will always send an
                // empty string for payment instrument id.
                //
                Subscription.RenewSubscriptionEx(
                    u.BillingPuid,
                    pmn,
                    origSubscriptionInfo.SubscriptionId,
                    o.BillingOfferId(u.CountryId, u.Tier, (int)request.paymentType),
                    trackingGuid.ToString(),
                    convertMode,
                    string.Empty,
                    encryptedBillingToken
                    );

                Guid? catalogOfferId = null;

                Guid? catalogOfferInstanceId = null;

                if (Config.GetBoolSetting(Setting.billing_useCatalogSubscriptionOffers))
                {
                    CatalogUtil.OfferIdToOfferInstanceId
                     (
                        o.OfferId
                      , (int)u.Tier
                      , u.CountryId
                      , request.paymentType
                      , out catalogOfferId
                      , out catalogOfferInstanceId
                      );
                }


                //
                // Update the subscription history with a record of this new offer
                //
                RenewalUtil.SetCurrentSubscriptionHistoryOffer(u.Puid, o.OfferId,catalogOfferId,catalogOfferInstanceId);

                //
                // If the offer is a MusicNet subscription offer and has a corresponding
                // MusicNet SKU, call MusicNet's AddSubscriptionOffer API now.
                if (o.IsMusicNetSubscription && o.MusicNetSku != string.Empty)
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "XeOfferPurchaseUtil.PurchaseSubscriptionRenewal: calling MusicNet.AddSubscriptionOffer for user: 0x" + u.Puid.ToString("X") + " for MusicNet SKU: " + o.MusicNetSku);

                    try
                    {
                        MusicnetClient.AddSubscriptionOffer(u.Puid, o.MusicNetSku, trackingGuid);
                    }
                    catch (Exception e)
                    {
                        // ignore the exception since the reconciliation code will correct it
                      Xom.NtEvent( XEvent.Id.MUSICNET_ADD_SUBSCRIPTION_OFFER_FAILED, "XeOfferPurchaseUtil.PurchaseSubscription: calling MusicNet.AddSubscriptionOffer for user: 0x" + u.Puid.ToString("X") + " for MusicNet SKU: " + o.MusicNetSku + " failed.  Check Musicnet connectivity!\r\nException:\r\n" + e);
                    }
                }

                // If the purchase is a token offer and has a reward
                // offer associated with it, process it now.  Rewards
                // are currently not granted for credit card offers unless
                // it's part of a new account creation because we cannot
                // prevent users from scheduling renewals repeatedly to
                // collect the reward points.
                if ((uint)PaymentTypeEnum.Token == request.paymentType)
                {
                    ProcessSubscriptionReward(request, u, o);
                }

                if (origSubscriptionInfo.DelayedCancel == false)
                {
                    // If the subscription originally had a renewal offering
                    // associated with it but no longer has one following the
                    // ConvertSubscriptionEx call, make another call to restore
                    // the renewal offering.
                    if ((origSubscriptionInfo.RenewOfferingId != null) && (origSubscriptionInfo.RenewOfferingId != string.Empty))
                    {
                        ReinstateRenewalOffer(u, origSubscriptionInfo, origSubscriptionInstanceID, paymentInstrumentID, pmn);
                    }
                }
                else
                {
                    // If user originally canceled the subscription and now redeemed a token,
                    // Make sure the delayed cancel is still there. This is neccessory because CAP tool and CTP behavior 
                    // after ConvertSubscriptionEx call will make the renew show up again for the user. (Bug 188778)
                    if ((uint)PaymentTypeEnum.Token == request.paymentType)
                    {
                        ReinstateDelayedCancel(u, request.machinePuid, currInstanceId, currOfferId, origSubscriptionInfo);
                    }
                }
            }
            catch (BillingProviderException e)
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "XeOfferPurchaseUtil.PurchaseSubscription: encountered billing error while attempting to purchase renewal!\r\n" + e);

                throw;
            }

            //
            // If we got this far, then we actually performed the renewal. We must succeed to the client.
            //

            try
            {
                XeSubscriptionUtil.FlagSubscriptionAsPendingMove(u.Puid,
                                                                 origSubscriptionOfferID, origSubscriptionInstanceID);

                XeSubscriptionUtil.ClearSubscriptionNotifications(u.Puid, o.TitleId, origSubscriptionInstanceID);
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.COMMON_CONFIG_26,
                           "Failure cleaning up after renewal. Ignoring failure and"
                           + " returning success to client.\n\n" + e);

                //
                // do nothing else
                //
            }
        }

        internal static void RemoveDelayedCancel(User u, ulong machinePuid, string currInstanceId, ulong currOfferId, SubscriptionInfo subInfo)
        {
            // if the current subscription has a delayed cancel, remove it now
            if (false == subInfo.DelayedCancel)
            {
                return;
            }

            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, string.Format("XeOfferPurchaseUtil.RemoveDelayedCancel: user: 0x{0}, subscription id:{1} to offerId: 0x{2} is flagged with DelayedCancel. Attempting to remove the DelayedCancel... ", u.Puid.ToString("x"), subInfo.SubscriptionId, currOfferId.ToString("x")));

            try
            {
                // call CancelSubscription with a cancelDate of "UNDO_DELAYED_EXPIRE" to uncancel
                string cancelDate = "UNDO_DELAYED_EXPIRE";
                string trGuid = null;
                Offering.Cancel(currInstanceId, (long)u.BillingPuid, machinePuid, cancelDate, out trGuid);
            }
            finally
            {
                // unset the cancel-in-progress transaction flag since it is not really a cancel
                XeSubscriptionUtil.RollbackCancel(u.Puid, currOfferId, currInstanceId);
            }
        }

        internal static void ReinstateDelayedCancel(User u, ulong machinePuid, string currInstanceId, ulong currOfferId, SubscriptionInfo subInfo)
        {
            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, string.Format("XeOfferPurchaseUtil.ReinstateDelayedCancel: user: 0x{0}, subscription id:{1} to offerId: 0x{2} was flagged with DelayedCancel before. Attempting to reinstate the DelayedCancel... ", u.Puid.ToString("x"), subInfo.SubscriptionId, currOfferId.ToString("x")));

            try
            {
                // call CancelSubscription with a cancelDate of "DELAYED_EXPIRE" to delayed cancel.
                string cancelDate = "DELAYED_EXPIRE";
                string trGuid = null;
                Offering.Cancel(currInstanceId, (long)u.BillingPuid, machinePuid, cancelDate, out trGuid);
            }
            catch (Exception e)
            {
                string msg = "XeOfferPurchaseUtil.ReinstateDelayedCancel: attempt to reinstate DelayedCancel for user 0x" + u.Puid.ToString("x") + " failed.";
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg + " Exception:\r\n" + e);
                Xom.NtEvent(XEvent.Id.REINSTATE_DELAYED_CANCEL_FAILURE, msg);
            }
        }

        internal static void ReinstateRenewalOffer(User u, SubscriptionInfo origSubscriptionInfo, string origInstanceId, string paymentInstrumentId, string passportMemberName)
        {
            SubscriptionInfo newSubscriptionInfo = Subscription.GetSubscriptionInfo(u.BillingPuid, origInstanceId);
            if (newSubscriptionInfo.RenewOfferingId == null || newSubscriptionInfo.RenewOfferingId == string.Empty)
            {
                try
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "XeOfferPurchaseUtil.ReinstateRenewalOffer: user 0x" + u.Puid.ToString("X") + " ('" + u.GamerTag + "'): renenwal offer was '" + origSubscriptionInfo.RenewOfferingId + "' and is no longer set.  Calling ConvertSubscriptionEx to restore renewal offering...");

                    Subscription.RenewSubscriptionEx(
                        u.BillingPuid,
                        passportMemberName,
                        origSubscriptionInfo.SubscriptionId,
                        origSubscriptionInfo.RenewOfferingId,
                        Guid.NewGuid().ToString(),
                        Subscription.MODE_RENEW,
                        paymentInstrumentId,
                        string.Empty
                    );
                }
                catch (Exception e)
                {
                    string msg = "XeOfferPurchaseUtil.ReinstateRenewalOffer: attempt to set renenwal offer to '" + origSubscriptionInfo.RenewOfferingId + "' failed";
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg + " Exception:\r\n" + e);
                  Xom.NtEvent(XEvent.Id.COMMON_CODE_9, msg);
                }
            }
        }

        internal static void ProcessSubscriptionReward(XeOfferPurchaseRequest request, User u, Offer o)
        {
            // if any reward is associated with the offer,
            // process it now
            if (o.HasReward(u.CountryId, (int)TierEnum.NewUser))
            {
                if (u.BillingPuid != u.PassportPuid)
                {
                    throw new Exception("BillingPuid != PassportPuid in PurchaseSubscription.");
                }

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW,
                    "XeOfferPurchaseUtil.ProcessSubscriptionReward: offer: 0x" + o.OfferId.ToString("X") +
                    " has reward id: " + o.RewardId(u.CountryId, u.Tier) +
                    " associated with it.  Processing now for user: 0x" + u.Puid.ToString("X") +
                    " (Passport puid: 0x" + u.BillingPuid.ToString("X") + ")");

                DMPClient dmpClient = new DMPClient(u.CountryId);

                dmpClient.ProcessSubscriptionReward(
                    u.Puid,
                    u.BillingPuid,
                    request.machinePuid,
                    o.OfferId,
                    u.CountryId,
                    u.CultureId,
                    u.Tier
                    );
            }
        }

        public static byte[] ValidateVoucherForOffer(XeOfferPurchaseRequest request)
        {
            bool isScsToken;
            return ValidateVoucherForOffer(request, out isScsToken);
        }

        public static byte[] ValidateVoucherForOffer(XeOfferPurchaseRequest request, out bool isScsToken)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(request.offerIDs != null);
            if (request.offerIDs == null)
            {
                throw new ArgumentException("request.offerIDs");
            }

            HResult hr = HResult.S_OK;

            byte[] voucherHash;

            if (request.billingToken == null || request.billingToken == string.Empty)
                voucherHash = null;
            else
                voucherHash = VoucherUtil.GetVoucherHash(request.billingToken);

            if (voucherHash == null)
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_129, "Voucher payment type requires a voucher");

            Offer o = Offer.CreateInstance(request.offerIDs[0]);
            if ((o.IsXbox1Offer && !o.RequiresVoucher) || (o.IsXenonOffer && !o.AcceptsVoucher(request.countryID, request.tier)))
            {
                // 39444: throw an error that the voucher is invalid (although it is a valid voucher,
                // technically).  In the future we should return a new error that says "you can't redeem
                // this token, due to tier/country/whatever"...

                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_VOUCHER_INVALID_FOR_TIER, XEvent.Id.COMMON_BILLING_CODE_130,
                    "Voucher payment attempt on an offer/country/tier which doesn't accept vouchers");
            }

            // verify that this token hasn't been consumed yet
            if ( VoucherUtil.IsLiveGeneratedToken(request.billingToken) )
            {
                string catalogOfferId;
                int mediaTypeId;
                string pkpn;

                hr = VoucherUtil.ValidateEmsToken(voucherHash, out catalogOfferId, out mediaTypeId, out isScsToken, out pkpn);
            }
            else
            {
                hr = o.ValidateVoucherForOffer(voucherHash, out isScsToken);
            }
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_131, string.Format(
                    "Failed to validate voucher for offer {0}",
                    request.offerIDs[0].ToString("x8")));
            }

            return voucherHash;
        }

        internal static HResult RegisterTokenUse(string billingToken, byte[] tokenHash, Puid userPuid)
        {
            if ( VoucherUtil.IsLiveGeneratedToken(billingToken) )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "RegisterTokenUse: recording usage for LIVE-generated hash: {0}, user: 0x{1}...", ByteConvert.ToString(tokenHash), userPuid.ToString());
                return VoucherUtil.RegisterEmsTokenUse(tokenHash, userPuid);
            }
            else
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "RegisterTokenUse: recording usage for legacy TokenDB hash: {0}, user: 0x{1}...", ByteConvert.ToString(tokenHash), userPuid.ToString());
                return VoucherUtil.RegisterVoucherUse(tokenHash, userPuid);
            }
        }

        internal static void ValidateScsTokenForContentOffer(XeOfferPurchaseRequest request, Offer o)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            //
            // This method is no longer called. It was called when game content was purchased
            // with XeOfferPurchase. This should be removed when the XeOfferPurchase code
            // supporting game content is removed.
            //
#if false
            string encryptedPassword = null;
            string paymentInstrumentId = null;

            try
            {
                // TODO:
                //
                // XeOfferPurchase has already instantiated a User object but does not bother
                // to pass it along.  As a result, it is necessary to make another stored
                // procedure call to instantiate it one more time.  This is unfortunate but
                // replumbing the Purchase codepaths is beyond the scope of the QFE that is
                // responsible for this method being added.
                //
                User u = new User();
                u.Load(request.userPuid);

                SCSPurchaseItem purchaseItem = new SCSPurchaseItem();

                purchaseItem.Purchase(
                    request.userPuid,
                    request.machinePuid,
                    u.BillingPuid,
                    u.AccountId,
                    request.offerIDs[0],
                    paymentInstrumentId,
                    request.billingToken,
                    null,
                    encryptedPassword,
                    request.countryID,
                    request.tier);
            }
            catch (Exception e)
            {
                if ( FastFailHelper.ConsiderExceptionAsTimeout(e) )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ValidateScsTokenForContentOffer: timeout occurred while validating content token...  assuming success.");
                    return;
                }

                throw;
            }
#endif
        }

        public static void PurchaseGameplay(XeOfferPurchaseRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(request.offerIDs != null);
            if (request.offerIDs == null)
            {
                throw new ArgumentException("request.offerIDs");
            }

            if (request.paymentType != (uint)PaymentTypeEnum.Token)
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_132, "Gameplay can only be purchased with tokens at this point");

            byte[] voucherHash = ValidateVoucherForOffer(request);

            // record the gameplay purchase in t_subscriptions
            RecordGameplayPurchase(request.userPuid, request.offerIDs[0]);

            // register the voucher usage
            HResult hr = RegisterTokenUse(request.billingToken, voucherHash, request.userPuid);
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_133, "Token use registration in TokenDB failed");
            }
        }

        public static void PurchasePointsBundle(XeOfferPurchaseRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(request.offerIDs != null);
            if (request.offerIDs == null)
            {
                throw new ArgumentException("request.offerIDs");
            }

            User u = new User();
            u.Load(request.userPuid);
            ulong userPassportPuid = u.BillingPuid;
            string accountID = u.AccountId;

            string paymentInstrumentID = null;
            string encryptedPassword = null;
            string billingToken = null;

            byte[] voucherHash = null;
            PaymentTypeEnum paymentType = (PaymentTypeEnum)request.paymentType;
            if (paymentType == PaymentTypeEnum.CreditCard)
                paymentInstrumentID = request.paymentInstrumentID;
            else if (paymentType == PaymentTypeEnum.Wholesale)
            {
                paymentInstrumentID = request.paymentInstrumentID;
                encryptedPassword = request.encryptedPassword;
            }
            else if (paymentType == PaymentTypeEnum.Token)
            {
                billingToken = request.billingToken;

                voucherHash = ValidateVoucherForOffer(request);
            }
            else
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_134,
                    "only scg or token payment instruments can be used to purchase point bundle offers");
            }

            if (ScsQueue.PumpPurchaseItemQueue == true &&
                SCSPurchaseItem.UserHasAnyPendingPointsPurchases(request.userPuid))
            {
                // the pump is turned on and the user has some queued points purchase transactions

                throw new XRLException(HResult.XONLINE_E_PENDING_POINTS_PURCHASE, XEvent.Id.COMMON_BILLING_CODE_135,
                    "the user already has a pending points purchase transaction, and the scs purchaseItem queue " +
                    "is pumping.  after the transaction goes through the user may purchase more points if they want");
            }

            SCSPurchaseItem purchaseItem = new SCSPurchaseItem();
            purchaseItem.Purchase(request.userPuid, request.machinePuid, userPassportPuid, accountID,
                request.offerIDs[0], paymentInstrumentID, billingToken, voucherHash, encryptedPassword, request.countryID, request.tier, null);

            if (paymentType == PaymentTypeEnum.Token)
            {
                // register the voucher usage
                HResult hr = RegisterTokenUse(request.billingToken, voucherHash, request.userPuid);
                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_136, "Token use registration in TokenDB failed");
                }
            }
        }

        public static void PurchaseRewardOffer(XeOfferPurchaseRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            Debug.Assert(request.offerIDs != null);
            if (request.offerIDs == null)
            {
                throw new ArgumentException("request.offerIDs");
            }

            HResult hr = HResult.S_OK;

            if (request.paymentType != (uint)PaymentTypeEnum.Token)
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_137, "Rewards can only be redeemed with tokens at this point");

            byte[] voucherHash;
            if (request.billingToken == null || request.billingToken == string.Empty)
                voucherHash = null;
            else
                voucherHash = VoucherUtil.GetVoucherHash(request.billingToken);

            if (voucherHash == null)
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_138, "Voucher payment type requires a voucher");

            Offer o = Offer.CreateInstance(request.offerIDs[0]);
            if (!o.AcceptsVoucher(request.countryID, request.tier))
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_139,
                    "Voucher payment attempt on an offer/country/tier which doesn't accept vouchers");
            }

            // verify that this voucher hasn't been consumed yet
            hr = o.ValidateVoucherForOffer(voucherHash);
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_140, string.Format(
                    "Failed to validate voucher for offer {0}",
                    request.offerIDs[0].ToString("x8")));
            }

            if (o.OfferType != (uint)OfferingTypeEnum.PromoPoints)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_141, "OfferID is not a promo-points/reward offer type");
            }

            int cultureID = Culture.GetCultureFromLanguageCountry(request.languageID, request.countryID);

            User u = new User();
            u.Load(request.userPuid);
            ulong userPassportPuid = u.BillingPuid;

            DMPClient dmpClient = new DMPClient(request.countryID);

            //
            // #170095 - Promo Points - Pressing Redeem twice quickly on Xbox.com causes points to be added twice
            //
            // Because there is no way to undo the granting of promo points, the token usage will be registered first
            // since it can be done within a transaction and thus can be rolled back if the DMP AddPromotionalBalance
            // API fails.
            //
            using (TransactionScope txn = new TransactionScope())
            {
                // register the token usage within a transaction in TokenDB
                hr = RegisterTokenUse(request.billingToken, voucherHash, request.userPuid);

                // A failed HRESULT will be returned if the token has already been used or is not found --
                // since these are not actionable by Ops, no event will be logged.
                //
                // Database access errors, etc. will result in an exception being thrown which will cause
                // the TransactionScope to be disposed of without committing the transaction, resulting in
                // a rollback.
                if (HResult.Failed(hr))
                {
                    string msg = string.Format("RegisterTokenUse failed with hr: 0x{0}", hr.ToString());

                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                    throw new XRLExceptionWithoutEvent(hr, msg);
                }

                dmpClient.GrantRewardOffer(request.userPuid, userPassportPuid, request.machinePuid, request.offerIDs[0], cultureID);

                // now that DMP.AddPromotionalBalance succeeded, it is safe to commit the transaction
                txn.Complete();
            }
        }

        public static void RecordGameplayPurchase(ulong userPuid, ulong offerID)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_xbos_purchase_gameplay";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_offer_id", offerID);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_143, msg);
                }

                AuditStream.Write(userPuid, AuditSubsystem.XBOS, ws, "success");
            }
        }
    }

    public class XePointsUtil
    {
        private XePointsUtil()
        {
        }

        public static XeGetPointsBalanceResponse GetBalance(XeGetPointsBalanceRequest request)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            User u = new User();
            u.Load(request.userPuid);
            ulong passportPuid = u.BillingPuid;
            byte countryID = u.CountryId;

            DMPClient dmpClient = new DMPClient(countryID);

            int balance;
            bool aboveLowBalance;
            DMPWSDL.Status statusUser;
            string country;

            dmpClient.GetBalance(passportPuid, out balance, out aboveLowBalance, out statusUser, out country);

            XeGetPointsBalanceResponse response = new XeGetPointsBalanceResponse();

            response.pointsBalance = (uint)balance;
            response.dmpAccountStatus = (byte)statusUser;
            response.aboveLowBalance = aboveLowBalance;

            return response;
        }
    }

    public class XeContentReferralUtil
    {
        public static XeContentReferralResponse XeContentReferral(XeContentReferralRequest request, out ulong machineId,
            out ulong[] offers)
        {
            Debug.Assert(request != null);
            if (request == null)
            {
                throw new ArgumentException("request");
            }

            machineId = 0;
            offers = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(request.userId);

                ws.StoredProc = "dbo.p_xbos_xenon_content_referral";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_id", request.userId);
                ws.AddParameter("@b_content_id", request.contentId);

                using (WstDataReader r = ws.Execute())
                {
                    XeContentReferralResponse response = new XeContentReferralResponse();
                    bool fSucceeded = false;

                    // First rowset is the machine id in the license
                    if (!r.Read())
                        goto lProcessRetVal;

                    machineId = (ulong)r.GetInt64(0);

                    // Second rowset contains content package details
                    if (!r.NextResult() || !r.Read())
                        goto lProcessRetVal;

                    response.packageSize = (uint)r.GetInt32(0);
                    response.installSize = (uint)r.GetInt32(1);
                    response.symKey = new byte[XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN];
                    r.GetBytes(2, 0, response.symKey, 0, (int)xonline.common.service.XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN);
                    response.pubKey = new byte[XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN];
                    r.GetBytes(3, 0, response.pubKey, 0, (int)xonline.common.service.XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN);

                    // Third rowset contains the locations
                    if (!r.NextResult() || !r.Read())
                        goto lProcessRetVal;

                    ArrayList locations = new ArrayList();
                    do
                    {
                        XeContentReferralLocation location = new XeContentReferralLocation();
                        location.rank = (ushort)r.GetInt32(0);
                        location.xrl = r.GetString(1);
                        locations.Add(location);
                    } while (r.Read());

                    response.locations = (XeContentReferralLocation[])locations.ToArray(typeof(XeContentReferralLocation));

                    // Fourth rowset contains offers the user has purchased for this content
                    if (r.NextResult() && r.Read())
                    {
                        List<ulong> offerList = new List<ulong>();
                        do
                        {
                            ulong offerID = (ulong)r.GetInt64(0);
                            offerList.Add(offerID);
                        } while (r.Read());

                        offers = offerList.ToArray();
                    }

                    fSucceeded = true;

                lProcessRetVal:

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@RETVAL");

                    if (!fSucceeded && HResult.Succeeded(hr))
                    {
                        hr = HResult.XONLINE_E_OFFERING_MISSING_RESULTS;
                    }

                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);
                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_161, msg);
                    }

                    return response;
                }
            }
        }
    }

    public class UserRightsUtil
    {
        static readonly DateTime s_minValidSqlDatetime = new DateTime(1753, 1, 1, 0, 0, 0, DateTimeKind.Utc);

        public enum LateBindingMachineState
        {
            None,
            Dirty,
            Updated,
        }

        public class MediaInstanceRights
        {
            public MediaInstanceRights()
            {
                purchased = false;
                lateBindingMachineState = LateBindingMachineState.None;
            }

            public Guid mediaInstanceId;
            public Guid offerId;

            public int instanceMediaTypeId;
            public int offerMediaTypeId;
            public Guid offerInstanceId;

            public bool isAcquirable;
            public bool isPreview;
            public bool isGeofenced;
            public DateTime absoluteExpiration; // absolute expiration date of the content, or DateTime.MinValue if none

            public int licenseTypeId;
            public int licenseClassId;
            public List<int> clientTypes;
            public string licenseXml;

            // if mediaType is video and the video content is hosted by SyncCast, then the following 3 are filled out
            public string scoid;
            public string syncCastKey;
            public string encryptedSeed;

            // if mediaType is Avatar, then the following is filled out
            public string assetId;

            // if mediaType is one of the game content media types, then this value is the set of bits
            // that the provider wants to allow for the content for this particular offerInstance.
            // otherwise this value is meaningless
            public uint licenseExtensionBits;

            public bool purchased;
            public DateTime purchaseDate;
            public ulong machineId;
            public LateBindingMachineState lateBindingMachineState;
        }

        // This version searches for all offers to the given list in the miops array
        public static List<MediaInstanceRights> GetUserMediaInstanceRights(
            ulong xuid,
            Guid[] mis
            )
        {
            User u = new User();
            u.Load(xuid);
            string isoCountryCode = CountryDictionary.CountryCode(u.CountryId);

            // get all the catalogInfo on the miid/oid pair
            List<MediaInstanceRights> mirs = GetMediaInstanceRights(isoCountryCode, mis);

            // fill in details on which of the rights have actually been purchased,
            // and remove any mediaInstanceRights that have not been purchased
            FinalizeWithUserPurchases(xuid, mirs, delegate(MediaInstanceRights mir) { return mir.purchased == false && mir.licenseTypeId != 13; });

            return mirs;
        }

        public static void FinalizeWithUserPurchases(ulong xuid, List<MediaInstanceRights> mirs, Predicate<MediaInstanceRights> pRemove)
        {
            Debug.Assert(mirs != null);
            if (mirs == null)
            {
                throw new ArgumentException("mirs");
            }

            // fill in details on which of the rights have actually been purchased
            UpdateWithUserPurchases(xuid, mirs);

            mirs.RemoveAll(pRemove);
        }

        public static void UpdateWithUserPurchases(ulong xuid, List<MediaInstanceRights> mirs)
        {
            Debug.Assert(mirs != null);
            if (mirs == null)
            {
                throw new ArgumentException("mirs");
            }

            StringBuilder instanceXml = new StringBuilder();
            foreach (MediaInstanceRights mir in mirs)
            {
                if (mir == null || mir.offerInstanceId == null)
                {
                    throw new ArgumentException("mirs (null element)");
                }

                if (String.IsNullOrEmpty(mir.assetId))
                {
                    instanceXml.Append(string.Format("<item oiid=\"{0}\"/>", mir.offerInstanceId.ToString()));
                }
                else
                {
                    instanceXml.Append(string.Format("<item oiid=\"{0}\" aid=\"{1}\"/>", mir.offerInstanceId.ToString(), mir.assetId));
                }
            }

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(xuid);

                ws.StoredProc = "dbo.p_xbos_get_user_offer_instance_purchases";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", xuid);
                ws.AddParameter("@xml_offers", instanceXml.ToString());

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        Guid offerInstanceId = r.GetGuid(0);
                        ulong machinePuid = (ulong)r.GetInt64(1);
                        DateTime purchaseDate = r.GetDateTime(2);

                        foreach (MediaInstanceRights mir in mirs)
                        {
                            if (mir.offerInstanceId == offerInstanceId)
                            {
                                mir.purchased = true;
                                mir.machineId = machinePuid;
                                mir.purchaseDate = purchaseDate;

                                // keep processing because a user may be attempting to purchase
                                // more than one episode of a season and there may be more than
                                // one offerInstaceId in mirs that match a given row in the database
                                continue;
                            }
                        }
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_100, msg);
                    }
                }
            }
        }

        public static List<MediaInstanceRights> GetMediaInstanceRights(string countryCode,
            MediaInstanceIdOfferIdPair[] miops,
            bool useZestStore)
        {
            Debug.Assert(miops != null);
            if (miops == null)
            {
                throw new ArgumentException("miops");
            }

            StringBuilder instanceXml = new StringBuilder();
            foreach (MediaInstanceIdOfferIdPair miop in miops)
            {
                if (miop == null || miop.miid == null || miop.oid == null)
                {
                    throw new ArgumentException("miops (null element)");
                }

                instanceXml.Append(string.Format("<item miid=\"{0}\" oid=\"{1}\"/>",
                    miop.miid.ToString(), miop.oid.ToString()));
            }

            return GetMediaInstanceRights(countryCode, instanceXml.ToString(), "dbo.GetMediaInstanceRights", useZestStore);
        }

        public static List<MediaInstanceRights> GetMediaInstanceRights(string countryCode,
            Guid[] mis)
        {
            Debug.Assert(mis != null);
            if (mis == null)
            {
                throw new ArgumentException("mis");
            }

            StringBuilder instanceXml = new StringBuilder();
            foreach (Guid mi in mis)
            {
                instanceXml.Append(string.Format("<item miid=\"{0}\"/>",
                    mi.ToString()));
            }

            return GetMediaInstanceRights(countryCode, instanceXml.ToString(), "dbo.GetMediaInstanceRightsAll", false);
        }

        internal static List<MediaInstanceRights> GetMediaInstanceRights(string countryCode,
            string instanceXml,
            string sproc,
            bool useZestStore)
        {
            string connectionString = useZestStore ?
                ConfigUtil.FECatalogDBZuneConnectionString : ConfigUtil.FECatalogDBXboxConnectionString;

            using (SqlConnection c = new SqlConnection(connectionString))
            {
                c.Open();

                using (SqlCommand cmd = c.CreateCommand())
                {
                    cmd.CommandText = sproc;
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@countryCode", SqlDbType.NVarChar, 2).Value = countryCode;
                    cmd.Parameters.Add("@instanceXml", SqlDbType.NVarChar, Int32.MaxValue).Value = instanceXml;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        List<MediaInstanceRights> mirs = new List<MediaInstanceRights>();

                        while (r.Read())
                        {
                            Guid mediaInstanceId = r.GetGuid(0);
                            int mediaInstanceMediaTypeId = r.GetInt32(1);
                            Guid offerId = r.GetGuid(2);
                            Guid offerInstanceId = r.GetGuid(3);
                            int licenseTypeId = r.GetInt32(4);
                            int licenseClassId = r.GetInt32(5);
                            byte isAcquirable = r.GetByte(6);
                            byte isPreview = r.GetByte(7);
                            string scoid = r.GetString(8);
                            string syncCastKey = r.GetString(9);
                            string encryptedSeed = r.GetString(10);
                            int licenseExtensionBits = r.GetInt32(11);
                            DateTime expirationDate = r.GetDateTime(12);
                            int instanceMediaGeoCheckPolicy = r.GetByte(13);
                            int offerMediaGeoCheckPolicy = r.GetByte(14);

                            int offerMediaTypeId = mediaInstanceMediaTypeId;
                            string licenseXml = String.Empty;
                            string assetId = String.Empty;

                            // sproc changes for PS 2857 are back-compat.
                            // this makes c# code back-compat also.
                            if (r.FieldCount > 15)
                            {
                                offerMediaTypeId = r.GetInt32(15);
                                licenseXml = r.GetString(16);
                            }

                            // this makes c# code back-compat also.
                            if (r.FieldCount > 17)
                            {
                                assetId = r.GetString(17);
                            }

                            MediaInstanceRights mir = new MediaInstanceRights();
                            mir.mediaInstanceId = mediaInstanceId;
                            mir.instanceMediaTypeId = mediaInstanceMediaTypeId;
                            mir.offerId = offerId;
                            mir.offerMediaTypeId = offerMediaTypeId;
                            mir.offerInstanceId = offerInstanceId;
                            mir.licenseTypeId = licenseTypeId;
                            mir.licenseClassId = licenseClassId;
                            mir.isAcquirable = isAcquirable == 1;
                            mir.isPreview = isPreview == 1;
                            mir.scoid = scoid;
                            mir.syncCastKey = syncCastKey;
                            mir.encryptedSeed = encryptedSeed;
                            mir.licenseExtensionBits = (uint)licenseExtensionBits;
                            if (expirationDate == s_minValidSqlDatetime)
                                mir.absoluteExpiration = DateTime.MinValue;
                            else
                                mir.absoluteExpiration = expirationDate;
                            mir.clientTypes = new List<int>();
                            mir.isGeofenced = (instanceMediaGeoCheckPolicy == (uint)GeoCheckPolicy.GeoFence)
                                | (offerMediaGeoCheckPolicy == (uint)GeoCheckPolicy.GeoFence);
                            mir.licenseXml = licenseXml;
                            mir.assetId = assetId;

                            mirs.Add(mir);
                        }

                        if (r.NextResult())
                        {
                            while (r.Read())
                            {
                                Guid mediaInstanceId = r.GetGuid(0);
                                Guid offerId = r.GetGuid(1);
                                int clientTypeId = r.GetInt32(2);

                                foreach (MediaInstanceRights mir in mirs)
                                {
                                    if (mir.mediaInstanceId == mediaInstanceId &&
                                        mir.offerId == offerId)
                                    {
                                        mir.clientTypes.Add(clientTypeId);
                                    }
                                }
                            }
                        }

                        r.Close();

                        HResult hr = (uint)((int)ret.Value);
                        if (HResult.Failed(hr))
                        {
                            string msg = "dbo.GetMediaInstanceRights failed with hr = " + hr;

                            throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_100, msg);
                        }

                        return mirs;
                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Comment.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

//
// This source code was auto-generated by xsd, Version=1.1.4322.573.
//
using System.Xml.Serialization;
using System.IO;


namespace  xonline.common.billing
{

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class CommentInfoSet
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("CommentInfo")]
        public CommentInfo[] Items;

        /// <summary>
        /// Custom Method -- must be reapplied if this class is autogenerated.
        /// </summary>
        /// <returns></returns>
        public string ToXml()
        {

            // for this object, it might have been less work to just create the XML string from literals
            // line by line...
            // but this is a good opportunity to do this right when the XML is simple...
            // future situations will be more difficult than just a few nodes

            XmlSerializer commentSerializer = new XmlSerializer( typeof( CommentInfoSet ) );
            using (StringWriter sw = new StringWriter())
            {
                commentSerializer.Serialize( sw, this );

                return sw.ToString();
            }
        }

    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class CommentInfo
    {

        /// <remarks/>
        public string CommentCode;

        /// <remarks/>
        public string CommentText;

        /// <remarks/>
        public string Date;

        /// <remarks/>
        public string Commenter;

        /// <summary>
        /// Custom Method -- must be reapplied if this class is autogenerated.
        /// </summary>
        /// <returns></returns>
        public string ToXml()
        {

            // for this object, it might have been less work to just create the XML string from literals
            // line by line...
            // but this is a good opportunity to do this right when the XML is simple...
            // future situations will be more difficult than just a few nodes

            XmlSerializer commentSerializer = new XmlSerializer( typeof( CommentInfo ) );
            using (StringWriter sw = new StringWriter())
            {
                commentSerializer.Serialize( sw, this );

                return sw.ToString();
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Culture.cs ===
using System;
using System.Collections;
using System.Globalization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.sql.webstore;
using xonline.common.utilities;


namespace xonline.common.billing
{
    public class CultureData
    {
        public int CultureID;
        public int LanguageID;
        public int LiveLanguageID;
        public byte CountryID;
        public string FriendlyName;
        public string CultureCode;
    }

    public class Culture
    {
        private static Hashtable m_cultures;
        public static Hashtable Cultures
        {
            get
            {
                if (m_cultures == null)
                    LoadData();

                return m_cultures;
            }
        }

        private static Hashtable m_culturesAll;
        public static Hashtable CulturesAll
        {
            get
            {
                if (m_culturesAll == null)
                    LoadAllCultures();

                return m_culturesAll;
            }
        }

        private static Hashtable m_regionCultures;
        public static Hashtable RegionCultures
        {
            get
            {
                if (m_regionCultures == null)
                    LoadData();

                return m_regionCultures;
            }
        }

        static Culture()
        {
            m_cultures = null;
            m_regionCultures = null;
            m_culturesAll = null;
        }

        // this is a static utility class
        private Culture()
        {
        }

        public static bool VerifyCulture(int culture)
        {
            return Cultures.ContainsKey(culture);
        }

        public static byte GetRegion(int culture)
        {
            CultureData cultureData = (CultureData) Cultures[culture];
            return cultureData.CountryID;
        }

        public static string CultureToString(int culture)
        {
            object o = Cultures[culture];

            if (o == null)
                throw new CultureException(culture);

            return ((CultureData) o).FriendlyName;
        }

        public static string CultureToCode(int culture)
        {
            object o = Cultures[culture];

            if (o == null)
                throw new CultureException(culture);

            return ((CultureData) o).CultureCode;
        }

        public static ArrayList GetRegionCultures(byte countryID)
        {
            return (ArrayList) RegionCultures[countryID];
        }

        // This function can ONLY look at LIVE cultures in which Offers are valid
        public static int GetCultureFromLanguageCountry(ushort languageId, byte countryID)
        {
            ArrayList regionCultures = GetRegionCultures(countryID);
            int iDefaultCultureId = Int32.MaxValue;
            bool bMatch = false;
            string szCultureCode = "";

            if (regionCultures == null)
                throw new CountryException(countryID);

            foreach (CultureData c in regionCultures)
            {
                if ((ushort)(c.LanguageID) == languageId)
                {
                    return c.CultureID;
                }
                else if (c.CultureID < iDefaultCultureId)
                {
                    iDefaultCultureId = c.CultureID;
                    szCultureCode = c.CultureCode;
                }
            }

            if (iDefaultCultureId == Int32.MaxValue)
                throw new CultureException("No culture for language id " + languageId + " in country " + countryID);

            if (!bMatch)
            {
                string szCountry = szCultureCode.Substring(3, 2).ToUpper();
                szCultureCode = Locale.DefaultByCountry(szCountry).ToLower();

                Hashtable cultures = Culture.Cultures;
                foreach (CultureData c in cultures.Values)
                {
                    if (c.CultureCode.ToLower().Equals(szCultureCode))
                    {
                        return c.CultureID;
                    }
                }
            }

            return iDefaultCultureId;
        }

        // This function uses the LiveLanguage + Country which always give a Culture
        public static int GetCultureFromLiveLanguageCountry(ushort liveLanguageId, byte countryID)
        {
            ArrayList regionCultures = GetRegionCultures(countryID);
            int cultureId = Int32.MaxValue;

            if (regionCultures == null)
                throw new CountryException(countryID);

            foreach (CultureData c in regionCultures)
            {
                if ((ushort)(c.LiveLanguageID) == liveLanguageId)
                {
                    cultureId = c.CultureID;
                    break; // stop on exact match
                }
                else if (c.CountryID == countryID)
                {
                    // a valid LiveLanguage+Country pair always map to a valid Culture,
                    // but in case mismatched values are passed in, we fall back to a default
                    cultureId = c.CultureID;
                }
            }

            return cultureId;
        }

        public static int GetCultureFromLanguage(ushort languageId)
        {
            return GetCultureFromLanguage(languageId, true);
        }

        // This function can look only at LIVE cultures, as of 2/8/07
        public static int GetCultureFromLanguage(ushort languageId, bool okToThrow)
        {
            int iDefaultCultureId = Int32.MaxValue;
            String szCultureCode = Locale.DefaultByLanguage(languageId).ToLower();

            Hashtable cultures = Culture.Cultures;

            foreach (CultureData c in cultures.Values)
            {
                if (c.CultureCode.ToLower().Equals(szCultureCode))
                {
                    // return an exact match
                    return c.CultureID;
                }
                else if (c.LanguageID == languageId && iDefaultCultureId == Int32.MaxValue)
                {
                    // get the first culture we come across in case we don't find an exact match
                    iDefaultCultureId = c.CultureID;
                }
            }

            if (okToThrow && iDefaultCultureId == Int32.MaxValue)
                throw new CultureException("No culture for language id " + languageId);

            return iDefaultCultureId;
        }

        public static string GetCurrencySymbol(string countryCode)
        {
            // prior to .NET 4, RegionInfo.ISOCurrencySymbol is incorrect for Russia
            string ruCountryCode = CountryDictionary.CountryCode((byte)xonline.common.service.XOn.XONLINE_COUNTRY_RUSSIAN_FEDERATION);
            if ( countryCode.Equals(ruCountryCode, StringComparison.InvariantCultureIgnoreCase) )
            {
                return "RUB";
            }

            RegionInfo ri = new RegionInfo(countryCode);
            return ri.ISOCurrencySymbol;
        }

        public static int GetLanguageFromCultureCode(string cultureCode)
        {

            Hashtable cultures = Culture.Cultures;

            foreach (CultureData c in cultures.Values)
            {
                if (c.CultureCode.Equals(cultureCode))
                {
                    // return an exact match
                    return c.LanguageID;
                }
            }

            throw new CultureException("No culture for Culture Code " + cultureCode);
        }

        protected static void LoadData()
        {
            LoadCultures();
        }

        protected static void LoadCultures()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_xbos_load_cultures";

                // restrict the cultures loaded to those supported by xbox live
                ws.AddParameter("@f_xbox_live_cultures", 1);

                WstDataReader r = ws.Execute();

                Hashtable cultures = new Hashtable();
                Hashtable regionCultures = new Hashtable();

                while (r.Read())
                {
                    CultureData cultureData = new CultureData();

                    cultureData.CultureID = r.GetInt32(0);
                    cultureData.CountryID = (byte) r.GetByte(1);
                    cultureData.FriendlyName= r.GetString(2);
                    cultureData.CultureCode= r.GetString(3);
                    cultureData.LanguageID = r.GetInt32(4);
                    cultureData.LiveLanguageID = r.GetInt32(5);

                    object o = regionCultures[cultureData.CountryID];
                    if (o == null)
                    {
                        ArrayList oneRegionCultures = new ArrayList();
                        oneRegionCultures.Add(cultureData);
                        regionCultures[cultureData.CountryID] = oneRegionCultures;
                    }
                    else
                    {
                        ArrayList oneRegionCultures = (ArrayList) o;
                        oneRegionCultures.Add(cultureData);
                    }

                    cultures.Add(cultureData.CultureID, cultureData);
                }

                m_cultures = cultures;
                m_regionCultures = regionCultures;
            }
        }

        protected static void LoadAllCultures()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_xbos_load_cultures";

                // load ALL the cultures that we have
                ws.AddParameter("@f_xbox_live_cultures", -1);

                WstDataReader r = ws.Execute();

                Hashtable cultures = new Hashtable();
                Hashtable regionCultures = new Hashtable();

                while (r.Read())
                {
                    CultureData cultureData = new CultureData();

                    cultureData.CultureID = r.GetInt32(0);
                    cultureData.CountryID = (byte) r.GetByte(1);
                    cultureData.FriendlyName= r.GetString(2);
                    cultureData.CultureCode= r.GetString(3);
                    cultureData.LanguageID = r.GetInt32(4);
                    cultureData.LiveLanguageID = r.GetInt32(5);

                    cultures.Add(cultureData.CultureID, cultureData);
                }

                m_culturesAll = cultures;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ContentLicense.cs ===
//
// This file contains classes to verify, update and sign the content license
// header of content packages.
//
// The license is a fixed size blob that's part of the content package header:
//
//   -------------------------------------
//   | License  |  Meta-Data  |  Content |
//   -------------------------------------
//
// We're only concerned with the format of the License part, which is defined
// by the class 'ContentLicenseHeader' in this same file.
//
// The License, among other things, include a table of licensees, a content-id
// and a signature. The content-id is also the sha1 of the entire meta-data
// section. Since the Meta-data contains the sha1 of the Content section, it's
// safe to say that the content-id uniquely identifies the package with very
// (neglegible) chances of collision.
//
// The table of licensees is a table with 16 licensee descriptors. Each
// licensee descriptor contains the licensee-id, the license-bits and the
// license flags. The licensee-id can be an user-id or a console-id (not machine
// id) or 0xFFFFFFFFFFFFFFFF which means that the license is unrestricted. The
// license-bits are the OR'd bits of all offers of that content package acquired
// by the licensee.
//
// The signature field of the license is the RSA (PKCS1-V1.5) signature of the
// entire license section minus the signature field itself, obviously. As of
// now, three authorities can sign the license: the console, PIRS and Live. We
// (live) don't care about console signature and we don't trust them. We should
// trust PIRS signatures but we don't currently support it.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.utilities;
using xonline.common.xcrypto;



namespace xonline.common.billing
{

    // This is the format of the content license header. All integer fields
    // are big-endian
    public class ContentLicense : WireData
    {
        public const int    LiveSignatureLen         = 256;
        public const int    ReservedLen              = 296;
        public const int    LicenseesLen             = 16;
        public const UInt64 UnrestrictedLicensee     = 0xFFFFFFFFFFFFFFFF;
        public const UInt32 LicenseFlagRequireOnline = 0x1;
        public const UInt32 LicenseTypeLive          = 0x4c495645;

        public ContentLicenseSignature signature;
        public ContentLicenseBody      body;
    }

    public class ContentLicenseSignature : WireData
    {
        public UInt32 signatureType;

        [WireInfo(ArraySize=ContentLicense.LiveSignatureLen)]
        public byte[] signature;

        [WireInfo(ArraySize=ContentLicense.ReservedLen)]
        public byte[] reserved;
    }

    public class ContentLicenseBody : WireData
    {
        [WireInfo(ArraySize=ContentLicense.LicenseesLen)]
        public ContentLicensee[] licensees;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;

        public UInt32 SizeOfHeaders;
    }

    public class ContentLicensee : WireData
    {
        public UInt64 licenseeId;
        public UInt32 licenseBits;
        public UInt32 licenseFlags;
    }

    // ContentLicense
    // Handles the verification and the updating of the content license header
    // of content packages
    public class ContentLicenseUtil
    {
        private static volatile ContentLicenseUtil _global = null;
        public static ContentLicenseUtil Global
        {
            get
            {
                if(_global == null)
                {
                    lock(typeof(ContentLicenseUtil))
                    {
                        if(_global == null)
                        {
                            _global = new ContentLicenseUtil();
                        }
                    }
                }

                return _global;
            }
        }

        // XeDrmRefreshContentLicense
        // This will process the Refresh-License request
        public XeContentRefreshLicenseResponse XeContentRefreshLicense(
            XeContentRefreshLicenseRequest request,
            out string[] logLines
        )
        {
            MemoryStream ms;
            byte[] licenseBody = null;

            // Parse license from the request
            ContentLicense license = new ContentLicense();
            license.ReadBytes(request.license);

            // Verify signature
            UInt32 licenseType = RevertByteOrder(license.signature.signatureType);
            if(licenseType == ContentLicense.LicenseTypeLive)
            {
                ms = new MemoryStream((int)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN);
                license.body.WriteStream(ms);
                licenseBody = ms.ToArray();

                if (!CryptoKeyProxy.VerifySignature(CONTAINER_CLASS,
                                                    (new SHA1Managed()).ComputeHash(licenseBody),
                                                    license.signature.signature))
                {
                    // Signature doesn't check. Reset all license information.
                    // Bug 47059 - Don't log an event. Turns out that the content
                    // packaging tool is signing all packages using the test DRM key.
                    // Therefore all downloads in prod result in this event being fired.

                    license.body.licensees = CreateEmptyLicenseeArray();
                }
            }
            else
            {
                // We don't honor any other type of signatures for now. Reset
                // all license information.
                license.body.licensees = CreateEmptyLicenseeArray();
            }

            // Convert licensee table to use the native byte order
            RevertByteOrder(license.body.licensees);

            // Retrieve licenses from the database
            License[] licenses = GetContentLicensesFromDatabase(
                request.userId,
                license.body.ContentId);

            // Resolve the requestor's console id using his machine id
            ulong consoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(request.machineId, SGInfo.Current.GetPlatformType());

            // Update the licensee array by processing the licenses
            ProcessLicenses(request.userId,
                            request.machineId,
                            consoleId,
                            license.body.licensees,
                            licenses);

            // Restore the original byte-order of the licensee table
            RevertByteOrder(license.body.licensees);

            // Update the signature
            using (ms = new MemoryStream((int)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN))
            {
                license.body.WriteStream(ms);
                licenseBody = ms.ToArray();
            }
            
            license.signature.signatureType = RevertByteOrder(ContentLicense.LicenseTypeLive);
            license.signature.signature = new byte[ContentLicense.LiveSignatureLen];
            UInt32 sigLen = 0;
            CryptoKeyProxy.Sign(CONTAINER_CLASS,
                                (new SHA1Managed()).ComputeHash(licenseBody),
                                license.signature.signature,
                                out sigLen);

            // Prepare response
            XeContentRefreshLicenseResponse response = new XeContentRefreshLicenseResponse();
            using (ms = new MemoryStream((int)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN))
            {
                license.WriteStream(ms);
                response.license = ms.ToArray();
            }

            logLines = Array.ConvertAll<string, string>(GetOfferIdsToReport(license.body.ContentId), delegate(string offerId)
                { return String.Join("|", new String[] {"CRL_OFFERID", offerId, request.machineId.ToString()}); } );

            return response;
        }

        // This function gives the intersection of the following two sets:
        //   --The offer ids associated with the contentId (we hit uodb to get this)
        //   --The offer ids we have been told to report on (we hit npdb to get this)
        // Returns an empty string array for an empty intersection (not null)
        private string[] GetOfferIdsToReport(byte[] contentId)
        {
            // Get the offer ids to report on.
            string[] offerIdsToReportOn = Config.GetMultiSetting(MultiSetting.xbos_ContentOfferIdsForReporting);
            if (offerIdsToReportOn.Length >= 0)
            {
                // Get the offer ids associated with the contentId.
                string[] offerIdsForContentId = GetOfferIdsForContentId(contentId);
                if (offerIdsForContentId.Length >= 0)

                    // Take the intersection of the two
                    return Array.FindAll(offerIdsToReportOn, delegate(string offerIdToReportOn)
                        { return Array.Exists(offerIdsForContentId, delegate(string offerIdForContent)
                            { return offerIdForContent.Equals(offerIdToReportOn); } ) ;
                        }
                    );
            }
            return new string[0];
        }

        private string[] GetOfferIdsForContentId(byte[] contentId)
        {
            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READTHENWRITE_COMMANDTYPE))
            {
                ws.SetHashVal(0);
                ws.StoredProc = "dbo.p_xbos_get_offer_ids_for_content_id";
                ws.AddParameter("@b_content_id", contentId);

                using (WstDataReader r = ws.Execute())
                {
                    List<string> offerIds = new List<string>();
                    while(r.Read())
                    {
                       offerIds.Add(String.Format("0x{0:X16}", r.GetInt64(0)));
                    }
                    return offerIds.ToArray();
                }
            }
        }

        public static UInt32 RevertByteOrder(UInt32 x)
        {
            return
                 (((x)&0x000000FF)<<24) |
                 (((x)&0x0000FF00)<<8)  |
                 (((x)&0x00FF0000)>>8)  |
                 (((x)&0xFF000000)>>24);
        }

        public static UInt64 RevertByteOrder(UInt64 x)
        {
            return
                ((UInt64)RevertByteOrder((UInt32)(x >> 32))) |
                (((UInt64)RevertByteOrder((UInt32)(x & 0xFFFFFFFF))) << 32);
        }

        public static void RevertByteOrder(ContentLicensee[] licensees)
        {
            for(int i=0; i < licensees.Length; i++)
            {
                licensees[i].licenseeId   = RevertByteOrder(licensees[i].licenseeId);
                licensees[i].licenseBits  = RevertByteOrder(licensees[i].licenseBits);
                licensees[i].licenseFlags = RevertByteOrder(licensees[i].licenseFlags);
            }
        }

        public static ContentLicensee[] CreateEmptyLicenseeArray()
        {
            ContentLicensee[] licensees = new ContentLicensee[ContentLicense.LicenseesLen];

            for(int i=0; i < licensees.Length; i++)
            {
                licensees[i] = new ContentLicensee();
                licensees[i].licenseeId   = 0;
                licensees[i].licenseBits  = 0;
                licensees[i].licenseFlags = 0;
            }

            return licensees;
        }

        // UpdateLicensee
        // This will insert/update one license descriptor from a ContentLicensee
        // table. The following scheme will be used:
        //
        // * If the entry is already in the table, it will be updated and the licenseBits
        // will be OR'd with the existing entry.
        // * If the entry is not in the table and the table is not full, the
        // entry will inserted at the first available slot.
        // * If the table is full, the first entry will be removed and the new
        // entry will be added to the end of the table
        //
        protected void UpdateLicensee(
            ContentLicensee[] licensees,
            UInt64 licenseeId,
            UInt32 licenseBits,
            UInt32 licenseFlags
        )
        {
            Assert.AreEqual(licensees.Length, ContentLicense.LicenseesLen);

            for(int i=0; i < licensees.Length; i++)
            {
                if(licensees[i].licenseeId == licenseeId)
                {
                    // Update
                    licensees[i].licenseeId    = licenseeId;
                    licensees[i].licenseBits  |= licenseBits;
                    licensees[i].licenseFlags  = licenseFlags;
                    return;
                }
                else if(licensees[i].licenseeId == 0)
                {
                    // Insert
                    licensees[i].licenseeId   = licenseeId;
                    licensees[i].licenseBits  = licenseBits;
                    licensees[i].licenseFlags = licenseFlags;
                    return;
                }
            }

            // The list is full. Remove the first entry from the list and
            // add the new licensee descriptor at end.
            for(int i=0; i < licensees.Length-1; i++)
                licensees[i] = licensees[i+1];

            int n = licensees.Length-1;
            licensees[n] = new ContentLicensee();
            licensees[n].licenseeId   = licenseeId;
            licensees[n].licenseBits  = licenseBits;
            licensees[n].licenseFlags = licenseFlags;
        }

        // RemoveLicensee
        // This will remove a licensee descriptor from a ContentLicensee table.
        // If the licensee is not found, the table will not be changed.
        //
        protected void RemoveLicensee(
            ContentLicensee[] licensees,
            UInt64 licenseeId
        )
        {
            Assert.AreEqual(licensees.Length, ContentLicense.LicenseesLen);

            for(int i=0; i < licensees.Length && licensees[i].licenseeId != 0; i++)
            {
                if(licensees[i].licenseeId == licenseeId)
                {
                    for(; i < licensees.Length-1; i++)
                        licensees[i] = licensees[i+1];

                    // Fill in the hole
                    licensees[i] = new ContentLicensee();
                    licensees[i].licenseeId   = 0;
                    licensees[i].licenseBits  = 0;
                    licensees[i].licenseFlags = 0;

                    break;
                }
            }
        }

        // ProcessLicenses
        //
        // This uses an array of Licenses to update the licensee array. This looks a bit
        // complicated because the way we store the stuff in the database is not the same
        // the way we represent the stuff in the content package. There following scheme
        // will be used:
        //
        // * Two DWORDs will be calculated. One containing the ORed license mask bits of
        // all restricted offers (restrictedLicenseBits) and one containing the ORed
        // license mask bits of all unrestricted offers (unrestrictedLicenseBits).
        //
        // * If there are any *user restricted* licenses, use "restrictedLicenseBits" to
        // update the license mask for that user in the licensee table. Otherwise, remove
        // any references to that user from the licensee table.
        //
        // * If there are any *machine restricted* licenses for the console id that is
        // making the request, use "restrictedLicenseBits" to update the license mask for
        // that console in the licensee table. The license-mask will be or'd with the
        // current entry in the table if one exists. Yes, the machine licensee is treated
        // differently because Uodb is partitioned by user and with the current design it
        // would require a partition scan to find all the content licenses for a specific
        // console.
        //
        // * If there are any *unrestricted* licenses, update the "unrestricted" entry on
        // the licensee table using "unrestrictedLicenseBits". Otherwiser, remove any
        // unrestricted entries in the licensee table.
        //
        // Parameters:
        //
        // * userId - requestor's userId
        // * machineId - requestor's machineId
        // * consoleId - the consoleId associated to the machineId (the license uses
        // consoleIds, but machine-ids are used in the database)
        // * licensees - array of licensees that will be updated
        // * licenses  - array of licenses that are going to be processed in order to
        // update licensees
        //
        protected void ProcessLicenses(
            UInt64 userId,
            UInt64 machineId,
            UInt64 consoleId,
            ContentLicensee[] licensees,
            License[] licenses
        )
        {
            bool fUnrestrictedLicenses = false;
            bool fPerMachineRights     = false;
            bool fPerUserRights        = false;
            UInt32 unrestrictedLicenseBits = 0;
            UInt32 restrictedLicenseBits   = 0;

            //
            // Remove existing entries for the unrestricted licensee and the userId. These
            // will be completely replaced with super-fresh data from the database. The
            // console licensee is different - we'll update an existing entry.
            //

            RemoveLicensee(licensees, ContentLicense.UnrestrictedLicensee);
            RemoveLicensee(licensees, userId);

            for(int i=0; i < licenses.Length; i++)
            {
                if((licenses[i].policyFlags & Offer.UNRESTRICTED) != 0)
                {
                    fUnrestrictedLicenses = true;
                    unrestrictedLicenseBits |= licenses[i].licenseBits;
                }
                else
                {
                    restrictedLicenseBits |= licenses[i].licenseBits;

                    if(licenses[i].machineId == machineId
                       && (licenses[i].policyFlags & Offer.PER_MACHINE_RIGHTS) != 0 )
                    {
                        fPerMachineRights = true;
                    }

                    if ((licenses[i].policyFlags & Offer.PER_USER_RIGHTS) != 0)
                    {
                        fPerUserRights = true;
                    }
                }
            }

            // Update unrestricted Licensee
            if(fUnrestrictedLicenses)
            {
                UpdateLicensee(licensees, ContentLicense.UnrestrictedLicensee, unrestrictedLicenseBits, 0);
            }

            // Update user licensee
            if(fPerUserRights)
            {
                UpdateLicensee(licensees, userId, restrictedLicenseBits, ContentLicense.LicenseFlagRequireOnline);
            }

            // Update console licensee
            if(fPerMachineRights)
            {
                UpdateLicensee(licensees, consoleId, restrictedLicenseBits, 0);
            }
        }

        // This is the format of a content license as modeled in the database
        protected class License
        {
            public UInt64 machineId;
            public UInt32 licenseBits;
            public UInt32 policyFlags;
        }

        // GetContentLicensesFromDatabase
        // Given an user-id and a console-id, this will return an array of
        // content-licenses as they are stored in the db
        protected License[] GetContentLicensesFromDatabase(
            UInt64 userId,
            byte[] contentId
        )
        {

            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userId);

                ws.StoredProc = "dbo.p_xbos_get_content_license";
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_id",   userId);
                ws.AddParameter("@b_content_id", contentId);

                License[] licenses;
                using (WstDataReader r = ws.Execute())
                {
                    ArrayList licenseList = new ArrayList(32);

                    while(r.Read())
                    {
                        License dbLicense = new License();
                        dbLicense.machineId   = (UInt64) r.GetInt64(0);
                        dbLicense.licenseBits = (UInt32) r.GetInt32(1);
                        dbLicense.policyFlags = (UInt32) r.GetInt32(2);

                        licenseList.Add(dbLicense);
                    }

                    licenses = (License[]) licenseList.ToArray(typeof(License));
                }

                HResult hr = (uint) ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    if(hr == HResult.XONLINE_E_CONTENT_NOT_FOUND)
                    {
                        string msg = String.Format(
                            "{0} failed with hr = {1}. The content-id was not found "+
                            "in the database. This might be a hack attempt. ",
                            ws.GetCallSignature(), hr.ToString());

                        throw new XRLException(hr, XEvent.Id.HACK_CONTENT_NOT_FOUND, msg);
                    }
                    else
                    {
                        string msg = String.Format(
                            "{0} failed with hr = {1}", ws.GetCallSignature(),
                            hr.ToString());

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_94, msg);
                    }
                }

                return licenses;
            }
        }

        private const EContainerClasses CONTAINER_CLASS = EContainerClasses.Drm;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CreditCardInfo.cs ===
using System;
using System.Diagnostics;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.billing
{
    public enum CardTypeEnum
    {
        Visa            = 0,
        MasterCard      = 1,
        AmEx            = 2,
        Discover        = 3,
        JCB             = 4,
        Diners          = 5,
        KLCC            = 6
    }

    public class CreditCardInfo
    {
        private static string[] CardTypes = new string[] {
            "VISA",
            "MC",
            "AMEX",
            "DISCOVER",
            "JCB",
            "DINERS",
            "KLCC",
        };

        // The following fields must be filled in to Create an account.
        public string       AccountHolderName;
        public string       AccountNumber;
        public string       AccountNumberLastFour;
        public string       EncryptedAccountNumber;
        public string       CvmCode;
        public string       EncryptedCvmCode;
        public DateTime     ExpirationDate = new DateTime(2001,11,15);
        public CardTypeEnum CardType = CardTypeEnum.Visa;
        public Address      BillingAddress;
        public Phone        BillingPhone;

        public void EncryptAccountNumber()
        {
            if (AccountNumber != null && AccountNumber != "")
            {
                BillingProvider bdk = new BillingProvider();
                EncryptedAccountNumber = bdk.EncryptNumber(AccountNumber);
                AccountNumber = null;
            }
        }

        public void EncryptCvmCode()
        {
            if (CvmCode != null && CvmCode != "")
            {
                BillingProvider bdk = new BillingProvider();
                EncryptedCvmCode = bdk.EncryptNumber(CvmCode);
                CvmCode = null;
            }
        }

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "ExpirationDate":
                        {
                            string dateStr = xmlReader.ReadElementString();
                            ExpirationDate = new DateTime(Convert.ToInt32(dateStr.Substring(2)), Convert.ToInt32(dateStr.Substring(0, 2)), 1);
                        }
                        break;

                    case "CardType":
                        CardType = CardNameToType(xmlReader.ReadElementString());
                        if( CardType < 0 ) CardType = CardTypeEnum.Visa;
                        break;

                    case "AccountHolderName":
                        AccountHolderName = xmlReader.ReadElementString();
                        break;

                    case "AccountNumber":
                        //
                        // In cases where we're reading in the actual AccountNumber, we must be pulling the
                        // XML set from the billing queue-- SCS will never return the real AccountNumber to us.
                        // As a result, we ALSO copy the last four digits into AccountNumberLastFour so that the
                        // Account instance can be used by top-level functions as if it had actually come from
                        // SCS.
                        //
                        AccountNumber = xmlReader.ReadElementString();
                        if ( AccountNumber != null && AccountNumber.Length >= 4 )
                        {
                            AccountNumberLastFour = AccountNumber.Substring(AccountNumber.Length-4, 4);
                        }
                        break;

                    case "AccountNumberLastFour":
                        if ( AccountNumberLastFour != null )
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_CODE_10, "ASSERT: AccountNumberLastFour should be null when being read! "
                                + " Instead we're copying over the current value of " + AccountNumberLastFour + " with " + xmlReader.ReadElementString());
                        }

                        AccountNumberLastFour = xmlReader.ReadElementString();
                        break;

                    case "EncryptedAccountNumber":
                        EncryptedAccountNumber = xmlReader.ReadElementString();
                        break;

                    case "EncryptedCVMCode":
                        EncryptedCvmCode = xmlReader.ReadElementString();
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "CreditCard: Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                        break;
                }
            }
        }


        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {
            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "CreditCardInfo" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<AccountHolderName>");
            xmlBldr.Append(XmlCleanser.Cleanup(AccountHolderName));
            xmlBldr.Append("</AccountHolderName>");

            if ( AccountNumber != null && AccountNumber != "" )
            {
                xmlBldr.Append("<AccountNumber>");
                xmlBldr.Append(XmlCleanser.Cleanup(AccountNumber));
                xmlBldr.Append("</AccountNumber>");
            }

            if ( EncryptedAccountNumber != null && EncryptedAccountNumber != "" )
            {
                xmlBldr.Append("<EncryptedAccountNumber>");
                xmlBldr.Append(XmlCleanser.Cleanup(EncryptedAccountNumber));
                xmlBldr.Append("</EncryptedAccountNumber>");
            }

            if ( CvmCode != null && CvmCode != "" )
            {
                EncryptCvmCode();
            }

            if ( EncryptedCvmCode != null && EncryptedCvmCode != "" )
            {
                xmlBldr.Append("<EncryptedCVMCode>");
                xmlBldr.Append(XmlCleanser.Cleanup(EncryptedCvmCode));
                xmlBldr.Append("</EncryptedCVMCode>");
            }

            xmlBldr.Append("<CardType>");
            xmlBldr.Append(XmlCleanser.Cleanup(CardTypes[(int)CardType]));
            xmlBldr.Append("</CardType>");

            xmlBldr.Append("<ExpirationDate>");
            xmlBldr.Append(XmlCleanser.Cleanup(ExpirationDate.ToString("MMyyyy")));
            xmlBldr.Append("</ExpirationDate>");

            xmlBldr.Append("</CreditCardInfo>");
        }


        // Returns a new instance of CreditCardInfoData populated with data
        // from the current CreditCardInfo instance.
        public CreditCardInfoData ToWireData()
        {
            CreditCardInfoData cardInfo = new CreditCardInfoData();

            cardInfo.cardType = (byte) CardType;
            cardInfo.accountHolderName = AccountHolderName;
            if ( AccountNumber != null && AccountNumber != "" )
            {
                cardInfo.accountNumber = AccountNumber;
            }
            else if ( AccountNumberLastFour != null && AccountNumberLastFour != "" )
            {
                cardInfo.accountNumber = AccountNumberLastFour;
            }
            if ( CvmCode != null && CvmCode != "" )
            {
                cardInfo.ccvNumber = CvmCode;
            }
            cardInfo.expirationDate = ExpirationDate;

            return cardInfo;
        }

        // Populates CreditCard property data with data from the given
        // CreditCardInfoData instance.
        public void FromWireData(CreditCardInfoData cardInfo)
        {
            CardType = (CardTypeEnum) cardInfo.cardType;
            AccountHolderName = cardInfo.accountHolderName;
            AccountNumber = cardInfo.accountNumber;
            CvmCode = cardInfo.ccvNumber;
            ExpirationDate = cardInfo.expirationDate;
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            if (AccountHolderName == "")                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_HOLDER_NAME_NOT_FOUND_ERROR, "Missing CreditCardInfo.AccountHolderName");
            if (AccountNumber == "")                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_NUMBER_NOT_FOUND_ERROR, "Missing CreditCardInfo.AccountNumber");
            if (ExpirationDate == DateTime.MinValue)        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_EXPIRATION_DATE_NOT_FOUND_ERROR, "Missing CreditCardInfo.ExpirationDate");
            if (isUpdate == false && (int)CardType < 0 || (int)CardType >= CardTypes.Length) throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_BAD_CREDIT_CARD_TYPE_ERROR, "Bad Credit Card type (PaymentInfo.CreditCard.CardType=" + CardType + ")");
            if (isUpdate == false && AccountNumber == null) throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_NUMBER_NOT_FOUND_ERROR, "Missing PaymentInfo.CreditCard.AccountNumber");
        }

        public override string ToString()
        {
            string a;

            a = "AccountHolderName: " + AccountHolderName +
                "ExpirationDate: " + ExpirationDate;
            return a;
        }

        public static CardTypeEnum CardNameToType(string cardName)
        {
            return (CardTypeEnum)Array.IndexOf(CardTypes, cardName);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CatalogUtil.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.offer;
using xonline.common.sql.sqlclient;
using xonline.common.utilities;


// ONE DAY, LARGE sections of this file should by auto-generated from a) querying CatalogDB or
// b) accessing the xml files which populate CatalogDB.  For now they are hand-coded and are
// specifically those constants in CatalogDB "domain data" tables which are needed for Live
// code to do purchase, etc.

// THIS FILE SHOULD be kept up to date with changes to CatalogDB

namespace xonline.common.billing
{
    public enum GeoCheckPolicy : uint
    {
        DoNotGeoFence       = 0,
        GeoFence            = 1
    }

    // Enum matches ClientType table in fecatalogdb
    public enum CatalogClientTypeEnum : uint
    {
        Xbox360             = 1,
        Xbox1               = 2,
        ZuneDeviceV1        = 3,
        ZuneDeviceV2        = 4,
        MediaCenterDevice   = 5,
        // Note: matching table definition, where there is no client type 6
        WindowsPcClient     = 7,
        ZuneDeviceV3        = 8,
        ZuneMobileDevice    = 9,
        WinMo7              = 10,
        Mobile              = 11
    }

    public static class VirtualInterfaceName
    {
        public const string UnknownCatalog = "unknowncatalog";
        public const string XboxCatalog = "fecatalogdbxbox";
        public const string ZuneCatalog = "fecatalogdbzune";
        public const string ZestCatalog = "fecatalogdbzest";
    }

    public enum LicenseClassEnum : uint
    {
        DTO                         = 1,
        PPV                         = 2,
        XboxUnrestricted            = 3,
        XboxRestrictedUserMachine   = 4
    }

    public enum MediaClassEnum
    {
        Unclassified        = 0,
        Music               = 1,
        Video               = 2,
        Game                = 3,
        PointsBundle        = 4,
        Subscription        = 5,
        App                 = 6
    }
    public class MediaTypeInfo
    {
        public const int Game360             = 1;
        public const int Movie               = 2;
        public const int TVShow              = 3;
        public const int MusicVideo          = 4;
        public const int GameTrial           = 5;
        public const int ViralVideo          = 7;
        public const int TVEpisode           = 8;
        public const int TVSeason            = 9;
        public const int TVSeries            = 10;
        public const int VideoPreview        = 11;
        public const int Poster              = 12;
        public const int Podcast             = 13;
        public const int Image               = 14;
        public const int BoxArt              = 15;
        public const int ArtistPicture       = 16;
        public const int ScreenShot          = 17;
        public const int InGameContent       = 18;
        public const int GameDemo            = 19;
        public const int Theme360            = 20;
        public const int Xbox1Game           = 21;
        public const int GamerTile           = 22;
        public const int ArcadeGame          = 23;
        public const int InGameConsumable    = 24;
        public const int Track               = 25;
        public const int Album               = 26;
        public const int AlbumDisc           = 27;
        public const int AlbumArt            = 28;
        public const int Music               = 29;
        public const int GameVideo           = 30;
        public const int BackgroundArt       = 31;
        public const int Playlist            = 32;
        public const int TVTrailer           = 33;
        public const int GameTrailer         = 34;
        public const int VideoShort          = 35;
        public const int Bundle              = 36;
        public const int XNACommunityGame    = 37;
        public const int Promotional         = 39;
        public const int MovieTrailer        = 40;
        public const int SlideshowPreview    = 41;
        public const int ServerBackedGames   = 45;
        public const int Marketplace         = 46;
        public const int AvatarItem          = 47;
        public const int GamerTagChange      = 48;
        public const int PointsBundle        = 49;
        public const int GameSubscription    = 50;
        public const int LiveSubscription    = 51;
        public const int AddonSubscription   = 52;
        public const int MobileGame          = 58;
        public const int MobilePDLC          = 59;
        public const int MobileConsumable    = 60;
        public const int App                 = 61;

        public int             Id;
        public string          Name;
        public MediaClassEnum  Class;
    }

    public class OfferRelationShipType
    {
        public const int ConvertPlusProRate=1;
        public const int ConvertPlusTimeExtend=2;
        public const int Renew=3;
        public const int DefaultRenew = 4;
        public const int Xbox1toXenonSubstitution = 5;
        public const int CountryMigration = 6;
    }

    public class PaymentType
    {
        public const int MicrosoftPoints = 1;
        public const int MicrosoftToken = 2;
        public const int CreditCard = 3;
    }

    public class DurationType
    {
        public const int Months=1;
        public const int Days=2;
        public const int NonTerminating=3;
    }

    public class OfferType
    {
        public const int Content = 1;
        public const int Subscriptions = 2;
        public const int SubscriptionTrial = 3;
        public const int SubscriptionMigration = 4;
    }

    public class AvatarBodyType
    {
        public const int Male                   = 1;
        public const int Female                 = 2;
        public const int Neutral                = 3;
    }

    public enum CatalogUserTypeEnum : uint
    {
        XboxLiveGoldUser = 2,
        XboxLiveSilverUser = 3,
        XboxLiveFamilyGoldUser = 4
    }

    // enum matches PaymentType table in fecatalogdb
    public enum CatalogPaymentTypeEnum : uint
    {
        Points              = 1,
        Token               = 2,
        CreditCard          = 3,
    }

    public enum StoreEnum : uint
    {
        Xbox        = 1,
        Zune        = 2,
        PC          = 3,
        Zest        = 4,
        Mobile      = 5
    }

    public enum VisibilityStatus : uint
    {
        Unpublished     = 1,
        Staging         = 2,
        Live            = 3,
        Withdrawn       = 4,
        Deleted         = 5
    }

    //Lightweight class to address scenarios where we need to look up the OfferInformation based on BillingOfferId.
    public class BillingOfferInfo
    {
        public Guid OfferId
        {
            get;
            set;
        }
        public Guid OfferInstanceId
        {
            get;
            set;
        }
        public Guid MediaId
        {
            get;
            set;
        }
        public int MediaTypeId
        {
            get;
            set;
        }
        public Guid? ServiceComponentId
        {
            get;
            set;
        }
        public ulong LiveOfferId
        {
            get;
            set;
        }
        public uint Duration
        {
            get;
            set;
        }
        public uint DurationType
        {
            get;
            set;
        }
        public string ReducedDescription
        {
            get;
            set;
        }
        public string ReducedTitle
        {
            get;
            set;
        }
        public string RevenueSku
        {
            get;
            set;
        }

        /// <summary>
        /// Return Basic OfferInfo given the BillingOfferId
        /// </summary>
        public static BillingOfferInfo GetInstance(Guid billingOfferId)
        {

            BillingOfferInfo billingOfferInfo = new BillingOfferInfo();
            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                HResult hr = HResult.S_OK;

                c.StoredProc = "dbo.GetOfferInfoFromBillingOfferId";

                // Params always added
                c.AddParameter(ParameterDirection.ReturnValue, "@hr", hr);
                c.AddParameter("@billingOfferId", billingOfferId);

                using (SqlDataReader reader = c.Execute())
                {

                    if (reader.Read())
                    {
                        billingOfferInfo.OfferId = reader.GetGuid(reader.GetOrdinal("offerId"));

                        billingOfferInfo.OfferInstanceId = reader.GetGuid(reader.GetOrdinal("offerInstanceId"));

                        billingOfferInfo.MediaId = reader.GetGuid(reader.GetOrdinal("mediaId"));

                        billingOfferInfo.MediaTypeId = reader.GetInt32(reader.GetOrdinal("mediaTypeId"));

                        billingOfferInfo.LiveOfferId = (ulong)reader.GetInt64(reader.GetOrdinal("liveOfferId"));

                        if (!reader.IsDBNull(reader.GetOrdinal("billingsvcComponentId")))
                        {
                            billingOfferInfo.ServiceComponentId = reader.GetGuid(reader.GetOrdinal("billingsvcComponentId"));
                        }

                        billingOfferInfo.Duration = (uint)reader.GetInt32(reader.GetOrdinal("subscriptionDuration"));

                        billingOfferInfo.DurationType = (uint)reader.GetInt32(reader.GetOrdinal("subscriptionDurationTypeId"));
                    }

                }
                hr = (uint)c.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr,
                                            XEvent.Id.CTP_NON_USER_EXCEPTION,
                                            String.Format("Error creating an Instance.Offer not found for Billing OfferId {0}", billingOfferId.ToString()));
                }
            }

            return billingOfferInfo;
        }

        /// <summary>
        /// Return Basic OfferInfo given the BillingOfferId
        /// </summary>
        public static BillingOfferInfo GetLocalizedInstance(Guid billingOfferId, string legalLocale)
        {

            BillingOfferInfo billingOfferInfo = new BillingOfferInfo();
            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                HResult hr = HResult.S_OK;

                c.StoredProc = "dbo.GetLocalizedOfferInfoFromBillingOfferId";

                // Params always added
                c.AddParameter(ParameterDirection.ReturnValue, "@hr", hr);
                c.AddParameter("@billingOfferId", billingOfferId);
                c.AddParameter("@legalLocale", legalLocale);

                using (SqlDataReader reader = c.Execute())
                {
                    if (reader.Read())
                    {
                        billingOfferInfo.OfferId = reader.GetGuid(reader.GetOrdinal("offerId"));

                        billingOfferInfo.OfferInstanceId = reader.GetGuid(reader.GetOrdinal("offerInstanceId"));

                        billingOfferInfo.MediaId = reader.GetGuid(reader.GetOrdinal("mediaId"));

                        billingOfferInfo.MediaTypeId = reader.GetInt32(reader.GetOrdinal("mediaTypeId"));

                        billingOfferInfo.LiveOfferId = (ulong)reader.GetInt64(reader.GetOrdinal("liveOfferId"));

                        if (!reader.IsDBNull(reader.GetOrdinal("billingsvcComponentId")))
                        {
                            billingOfferInfo.ServiceComponentId = reader.GetGuid(reader.GetOrdinal("billingsvcComponentId"));
                        }

                        billingOfferInfo.Duration = (uint)reader.GetInt32(reader.GetOrdinal("subscriptionDuration"));

                        billingOfferInfo.DurationType = (uint)reader.GetInt32(reader.GetOrdinal("subscriptionDurationTypeId"));

                        billingOfferInfo.ReducedDescription = reader.GetString(reader.GetOrdinal("reducedDescription")).Trim();

                        billingOfferInfo.ReducedTitle = reader.GetString(reader.GetOrdinal("reducedTitle")).Trim();

                        billingOfferInfo.RevenueSku = reader.GetString(reader.GetOrdinal("revenueSku")).Trim();
                    }
                }
                hr = (uint)c.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.CTP_NON_USER_EXCEPTION, "Error creating an Instance.Offer not found for billingOfferId: {0}, legalLocale: {1}", billingOfferId.ToString(), legalLocale);
                }
            }

            return billingOfferInfo;
        }
    }

    public class CatalogUtil
    {
        private static bool    _initialized = false;
        private static object  _lockObject = new object();
        private static bool    _controlRequestEventInitialized = false;
        private static bool    _settingsChangeEventInitialized = false;

        public static void Init()
        {
            if (_initialized) return;

            lock (_lockObject)
            {
                if (_initialized) return;

                try
                {
                    if (! _controlRequestEventInitialized)
                    {
                    // register xmgmt command hander
                        XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(CatalogUtil.OnControlRequest);
                        _controlRequestEventInitialized = true;
                    }

                    if (! _settingsChangeEventInitialized)
                    {
                        // register for setting changes
                        Config.SettingChange += new SettingChangeEventHandler(OnSettingsChanged);
                        _settingsChangeEventInitialized = true;
                    }

                    InitMediaTypeClasses();

                    LoadMediaTypesFromCatalog();

                    _initialized = true;
                }

                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.BILLING_CONFIG_7, e, "CatalogUtil: failed to initialize");
                    throw; // log the specific eventid, but let the exception bubble out to the global application_start try/catch
                }
            }
        }

        public static Guid TitleIdToMediaId(uint titleId)
        {
            //
            // The EMS mediaId is constructed from the Xbox Live titleId using the
            // following algorithm:
            //
            //        66acd000-77fe-1000-9115-D8cctttttttt
            //
            // The Title Id for Halo 3 (0x4D5307E6), for example would be converted to a UUID as:
            //
            //        66acd000-77fe-1000-9115-d8024D5307E6
            //                                 (cctttttttt)
            //
            //
            //        c = live console-type id
            //        t = live title id
            //

            return TitleIdToMediaId(titleId, ConsoleTypeEnum.Xenon);
        }

        public static Guid TitleIdToMediaId(uint titleId, ConsoleTypeEnum consoleType)
        {
            //
            // The EMS mediaId is constructed from the Xbox Live titleId using the
            // following algorithm:
            //
            //        66acd000-77fe-1000-9115-D8cctttttttt
            //
            // The Title Id for Halo 3 (0x4D5307E6), for example would be converted to a UUID as:
            //
            //        66acd000-77fe-1000-9115-d8024D5307E6
            //                                 (cctttttttt)
            //
            //
            //        c = live console-type id
            //        t = live title id
            //

            string s = String.Format("66acd000-77fe-1000-9115-D8{0:x2}{1:x8}", (int)consoleType, titleId);

            return new System.Guid(s);
        }

        public static uint MediaIdToTitleId(Guid mediaId)
        {
            //
            // The EMS mediaId is constructed from the Xbox Live titleId using the
            // following algorithm:
            //
            //        66acd000-77fe-1000-9115-D8cctttttttt
            //
            // The Title Id for Halo 3 (0x4D5307E6), for example would be converted to a UUID as:
            //
            //        66acd000-77fe-1000-9115-d8024D5307E6
            //                                 (cctttttttt)
            //
            //
            //        c = live console-type id
            //        t = live title id
            //

            string s = mediaId.ToString();
            string m = s.Substring(s.Length - 8);

            return UInt32.Parse(m, NumberStyles.HexNumber);
        }

        public static Guid OfferIdToOfferingGuid(ulong offerId)
        {
            Guid id = Guid.Empty;
            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                c.StoredProc = "dbo.GetOfferingGuidFromLegacyId";

                c.AddParameter("@liveOfferId", offerId);
                c.AddParameter(ParameterDirection.ReturnValue, "@return_value", 0);

                using (SqlDataReader r = c.Execute())
                {
                    int error = c.GetIntParameter("@return_value");

                    if (error == 0 && r.Read())
                    {
                        id = r.GetGuid(r.GetOrdinal("offerId"));
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_GET_LEGACYOFFER_ERROR,
                                                XEvent.Id.OFFER_ID_LOOKUP_FAILURE,
                                                String.Format("Error retrieving catalog offerguid for legacyofferid {0}", offerId.ToString("x")));
                    }

                }

            }

            return id;
        }

        public static ulong OfferingGuidToOfferId(Guid offerGuid)
        {
            ulong id = 0;
            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                c.StoredProc = "dbo.GetLegacyIdfromOfferingGuid";

                c.AddParameter("@offerId", offerGuid);
                c.AddParameter(ParameterDirection.ReturnValue, "@return_value", 0);

                using (SqlDataReader r = c.Execute())
                {
                    int error = c.GetIntParameter("@return_value");

                    if (error == 0 && r.Read())
                    {
                        id = (ulong)r.GetInt64(r.GetOrdinal("liveOfferId"));
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_GET_LEGACYOFFER_ERROR,
                                                XEvent.Id.OFFER_ID_LOOKUP_FAILURE,
                                                String.Format("Error retrieving catalog legacyofferid for offerguid {0}", offerGuid.ToString()));
                    }

                }



            }
            return id;
        }

        public static void OfferIdToOfferInstanceId(ulong offerId, int uodbTier, byte countryId, uint uodbPaymentType, out Guid? catalogOfferId, out Guid? catalogOfferInstanceId)
        {
            int catalogPaymentType = UodbPaymentTypetoCatalogPaymentType((int)uodbPaymentType);

            string countryCode = CountryDictionary.CountryCode(countryId);

            int emsUserTypeId = UODBTierToCatalogUserType(uodbTier);

            CatalogUtil.OfferIdToOfferInstanceId(offerId, emsUserTypeId, countryCode, catalogPaymentType, out catalogOfferId,out catalogOfferInstanceId);
        }

        public static int UODBTierToCatalogUserType(int uodbTier)
        {
             switch (uodbTier)
            {
                case (int)TierEnum.FamilyGold:
                    return (int)CatalogUserTypeEnum.XboxLiveGoldUser;

                case (int)TierEnum.Gold:
                    return (int)CatalogUserTypeEnum.XboxLiveGoldUser;

                case (int)TierEnum.Silver:
                    return (int)CatalogUserTypeEnum.XboxLiveSilverUser;

                default:
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_CATALOG_1,
                        string.Format("tier '{0}' is invalid.", uodbTier));
            }

        }

        public static void OfferIdToOfferInstanceId(ulong offerId, int emsUserTypeId, string countryCode, int emsPaymentTypeId, out Guid? catalogOfferId, out Guid? catalogOfferInstanceId)
        {
            catalogOfferId = null;

            catalogOfferInstanceId = null;


            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                c.StoredProc = "dbo.GetOfferInstanceIdFromLegacyOffer";

                c.AddParameter("@liveOfferId", offerId);

                c.AddParameter("@paymentTypeId", emsPaymentTypeId);

                c.AddParameter("@countryCode", countryCode);

                c.AddParameter("@userTypeId", emsUserTypeId);

                using (SqlDataReader r = c.Execute())
                {

                    if (r.Read())
                    {
                        if (!r.IsDBNull(r.GetOrdinal("offerInstanceId")))
                        {
                            catalogOfferInstanceId = r.GetGuid(r.GetOrdinal("offerInstanceId"));
                        }
                        if (!r.IsDBNull(r.GetOrdinal("offerId")))
                        {
                            catalogOfferId = r.GetGuid(r.GetOrdinal("offerId"));
                        }
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_GET_OFFERINSTANCE_ERROR,
                                                XEvent.Id.COMMON_CATALOG_1,
                                                String.Format("Error retrieving catalog offerInstanceId for legacyofferid {0},paymenttype {1},countrycode {2}", offerId.ToString("x"), emsPaymentTypeId.ToString(), countryCode));
                    }
                }
            }

        }

        public static Guid OfferIdToOfferInstanceId(ulong offerId, int emsUserTypeId, byte countryId, int emsPaymentTypeId)
        {
            Guid? catalogOfferId=null;

            Guid? catalogOfferInstanceId=null;

            string countryCode = CountryDictionary.CountryCode(countryId);

            CatalogUtil.OfferIdToOfferInstanceId(offerId, emsUserTypeId, countryCode, emsPaymentTypeId, out catalogOfferId, out catalogOfferInstanceId);

            return (catalogOfferInstanceId.HasValue?catalogOfferInstanceId.Value:Guid.Empty);

        }

        public static Guid ContentIdToMediaInstanceId(byte[] ContentId)
        {
            // The Media Instance Id for Halo 3 Heroic Map Pack with Offer Id (0x4D5307E60CCF0004)
            // and Content Id (0xa625e0d7ed51adda217ad5f150c843988717e9bd), for example would be converted to a UUID as:
            // a625e0d7-ed51-40ad-80da-217ad5f150c8
            //(CCCCCCCC-CCCC-  CC-  CC-CCCCCCCCCCCC)

            //
            // TBD: check length on the ContentId
            //
            byte[] map = { 3, 2, 1, 0, 5, 4, 6, 9, 10, 11, 12, 13, 14, 15 };
            int len = ContentId.Length;
            int max = (len < 14 ? len : 14);

            byte[] scratch = new byte[16];
            for (int i = 0; i < max; i++)
            {
                scratch[map[i]] = ContentId[i];
            }
            scratch[7] = 0x40;
            scratch[8] = 0x80;

            return new Guid(scratch);
        }

        public static MediaClassEnum MediaTypeIdToMediaClass(int mediaTypeId)
        {
            if ( _musicMediaTypes == null
                || _videoMediaTypes == null
                || _gameMediaTypes == null
                || _pointsBundleMediaTypes == null
                || _subscriptionMediaTypes == null
                || _appMediaTypes == null

              )
            {
                throw new Exception("MediaTypeIdToMediaClass: mediaType lists not initialized from config settings!");
            }

            if ( _musicMediaTypes.Contains(mediaTypeId) )
            {
                 return MediaClassEnum.Music;
            }
            else if ( _videoMediaTypes.Contains(mediaTypeId) )
            {
                return MediaClassEnum.Video;
            }
            else if ( _gameMediaTypes.Contains(mediaTypeId) )
            {
                return MediaClassEnum.Game;
            }
           else if (_pointsBundleMediaTypes.Contains(mediaTypeId))
            {
                return MediaClassEnum.PointsBundle;
            }
           else if (_subscriptionMediaTypes.Contains(mediaTypeId))
            {
                return MediaClassEnum.Subscription;
            }
            else if ( _appMediaTypes.Contains( mediaTypeId ) )
            {
                return MediaClassEnum.App;
            }

            return MediaClassEnum.Unclassified;
        }

        // Converts EMS PaymentType into UODB PaymentType
        public static uint CatalogPaymentTypeToUodbPaymentType(uint catalogPaymentType)
        {
            PaymentTypeEnum type;

            switch ((CatalogPaymentTypeEnum)catalogPaymentType)
            {
                case CatalogPaymentTypeEnum.CreditCard:
                    type = PaymentTypeEnum.CreditCard;
                    break;

                case CatalogPaymentTypeEnum.Token:
                    type = PaymentTypeEnum.Token;
                    break;

                case CatalogPaymentTypeEnum.Points:
                default:
                    type = PaymentTypeEnum.Points;
                    break;
            }

            return (uint)type;
        }

        public static int UodbPaymentTypetoCatalogPaymentType(int uodbPaymentType)
        {
            CatalogPaymentTypeEnum type;

            switch ((PaymentTypeEnum)uodbPaymentType)
            {
                case PaymentTypeEnum.CreditCard:
                    type = CatalogPaymentTypeEnum.CreditCard;
                    break;

                case PaymentTypeEnum.Token:
                    type = CatalogPaymentTypeEnum.Token;
                    break;

                case PaymentTypeEnum.Points:
                default:
                    type = CatalogPaymentTypeEnum.Points;
                    break;
            }

            return (int)type;
        }

        public static void LoadMediaTypesFromCatalog()
        {
            string connectionString = ConfigUtil.FECatalogDBXboxConnectionString;
            using (SqlConnection c = new SqlConnection(connectionString))
            {
                c.Open();

                Dictionary<int,MediaTypeInfo> allMediaTypes = new Dictionary<int,MediaTypeInfo>();

                using (SqlCommand cmd = c.CreateCommand())
                {
                    cmd.CommandText = "dbo.GetMediaTypes";
                    cmd.CommandType = CommandType.StoredProcedure;

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        while (r.Read())
                        {
                            MediaTypeInfo mti = new MediaTypeInfo();

                            mti.Id = r.GetInt32(0);
                            mti.Name = r.GetString(1).Trim();
                            mti.Class = MediaTypeIdToMediaClass(mti.Id);

                            allMediaTypes.Add(mti.Id, mti);
                        }
                    }
                }

                _allMediaTypes = allMediaTypes;
            }
        }

        protected static List<int> InitMediaClassFromSettingValue(string settingValue)
        {
            if ( settingValue == null )
            {
                throw new ExceptionWithEventId(XEvent.Id.CATALOG_MEDIACLASS_SETTING_MALFORMATTED, "InitMediaClassFromSettingValue: settingValue is null... this should not happen -- ensure caller is passing value obtained from Config.GetSetting.");
            }

            List<int> mediaTypes = new List<int>();
            foreach (string value in settingValue.Split(','))
            {
                try
                {
                    int mediaTypeId = Int32.Parse(value);

                    mediaTypes.Add(mediaTypeId);
                }
                catch (Exception)
                {
                    throw new ExceptionWithEventId(XEvent.Id.CATALOG_MEDIACLASS_SETTING_MALFORMATTED, string.Format("InitMediaClassFromSettingValue: failed to parse value of setting: {0}, value ({1}) should be comma-separated list of ints.", settingValue, value));
                }
            }
            return mediaTypes;
        }

        public static void InitMediaTypeClasses()
        {
            _musicMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_musicMediaTypes));

            _videoMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_videoMediaTypes));

            _gameMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_gameMediaTypes));

            _consumableMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_consumableMediaTypes));

            _repurchasableMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_repurchasableMediaTypes));

            _pointsBundleMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_pointsBundleMediaTypes));

            _subscriptionMediaTypes = InitMediaClassFromSettingValue(Config.GetSetting(Setting.catalog_subscriptionMediaTypes));

            _appMediaTypes = InitMediaClassFromSettingValue( Config.GetSetting( Setting.catalog_appMediaTypes ) );
        }

        protected static Dictionary<int,MediaTypeInfo> _allMediaTypes = null;

        protected static List<int> _videoMediaTypes = null;
        protected static List<int> _gameMediaTypes = null;
        protected static List<int> _musicMediaTypes = null;
        protected static List<int> _consumableMediaTypes = null;
        protected static List<int> _repurchasableMediaTypes = null;
        protected static List<int> _pointsBundleMediaTypes = null;
        protected static List<int> _subscriptionMediaTypes = null;
        protected static List<int> _appMediaTypes = null;

        private static bool IsValidMediaType(int mediaTypeId)
        {
            Init();
            bool isValidMediaType = _allMediaTypes.ContainsKey(mediaTypeId);
            return isValidMediaType;
        }

        private static bool IsMediaTypeGivenMediaClass(int mediaTypeId, MediaClassEnum givenMediaClass)
        {
            bool isGivenMediaClass = IsValidMediaType(mediaTypeId) && _allMediaTypes[mediaTypeId].Class == givenMediaClass;
            return isGivenMediaClass;
        }

        private static bool IsGameMediaType( int mediaTypeId )
        {
            return IsMediaTypeGivenMediaClass( mediaTypeId, MediaClassEnum.Game );
        }

        private static bool IsMusicMediaType( int mediaTypeId )
        {
            return IsMediaTypeGivenMediaClass( mediaTypeId, MediaClassEnum.Music );
        }

        private static bool IsConsumableMediaType( int mediaTypeId )
        {
            bool isConsumable = _consumableMediaTypes != null && _consumableMediaTypes.Contains( mediaTypeId );
            return isConsumable;
        }

        public static bool IsPurchasableMediaType(int mediaTypeId)
        {
            bool isPurchasable = IsValidMediaType(mediaTypeId) && _allMediaTypes[mediaTypeId].Class != MediaClassEnum.Unclassified;
            return isPurchasable;
        }

        public static bool IsVideoMediaType(int mediaTypeId)
        {
            return IsMediaTypeGivenMediaClass(mediaTypeId, MediaClassEnum.Video);
        }

        public static bool IsGameConsumableMediaType(int mediaTypeId)
        {
            bool isGameConsumable = IsGameMediaType(mediaTypeId) && IsConsumableMediaType(mediaTypeId);
            return isGameConsumable;
        }

        public static bool IsRepurchasableMediaType(int mediaTypeId)
        {
            bool isRepurchasable = _repurchasableMediaTypes != null && _repurchasableMediaTypes.Contains(mediaTypeId);
            return isRepurchasable;
        }

        public static bool IsPointsBundleMediaType(int mediaTypeId)
        {
            return IsMediaTypeGivenMediaClass(mediaTypeId, MediaClassEnum.PointsBundle);
        }

        public static bool IsSubscriptionMediaType(int mediaTypeId)
        {
            return IsMediaTypeGivenMediaClass(mediaTypeId, MediaClassEnum.Subscription);
        }

        public static bool IsInZuneCatalog(int storeId, int mediaTypeId)
        {
            //
            // This method returns Zune/NotZune bool value and relies on logic implemented
            // in InWhichCatalogIsIt() generic method in identifying the VideoCatalog type.
            // (currently called by VerifyToken.cs only)
            bool useZuneCatalog = (InWhichCatalogIsIt(storeId, mediaTypeId) == VirtualInterfaceName.ZuneCatalog) ? true : false;

            return useZuneCatalog;
        }

        public static string InWhichCatalogIsIt(int storeId, int mediaTypeId)
        {
            // Expanding logic of former IsInZuneCatalog() method for multiple catalogs
            // driven by npdb settings:
            //    1. Setting.xbos_useExternalVideoMarketPlace.
            //    2. MultiSetting.catalog_storeCatalogDefault
            //    3. MultiSetting.catalog_storeMediaTypeCatalogOverride
            //
            // Two catalog types available for now are - XboxCatalog and ZuneCatalog

            if (Config.GetBoolSetting(Setting.xbos_useExternalVideoMarketplaceCatalog))
            {
                // Video Marketplace has moved to external catalog (Zune/Zest); use Geneva catalog determination logic
                //
                // new catalog determination logic is used here

                string[] npdbStoreCatalogDefaultMultiSettings = Config.GetMultiSetting(MultiSetting.catalog_storeCatalogDefault);
                int MultiSettingsCount = npdbStoreCatalogDefaultMultiSettings.Length;
                string currVirtualInterfaceName = VirtualInterfaceName.UnknownCatalog;

                if (MultiSettingsCount < 1)
                {
                    // error - empty multi-settings
                    throw new ExceptionWithEventId(
                        XEvent.Id.STORECATALOG_DEFAULT_SETTINGS_MISSING,
                        "MultiSetting.catalog_storeCatalogDefault contains no default settings - must be at least one;"
                        );
                }

                foreach (string defaultsetting in npdbStoreCatalogDefaultMultiSettings)
                {
                    string[] arrDefaultSettings = defaultsetting.Split(',');

                    if (arrDefaultSettings.Length != 2)
                    {
                        // error - wrong format: must be comma delimited string with two elements for default settings
                        throw new ExceptionWithEventId(
                            XEvent.Id.STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_1,
                            "MultiSetting.catalog_storeCatalogDefault contains malformatted settings; every setting must be a set of {storeID, VirtualInterfaceName} pairs like: '1, FECatalogDbXbox'"
                            );
                    }

                    // parsing storeID with string ==> Int32 conversion
                    int currStoreID = -1;
                    try
                    {
                        currStoreID = Convert.ToInt32(arrDefaultSettings[0]);
                    }
                    catch
                    {
                        throw new ExceptionWithEventId(
                            XEvent.Id.STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_2,
                            "MultiSetting.catalog_storeCatalogDefault contains malformatted settings; storeID in  '1, FECatalogDbXbox' must be an integer number"
                            );
                    }

                    // parsing VirtualInterfaceName
                    currVirtualInterfaceName = arrDefaultSettings[1].ToLowerInvariant();

                    if (currStoreID == storeId)
                    {
                        // return specified CatalogName lloking for storeId (and mediaTypeId if needed)

                        // check for everrides first
                        string[] npdbStoreCatalogOverridesMultiSettings = Config.GetMultiSetting(MultiSetting.catalog_storeMediaTypeCatalogOverride);

                        foreach (string overridesetting in npdbStoreCatalogOverridesMultiSettings)
                        {
                            string[] arrOverrideSettings = overridesetting.Split(',');

                            if (arrOverrideSettings.Length != 3) // must be like: 1, 2, FECatalogDbZune
                            {
                                // wrong format - must be like: '1, 2, FECatalogDbZune'
                                throw new ExceptionWithEventId(
                                    XEvent.Id.STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_1,
                                    "MultiSetting.catalog_storeMediaTypeCatalogOverride wrong formatted settings; every setting must have 3 comma-delimited elements, like: '1, 2, FECatalogDbZune'"
                                    );
                            }
                            else
                            {
                                // get overrides for storeId, mediaTypeId and VirtualInterfaceName
                                int currOverrideStoreID = -1;
                                try
                                {
                                    currOverrideStoreID = Convert.ToInt32(arrOverrideSettings[0]);
                                }
                                catch
                                {
                                    throw new ExceptionWithEventId(
                                        XEvent.Id.STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_2,
                                        "MultiSetting.catalog_storeMediaTypeCatalogOverride contains malformatted settings; storeID in  '1, 2, FECatalogDbXbox' must be an integer number"
                                        );
                                }

                                // parsing mediaTypeID with string ==> Int32 conversion
                                int currOverrideMediaTypeID = -1;
                                try
                                {
                                    currOverrideMediaTypeID = Convert.ToInt32(arrOverrideSettings[1]);
                                }
                                catch
                                {
                                    throw new ExceptionWithEventId(
                                        XEvent.Id.STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_3,
                                        "MultiSetting.catalog_storeMediaTypeCatalogOverride contains malformatted settings; mediaTypeID in  '1, 2, FECatalogDbXbox' must be an integer number"
                                        );
                                }

                                // parsing virtual interface name
                                string currOverrideVirtualInterfaceName = arrOverrideSettings[2].ToLowerInvariant();

                                if (currOverrideStoreID == storeId && currOverrideMediaTypeID == mediaTypeId)
                                {
                                    // override available
                                    currVirtualInterfaceName = currOverrideVirtualInterfaceName;
                                    break;
                                }
                            }
                        }

                        break;
                    }
                }

                // "formatting output" - returning VirtualInterfaceName (catalog type)
                // as listed in VirtualInterfaceName class

                if (currVirtualInterfaceName == VirtualInterfaceName.ZuneCatalog)
                {
                    return VirtualInterfaceName.ZuneCatalog;
                }
                if (currVirtualInterfaceName == VirtualInterfaceName.ZestCatalog)
                {
                    return VirtualInterfaceName.ZestCatalog;
                }
                if (currVirtualInterfaceName == VirtualInterfaceName.XboxCatalog)
                {
                    return VirtualInterfaceName.XboxCatalog;
                }

                return VirtualInterfaceName.UnknownCatalog;
            }
            else
            {
                // Video Marketplace is still in XBox catalog; use Stockholm catalog determination logic

                //
                // This is a bit kludgy but here goes...  video purchases from the Zune store
                // will be redirected to the EMS catalog except in the case of music videos.
                // The Zune catalog has previously handled music video purchases from its store
                // and will continue to do so.
                //

                if (storeId == (int)StoreEnum.Zune && (!IsVideoMediaType(mediaTypeId) || mediaTypeId == MediaTypeInfo.MusicVideo))
                {
                    return VirtualInterfaceName.ZuneCatalog;
                }
                else
                {
                    return VirtualInterfaceName.XboxCatalog;
                }
            }
        }

        public static string GetMediaTypeName(int mediaTypeId)
        {
            if ( _allMediaTypes == null )
            {
                throw new Exception("GetMediaTypeName: _allMediaTypes not initialized from catalog!");
            }

            if ( IsValidMediaType(mediaTypeId) )
            {
                MediaTypeInfo mti = _allMediaTypes[mediaTypeId];
                return mti.Name;
            }

            return null;
        }

        public static List<OfferInfo> GetOfferInstanceGrantInfo(List<MediaPurchaseInfo> purchaseInfos,
            bool feZune)
        {
            StringBuilder offerInstanceXml = new StringBuilder();
            foreach (MediaPurchaseInfo purchaseInfo in purchaseInfos)
            {
                offerInstanceXml.Append(string.Format("<item oiid=\"{0}\"/>", purchaseInfo.OfferInstanceId.ToString()));
            }

            string connectionString = feZune ?
                ConfigUtil.FECatalogDBZuneConnectionString : ConfigUtil.FECatalogDBXboxConnectionString;

            using (SqlConnection c = new SqlConnection(connectionString))
            {
                c.Open();

                using (SqlCommand cmd = c.CreateCommand())
                {
                    cmd.CommandText = "dbo.GetOfferInstanceGrantInfo";
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@offerInstanceXml", SqlDbType.NVarChar, Int32.MaxValue).Value =
                        offerInstanceXml.ToString();

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        List<OfferInfo> ois = new List<OfferInfo>();

                        while (r.Read())
                        {
                            Guid offerInstanceId = r.GetGuid(0);
                            Guid offerId = r.GetGuid(1);
                            int mediaTypeId = r.GetInt32(2);
                            int isMusicNetContent = r.GetInt32(3);
                            string mnetId = r.GetString(4).Trim();

                            OfferInfo oi = new OfferInfo();
                            oi.offerInstanceId = offerInstanceId;
                            oi.offerId = offerId;
                            oi.mediaTypeId = mediaTypeId;

                            oi.isMusicNetContent = isMusicNetContent == 1;
                            oi.mnetId = mnetId;

                            ois.Add(oi);
                        }

                        r.Close();

                        HResult hr = (uint) ((int) ret.Value);
                        if (HResult.Failed(hr))
                        {
                            string msg = "dbo.GetOffersFromOfferInstances failed with hr = " + hr;

                            throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_100, msg);
                        }

                        if (ois.Count != purchaseInfos.Count)
                        {
                            throw new XRLException(HResult.XOFF_E_INVALID_OFFER_ID,
                                XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                                string.Format("One of the offers being purchased is not configured properly."));
                        }

                        return ois;
                    }
                }
            }
        }

        public static List<OfferInfo> GetOfferPurchaseInfo(DateTime postingDate, int storeId, OfferMediaTypeExpectedPrice [] offers,
            string legalLocale, int requiredUserTypeId, int paymentTypeId, bool userHasStagingAccess, out bool isEditorialPurchase)
        {
            StringBuilder xboxOfferXml = new StringBuilder();
            int numXboxOffers = 0;
            bool isXboxEditorialPurchase = false;

            StringBuilder zuneOfferXml = new StringBuilder();
            int numZuneOffers = 0;
            bool isZuneEditorialPurchase = false;

            isEditorialPurchase = false;

            foreach (OfferMediaTypeExpectedPrice offer in offers)
            {
                string offerNode = string.Format("<item oid=\"{0}\"/>", offer.offerId.ToString());

                // proceding according to catalog type
                switch (InWhichCatalogIsIt(storeId, offer.mediaTypeId))
                {
                    case VirtualInterfaceName.ZuneCatalog:
                            zuneOfferXml.Append(offerNode);
                            numZuneOffers++;
                            break;

                    case VirtualInterfaceName.XboxCatalog:
                            xboxOfferXml.Append(offerNode);
                            numXboxOffers++;
                            break;
                    default:
                            throw new ExceptionWithEventId(
                                XEvent.Id.VIDEOCATALOG_SETTINGS_MALFORMATTED,
                                "VideoCatalog Settings provided in npdb..t_multisettings table are missing or malformatted"
                                );
                }
            }

            List<OfferInfo> offerInfos = new List<OfferInfo>();

            // first, obtain offer data for any offers in the Xbox catalog
            if ( numXboxOffers > 0 )
            {
                bool feZune = false;
                List<OfferInfo> xboxOfferInfos = GetOfferPurchaseInfo(postingDate, xboxOfferXml.ToString(), numXboxOffers, legalLocale, requiredUserTypeId, paymentTypeId, feZune, userHasStagingAccess, out isXboxEditorialPurchase);

                foreach (OfferInfo xboxOfferInfo in xboxOfferInfos)
                {
                    offerInfos.Add(xboxOfferInfo);
                }
            }

            if ( numZuneOffers > 0 )
            {
                bool feZune = true;

                List<OfferInfo> zuneOfferInfos = GetOfferPurchaseInfo(postingDate, zuneOfferXml.ToString(), numZuneOffers, legalLocale, requiredUserTypeId, paymentTypeId, feZune, userHasStagingAccess, out isZuneEditorialPurchase);

                foreach (OfferInfo zuneOfferInfo in zuneOfferInfos)
                {
                    offerInfos.Add(zuneOfferInfo);
                }
            }

            isEditorialPurchase = isXboxEditorialPurchase || isZuneEditorialPurchase;

            return offerInfos;
        }

        /// <summary>
        /// Given an OfferInfo object from the Zune catalog, identify whether the track
        /// is a normal points-based offering or if it is a SubscriptionFree offering.
        /// </summary>
        /// <param name="offerInfo">Zune catalog offerInfo</param>
        public static bool IsZuneSubscriptionFreeOffer(OfferInfo offerInfo)
        {
            const int zuneSubscriptionFreeLicenseTypeId = 14;

            Debug.Assert( offerInfo != null );
            if ( offerInfo == null )
            {
                throw new ArgumentNullException("offerInfo");
            }

            Debug.Assert( offerInfo.isMusicNetContent && IsMusicMediaType(offerInfo.mediaTypeId) );
            if ( offerInfo.isMusicNetContent == false )
            {
                throw new ArgumentException("offerInfo is not a Musicnet content offer.");
            }

            if ( IsMusicMediaType(offerInfo.mediaTypeId) == false )
            {
                throw new ArgumentException(string.Format("offerInfo has a mediaTypeId {0} not associated with music.", offerInfo.mediaTypeId));
            }

            if ( offerInfo.mediaInstanceInfos == null || offerInfo.mediaInstanceInfos.Count < 1 )
            {
                return false;
            }

            // If all of the media instances have a licenseTypeId of SubscriptionFree,
            // then the track is a SubscriptionFree track.
            foreach (MediaInstanceInfo mii in offerInfo.mediaInstanceInfos)
            {
                if ( mii.licenseTypeId != zuneSubscriptionFreeLicenseTypeId )
                {
                    return false;
                }

                return true;
            }

            return false;
        }

        public static List<OfferInfo> GetOfferPurchaseInfo(DateTime postingDate, OfferExpectedPrice [] offers,
            string legalLocale, int requiredUserTypeId, int paymentTypeId, bool feZune, bool userHasStagingAccess, out bool isEditorialPurchase)
        {
            StringBuilder offerXml = new StringBuilder();
            isEditorialPurchase = false;

            foreach (OfferExpectedPrice offer in offers)
            {
                offerXml.Append(string.Format("<item oid=\"{0}\"/>", offer.offerId.ToString()));
            }

            return GetOfferPurchaseInfo(postingDate, offerXml.ToString(), offers.Length, legalLocale, requiredUserTypeId, paymentTypeId,
                feZune, userHasStagingAccess, out isEditorialPurchase);
        }
        public static List<OfferInfo> GetOfferPurchaseInfo(DateTime postingDate, OfferProductInfo[] offers,
           string legalLocale, int requiredUserTypeId, int paymentTypeId, bool feZune, bool userHasStagingAccess)
        {
            StringBuilder offerXml = new StringBuilder();
            bool isEditorialPurchase = false;

            foreach (OfferProductInfo offer in offers)
            {
                offerXml.Append(string.Format("<item oid=\"{0}\"/>", offer.offerId.ToString()));
            }

            return GetOfferPurchaseInfo(postingDate, offerXml.ToString(), offers.Length, legalLocale, requiredUserTypeId, paymentTypeId,
                feZune, userHasStagingAccess, out isEditorialPurchase);
        }

        public static List<OfferInfo> GetOfferPurchaseInfo(DateTime postingDate, string offerXml, int numOffers,
            string legalLocale, int requiredUserTypeId, int paymentTypeId, bool feZune, bool userHasStagingAccess, out bool isEditorialPurchase)
        {
            string connectionString = feZune ?
                ConfigUtil.FECatalogDBZuneConnectionString : ConfigUtil.FECatalogDBXboxConnectionString;
            isEditorialPurchase = false;

            using (SqlConnection c = new SqlConnection(connectionString))
            {
                c.Open();

                using (SqlCommand cmd = c.CreateCommand())
                {
                    cmd.CommandText = "dbo.GetOfferPurchaseInfo";
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@postingDate", SqlDbType.DateTime).Value = postingDate;
                    cmd.Parameters.Add("@offerXml", SqlDbType.NVarChar, Int32.MaxValue).Value = offerXml.ToString();
                    cmd.Parameters.Add("@legalLocale", SqlDbType.NVarChar, 10).Value = legalLocale;
                    cmd.Parameters.Add("@requiredUserTypeId", SqlDbType.Int).Value = requiredUserTypeId;

                    //
                    // Zune needs to integrate this parameter into their catalog's version
                    // of GetOfferPurchaseInfo
                    //
                    if ( !feZune || Config.GetBoolSetting(Setting.xbos_EnablePaymentTypeIdSupportInZuneCatalog) )
                    {
                        cmd.Parameters.Add("@paymentTypeId", SqlDbType.Int).Value = paymentTypeId;
                    }

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        List<OfferInfo> ois = new List<OfferInfo>();

                        # region First result
                        while (r.Read())
                        {
                            Guid offerId = r.GetGuid(0);
                            Guid offerInstanceId = r.GetGuid(1);
                            Guid mediaId = r.GetGuid(2);

                            int mediaTypeId = r.GetInt32(3);
                            string mediaType = r.GetString(4).Trim();
                            string reducedTitle = r.GetString(5).Trim();
                            int geoCheckPolicy = r.GetByte(6);

                            int retailPricePoints = r.GetInt32(7);
                            decimal retailPrice = r.GetDecimal(8);
                            string retailCurrency = r.GetString(9).Trim();
                            int pricingRuleId = r.GetInt32(10);
                            string promotionId;
                            if (r.IsDBNull(11))
                                promotionId = null;
                            else
                                promotionId = r.GetGuid(11).ToString();

                            string sku = null;
                            if (!r.IsDBNull(12))
                            {
                                sku = r.GetString(12).Trim();
                            }
                            DateTime visibilityDate = r.GetDateTime(13);
                            int mediaVisibilityStatusId = r.GetInt32(14);

                            DateTime startDateTime = DateTime.UtcNow.AddDays(-1); // assume in the past if not found
                            int oiPaymentTypeId = (int) CatalogPaymentTypeEnum.Points;

                            decimal oiCurrencyPrice = 0.0M;
                            string oiCurrencyCode = "";
                            int oiTaxTypeId = 0;
                            string oiBillingOfferId = "";

                            Guid? billingServiceComponentid = null;

                            int duration = 0;

                            int durationType = 0;

                            int offerTypeId = 0;

                            uint titleId = 0;

                            int tierId = -1;


                            // some unpleasant hackery to deal with the fact that not only
                            // may the catalog lag the front end code but the Zune catalog
                            // will not necessarily return any of these fields back to us.
                            if ( r.FieldCount > 15 )
                            {
                                startDateTime = r.GetDateTime(15);

                                if ( r.FieldCount > 16 )
                                {
                                    oiPaymentTypeId = r.GetInt32(16);

                                    if ( r.FieldCount > 18 )
                                    {
                                        oiCurrencyPrice = r.GetDecimal(17);
                                        oiCurrencyCode = r.GetString(18).Trim();

                                        if ( r.FieldCount > 19 )
                                        {
                                            oiBillingOfferId = r.GetString(19).Trim();

                                            if ( r.FieldCount > 20 )
                                            {
                                                oiTaxTypeId = r.GetInt32(20);

                                                if (r.FieldCount > 21)
                                                {
                                                    if (r.IsDBNull(21))
                                                    {
                                                        billingServiceComponentid = null;
                                                    }
                                                    else
                                                    {
                                                        billingServiceComponentid = r.GetGuid(21);
                                                    }
                                                    if (!r.IsDBNull(22))
                                                    {
                                                        duration = r.GetInt32(22);
                                                    }
                                                    if (!r.IsDBNull(23))
                                                    {
                                                        durationType = r.GetInt32(23);
                                                    }
                                                    if (!r.IsDBNull(24))
                                                    {
                                                        offerTypeId = r.GetInt32(24);
                                                    }
                                                    if (!r.IsDBNull(25))
                                                    {
                                                        titleId = (uint)r.GetInt32(25);
                                                    }
                                                    if (!r.IsDBNull(26))
                                                    {
                                                        tierId = r.GetInt32(26);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            OfferInfo oi = new OfferInfo();
                            oi.wholesalePriceLoaded = false;

                            oi.offerInstanceId = offerInstanceId;
                            oi.offerId = offerId;
                            oi.mediaId = mediaId;
                            oi.startDateTime = startDateTime;
                            oi.paymentTypeId = oiPaymentTypeId;
                            oi.currencyPrice = oiCurrencyPrice;
                            oi.currencyCode = oiCurrencyCode;
                            oi.taxTypeId = oiTaxTypeId;
                            oi.billingOfferId = oiBillingOfferId;

                            oi.mediaTypeId = mediaTypeId;
                            oi.mediaType = mediaType;
                            oi.reducedTitle = reducedTitle;
                            oi.geoCheckPolicy = geoCheckPolicy;
                            oi.retailPricePoints = retailPricePoints;
                            oi.retailPrice = retailPrice;
                            oi.retailCurrency = retailCurrency;
                            oi.pricingRuleId = pricingRuleId;
                            oi.promotionId = promotionId;
                            oi.sku = sku;
                            oi.visibilityDate = visibilityDate;
                            oi.mediaVisibilityStatusId = mediaVisibilityStatusId;
                            oi.subscriptionDuration=duration;
                            oi.subscriptionDurationType=durationType;
                            oi.offerType = offerTypeId;
                            oi.titleId = titleId;
                            oi.tierId = tierId;


                            if (billingServiceComponentid.HasValue)
                            {
                                oi.serviceComponentId = billingServiceComponentid.Value.ToString();
                            }
                            else
                            {
                                oi.serviceComponentId=null;
                           }

                            ois.Add(oi);
                            oi.mediaInstanceInfos = new List<MediaInstanceInfo>();
                            oi.offerRelationshipsFrom = new List<OfferRelationship>();
                            oi.offerRelationshipsTo = new List<OfferRelationship>();
                        }
                        # endregion

                        # region Secondresult
                        r.NextResult();

                        while (r.Read())
                        {
                            Guid offerInstanceId = r.GetGuid(0);

                            Guid providerTermId=Guid.Empty;
                            if (!r.IsDBNull(1))
                            {
                                providerTermId = r.GetGuid(1); // currently unused
                            }

                            decimal wholesalePrice=0;
                            if (!r.IsDBNull(2))
                            {
                                wholesalePrice = r.GetDecimal(2);
                            }

                            string wholesaleCurrency=string.Empty;
                            if (!r.IsDBNull(3))
                            {
                                wholesaleCurrency = r.GetString(3).Trim();
                            }

                            int isSyncCastContent = r.GetInt32(4);
                            int isMusicNetContent = r.GetInt32(5);

                            string mnetId=string.Empty;
                            if (!r.IsDBNull(6))
                            {
                                mnetId = r.GetString(6).Trim();
                            }
                            int visibilityStatusId = r.GetInt32(7);

                            decimal suggestedRetailPrice = 0;
                            if (r.FieldCount > 8 && !r.IsDBNull(8))
                            {
                                suggestedRetailPrice = r.GetDecimal(8);
                            }

                            foreach (OfferInfo oi in ois)
                            {
                                if (oi.offerInstanceId == offerInstanceId)
                                {
                                    if (oi.wholesalePriceLoaded)
                                    {
                                        throw new XRLException(HResult.XONLINE_E_OFFERING_OFFER_MISCONFIGURED,
                                            XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                                            string.Format("OfferInstanceId '{0}' has more than one providerTerm specified, or is otherwise misconfigured",
                                            oi.offerInstanceId.ToString()));
                                    }

                                    if (string.Compare(oi.retailCurrency, wholesaleCurrency, true) != 0)
                                    {
                                        throw new XRLException(HResult.XONLINE_E_OFFERING_OFFER_MISCONFIGURED,
                                            XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                                            string.Format("OfferInstanceId '{0}' has mismatching retailPrice and wholesalePrice currencies",
                                            oi.offerInstanceId.ToString()));
                                    }

                                    oi.wholesalePrice = wholesalePrice;
                                    oi.wholesaleCurrency = wholesaleCurrency;
                                    oi.wholesalePriceLoaded = true;
                                    oi.suggestedRetailPrice = suggestedRetailPrice;

                                    oi.isSyncCastContent = isSyncCastContent == 1;
                                    oi.isMusicNetContent = isMusicNetContent == 1;
                                    oi.mnetId = mnetId;

                                    oi.visibilityStatusId = visibilityStatusId;
                                }
                            }
                        }
                        # endregion

                        # region Third result
                        r.NextResult();


                        //the check for null is being made here because pointsbundle do not have instances
                        while (r.Read())
                        {
                            Guid offerInstanceId=Guid.Empty;
                            Guid mediaId = Guid.Empty;
                            Guid mediaInstanceId = Guid.Empty;
                            Guid mediaContributorId = Guid.Empty;
                            byte isAcquirable=byte.MinValue;
                            int licenseTypeId=0;
                            int licenseClassId=0;
                            int mediaTypeId=0;
                            int geoCheckPolicy=0;
                            DateTime visibilityDate=DateTime.MaxValue;
                            int visibilityStatusId=0;
                            int assetId = 0;
                            int assetQuantity = 0;
                            int assetTitleId = 0;
                            string mediaTitle = string.Empty;
                            string revenueSku = string.Empty;

                            if (!r.IsDBNull(0))
                            {
                                offerInstanceId = (r.GetGuid(0));
                            }
                            if (!r.IsDBNull(1))
                            {
                                mediaId = r.GetGuid(1);
                            }
                            if (!r.IsDBNull(2))
                            {
                                mediaInstanceId = r.GetGuid(2);
                            }
                            if (!r.IsDBNull(3))
                            {
                                isAcquirable = r.GetByte(3);
                            }
                            if (!r.IsDBNull(4))
                            {
                                licenseTypeId = r.GetInt32(4);
                            }
                            if (!r.IsDBNull(5))
                            {
                                licenseClassId = r.GetInt32(5);
                            }
                            if (!r.IsDBNull(6))
                            {
                                mediaTypeId = r.GetInt32(6);
                            }
                            if (!r.IsDBNull(7))
                            {
                                geoCheckPolicy = r.GetByte(7);
                            }
                            if (!r.IsDBNull(8))
                            {
                                visibilityDate = r.GetDateTime(8);
                            }
                            if (!r.IsDBNull(9))
                            {
                                visibilityStatusId = r.GetInt32(9);
                            }

                            // KLUDGE:
                            //
                            // Oh joy!  More hacktastic dual-catalog complexity...
                            //
                            // The Zune catalog version of this stored procedure will not return
                            // the asset-related columns as part of the media instance result set.
                            //
                            // The one fringe benefit of this madness is that the changes to this
                            // code can be checked in before the GetOfferPurchaseInfo change is
                            // checked into the EMS tree and deployed in test environments.
                            //
                            if (r.FieldCount > 10 && !r.IsDBNull(10))
                            {
                                assetId = r.GetInt32(10);
                            }

                            if (r.FieldCount > 11 && !r.IsDBNull(11))
                            {
                                    assetQuantity = r.GetInt32(11);
                            }
                            if (r.FieldCount > 12 && !r.IsDBNull(12))
                            {
                                    assetTitleId = r.GetInt32(12);

                            }
                            if (r.FieldCount > 13 && !r.IsDBNull(13))
                            {
                                mediaContributorId = r.GetGuid(13);
                            }
                            if (r.FieldCount > 14 && !r.IsDBNull(14))
                            {
                                mediaTitle = r.GetString(14).Trim();
                            }

                            MediaInstanceInfo mii = new MediaInstanceInfo();
                            mii.mediaId = mediaId;
                            mii.mediaInstanceId = mediaInstanceId;
                            mii.isAcquirable = isAcquirable == 1;
                            mii.licenseTypeId = licenseTypeId;
                            mii.licenseClassId = licenseClassId;
                            mii.mediaTypeId = mediaTypeId;
                            mii.geoCheckPolicy = geoCheckPolicy;
                            mii.visibilityDate = visibilityDate;
                            mii.visibilityStatusId = visibilityStatusId;
                            mii.assetId = assetId;
                            mii.assetQuantity = assetQuantity;
                            mii.assetTitleId = assetTitleId;
                            mii.mediaContributorId = mediaContributorId;
                            mii.mediaTitle = mediaTitle;

                            // If the mediaType is InGameConsumable and the catalog did not return
                            // asset information, fail now.
                            if ( IsGameConsumableMediaType(mii.mediaTypeId) && !mii.HasAssetInfo )
                            {
                                string offerId = "uknown";

                                // find the parent offer
                                foreach (OfferInfo oi in ois)
                                {
                                    if ( oi.offerInstanceId == offerInstanceId )
                                    {
                                        offerId = oi.offerId.ToString();
                                        break;
                                    }
                                }

                                throw new XRLException(
                                    HResult.XONLINE_E_OFFERING_OFFER_MISCONFIGURED,
                                    XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                                    string.Format("GenerateOfferAssetXml: offerId: {0} is of type InGameConsumable but no asset information was returned from GetOfferPurchaseInfo.  Verify offer is correctly configured in EMS Catalog!", offerId));
                            }

                            foreach (OfferInfo oi in ois)
                            {
                                if (oi.offerInstanceId == offerInstanceId)
                                {
                                    oi.mediaInstanceInfos.Add(mii);
                                }
                            }
                        }

                        # endregion

                        # region Fourth result

                        if (r.NextResult())
                        {
                            while (r.Read())
                            {
                                OfferRelationship offerRelationship = new OfferRelationship();

                                offerRelationship.offerId= r.GetGuid(r.GetOrdinal("offerId"));

                                offerRelationship.relatedOfferId=r.GetGuid(r.GetOrdinal("relatedOfferId"));

                                offerRelationship.offerRelationshipTypeId = r.GetInt32(r.GetOrdinal("relationshipTypeId"));

                                offerRelationship.relatedOfferPrice = r.GetDecimal(r.GetOrdinal("relatedOfferPrice"));

                                foreach (OfferInfo oi in ois)
                                {
                                    if (oi.offerId == offerRelationship.offerId)
                                    {
                                        oi.offerRelationshipsTo.Add(offerRelationship);
                                    }
                                }
                            }

                        }
                        # endregion

                        # region Fifth result

                        if (r.NextResult())
                        {
                            while (r.Read())
                            {
                                OfferRelationship offerRelationship = new OfferRelationship();

                                offerRelationship.offerId = r.GetGuid(r.GetOrdinal("offerId"));

                                offerRelationship.relatedOfferId = r.GetGuid(r.GetOrdinal("relatedOfferId"));

                                offerRelationship.offerRelationshipTypeId = r.GetInt32(r.GetOrdinal("relationshipTypeId"));

                                foreach (OfferInfo oi in ois)
                                {
                                    if (oi.offerId == offerRelationship.relatedOfferId)
                                    {
                                        oi.offerRelationshipsFrom.Add(offerRelationship);
                                    }
                                }
                            }
                        }
                        # endregion

                        r.Close();

                        HResult hr = (uint) ((int) ret.Value);
                        if (HResult.Failed(hr))
                        {
                            string msg = "dbo.GetOfferPurchaseInfo failed with hr = " + hr;

                            throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_100, msg);
                        }

                        if (ois.Count != numOffers)
                        {
                            throw new XRLException(HResult.XOFF_E_INVALID_OFFER_ID,
                                XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                                string.Format("One of the offers being purchased does not exist, or is not configured properly."));
                        }

                        // perform offer/instance/media visibility and editorial checks
                        CheckOfferVisibility(ois, userHasStagingAccess, out isEditorialPurchase);

                        return ois;
                    }
                }
            }
        }

        private static void CheckOfferVisibility(List<OfferInfo> ois, bool userHasStagingAccess, out bool isEditorialPurchase)
        {
            Debug.Assert( ois != null );
            if ( ois == null )
            {
                throw new ArgumentNullException("ois");
            }

            isEditorialPurchase = false;

            foreach (OfferInfo oi in ois)
            {
                if (!oi.wholesalePriceLoaded)
                {
                    throw new XRLException(HResult.XONLINE_E_OFFERING_OFFER_MISCONFIGURED,
                        XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                        string.Format("OfferInstanceId '{0}' has no corresponding providerTerms.",
                            oi.offerInstanceId.ToString()));
                }

                if (oi.visibilityStatusId != (int) VisibilityStatus.Staging && oi.visibilityStatusId != (int) VisibilityStatus.Live)
                {
                    throw new XRLException(HResult.XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED,
                        XEvent.Id.PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED,
                        string.Format(
                            "OfferInstanceId '{0}' has OfferInstanceProviderTerm with visibilityStatus '{1}', which cannot be purchased.",
                            oi.offerInstanceId.ToString(), oi.visibilityStatusId));
                }

                if (oi.mediaVisibilityStatusId != (int) VisibilityStatus.Staging && oi.mediaVisibilityStatusId != (int) VisibilityStatus.Live)
                {
                    throw new XRLException(HResult.XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED,
                        XEvent.Id.PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED,
                        string.Format(
                            "OfferInstanceId '{0}' has Offer.Media with visibilityStatus '{1}', which cannot be purchased.",
                            oi.offerInstanceId.ToString(), oi.mediaVisibilityStatusId));
                }

                if (oi.visibilityStatusId == (int)VisibilityStatus.Staging)
                {
                    if (!userHasStagingAccess)
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED,
                            XEvent.Id.PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED,
                            string.Format(
                                "OfferInstanceId '{0}' has Offer.Media as VisibilityStatusId=Staging, but the user does not have editorial privilege.  Purchase is blocked.",
                                oi.offerInstanceId.ToString()));
                    }
                    else
                    {
                        isEditorialPurchase = true;
                    }
                }

                if (oi.mediaVisibilityStatusId == (int)VisibilityStatus.Staging)
                {
                    if (!userHasStagingAccess)
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED,
                            XEvent.Id.PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED,
                            string.Format(
                                "OfferInstanceId '{0}' has OfferInstanceProviderTerm with VisibilityStatusId=Staging, but the user does not have editorial privilege.  Purchase is blocked.",
                                oi.offerInstanceId.ToString()));
                    }
                    else
                    {
                        isEditorialPurchase = true;
                    }
                }

                if (oi.startDateTime > DateTime.UtcNow)
                {
                    if (!userHasStagingAccess)
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED,
                            XEvent.Id.PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED,
                            string.Format(
                                "OfferInstanceId '{0}' has OfferInstance.startDateTime in the future, but the user does not have editorial privilege.  Purchase is blocked.",
                                oi.offerInstanceId.ToString()));
                    }
                    else
                    {
                        isEditorialPurchase = true;
                    }
                }

                // loop over what the user is "getting" and make sure they will "get" at least one
                // mediaInstance when purchasing this offer, otherwise block the purchase (Ramesh
                // confirmed with JHook that this is a valid rule, and should hopefully catch early
                // one class of offer misconfigurations)
                // also check if any of the instances are "staging" for a user that can access them

                bool purchaseableInstanceFound = false;
                foreach (MediaInstanceInfo mii in oi.mediaInstanceInfos)
                {
                    if (mii.mediaTypeId != MediaTypeInfo.PointsBundle
                        && mii.mediaTypeId != MediaTypeInfo.LiveSubscription
                        && mii.mediaTypeId != MediaTypeInfo.GameSubscription)
                    {
                        if (mii.visibilityDate <= DateTime.UtcNow || userHasStagingAccess)
                        {
                            if (mii.isAcquirable == true)
                            {
                                if (mii.visibilityStatusId == (int)VisibilityStatus.Live ||
                                    (mii.visibilityStatusId == (int)VisibilityStatus.Staging && userHasStagingAccess))
                                {
                                    purchaseableInstanceFound = true;

                                    // future visibility or "stating" status
                                    if (userHasStagingAccess && (mii.visibilityDate > DateTime.UtcNow || mii.visibilityStatusId == (int)VisibilityStatus.Staging))
                                    {
                                        isEditorialPurchase = true;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        purchaseableInstanceFound = true;
                    }
                }

                if (!purchaseableInstanceFound)
                {
                    throw new XRLException(HResult.XONLINE_E_OFFERING_GRANTS_NOTHING,
                        XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                        string.Format(
                            "OfferInstanceId '{0}' has no mediaInstances which are acquirable by the user, and so purchase is blocked.",
                            oi.offerInstanceId.ToString()));
                }

                if (oi.visibilityDate > DateTime.UtcNow)
                {
                    if (!userHasStagingAccess)
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_OFFER_NOT_VISIBLE,
                            XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                            string.Format(
                                "OfferInstanceId '{0}' has Offer.Media which with a visibilityDate in the future, and so cannot be purchased.",
                                oi.offerInstanceId.ToString()));
                    }
                    else
                    {
                        isEditorialPurchase = true;
                    }
                }
            }
        }

        /// <summary>
        /// Return migration offer info for a given subscription offer and target locale
        /// </summary>
        public static HResult GetMigrationOfferInfo(Guid offerId, string legalLocale, out Guid migrationOfferId, out Guid migrationBillingOfferId)
        {
            migrationOfferId = Guid.Empty;
            migrationBillingOfferId = Guid.Empty;

            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                HResult hr = HResult.E_UNEXPECTED;

                c.StoredProc = "dbo.GetMigrationOfferInfo";

                c.AddParameter(ParameterDirection.ReturnValue, "@hr", hr);
                c.AddParameter("@offerId", offerId);
                c.AddParameter("@legalLocale", legalLocale);

                using (SqlDataReader reader = c.Execute())
                {
                    if (reader.Read())
                    {
                        migrationOfferId = reader.GetGuid(reader.GetOrdinal("migrationOfferId"));
                        migrationBillingOfferId = reader.GetGuid(reader.GetOrdinal("migrationBillingOfferId"));
                    }
                }

                hr = (uint)c.GetIntParameter("@hr");

                return hr;
            }
        }

        public static void OnFlushCache(object o, EventArgs e)
        {
            LoadMediaTypesFromCatalog();
        }

        public static void OnControlRequest(object o, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();

            switch (args.Command)
            {
            case "help":
                string helpText =
                    "CatalogUtil help\r\n" +
                    "  DumpMediaTypes -- display the media type information loaded from catalog\r\n" +
                    "  LoadMediaTypes -- reload the valid media type information from catalog\r\n" +
                    "\r\n";
                XomControlConnection.SendMessage(helpText, args.RequestId);
                args.Handled = true;
                break;

            case "dumpmediatypes":
                StringBuilder sb = new StringBuilder();
                sb.Append(string.Format("    {0,-10}  {1,-40}  {2,-20}  {3,-10}  {4,-13}\r\n", "Media Type", "Name", "Media Class", "Consumable", "Repurchasable"));
                sb.Append("    ----------  ----------------------------------------  --------------------  ----------  -------------\r\n");
                foreach (MediaTypeInfo mti in _allMediaTypes.Values)
                {
                    sb.Append(string.Format("    {0,10}  {1,-40}  {2,20}  {3,10}  {4,13}\r\n", mti.Id, mti.Name, mti.Class.ToString(), IsConsumableMediaType(mti.Id), IsRepurchasableMediaType(mti.Id)));
                }
                sb.Append("\r\n");
                XomControlConnection.SendMessage("MediaTypes:\r\n" + sb.ToString(), args.RequestId);
                args.Handled = true;
                break;

            case "loadmediatypes":
                LoadMediaTypesFromCatalog();
                int numMusic = 0;
                int numVideo = 0;
                int numGame = 0;
                int numPointsBundle = 0;
                int numUnclassified = 0;
                foreach (MediaTypeInfo mti in _allMediaTypes.Values)
                {
                    switch (mti.Class)
                    {
                    case MediaClassEnum.Music:
                        numMusic++;
                        break;
                    case MediaClassEnum.Video:
                        numVideo++;
                        break;
                    case MediaClassEnum.Game:
                        numGame++;
                        break;
                        case MediaClassEnum.PointsBundle:
                        numPointsBundle++;
                        break;
                    default:
                        numUnclassified++;
                        break;
                    }
                }
                XomControlConnection.SendMessage(string.Format("LoadMediaTypes loaded MediaTypes: music: {0}, video: {1}, game: {2}, unclassified: {3} (total: {4})\r\n", numMusic, numVideo, numGame, numUnclassified, _allMediaTypes.Values.Count), args.RequestId);
                args.Handled = true;
                break;
            }
        }

        // -------------------------------------------------------------------------
        // OnSettingsChanged - handles change notifications from Config. We need to build
        // our new list of music, video, game, and consumable media types.
        // -------------------------------------------------------------------------
        public static void OnSettingsChanged(object sender, SettingChangeEventArgs eventArgs)
        {
            switch (eventArgs.Setting)
            {
            case Setting.catalog_musicMediaTypes:
                _musicMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_videoMediaTypes:
                _videoMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_gameMediaTypes:
                _gameMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_consumableMediaTypes:
                _consumableMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_repurchasableMediaTypes:
                _repurchasableMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_pointsBundleMediaTypes:
                _pointsBundleMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_subscriptionMediaTypes:
                _subscriptionMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;

            case Setting.catalog_appMediaTypes:
                _appMediaTypes = InitMediaClassFromSettingValue(eventArgs.ValueNew);
                break;
            }
        }

        /// <summary>
        /// Returns the UODB offerId given catalog OfferInstanceId.
        /// Looks up SubscriptionOfferMapping
        /// </summary>
        /// <returns>UODB OfferId</returns>
        public static ulong GetLegacyOfferIdFromOfferInstanceId(Guid offerInstanceId)
        {

            ulong liveOfferId=0;

            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                c.StoredProc = "dbo.GetLegacyOfferIdFromOfferInstance";

                c.AddParameter("@offerInstanceId", offerInstanceId);
                using (SqlDataReader r = c.Execute())
                {
                    if (r.Read())
                    {
                        liveOfferId = (ulong)r.GetInt64(r.GetOrdinal("liveOfferId"));
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_OFFERING_GET_LEGACYOFFER_ERROR,
                                               XEvent.Id.COMMON_CATALOG_1,
                                               String.Format("Error retrieving legacy offerId for offerInstance {0}", offerInstanceId.ToString()));

                    }
                }
            }

            return liveOfferId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\dmp.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Transactions;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.finbus;
using xonline.common.mgmt;
using xonline.common.musicnet;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.trackedapi;
using xonline.common.user;
using xonline.common.utilities;
using xonline.common.utilities2;

using DMPWSDL;
using Microsoft.Webstore.WstClient;

using musicnet.wsdl.client.ecomm;

[assembly: XomAreaDefinition(XomAreaName.dmplog)]
[assembly: XomAreaDefinition(XomAreaName.dmptrace)]

namespace xonline.common.billing
{
    // the following struct-like classes are used only
    // for passing data around between functions

    public class DMPPendingPurchaseDetails
    {
        public Guid TrackingGuid;
        public string ConfirmationID;
        public DateTime ConfirmationDate;
    }

    public class DMPOfferDetails
    {
        public ulong OfferID;
        public string Title;
        public int Price;
        public string RevenueSKU;
        public string ItemCategory;
        public int CampaignID;
    }

    public class DMPRewardDetails
    {
        public int PointsRewarded;
        public int RewardLifetime;
        public string PromoSKU;
        public int CampaignID;
        public int AcquisitionType;
        public string AcquisitionTitle;
    }

    public class DMPCancelablePurchase
    {
        public ulong UserPuid;
        public ulong UserPassportPuid;
        public byte CountryID;
        public Guid TransactionGuid;
        public string AlternateUrl;
    }

    public class DMPRewardRetry
    {
        public ulong UserPuid;
        public ulong UserPassportPuid;
        public byte CountryID;
        public int CultureID;
        public Guid TransactionGuid;
        public string AlternateUrl;
        public int RewardID;
    }

    public class MediaInstanceInfo
    {
        public Guid mediaId;
        public Guid mediaInstanceId;
        public bool isAcquirable;
        public int licenseTypeId;
        public int licenseClassId;
        public int mediaTypeId;
        public int geoCheckPolicy;
        public DateTime visibilityDate;
        public int visibilityStatusId;
        public int assetId;
        public int assetQuantity;
        public int assetTitleId;
        public Guid mediaContributorId;
        public string mediaTitle;
        //public string revenueSku;

        public bool HasAssetInfo
        {
            get
            {
                return (assetId != 0 && assetQuantity != 0 && assetTitleId != 0);
            }
        }
    }

    public class OfferInfo
    {
        public Guid offerInstanceId;
        public Guid offerId;
        public int offerType;
        public Guid mediaId;
        public DateTime startDateTime;
        public int paymentTypeId;
        public decimal currencyPrice;
        public string currencyCode;
        public int taxTypeId;
        public decimal taxAmount; // not returned by Catalog; determined by SCS if applicable
        public string billingOfferId;

        public int mediaTypeId;
        public string mediaType;
        public string reducedTitle;
        public int geoCheckPolicy;
        public DateTime visibilityDate;
        public int visibilityStatusId;
        public int mediaVisibilityStatusId;

        public bool wholesalePriceLoaded;
        public decimal wholesalePrice;
        public string wholesaleCurrency;

        // this is joined to wholesale price. If wholesalePriceLoaded == true, then sugested retial will also be there
        public decimal suggestedRetailPrice;


        public int retailPricePoints;
        public decimal retailPrice;
        public string retailCurrency;

        public int pricingRuleId;
        public string promotionId; // this string is null if there is no promotion, or a guid string if there was one
        public string sku;

        public bool isSyncCastContent;  // whether this content is hosted by SyncCast
        public bool isMusicNetContent;  // whether this content is hosted by MusicNet
        public string mnetId;           // only meaningful if mediaInstance is music

        public List<MediaInstanceInfo> mediaInstanceInfos;

        public List<OfferRelationship> offerRelationshipsTo;

        public List<OfferRelationship> offerRelationshipsFrom;

        public string serviceComponentId=string.Empty;

        public int subscriptionDuration;

        public int subscriptionDurationType;

        /// <summary>
        /// Use the title id to determine if a subscription is a zune subscription
        /// </summary>
        public bool IsZuneSubscription
        {
            get
            {
                return (mediaTypeId == MediaTypeInfo.GameSubscription && titleId == XOn.CRUX_TITLE_ID);
            }
        }

        public uint titleId = 0;

        public int tierId;


        public uint ValidateSubscriptionRenewalPath(ulong userPuid, Guid convertFromCatalogOfferID, int subscriptionStatusId, out int relationshipTypeId)
        {
            relationshipTypeId = 0;

            HResult hr = HResult.S_OK;

            if (subscriptionStatusId >= (int)XeSubscriptionUtil.SubscriptionStatus.Renewed)
            {
                //status of 10 and above are internal and invalid for renewal
                hr = HResult.XONLINE_E_OFFERING_INVALID_RENEWAL;
            }

            if (subscriptionStatusId == (int)XeSubscriptionUtil.SubscriptionStatus.Canceled)
            {
                hr = HResult.XONLINE_E_ACCOUNTS_ALREADY_DEPROVISIONED;
            }

            if (offerType == OfferType.SubscriptionTrial)
            {
                hr = HResult.XOFF_E_INELIGIBLE_FOR_OFFER;
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_141, "ValidateSubscriptionRenewalPath: cannot renew into trial offer!  offerInstanceId: " + offerInstanceId.ToString());
            }

            if (offerRelationshipsFrom == null || offerRelationshipsFrom.Count == 0)
            {
                hr = HResult.XONLINE_E_OFFERING_INVALID_RENEWAL;
            }

            OfferRelationship[] renewalOfferPaths = Array.FindAll<OfferRelationship>
                (
                    this.offerRelationshipsFrom.ToArray(), delegate(OfferRelationship offerRelationship)
                     {
                         return (
                                   offerRelationship.offerId == convertFromCatalogOfferID
                                   &&
                                   (
                                        offerRelationship.offerRelationshipTypeId==OfferRelationShipType.ConvertPlusProRate
                                        || offerRelationship.offerRelationshipTypeId== OfferRelationShipType.ConvertPlusTimeExtend
                                   )
                                );
                     }
                );

            if (renewalOfferPaths == null)
            {
                hr = HResult.XONLINE_E_OFFERING_INVALID_RENEWAL;
            }
            if (renewalOfferPaths.Length == 0)
            {
                hr = HResult.XONLINE_E_OFFERING_INVALID_RENEWAL;
            }
            else if (renewalOfferPaths.Length > 1)
            {
                hr = HResult.XONLINE_E_OFFERING_MULTIPLE_RENEWAL;
            }
            else
            {
                relationshipTypeId = renewalOfferPaths[0].offerRelationshipTypeId;

                Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_LOW,
                   "[Offer] Validated renewal path for 0x" + userPuid.ToString("x")
                       + " from offerId " + convertFromCatalogOfferID.ToString()
                       + " to renewal offer" + renewalOfferPaths[0].offerId.ToString()
                       + " using relationShipTypeId " + relationshipTypeId.ToString());

                hr = HResult.S_OK;
            }

            return hr;
        }


        /// <summary>
        /// Returns if a subscription auto renews/not
        /// </summary>
        /// <returns></returns>
        public bool IsSubscriptionAutoRenew()
        {
            decimal relatedOfferprice=0;

            Guid renewalOfferId = Guid.Empty;

            return IsSubscriptionAutoRenew(out relatedOfferprice, out renewalOfferId);
        }

        /// <summary>
        /// Gets the subscription Auto Renew offer price.Return false if there is not Auto renew link.
        /// </summary>
        /// <returns></returns>
        public bool IsSubscriptionAutoRenew(out decimal renewalPrice,out Guid renewalOfferId)
        {
            renewalPrice = 0;
            renewalOfferId = Guid.Empty;


            if(offerRelationshipsTo == null || offerRelationshipsTo.Count==0)
            {
                return false;
            }

            OfferRelationship[] renewalOfferPaths = Array.FindAll<OfferRelationship>(this.offerRelationshipsTo.ToArray(), delegate(OfferRelationship offerRelationship) { return offerRelationship.offerRelationshipTypeId == OfferRelationShipType.DefaultRenew; });
            bool retValue = false;
            if (renewalOfferPaths.Length == 1)
            {
                renewalPrice = renewalOfferPaths[0].relatedOfferPrice;

                renewalOfferId = renewalOfferPaths[0].relatedOfferId;

                retValue = true;
            }
            else if (renewalOfferPaths == null || renewalOfferPaths.Length == 0)
            {
                retValue = false;
            }
            else if (renewalOfferPaths.Length > 1)
            {
                //TODO raise error for more than one default renewal
                retValue = false;
            }
            return retValue;
        }


        public decimal GetSubscriptionDiscountedPrice
            (
             Guid existingCatalogOfferId
            ,int monthsExtended
            ,decimal creditValue
            ,out decimal discountAmount
            ,out int actualMonthExtended
            ,out int relationshipType
            )
        {

            OfferRelationship renewalOfferPath = Array.Find<OfferRelationship>(this.offerRelationshipsFrom.ToArray(), delegate(OfferRelationship offerRelationship) { return (offerRelationship.offerId == existingCatalogOfferId ); });

            discountAmount = 0;

            actualMonthExtended = 0;


            relationshipType = renewalOfferPath.offerRelationshipTypeId;

             //If we time extending then discount is 0
            if (relationshipType == OfferRelationShipType.ConvertPlusTimeExtend)
            {
                discountAmount = 0;
                actualMonthExtended = monthsExtended;
            }
            //If we are pro-rating then time credit is 0
            else if (relationshipType == OfferRelationShipType.ConvertPlusProRate)
            {
                //make sure that the credit value is not negative.If it is then raise an exception for action
                if (creditValue < 0)
                {
                    throw new XRLException(HResult.XONLINE_E_BILLING_BAD_CREDIT_VALUE,
                    XEvent.Id.SUBSCRIPTION_BAD_CREDITVALUE_ERROR,
                    string.Format("Negative creditvalue returned for the user. Please inspect the credit values for user's country"));
                }
                discountAmount = (decimal)(monthsExtended * creditValue);
                actualMonthExtended = 0;
            }

            //Discount must not be greater than the current offer price.We cap it if this is the case
            if (discountAmount > this.currencyPrice)
            {
                discountAmount = this.currencyPrice;
            }
            //Return actual price
            return (this.currencyPrice - discountAmount);
        }
    }

    public class MediaPurchaseInfo
    {
        public Guid OfferInstanceId;
        public decimal retailPrice;
        public string retailPriceCurrency;
    }

    public class OfferRelationship
    {
        public Guid offerId;
        public Guid relatedOfferId;
        public int offerRelationshipTypeId;
        public decimal relatedOfferPrice=0;
    }

    // the following enum is used for tracking the type of client originating DMP purchases
    public enum DMPPurchaseOrigin
    {
        Xbox360                 = 1,    // purchase originated from an Xbox 360 console
        ZuneDorado              = 2,    // purchase originated from the Zune Dorado client
        GamesForWindows         = 3,    // purchase originated from a G4W client
        XboxDotCom              = 32,   // purchase originated from Xbox.com web site
        ZuneDotNet              = 33,   // purchase originated from Zune.net web site
        GamesForWindowsDotCom   = 34,   // purchase originated from G4W.com web site
        ZuneMobile              = 64,   // purchase originated from a Zune mobile client
        ZuneDevice              = 65,   // purchase originated from a Zune device
        MediaCenter             = 96,   // purchase originated from a Media Center client
        LicenseTransfer         = 128,  // purchase represents a license transfer
        WindowsPhone            = 160   // purchase originated from a Windows Phone
    }

    public class DMPClient:IDisposable
    {
        private byte m_countryID;
        private DMPTransactionWrapper m_dmpTransaction;
        private static volatile bool m_initControl = false;

        public static int MaxItemCategoryLength

        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_maxItemCategoryLength);
            }
        }

        public static int MaxItemTitleLength

        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_maxItemTitleLength);
            }
        }

        public static int MaxAcquisitionTitleLength
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_maxAcquisitionTitleLength);
            }
        }


        public static bool AutoRegisterUsers
        {
            get
            {
                return Config.GetBoolSetting(Setting.dmp_autoRegisterUsers);
            }
        }

        public static bool AllowUrlOverride
        {
            get
            {
                return Config.GetBoolSetting(Setting.dmp_allowUrlOverride);
            }
        }


        public static int UserCommerceDbPartitionCount
        {
            get
            {
                using(WstConnection c = new WstConnection(ConfigUtil.GetUserCommerceWebstoreApp()))
                {
                    c.Open();

                    return c.SqlPartitions.Count;
                }
            }
        }
        public DMPClient(byte countryID)
        {
            m_countryID = countryID;
            m_dmpTransaction = new DMPTransactionWrapper();
        }

        public enum DMPTransactionStatus
        {
            PrePending              = -1,   // this state is used during RecordFinBusintent
            Pending                 = 1,    // this state is used while making the call to SCS
            Success                 = 2,    // the API call succeeded
            Failed                  = 3,    // the API call failed
            Canceled                = 5,    // the API call was cancelled successfully
            CancelFailed            = 6,    // the API call succeeded and later a cancel attempt was made, but that failed
            RetryFailed             = 7,    // a retry attempt was made, but it failed (eg SCS::PurchaseItem)
            MusicPurchasePending    = 8,    // points have been deducted, now we are going to call MusicNet
            MusicPurchaseFailed     = 10,   // points have been deducted, but the MusicNet call failed
        }

        public enum DMPPurchaseType
        {
            XboxLiveOffers          = 1,    // defines a purchase transaction consisting only of Xbox Live offers
            MusicNetMTVContent      = 2,    // defines a purchase transaction consisting only of MusicNet tracks/albums
            SyncCastWMISContent     = 3,    // defines a purchase transaction consisting only of SyncCast videos
            CatalogDBOffers         = 4,    // defines a purchase transaction consisting only of CatalogDB media offers that are not music
            CatalogDBMusicOffers    = 5     // defines a purchase transaction consisting only of CatalogDB media offers, some of which are music
        }

        public enum DMPOrderIDType
        {
            DMPTrackingGuid         = 1,    // represents the guid that is created for all dmp transactions
            MTVExternalOrderID      = 2     // represents the ID that MTV generates when making a call into wcmusic.OrderItems
        }

        public static char [] g_unsafeDMPCharacters = {
            '\u003B', // ;
            '\u003C', // <
            '\u003E', // >
            '\u0028', // (
            '\u0029', // )
            '\u005C', // \
            '\u0022', // "
            '\u0024', // $
            '\u0026', // &
            '\u0025'  // %
        };

        public string MakeDMPSafeString(string s, int maxChars)
        {
            if (s.Length > maxChars)
                s = s.Substring(0, maxChars);

            if (s.IndexOfAny(g_unsafeDMPCharacters) == -1)
                return s;

            StringBuilder sb = new StringBuilder(s);
            int startingIndex = 0;
            while (true)
            {
                int badCharIndex = s.IndexOfAny(g_unsafeDMPCharacters, startingIndex);
                if (badCharIndex == -1)
                    break;
                sb[badCharIndex] = ' ';
                startingIndex = badCharIndex + 1;
            }

            return sb.ToString();
        }

        public DMPPendingPurchaseDetails BeginMediaPurchase(DateTime postingDate,
            ulong userPuid, ulong userPassportPuid, ulong machinePuid, int countryID, int cultureID,
            int tierRequired, string ipAddress, bool hasMusicOffers, int storeId, byte purchaseOrigin, uint purchasingTitleID, List<OfferInfo> offers,
            string alternateDmpUrl, string alternateMusicNetUrl)
        {
            Guid trackingGuid = Guid.NewGuid();

            return BeginMediaPurchase(trackingGuid, postingDate, userPuid, userPassportPuid, machinePuid,
                countryID, cultureID, tierRequired, ipAddress, hasMusicOffers, storeId, purchaseOrigin,
                purchasingTitleID, offers, alternateDmpUrl, alternateMusicNetUrl);
        }

        public DMPPendingPurchaseDetails BeginMediaPurchase(Guid trackingGuid, DateTime postingDate,
           ulong userPuid, ulong userPassportPuid, ulong machinePuid, int countryID, int cultureID,
           int tierRequired, string ipAddress, bool hasMusicOffers, int storeId, byte purchaseOrigin, uint purchasingTitleID, List<OfferInfo> offers,
           string alternateDmpUrl, string alternateMusicNetUrl)
        {
            RecordMediaPurchaseIntent(userPuid, machinePuid, storeId, purchaseOrigin, purchasingTitleID, offers, hasMusicOffers, trackingGuid, postingDate,
                alternateDmpUrl, ipAddress, alternateMusicNetUrl);

            List<Item> dmpItems = new List<Item>();
            foreach (OfferInfo offer in offers)
            {
                if (offer.retailPricePoints > 0)
                {
                    Item dmpItem = new Item();
                    dmpItem.ExternalId = GenerateExternalCatalogID(offer.offerInstanceId, cultureID);
                    dmpItem.Title = MakeDMPSafeString(offer.reducedTitle, MaxItemTitleLength);
                    dmpItem.Price = offer.retailPricePoints;
                    dmpItem.SKU = offer.sku;
                    dmpItem.ItemCategory = offer.mediaType;

                    dmpItems.Add(dmpItem);
                }
            }

            if (dmpItems.Count == 0)
            {
                DMPPendingPurchaseDetails details = new DMPPendingPurchaseDetails();
                details.TrackingGuid = trackingGuid;
                details.ConfirmationID = string.Empty;
                details.ConfirmationDate = postingDate;

                return details;
            }

            TransactionContext context = new TransactionContext();
            context.SellingPartnerId = m_dmpTransaction.TenantID;
            context.ExternalReferenceId = trackingGuid.ToString();
            context.PostingDate = postingDate;
            context.ClientAddress = ipAddress;
            context.CampaignId = -1;

            return TryPurchaseItem(trackingGuid, userPuid, userPassportPuid, dmpItems.ToArray(), context);
        }

        public DMPPendingPurchaseDetails TryPurchaseItem(Guid trackingGuid, ulong userPuid,
            ulong userPassportPuid, Item [] items, TransactionContext context)
        {
            Receipt receipt = new Receipt();

            try
            {
                PurchaseItem(trackingGuid, userPassportPuid, items, context, out receipt);
            }
            catch (DMPException e)
            {
                HResult hr = BillingProviderException.ToHResult(e, HResult.XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR);

                TransactionOptions txnOpts = new TransactionOptions();
                txnOpts.IsolationLevel = System.Transactions.IsolationLevel.RepeatableRead;

                using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew, txnOpts))
                {
                    RecordPurchaseFailure(userPuid, trackingGuid, (uint) HResult.E_FAIL, e.ErrorInfo.Error, e.ErrorXml, DateTime.UtcNow);
                    FinBusItem.ClearFinBusItemPreIntent(userPuid, trackingGuid);
                    TrackedApiCall.RecordCommerceActionResult(trackingGuid, userPuid, hr, e.Message, null);
                    ts.Complete();
                }

                throw;
            }
            catch (Exception e)
            {
                HResult hr = HResult.E_FAIL;
                if ( e is ExceptionWithHResult )
                {
                    hr = ((ExceptionWithHResult)e).HResult;
                }

                if (FastFailHelper.ConsiderExceptionAsTimeout(e))
                {
                    // something could have happened, so we have to audit
                    AuditStream.Write(
                        userPuid, AuditSubsystem.DMP, "PurchaseItem", e.Message,
                        new AuditParam("trackingGuid", trackingGuid.ToString()),
                        new AuditParam("userPassportPuid", userPassportPuid.ToString("x")),
                        new AuditXmlParam("itemsXml", DMPClient.AuditItems(items))
                    );
                }

                // assume the worst and try cancelling the transaction
                TryCancelPurchase(userPuid, userPassportPuid, trackingGuid);

                throw;
            }

            DMPPendingPurchaseDetails pendingDetails = new DMPPendingPurchaseDetails();
            pendingDetails.TrackingGuid = trackingGuid;
            pendingDetails.ConfirmationDate = receipt.ConfirmationDate;
            pendingDetails.ConfirmationID = receipt.ConfirmationId;

            return pendingDetails;
        }

        public class GamertagChangeInfo
        {
            public string oldGamertag;
            public string newGamertag;
        }

        public DMPPendingPurchaseDetails BeginOfferPurchase(Guid trackingGuid, ulong userPuid, ulong userPassportPuid, ulong machinePuid,
            ulong [] offerIDs, int countryID, int cultureID, int tierRequired, byte purchaseOrigin, uint purchasingTitleID)
        {
            return BeginOfferPurchase(trackingGuid, userPuid, userPassportPuid, machinePuid, offerIDs, countryID,
                cultureID, tierRequired, purchaseOrigin, purchasingTitleID, null);
        }

        public DMPPendingPurchaseDetails BeginOfferPurchase(Guid trackingGuid, ulong userPuid, ulong userPassportPuid, ulong machinePuid,
            ulong [] offerIDs, int countryID, int cultureID, int tierRequired, byte purchaseOrigin, uint purchasingTitleID, GamertagChangeInfo info)
        {
            DateTime postingDate = DateTime.UtcNow;

            DMPOfferDetails [] allDetails = GetDMPOfferDetails(offerIDs, countryID, cultureID, tierRequired);

            string alternateDmpUrl = DMPTransactionWrapper.GetSessionAlternateUrl();

            List<Item> itemsList = new List<Item>();
            foreach (DMPOfferDetails details in allDetails)
            {
                // look for non-free items that we need to charge the user for
                if (details.Price > 0)
                {
                    Item item = new Item();
                    item.ExternalId = GenerateExternalID(details.OfferID, countryID, tierRequired, cultureID);

                    string title = details.Title;
                    if (info != null)
                        title = string.Format("{0}: '{1}'-'{2}'", title, info.oldGamertag, info.newGamertag);

                    item.Title = MakeDMPSafeString(title, MaxItemTitleLength);
                    item.Price = details.Price;
                    item.SKU = details.RevenueSKU;
                    item.ItemCategory = MakeDMPSafeString(details.ItemCategory, MaxItemCategoryLength);

                    itemsList.Add(item);
                }
            }

            // in the case of a purchase request that is totally free,
            // we won't write to the transaction table at all
            if (itemsList.Count == 0)
                return null;

            TransactionContext context = new TransactionContext();
            context.SellingPartnerId = m_dmpTransaction.TenantID;
            context.ExternalReferenceId = trackingGuid.ToString();
            context.PostingDate = postingDate;
            context.ClientAddress = machinePuid.ToString("x");
            context.CampaignId = allDetails[0].CampaignID; // dholt: just send in the first item's campaignID

            RecordPurchaseIntent(userPuid, machinePuid, offerIDs, trackingGuid, postingDate, purchaseOrigin, purchasingTitleID, alternateDmpUrl);

            Item [] items = itemsList.ToArray();
            return TryPurchaseItem(trackingGuid, userPuid, userPassportPuid, items, context);
        }

        public void MoveToMusicNetPendingState(DMPPendingPurchaseDetails details, ulong userPuid,
            ulong userPassportPuid)
        {
            try
            {
                RecordMoveToMusicNetPendingState(userPuid, details.TrackingGuid,
                    details.ConfirmationID, details.ConfirmationDate);
            }
            catch (Exception e)
            {
                // if we don't record success, treat it as a failure, and try cancelling the purchase

                Xom.NtEvent(XEvent.Id.UODB_ACCESS_ERROR, e,
                    "DMPClient::RecordMoveToMusicNetPendingState failed. Will try to cancel."
                );

                TryCancelPurchase(userPuid, userPassportPuid, details.TrackingGuid);

                throw;
            }
        }

        public void CompleteGamertagPurchase(DMPPendingPurchaseDetails details, ulong userPuid, ulong userPassportPuid,
            ulong machinePuid, string newGamertag)
        {
            try
            {
                RecordGamertagPurchaseSuccess(userPuid, details.TrackingGuid, details.ConfirmationID,
                    details.ConfirmationDate, newGamertag);
            }
            catch (Exception e)
            {
                // if we don't record success, treat it as a failure, and try cancelling the purchase

                Xom.NtEvent(XEvent.Id.UODB_ACCESS_ERROR, e,
                    "DMPClient::CompleteGamertagPurchase failed. Will try to cancel."
                );

                TryCancelPurchase(userPuid, userPassportPuid, details.TrackingGuid);

                throw;
            }
        }

        public void GrantRewardOffer(ulong userPuid, ulong userPassportPuid, ulong machinePuid,
            ulong offerID, int cultureID)
        {
            int rewardID = GetRewardOfferReward(offerID);

            RewardUser(userPuid, userPassportPuid, machinePuid, rewardID, cultureID);
        }

        public void ProcessSubscriptionReward(ulong userPuid, ulong userPassportPuid, ulong machinePuid,
            ulong offerID, int countryID, int cultureID, int userTier)
        {
            int rewardID = GetSubscriptionReward(offerID, countryID, userTier);

            if (rewardID != -1)
            {
                string szLog = string.Join("|", new string []
                {
                    "XESUBREWARD",
                    machinePuid.ToString("x"),
                    userPuid.ToString("x"),
                    userPassportPuid.ToString("x"),
                    offerID.ToString("x"),
                    userTier.ToString("x"),
                    countryID.ToString("x"),
                    cultureID.ToString("x")
                });

                Xom.Trace(XomAreaName.dmptrace, LogLevel.L_NORMAL, szLog);

                RewardUser(userPuid, userPassportPuid, machinePuid, rewardID, cultureID, true);
            }
        }

        // when queueFailures=true, any failures will be "swallowed" so that the worker thread can retry
        // the reward at a later time.  when queueFailures=false, these failures cause the transaction
        // to be "closed" with a status of Fail.
        public void TryRewardUser(Guid trackingGuid, ulong userPuid, ulong userPassportPuid, int rewardID,
            int cultureID, bool queueFailures)
        {
            try
            {
                DMPRewardDetails details = GetDMPRewardDetails(rewardID, cultureID);

                if (details.RewardLifetime != 0)
                {
                    throw new XRLException(HResult.XOFF_E_INVALID_OFFER_ID, XEvent.Id.COMMON_BILLING_CODE_163,
                        "Currently DMP does not allow overriding the reward/promo point lifetime");
                }

                string acquisitionTitle = MakeDMPSafeString(details.AcquisitionTitle, MaxAcquisitionTitleLength);

                Receipt receipt;
                AddPromotionalBalance(trackingGuid, userPassportPuid, details.PointsRewarded, trackingGuid.ToString(),
                    details.PromoSKU, details.CampaignID, (short) details.RewardLifetime, acquisitionTitle,
                    details.AcquisitionType, out receipt);

                try
                {
                    RecordRewardResult(userPuid, trackingGuid, (int) DMPTransactionStatus.Success, receipt.ConfirmationId,
                        (uint) HResult.S_OK, "", "", receipt.ConfirmationDate);
                }
                catch (Exception e)
                {
                    // if this fails, do nothing--the worker threads will try to reward the user again later,
                    // and will update the reward result at that time

                    Xom.NtEvent(XEvent.Id.UODB_ACCESS_ERROR, e,
                        "DMPClient::RecordRewardResult failed. DMPQueue will retry reward later."
                    );
                }
            }
            catch (DMPException e)
            {
                if (e.ErrorInfo.CanRetry && queueFailures)
                {
                    // if DMP says we can retry later, do nothing--the worker threads will try to reward the
                    // user again later

                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "DMPClient::AddPromotionalBalance failed. DMPQueue will retry reward later."
                    );
                }
                else
                {
                    RecordRewardResult(userPuid, trackingGuid, (int) DMPTransactionStatus.Failed, "",
                        (uint) HResult.E_FAIL, e.ErrorInfo.Error, e.ErrorXml, DateTime.UtcNow);

                    throw;
                }
            }
            catch (XRLException e)
            {
                if (queueFailures)
                {
                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "DMPClient::TryRewardUser failed. DMPQueue will retry reward later."
                    );
                }
                else
                {
                    RecordRewardResult(userPuid, trackingGuid, (int) DMPTransactionStatus.Failed, "",
                        e.HResult, "XRLException", e.Message, DateTime.UtcNow);

                    throw;
                }
            }
            catch (WebException e)
            {
                if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                {
                    // we have to treat this as a success, since we can't cancel the DMP::AddPromotionalBalance call

                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "DMPClient::TryRewardUser timed-out. DMPQueue will retry reward later.");
                }
                else if (!queueFailures)
                {
                    RecordRewardResult(userPuid, trackingGuid, (int) DMPTransactionStatus.Failed, "",
                        (uint) HResult.E_FAIL, "Exception", e.Message, DateTime.UtcNow);

                    throw;
                }
                else
                {
                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "DMPClient::TryRewardUser failed. DMPQueue will retry reward later."
                    );
                }
            }
            catch (Exception e)
            {
                HResult hr = HResult.E_FAIL;
                if ( e is ExceptionWithHResult )
                {
                    hr = ((ExceptionWithHResult)e).HResult;
                }

                if (queueFailures)
                {
                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "DMPClient::TryRewardUser failed. DMPQueue will retry reward later."
                    );
                }
                else
                {
                    RecordRewardResult(userPuid, trackingGuid, (int) DMPTransactionStatus.Failed, "",
                        hr, "Exception", e.Message, DateTime.UtcNow);

                    throw;
                }
            }
        }

        public Guid RewardUser(ulong userPuid, ulong userPassportPuid, ulong machinePuid, int rewardID, int cultureID)
        {
            return RewardUser(userPuid, userPassportPuid, machinePuid, rewardID, cultureID, false);
        }

        public Guid RewardUser(ulong userPuid, ulong userPassportPuid, ulong machinePuid, int rewardID,
            int cultureID, bool queueFailures)
        {
            DateTime postingDate = DateTime.UtcNow;
            Guid trackingGuid = Guid.NewGuid();

            string alternateDmpUrl = DMPTransactionWrapper.GetSessionAlternateUrl();

            RecordRewardIntent(userPuid, machinePuid, rewardID, trackingGuid, postingDate, alternateDmpUrl);

            TryRewardUser(trackingGuid, userPuid, userPassportPuid, rewardID, cultureID, queueFailures);

            return trackingGuid;
        }

        public static string GenerateExternalID(ulong offerID, int countryID, int tierRequired, int cultureID)
        {
            return string.Join("-", new string[] {offerID.ToString("x"),
                countryID.ToString("d"),
                tierRequired.ToString("d"),
                cultureID.ToString("d")});
        }

        public static string GenerateExternalMusicID(string mnetId, PurchaseItemType itemType,
            int tierRequired, int countryID, int cultureID)
        {
            return string.Join("-", new string []
            {
                mnetId,
                itemType == PurchaseItemType.Track ? "T" : "A",
                tierRequired.ToString("d"),
                countryID.ToString("d"),
                cultureID.ToString("d")
            });
        }

        public static string GenerateExternalCatalogID(Guid offerInstanceId, int cultureID)
        {
            string cultureCode = Culture.CultureToCode(cultureID);

            return string.Format("{0}{1}",
                offerInstanceId.ToString("N"), // we are tight on space, the N makes the guid have no dashes
                cultureCode.Replace("-", "")
                );
        }

        // note that this method will never throw an exception
        // either it will succeed or fail in cancelling the purchase, or it will do nothing at all,
        // relying on the worker threads to retry the cancel again later
        public void TryCancelPurchase(ulong userPuid, ulong userPassportPuid, Guid transactionGuid)
        {
            TransactionOptions txnOpts = new TransactionOptions();
            txnOpts.IsolationLevel = System.Transactions.IsolationLevel.RepeatableRead;

            try
            {
                Receipt receipt;

                CancelPurchaseItem(userPassportPuid, transactionGuid, out receipt);

                using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew, txnOpts))
                {
                    RecordPurchaseCancelSuccess(userPuid, transactionGuid, true, receipt.ConfirmationId, receipt.ConfirmationDate);

                    // If the original DMP PurchaseItem call  transaction was cancelled successfully,
                    // it will never be sent to FinBus for royalty/revenue reporting so if a FinBus
                    // PreIntent row exists, it should also be cleaned up now.
                    FinBusItem.ClearFinBusItemPreIntent(userPuid, transactionGuid);

                    TrackedApiCall.RecordCommerceActionResult(transactionGuid, userPuid, HResult.XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR, "PurchaseItem timed out and the transaction was successfully cancelled.", null);

                    ts.Complete();
                }
            }
            catch (DMPException e)
            {
                //
                // If the call to CancelPurchaseItem failed with a TRANSACTION_NOT_FOUND error, it is safe to
                // assume that the request timed out, thread was aborted, etc. before the original PurchaseItem
                // call was received by DMP and thus, it is safe to treat this as a successful purchase
                // cancellation and perform all of the same steps that would happen in that case.
                //
                if (e.HResult == HResult.XONLINE_E_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND)
                {
                    using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew, txnOpts))
                    {
                        RecordPurchaseCancelSuccess(userPuid, transactionGuid, false, "", DateTime.UtcNow);

                        FinBusItem.ClearFinBusItemPreIntent(userPuid, transactionGuid);

                        TrackedApiCall.RecordCommerceActionResult(transactionGuid, userPuid, HResult.XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR, "PurchaseItem was never received by DMP.", null);

                        ts.Complete();
                    }
                }
                else if (!e.ErrorInfo.CanRetry)
                {
                    using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew, txnOpts))
                    {
                        RecordPurchaseCancelFailure(userPuid, transactionGuid, (uint)HResult.E_FAIL, e.ErrorInfo.Error,
                                                    e.ErrorXml, DateTime.UtcNow);

                        FinBusItem.RecordFinBusItemIntent(userPuid, transactionGuid);

                        // treat this as a successful purchase if the call is resubmitted
                        TrackedApiCall.RecordCommerceActionResult( transactionGuid, userPuid, HResult.S_OK, string.Empty, null );

                        ts.Complete();
                    }
                }
                else
                {
                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "DMPClient::CancelPurchase failed.. DMPQueue will retry later."
                    );
                }
            }
            catch (Exception e)
            {
                // if any other kind of error is thrown, just don't touch the transaction, it will be
                // tried again later by the worker threads

                Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                    "DMPClient::CancelPurchase failed.. DMPQueue will retry cancel later."
                );
            }
        }

        public static DMPCancelablePurchase GetCancelablePurchase(int partition, uint expiredSeconds,
            uint considerFailedSeconds, out bool keepGoing)
        {
            keepGoing = false;

            // this stored procedure acquires locks and must be executed on the primary write partition
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_dmp_get_cancelable_purchase_v2";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_expired_seconds", expiredSeconds);
                ws.AddParameter("@i_consider_failed_seconds", considerFailedSeconds);

                using (WstDataReader r = ws.Execute())
                {
                    DMPCancelablePurchase cancelablePurchase = null;

                    if (r.Read())
                    {
                        cancelablePurchase = new DMPCancelablePurchase();

                        cancelablePurchase.UserPuid = (ulong) r.GetInt64(0);
                        cancelablePurchase.TransactionGuid = r.GetGuid(1);
                        cancelablePurchase.AlternateUrl = r.GetString(2);
                        if (cancelablePurchase.AlternateUrl == string.Empty)
                            cancelablePurchase.AlternateUrl = null;

                        // load the user in order to find the Passport puid and country id
                        User u = new User();
                        u.Load(cancelablePurchase.UserPuid);

                        cancelablePurchase.UserPassportPuid = u.PassportPuid;
                        cancelablePurchase.CountryID = u.CountryId;
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_164, msg);
                    }

                    if (hr == HResult.XONLINE_S_DMP_RETRY_INTERVAL_EXCEEDED)
                    {
                        keepGoing = true;
                    }

                    return cancelablePurchase;
                }
            }
        }

        public static int GetCancelablePurchaseCount(int partition, uint expiredSeconds)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_dmp_get_cancelable_purchase_count";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_expired_seconds", expiredSeconds);

                using (WstDataReader r = ws.Execute())
                {
                    int count = 0;

                    if (r.Read())
                    {
                        count = r.GetInt32(0);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_165, msg);
                    }

                    return count;
                }
            }
        }

        public static int GetRewardForRetryCount(int partition, uint expiredSeconds)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_dmp_get_reward_for_retry_count";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_expired_seconds", expiredSeconds);

                using (WstDataReader r = ws.Execute())
                {
                    int count = 0;

                    if (r.Read())
                    {
                        count = r.GetInt32(0);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_166, msg);
                    }

                    return count;
                }
            }
        }

        public static DMPRewardRetry GetRewardForRetry(int partition, uint expiredSeconds)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_dmp_get_reward_for_retry_v2";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_expired_seconds", expiredSeconds);

                using (WstDataReader r = ws.Execute())
                {
                    DMPRewardRetry retryableReward = null;

                    if (r.Read())
                    {
                        retryableReward = new DMPRewardRetry();

                        retryableReward.UserPuid = (ulong) r.GetInt64(0);
                        //retryableReward.UserPassportPuid = (ulong) r.GetInt64(1);
                        //retryableReward.CountryID = r.GetByte(2);
                        //retryableReward.CultureID = r.GetInt32(3);
                        retryableReward.RewardID = r.GetInt32(1);
                        retryableReward.TransactionGuid = r.GetGuid(2);
                        retryableReward.AlternateUrl = r.GetString(3);
                        if (retryableReward.AlternateUrl == string.Empty)
                            retryableReward.AlternateUrl = null;

                        // load the user in order to find the Passport puid, country id, and culture id
                        User u = new User();
                        u.Load(retryableReward.UserPuid);

                        retryableReward.UserPassportPuid = u.PassportPuid;
                        retryableReward.CountryID = u.CountryId;
                        retryableReward.CultureID = u.CultureId;
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_167, msg);
                    }

                    return retryableReward;
                }
            }
        }

        protected static DMPRewardDetails GetDMPRewardDetails(int rewardID, int cultureID)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_dmp_get_reward_details";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_reward_id", rewardID);
                ws.AddParameter("@i_culture_id", cultureID);

                using (WstDataReader r = ws.Execute())
                {
                    DMPRewardDetails details = new DMPRewardDetails();

                    if (r.Read())
                    {
                        details.PointsRewarded = r.GetInt32(0);
                        details.RewardLifetime = r.GetInt32(1);
                        details.PromoSKU = r.GetString(2);
                        details.CampaignID = r.GetInt32(3);
                        details.AcquisitionType = r.GetInt32(4);
                        details.AcquisitionTitle = r.GetString(5);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_168, msg);
                    }

                    return details;
                }
            }
        }

        protected static int GetRewardOfferReward(ulong offerID)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_dmp_get_reward_offer_reward";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerID);

                using (WstDataReader r = ws.Execute())
                {
                    r.Read();

                    int rewardID = r.GetInt32(0);

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_169, msg);
                    }

                    return rewardID;
                }
            }
        }

        // if there is no reward associated with the subscription, this function returns -1
        protected static int GetSubscriptionReward(ulong offerID, int countryID, int userTier)
        {
            Offer o = Offer.CreateInstance(offerID);
            return o.RewardId((byte)countryID, userTier);
        }

        internal static DMPOfferDetails [] GetDMPOfferDetails(ulong [] offerIDs, int countryID,
            int cultureID, int tierRequired)
        {
            StringBuilder offerXml = new StringBuilder();
            foreach (ulong offerID in offerIDs)
            {
                offerXml.Append(string.Format("<o>{0}</o>", (long) offerID));
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_dmp_get_offer_details";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@xml_offers", offerXml.ToString());
                ws.AddParameter("@i_offer_count", offerIDs.Length);
                ws.AddParameter("@i_country_id", countryID);
                ws.AddParameter("@i_culture_id", cultureID);
                ws.AddParameter("@i_tier_required", tierRequired);

                using (WstDataReader r = ws.Execute())
                {
                    DMPOfferDetails [] details = new DMPOfferDetails[offerIDs.Length];

                    for (int i = 0; i < offerIDs.Length; i++)
                    {
                        if (r.Read())
                        {
                            details[i] = new DMPOfferDetails();
                            details[i].OfferID = offerIDs[i];

                            details[i].Title = r.GetString(0);
                            details[i].Price = r.GetInt32(1);
                            details[i].RevenueSKU = r.GetString(2);
                            details[i].ItemCategory = r.GetString(3);
                            details[i].CampaignID = r.GetInt32(4);
                        }
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_170, msg);
                    }

                    return details;
                }
            }
        }

        public static PointsPurchaseStatus [] p_dmp_get_transaction_status(ulong userPuid,
            PointsPurchaseQuery [] queries)
        {
            StringBuilder queryXml = new StringBuilder();
            int sortPosition = 0;
            foreach (PointsPurchaseQuery query in queries)
            {
                // for now we just support querying music transaction status
                if (query.purchaseType != (ushort) DMPPurchaseType.MusicNetMTVContent)
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_171,
                        string.Format("DMPPurchaseType not supported: {0}", query.purchaseType));

                // for now we just support querying by external order id
                if (query.orderIDType != (ushort) DMPOrderIDType.MTVExternalOrderID)
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_172,
                        string.Format("DMPOrderIDType not supported: {0}", query.orderIDType));

                queryXml.Append(string.Format(
                    "<query purchaseType=\"{0}\" orderIDType=\"{1}\" orderID=\"{2}\" sortPosition=\"{3}\"/>",
                    query.purchaseType, query.orderIDType, query.orderID, sortPosition
                    ));

                sortPosition++;
            }

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_get_transaction_status";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@xml_queries", queryXml.ToString());

                using (WstDataReader r = ws.Execute())
                {
                    PointsPurchaseStatus [] statuses = new PointsPurchaseStatus[queries.Length];

                    for (int i = 0; i < queries.Length; i++)
                    {
                        r.Read();

                        statuses[i] = new PointsPurchaseStatus();

                        statuses[i].orderID = r.GetString(0);
                        statuses[i].status = r.GetInt32(1);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_173, msg);
                    }

                    return statuses;
                }
            }
        }

        protected static void RecordMediaPurchaseIntent(ulong userPuid, ulong machinePuid, int storeId, byte purchaseOrigin, uint purchasingTitleId,
            List<OfferInfo> infos, bool hasMusicOffers, Guid trackingGuid, DateTime postingDate,
            string alternateDmpUrl, string ipAddress, string alternateMusicNetUrl)
        {
            // <item oid="AF8AD20D-905A-4f79-ADF0-51048BD2A52B" oiid="AF8AD20D-905A-4f79-ADF0-51048BD2A52B" retailPoints="70" retailUSD="1.00" wholesaleUSD="0.70" pricingRuleId="24"/>

            StringBuilder itemsXml = new StringBuilder();
            foreach (OfferInfo info in infos)
            {
                itemsXml.Append(string.Format(
                    "<item oid=\"{0}\" oiid=\"{1}\" mediaId=\"{2}\" mediaTypeId=\"{3}\" retailPoints=\"{4}\" retailPrice=\"{5}\" retailCurrency=\"{6}\" wholesalePrice=\"{7}\" wholesaleCurrency=\"{8}\" pricingRuleId=\"{9}\"",
                    info.offerId,
                    info.offerInstanceId,
                    info.mediaId,
                    info.mediaTypeId,
                    info.retailPricePoints,
                    info.retailPrice,
                    info.retailCurrency,
                    info.wholesalePrice,
                    info.wholesaleCurrency,
                    info.pricingRuleId
                    ));

                if (info.promotionId != null)
                {
                    itemsXml.Append(string.Format(" promotionId=\"{0}\"", info.promotionId));
                }

                itemsXml.Append("/>");
            }

            string offerInfoXml;
            string assetXml;
            DMPClient.GenerateOfferAssetXml(infos, out offerInfoXml, out assetXml);

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_media_purchase_intent";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);

                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@ti_has_music_offers", hasMusicOffers ? 1 : 0);
                ws.AddParameter("@i_store_id", storeId);
                ws.AddParameter("@xml_items", itemsXml.ToString());
                ws.AddParameter("@xml_assets", assetXml);
                ws.AddParameter("@dt_posting_date", postingDate);
                ws.AddParameter("@vc_alternate_dmp_url", alternateDmpUrl != null ? alternateDmpUrl : string.Empty);
                ws.AddParameter("@vc_external_id", trackingGuid.ToString());
                ws.AddParameter("@vc_ip_address", ipAddress);
                ws.AddParameter("@vc_alternate_musicnet_url", alternateMusicNetUrl != null ? alternateMusicNetUrl : string.Empty);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                if ( purchaseOrigin != 0 )
                {
                    ws.AddParameter("@ti_purchase_origin", purchaseOrigin);
                }

                ws.AddParameter("@i_purchasing_title_id", purchasingTitleId);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_175, msg);
                }
            }
        }

        public static bool IsDuplicateExternalOrderId(ulong userPuid, string externalOrderID)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_check_existence_external_id";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@vc_external_id", externalOrderID);
                ws.ExecuteNonQuery();

                int ret = ws.GetIntParameter("@ret");

                return ws.GetIntParameter("@ret") == 1;
            }
        }

        protected static void RecordPurchaseIntent(ulong userPuid, ulong machinePuid, ulong [] offerIDs, Guid trackingGuid,
            DateTime postingDate, byte purchaseOrigin, uint purchasingTitleID, string alternateUrl)
        {
            StringBuilder offerXml = new StringBuilder();
            foreach (ulong offerID in offerIDs)
            {
                offerXml.Append(string.Format("<o>{0}</o>", (long) offerID));
            }

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_purchase_intent";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@xml_offers", offerXml.ToString());
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@dt_posting_date", postingDate);
                ws.AddParameter("@vc_alternate_url", alternateUrl != null ? alternateUrl : string.Empty);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                if ( purchaseOrigin != 0 )
                {
                    ws.AddParameter("@ti_purchase_origin", purchaseOrigin);
                }

                if ( purchasingTitleID != 0 )
                {
                    ws.AddParameter("@i_purchasing_title_id", purchasingTitleID);
                }

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_176, msg);
                }
            }
        }

        protected static void RecordRewardIntent(ulong userPuid, ulong machinePuid, int rewardID, Guid trackingGuid,
            DateTime postingDate, string alternateUrl)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_reward_intent";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@i_reward_id", rewardID);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@dt_posting_date", postingDate);
                ws.AddParameter("@vc_alternate_url", alternateUrl != null ? alternateUrl : string.Empty);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_177, msg);
                }
            }
        }

        public static void GenerateOfferAssetXml(List<OfferInfo> infos, out string offers,
            out string assets)
        {
            StringBuilder offerXml = new StringBuilder();
            StringBuilder assetXml = new StringBuilder();
            foreach (OfferInfo offer in infos)
            {
                bool isPPV = false;

                if ( offer.mediaInstanceInfos != null )
                {
                    foreach (MediaInstanceInfo mediaInstanceInfo in offer.mediaInstanceInfos)
                    {
                        if ( CatalogUtil.IsGameConsumableMediaType(mediaInstanceInfo.mediaTypeId) )
                        {
                            if ( !mediaInstanceInfo.HasAssetInfo )
                            {
                                throw new XRLException(
                                    HResult.XONLINE_E_OFFERING_OFFER_MISCONFIGURED,
                                    XEvent.Id.PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION,
                                    string.Format("GenerateOfferAssetXml: offerId: {0} is of type InGameConsumable but no asset information was returned from GetOfferPurchaseInfo.  Verify offer is correctly configured in EMS Catalog!", offer.offerId.ToString()));
                            }

                            assetXml.Append(string.Format(
                                "<item assetId=\"{0}\" quantity=\"{1}\" titleID=\"{2}\"/>",
                                mediaInstanceInfo.assetId, mediaInstanceInfo.assetQuantity, mediaInstanceInfo.assetTitleId));
                        }

                        if ( mediaInstanceInfo.licenseClassId == (int) LicenseClassEnum.PPV )
                        {
                            isPPV = true;
                        }
                    }
                }

                offerXml.Append(string.Format("<item oiid=\"{0}\" oid=\"{1}\" offerMediaTypeId=\"{2}\" offerMediaId=\"{3}\" isPPV=\"{4}\"/>",
                    offer.offerInstanceId.ToString(), offer.offerId.ToString(), offer.mediaTypeId.ToString("d"), offer.mediaId.ToString(), isPPV ? 1 : 0));
            }

            offers = offerXml.ToString();
            assets = assetXml.ToString();
        }

        public static void RecordMediaAndMusicPurchaseSuccess(ulong userPuid, ulong machinePuid,
            Guid trackingGuid, List<OfferInfo> offerInfos)
        {
            RecordMediaPurchaseSuccess(userPuid, machinePuid, trackingGuid, "", DateTime.UtcNow,
                true, offerInfos);
        }

        public static void RecordMediaPurchaseSuccess(ulong userPuid, ulong machinePuid,
            Guid trackingGuid, string confirmationID, DateTime transactionEnd, List<OfferInfo> offerInfos)
        {
            /// <summary>
            /// This is User Story 136136 - Mainline Token || Points purchase - FinBus integration with RecordMediaPurchaseSuccess
            /// Pattern is as follows
            /// 1. Create Transaction Scope
            ///    a. Call method-to-integrate with FinBus
            ///    b. Call static RecordFinBusItemIntent to change staus of FinBus item to 'Pending' and get the desired finBusItem
            /// 2. Commit Transaction
            /// </summary>
            TransactionOptions txnOpts = new TransactionOptions();
            txnOpts.IsolationLevel = System.Transactions.IsolationLevel.RepeatableRead;

            using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew, txnOpts))
            {
                RecordMediaPurchaseSuccess(userPuid, machinePuid, trackingGuid, confirmationID, transactionEnd, false, offerInfos);
                FinBusItem.RecordFinBusItemIntent(userPuid, trackingGuid);
                TrackedApiCall.RecordCommerceActionResult(trackingGuid, userPuid, HResult.S_OK, string.Empty, null);
                ts.Complete();
            }
        }

        protected static void RecordMediaPurchaseSuccess(ulong userPuid, ulong machinePuid,
            Guid trackingGuid, string confirmationID, DateTime transactionEnd, bool hasMusicOffers,
            List<OfferInfo> offerInfos)
        {
            string offers;
            string assets;
            GenerateOfferAssetXml(offerInfos, out offers, out assets);

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_media_purchase_success";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@vc_confirmation_id", confirmationID);
                ws.AddParameter("@dt_transaction_end", transactionEnd);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@ti_has_music_offers", hasMusicOffers ? 1 : 0);
                ws.AddParameter("@xml_offers", offers);
                ws.AddParameter("@xml_assets", assets);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_180, msg);
                }
            }
        }

        public static void RecordMediaPurchasesAndAssets(Guid trackingGuid, ulong userPuid, ulong machinePuid,
            List<OfferInfo> offerInfos, DateTime transactionEnd)
        {
            string offers;
            string assets;
            GenerateOfferAssetXml(offerInfos, out offers, out assets);

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_xbos_record_media_purchases_and_assets";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@dt_posting_date", transactionEnd);
                ws.AddParameter("@xml_offers", offers);
                ws.AddParameter("@xml_assets", assets);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_178, msg);
                }
            }
        }

        protected static void RecordMoveToMusicNetPendingState(ulong userPuid, Guid trackingGuid,
            string confirmationID, DateTime transactionEnd)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_move_to_musicnet_pending_state";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@vc_confirmation_id", confirmationID);
                ws.AddParameter("@dt_transaction_end", transactionEnd);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_179, msg);
                }
            }
        }

        protected static void RecordGamertagPurchaseSuccess(ulong userPuid, Guid trackingGuid,
             string confirmationID, DateTime transactionEnd, string newGamertag)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_gamertag_purchase_success";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@vc_confirmation_id", confirmationID);
                ws.AddParameter("@dt_transaction_end", transactionEnd);
                ws.AddParameter("@vc_new_gamertag", newGamertag);
                ws.AddParameter("@bi_user_puid", userPuid);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_181, msg);
                }

                AuditStream.Write(userPuid, AuditSubsystem.DMP, ws, string.Empty);
            }

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_purchase_success";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@vc_confirmation_id", confirmationID);
                ws.AddParameter("@dt_transaction_end", transactionEnd);
                ws.AddParameter("@i_status_id", 2); // DMPTransactionStatus.Success
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_181, msg);
                }

                AuditStream.Write(userPuid, AuditSubsystem.DMP, ws, string.Empty);
            }

            TrackedApiCall.RecordCommerceActionResult(trackingGuid, userPuid, HResult.S_OK, string.Empty, null);
        }

        protected static void RecordPurchaseCancelSuccess(ulong userPuid, Guid trackingGuid,
            bool transactionFound, string confirmationID, DateTime transactionEnd)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_purchase_cancellation_success";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@i_transaction_found", transactionFound ? 1 : 0);
                ws.AddParameter("@vc_confirmation_id", confirmationID);
                ws.AddParameter("@dt_transaction_end", transactionEnd);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_182, msg);
                }
            }
        }

        protected static void RecordPurchaseCancelFailure(ulong userPuid, Guid trackingGuid, HResult hresult,
            string errorCode, string errorXML, DateTime transactionEnd)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_purchase_cancellation_failure";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@i_hresult", hresult);
                ws.AddParameter("@vc_error_code", errorCode);
                ws.AddParameter("@vc_error_xml", errorXML);
                ws.AddParameter("@dt_transaction_end", transactionEnd);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_183, msg);
                }
            }
        }

        protected static void RecordPurchaseFailure(ulong userPuid, Guid trackingGuid, HResult hresult,
            string errorCode, string errorXML, DateTime transactionEnd)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_purchase_failure";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@i_hresult", hresult);
                ws.AddParameter("@vc_error_code", errorCode);
                ws.AddParameter("@vc_error_xml", errorXML);
                ws.AddParameter("@dt_transaction_end", transactionEnd);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_184, msg);
                }
            }
        }

        protected static void RecordRewardResult(ulong userPuid, Guid trackingGuid, int statusID, string confirmationID,
            HResult hresult, string errorCode, string errorXML, DateTime confirmationDate)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_dmp_record_reward_result";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@i_status_id", statusID);
                ws.AddParameter("@vc_confirmation_id", confirmationID);
                ws.AddParameter("@i_hresult", hresult);
                ws.AddParameter("@vc_error_code", errorCode);
                ws.AddParameter("@vc_error_xml", errorXML);
                ws.AddParameter("@dt_confirmation_date", confirmationDate);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_185, msg);
                }
            }
        }

        public void RegisterUser(ulong targetUser)
        {
            Guid newTrackingGuid = Guid.NewGuid();
            DMPWSDL.Receipt newReceipt;

            string country = CountryDictionary.CountryCode(m_countryID);

            try
            {
                m_dmpTransaction.RegisterUser(newTrackingGuid, targetUser, country, out newReceipt);
            }
            catch (DMPException e)
            {
                if ( e.HResult == HResult.XONLINE_E_DMP_E_USER_REGISTERED )
                {
                    Xom.Trace(XomAreaName.dmptrace, LogLevel.L_HIGH, "RegisterUser: user: 0x" + targetUser.ToString("x") + " already registered with DMP.  Ignoring error...");
                    return;
                }

                throw;
            }
        }

        public int GetBalance(ulong targetUser)
        {
            int balance;
            bool aboveLowBalance;
            Status statusUser;
            string country;

            GetBalance(targetUser, out balance, out aboveLowBalance, out statusUser, out country);

            return balance;
        }

        public void GetBalance(ulong targetUser, out int balance, out bool aboveLowBalance,
            out Status statusUser, out string country)
        {
            try
            {
                m_dmpTransaction.GetBalance(targetUser, out balance, out aboveLowBalance, out statusUser,
                    out country);

                return;
            }
            catch (DMPException e)
            {
                if (!AutoRegisterUsers || e.HResult != HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED)
                    throw;
            }

            RegisterUser(targetUser);

            m_dmpTransaction.GetBalance(targetUser, out balance, out aboveLowBalance, out statusUser,
                out country);
        }

        protected void AddPromotionalBalance(System.Guid trackingGuid, ulong targetUser, int balanceToAdd,
            string externalReferenceId, string promotionalSKU, int campaignId,
            short expirationLength, string acquisitionTitle, int acquisitionType, out Receipt receipt)
        {
            try
            {
                m_dmpTransaction.AddPromotionalBalance(trackingGuid, targetUser, balanceToAdd, externalReferenceId,
                        promotionalSKU, campaignId, expirationLength, acquisitionTitle, acquisitionType, out receipt);

                return;
            }
            catch (DMPException e)
            {
                if (!AutoRegisterUsers || e.HResult != HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED)
                    throw;
            }

            RegisterUser(targetUser);

            m_dmpTransaction.AddPromotionalBalance(trackingGuid, targetUser, balanceToAdd, externalReferenceId,
                    promotionalSKU, campaignId, expirationLength, acquisitionTitle, acquisitionType, out receipt);
        }

        protected void PurchaseItem(System.Guid trackingGuid, ulong targetUser, Item item,
            TransactionContext context, out Receipt receipt)
        {
            Item [] items = new Item[1];
            items[0] = item;

            PurchaseItem(trackingGuid, targetUser, items, context, out receipt);
        }

        protected void PurchaseItem(System.Guid trackingGuid, ulong targetUser, Item [] items,
            TransactionContext context, out Receipt receipt)
        {
            try
            {
                m_dmpTransaction.PurchaseItem(trackingGuid, targetUser, items, context, out receipt);

                return;
            }
            catch (DMPException e)
            {
                if (!AutoRegisterUsers || e.HResult != HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED)
                    throw;
            }

            RegisterUser(targetUser);

            m_dmpTransaction.PurchaseItem(trackingGuid, targetUser, items, context, out receipt);
        }

        public void GetBalanceDetails(ulong targetUser, out int balance, out bool aboveLowBalance,
            out Status statusUser, out PointLot[] lots)
        {
            try
            {
                m_dmpTransaction.GetBalanceDetails(targetUser, out balance, out aboveLowBalance, out statusUser, out lots);

                return;
            }
            catch (DMPException e)
            {
                if (!AutoRegisterUsers || e.HResult != HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED)
                    throw;
            }

            RegisterUser(targetUser);

            m_dmpTransaction.GetBalanceDetails(targetUser, out balance, out aboveLowBalance, out statusUser, out lots);
        }

        protected void CancelPurchaseItem(ulong targetUser, Guid trackingGuidOriginal, out Receipt receipt)
        {
            try
            {
                m_dmpTransaction.CancelPurchaseItem(targetUser, trackingGuidOriginal, out receipt);

                return;
            }
            catch (DMPException e)
            {
                if (!AutoRegisterUsers || e.HResult != HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED)
                    throw;
            }

            RegisterUser(targetUser);

            m_dmpTransaction.CancelPurchaseItem(targetUser, trackingGuidOriginal, out receipt);
        }

        public void TestConnection(string echoIn, out System.DateTime dt, out string echoOut)
        {
            m_dmpTransaction.TestConnection(echoIn, out dt, out echoOut);
        }

        public void TransferBalance(Guid trackingGuid, ulong machinePuid, ulong sourceUser, ulong destinationUser, int pointsToTransfer, out Receipt sourceBalance, out Receipt transferredBalance)
        {
            TransactionContext context = new TransactionContext();
            context.SellingPartnerId = m_dmpTransaction.TenantID;
            context.ExternalReferenceId = trackingGuid.ToString();
            context.ClientAddress = machinePuid.ToString("x");
            context.PostingDate = DateTime.UtcNow;

            try
            {
                m_dmpTransaction.TransferBalance(trackingGuid, sourceUser, destinationUser, pointsToTransfer, context, out sourceBalance, out transferredBalance);

                return;
            }
            catch (DMPException e)
            {
                if (!AutoRegisterUsers || e.HResult != HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED)
                    throw;
            }

            RegisterUser(destinationUser);

            m_dmpTransaction.TransferBalance(trackingGuid, sourceUser, destinationUser, pointsToTransfer, context, out sourceBalance, out transferredBalance);
        }
        public void TransferPoints(Guid trackingGuid,ulong sourceUser, ulong destinationUser, int pointsToTransfer,Property [] riskInformation, out Receipt sourceBalance, out Receipt transferredBalance)
        {
            sourceBalance = null;
            transferredBalance = null;

            TransferTransactionContext context = new TransferTransactionContext();
            context.TenantId = m_dmpTransaction.TenantID;
            context.PostingDate = DateTime.UtcNow;
            context.ExternalReferenceId = trackingGuid.ToString();
            //set campaign id to -1
            context.CampaignId = -1;
            //do the risk check
            context.RiskCheckFlag = true;
            //trigger an email when successful transfer happens
            context.EmailFlag = true;

            //todo populate risk data
            context.PropertyBag = riskInformation;

            context.ReasonCode = string.Format("Transfer Points from {0} to {1}", sourceUser, destinationUser);

            m_dmpTransaction.TransferPoints(trackingGuid, sourceUser, destinationUser, 0, pointsToTransfer, context, out sourceBalance, out transferredBalance);

            return;

        }

        // InitControl
        // Call this during app startup to initialize the xmgmt contro interface
        public static void InitControl()
        {
            if(!m_initControl)
            {
                lock(typeof(DMPClient))
                {
                    if (! m_initControl)
                    {
                        XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(DMPClient.OnControlRequest);
                        m_initControl = true;
                    }
                }
            }
        }

        protected static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command.ToLower())
                {
                    case "help":
                        XomControlConnection.SendMessage("DMPClient help:\n  TestDmpConnection\n\n", args.RequestId);
                        args.Handled = true;
                        break;

                    case "testdmpconnection":
                        ProcessTestConnectionRequest(args);
                        args.Handled = true;
                        break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\n\n", args.RequestId);
            }
        }

        protected static void ProcessTestConnectionRequest(ControlRequestEventArgs args)
        {
            DMPClient dmp;

            try
            {
                XomControlConnection.SendMessage("Creating DMPClient object...", args.RequestId);
                dmp = new DMPClient(103);
                XomControlConnection.SendMessage("success!\n", args.RequestId);
            }
            catch (Exception eInitialize)
            {
                XomControlConnection.SendMessage("failure!!!\n\n" +eInitialize.ToString() + "\n", args.RequestId);
                return;
            }

            try
            {
                string echoIn  = "Testing 1, 2, 3..!";
                string echoOut;
                DateTime dt;
                XomControlConnection.SendMessage("Running testconnection against " +
                    DMPTransactionWrapper.TransactionUrl + "\n", args.RequestId);
                dmp.TestConnection(echoIn, out dt, out echoOut );
                XomControlConnection.SendMessage(String.Format("Success! {0} {1}\n", echoOut, dt.ToString()), args.RequestId);
            }
            catch (Exception eTest)
            {
                XomControlConnection.SendMessage("failure!!!\n\n" + eTest.ToString() + "\n", args.RequestId);
                return;
            }
        }

        public static string AuditItems(Item[] items) {

            if (items == null) return string.Empty;
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("<items>");

            foreach (Item item in items) {
                sb.AppendLine("<item>");
                sb.AppendLine("<externalId>" + item.ExternalId + "</externalId>");
                sb.AppendLine("<title>" + item.Title + "</title>");
                sb.AppendLine("<price>" + item.Price.ToString("d") + "</price>");
                sb.AppendLine("<sku>" + item.SKU + "</sku>");
                sb.AppendLine("<category>" + item.ItemCategory + "</category>");
                sb.AppendLine("<credit>" + item.ItemCredit.ToString("d") + "</credit>");
                sb.AppendLine("</item>");
            }

            sb.AppendLine("</items>");
            return sb.ToString();
        }

        public static string AuditContext(TransactionContext context) {
            if (context == null) return string.Empty;
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("<context>");
            sb.AppendLine("<sellingPartnerId>" + context.SellingPartnerId.ToString() + "</sellingPartnerId>");
            sb.AppendLine("<externalReferenceId>" + context.ExternalReferenceId + "</externalReferenceId>");
            sb.AppendLine("<postingDate>" + context.PostingDate.ToString() + "</postingDate>");
            sb.AppendLine("<clientAddress>" + context.ClientAddress + "</clientAddress>");
            sb.AppendLine("<campaignId>" + context.CampaignId.ToString() + "</campaignId>");
            sb.AppendLine("</context>");

            return sb.ToString();
        }

        public void Dispose()
        {
            this.m_dmpTransaction = null;
        }
    }

    [XmlType(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    [XmlRoot(Namespace="http://schemas.microsoft.com/DMP/2004/09/API", IsNullable=false)]
    public class DMPErrorInfo
    {
        // Property is always "DMP".  The reason we have this is later on if we integrate with others, we can pass
        // along their error information.
        public string Property;

        // Error is the list of External Errors you will get from the DMP spec.
        public string Error;

        // Normally you wont see this at all.  This is useful during development phase that if you have thing
        // configured wrong.  Well let you know what is wrong.  This message should not show to user.
        public string DetailMessage;

        // If this is a client error, definitely no retry will work.  We let you know if a transaction can retry.
        public bool CanRetry;

        // ErrorBlob is an encrypted blob we can send to DMP folks for diagnosis.
        public string ErrorBlob;
    }

    public class DMPErrorMapping
    {
        public string DMPErrorString;
        public uint ErrorCode;

        public DMPErrorMapping(string dmpErrorString, uint errorCode)
        {
            DMPErrorString = dmpErrorString;
            ErrorCode = errorCode;
        }
    }

    public class DMPException : XRLException
    {
        public DMPErrorInfo ErrorInfo;
        public string ErrorXml;

        public static DMPErrorMapping [] DMPErrorMappings = new DMPErrorMapping []
        {
            new DMPErrorMapping("DMP_E_STATUS_UNREGISTERED", xonline.common.service.HResult.XONLINE_E_DMP_E_STATUS_UNREGISTERED),
            new DMPErrorMapping("DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND", xonline.common.service.HResult.XONLINE_E_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND),
            new DMPErrorMapping("DMP_E_REQUEST_CANNOT_BE_COMPLETED", xonline.common.service.HResult.XONLINE_E_DMP_E_REQUEST_CANNOT_BE_COMPLETED),
            new DMPErrorMapping("DMP_E_INSUFFICIENT_BALANCE", xonline.common.service.HResult.XONLINE_E_DMP_E_INSUFFICIENT_BALANCE),
            new DMPErrorMapping("DMP_E_MAX_BALANCE_EXCEEDED", xonline.common.service.HResult.XONLINE_E_DMP_E_MAX_BALANCE_EXCEEDED),
            new DMPErrorMapping("DMP_E_MAX_ACQUISITION_EXCEEDED", xonline.common.service.HResult.XONLINE_E_DMP_E_MAX_ACQUISITION_EXCEEDED),
            new DMPErrorMapping("DMP_E_MAX_CONSUMPTION_EXCEEDED", xonline.common.service.HResult.XONLINE_E_DMP_E_MAX_CONSUMPTION_EXCEEDED),
            new DMPErrorMapping("DMP_E_NO_MORE_PROMO_POINTS", xonline.common.service.HResult.XONLINE_E_DMP_E_NO_MORE_PROMO_POINTS),
            new DMPErrorMapping("DMP_E_PROMOTION_LIMIT_LIFE_MAX", xonline.common.service.HResult.XONLINE_E_DMP_E_PROMOTION_LIMIT_LIFE_MAX),
            new DMPErrorMapping("DMP_E_PROMO_EXPIRED", xonline.common.service.HResult.XONLINE_E_DMP_E_PROMO_EXPIRED),
            new DMPErrorMapping("DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED", xonline.common.service.HResult.XONLINE_E_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED),
            new DMPErrorMapping("DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW", xonline.common.service.HResult.XONLINE_E_DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW),
            new DMPErrorMapping("DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW", xonline.common.service.HResult.XONLINE_E_DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW),
            new DMPErrorMapping("DMP_E_COUNTRY_CODE_MISMATCH", xonline.common.service.HResult.XONLINE_E_DMP_E_COUNTRY_CODE_MISMATCH),
            new DMPErrorMapping("DMP_E_USER_REGISTERED", xonline.common.service.HResult.XONLINE_E_DMP_E_USER_REGISTERED),
            new DMPErrorMapping("DMP_E_UNKNOWNSERVER_ERROR", xonline.common.service.HResult.XONLINE_E_DMP_E_UNKNOWNSERVER_ERROR),
            new DMPErrorMapping("DMP_E_SYSTEM_INTERNAL_ERROR", xonline.common.service.HResult.XONLINE_E_DMP_E_SYSTEM_INTERNAL_ERROR),
            new DMPErrorMapping("DMP_E_INVALID_SOURCE_ACCOUNT", xonline.common.service.HResult.XONLINE_E_DMP_E_INVALID_SOURCE_ACCOUNT),
            new DMPErrorMapping("DMP_E_USER_DISABLED", xonline.common.service.HResult.XONLINE_E_DMP_E_USER_DISABLED),
            new DMPErrorMapping("DMP_E_PROMO_POINTS_UNAVAILIABLE", xonline.common.service.HResult.XONLINE_E_DMP_E_PROMO_POINTS_UNAVAILIABLE),
            new DMPErrorMapping("DMP_E_INVALID_SKU", xonline.common.service.HResult.XONLINE_E_DMP_E_INVALID_SKU),
            new DMPErrorMapping("DMP_E_DELEGATE_NOT_SUPPORTED", xonline.common.service.HResult.XONLINE_E_DMP_E_DELEGATE_NOT_SUPPORTED),
            new DMPErrorMapping("DMP_E_DESTINATION_ZERO", xonline.common.service.HResult.XONLINE_E_DMP_E_DESTINATION_ZERO),
            new DMPErrorMapping("DMP_E_INVALID_DESTINATION_ACCOUNT", xonline.common.service.HResult.XONLINE_E_DMP_E_INVALID_DESTINATION_ACCOUNT),
            new DMPErrorMapping("DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED", xonline.common.service.HResult.XONLINE_E_DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED),
            new DMPErrorMapping("DMP_E_SOURCE_TRANSFER_PUIDS_SAME", xonline.common.service.HResult.XONLINE_E_DMP_E_SOURCE_TRANSFER_PUIDS_SAME),
            new DMPErrorMapping("DMP_E_SOURCE_ZERO", xonline.common.service.HResult.XONLINE_E_DMP_E_SOURCE_ZERO),
            new DMPErrorMapping("DMP_E_ZERO_NEGTIVE_TRANSFER", xonline.common.service.HResult.XONLINE_E_DMP_E_ZERO_NEGTIVE_TRANSFER),
            new DMPErrorMapping("DMP_E_RISK_UNEXPECTED_RESULT", xonline.common.service.HResult.XONLINE_E_DMP_E_RISK_UNEXPECTED_RESULT),

        };

        public DMPException(string message, XEvent.Id eventid, SoapException e, string errorXml, DMPErrorInfo errorInfo,
            HResult hresult) : base(hresult, eventid, message, e)
        {
            ErrorXml = errorXml;
            ErrorInfo = errorInfo;
        }

        public static bool ConsiderSoapExceptionAsDMPException(SoapException se)
        {
            Debug.Assert( se != null );
            if ( se == null ) { throw new ArgumentNullException("se cannot be null"); }

            return ( se.Detail != null && false == string.IsNullOrEmpty(se.Detail.InnerXml) );
        }

        public static DMPException FromSoapException(SoapException e)
        {
            try
            {
                string errorXml = e.Detail.InnerXml;

                XmlSerializer s = new XmlSerializer(typeof(DMPErrorInfo));

                XmlReader r = new XmlNodeReader(e.Detail.FirstChild);

                DMPErrorInfo errorInfo = (DMPErrorInfo) s.Deserialize(r);

                HResult hr = xonline.common.service.HResult.XONLINE_E_DMP_E_UNKNOWN_ERROR;
                for (int i = 0; i < DMPErrorMappings.Length; i++)
                {
                    if (string.CompareOrdinal(errorInfo.Error, DMPErrorMappings[i].DMPErrorString) == 0)
                    {
                        hr = DMPErrorMappings[i].ErrorCode;
                        break;
                    }
                }

                string message = string.Join("\n", new string []
                    {
                        e.Message,
                        string.Format("DMP Error: {0} ({1})", errorInfo.Error, errorInfo.Property),
                        string.Format("Xbox Live Mapped Error: {0}", hr.ToString()),
                        string.Format("Detail: {0}", errorInfo.DetailMessage),
                        string.Format("XML Dump: {0}", errorXml)
                    });

                return new DMPException(message, XEvent.Id.DMP_EXTERNAL_EXCEPTION, e, errorXml, errorInfo, hr);
            }
            catch
            {
                // if we have any trouble creating our nice, rich DMPException class,
                // just bail and throw the original SoapException
                throw;
            }
        }
    }

    public class DMPTransactionWrapper : DMPTransaction
    {
        protected static X509Certificate m_cert;
        public Guid TenantID;

        public static int GetBalanceMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_getBalanceMaxAttempts);
            }
        }

        public static int AddPromotionalBalanceMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_addPromotionalBalanceMaxAttempts);
            }
        }

        public static int PurchaseItemMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_purchaseItemMaxAttempts);
            }
        }

        public static int GetBalanceDetailsMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_getBalanceDetailsMaxAttempts);
            }
        }

        public static int CancelPurchaseItemMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_cancelPurchaseItemMaxAttempts);
            }
        }

        public static int RegisterUserMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_registerUserMaxAttempts);
            }
        }

        public static int TransferBalanceMaxAttempts
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_transferBalanceMaxAttempts);
            }
        }

        public int GetBalanceTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_getBalanceTimeoutSeconds);
            }
        }

        public int AddPromotionalBalanceTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_addPromotionalBalanceTimeoutSeconds);
            }
        }

        public int PurchaseItemTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_purchaseItemTimeoutSeconds);
            }
        }

        public int GetBalanceDetailsTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_getBalanceDetailsTimeoutSeconds);
            }
        }

        public int CancelPurchaseItemTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_cancelPurchaseItemTimeoutSeconds);
            }
        }

        public int RegisterUserTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_registerUserTimeoutSeconds);
            }
        }

        public int TransferBalanceTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_transferBalanceTimeoutSeconds);
            }
        }

        public int TransferPointsTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.dmp_transferPointsTimeoutSeconds);
            }
        }

        public static string TransactionUrl
        {
            get
            {
                string transactionUrl = Config.GetSetting(Setting.dmp_transactionUrl);
                if (transactionUrl == "" || transactionUrl == string.Empty)
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_186, "The dmp_transactionUrl setting is not configured");

                return transactionUrl;
            }
        }

        public string ClientCertSubject
        {
            get
            {
                string clientCertSubject = Config.GetSetting(Setting.dmp_clientCertSubject);
                if (clientCertSubject == string.Empty)
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_187, "The dmp_clientCertSubject setting is not configured");

                return clientCertSubject;
            }
        }

        public DMPTransactionWrapper() : base()
        {
            string tenantID = Config.GetSetting(Setting.dmp_tenantID);
            if ( string.IsNullOrEmpty(tenantID) )
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_188, "The dmp_tenantID setting is not configured");
            }

            TenantID = new Guid(tenantID);

            string url = GetSessionAlternateUrl();
            if ( string.IsNullOrEmpty(url) )
            {
                url = TransactionUrl;
            }

            Url = url;
            PreAuthenticate = true;

            string proxy = Config.GetSetting(Setting.billing_proxy);
            if ( string.IsNullOrEmpty(proxy) )
            {
                Proxy = new WebProxy();
            }
            else
            {
                Proxy = new WebProxy(proxy, true);
            }

            if (m_cert == null)
            {
                m_cert = CertUtil.GetLocalMachineCertificate(ClientCertSubject);
            }

            ClientCertificates.Add(m_cert);
        }

        [ThreadStaticAttribute]
        protected static string m_tlsSessionAlternateUrl;

        public const string FastFailDmpUps = "DmpUps";
        public const string FastFailDmp    = "Dmp";

        static DMPTransactionWrapper()
        {
            FastFailResourceConfig defaultConfig;

            defaultConfig = FastFailBillingDefaults.GetConfiguration();

            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, FastFailDmpUps);
            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, FastFailDmp);
        }

        public static void ResetSessionAlternateUrl()
        {
            m_tlsSessionAlternateUrl = null;
        }

        public static void SetSessionAlternateUrl(string url)
        {
            m_tlsSessionAlternateUrl = url;
        }

        public static string GetSessionAlternateUrl()
        {
            string url = null;
            if (Config.IsTestEnvironment() == true &&
                Config.GetBoolSetting(Setting.dmp_allowUrlOverride) &&
                (null != m_tlsSessionAlternateUrl)
                )
            {
                url = m_tlsSessionAlternateUrl;
            }

            return url;
        }

        private FastFailTracker GetFastFailTracker(string apiName, string resourceName, ref APIResultEnum result) {
            try { return new FastFailTracker(resourceName); }
            catch (FastFailException inner) {
                DMPCounters.Counters.BlockedCallsPerSecond.Increment();
                DMPCounters.Counters.BlockedCallsTotal.Increment();

                DMPCounters apiCounters = DMPCounters.Counters[apiName];
                apiCounters.BlockedCallsPerSecond.Increment();
                apiCounters.BlockedCallsTotal.Increment();

                result = APIResultEnum.FailFast;

                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    inner,
                    "DMP call blocked due to fail-fasting of DMP server");
            }
        }

        private void HandleTimeout(string apiName, string errorMessage)
        {
            DMPCounters.Counters.TimeoutsPerSecond.Increment();
            DMPCounters.Counters.TimeoutsTotal.Increment();

            DMPCounters apiCounters = DMPCounters.Counters[apiName];
            apiCounters.TimeoutsPerSecond.Increment();
            apiCounters.TimeoutsTotal.Increment();
        }

        private void HandlePerfCountersEnd(string apiName, APIResultEnum result, XomRequestTimeElapsed timeElapsed)
        {
            DMPCounters.Counters.CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            DMPCounters.Counters.CallsTimeBase.Increment();

            DMPCounters apiCounters = DMPCounters.Counters[apiName];
            apiCounters.CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            apiCounters.CallsTimeBase.Increment();

            if (result != APIResultEnum.Success && result != APIResultEnum.FailFast)
            {
                DMPCounters.Counters.CallsFailedPerSecond.Increment();
                DMPCounters.Counters.CallsFailedTotal.Increment();

                apiCounters.CallsFailedPerSecond.Increment();
                apiCounters.CallsFailedTotal.Increment();
            }
        }

        private void HandlePerfCountersBegin(string apiName)
        {
            DMPCounters.Counters.CallsPerSecond.Increment();
            DMPCounters.Counters.CallsTotal.Increment();

            DMPCounters apiCounters = DMPCounters.Counters[apiName];
            apiCounters.CallsPerSecond.Increment();
            apiCounters.CallsTotal.Increment();
        }

        protected enum APIResultEnum
        {
            Success,
            FailFast,
            Failed,
            Timeout
        }

        private void LogApiCall(string apiName, APIResultEnum result, long millisecondsElapsed, string [] inParams,
            string [] outParams, string dmpErrorDetails)
        {
            // TODO: could also handle failures here with some code cleanup

            string resultString;
            switch (result)
            {
                case APIResultEnum.Success:
                    resultString = "Success";
                    break;

                case APIResultEnum.FailFast:
                    resultString = "FailFast";
                    break;

                case APIResultEnum.Failed:
                    resultString = "Failed";
                    break;

                case APIResultEnum.Timeout:
                    resultString = "Timeout";
                    break;

                default:
                    resultString = "Unknown";
                    break;
            }

            string szLog = string.Join("|", new string []
            {
                apiName,
                resultString,
                millisecondsElapsed.ToString(),
                string.Join("|", inParams),
                result == APIResultEnum.Success ? string.Join("|", outParams) : "Failed",
                dmpErrorDetails == null ? "" : dmpErrorDetails
            });

            Xom.Log(XomAreaName.dmplog, szLog);
        }

        public virtual string GetBalance(ulong targetUser, out int balance, out bool aboveLowBalance,
            out Status statusUser, out string country)
        {
            string apiName = "GetBalance";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmpUps, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = GetBalanceTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.GetBalance((long)targetUser, 0, out balance, out aboveLowBalance,
                            out statusUser, out country);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string [] { balance.ToString("d"), aboveLowBalance ? "true" : "false",
                        statusUser.ToString("d"), country };

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;

                    if (!e.ErrorInfo.CanRetry || attempts >= GetBalanceMaxAttempts)
                    {
                        throw e;
                    }

                    // else try the API again
                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { targetUser.ToString("x") },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }

        public virtual string AddPromotionalBalance(System.Guid trackingGuid, ulong targetUser, int balanceToAdd,
            string externalReferenceId, string promotionalSKU, int campaignId,
            short expirationLength, string acquisitionTitle, int acquisitionType, out Receipt receipt)
        {
            string apiName = "AddPromotionalBalance";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = AddPromotionalBalanceTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.AddPromotionalBalance(trackingGuid, (long)targetUser, 0, TenantID,
                            balanceToAdd, externalReferenceId, promotionalSKU, campaignId,
                            expirationLength, acquisitionTitle, acquisitionType, out receipt);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string [] { receipt.TrackingGuid.ToString(), receipt.ConfirmationId,
                        receipt.ConfirmationDate.ToString("s"), receipt.NewBalance.ToString("d") };

                    AuditStream.Write(
                        0, AuditSubsystem.DMP, apiName, string.Empty,
                        new AuditParam("trackingGuid", receipt.TrackingGuid.ToString()),
                        new AuditParam("tenantId", TenantID.ToString()),
                        new AuditParam("externalReferenceId", externalReferenceId),
                        new AuditParam("promotionalSKU", promotionalSKU),
                        new AuditParam("campaignId", campaignId),
                        new AuditParam("expirationLength", expirationLength.ToString("d")),
                        new AuditParam("acquisitionTitle", acquisitionTitle),
                        new AuditParam("acquisitionType", acquisitionType),
                        new AuditParam("newBalance", receipt.NewBalance.ToString("d")),
                        new AuditParam("confirmationId", receipt.ConfirmationId),
                        new AuditParam("confirmationDate", receipt.ConfirmationDate.ToString())
                    );

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;

                    if (!e.ErrorInfo.CanRetry || attempts >= AddPromotionalBalanceMaxAttempts)
                    {
                        throw e;
                    }

                    // else try the API again
                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        AuditStream.Write(
                            0, AuditSubsystem.DMP, apiName, e.Message,
                            new AuditParam("trackingGuid", trackingGuid.ToString()),
                            new AuditParam("tenantId", TenantID.ToString()),
                            new AuditParam("externalReferenceId", externalReferenceId),
                            new AuditParam("promotionalSKU", promotionalSKU),
                            new AuditParam("campaignId", campaignId),
                            new AuditParam("expirationLength", expirationLength.ToString("d")),
                            new AuditParam("acquisitionTitle", acquisitionTitle),
                            new AuditParam("acquisitionType", acquisitionType)
                        );

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { trackingGuid.ToString(), targetUser.ToString("x"), balanceToAdd.ToString("d"),
                            externalReferenceId, promotionalSKU, campaignId.ToString("d"), expirationLength.ToString("d"),
                            acquisitionTitle, acquisitionType.ToString("d") },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }

        public virtual string GetBalanceDetails(ulong targetUser, out int balance, out bool aboveLowBalance,
            out Status statusUser, out PointLot[] lots)
        {
            string apiName = "GetBalanceDetails";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = GetBalanceDetailsTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.GetBalanceDetails((long)targetUser, 0, out balance, out aboveLowBalance, out statusUser, out lots);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string [] { balance.ToString("d"), aboveLowBalance ? "true" : "false",
                        statusUser.ToString("d"), lots.Length.ToString("d"),
                        lots.Length > 0 ? lots[0].ExpirationDays.ToString("d") : "",
                        lots.Length > 0 ? lots[0].Quantity.ToString("d") : "",
                        lots.Length > 0 ? lots[0].sourceType.ToString("d") : "",
                        };

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;

                    if (!e.ErrorInfo.CanRetry || attempts >= GetBalanceDetailsMaxAttempts)
                    {
                        throw e;
                    }

                    // else try the API again
                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { targetUser.ToString("x") },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }

        public virtual string PurchaseItem(System.Guid trackingGuid, ulong targetUser, Item [] items,
            TransactionContext context, out Receipt receipt)
        {
            string apiName = "PurchaseItem";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = PurchaseItemTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.PurchaseItem(trackingGuid, (long)targetUser, 0, items, context, out receipt);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string [] { receipt.TrackingGuid.ToString(), receipt.ConfirmationId,
                        receipt.ConfirmationDate.ToString("s"), receipt.NewBalance.ToString("d") };

                    AuditStream.Write(
                        0, AuditSubsystem.DMP, apiName, "success",
                        new AuditParam("trackingGuid", receipt.TrackingGuid.ToString()),
                        new AuditXmlParam("itemsXml", DMPClient.AuditItems(items)),
                        new AuditXmlParam("contextXml", DMPClient.AuditContext(context)),
                        new AuditParam("newBalance", receipt.NewBalance.ToString("d")),
                        new AuditParam("confirmationId", receipt.ConfirmationId),
                        new AuditParam("confirmationDate", receipt.ConfirmationDate.ToString())
                    );

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;

                    if (!e.ErrorInfo.CanRetry || attempts >= PurchaseItemMaxAttempts)
                    {
                        throw e;
                    }

                    // else try the API again
                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        AuditStream.Write(
                            0, AuditSubsystem.DMP, apiName, e.Message,
                            new AuditParam("trackingGuid", trackingGuid.ToString()),
                            new AuditXmlParam("itemsXml", DMPClient.AuditItems(items)),
                            new AuditXmlParam("contextXml", DMPClient.AuditContext(context))
                        );

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { trackingGuid.ToString(), targetUser.ToString("x"), DumpItems(items),
                            context.SellingPartnerId.ToString(), context.ExternalReferenceId,
                            context.PostingDate.ToString("s"), context.ClientAddress,
                            context.CampaignId.ToString("d") },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }

        public virtual string CancelPurchaseItem(ulong targetUser, System.Guid trackingGuidOriginal,
            out Receipt receipt)
        {
            string apiName = "CancelPurchaseItem";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = CancelPurchaseItemTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.CancelPurchaseItem((long)targetUser, 0, trackingGuidOriginal, out receipt);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string [] { receipt.TrackingGuid.ToString(), receipt.ConfirmationId,
                        receipt.ConfirmationDate.ToString("s"), receipt.NewBalance.ToString("d") };

                    AuditStream.Write(
                        0, AuditSubsystem.DMP, apiName, string.Empty,
                        new AuditParam("trackingGuid", receipt.TrackingGuid.ToString()),
                        new AuditParam("newBalance", receipt.NewBalance.ToString("d")),
                        new AuditParam("confirmationId", receipt.ConfirmationId),
                        new AuditParam("confirmationDate", receipt.ConfirmationDate.ToString())
                    );

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;

                    if (!e.ErrorInfo.CanRetry || attempts >= CancelPurchaseItemMaxAttempts)
                    {
                        throw e;
                    }

                    // else try the API again
                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        AuditStream.Write(
                            0, AuditSubsystem.DMP, apiName, e.Message,
                            new AuditParam("trackingGuid", trackingGuidOriginal.ToString())
                        );

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { targetUser.ToString("x"), trackingGuidOriginal.ToString() },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }

        public virtual string RegisterUser(System.Guid trackingGuid, ulong targetUser, string country,
            out Receipt receipt)
        {
            string apiName = "RegisterUser";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = RegisterUserTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.RegisterUser(trackingGuid, (long)targetUser, 0, country, out receipt);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string [] { receipt.TrackingGuid.ToString(), receipt.ConfirmationId,
                        receipt.ConfirmationDate.ToString("s"), receipt.NewBalance.ToString("d") };

                    AuditStream.Write(
                        0, AuditSubsystem.DMP, apiName, "success",
                        new AuditParam("trackingGuid", receipt.TrackingGuid.ToString()),
                        new AuditParam("country", country),
                        new AuditParam("confirmationId", receipt.ConfirmationId),
                        new AuditParam("confirmationDate", receipt.ConfirmationDate.ToString())
                    );

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;

                    if (!e.ErrorInfo.CanRetry || attempts >= RegisterUserMaxAttempts)
                    {
                        throw e;
                    }

                    // else try the API again
                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        AuditStream.Write(
                            0, AuditSubsystem.DMP, apiName, e.Message,
                            new AuditParam("trackingGuid", trackingGuid.ToString()),
                            new AuditParam("country", country)
                        );

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { trackingGuid.ToString(), targetUser.ToString("x"), country },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }

        public virtual string TransferBalance(System.Guid trackingGuid, ulong sourceUser, ulong targetUser, int pointsToTransfer, TransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt)
        {
            string apiName = "TransferBalance";

            int attempts = 0;
            while (true)
            {
                APIResultEnum result = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                string dmpErrorDetails = null;
                string [] outParams = null;
                FastFailTracker tracker = null;

                try
                {
                    tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                    HandlePerfCountersBegin(apiName);

                    attempts++;

                    int timeout = TransferBalanceTimeoutSeconds * 1000;

                    DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                    Timeout = timeout;

                    string s;
                    using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                    {

                        s = base.TransferBalance(trackingGuid, (long)sourceUser, (long)targetUser, 0, pointsToTransfer, context, out sourceReceipt, out transferReceipt);

                    }

                    postCallInjectedBehavior();

                    tracker.IndicateSuccess();

                    result = APIResultEnum.Success;

                    outParams = new string[] {
                        sourceReceipt.TrackingGuid.ToString(), sourceReceipt.ConfirmationId, sourceReceipt.ConfirmationDate.ToString("s"), sourceReceipt.NewBalance.ToString("d"),
                        transferReceipt.TrackingGuid.ToString(), transferReceipt.ConfirmationId, transferReceipt.ConfirmationDate.ToString("s"), transferReceipt.NewBalance.ToString("d"),
                    };

                    AuditStream.Write(
                        0, AuditSubsystem.DMP, apiName, string.Empty,
                        new AuditParam("trackingGuid", trackingGuid.ToString()),
                        new AuditParam("sourceUser", sourceUser.ToString("x")),
                        new AuditParam("targetUser", targetUser.ToString("x")),
                        new AuditParam("pointsToTransfer", pointsToTransfer),
                        new AuditParam("sourceTrackingGuid", sourceReceipt.TrackingGuid.ToString()),
                        new AuditParam("sourceConfirmationId", sourceReceipt.ConfirmationId),
                        new AuditParam("sourceConfirmationDate", sourceReceipt.ConfirmationDate.ToString("s")),
                        new AuditParam("sourceNewBalance", sourceReceipt.NewBalance),
                        new AuditParam("transferTrackingGuid", transferReceipt.TrackingGuid.ToString()),
                        new AuditParam("transferConfirmationId", transferReceipt.ConfirmationId),
                        new AuditParam("transferConfirmationDate", transferReceipt.ConfirmationDate.ToString("s")),
                        new AuditParam("transferNewBalance", transferReceipt.NewBalance)
                    );

                    return s;
                }
                catch (SoapException se)
                {
                    if ( !DMPException.ConsiderSoapExceptionAsDMPException(se) )
                    {
                        throw;
                    }

                    DMPException e = DMPException.FromSoapException(se);
                    dmpErrorDetails = e.Message;
                    if (!e.ErrorInfo.CanRetry || attempts >= RegisterUserMaxAttempts)
                    {
                        throw e;
                    }

                }
                catch (WebException e)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                    {
                        tracker.IndicateTimeout();

                        AuditStream.Write(
                            0, AuditSubsystem.DMP, apiName, e.Message,
                            new AuditParam("trackingGuid", trackingGuid.ToString()),
                            new AuditParam("sourceUser", sourceUser.ToString("x")),
                            new AuditParam("targetUser", targetUser.ToString("x")),
                            new AuditParam("pointsToTransfer", pointsToTransfer.ToString("d"))
                        );

                        result = APIResultEnum.Timeout;
                        HandleTimeout(apiName, e.ToString());
                    }

                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, result, timeElapsed);

                    // Liberal reporting policy here, success or timeout
                    if (null != tracker) {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                        new string [] { trackingGuid.ToString(), sourceUser.ToString("x"), targetUser.ToString("x"), pointsToTransfer.ToString("d") },
                        outParams,
                        dmpErrorDetails
                        );
                }
            }
        }
        public virtual string TransferPoints(System.Guid trackingGuid, ulong sourceUser, ulong transferUser, ulong delegateUser, int pointsToTransfer, TransferTransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt)
        {
            string apiName = "TransferPoints";

            APIResultEnum result = APIResultEnum.Failed;

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string dmpErrorDetails = null;

            string[] outParams = null;

            FastFailTracker tracker = null;

            try
            {

                tracker = GetFastFailTracker(apiName, FastFailDmp, ref result);

                HandlePerfCountersBegin(apiName);

                int timeout = TransferPointsTimeoutSeconds * 1000;

                DmpFailure.PostCallDelegate postCallInjectedBehavior = DmpFailure.HandleBehaviorInjection(apiName, ref timeout);

                Timeout = timeout;

                string s;
                using (HistogramPerfCounterManager.GetHistogramManager("DMP", apiName))
                {

                    s = base.TransferPoints(trackingGuid, (long)sourceUser, (long)transferUser, (long)delegateUser, pointsToTransfer, context, out sourceReceipt, out transferReceipt);

                }

                postCallInjectedBehavior();

                tracker.IndicateSuccess();

                result = APIResultEnum.Success;

                outParams = new string[] {
                        sourceReceipt.TrackingGuid.ToString(), sourceReceipt.ConfirmationId, sourceReceipt.ConfirmationDate.ToString("s"), sourceReceipt.NewBalance.ToString("d"),
                        transferReceipt.TrackingGuid.ToString(), transferReceipt.ConfirmationId, transferReceipt.ConfirmationDate.ToString("s"), transferReceipt.NewBalance.ToString("d"),
                    };

                return s;

            }
            catch (SoapException se)
            {
                if (!DMPException.ConsiderSoapExceptionAsDMPException(se))
                {
                    throw;
                }

                DMPException e = DMPException.FromSoapException(se);
                dmpErrorDetails = e.Message;
                throw e;
            }
            catch (WebException e)
            {
                if (FastFailHelper.ConsiderWebExceptionAsTimeout(e))
                {
                    if (null != tracker)
                    {
                        tracker.IndicateTimeout();
                    }

                    AuditStream.Write(
                        0, AuditSubsystem.DMP, apiName, e.Message,
                        new AuditParam("trackingGuid", trackingGuid.ToString()),
                        new AuditParam("sourceUser", sourceUser.ToString("x")),
                        new AuditParam("targetUser", transferUser.ToString("x")),
                        new AuditParam("pointsToTransfer", pointsToTransfer.ToString("d"))
                    );

                    result = APIResultEnum.Timeout;
                    HandleTimeout(apiName, e.ToString());
                }

                throw;
            }
            finally
            {
                HandlePerfCountersEnd(apiName, result, timeElapsed);

                // Liberal reporting policy here, success or timeout
                if (null != tracker)
                {
                    // Only first feature indication will be acknowledged, this might be ignored
                    tracker.IndicateSuccess();
                }

                LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed,
                    new string[] { trackingGuid.ToString(), sourceUser.ToString("x"), transferUser.ToString("x"), pointsToTransfer.ToString("d") },
                    outParams,
                    dmpErrorDetails
                    );
            }


        }

        public string DumpItems(Item [] items)
        {
            if (items == null || items.Length == 0)
                return "0";

            StringBuilder sb = new StringBuilder();
            sb.Append(items.Length.ToString("d"));

            foreach (Item item in items)
            {
                sb.Append('|');
                sb.Append(string.Join("|", new string []
                {
                    item.ExternalId,
                    item.Title,
                    item.Price.ToString("d"),
                    item.SKU,
                    item.ItemCategory,
                    item.ItemCredit.ToString("d"),
                }));
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\DirectDebitInfo.cs ===
using System.Diagnostics;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.billing
{
    public class DirectDebitInfo
    {

        // The following fields must be filled in to Create an account.
        public string   AccountHolderName;
        public string   AccountNumber;
        public string   AccountNumberLastFour;
        public string   EncryptedAccountNumber;
        public string   BankCode;
        public string   BranchCode;
        public string   CheckDigits;


        public void EncryptAccountNumber()
        {
            if (AccountNumber != null && AccountNumber != "")
            {
                BillingProvider bdk = new BillingProvider();
                EncryptedAccountNumber = bdk.EncryptNumber(AccountNumber);
                AccountNumber = null;
            }
        }

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "AccountHolderName":
                        AccountHolderName = xmlReader.ReadElementString();
                        break;

                    case "AccountNumber":
                        //
                        // In cases where we're reading in the actual AccountNumber, we must be pulling the
                        // XML set from the billing queue-- SCS will never return the real AccountNumber to us.
                        // As a result, we ALSO copy the last four digits into AccountNumberLastFour so that the
                        // Account instance can be used by top-level functions as if it had actually come from
                        // SCS.
                        //
                        AccountNumber = xmlReader.ReadElementString();
                        if ( AccountNumber != null && AccountNumber.Length >= 4 )
                        {
                            AccountNumberLastFour = AccountNumber.Substring(AccountNumber.Length-4, 4);
                        }
                        break;

                    case "AccountNumberLastFour":
                        if ( AccountNumberLastFour != null )
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_CODE_11, "ASSERT: AccountNumberLastFour should be null when being read! "
                                + " Instead we're copying over the current value of " + AccountNumberLastFour + " with " + xmlReader.ReadElementString());
                        }

                        AccountNumberLastFour = xmlReader.ReadElementString();
                        break;

                    case "EncryptedAccountNumber":
                        EncryptedAccountNumber = xmlReader.ReadElementString();
                        break;

                    case "BankCode":
                        BankCode = xmlReader.ReadElementString();
                        break;

                    case "BranchCode":
                        BranchCode = xmlReader.ReadElementString();
                        break;

                    case "CheckDigits":
                        CheckDigits = xmlReader.ReadElementString();
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "DirectDebit: Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                        break;
                }
            }
        }


        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {
            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "DirectDebitInfo" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<AccountHolderName>");
            xmlBldr.Append(XmlCleanser.Cleanup(AccountHolderName));
            xmlBldr.Append("</AccountHolderName>");

            if ( AccountNumber != null )
            {
                xmlBldr.Append("<AccountNumber>");
                xmlBldr.Append(XmlCleanser.Cleanup(AccountNumber));
                xmlBldr.Append("</AccountNumber>");
            }

            if ( EncryptedAccountNumber != null )
            {
                xmlBldr.Append("<EncryptedAccountNumber>");
                xmlBldr.Append(XmlCleanser.Cleanup(EncryptedAccountNumber));
                xmlBldr.Append("</EncryptedAccountNumber>");
            }

            if ( BankCode != null && BankCode != "" )
            {
                xmlBldr.Append("<BankCode>");
                xmlBldr.Append(XmlCleanser.Cleanup(BankCode));
                xmlBldr.Append("</BankCode>");
            }

            xmlBldr.Append("<BranchCode>");
            xmlBldr.Append(XmlCleanser.Cleanup(BranchCode));
            xmlBldr.Append("</BranchCode>");

            if ( CheckDigits != null && CheckDigits != "" )
            {
                xmlBldr.Append("<CheckDigits>");
                xmlBldr.Append(XmlCleanser.Cleanup(CheckDigits));
                xmlBldr.Append("</CheckDigits>");
            }

            xmlBldr.Append("</DirectDebitInfo>");
        }


        // Returns a new instance of DirectDebitInfoData populated with data
        // from the current DirectDebitInfo instance.
        public DirectDebitInfoData ToWireData()
        {
            DirectDebitInfoData directDebitInfo = new DirectDebitInfoData();

            directDebitInfo.accountHolderName = AccountHolderName;
            if ( AccountNumber != null && AccountNumber != "" )
            {
                directDebitInfo.accountNumber = AccountNumberLastFour;
            }
            else if ( AccountNumberLastFour != null && AccountNumberLastFour != "" )
            {
                directDebitInfo.accountNumber = AccountNumberLastFour;
            }
            directDebitInfo.bankCode = BankCode;
            directDebitInfo.branchCode = BranchCode;
            directDebitInfo.checkDigits = CheckDigits;

            return directDebitInfo;
        }

        // Populates DirectDebit property data with data from the given
        // DirectDebitInfoData instance.
        public void FromWireData(DirectDebitInfoData directDebitInfo)
        {
            AccountHolderName = directDebitInfo.accountHolderName;
            AccountNumber = directDebitInfo.accountNumber;
            BankCode = directDebitInfo.bankCode;
            BranchCode = directDebitInfo.branchCode;
            CheckDigits = directDebitInfo.checkDigits;
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            if (AccountHolderName == "")                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_HOLDER_NAME_NOT_FOUND_ERROR, "Missing DirectDebitInfo.AccountHolderName");
            if (AccountNumber == "")                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_NUMBER_NOT_FOUND_ERROR, "Missing DirectDebitInfo.AccountNumber");
            if (BranchCode == "")                           throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_BRANCH_CODE_NOT_FOUND_ERROR, "Missing DirectDebitInfo.BranchCode");
            if (isUpdate == false && AccountNumber == null) throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_NUMBER_NOT_FOUND_ERROR, "Missing PaymentInfo.DirectDebit.AccountNumber");
        }

        public override string ToString()
        {
            string a;

            a = "AccountHolderName: " + AccountHolderName +
                "\nBankCode: " + BankCode +
                "\nBranchCode: " + BranchCode +
                "\nCheckDigits: " + CheckDigits;

            return a;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\DmpPerf.cs ===
using System.Diagnostics;
using xonline.common.mgmt;

namespace xonline.common.billing
{
    [XomPerformanceCounterCategoryAttr( "Partner: DMP", "XBox Live DMP Counters", true )]
    public class DMPCounters : XomPerformanceCounterCategory
    {
        static public DMPCounters Counters = new DMPCounters();

        public DMPCounters this[string api]
        {
            get
            {
                return (DMPCounters) GetInstance(api);
            }
        }

		[XomPerformanceCounterAttr(
			"DMP API requests/sec",
			"DMP SOAP API requests per second",
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter CallsPerSecond;

		[XomPerformanceCounterAttr(
			"DMP API requests total",
			"Total DMP SOAP API requests made in the the current AppDomain.",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter CallsTotal;

		[XomPerformanceCounterAttr(
			"DMP API failures/sec",
			"Number of unsuccessful results returned per second in the current AppDomain.",
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter CallsFailedPerSecond;

		[XomPerformanceCounterAttr(
			"DMP API total failures",
			"Total number unsuccessful results returned in the current AppDomain.",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter CallsFailedTotal;

		[XomPerformanceCounterAttr(
			"DMP API timeouts/sec",
			"Number of timeouts making DMP SOAP API calls per second in the current AppDomain.",
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter TimeoutsPerSecond;

		[XomPerformanceCounterAttr(
			"DMP API total timeouts",
			"Total number of timeouts making DMP SOAP API calls in the current AppDomain.",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter TimeoutsTotal;

		[XomPerformanceCounterAttr(
			"DMP API blocked calls/sec",
			"Number of DMP SOAP API calls blocked due to blacklisting per second in the current AppDomain.",
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter BlockedCallsPerSecond;

		[XomPerformanceCounterAttr(
			"DMP API total blocked calls",
			"Total number of DMP SOAP API calls blocked due to blacklisting per second in the current AppDomain.",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter BlockedCallsTotal;

        [XomPerformanceCounterAttr(
			"Avg. execution time",
			"Average time taken to execute SOAP requests against DMP",
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter CallsTime;

    	[XomPerformanceCounterAttr(
			"Avg. execution time base",
			"Base average time taken to execute SOAP requests against DMP",
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter CallsTimeBase;
    }

    [XomPerformanceCounterCategoryAttr( "Partner: DMP Queue", "XBox Live DMP Queue Counters", true )]
    public class DMPQueueCounters : XomPerformanceCounterCategory
    {
        static public DMPQueueCounters Counters = new DMPQueueCounters();

		[XomPerformanceCounterAttr(
			"DMP::CancelPurchase attempts/second",
			"DMP::CancelPurchase attempts/second made by the DMP queue worker thread",
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter CancelPurchaseAttemptsPerSecond;

		[XomPerformanceCounterAttr(
			"DMP::CancelPurchase attempts total",
			"DMP::CancelPurchase attempts total made by the DMP queue worker thread in this App Domain",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter CancelPurchaseAttemptsTotal;

		[XomPerformanceCounterAttr(
			"Number of pending cancelable purchases",
			"Total number of purchases that need to be cancelled.  " +
            "This value represents the last known number, and won't include " +
            "activity by other servers which affect the pending size.",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter CancelPurchasePendingTotal;

		[XomPerformanceCounterAttr(
			"DMP::AddPromotionalBalance attempts/second",
			"DMP::AddPromotionalBalance attempts/second made by the DMP queue worker thread",
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter AddPromotionalBalanceAttemptsPerSecond;

		[XomPerformanceCounterAttr(
			"DMP::AddPromotionalBalance attempts total",
			"DMP::AddPromotionalBalance attempts total made by the DMP queue worker thread in this App Domain",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter AddPromotionalBalanceAttemptsTotal;

		[XomPerformanceCounterAttr(
			"Number of pending rewards",
			"Total number of rewards that need to be retried.  " +
            "This value represents the last known number, and won't include " +
            "activity by other servers which affect the pending size.",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter AddPromotionalBalancePendingTotal;

		[XomPerformanceCounterAttr(
			"DMP::CancelPurchase pump runs total",
			"Total times the DMP::CancelPurchase pump has attempted to empty the queue in the current App Domain",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter CancelPurchasePumpRunsTotal;

		[XomPerformanceCounterAttr(
			"DMP::AddPromotionalBalance runs total",
			"Total times the DMP::AddPromotionalBalance pump has attempted to empty the queue in the current App Domain",
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter AddPromotionalBalancePumpRunsTotal;

        [XomPerformanceCounterAttr(
			"DMP::CancelPurchase Pump avg. execution time",
			"Average time taken to pump the DMP::CancelPurchase queue on all UODB partitions",
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter CancelPurchasePumpRunTime;

    	[XomPerformanceCounterAttr(
			"DMP::CancelPurchase Pump avg. execution time base",
			"Base average time taken to pump the DMP::CancelPurchase queue on all UODB partitions",
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter CancelPurchasePumpRunTimeBase;

        [XomPerformanceCounterAttr(
            "DMP::AddPromotionalBalance Pump avg. execution time",
            "Average time taken to pump the DMP::AddPromotionalBalance queue on all UODB partitions",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AddPromotionalBalancePumpRunTime;

        [XomPerformanceCounterAttr(
            "DMP::AddPromotionalBalance Pump avg. execution time base",
            "Base average time taken to pump the DMP::AddPromotionalBalance queue on all UODB partitions",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AddPromotionalBalancePumpRunTimeBase;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\FastFailCounters.cs ===
using System;

using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.billing {
   public static class FastFailBillingDefaults {
      public static readonly uint MaximumThreshold = 50;
      public static readonly uint MinimumThreshold = 5;
      
      public static readonly TimeSpan CaptureTimeWindow = 
         TimeSpan.FromSeconds(30);

      private static readonly FastFailThrottleSelector ThrottlingSelector =
         new FastFailSquareThrottleSelector(0.5f);

      public static void InitializeFastFailResource(FastFailResourceConfig defaultConfig, string apiName) {
         FastFail.ConfigureResource(
            apiName,
            new FastFailResourceConfig(defaultConfig, apiName, true));

         FastFail.RegisterNpdbListener(apiName, apiName);
      }

      public static FastFailResourceConfig GetConfiguration() {
         FastFailResourceConfig configuration;

         configuration = new FastFailResourceConfig();
         configuration.MaximumThreshold = MaximumThreshold;
         configuration.MinimumThreshold = MinimumThreshold;
         configuration.CaptureTimeWindow = CaptureTimeWindow;
         configuration.ThrottlingSelector = ThrottlingSelector;

         return configuration;
      }
      public static FastFailResourceConfig GetConfiguration(float tolerance)
      {
          FastFailResourceConfig configuration;

          configuration = new FastFailResourceConfig();
          configuration.MaximumThreshold = MaximumThreshold;
          configuration.MinimumThreshold = MinimumThreshold;
          configuration.CaptureTimeWindow = CaptureTimeWindow;
          configuration.ThrottlingSelector = new FastFailThrottleSelector(tolerance);

          return configuration;
      }
   }

   #region DMP Performance Counter Categories
   [XomPerformanceCounterCategoryAttr( "FastFail: PassportCreation", "FastFail info for creation based passport requests (CreatePassport).", true )]
   public class PassportCreationCategory : FastFailPerformanceCategory {
      public PassportCreationCategory()
         : base("PassportCreation") { }

      public static PassportCreationCategory Counters = 
         new PassportCreationCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: PassportCredentials", "FastFail data for credential based passport requests (ChangePassword, GetPassportMemberName, GetPassportMemberNameAndCID, GetPassportPuid).", true )]
   public class PassportCredentialsCategory : FastFailPerformanceCategory {
      public PassportCredentialsCategory()
         : base("PassportCredentials") { }

      public static PassportCredentialsCategory Counters = new PassportCredentialsCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: PassportLogin", "FastFail data for login based passport requests (Login).", true )]
   public class PassportLoginCategory : FastFailPerformanceCategory {
      public PassportLoginCategory()
         : base("PassportLogin") { }

      public static PassportLoginCategory Counters = new PassportLoginCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: PassportUps", "FastFail data for ups based passport requests (InternalUpdateProfile).", true )]
   public class PassportUpsCategory : FastFailPerformanceCategory {
      public PassportUpsCategory()
         : base("PassportUps") { }

      public static PassportUpsCategory Counters = new PassportUpsCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: SCSCreditCard", "FastFail data for credit card based SCS requests.", true )]
   public class SCSCreditCardCategory : FastFailPerformanceCategory {
      public SCSCreditCardCategory()
         : base("SCSCreditCard") { }

      public static SCSCreditCardCategory Counters = new SCSCreditCardCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: SCSNonCreditCard", "FastFail data for non credit card based SCS requests", true )]
   public class SCSNonCreditCardCategory : FastFailPerformanceCategory {
      public SCSNonCreditCardCategory()
         : base("SCSNonCreditCard") { }

      public static SCSNonCreditCardCategory Counters = new SCSNonCreditCardCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: DmpUps", "FastFail data for ups based DMP requests (GetBalance)", true )]
   public class DmpUpsCategory : FastFailPerformanceCategory {
      public DmpUpsCategory()
         : base("DmpUps") { }

      public static DmpUpsCategory Counters = new DmpUpsCategory();
   }

   [XomPerformanceCounterCategoryAttr( "FastFail: Dmp", "FastFail data for standard DMP requests (AddPromotionalBalance, GetBalanceDetails, PurchaseItem, CancelPurchaseItem, RegisterUser, TransferBalance).", true )]
   public class DmpCategory : FastFailPerformanceCategory {
      public DmpCategory()
         : base("Dmp") { }

      public static DmpCategory Counters = new DmpCategory();
   }
   #endregion

    # region CTP Purchase Counters
   [XomPerformanceCounterCategoryAttr("FastFail: CTPPurchase", "FastFail data for CTPPurchase requests.", true)]
   public class CTPPurchase : FastFailPerformanceCategory
   {
       public CTPPurchase()
           : base("CTPPurchase") { }

       public static CTPPurchase Counters = new CTPPurchase();
   }
    # endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\DmpQueue.cs ===
using System;
using System.Security.Principal;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.billing
{
    public class DmpQueue
    {
        private static Timer m_timer = null;
        private static bool m_isStopped = false;

        static DmpQueue()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(DmpQueue.OnControlRequest);
        }

        public static uint PurchaseTransactionExpiredSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.dmp_purchaseTransactionExpiredSeconds);
            }
        }

        public static uint PurchaseTransactionConsiderFailedSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.dmp_purchaseTransactionConsiderFailedSeconds);
            }
        }

        public static uint RewardTransactionExpiredSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.dmp_rewardTransactionExpiredSeconds);
            }
        }

        public static uint PumpIntervalSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.dmp_queuePumpIntervalSeconds);
            }
        }

        public static bool PumpCancelPurchaseQueue
        {
            get
            {
                return Config.GetBoolSetting(Setting.dmp_pumpPurchasesQueue);
            }
        }

        public static bool PumpRetryRewardsQueue
        {
            get
            {
                return Config.GetBoolSetting(Setting.dmp_pumpRewardsQueue);
            }
        }

        public static void StartPump()
        {
            if ( BillingConfig.ConnectToBilling )
            {
                WindowsIdentity id = WindowsIdentity.GetCurrent();
                ThreadPool.QueueUserWorkItem(new WaitCallback(PumpFunc), id);
            }
        }

        public static void StopPump()
        {
            m_isStopped = true;

            if (m_timer != null)
            {
                m_timer.Dispose();
                m_timer = null;
            }
        }

        private static void ResetPumpTimer(WindowsIdentity id)
        {
            try
            {
                if (m_isStopped)
                    return;

                uint timerIntervalMillseconds = PumpIntervalSeconds * 1000;

                if (m_timer == null)
                    m_timer = new Timer(new TimerCallback(PumpFunc), id, timerIntervalMillseconds, Timeout.Infinite);
                else
                    m_timer.Change(timerIntervalMillseconds, Timeout.Infinite);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_38, e,
                    "Failed to reset the dmp queue timer.  DMP queues will not be processed."
                );
            }
        }

        public static void PumpFunc(object o)
        {
            WindowsIdentity identity = (WindowsIdentity) o;
            WindowsImpersonationContext impContext = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    if (identity.IsSystem == false)
                    {
                        // impersonate the thread that started this
                        impContext = identity.Impersonate();
                    }

                    UpdatePendingRewardsTotal();
                    UpdatePendingCancelsTotal();

                    if (PumpRetryRewardsQueue)
                    {
                        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                        DMPQueueCounters.Counters.AddPromotionalBalancePumpRunsTotal.Increment();

                        RetryRewardUserLoop();

                        DMPQueueCounters.Counters.AddPromotionalBalancePumpRunTime.IncrementBy(timeElapsed.TimeElapsed);
                        DMPQueueCounters.Counters.AddPromotionalBalancePumpRunTimeBase.Increment();
                    }

                    if (PumpCancelPurchaseQueue)
                    {
                        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                        DMPQueueCounters.Counters.CancelPurchasePumpRunsTotal.Increment();

                        CancelPurchaseLoop();

                        DMPQueueCounters.Counters.CancelPurchasePumpRunTime.IncrementBy(timeElapsed.TimeElapsed);
                        DMPQueueCounters.Counters.CancelPurchasePumpRunTimeBase.Increment();
                    }
                }
                finally
                {
                    try
                    {
                        if (impContext != null)
                            impContext.Undo();
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_40, e, "Failure undoing impersonation in the DMP queue pump.");
                    }
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_39, e, "Failure in the DMP queue pump.");
            }

            ResetPumpTimer(identity);
        }

        public static void UpdatePendingCancelsTotal()
        {
            int partitions = DMPClient.UserCommerceDbPartitionCount;

            int totalCancelablePurchases = 0;
            for (int partition = 0; partition < partitions; partition++)
            {
                try
                {
                    totalCancelablePurchases += DMPClient.GetCancelablePurchaseCount(partition, PurchaseTransactionExpiredSeconds);
                }
                catch (Exception e)
                {
                  Xom.NtEvent(XEvent.Id.COMMON_CONFIG_41, e, "DMPQueue unable to read count of cancelable transactions.");

                    // this isn't fatal, our count will just be wrong
                }
            }

            if (totalCancelablePurchases > 0)
            {
                string szTrace = string.Format("DMPQueue: {0} cancelable purchases found", totalCancelablePurchases);
                Xom.Trace(XomAreaName.dmptrace, LogLevel.L_NORMAL, szTrace);
            }

            DMPQueueCounters.Counters.CancelPurchasePendingTotal.RawValue = totalCancelablePurchases;
        }

        public static void CancelPurchaseLoop()
        {
            int partitions = DMPClient.UserCommerceDbPartitionCount;

            for (int partition = 0; partition < partitions; partition++)
            {
                while (true)
                {
                    DMPCancelablePurchase cancelablePurchase;
                    bool keepGoing = false;

                    try
                    {
                        cancelablePurchase = DMPClient.GetCancelablePurchase(partition,
                            PurchaseTransactionExpiredSeconds, PurchaseTransactionConsiderFailedSeconds,
                            out keepGoing);
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_42, e, 
                            "DMPQueue: DMPClient.GetCancelablePurchase failed on partition {0}, moving on to the next partition...", partition
                        );

                        // this isn't fatal, move on to the next partition
                        break;
                    }

                    if (keepGoing == true)
                    {
                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_NORMAL,
                            "DMPQueue: Giving up on transaction and moving it to the failure state");

                        continue;
                    }

                    if (cancelablePurchase == null)
                        break;

                    DMPTransactionWrapper.ResetSessionAlternateUrl();
                    if (cancelablePurchase.AlternateUrl != null)
                        DMPTransactionWrapper.SetSessionAlternateUrl(cancelablePurchase.AlternateUrl);
                    DMPClient dmpClient = new DMPClient(cancelablePurchase.CountryID);

                    DMPQueueCounters.Counters.CancelPurchaseAttemptsPerSecond.Increment();
                    DMPQueueCounters.Counters.CancelPurchaseAttemptsTotal.Increment();

                    // most auditing happens through a front door,  not a
                    // worker thread.  prime this thread with  user  puid

                    AuditStream.WriteOptional(
                        cancelablePurchase.UserPuid, AuditSubsystem.XUACS, "DmpQueue", string.Empty
                    );

                    try
                    {
                        string szTrace = string.Format("DMPQueue: Calling DMP.CancelPurchase for GUID '{0}'",
                            cancelablePurchase.TransactionGuid.ToString());
                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_NORMAL, szTrace);

                        dmpClient.TryCancelPurchase(cancelablePurchase.UserPuid, cancelablePurchase.UserPassportPuid,
                            cancelablePurchase.TransactionGuid);

                        DMPQueueCounters.Counters.CancelPurchasePendingTotal.Decrement();
                    }
                    catch
                    {
                        // move on to the next purchase, cancel will be tried again later if needed
                    }
                    finally
                    {
                        // and then flush any work audited on this thread
                        AuditStream.Cleanup(/* flush = */ true);
                    }
                }
            }
        }

        public static void UpdatePendingRewardsTotal()
        {
            int partitions = DMPClient.UserCommerceDbPartitionCount;

            int totalRetryableRewards = 0;
            for (int partition = 0; partition < partitions; partition++)
            {
                try
                {
                    totalRetryableRewards += DMPClient.GetRewardForRetryCount(partition, RewardTransactionExpiredSeconds);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.COMMON_CONFIG_45, e, "DMPQueue unable to read count of retyable reward transactions.");

                    // this isn't fatal, our count will just be wrong
                }
            }

            if (totalRetryableRewards > 0)
            {
                string szTrace = string.Format("DMPQueue: {0} retryable rewards found", totalRetryableRewards);
                Xom.Trace(XomAreaName.dmptrace, LogLevel.L_NORMAL, szTrace);
            }

            DMPQueueCounters.Counters.AddPromotionalBalancePendingTotal.RawValue = totalRetryableRewards;
        }

        public static void RetryRewardUserLoop()
        {
            int partitions = DMPClient.UserCommerceDbPartitionCount;

            for (int partition = 0; partition < partitions; partition++)
            {
                while (true)
                {
                    DMPRewardRetry retryableReward;

                    try
                    {
                        retryableReward = DMPClient.GetRewardForRetry(partition, RewardTransactionExpiredSeconds);
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_46, e,
                            "DMPQueue: DMPClient.GetRewardForRetry failed on partition {0}, moving on to the next partition...", partition
                        );

                        // this isn't fatal, move on to the next partition
                        break;
                    }

                    if (retryableReward == null)
                        break;

                    DMPTransactionWrapper.ResetSessionAlternateUrl();
                    if (retryableReward.AlternateUrl != null)
                        DMPTransactionWrapper.SetSessionAlternateUrl(retryableReward.AlternateUrl);
                    DMPClient dmpClient = new DMPClient(retryableReward.CountryID);

                    DMPQueueCounters.Counters.AddPromotionalBalanceAttemptsPerSecond.Increment();
                    DMPQueueCounters.Counters.AddPromotionalBalanceAttemptsTotal.Increment();

                    // most auditing happens through a front door,  not a
                    // worker thread.  prime this thread with  user  puid

                    AuditStream.WriteOptional(
                        retryableReward.UserPuid, AuditSubsystem.DMP, "DmpQueue", string.Empty
                    );

                    try
                    {
                        string szTrace = string.Format("DMPQueue: Retrying DMP.RewardUser for GUID '{0}'",
                            retryableReward.TransactionGuid.ToString());
                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_NORMAL, szTrace);

                        dmpClient.TryRewardUser(retryableReward.TransactionGuid, retryableReward.UserPuid,
                            retryableReward.UserPassportPuid, retryableReward.RewardID, retryableReward.CultureID, true);

                        DMPQueueCounters.Counters.AddPromotionalBalancePendingTotal.Decrement();
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_47, e, 
                            "DMPQueue: dmpClient.TryRewardUser failed on transactionGuid '{0}', moving on to the next transaction...", retryableReward.TransactionGuid
                        );

                        // this isn't fatal, move on to the next reward
                    }
                    finally
                    {
                        // and then flush any work audited on this thread
                        AuditStream.Cleanup(/* flush = */ true);
                    }
                }
            }
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();
            switch (args.Command)
            {
            case "help":
                XomControlConnection.SendMessage(
                    "DmpQueue help:\r\n" +
                    "DmpDequeue -- Force the DmpQueue to start processing queued items\n\r\n\r",
                    args.RequestId);
                args.Handled = true;
                break;

            case "dmpdq":
            case "dmpdequeue":
                DmpQueue.PumpFunc(WindowsIdentity.GetCurrent());
                args.Handled = true;
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

BdkErrorAutoGen.cs: $(SCS_BDK_ERROR_XML) BdkErrorAutoGen.xsl
    @
    cscript /e:jscript /nologo TransformXml.js $(XONEXTPATH)\SCS\$(SCS_SDK)\inc\BdkError.xml BdkErrorAutoGen.xsl $@ & \
    if errorlevel 1 echo NMAKE : TransformXml.js: error transforming $@

clean:
    del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ImageLoadPermissions.cs ===
using System;
using System.IO;
using System.Security.Cryptography;

using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.blacklist;
using xonline.common.xcrypto;

namespace xonline.common.billing
{
    public class ImageLoadUtil
    {
        private const EContainerClasses CONTAINER_CLASS = EContainerClasses.Drm;
        protected RNGCryptoServiceProvider _rng = null;

        private static volatile ImageLoadUtil _global = null;
        public static ImageLoadUtil Global
        {
            get
            {
                if(_global == null)
                {
                    lock(typeof(ImageLoadUtil))
                    {
                        if(_global == null)
                        {
                            ImageLoadUtil ilu;
                            ilu = new ImageLoadUtil();
                            ilu.Init();

                            _global = ilu;
                        }
                    }
                }

                return _global;
            }
        }

        // Init
        // Initialize ImageLoadUtil object.
        public void Init()
        {
            _rng = new RNGCryptoServiceProvider();
        }

        public XeGetRevocationListReply GetRevocationList(XeGetRevocationListRequest req)
        {
            //
            // set up the image hash blacklist if it isn't already set up
            //

            XbosListMgr.Init();

            //
            // retrieve list of digests
            //

            XSigDigest[] digests = XbosListMgr.DigestBlackList.GetDigestList();

            int digestCount = digests.Length;

            if(digestCount > XOn.REVOCATION_LIST_MAX_ENTRIES)
            {
              Xom.NtEvent(XEvent.Id.COMMON_CONFIG_50,
                           "Number of banned digests in t_blacklisted_digests exceeded " + XOn.REVOCATION_LIST_MAX_ENTRIES + ". "+
                           "The list of digests returned by XGetRevocationList will be truncated.");

                digestCount = (int) XOn.REVOCATION_LIST_MAX_ENTRIES;
            }

            //
            // prepare reply
            //

            XeGetRevocationListReply reply = new XeGetRevocationListReply();


            // generate random server nonce
            reply.serverNonce = new byte[XOn.REVOCATION_LIST_SERVER_NONCE_SIZE];
            _rng.GetBytes(reply.serverNonce);

            reply.numListEntries = (uint) digestCount;
            reply.entries = new RevocationListEntry[digestCount];

            for(int i=0; i < reply.entries.Length; i++)
            {
                RevocationListEntry entry = new RevocationListEntry();
                entry.digest = digests[i].digestBytes;
                reply.entries[i] = entry;
            }

            //
            // generate reply's hash for the signature using the following
            // scheme: hash = Sha1(client-nonce | server-nonce | H1 | ... | Hn)
            //

            MemoryStream signatureMaterial = new MemoryStream((int)(
                XOn.REVOCATION_LIST_SERVER_NONCE_SIZE +
                XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE +
                XOn.REVOCATION_LIST_ENTRY_DIGEST_SIZE * digestCount));

            using (BinaryWriter signatureMaterialWriter = new BinaryWriter(signatureMaterial))
            {
                signatureMaterialWriter.Write(req.clientNonce);
                signatureMaterialWriter.Write(reply.serverNonce);

                for(int i=0; i < reply.entries.Length; i++)
                {
                    signatureMaterialWriter.Write(reply.entries[i].digest);
                }

                byte[] hash;
                using(SHA1Managed sha1 = new SHA1Managed())
                {
                    hash = sha1.ComputeHash(signatureMaterial.ToArray());
                }

                //
                // generate signature = RsaesPkcs1V1_5(DrmKey, hash)
                //

                reply.signature = new byte[XOn.REVOCATION_LIST_SIGNATURE_SIZE];

                UInt32 sigLen = 0;
                CryptoKeyProxy.Sign(CONTAINER_CLASS, hash, reply.signature, out sigLen);
                Assert.AreEqual(sigLen, XOn.REVOCATION_LIST_SIGNATURE_SIZE);
            }

            return reply;
        }

        public bool VerifySignature(byte[] hash, byte[] signature)
        {
            Assert.AreEqual(hash.Length, 20);
            Assert.AreEqual(signature.Length, XOn.REVOCATION_LIST_SIGNATURE_SIZE);

            return CryptoKeyProxy.VerifySignature(CONTAINER_CLASS, hash, signature);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\GetSubscriptionInfoSchema.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.1.4322.573.

// NOTES:
// 1. This schema is based on SPK 2.6

// 2. Changes to the auto-generated file
// <== additions made to this file are within markers ==>
// /== prefaces one line changes... 

// if you re-autogenerate this file, you should replace these areas or you will 
// lose functionality from these classes.

// 3. I opted to keep the long names generated by the tool to minimize the amount of work we'll need to do 
//    to update this schema as SCS changes it... 


namespace  xonline.common.billing 
{

    //<==
    public class BillingConstants
    {
        public const string SubscriptionInfoEnabledString = "ENABLED";
        public const string SubscriptionInfoExpiredString = "EXPIRED";
        public const string SubscriptionInfoCancelledString = "CANCELLED";
        public const string BaseServiceOfferingGUID = "BBBE8103-BB3C-40CD-96BD-A37A7CA73314";
    }
    //==>

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
    public class SubscriptionInfoSet 
    {
    
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SubscriptionInfo")]
        public SubscriptionInfoSetSubscriptionInfo[] Items;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfo 
    {
    
        /// <remarks/>
        public string SubscriptionId;
    
        /// <remarks/>
        public string AnniversaryDate;
    
        /// <remarks/>
        public string OfferingGUID;
    
        /// <remarks/>
        public string SubscriptionDescription;
    
        /// <remarks/>
        public string SubscriptionPriceDescription;
    
        /// <remarks/>
        public string InternalSubscriptionDescription;
    
        /// <remarks/>
        public string FriendlyName;
    
        /// <remarks/>
        public string ShippingAddressId;
    
        /// <remarks/>
        public string PurchaseDate;
    
        /// <remarks/>
        public string ActivationDate;
    
        /// <remarks/>
        public string EndDate;
    
        /// <remarks/>
        public string BillingPeriod;
    
        /// <remarks/>
        public string RenewalGracePeriod;
    
        /// <remarks/>
        public string RenewOfferingId;
    
        /// <remarks/>
        public string PaymentInstrumentId;
    
        /// <remarks/>
        public string TermCommitCyclesRemaining;
    
        /// <remarks/>
        public string SubscriptionCoBrand;
    
        /// <remarks/>
        public string CurrentSubscriptionAgreementId;
    
        /// <remarks/>
        public string CurrentSubscriptionAgreementVersion;
    
        /// <remarks/>
        public string CurrentSubscriptionAgreementName;
    
        // /== converted from array to single instance
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SubscriptionStatusInfo")]
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo SubscriptionStatusInfo;
    
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DelayedConversion")]
        public SubscriptionInfoSetSubscriptionInfoDelayedConversion[] DelayedConversion;
    
        // /== changed from multi- to single-dimension array
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("ServiceInstance", typeof(SubscriptionInfoSetSubscriptionInfoServiceInstanceSetServiceInstance), IsNullable=false)]
        public SubscriptionInfoSetSubscriptionInfoServiceInstanceSetServiceInstance[] ServiceInstanceSet;

        // /== changed from multi- to single-dimension array
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("SignatureInfo", typeof(SubscriptionInfoSetSubscriptionInfoSignatureInfoSetSignatureInfo), IsNullable=false)]
        public SubscriptionInfoSetSubscriptionInfoSignatureInfoSetSignatureInfo[] SignatureInfoSet;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfo 
    {
    
        /// <remarks/>
        public string SubscriptionStatus;
    
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ViolationSet")]
        public SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet[] ViolationSet;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSubscriptionStatusInfoViolationSet 
    {
    
        /// <remarks/>
        public string ViolationId;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoSignatureInfoSetSignatureInfo 
    {
    
        /// <remarks/>
        public string SignedPolicyId;
    
        /// <remarks/>
        public string SignedPolicyVersion;
    
        /// <remarks/>
        public string SignedPolicyName;
    
        /// <remarks/>
        public string SignatureDate;
    
        /// <remarks/>
        public string PuidHigh;
    
        /// <remarks/>
        public string PuidLow;
    
        /// <remarks/>
        public string CurrentVersionOfSignedPolicy;
    
        /// <remarks/>
        public string CurrentVersionsName;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoServiceInstanceSetServiceInstance 
    {
    
        /// <remarks/>
        public string ServiceInstanceId;
    
        /// <remarks/>
        public string ServiceComponentId;
    
        /// <remarks/>
        public string ProvisioningStatus;
    
        /// <remarks/>
        public string ProvisioningErrorCode;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
    public class SubscriptionInfoSetSubscriptionInfoDelayedConversion 
    {
    
        /// <remarks/>
        public string OfferingGUID;
    
        /// <remarks/>
        public string ConversionDate;
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\MigrateUserTable.cs ===
/*
 * MigrateUserTable.cs
 *
 * MigrateUser tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;                           // Exception
using System.IO;                        // StringWriter
using System.Collections.Generic;       // Dictionary<T,T>
using System.Xml;                       // XmlNode

using Microsoft.Webstore.WstClient;     // WstDataReader

using xonline.common.config;            // ConfigUtil
using xonline.common.sql.webstore;      // WSClient

namespace xonline.common.billing.migrateuser
{
    internal class TableList
    {
        private string databaseName;
        private Dictionary<string, Table> tables = new Dictionary<string, Table>();

        public TableList(string dName)
        {
            databaseName = dName;
        }

        public void Add(string tableName,
                        string tableHash,
                        string primaryColumnName,
                        ulong primaryColumnValue)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(primaryColumnValue);
                Add(ws, tableName, tableHash, primaryColumnName, primaryColumnValue.ToString());
            }
        }

        public void Add(string tableName,
                        string tableHash,
                        string primaryColumnName,
                        long primaryColumnValue)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(primaryColumnValue);
                Add(ws, tableName, tableHash, primaryColumnName, primaryColumnValue.ToString());
            }
        }

        public void Add(string tableName,
                        string tableHash,
                        string primaryColumnName,
                        string primaryColumnValue)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(primaryColumnValue);
                Add(ws, tableName, tableHash, primaryColumnName, primaryColumnValue);
            }
        }

        private void Add(   WSClient ws,
                            string tableName,
                            string tableHash,
                            string primaryColumnName,
                            string primaryColumnValue)
        {
            StringList primaryColumnValues = new StringList();
            primaryColumnValues.Add(primaryColumnValue);
            Add(ws,
                tableName,
                tableHash,
                primaryColumnName,
                primaryColumnValues);
        }

        private void Add(   WSClient ws,
                            string tableName,
                            string tableHash,
                            string primaryColumnName,
                            StringList primaryColumnValues)
        {
            if (Table.RowsHaveData(ws, databaseName, tableName, primaryColumnName, primaryColumnValues))
            {
                Table table = new Table(ws, databaseName, tableName, tableHash, primaryColumnName);
                tables.Add(tableName, table);
                AddRows(ws,table,primaryColumnValues);
            }
        }

        private void AddRows(   WSClient ws,
                                Table table,
                                StringList primaryColumnValues)
        {
            foreach (string value in primaryColumnValues)
            {
                table.LoadRow(ws, value);
            }
            AddDependencies(ws, table);
        }

        private void AddDependencies(WSClient ws, Table table)
        {
            foreach (TableDependency tableDependency in table.TableDependencies)
            {
                if (!tables.ContainsKey(tableDependency.referencingTableName))
                {
                    Add(ws,
                        tableDependency.referencingTableName,
                        table.TableHash,
                        tableDependency.referencingColumnName,
                        table.Columns[tableDependency.currentColumnName].RowData);
                }
                else
                {
                    AddRows(ws,
                            tables[tableDependency.referencingTableName],
                            tables[tableDependency.referencingTableName].Columns[tableDependency.currentColumnName].RowData);
                }
            }
        }

        public void SwapValues(string oldValue, string newValue)
        {
            foreach (Table table in tables.Values)
            {
                table.SwapValues(oldValue, newValue);
            }
        }

        public void SetHashValues(int newHashValue, string tableHash)
        {
            foreach (Table table in tables.Values)
            {
                if (table.TableHash == tableHash)
                {
                    table.SetHashValues(newHashValue);
                }
            }
        }

        public void WriteToDB(string tableHash, ulong hashValue)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(hashValue);
                WriteToDB(ws, tableHash);
            }
        }

        public void WriteToDB(string tableHash, long hashValue)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(hashValue);
                WriteToDB(ws, tableHash);
            }
        }

        public void WriteToDB(string tableHash, string hashValue)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(hashValue);
                WriteToDB(ws, tableHash);
            }
        }

        private void WriteToDB(WSClient ws, string tableHash)
        {
            StringWriter sqlCommandWriter = new StringWriter();
            sqlCommandWriter.WriteLine("BEGIN TRANSACTION WriteUserToDatabase");

            foreach (Table table in tables.Values)
            {
                if (table.TableHash == tableHash)
                {
                    table.WriteToDB(sqlCommandWriter);
                }
            }

            sqlCommandWriter.WriteLine("COMMIT TRANSACTION WriteUserToDatabase");
            ws.CommandSql = sqlCommandWriter.ToString();
            ws.ExecuteNonQuery();
        }

        public bool TableExists(string tableName)
        {
            return tables.ContainsKey(tableName);
        }

        public void WriteToFile(XmlTextWriter w)
        {
            w.WriteStartElement("Tables");
                w.WriteElementString("Database_Name", databaseName);
                foreach (Table table in tables.Values)
                { table.WriteToFile(w); }
            w.WriteEndElement();
        }

        public TableList(XmlNode tablesNode)
        {
            XmlUtil.ValidateNode(tablesNode, "Tables");

            XmlNode node = tablesNode.FirstChild;
            databaseName = XmlUtil.ReadNode(node, "Database_Name");

            node = node.NextSibling;
            while (node != null)
            {
                Table table = new Table(node, databaseName);
                tables.Add(table.TableName, table);
                node = node.NextSibling;
            }
        }

        public void VerifySchema()
        {
            Printer.Print("Verifying schema...", Printer.Color.Debug);
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                foreach (Table table in tables.Values)
                {
                    table.VerifySchema(ws);
                }
            }
            Printer.Print("Verified schema!", Printer.Color.Info);
        }
    }

    internal class Table
    {
        private readonly string databaseName;
        private readonly string tableName;
        private ColumnList columns;
        private List<TableDependency> tableDependencies;

        private readonly string tableHash;
        public string TableHash { get { return tableHash; } }

        public string DatabaseName { get { return databaseName; } }
        public string TableName { get { return tableName; } }
        public ColumnList Columns { get { return columns; } }
        public List<TableDependency> TableDependencies { get { return tableDependencies; } }

        public Table(WSClient ws, string dName, string tName, string tHash, string primaryColumnName)
        {
            databaseName = dName;
            tableName = tName;
            tableHash = tHash;
            Load(ws, primaryColumnName);
        }

        public void LoadRow(WSClient ws, string primaryColumnValue)
        {
            #region validation
            if (!SqlUtil.ValidSqlValue(databaseName, tableName, columns.PrimaryColumnName, primaryColumnValue))
            {
                Printer.Print("Not a valid value: '" + primaryColumnValue + "' for column '" + databaseName + "." + tableName + "." + columns.PrimaryColumnName + "'", Printer.Color.Error);
                throw new Exception();
            }
            #endregion

            if (RowHasData(ws, primaryColumnValue))
            {
                columns.AddRow(ws, primaryColumnValue);

                Printer.Print("Successfully loaded row for Sql Table '" + databaseName + "." + tableName + "'!", Printer.Color.Info);
            }
        }

        private bool RowHasData(WSClient ws, string primaryColumnValue)
        {
            return RowHasData(ws, databaseName, tableName, columns.PrimaryColumnName, primaryColumnValue);
        }

        public static bool RowsHaveData(WSClient ws, string dName, string tName, string pColumnName, StringList pColumnValues)
        {
            bool hasData = false;

            foreach (string value in pColumnValues)
            {
                if (RowHasData(ws, dName, tName, pColumnName, value))
                {
                    hasData = true;
                }
            }

            return hasData;
        }

        public static bool RowHasData(WSClient ws, string dName, string tName, string pColumnName, string pColumnValue)
        {
            ws.CommandSql = @"  IF EXISTS
                                (
                                    SELECT 1
                                    FROM " + tName + @"
                                    WHERE " + pColumnName + @" = '" + pColumnValue + @"'
                                )
                                    SELECT 1
                                ELSE
                                    SELECT 0";

            bool hasData =  1 == (int)ws.ExecuteScalar();

            if (!hasData)
            {
                Printer.Print("table '" + dName + "." + tName + "' doesn't have a row for " + pColumnName + " = " + pColumnValue, Printer.Color.Warning);
            }
            return hasData;
        }

        private void Load(WSClient ws, string primaryColumnName)
        {
            Printer.Print("Loading Sql Table '" + databaseName + "." + tableName + "'...", Printer.Color.Debug);

            #region validation
            if (!SqlUtil.ValidSqlDatabase(databaseName))
            {
                Printer.Print("Not a valid Database: '" + databaseName + "'", Printer.Color.Error);
                throw new Exception();
            }

            if (!SqlUtil.ValidSqlTable(databaseName, tableName))
            {
                Printer.Print("Not a valid table: '" + tableName + "' for database '" + databaseName + "'", Printer.Color.Error);
                throw new Exception();
            }

            if (!SqlUtil.ValidSqlColumn(databaseName, tableName, primaryColumnName))
            {
                Printer.Print("Not a valid column: '" + primaryColumnName + "' for table '" + databaseName + "." + tableName + "'", Printer.Color.Error);
                throw new Exception();
            }
            #endregion

            columns = new ColumnList(ws, tableName, primaryColumnName);

            LoadDependantTableList(ws);
        }

        private void LoadDependantTableList(WSClient ws)
        {
            tableDependencies = new List<TableDependency>();

            try
            {
                ws.CommandSql = @"  SELECT DISTINCT
				                        OBJECT_NAME(f.parent_object_id) AS DependantTableName,
				                        COL_NAME(fc.parent_object_id, fc.parent_column_id) AS DependantColumnName,
				                        COL_NAME(fc.referenced_object_id, fc.referenced_column_id) AS CurrentColumnName
			                        FROM sys.foreign_keys AS f
				                        INNER JOIN sys.foreign_key_columns AS fc
				                        ON f.object_id = fc.constraint_object_id
			                        WHERE OBJECT_NAME (f.referenced_object_id) = '" + tableName + @"'
	                                    AND SCHEMA_NAME(f.schema_id) = 'dbo'";

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        string referencingTableName = r.GetString(0);
                        string referencingColumnName = r.GetString(1);
                        string currentColumnName = r.GetString(2);

                        Printer.Print("    current table (" + tableName + ") has a column (" + currentColumnName + ") referenced by " + referencingTableName + "." + referencingColumnName, Printer.Color.Debug);

                        tableDependencies.Add(new TableDependency(referencingTableName, referencingColumnName, currentColumnName));
                    }
                }
            }
            catch (Exception e)
            {
                Printer.Print("Failed to load dependent tables for table '" + databaseName + "." + tableName + "' Exception: " + e.Message, Printer.Color.Error);
                throw e;
            }
        }

        public void SwapValues(string oldValue, string newValue)
        {
            columns.SwapValues(oldValue, newValue);
        }

        public void SetHashValues(int newHashValue)
        {
            columns.SetHashValues(newHashValue);
        }

        public void WriteToDB(StringWriter sqlCommandWriter)
        {
            Columns.WriteToDB(sqlCommandWriter);
        }

        public void WriteToFile(XmlTextWriter w)
        {
            w.WriteStartElement("Table");
                w.WriteElementString("Table_Name", tableName);
                w.WriteElementString("Table_Hash", tableHash);
                w.WriteStartElement("Columns");
                    columns.WriteToFile(w);
                w.WriteEndElement();
            w.WriteEndElement();
        }

        public Table(XmlNode tableNode, string dName)
        {
            databaseName = dName;
            XmlUtil.ValidateNode(tableNode, "Table");

            XmlNode node = tableNode.FirstChild;
            tableName = XmlUtil.ReadNode(node, "Table_Name");

            node = node.NextSibling;
            tableHash = XmlUtil.ReadNode(node, "Table_Hash");

            node = node.NextSibling;
            columns = new ColumnList(node, tableName);
        }

        public void VerifySchema(WSClient ws)
        {
            columns.VerifySchema(ws);
        }
    }

    internal class ColumnList
    {
        private const string HASH_COLUMN = "si_hash_bucket";

        private string tableName;
        private Dictionary<string, Column> columns = new Dictionary<string, Column>();
        private Column primaryColumn = null;
        
        public string PrimaryColumnName { get { return primaryColumn.ColumnName; } }
        public Column this[string columnName] { get { return columns[columnName]; } }

        public ColumnList(WSClient ws, string tName, string primaryColumnName)
        {
            tableName = tName;

            try
            {
                ws.CommandSql = @"  SELECT COLUMN_NAME, DATA_TYPE
                                    FROM INFORMATION_SCHEMA.COLUMNS
                                    WHERE TABLE_NAME = '" + tableName + @"'
                                    ORDER BY COLUMN_NAME ASC";

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        string columnName = r.GetString(0);
                        string dataType = r.GetString(1);
                        Column c = new Column(tableName, columnName, dataType);
                        columns.Add(columnName,c);
                        if (columnName == primaryColumnName) primaryColumn = c;
                    }
                }

                if (primaryColumn == null)
                {
                    Printer.Print("Unable to find primary column (" + primaryColumnName + ") for table " + tableName, Printer.Color.Error);
                    throw new Exception();
                }
            }
            catch (Exception e)
            {
                Printer.Print("Failed to load column names for table " + tableName + " off of primary column " + primaryColumnName + ". Exception : " + e.Message, Printer.Color.Error);
                throw e;
            }
        }

        public void AddRow(WSClient ws, string primaryColumnValue)
        {
            foreach (Column c in columns.Values)
            {
                c.AddRowItems(ws, primaryColumn.ColumnName, primaryColumnValue);
            }
        }

        public void SwapValues(string oldValue, string newValue)
        {
            foreach (Column column in columns.Values)
            {
                column.SwapValues(oldValue, newValue);
            }
        }

        public void SetHashValues(int newHashValue)
        {
            int hashColumnCount = 0;

            foreach (Column column in columns.Values)
            {
                if (string.Equals(column.ColumnName, HASH_COLUMN, StringComparison.CurrentCultureIgnoreCase))
                {
                    column.SetAllValuesTo(newHashValue.ToString());
                    hashColumnCount++;
                }
            }

            if (hashColumnCount == 0)
            {
                Printer.Print("Error: " + tableName + " doesn't have a hash column (" + HASH_COLUMN + ")", Printer.Color.Error);
                throw new Exception();
            }

            if (hashColumnCount > 1)
            {
                Printer.Print("Error: " + tableName + " has too many hash columns... what's up with that?", Printer.Color.Error);
                throw new Exception();
            }
        }

        public void WriteToDB(StringWriter sqlCommandWriter)
        {
            for(int i = 0; i < primaryColumn.RowCount; i++)
            {
                sqlCommandWriter.Write("INSERT INTO " + tableName + " (");
                bool first = true;
                foreach(Column column in columns.Values)
                {
                    if(!first)
                    {
                        sqlCommandWriter.Write(", ");
                    }
                    first = false;
                    sqlCommandWriter.Write(column.ColumnName);
                }

                sqlCommandWriter.Write(") VALUES (");

                first = true;
                foreach (Column column in columns.Values)
                {
                    if (!first) { sqlCommandWriter.Write(", "); }
                    first = false;

                    sqlCommandWriter.Write(column.ToSql(i));
                }

                sqlCommandWriter.WriteLine(")");
            }
        }

        public void WriteToFile(XmlTextWriter w)
        {
            w.WriteElementString("Primary_Column", PrimaryColumnName);
            foreach (Column column in columns.Values)
            {
                column.WriteToFile(w);
            }
        }

        public ColumnList(XmlNode columnsNode, string tName)
        {
            tableName = tName;
            XmlUtil.ValidateNode(columnsNode, "Columns");

            XmlNode node = columnsNode.FirstChild;
            string primaryColumnName = XmlUtil.ReadNode(node, "Primary_Column");

            node = node.NextSibling;
            while (node != null)
            {
                Column column = new Column(node, tName);
                columns.Add(column.ColumnName, column);
                if (column.ColumnName == primaryColumnName)
                    { primaryColumn = column; }

                node = node.NextSibling;
            }
        }

        public void VerifySchema(WSClient ws)
        {
            ColumnList newSchema = new ColumnList(ws, tableName, PrimaryColumnName);

            if (columns.Count != newSchema.columns.Count)
            {
                string errorString = "Table '" + tableName + "' has a different number of rows than expected! (expected " + columns.Count + " but has " + newSchema.columns.Count + ")";
                Printer.Print(errorString, Printer.Color.Error);
                throw new Exception(errorString);
            }

            foreach (string columnName in columns.Keys)
            {
                if (!newSchema.columns.ContainsKey(columnName))
                {
                    string errorString = "Table '" + tableName + "' doesn't have expected column named '" + columnName + "'";
                    Printer.Print(errorString, Printer.Color.Error);
                    throw new Exception(errorString);
                }

                if (columns[columnName].DataType != newSchema.columns[columnName].DataType)
                {
                    string errorString = "Table '" + tableName + "' has a column with an unexpected data type! (column '" + columnName + "' was expected to be '" + columns[columnName].DataType + "' but is '" + newSchema.columns[columnName].DataType + "')";
                    Printer.Print(errorString, Printer.Color.Error);
                    throw new Exception(errorString);
                }
            }
        }
    }

    internal class Column
    {
        private string dataType;
        public string DataType { get { return dataType; } }

        private readonly string tableName;

        private readonly string columnName;
        public string ColumnName { get { return columnName; } }

        private StringList rowData = new StringList();
        public StringList RowData { get { return rowData; } }
        public int RowCount { get { return rowData.Count; } }

        public Column(string tName, string cName, string dType)
        {
            tableName = tName;
            columnName = cName;
            dataType = dType;
        }

        public void AddRowItems(WSClient ws, string primaryColumnName, string primaryColumnValue)
        {
            try
            {
                ws.CommandSql = @"  SELECT " + columnName + @"
                                            FROM " + tableName + @"
                                            WHERE " + primaryColumnName + @" = '" + primaryColumnValue + "'";

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        FromSql(r.GetValue(0));
                    }
                }
            }
            catch (Exception e)
            {
                Printer.Print(" Failed to load column data for column " + tableName + "." + columnName + " off of primary column " + primaryColumnName + " (" + primaryColumnValue + "). Exception : " + e.Message, Printer.Color.Error);
                throw e;
            }
        }

        public void SwapValues(string oldValue, string newValue)
        {
            for (int i = 0; i < rowData.Count; i++)
            {
                if (rowData[i] == oldValue)
                {
                    rowData[i] = newValue;
                    Printer.Print("        Performed a swap in " + tableName + "." + columnName + " ( " + oldValue + " ) ==> ( " + newValue + " )", Printer.Color.Warning);
                }
            }
        }

        public void SetAllValuesTo(string newValue)
        {
            for (int i = 0; i < rowData.Count; i++)
            {
                rowData[i] = newValue;
            }
        }

        public void WriteToFile(XmlTextWriter w)
        {
            w.WriteStartElement("Column");
                w.WriteElementString("Column_Name", columnName);
                w.WriteElementString("Data_Type", dataType);
                w.WriteStartElement("Rows");
                    foreach (string rowData in RowData)
                    { w.WriteElementString("Item", rowData); }
                w.WriteEndElement();
            w.WriteEndElement();
        }

        public Column(XmlNode columnNode, string tName)
        {
            tableName = tName;
            XmlUtil.ValidateNode(columnNode, "Column");

            XmlNode node = columnNode.FirstChild;
            columnName = XmlUtil.ReadNode(node, "Column_Name");

            node = node.NextSibling;
            dataType = XmlUtil.ReadNode(node, "Data_Type");

            node = node.NextSibling;
            XmlUtil.ValidateNode(node, "Rows");
            foreach (XmlNode rowNode in node.ChildNodes)
            {
                rowData.Add(XmlUtil.ReadNode(rowNode, "Item"));
            }
        }

        public string ToSql(int i)
        {
            if (rowData[i] == ""
            && DataType != "char"
            && DataType != "nchar"
            && DataType != "varchar"
            && DataType != "nvarchar"
            && DataType != "text"
            && DataType != "ntext")
            {
                return "NULL";
            }

            switch(DataType)
            {
                case "char":
                case "nchar":
                case "varchar":
                case "nvarchar":
                case "text":
                case "ntext":
                case "date":
                case "time":
                case "datetime":
                case "smalldatetime":
                case "datetimeoffset":
                case "datetime2":
                case "xml":
                    return "'" + rowData[i] + "'";

                case "uniqueidentifier":
                    return "newid()";

                case "timestamp":
                    return "DEFAULT";

                default:
                    return rowData[i];
            }
        }

        private void FromSql(Object o)
        {
            string s;
            if (o is Array)
            {
                s = BitConverter.ToString((byte[])o);
                s = String.Join("", s.Split('-'));
            }
            else
            {
                s = o.ToString();
            }

            if(DataType == "binary"
            || DataType == "varbinary"
            || DataType == "image"
            || DataType == "timestamp"
            || DataType == "hierarchyid")
            {
                s = "0x" + s;
            }

            rowData.Add(s);
        }
    }

    internal class TableDependency
    {
        public readonly string referencingTableName;
        public readonly string referencingColumnName;
        public readonly string currentColumnName;

        public TableDependency(string rTableName, string rColumnName, string cColumnName)
        {
            referencingTableName = rTableName;
            referencingColumnName = rColumnName;
            currentColumnName = cColumnName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\dmpwsdl.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.1432.
// 
namespace DMPWSDL {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="DMPTransactionSoap", Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class DMPTransaction : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AddProvisionedBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddPromotionalBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback RegisterUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateRegistrationOperationCompleted;
        
        private System.Threading.SendOrPostCallback PurchaseItemOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelPurchaseItemOperationCompleted;
        
        private System.Threading.SendOrPostCallback TransferBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback TransferPointsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetBalanceDetailsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetStatementOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSingleTransactionHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetUserPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetBalancePolicyOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreditBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback DebitBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SyncUpsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ExchangePointsOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        /// <remarks/>
        public DMPTransaction() {
            this.Url = "https://vm1box/DMPTransaction/Transaction.asmx";
        }
        
        /// <remarks/>
        public event AddProvisionedBalanceCompletedEventHandler AddProvisionedBalanceCompleted;
        
        /// <remarks/>
        public event AddPromotionalBalanceCompletedEventHandler AddPromotionalBalanceCompleted;
        
        /// <remarks/>
        public event RegisterUserCompletedEventHandler RegisterUserCompleted;
        
        /// <remarks/>
        public event UpdateRegistrationCompletedEventHandler UpdateRegistrationCompleted;
        
        /// <remarks/>
        public event PurchaseItemCompletedEventHandler PurchaseItemCompleted;
        
        /// <remarks/>
        public event CancelPurchaseItemCompletedEventHandler CancelPurchaseItemCompleted;
        
        /// <remarks/>
        public event TransferBalanceCompletedEventHandler TransferBalanceCompleted;
        
        /// <remarks/>
        public event TransferPointsCompletedEventHandler TransferPointsCompleted;
        
        /// <remarks/>
        public event GetBalanceCompletedEventHandler GetBalanceCompleted;
        
        /// <remarks/>
        public event GetBalanceDetailsCompletedEventHandler GetBalanceDetailsCompleted;
        
        /// <remarks/>
        public event GetStatementCompletedEventHandler GetStatementCompleted;
        
        /// <remarks/>
        public event GetSingleTransactionHistoryCompletedEventHandler GetSingleTransactionHistoryCompleted;
        
        /// <remarks/>
        public event GetStatusCompletedEventHandler GetStatusCompleted;
        
        /// <remarks/>
        public event SetStatusCompletedEventHandler SetStatusCompleted;
        
        /// <remarks/>
        public event GetUserPropertiesCompletedEventHandler GetUserPropertiesCompleted;
        
        /// <remarks/>
        public event SetUserPropertiesCompletedEventHandler SetUserPropertiesCompleted;
        
        /// <remarks/>
        public event GetBalancePolicyCompletedEventHandler GetBalancePolicyCompleted;
        
        /// <remarks/>
        public event CreditBalanceCompletedEventHandler CreditBalanceCompleted;
        
        /// <remarks/>
        public event DebitBalanceCompletedEventHandler DebitBalanceCompleted;
        
        /// <remarks/>
        public event SyncUpsCompletedEventHandler SyncUpsCompleted;
        
        /// <remarks/>
        public event ExchangePointsCompletedEventHandler ExchangePointsCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/AddProvisionedBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string AddProvisionedBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, out Receipt receipt) {
            object[] results = this.Invoke("AddProvisionedBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        SKU,
                        campaignId,
                        mode,
                        acquisitionTitle,
                        acquisitionType});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddProvisionedBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddProvisionedBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        SKU,
                        campaignId,
                        mode,
                        acquisitionTitle,
                        acquisitionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndAddProvisionedBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddProvisionedBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType) {
            this.AddProvisionedBalanceAsync(trackingGuid, targetUser, delegateUser, tenantId, balanceToAdd, externalReferenceId, SKU, campaignId, mode, acquisitionTitle, acquisitionType, null);
        }
        
        /// <remarks/>
        public void AddProvisionedBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, object userState) {
            if ((this.AddProvisionedBalanceOperationCompleted == null)) {
                this.AddProvisionedBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddProvisionedBalanceOperationCompleted);
            }
            this.InvokeAsync("AddProvisionedBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        SKU,
                        campaignId,
                        mode,
                        acquisitionTitle,
                        acquisitionType}, this.AddProvisionedBalanceOperationCompleted, userState);
        }
        
        private void OnAddProvisionedBalanceOperationCompleted(object arg) {
            if ((this.AddProvisionedBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddProvisionedBalanceCompleted(this, new AddProvisionedBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/AddPromotionalBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string AddPromotionalBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, out Receipt receipt) {
            object[] results = this.Invoke("AddPromotionalBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        promotionalSKU,
                        campaignId,
                        expirationLength,
                        acquisitionTitle,
                        acquisitionType});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddPromotionalBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddPromotionalBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        promotionalSKU,
                        campaignId,
                        expirationLength,
                        acquisitionTitle,
                        acquisitionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndAddPromotionalBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddPromotionalBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType) {
            this.AddPromotionalBalanceAsync(trackingGuid, targetUser, delegateUser, tenantId, balanceToAdd, externalReferenceId, promotionalSKU, campaignId, expirationLength, acquisitionTitle, acquisitionType, null);
        }
        
        /// <remarks/>
        public void AddPromotionalBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, object userState) {
            if ((this.AddPromotionalBalanceOperationCompleted == null)) {
                this.AddPromotionalBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddPromotionalBalanceOperationCompleted);
            }
            this.InvokeAsync("AddPromotionalBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        promotionalSKU,
                        campaignId,
                        expirationLength,
                        acquisitionTitle,
                        acquisitionType}, this.AddPromotionalBalanceOperationCompleted, userState);
        }
        
        private void OnAddPromotionalBalanceOperationCompleted(object arg) {
            if ((this.AddPromotionalBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddPromotionalBalanceCompleted(this, new AddPromotionalBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/RegisterUser", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string RegisterUser(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt) {
            object[] results = this.Invoke("RegisterUser", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRegisterUser(System.Guid trackingGuid, long targetUser, long delegateUser, string country, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RegisterUser", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndRegisterUser(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void RegisterUserAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country) {
            this.RegisterUserAsync(trackingGuid, targetUser, delegateUser, country, null);
        }
        
        /// <remarks/>
        public void RegisterUserAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country, object userState) {
            if ((this.RegisterUserOperationCompleted == null)) {
                this.RegisterUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRegisterUserOperationCompleted);
            }
            this.InvokeAsync("RegisterUser", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, this.RegisterUserOperationCompleted, userState);
        }
        
        private void OnRegisterUserOperationCompleted(object arg) {
            if ((this.RegisterUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RegisterUserCompleted(this, new RegisterUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/UpdateRegistration", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateRegistration(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt) {
            object[] results = this.Invoke("UpdateRegistration", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateRegistration(System.Guid trackingGuid, long targetUser, long delegateUser, string country, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateRegistration", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndUpdateRegistration(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateRegistrationAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country) {
            this.UpdateRegistrationAsync(trackingGuid, targetUser, delegateUser, country, null);
        }
        
        /// <remarks/>
        public void UpdateRegistrationAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country, object userState) {
            if ((this.UpdateRegistrationOperationCompleted == null)) {
                this.UpdateRegistrationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateRegistrationOperationCompleted);
            }
            this.InvokeAsync("UpdateRegistration", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, this.UpdateRegistrationOperationCompleted, userState);
        }
        
        private void OnUpdateRegistrationOperationCompleted(object arg) {
            if ((this.UpdateRegistrationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateRegistrationCompleted(this, new UpdateRegistrationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/PurchaseItem", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string PurchaseItem(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, out Receipt receipt) {
            object[] results = this.Invoke("PurchaseItem", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        itemSet,
                        context});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseItem(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PurchaseItem", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        itemSet,
                        context}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndPurchaseItem(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void PurchaseItemAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context) {
            this.PurchaseItemAsync(trackingGuid, targetUser, delegateUser, itemSet, context, null);
        }
        
        /// <remarks/>
        public void PurchaseItemAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, object userState) {
            if ((this.PurchaseItemOperationCompleted == null)) {
                this.PurchaseItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseItemOperationCompleted);
            }
            this.InvokeAsync("PurchaseItem", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        itemSet,
                        context}, this.PurchaseItemOperationCompleted, userState);
        }
        
        private void OnPurchaseItemOperationCompleted(object arg) {
            if ((this.PurchaseItemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseItemCompleted(this, new PurchaseItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/CancelPurchaseItem", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string CancelPurchaseItem(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, out Receipt receipt) {
            object[] results = this.Invoke("CancelPurchaseItem", new object[] {
                        targetUser,
                        delegateUser,
                        trackingGuidOriginal});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelPurchaseItem(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelPurchaseItem", new object[] {
                        targetUser,
                        delegateUser,
                        trackingGuidOriginal}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCancelPurchaseItem(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CancelPurchaseItemAsync(long targetUser, long delegateUser, System.Guid trackingGuidOriginal) {
            this.CancelPurchaseItemAsync(targetUser, delegateUser, trackingGuidOriginal, null);
        }
        
        /// <remarks/>
        public void CancelPurchaseItemAsync(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, object userState) {
            if ((this.CancelPurchaseItemOperationCompleted == null)) {
                this.CancelPurchaseItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelPurchaseItemOperationCompleted);
            }
            this.InvokeAsync("CancelPurchaseItem", new object[] {
                        targetUser,
                        delegateUser,
                        trackingGuidOriginal}, this.CancelPurchaseItemOperationCompleted, userState);
        }
        
        private void OnCancelPurchaseItemOperationCompleted(object arg) {
            if ((this.CancelPurchaseItemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelPurchaseItemCompleted(this, new CancelPurchaseItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TransferBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TransferBalance(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt) {
            object[] results = this.Invoke("TransferBalance", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context});
            sourceReceipt = ((Receipt)(results[1]));
            transferReceipt = ((Receipt)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferBalance", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTransferBalance(System.IAsyncResult asyncResult, out Receipt sourceReceipt, out Receipt transferReceipt) {
            object[] results = this.EndInvoke(asyncResult);
            sourceReceipt = ((Receipt)(results[1]));
            transferReceipt = ((Receipt)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TransferBalanceAsync(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context) {
            this.TransferBalanceAsync(trackingGuid, sourceUser, transferUser, delegateUser, pointsToTransfer, context, null);
        }
        
        /// <remarks/>
        public void TransferBalanceAsync(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, object userState) {
            if ((this.TransferBalanceOperationCompleted == null)) {
                this.TransferBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferBalanceOperationCompleted);
            }
            this.InvokeAsync("TransferBalance", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context}, this.TransferBalanceOperationCompleted, userState);
        }
        
        private void OnTransferBalanceOperationCompleted(object arg) {
            if ((this.TransferBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferBalanceCompleted(this, new TransferBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TransferPoints", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TransferPoints(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransferTransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt) {
            object[] results = this.Invoke("TransferPoints", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context});
            sourceReceipt = ((Receipt)(results[1]));
            transferReceipt = ((Receipt)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferPoints(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransferTransactionContext context, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferPoints", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTransferPoints(System.IAsyncResult asyncResult, out Receipt sourceReceipt, out Receipt transferReceipt) {
            object[] results = this.EndInvoke(asyncResult);
            sourceReceipt = ((Receipt)(results[1]));
            transferReceipt = ((Receipt)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TransferPointsAsync(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransferTransactionContext context) {
            this.TransferPointsAsync(trackingGuid, sourceUser, transferUser, delegateUser, pointsToTransfer, context, null);
        }
        
        /// <remarks/>
        public void TransferPointsAsync(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransferTransactionContext context, object userState) {
            if ((this.TransferPointsOperationCompleted == null)) {
                this.TransferPointsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferPointsOperationCompleted);
            }
            this.InvokeAsync("TransferPoints", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context}, this.TransferPointsOperationCompleted, userState);
        }
        
        private void OnTransferPointsOperationCompleted(object arg) {
            if ((this.TransferPointsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferPointsCompleted(this, new TransferPointsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetBalance(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out string country) {
            object[] results = this.Invoke("GetBalance", new object[] {
                        targetUser,
                        delegateUser});
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            country = ((string)(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBalance(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBalance", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetBalance(System.IAsyncResult asyncResult, out int balance, out bool aboveLowBalance, out Status statusUser, out string country) {
            object[] results = this.EndInvoke(asyncResult);
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            country = ((string)(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetBalanceAsync(long targetUser, long delegateUser) {
            this.GetBalanceAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetBalanceAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetBalanceOperationCompleted == null)) {
                this.GetBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBalanceOperationCompleted);
            }
            this.InvokeAsync("GetBalance", new object[] {
                        targetUser,
                        delegateUser}, this.GetBalanceOperationCompleted, userState);
        }
        
        private void OnGetBalanceOperationCompleted(object arg) {
            if ((this.GetBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBalanceCompleted(this, new GetBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalanceDetails", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetBalanceDetails(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out PointLot[] lots) {
            object[] results = this.Invoke("GetBalanceDetails", new object[] {
                        targetUser,
                        delegateUser});
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            lots = ((PointLot[])(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBalanceDetails(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBalanceDetails", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetBalanceDetails(System.IAsyncResult asyncResult, out int balance, out bool aboveLowBalance, out Status statusUser, out PointLot[] lots) {
            object[] results = this.EndInvoke(asyncResult);
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            lots = ((PointLot[])(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetBalanceDetailsAsync(long targetUser, long delegateUser) {
            this.GetBalanceDetailsAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetBalanceDetailsAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetBalanceDetailsOperationCompleted == null)) {
                this.GetBalanceDetailsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBalanceDetailsOperationCompleted);
            }
            this.InvokeAsync("GetBalanceDetails", new object[] {
                        targetUser,
                        delegateUser}, this.GetBalanceDetailsOperationCompleted, userState);
        }
        
        private void OnGetBalanceDetailsOperationCompleted(object arg) {
            if ((this.GetBalanceDetailsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBalanceDetailsCompleted(this, new GetBalanceDetailsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetStatement", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetStatement(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, out string nextHandle, out Transaction[] transactions) {
            object[] results = this.Invoke("GetStatement", new object[] {
                        targetUser,
                        delegateUser,
                        tenantId,
                        filter,
                        startDate,
                        endDate,
                        numTransactionsRequested,
                        startHandle});
            nextHandle = ((string)(results[1]));
            transactions = ((Transaction[])(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatement", new object[] {
                        targetUser,
                        delegateUser,
                        tenantId,
                        filter,
                        startDate,
                        endDate,
                        numTransactionsRequested,
                        startHandle}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetStatement(System.IAsyncResult asyncResult, out string nextHandle, out Transaction[] transactions) {
            object[] results = this.EndInvoke(asyncResult);
            nextHandle = ((string)(results[1]));
            transactions = ((Transaction[])(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetStatementAsync(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle) {
            this.GetStatementAsync(targetUser, delegateUser, tenantId, filter, startDate, endDate, numTransactionsRequested, startHandle, null);
        }
        
        /// <remarks/>
        public void GetStatementAsync(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, object userState) {
            if ((this.GetStatementOperationCompleted == null)) {
                this.GetStatementOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStatementOperationCompleted);
            }
            this.InvokeAsync("GetStatement", new object[] {
                        targetUser,
                        delegateUser,
                        tenantId,
                        filter,
                        startDate,
                        endDate,
                        numTransactionsRequested,
                        startHandle}, this.GetStatementOperationCompleted, userState);
        }
        
        private void OnGetStatementOperationCompleted(object arg) {
            if ((this.GetStatementCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStatementCompleted(this, new GetStatementCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetSingleTransactionHistory", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetSingleTransactionHistory(long targetUser, long delegateUser, string cId, out Transaction[] transactions) {
            object[] results = this.Invoke("GetSingleTransactionHistory", new object[] {
                        targetUser,
                        delegateUser,
                        cId});
            transactions = ((Transaction[])(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSingleTransactionHistory(long targetUser, long delegateUser, string cId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSingleTransactionHistory", new object[] {
                        targetUser,
                        delegateUser,
                        cId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetSingleTransactionHistory(System.IAsyncResult asyncResult, out Transaction[] transactions) {
            object[] results = this.EndInvoke(asyncResult);
            transactions = ((Transaction[])(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetSingleTransactionHistoryAsync(long targetUser, long delegateUser, string cId) {
            this.GetSingleTransactionHistoryAsync(targetUser, delegateUser, cId, null);
        }
        
        /// <remarks/>
        public void GetSingleTransactionHistoryAsync(long targetUser, long delegateUser, string cId, object userState) {
            if ((this.GetSingleTransactionHistoryOperationCompleted == null)) {
                this.GetSingleTransactionHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSingleTransactionHistoryOperationCompleted);
            }
            this.InvokeAsync("GetSingleTransactionHistory", new object[] {
                        targetUser,
                        delegateUser,
                        cId}, this.GetSingleTransactionHistoryOperationCompleted, userState);
        }
        
        private void OnGetSingleTransactionHistoryOperationCompleted(object arg) {
            if ((this.GetSingleTransactionHistoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSingleTransactionHistoryCompleted(this, new GetSingleTransactionHistoryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetStatus", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetStatus(long targetUser, long delegateUser, out Status statusUser) {
            object[] results = this.Invoke("GetStatus", new object[] {
                        targetUser,
                        delegateUser});
            statusUser = ((Status)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatus(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatus", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetStatus(System.IAsyncResult asyncResult, out Status statusUser) {
            object[] results = this.EndInvoke(asyncResult);
            statusUser = ((Status)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetStatusAsync(long targetUser, long delegateUser) {
            this.GetStatusAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetStatusAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetStatusOperationCompleted == null)) {
                this.GetStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStatusOperationCompleted);
            }
            this.InvokeAsync("GetStatus", new object[] {
                        targetUser,
                        delegateUser}, this.GetStatusOperationCompleted, userState);
        }
        
        private void OnGetStatusOperationCompleted(object arg) {
            if ((this.GetStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStatusCompleted(this, new GetStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SetStatus", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string SetStatus(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("SetStatus", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        statusUser,
                        externalReferenceId,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetStatus(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetStatus", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        statusUser,
                        externalReferenceId,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndSetStatus(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void SetStatusAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason) {
            this.SetStatusAsync(trackingGuid, targetUser, delegateUser, statusUser, externalReferenceId, reason, null);
        }
        
        /// <remarks/>
        public void SetStatusAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, object userState) {
            if ((this.SetStatusOperationCompleted == null)) {
                this.SetStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetStatusOperationCompleted);
            }
            this.InvokeAsync("SetStatus", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        statusUser,
                        externalReferenceId,
                        reason}, this.SetStatusOperationCompleted, userState);
        }
        
        private void OnSetStatusOperationCompleted(object arg) {
            if ((this.SetStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetStatusCompleted(this, new SetStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetUserProperties", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetUserProperties(long targetUser, long delegateUser, out UserProperties userProp) {
            object[] results = this.Invoke("GetUserProperties", new object[] {
                        targetUser,
                        delegateUser});
            userProp = ((UserProperties)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserProperties(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserProperties", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetUserProperties(System.IAsyncResult asyncResult, out UserProperties userProp) {
            object[] results = this.EndInvoke(asyncResult);
            userProp = ((UserProperties)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserPropertiesAsync(long targetUser, long delegateUser) {
            this.GetUserPropertiesAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetUserPropertiesAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetUserPropertiesOperationCompleted == null)) {
                this.GetUserPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserPropertiesOperationCompleted);
            }
            this.InvokeAsync("GetUserProperties", new object[] {
                        targetUser,
                        delegateUser}, this.GetUserPropertiesOperationCompleted, userState);
        }
        
        private void OnGetUserPropertiesOperationCompleted(object arg) {
            if ((this.GetUserPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserPropertiesCompleted(this, new GetUserPropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SetUserProperties", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string SetUserProperties(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("SetUserProperties", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        userProp,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetUserProperties(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetUserProperties", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        userProp,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndSetUserProperties(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void SetUserPropertiesAsync(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason) {
            this.SetUserPropertiesAsync(trackingGuid, targetUser, delegateUser, userProp, reason, null);
        }
        
        /// <remarks/>
        public void SetUserPropertiesAsync(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, object userState) {
            if ((this.SetUserPropertiesOperationCompleted == null)) {
                this.SetUserPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserPropertiesOperationCompleted);
            }
            this.InvokeAsync("SetUserProperties", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        userProp,
                        reason}, this.SetUserPropertiesOperationCompleted, userState);
        }
        
        private void OnSetUserPropertiesOperationCompleted(object arg) {
            if ((this.SetUserPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserPropertiesCompleted(this, new SetUserPropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalancePolicy", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetBalancePolicy(long targetUser, long delegateUser, out BalancePolicy policy) {
            object[] results = this.Invoke("GetBalancePolicy", new object[] {
                        targetUser,
                        delegateUser});
            policy = ((BalancePolicy)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBalancePolicy(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBalancePolicy", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetBalancePolicy(System.IAsyncResult asyncResult, out BalancePolicy policy) {
            object[] results = this.EndInvoke(asyncResult);
            policy = ((BalancePolicy)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetBalancePolicyAsync(long targetUser, long delegateUser) {
            this.GetBalancePolicyAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetBalancePolicyAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetBalancePolicyOperationCompleted == null)) {
                this.GetBalancePolicyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBalancePolicyOperationCompleted);
            }
            this.InvokeAsync("GetBalancePolicy", new object[] {
                        targetUser,
                        delegateUser}, this.GetBalancePolicyOperationCompleted, userState);
        }
        
        private void OnGetBalancePolicyOperationCompleted(object arg) {
            if ((this.GetBalancePolicyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBalancePolicyCompleted(this, new GetBalancePolicyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/CreditBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string CreditBalance(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("CreditBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        cId,
                        itemsToCredit,
                        externalReferenceId,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditBalance(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        cId,
                        itemsToCredit,
                        externalReferenceId,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCreditBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CreditBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason) {
            this.CreditBalanceAsync(trackingGuid, targetUser, delegateUser, cId, itemsToCredit, externalReferenceId, reason, null);
        }
        
        /// <remarks/>
        public void CreditBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, object userState) {
            if ((this.CreditBalanceOperationCompleted == null)) {
                this.CreditBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreditBalanceOperationCompleted);
            }
            this.InvokeAsync("CreditBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        cId,
                        itemsToCredit,
                        externalReferenceId,
                        reason}, this.CreditBalanceOperationCompleted, userState);
        }
        
        private void OnCreditBalanceOperationCompleted(object arg) {
            if ((this.CreditBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreditBalanceCompleted(this, new CreditBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/DebitBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string DebitBalance(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("DebitBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        balanceToAdjust,
                        cId,
                        externalReferenceId,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDebitBalance(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DebitBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        balanceToAdjust,
                        cId,
                        externalReferenceId,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndDebitBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void DebitBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason) {
            this.DebitBalanceAsync(trackingGuid, targetUser, delegateUser, balanceToAdjust, cId, externalReferenceId, reason, null);
        }
        
        /// <remarks/>
        public void DebitBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, object userState) {
            if ((this.DebitBalanceOperationCompleted == null)) {
                this.DebitBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDebitBalanceOperationCompleted);
            }
            this.InvokeAsync("DebitBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        balanceToAdjust,
                        cId,
                        externalReferenceId,
                        reason}, this.DebitBalanceOperationCompleted, userState);
        }
        
        private void OnDebitBalanceOperationCompleted(object arg) {
            if ((this.DebitBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DebitBalanceCompleted(this, new DebitBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SyncUps", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string SyncUps(long targetUser) {
            object[] results = this.Invoke("SyncUps", new object[] {
                        targetUser});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSyncUps(long targetUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SyncUps", new object[] {
                        targetUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndSyncUps(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void SyncUpsAsync(long targetUser) {
            this.SyncUpsAsync(targetUser, null);
        }
        
        /// <remarks/>
        public void SyncUpsAsync(long targetUser, object userState) {
            if ((this.SyncUpsOperationCompleted == null)) {
                this.SyncUpsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSyncUpsOperationCompleted);
            }
            this.InvokeAsync("SyncUps", new object[] {
                        targetUser}, this.SyncUpsOperationCompleted, userState);
        }
        
        private void OnSyncUpsOperationCompleted(object arg) {
            if ((this.SyncUpsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SyncUpsCompleted(this, new SyncUpsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/ExchangePoints", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string ExchangePoints(System.Guid trackingGuid, System.Guid exchangePartnerId, long targetUser, long delegateUser, TransactionContext context, ExchangeType exchangeType, int pointsToExchange, decimal price, string currency, out Receipt receipt) {
            object[] results = this.Invoke("ExchangePoints", new object[] {
                        trackingGuid,
                        exchangePartnerId,
                        targetUser,
                        delegateUser,
                        context,
                        exchangeType,
                        pointsToExchange,
                        price,
                        currency});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExchangePoints(System.Guid trackingGuid, System.Guid exchangePartnerId, long targetUser, long delegateUser, TransactionContext context, ExchangeType exchangeType, int pointsToExchange, decimal price, string currency, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExchangePoints", new object[] {
                        trackingGuid,
                        exchangePartnerId,
                        targetUser,
                        delegateUser,
                        context,
                        exchangeType,
                        pointsToExchange,
                        price,
                        currency}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndExchangePoints(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void ExchangePointsAsync(System.Guid trackingGuid, System.Guid exchangePartnerId, long targetUser, long delegateUser, TransactionContext context, ExchangeType exchangeType, int pointsToExchange, decimal price, string currency) {
            this.ExchangePointsAsync(trackingGuid, exchangePartnerId, targetUser, delegateUser, context, exchangeType, pointsToExchange, price, currency, null);
        }
        
        /// <remarks/>
        public void ExchangePointsAsync(System.Guid trackingGuid, System.Guid exchangePartnerId, long targetUser, long delegateUser, TransactionContext context, ExchangeType exchangeType, int pointsToExchange, decimal price, string currency, object userState) {
            if ((this.ExchangePointsOperationCompleted == null)) {
                this.ExchangePointsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExchangePointsOperationCompleted);
            }
            this.InvokeAsync("ExchangePoints", new object[] {
                        trackingGuid,
                        exchangePartnerId,
                        targetUser,
                        delegateUser,
                        context,
                        exchangeType,
                        pointsToExchange,
                        price,
                        currency}, this.ExchangePointsOperationCompleted, userState);
        }
        
        private void OnExchangePointsOperationCompleted(object arg) {
            if ((this.ExchangePointsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExchangePointsCompleted(this, new ExchangePointsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TestConnection", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string echoIn, out System.DateTime dt, out string echoOut) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        echoIn});
            dt = ((System.DateTime)(results[1]));
            echoOut = ((string)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string echoIn, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        echoIn}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult, out System.DateTime dt, out string echoOut) {
            object[] results = this.EndInvoke(asyncResult);
            dt = ((System.DateTime)(results[1]));
            echoOut = ((string)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string echoIn) {
            this.TestConnectionAsync(echoIn, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string echoIn, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        echoIn}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum ProvisionMode {
        
        /// <remarks/>
        Normal,
        
        /// <remarks/>
        ComputeOnly,
        
        /// <remarks/>
        MaxBalanceOverride,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Receipt {
        
        private System.Guid trackingGuidField;
        
        private string confirmationIdField;
        
        private System.DateTime confirmationDateField;
        
        private int newBalanceField;
        
        /// <remarks/>
        public System.Guid TrackingGuid {
            get {
                return this.trackingGuidField;
            }
            set {
                this.trackingGuidField = value;
            }
        }
        
        /// <remarks/>
        public string ConfirmationId {
            get {
                return this.confirmationIdField;
            }
            set {
                this.confirmationIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ConfirmationDate {
            get {
                return this.confirmationDateField;
            }
            set {
                this.confirmationDateField = value;
            }
        }
        
        /// <remarks/>
        public int NewBalance {
            get {
                return this.newBalanceField;
            }
            set {
                this.newBalanceField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class BalancePolicy {
        
        private int minBalanceIndicatorField;
        
        private int maxBalancePurchasedField;
        
        private int maxBalancePromotionalField;
        
        private int maxBalanceAcquisitionField;
        
        private int consumptionLimitSpanField;
        
        private int consumptionLimitMaxField;
        
        private int promotionalLimitMaxPerSkuField;
        
        /// <remarks/>
        public int MinBalanceIndicator {
            get {
                return this.minBalanceIndicatorField;
            }
            set {
                this.minBalanceIndicatorField = value;
            }
        }
        
        /// <remarks/>
        public int MaxBalancePurchased {
            get {
                return this.maxBalancePurchasedField;
            }
            set {
                this.maxBalancePurchasedField = value;
            }
        }
        
        /// <remarks/>
        public int MaxBalancePromotional {
            get {
                return this.maxBalancePromotionalField;
            }
            set {
                this.maxBalancePromotionalField = value;
            }
        }
        
        /// <remarks/>
        public int MaxBalanceAcquisition {
            get {
                return this.maxBalanceAcquisitionField;
            }
            set {
                this.maxBalanceAcquisitionField = value;
            }
        }
        
        /// <remarks/>
        public int ConsumptionLimitSpan {
            get {
                return this.consumptionLimitSpanField;
            }
            set {
                this.consumptionLimitSpanField = value;
            }
        }
        
        /// <remarks/>
        public int ConsumptionLimitMax {
            get {
                return this.consumptionLimitMaxField;
            }
            set {
                this.consumptionLimitMaxField = value;
            }
        }
        
        /// <remarks/>
        public int PromotionalLimitMaxPerSku {
            get {
                return this.promotionalLimitMaxPerSkuField;
            }
            set {
                this.promotionalLimitMaxPerSkuField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class UserProperties {
        
        private int minBalanceIndicatorField;
        
        /// <remarks/>
        public int MinBalanceIndicator {
            get {
                return this.minBalanceIndicatorField;
            }
            set {
                this.minBalanceIndicatorField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Transaction {
        
        private long targetUserField;
        
        private long delegateUserField;
        
        private int balanceChangeField;
        
        private TransactionType transactionTypeField;
        
        private string acquisitionTitleField;
        
        private int acquisitionTypeField;
        
        private bool acquisitionTypeFieldSpecified;
        
        private Item[] itemSetField;
        
        private ReasonCode reasonCodeField;
        
        private bool reasonCodeFieldSpecified;
        
        private string confirmationIdField;
        
        private System.DateTime confirmationDateField;
        
        private string originalConfirmationIdField;
        
        private System.Guid tenantIdField;
        
        private string externalReferenceIdField;
        
        private System.DateTime postingDateField;
        
        private bool postingDateFieldSpecified;
        
        private string clientAddressField;
        
        private string purchaseIdField;
        
        private string bundleIdField;
        
        private string bundleTitleField;
        
        private string bundleDiscriptionField;
        
        private string[] discountDescriptionSetField;
        
        /// <remarks/>
        public long TargetUser {
            get {
                return this.targetUserField;
            }
            set {
                this.targetUserField = value;
            }
        }
        
        /// <remarks/>
        public long DelegateUser {
            get {
                return this.delegateUserField;
            }
            set {
                this.delegateUserField = value;
            }
        }
        
        /// <remarks/>
        public int BalanceChange {
            get {
                return this.balanceChangeField;
            }
            set {
                this.balanceChangeField = value;
            }
        }
        
        /// <remarks/>
        public TransactionType transactionType {
            get {
                return this.transactionTypeField;
            }
            set {
                this.transactionTypeField = value;
            }
        }
        
        /// <remarks/>
        public string AcquisitionTitle {
            get {
                return this.acquisitionTitleField;
            }
            set {
                this.acquisitionTitleField = value;
            }
        }
        
        /// <remarks/>
        public int AcquisitionType {
            get {
                return this.acquisitionTypeField;
            }
            set {
                this.acquisitionTypeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AcquisitionTypeSpecified {
            get {
                return this.acquisitionTypeFieldSpecified;
            }
            set {
                this.acquisitionTypeFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public Item[] ItemSet {
            get {
                return this.itemSetField;
            }
            set {
                this.itemSetField = value;
            }
        }
        
        /// <remarks/>
        public ReasonCode reasonCode {
            get {
                return this.reasonCodeField;
            }
            set {
                this.reasonCodeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool reasonCodeSpecified {
            get {
                return this.reasonCodeFieldSpecified;
            }
            set {
                this.reasonCodeFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public string ConfirmationId {
            get {
                return this.confirmationIdField;
            }
            set {
                this.confirmationIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ConfirmationDate {
            get {
                return this.confirmationDateField;
            }
            set {
                this.confirmationDateField = value;
            }
        }
        
        /// <remarks/>
        public string OriginalConfirmationId {
            get {
                return this.originalConfirmationIdField;
            }
            set {
                this.originalConfirmationIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid TenantId {
            get {
                return this.tenantIdField;
            }
            set {
                this.tenantIdField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime PostingDate {
            get {
                return this.postingDateField;
            }
            set {
                this.postingDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool PostingDateSpecified {
            get {
                return this.postingDateFieldSpecified;
            }
            set {
                this.postingDateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public string ClientAddress {
            get {
                return this.clientAddressField;
            }
            set {
                this.clientAddressField = value;
            }
        }
        
        /// <remarks/>
        public string PurchaseId {
            get {
                return this.purchaseIdField;
            }
            set {
                this.purchaseIdField = value;
            }
        }
        
        /// <remarks/>
        public string BundleId {
            get {
                return this.bundleIdField;
            }
            set {
                this.bundleIdField = value;
            }
        }
        
        /// <remarks/>
        public string BundleTitle {
            get {
                return this.bundleTitleField;
            }
            set {
                this.bundleTitleField = value;
            }
        }
        
        /// <remarks/>
        public string BundleDiscription {
            get {
                return this.bundleDiscriptionField;
            }
            set {
                this.bundleDiscriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("DiscountDescription")]
        public string[] DiscountDescriptionSet {
            get {
                return this.discountDescriptionSetField;
            }
            set {
                this.discountDescriptionSetField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum TransactionType {
        
        /// <remarks/>
        All,
        
        /// <remarks/>
        StatusCreated,
        
        /// <remarks/>
        StatusDisabled,
        
        /// <remarks/>
        StatusReactivated,
        
        /// <remarks/>
        StatusClosed,
        
        /// <remarks/>
        PurchasePoints,
        
        /// <remarks/>
        PromotionPoints,
        
        /// <remarks/>
        PurchaseItem,
        
        /// <remarks/>
        ChangeUserProperties,
        
        /// <remarks/>
        CancelPurchase,
        
        /// <remarks/>
        CreditBalance,
        
        /// <remarks/>
        ChargebackDebit,
        
        /// <remarks/>
        RefundDebit,
        
        /// <remarks/>
        ExpirePurchasedPoints,
        
        /// <remarks/>
        ExpirePromoPoints,
        
        /// <remarks/>
        OffsetCredit,
        
        /// <remarks/>
        UpdateRegistration,
        
        /// <remarks/>
        ExchangeIn,
        
        /// <remarks/>
        ExchangeOut,
        
        /// <remarks/>
        TransferOut,
        
        /// <remarks/>
        TransferIn,
        
        /// <remarks/>
        AdminOffset,
        
        /// <remarks/>
        DistributePoints,
        
        /// <remarks/>
        PointsTransferOut,
        
        /// <remarks/>
        PointsTransferIn,
        
        /// <remarks/>
        RiskReversePointsTransferOut,
        
        /// <remarks/>
        RiskReversePointsTransferIn,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Item {
        
        private string externalIdField;
        
        private string titleField;
        
        private int priceField;
        
        private string sKUField;
        
        private string itemCategoryField;
        
        private byte itemCreditField;
        
        private bool itemCreditFieldSpecified;
        
        /// <remarks/>
        public string ExternalId {
            get {
                return this.externalIdField;
            }
            set {
                this.externalIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public int Price {
            get {
                return this.priceField;
            }
            set {
                this.priceField = value;
            }
        }
        
        /// <remarks/>
        public string SKU {
            get {
                return this.sKUField;
            }
            set {
                this.sKUField = value;
            }
        }
        
        /// <remarks/>
        public string ItemCategory {
            get {
                return this.itemCategoryField;
            }
            set {
                this.itemCategoryField = value;
            }
        }
        
        /// <remarks/>
        public byte ItemCredit {
            get {
                return this.itemCreditField;
            }
            set {
                this.itemCreditField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ItemCreditSpecified {
            get {
                return this.itemCreditFieldSpecified;
            }
            set {
                this.itemCreditFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum ReasonCode {
        
        /// <remarks/>
        OK,
        
        /// <remarks/>
        ConsumptionError,
        
        /// <remarks/>
        CustomerRetention,
        
        /// <remarks/>
        PurchaseCredit,
        
        /// <remarks/>
        ProductFailure,
        
        /// <remarks/>
        FraudClaim,
        
        /// <remarks/>
        PromotionalExpiration,
        
        /// <remarks/>
        CountryDisable,
        
        /// <remarks/>
        CountryActivate,
        
        /// <remarks/>
        CustomerRequestedClose,
        
        /// <remarks/>
        CustomerRequestedReopen,
        
        /// <remarks/>
        FraudSuspected,
        
        /// <remarks/>
        FraudNotSuspected,
        
        /// <remarks/>
        CustomerRequestedCloseAndRefund,
        
        /// <remarks/>
        Offset,
        
        /// <remarks/>
        Chargeback,
        
        /// <remarks/>
        Refund,
        
        /// <remarks/>
        RegularExpiration,
        
        /// <remarks/>
        TransferOut,
        
        /// <remarks/>
        TransferIn,
        
        /// <remarks/>
        PointsTransferOut,
        
        /// <remarks/>
        PointsTransferIn,
        
        /// <remarks/>
        RiskReversePointsTransferOut,
        
        /// <remarks/>
        RiskReversePointsTransferIn,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class PointLot {
        
        private SourceType sourceTypeField;
        
        private int quantityField;
        
        private short expirationDaysField;
        
        private bool expirationDaysFieldSpecified;
        
        /// <remarks/>
        public SourceType sourceType {
            get {
                return this.sourceTypeField;
            }
            set {
                this.sourceTypeField = value;
            }
        }
        
        /// <remarks/>
        public int Quantity {
            get {
                return this.quantityField;
            }
            set {
                this.quantityField = value;
            }
        }
        
        /// <remarks/>
        public short ExpirationDays {
            get {
                return this.expirationDaysField;
            }
            set {
                this.expirationDaysField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ExpirationDaysSpecified {
            get {
                return this.expirationDaysFieldSpecified;
            }
            set {
                this.expirationDaysFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum SourceType {
        
        /// <remarks/>
        SourcePurchased,
        
        /// <remarks/>
        SourcePromo,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Property {
        
        private string namespaceField;
        
        private string nameField;
        
        private string valueField;
        
        /// <remarks/>
        public string Namespace {
            get {
                return this.namespaceField;
            }
            set {
                this.namespaceField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class TransferTransactionContext {
        
        private System.Guid tenantIdField;
        
        private string externalReferenceIdField;
        
        private System.DateTime postingDateField;
        
        private int campaignIdField;
        
        private bool riskCheckFlagField;
        
        private string reasonCodeField;
        
        private bool emailFlagField;
        
        private Property[] propertyBagField;
        
        /// <remarks/>
        public System.Guid TenantId {
            get {
                return this.tenantIdField;
            }
            set {
                this.tenantIdField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime PostingDate {
            get {
                return this.postingDateField;
            }
            set {
                this.postingDateField = value;
            }
        }
        
        /// <remarks/>
        public int CampaignId {
            get {
                return this.campaignIdField;
            }
            set {
                this.campaignIdField = value;
            }
        }
        
        /// <remarks/>
        public bool RiskCheckFlag {
            get {
                return this.riskCheckFlagField;
            }
            set {
                this.riskCheckFlagField = value;
            }
        }
        
        /// <remarks/>
        public string ReasonCode {
            get {
                return this.reasonCodeField;
            }
            set {
                this.reasonCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool EmailFlag {
            get {
                return this.emailFlagField;
            }
            set {
                this.emailFlagField = value;
            }
        }
        
        /// <remarks/>
        public Property[] PropertyBag {
            get {
                return this.propertyBagField;
            }
            set {
                this.propertyBagField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class TransactionContext {
        
        private System.Guid sellingPartnerIdField;
        
        private string externalReferenceIdField;
        
        private System.DateTime postingDateField;
        
        private string clientAddressField;
        
        private int campaignIdField;
        
        private string validationTicketField;
        
        /// <remarks/>
        public System.Guid SellingPartnerId {
            get {
                return this.sellingPartnerIdField;
            }
            set {
                this.sellingPartnerIdField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime PostingDate {
            get {
                return this.postingDateField;
            }
            set {
                this.postingDateField = value;
            }
        }
        
        /// <remarks/>
        public string ClientAddress {
            get {
                return this.clientAddressField;
            }
            set {
                this.clientAddressField = value;
            }
        }
        
        /// <remarks/>
        public int CampaignId {
            get {
                return this.campaignIdField;
            }
            set {
                this.campaignIdField = value;
            }
        }
        
        /// <remarks/>
        public string ValidationTicket {
            get {
                return this.validationTicketField;
            }
            set {
                this.validationTicketField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum Status {
        
        /// <remarks/>
        Active,
        
        /// <remarks/>
        Disabled,
        
        /// <remarks/>
        Closed,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum ExchangeType {
        
        /// <remarks/>
        IN,
        
        /// <remarks/>
        OUT,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void AddProvisionedBalanceCompletedEventHandler(object sender, AddProvisionedBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddProvisionedBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddProvisionedBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void AddPromotionalBalanceCompletedEventHandler(object sender, AddPromotionalBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddPromotionalBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddPromotionalBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void RegisterUserCompletedEventHandler(object sender, RegisterUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RegisterUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RegisterUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void UpdateRegistrationCompletedEventHandler(object sender, UpdateRegistrationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateRegistrationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateRegistrationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void PurchaseItemCompletedEventHandler(object sender, PurchaseItemCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PurchaseItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void CancelPurchaseItemCompletedEventHandler(object sender, CancelPurchaseItemCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CancelPurchaseItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CancelPurchaseItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void TransferBalanceCompletedEventHandler(object sender, TransferBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TransferBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt sourceReceipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Receipt transferReceipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void TransferPointsCompletedEventHandler(object sender, TransferPointsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferPointsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TransferPointsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt sourceReceipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Receipt transferReceipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetBalanceCompletedEventHandler(object sender, GetBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int balance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool aboveLowBalance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public Status statusUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Status)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string country {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetBalanceDetailsCompletedEventHandler(object sender, GetBalanceDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBalanceDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetBalanceDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int balance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool aboveLowBalance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public Status statusUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Status)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public PointLot[] lots {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PointLot[])(this.results[4]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetStatementCompletedEventHandler(object sender, GetStatementCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStatementCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetStatementCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nextHandle {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Transaction[] transactions {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Transaction[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetSingleTransactionHistoryCompletedEventHandler(object sender, GetSingleTransactionHistoryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSingleTransactionHistoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSingleTransactionHistoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Transaction[] transactions {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Transaction[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetStatusCompletedEventHandler(object sender, GetStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Status statusUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Status)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void SetStatusCompletedEventHandler(object sender, SetStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetUserPropertiesCompletedEventHandler(object sender, GetUserPropertiesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserPropertiesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserPropertiesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public UserProperties userProp {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserProperties)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void SetUserPropertiesCompletedEventHandler(object sender, SetUserPropertiesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetUserPropertiesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetUserPropertiesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void GetBalancePolicyCompletedEventHandler(object sender, GetBalancePolicyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBalancePolicyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetBalancePolicyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public BalancePolicy policy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((BalancePolicy)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void CreditBalanceCompletedEventHandler(object sender, CreditBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreditBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreditBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void DebitBalanceCompletedEventHandler(object sender, DebitBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DebitBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DebitBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void SyncUpsCompletedEventHandler(object sender, SyncUpsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SyncUpsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SyncUpsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void ExchangePointsCompletedEventHandler(object sender, ExchangePointsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ExchangePointsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ExchangePointsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string echoOut {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\MigrateUser.cs ===
/*
 * MigrateUser.cs
 *
 * Xbox Live Operations / MigrateUser tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;                           // Exception
using xonline.common.service;           // HResult
using xonline.common.user;              // User

namespace xonline.common.billing.migrateuser
{
    public class MigrateUser
    {
        public static string Read(string gamertag)
        {
            return Read(gamertag, false);
        }

        public static string Read(string gamertag, bool ensure)
        {
            Printer.Print("MigrateUser.Read...", Printer.Color.Debug);

            #region make sure the user exists
            User user = new User();
            if (!UserExists(gamertag, ref user))
            {
                string errorString = "User '" + gamertag + "' does not exist!";
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_USER_DOES_NOT_EXIST_ERROR, errorString);
            }
            #endregion

            #region read in user data
            UserData userData = null;
            try
            {
                userData = new UserData(user);

                if (ensure)
                {
                    // make sure we got everything
                    userData.Ensure();
                }
            }
            catch (Exception e)
            {
                string errorString = "Failed to Load User: " + e.Message;
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_FAILED_TO_LOAD_USER_ERROR, errorString);
            }

            Printer.Print("Successfully Read in data for user '" + gamertag + "' !", Printer.Color.Info);
            #endregion

            #region write the user data to xml
            string userDataXML = "";
            try
            {
                userDataXML = userData.Write();
            }
            catch (Exception e)
            {
                string errorString = "Failed to Write User to XML: " + e.Message;
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_FAILED_TO_WRITE_XML_ERROR, errorString);
            }

            Printer.Print("Successfully wrote data for user '" + gamertag + "' to XML!", Printer.Color.Info);
            #endregion

            Printer.Print("\t", Printer.Color.Complete);
            Printer.Print("\tSuccessfully Read user '" + gamertag + "' !", Printer.Color.Complete);
            Printer.Print("\t", Printer.Color.Complete);
            return userDataXML;
        }

        private static bool UserExists(string gamertag, ref User user)
        {
            Printer.Print("Checking if a user with gamertag '" + gamertag + "' exists...", Printer.Color.Debug);
            bool exists = false;

            try
                { exists = HResult.Succeeded(user.LoadFromGamerTag(gamertag)); }
            catch (Exception)
                { exists = false;  }

            if (exists)
            {
                Printer.Print("User '" + gamertag + "' exists!", Printer.Color.Info);
            }
            else
            {
                Printer.Print("User '" + gamertag + "' does not exist!", Printer.Color.Info);
            }

            return exists;
        }

        public static void Write(ref string gamertag, string userDataXML, ref string userEmail, ref string userPassword)
        {
            Printer.Print("MigrateUser.Write...", Printer.Color.Debug);

            #region NEVER WRITE TO PROD
            Printer.Print("Checking environment to make sure this isn't a production environment...", Printer.Color.Debug);
            if (Util.IsCurrentEnvironmentProduction())
            {
                string errorString = "Using this tool to write a user into a production environment is not allowed!";
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_WRITE_TO_PROD_ERROR, errorString);
            }
            Printer.Print("This is a valid debug environment!", Printer.Color.Info);
            #endregion

            #region read in the user's data
            Printer.Print("Reading XML...", Printer.Color.Debug);
            UserData userData = null;
            try { userData = new UserData(userDataXML); }
            catch (Exception e)
            {
                string errorString = "Failed to read user from file: " + e.Message;
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_FAILED_TO_READ_XML_ERROR, errorString);
            }

            Printer.Print("Successfully read data for user '" + userData.Gamertag + "' from file!", Printer.Color.Info);
            #endregion

            #region generate a gamertag / make sure the gamertag does not currently exist
            if (string.IsNullOrEmpty(gamertag))
            {
                Printer.Print("No gamertag provided. Using the gamertag provided in the xml", Printer.Color.Debug);
                gamertag = userData.Gamertag;
                Printer.Print("proceeding with gamertag = " + gamertag, Printer.Color.Info);
            }

            User user = new User();
            if (UserExists(gamertag, ref user))
            {
                string errorString = "User '" + gamertag + "' exists!";
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_USER_ALREADY_EXISTS_ERROR, errorString);
            }
            #endregion

            #region load the user into the current environment
            try
            {
                userData.WriteUser(gamertag, ref userEmail, ref userPassword);
            }
            catch (Exception e)
            {
                string errorString = "Failed to Create User: " + e.Message;
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_FAILED_TO_CREATE_USER_ERROR, errorString);
            }

            Printer.Print("Successfully set data for user '" + gamertag + "' into current environment!", Printer.Color.Info);
            #endregion

            #region make sure the user exists
            user = new User();
            if (!UserExists(gamertag, ref user))
            {
                string errorString = "Failed to Verify that user '" + gamertag + "' was created!";
                Printer.Print(errorString, Printer.Color.Error);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIGRATEUSER_FAILED_TO_CREATE_USER_ERROR, errorString);
            }
            #endregion

            Printer.Print("\t", Printer.Color.Complete);
            Printer.Print("\tSuccessfully Wrote user '" + gamertag + "' !", Printer.Color.Complete);
            Printer.Print("\temail: '" + userEmail + "' !", Printer.Color.Complete);
            Printer.Print("\tpassword: '" + userPassword + "' !", Printer.Color.Complete);
            Printer.Print("\t", Printer.Color.Complete);
        }

        public static void Copy(string oldGamertag, ref string newGamertag, bool ensure, ref string userEmail, ref string userPassword)
        {
            Write(ref newGamertag, Read(oldGamertag, ensure), ref userEmail, ref userPassword);
        }

        public static void FindAllInstancesOfUser(string gamertag)
        {
            Util.FindAllInstancesOfUser(gamertag);
        }

        public static void PrintError(string errorText)
        {
            if (!String.IsNullOrEmpty(errorText))
            {
                Printer.Print("\n\tERROR: " + errorText, Printer.Color.Error);
            }
        }

        public static void Print(string text)
        {
            if (!String.IsNullOrEmpty(text))
            {
                Printer.Print(text, Printer.Color.Debug);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Offering.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using Billing.PSO;

using System;
using System.Diagnostics;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.common.billing
{
    public class CancelDate
    {
        public const string Now = "NOW";
        public const string DelayedExpire = "DELAYED_EXPIRE";
        public const string UndoDelayedExpire = "UNDO_DELAYED_EXPIRE";
    }

    public class Offering
    {
        // these are used for CommitPurchase
        public const uint INITIAL_RECORD = 1;
        public const uint FINAL_COMMIT   = 2;
        public const uint DO_ROLLBACK    = 3;

        public static void PurchaseEx(
            string offeringId,
            ulong billingPuid,
            ulong userPuid,
            string PMN,
            string accountId,
            string payInfoId,
            string tokenId,
            string transactionGUID,
            string expectedServiceComponentId,
            out Price offerPrice,
            out string subscriptionId,
            out string serviceInstanceId
            )
        {
            uint puidHigh;
            uint puidLow;
            string errorXml;
            string amountChargedXml = "";
            string referralSetXml = "";
            int    addedServiceComponentSetCount;
            string addedServiceComponentSet;
            Price  outputPrice  = new Price();



            serviceInstanceId = "";

            // SCG requested that we provide this XML fragment to them as
            // part of calling PurchaseOffering.
            referralSetXml =
              "<ReferralSet xmlns=\"urn:schemas-microsoft-com:billing-data\" >"
            +    "<Referral>"
            +       "<ReferralType> Xbox </ReferralType>"
            +       "<ReferralData>"
            +          "<ReferralID xmlns=\"urn:schemas-microsoft-com:Msnia\" >"
            +             "<InsertDate> " + DateTime.UtcNow.ToString() + " </InsertDate>"
            +             "<Product> " + offeringId + " </Product> "
            +          "</ReferralID>"
            +       "</ReferralData>"
            +    "</Referral>"
            + "</ReferralSet>";

            if ( BillingConfig.ConnectToBilling == false)
            {
                subscriptionId = BillingProvider.GenerateDummyId();
                serviceInstanceId = BillingProvider.GenerateDummyId();
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "SKIPPING Purchase call to SCS" );
            }
            else
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Offering.PurchaseEx: calling SCS's PurchaseOfferingEx method..." );

                using (BillingProvider bdk = new BillingProvider())
                {
                    Int64Convert.ToUintPair((long) billingPuid, out puidHigh, out puidLow);

                    bdk.PurchaseOfferingEx(
                        0x0,                    // int lDelegatePUIDHigh,
                        0x0,                    // int lDelegatePUIDLow,
                        (int)puidHigh,          // int lRequesterPUIDHigh,
                        (int)puidLow,           // int lRequesterPUIDLow,
                        transactionGUID,        // string bstrTransactionGUID
                        false,                  // bool fComputeOnly,
                        PMN,                    // string bstrSubscriptionName, [XName used to identify line items]
                        accountId,              // string bstrAccountId,
                        String.Empty,           // string bstrBaseSubscriptionID,
                        offeringId,             // string bstrOfferingGUID,
                        0,                      // int lOverrideAmount,
                        payInfoId,              // string bstrPaymentInstrumentId,
                        String.Empty,           // string lShippingAddressID,
                        String.Empty,           // string bstrActivationDate,
                        String.Empty,           // string bstrSubscriptionEndDate,
                        referralSetXml,         // string bstrReferralSetXML,
                        tokenId,                // string bstrTokenId,
                        String.Empty,           // string bstrPolicyGUID,
                        0,                      // int lPolicyVersion,
                        String.Empty,           // string bstrSignatureDateTime,
                        out errorXml,           // out string pbstrErrorXML,
                        out subscriptionId,     // out string pbstrSubscriptionID,
                        out amountChargedXml,   // out string pbstrAmountChargedXML,
                        out addedServiceComponentSetCount,  // out int plAddedServiceComponentSetCount,
                        out addedServiceComponentSet        // out string pbstrAddedServiceComponentSet
                        );

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Offering.PurchaseEx: PurchaseOfferingEx succeeded! subscriptionId: " + subscriptionId );
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Offering.PurchaseEx: PurchaseOfferingEx added components: " + addedServiceComponentSet );

                    // get real provisioning data if this is a real purchase.
                    if (addedServiceComponentSetCount > 0)
                    {
                        ServiceInstance serviceSet = new ServiceInstance();
                        serviceSet.FromXml(addedServiceComponentSet, "ServiceInstanceSet");

                        // verify that the service component id SCS returns is
                        // the same one we have in UODB and are expecting
                        if ( expectedServiceComponentId != null )
                        {
                            if ( expectedServiceComponentId.ToLower() != serviceSet.ServiceComponentId.ToLower() )
                            {
                                Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "Service component id mismatch in SCS for offering " + offeringId + ": SCS returned " + serviceSet.ServiceComponentId + ", expected: " + expectedServiceComponentId);

                                throw new ExceptionWithEventId(
                                    XEvent.Id.MC_SPS_OFFER_MISCONFIGURATION,
                                    "The service component id associated with this offering (" + offeringId + ") "
                                    + "in UODB (" + expectedServiceComponentId + ") "
                                    + "does not match the service component associated with the offering in SCS (" + serviceSet.ServiceComponentId + ").");
                            }
                        }

                        // this Purchase output param must be set here,
                        // parenthetically to the task at hand.
                        serviceInstanceId = serviceSet.ServiceInstanceId;

                        // now set the inputs for provisioning
                        uint userHigh, userLow;
                        Int64Convert.ToUintPair((long) userPuid, out userHigh, out userLow);

                        serviceSet.PuidHigh = (int)userHigh;
                        serviceSet.PuidLow  = (int)userLow;
                        serviceSet.PMN      = PMN;
                        serviceSet.Role     = "User";
                        serviceSet.Details  = "&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;";
                        serviceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
                        serviceSet.InstanceFriendlyName = PMN;

                        // make sure we have enough information
                        serviceSet.ValidateFields();

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Provisioning with the following: " + serviceSet.ToXml("ServiceInstanceSet") );
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Calling SCS's ProvisionServices method via SOAP..." );

                        try
                        {
                            // now we can make an actual provisioning call.
                            bdk.ProvisionServices(0x0, 0x0, (int)puidHigh, (int)puidLow, serviceSet.ToXml("ServiceInstanceSet"), out errorXml);
                        }
                        catch (Exception e)
                        {
                            // If the ProvisionServices call failed or (more likely) timed out,
                            // don't cause the purchase call to fail by allowing the exception to
                            // propogate.  The next time a reconciliation is performed, it will
                            // recognize that the subscription is not provisioned and reattempt
                            // the ProvisionServices call.

                            Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH,
                                "Provision error! Offering.PurchaseEx: PurchaseOffering succeeded, ProvisionServices not so.\r\n"
                                + "ServiceInstanceSet:\r\n"
                                + serviceSet.ToXml("ServiceInstanceSet") + "\r\n"
                                + "Exception:\r\n"
                                + e.Message );
                        }
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "...succeeded!" );

                    } // end of if addedServiceComponentSetCount > 0

                } // end of using

            }  // end of if ConnectToBilling

            offerPrice = outputPrice;
        }

        /// <summary>
        /// Sends a purchase request to SCS 2.5.
        /// </summary>
        /// <param name="offeringId"></param>
        /// <param name="friendlyName"></param>
        /// <param name="passportId"></param>
        /// <param name="accountId"></param>
        /// <param name="computeOnly"></param>
        /// <param name="shippingAddressId">IGNORED right now.  The default ship address (0) is always used.</param>
        /// <param name="payInfoId"></param>
        /// <param name="transactionGUID">This GUID is currently ignored; use null.</param>
        /// <param name="offerPrice"></param>
        /// <returns>A unique subscriptionId for the instance purchased</returns>
        public static void Purchase (string offeringId,
            long ownerId,
            long userId,
            string PMN,
            string accountId,
            bool computeOnly,
            string payInfoId,
            string transactionGUID,
            string expectedServiceComponentId,
            out Price offerPrice,
            out string subscriptionId,
            out string serviceInstanceId
            )
        {
            uint puidHigh;
            uint puidLow;
            string errorXml;
            string amountChargedXml = "";
            string referralSetXml = "";
            int    addedServiceComponentSetCount;
            string addedServiceComponentSet;
            Price  outputPrice  = new Price();



            serviceInstanceId = "";

            // SCG requested that we provide this XML fragment to them as
            // part of calling PurchaseOffering.
            referralSetXml =
              "<ReferralSet xmlns=\"urn:schemas-microsoft-com:billing-data\" >"
            +    "<Referral>"
            +       "<ReferralType> Xbox </ReferralType>"
            +       "<ReferralData>"
            +          "<ReferralID xmlns=\"urn:schemas-microsoft-com:Msnia\" >"
            +             "<InsertDate> " + DateTime.UtcNow.ToString() + " </InsertDate>"
            +             "<Product> " + offeringId + " </Product> "
            +          "</ReferralID>"
            +       "</ReferralData>"
            +    "</Referral>"
            + "</ReferralSet>";

            if ( BillingConfig.ConnectToBilling == false)
            {
                subscriptionId = BillingProvider.GenerateDummyId();
                serviceInstanceId = BillingProvider.GenerateDummyId();
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "SKIPPING Purchase call to SCS" );
            }
            else
            {
                using (BillingProvider bdk = new BillingProvider())
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Calling SCS's PurchaseOffering method via SOAP..." );
                    Int64Convert.ToUintPair(ownerId, out puidHigh, out puidLow);

                    bdk.PurchaseOffering(
                        0x0,                    // int lDelegatePUIDHigh,
                        0x0,                    // int lDelegatePUIDLow,
                        (int)puidHigh,          // int lRequesterPUIDHigh,
                        (int)puidLow,           // int lRequesterPUIDLow,
                        transactionGUID,        // string bstrTransactionGUID
                        computeOnly,            // bool fComputeOnly,
                        PMN,                    // string bstrSubscriptionName, [XName used to identify line items]
                        accountId,              // string bstrAccountId,
                        String.Empty,           // string bstrBaseSubscriptionID,
                        offeringId,             // string bstrOfferingGUID,
                        0,                      // int lOverrideAmount,
                        payInfoId,              // string bstrPaymentInstrumentId,
                        String.Empty,           // string lShippingAddressID,
                        String.Empty,           // string bstrActivationDate,
                        String.Empty,           // string bstrSubscriptionEndDate,
                        referralSetXml,         // string bstrReferralSetXML,
                        out errorXml,           // out string pbstrErrorXML,
                        out subscriptionId,     // out string pbstrSubscriptionID,
                        out amountChargedXml,   // out string pbstrAmountChargedXML,
                        out addedServiceComponentSetCount,  // out int plAddedServiceComponentSetCount,
                        out addedServiceComponentSet        // out string pbstrAddedServiceComponentSet
                        );

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "...succeeded! subId: " + subscriptionId );
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Added components: " + addedServiceComponentSet );

                    //
                    //  We make the assertion for v1 that there will only ever be a single (at most)
                    //  Service Component associated with and Offering.
                    //
                    if (addedServiceComponentSetCount > 1)
                    {
                        Xom.NtEvent(  XEvent.Id.MC_SPS_TOO_MANY_SERVICE_COMPONENTS,
                            "A subscription included more than one service component.  This is not allowed by "
                            + "our design.  SPG's BizOps must immediately remove the extra component(s). "
                            + "Only the first of the " + addedServiceComponentSetCount + " will be Provisioned "
                            + "correctly.\n" + addedServiceComponentSet);
                    }

                    // get real provisioning data if this is a real purchase.
                    if ( computeOnly == false && addedServiceComponentSetCount > 0)
                    {
                        ServiceInstance serviceSet = new ServiceInstance();
                        serviceSet.FromXml(addedServiceComponentSet, "ServiceInstanceSet");

                        // verify that the service component id SCS returns is
                        // the same one we have in UODB and are expecting
                        if ( expectedServiceComponentId != null )
                        {
                            if ( expectedServiceComponentId.ToLower() != serviceSet.ServiceComponentId.ToLower() )
                            {
                                Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "Service component id mismatch in SCS for offering " + offeringId + ": SCS returned " + serviceSet.ServiceComponentId + ", expected: " + expectedServiceComponentId);

                                throw new ExceptionWithEventId(
                                    XEvent.Id.COMMON_CONFIG_52,
                                    "The service component id associated with this offering (" + offeringId + ") "
                                    + "in UODB (" + expectedServiceComponentId + ") "
                                    + "does not match the service component associated with the offering in SCS (" + serviceSet.ServiceComponentId + ").");
                            }
                        }

                        // this Purchase output param must be set here,
                        // parenthetically to the task at hand.
                        serviceInstanceId = serviceSet.ServiceInstanceId;

                        // now set the inputs for provisioning
                        uint userHigh, userLow;
                        Int64Convert.ToUintPair(userId, out userHigh, out userLow);

                        serviceSet.PuidHigh = (int)userHigh;
                        serviceSet.PuidLow  = (int)userLow;
                        serviceSet.PMN      = PMN;
                        serviceSet.Role     = "User";
                        serviceSet.Details  = "&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;";
                        serviceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
                        serviceSet.InstanceFriendlyName = PMN;

                        // make sure we have enough information
                        serviceSet.ValidateFields();

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Provisioning with the following: " + serviceSet.ToXml("ServiceInstanceSet") );
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Calling SCS's ProvisionServices method via SOAP..." );

                        try
                        {
                            // now we can make an actual provisioning call.
                            bdk.ProvisionServices(0x0, 0x0, (int)puidHigh, (int)puidLow, serviceSet.ToXml("ServiceInstanceSet"), out errorXml);
                        }
                        catch (Exception e)
                        {
                            // no-op.
                            //
                            // If a larger exception is thrown here, the purchase may never be committed
                            // which would be a terrible thing since someone is paying for it.
                            // Better that we suck up the fact that SCS doesn't think something is
                            // Provisioned and have it be uncancelable via CSR than leave a paying customer
                            // without content rights, etc.
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_4, e,
                                "Provision error! Purchase succeeded, Provision not so."
                                + " Data integrity warning; SCS is out of sync with UODB-- SCS must be notified of the "
                                + " following request. \nSERVICEINSTANCESET:\n"
                                + serviceSet.ToXml("ServiceInstanceSet")
                            );
                        }
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "...succeeded!" );

                    } // end of if ComputeOnly

                } // end of using

            }  // end of if ConnectToBilling


            if ( computeOnly == true )
            {

                if( BillingConfig.ConnectToBilling == true )
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "amountChargedXml = " + amountChargedXml );
                    outputPrice.ParseFromXml(amountChargedXml);
                }
                else
                {
                    // constant dummy information
                    outputPrice.grossWhole = 10;
                    outputPrice.grossDecimal = 49;
                    outputPrice.netWhole = 9;
                    outputPrice.netDecimal = 99;
                    outputPrice.currencyCode = new char[] { 'U', 'S', 'D' };
                    outputPrice.cultureCode  = "en-US";
                }
            }

            offerPrice = outputPrice;
        }

        /// <summary>
        /// Cancels an offering.  Currently this functionality will perform an immediate cancel.
        /// </summary>
        /// <param name="subscriptionId"></param>
        /// <param name="passportId"></param>
        /// <param name="transactionGUID">This GUID is currently ignored; use null.</param>
        public static void Cancel(string instanceId, long passportId, out string transactionGUID)
        {
            Cancel(instanceId, passportId, 0, String.Empty, out transactionGUID);
        }

        /// <summary>
        /// Cancels an offering using the given cancelDate. This version of Cancel should not be used by new code and exists
        /// solely for maintaining compatibility with older code.
        /// </summary>
        /// <param name="subscriptionId"></param>
        /// <param name="passportId"></param>
        /// <param name="cancelDate">Pass "NOW" to bypass the expired state; use an empty string otherwise.</param>
        /// <param name="transactionGUID">This GUID is currently ignored; use null.</param>
        public static void Cancel(string instanceId, long passportId, ulong machinePuid, string cancelDate, out string transactionGUID)
        {
            transactionGUID = null;

            const string commentText = "Cancel request received through XBOS Front Door.";
            Guid trackingGuid = Guid.NewGuid();

            Cancel(instanceId, (ulong)passportId, cancelDate, commentText, trackingGuid);

            transactionGUID = trackingGuid.ToString();
        }


        /// <summary>
        /// Cancels an offering using the given cancelDate.
        /// </summary>
        /// <param name="subscriptionId"></param>
        /// <param name="passportId"></param>
        /// <param name="cancelDate">Pass "NOW" to bypass the expired state; use an empty string otherwise.</param>
        /// <param name="commentText">Comment Text to be included in the CommentInfo XML fragment</param>
        /// <param name="trackingGuid">The trackingGuid to use for the CancelSubscription call.</param>
        public static void Cancel(string instanceId, ulong passportId, string cancelDate, string commentText, Guid trackingGuid)
        {
            string errorXml;
            string cancelFeeXml;
            string subStatusXml;
            int    removedComponentsCount;
            string removedComponentsXml;

            // CTP has instructed us to always pass this specific comment code value when calling CancelSubscription
            const string commentCode = "00031003";

            string commentInfoXml = String.Format(
                "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                "<CommentCode>{0}</CommentCode>" +
                "<CommentText>{1}</CommentText>" +
                "</CommentInfo>",
                commentCode, commentText);

            if ( BillingConfig.ConnectToBilling == true )
            {
                // verify the integrity of what we're cancelling.
                if ( BillingProvider.IsDummyId(instanceId) == true )
                {
                    throw new Exception( "Offering.Cancel: Attempt to use a dummy service instance ID"
                        + " with a live connection to SCS.\n"
                        + "PUID: " + passportId + "\n"
                        + "Instance ID: " + instanceId
                        );
                }

                using (BillingProvider bdk = new BillingProvider())
                {
                    string subscriptionId = GetSubIDfromSvcInstanceID(instanceId);

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Offering.Cancel: derived subscriptionId {0} from instanceId {1}", subscriptionId, instanceId);

                    uint puidHigh;
                    uint puidLow;
                    Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

                    bdk.CancelSubscription(
                        0x0,                    // int lDelegatePUIDHigh,
                        0x0,                    // int lDelegatePUIDLow,
                        (int)puidHigh,          // int lRequesterPUIDHigh,
                        (int)puidLow,           // int lRequesterPUIDLow,
                        trackingGuid.ToString(),// string bstrTransactionGUID,
                        false,                  // bool fComputeOnly,
                        subscriptionId,         // string bstrSubscriptionID,
                        cancelDate,             // string bstrCancelDate,
                        commentInfoXml,         // string bstrCommentInfoXml,
                        out errorXml,           // out string pbstrErrorXML,
                        out cancelFeeXml,       // out string pbstrCancelFeeXML,
                        out subStatusXml,       // out string pbstrSubscriptionStatusInfoXML,
                        out removedComponentsCount, // out int piRemovedServiceComponentSetCount,
                        out removedComponentsXml    // out string pbstrRemovedServiceComponentSetXML
                        );
                }
            }
            else
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Offering.Cancel: SKIPPING Cancel call to SCS, will NOT appear as canceled to user!" );
            }
        }

        /// <summary>
        /// Utility function to retrive sub ID from an instance ID.
        /// </summary>
        /// <param name="instanceId"></param>
        /// <returns></returns>
        private static string GetSubIDfromSvcInstanceID(string instanceId)
        {
            PsoEncrypterClass pso = new PsoEncrypterClass();
            return pso.ConvertServiceRefIDToSubID(instanceId);
        }

        /// <summary>
        /// This method is used by a service provider to determine subscriptionID and offerID given a
        /// service instance ID.
        /// </summary>
        /// <param name="passportId">PUID</param>
        /// <param name="serviceInstanceId">16-character Service Instance ID</param>
        public static void GetSubscriptionInfo(long passportId, string serviceInstanceId,
            out string subscriptionId, out string billingOfferId)
        {
            BillingProvider bdk = new BillingProvider();

            uint puidHigh;
            uint puidLow;
            string errorXml;
            string subInfoSetXml = "";
            int    subInfoCount  = 0;

            if ( BillingConfig.ConnectToBilling )
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Calling SCS's GetSubscriptions method via SOAP..." );
                Int64Convert.ToUintPair(passportId, out puidHigh, out puidLow);
                bdk.GetSubscriptions(
                    0x0,                    // int lDelegatePUIDHigh,
                    0x0,                    // int lDelegatePUIDLow,
                    (int)puidHigh,          // int lRequesterPUIDHigh,
                    (int)puidLow,           // int lRequesterPUIDLow,
                    serviceInstanceId,      // string bstrObjectId,
                    out errorXml,           // out string pbstrErrorXML,
                    out subInfoCount,       // out int lpSubscriptionInfoCount
                    out subInfoSetXml      // out string pbstrSubscriptionInfoSetXML) {
                    );
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "...success!" );
            }
            else
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "SKIPPING GetSubscriptions call to SCS." );
            }

            if( BillingConfig.ConnectToBilling )
            {
                // we assume that we will only get a single record back on this.
                Debug.Assert(subInfoCount == 1);

                // the call was successful.  we need to parse the XML output now.
                if ((subscriptionId = GrabFromXml(subInfoSetXml, "SubscriptionId")) == null)
                {
                    throw new Exception("Can't find SubscriptionId element in " + subInfoSetXml);
                }
                if ((billingOfferId = GrabFromXml(subInfoSetXml, "OfferingGUID")) == null )
                {
                    throw new Exception("Can't find OfferingGUID in " + subInfoSetXml);
                }
            }
            else
            {
                subscriptionId = BillingProvider.GenerateDummyId();
                billingOfferId = "00000000-0000-0000-0000-000000000000";
            }
            // nothing to return
        }

        /// <summary>
        /// Provides a quick string search way to grab the text of an XML node
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="element"></param>
        /// <returns></returns>
        private static string GrabFromXml(string xml, string element)
        {
            string tagName;
            int    startPos, endPos;

            tagName = "<" + element + ">";
            if( (startPos = xml.IndexOf(tagName)) <= 0 )
            {
                return null;
            }
            startPos += tagName.Length;

            tagName = "</" + element + ">";
            if( (endPos = xml.IndexOf(tagName)) <= 0 )
            {
                return null;
            }

            return xml.Substring(startPos, (endPos-startPos));
        }

        /// <summary>
        /// Commits the subscription Purchase
        /// </summary>
        public static void CommitSubscriptionPurchase(uint op, ulong userPuid,ulong offerId,ulong machinePuid, OfferInfo oi, string serviceInstanceId, string tempId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal((long)userPuid);
                ws.StoredProc = "dbo.p_xbos_subscription_purchase";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@op", op);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@machinepuid", machinePuid);
                ws.AddParameter(ParamType.INPUT, "@uid_catalogOfferId", oi.offerId);
                ws.AddParameter(ParamType.INPUT, "@uid_catalogOfferInstanceId", oi.offerInstanceId);
                ws.AddParameter(ParamType.INPUT, "@instanceid", serviceInstanceId, 16);    // 16-char serv instance ID
                ws.AddParameter(ParamType.INPUT, "@tempid", tempId, 16);
                ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerId);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_196,
                        "Failure (hr = " + hr + ") committing purchase: " +
                        "Operation " + op + ", user: 0x" + userPuid.ToString("x") + ", " +
                        "machine: 0x" + machinePuid.ToString("x") + ", " +
                        "offer id: 0x" + oi.offerId.ToString() + ", " +
                        "offerInstance id: 0x" + oi.offerInstanceId.ToString() + ", " +
                        "service instance: " + serviceInstanceId);
                }

                AuditStream.Write(userPuid, AuditSubsystem.XBOS, ws, "success");
            }
        }
        public static void CommitPurchase(uint op, ulong userPuid, ulong machinePuid, Offer o, string serviceInstanceId, string tempId,Guid? catalogOfferId,Guid? catalogOfferInstanceId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(o.IsPerUser ? (long)userPuid : (long)machinePuid);
                ws.StoredProc = "dbo.p_xbos_purchase";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@op", op);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@machinepuid", machinePuid);
                ws.AddParameter(ParamType.INPUT, "@offerid", o.OfferId);
                ws.AddParameter(ParamType.INPUT, "@instanceid", serviceInstanceId, 16);    // 16-char serv instance ID
                ws.AddParameter(ParamType.INPUT, "@tempid", tempId, 16);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                if (catalogOfferId.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@catalogOfferId", catalogOfferId.Value);
                }
                if (catalogOfferInstanceId.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@catalogOfferInstanceId", catalogOfferInstanceId.Value);
                }

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if(HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_196,
                        "Failure (hr = " + hr + ") committing purchase: " +
                        "Operation " + op + ", user: 0x" + userPuid.ToString("x")+ ", " +
                        "machine: 0x" + machinePuid.ToString("x") + ", " +
                        "offer id: 0x" + o.OfferId.ToString("x") + ", " +
                        "service instance: " + serviceInstanceId);
                }

                AuditStream.Write(userPuid, AuditSubsystem.XBOS, ws, "success");
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\MigrateUtil.cs ===
using System;
using System.Globalization;
using System.Net;

using xonline.common.config;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.mgmt;

using Microsoft.Webstore.WstClient;


// migrate notes:
//
// check subscription status - don't allow migration of suspended accounts
//
// for juvenile accounts,
//    set  allow xbox1 logon off,
//    parental control group restrictred
//
namespace xonline.common.billing
{
    public class XeMigrateUtil
    {
        public static string GetRoleXml(string role, string pmn, ulong puid)
        {
            uint puidHigh;
            uint puidLow;
            Int64Convert.ToUintPair((long)puid, out puidHigh, out puidLow);

            string roleXml =
                "<RoleAssignment xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                    "<Role>" + role + "</Role>" +
                    "<PUIDHigh>" + (int)puidHigh + "</PUIDHigh>" +
                    "<PUIDLow>" + (int)puidLow + "</PUIDLow>" +
                    "<PMN>" + pmn + "</PMN>" +
                "</RoleAssignment>";

            return roleXml;
        }

        public static void AddDelegatedAdmin(string accountId, string pmn, ulong xboxPuid, ulong passportPuid)
        {
            // record AddRoleAssignment starting

            BillingProvider bp = new BillingProvider();
            if ( BillingConfig.ConnectToBilling == false )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "XeMigrateUtil.AddDelegatedAdmin: skipping AddRoleAssignment...");
            }

            uint xboxPuidHigh;
            uint xboxPuidLow;
            Int64Convert.ToUintPair((long)xboxPuid, out xboxPuidHigh, out xboxPuidLow);

            string roleXml = GetRoleXml("BillableAccountDelAdmin", pmn, passportPuid);

            string errorXml = "";

            bp.AddRoleAssignment(
                0, 0,                                   // delegate puid
                (int) xboxPuidHigh, (int) xboxPuidLow,  // requester puid
                accountId,                              // object id
                roleXml,                                // role assignment XML
                out errorXml);                          // error XML
        }

        public static void PromoteDelegatedAdmin(string accountId, string pmn, ulong xboxPuid, ulong passportPuid)
        {
            // record AddRoleAssignment attempt

            BillingProvider bp = new BillingProvider();
            if ( BillingConfig.ConnectToBilling == false )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "XeMigrateUtil.PromoteDelegatedAdmin: skipping AddRoleAssignment...");
            }

            uint xboxPuidHigh;
            uint xboxPuidLow;
            Int64Convert.ToUintPair((long)xboxPuid, out xboxPuidHigh, out xboxPuidLow);

            string roleXml = GetRoleXml("BillableAccountAdmin", pmn, passportPuid);

            string errorXml = "";

            bp.AddRoleAssignment(
                0, 0,                                   // delegate puid
                (int) xboxPuidHigh, (int) xboxPuidLow,  // requester puid
                accountId,                              // object id
                roleXml,                                // role assignment XML
                out errorXml);                          // error XML
        }

        public static void RemoveDelegatedAdmin(string accountId, string pmn, ulong xboxPuid, ulong passportPuid)
        {
            // record RemoveRoleAssignment attempt

            BillingProvider bp = new BillingProvider();
            if ( BillingConfig.ConnectToBilling == false )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "XeMigrateUtil.RemoveDelegatedAdmin: skipping RemoveRoleAssignment...");
            }

            uint passportPuidHigh;
            uint passportPuidLow;
            Int64Convert.ToUintPair((long)passportPuid, out passportPuidHigh, out passportPuidLow);

            string roleXml = GetRoleXml("BillableAccountDelAdmin", pmn, xboxPuid);

            string errorXml = "";

            bp.RemoveRoleAssignment(
                0, 0,                                   // delegate puid
                (int) passportPuidHigh,                 // requester puid
                (int) passportPuidLow,
                accountId,                              // object id
                roleXml,                                // role assignment XML
                out errorXml);                          // error XML
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\MigrateUserData.cs ===
/*
 * MigrateUserData.cs
 *
 * MigrateUser tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;                           // Exception
using System.IO;                        // StringWriter
using System.Collections.Generic;       // List<T>
using System.Xml;                       // XmlNode
using System.Diagnostics;               // Debug.Assert

using xonline.common.user;              // User
using xonline.common.utilities;         // CountryDictionary
using xonline.common.offer;             // Offer
using xonline.common.puidmgr;           // PUIDMgr
using xonline.common.service;           // XRLException

namespace xonline.common.billing.migrateuser
{
    internal class UserData
    {
        #region private data
        private const string UODB_DATABASE = "uodb";
        private const ulong SILVER_OFFER_ID = 0xfffe07d180000011;

        private static string[] AccountTypes = new string[]
        {
            "XBOX1",
            "XBOX.COM",
            "XBOX360",
            "ZUNE",
            "GAMESFORWINDOWSLIVE",
        };

        private static string[] PaymentInstrumentTypes = new string[]
        {
            "NONE",
            "CREDITCARD",
            "DIRECTDEBIT",
            "WHOLESALE",
            "PAYPALPAYIN",
        };

        private TableList tables = new TableList(UODB_DATABASE);
        byte accountType;
        private string gamertag;
        private ulong xuid;
        private string billingAccountId;
        private long offlineXuid;
        private DateTime birthdate;
        private string countryCode;
        private List<ulong> offerIds = new List<ulong>();
        private int pointsBalance;
        private List<string> paymentInstruments = new List<string>();
        private PassportData passportData;

        public string Gamertag { get { return gamertag; } }

        #endregion

        public UserData(User user)
        {
            Printer.Print("Loading UserData from User Struct...", Printer.Color.Debug);
            accountType = user.AccountType;
            gamertag = user.GamerTag;
            xuid = user.Puid;
            billingAccountId = user.AccountId;
            offlineXuid = (long)user.OfflineXuid;
            birthdate = user.Birthdate;
            countryCode = CountryDictionary.CountryCode(user.CountryId);
            passportData = new PassportData(user);
            LoadBillingInfo(user);
            Printer.Print("Loaded UserData from User Struct!", Printer.Color.Info);

            AddTables();
        }

        private void AddTables()
        {
            // load all references to the user's puid
            AddTable_xuid("t_users", "bi_user_puid");
            AddTable_xuid("t_user_settings", "bi_user_puid");
            AddTable_xuid("t_subscriptions", "bi_primary_puid");
            AddTable_xuid("t_user_console_audit_list", "bi_user_puid");
            AddTable_xuid("t_xmsg_user_titles", "bi_user_puid");
            AddTable_xuid("t_transactions", "bi_owner_puid");
            AddTable_xuid("t_achievements", "bi_puid");
            AddTable_xuid("t_awarded_avatar_items", "bi_user_puid");
            AddTable_xuid("t_user_billing_queue", "bi_user_puid");
            AddTable_xuid("t_user_licenses", "bi_user_id");
            AddTable_xuid("t_user_rating_data", "bi_user_puid");
            AddTable_xuid("t_user_audit_info", "bi_user_puid");

            // load all references to the user's passport puid
            AddTable_passportPuid("t_user_passport_puids", "bi_user_passport_puid");

            //load all references to the user's offline xuid
            AddTable_offlineXuid("t_offline_xuids", "bi_offline_xuid");

            // load all references to the user's gamertag
            AddTable_gamertag("t_user_names", "vc_gamertag");
            AddTable_gamertag("t_user_name_deletes", "vc_gamertag");
            AddTable_gamertag("t_xprof_team_members", "vc_gamertag");
        }

        public UserData(string userDataXML)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(userDataXML);

            XmlNode userDataNode = doc.FirstChild;
            XmlUtil.ValidateNode(userDataNode, "User_Data");

            XmlNode node = userDataNode.FirstChild;
            accountType = GetAccountType(XmlUtil.ReadNode(node, "Account_Type"));

            node = node.NextSibling;
            gamertag = XmlUtil.ReadNode(node, "Gamertag");

            node = node.NextSibling;
            xuid = Convert.ToUInt64(XmlUtil.ReadNode(node, "Xuid"));

            node = node.NextSibling;
            billingAccountId = XmlUtil.ReadNode(node, "Billing_Account_ID");

            node = node.NextSibling;
            offlineXuid = Convert.ToInt64(XmlUtil.ReadNode(node, "Offline_Xuid"));

            node = node.NextSibling;
            passportData = new PassportData(node);

            node = node.NextSibling;
            birthdate = Convert.ToDateTime(XmlUtil.ReadNode(node, "Birth_Date"));

            node = node.NextSibling;
            countryCode = XmlUtil.ReadNode(node, "Country_Code");

            node = node.NextSibling;
            pointsBalance = Convert.ToInt32(XmlUtil.ReadNode(node, "Points_Balance"));

            node = node.NextSibling;
            XmlUtil.ValidateNode(node, "Payment_Options");
            foreach (XmlNode paymentInstrumentNode in node.ChildNodes)
            {
                paymentInstruments.Add(XmlUtil.ReadNode(paymentInstrumentNode, "Payment_Option"));
            }

            node = node.NextSibling;
            XmlUtil.ValidateNode(node, "Offer_IDs");
            foreach (XmlNode offerIdNode in node.ChildNodes)
            {
                offerIds.Add(Convert.ToUInt64(XmlUtil.ReadNode(offerIdNode, "Offer_ID"), 16));
            }

            node = node.NextSibling;
            tables = new TableList(node);
        }

        private void WriteToStream(XmlTextWriter w)
        {
            w.Formatting = Formatting.Indented;
            w.WriteStartElement("User_Data");
                w.WriteElementString("Account_Type", AccountTypes[accountType]);
                w.WriteElementString("Gamertag", gamertag);
                w.WriteElementString("Xuid", xuid.ToString());
                w.WriteElementString("Billing_Account_ID", billingAccountId);
                w.WriteElementString("Offline_Xuid", offlineXuid.ToString());
                passportData.WriteToStream(w);
                w.WriteElementString("Birth_Date", birthdate.ToString());
                w.WriteElementString("Country_Code", countryCode.ToString());
                w.WriteElementString("Points_Balance", pointsBalance.ToString());
                w.WriteStartElement("Payment_Options");
                foreach (string paymentInstrument in paymentInstruments)
                    { w.WriteElementString("Payment_Option", paymentInstrument); }
                    w.WriteEndElement();

                w.WriteStartElement("Offer_IDs");
                foreach (ulong offerId in offerIds)
                    { w.WriteElementString("Offer_ID", String.Format("{0:X}", offerId)); }
                    w.WriteEndElement();

                tables.WriteToFile(w);
            w.WriteEndElement();
        }

        public string Write()
        {
            string userDataXML = "";
            try
            {
                StringWriter stringStream = new StringWriter();
                XmlTextWriter w = new XmlTextWriter(stringStream);
                WriteToStream(w);
                userDataXML = stringStream.ToString();
            }
            catch (Exception e)
            {
                string errorString = "Error writing data to xml: " + e.Message;
                Printer.Print(errorString, Printer.Color.Error);
                throw new Exception(errorString);
            }

            return userDataXML;
        }

        private void LoadBillingInfo(User user)
        {
            Printer.Print("Loading billing user data from User Struct...", Printer.Color.Debug);

            if (BillingProvider.IsDummyId(user.AccountId))
            {
                Printer.Print("User has a dummy billing account id!", Printer.Color.Warning);
                return;
            }

            // load subscriptions and offers for this user
            SubscriptionInfoCollection subscriptionSet = null;
            try
            {
                subscriptionSet = Subscription.GetSubscriptionInfoSet(user.BillingPuid, user.AccountId);
            }
            catch (BillingProviderException e)
            {
                if (e.HResult == BdkError.BDK_E_NOPERMISSION)
                {
                    Printer.Print("Access denied: This is likely because the billing account ID and user passport puid do not match.", Printer.Color.Warning);
                    return;
                }
                throw;
            }

            foreach (SubscriptionInfo subInfo in subscriptionSet.SubscriptionInfoList)
            {
                bool authoritative = false;
                offerIds.Add(Offer.OfferIdFromBillingOfferId(subInfo.OfferingGUID, 0, out authoritative));
            }

            // get the balance of this user
            pointsBalance = GetPointsBalance(user);

            // the the payment options of this user
            PaymentInstrumentTypeEnum[] payInfoTypes =
                new PaymentInstrumentTypeEnum[] {   PaymentInstrumentTypeEnum.CreditCard,
                                                    PaymentInstrumentTypeEnum.DirectDebit,
                                                    PaymentInstrumentTypeEnum.Wholesale,
                                                    PaymentInstrumentTypeEnum.PayPalPayin };
            PaymentInstrumentInfoSet pIs = PaymentInstrumentInfoSet.GetPaymentInstruments(user.BillingPuid, user.AccountId, false, payInfoTypes);
            foreach (PaymentInfo pI in pIs.PaymentInstrumentInfoList)
            {
                paymentInstruments.Add(PaymentInstrumentTypes[(int)pI.PaymentInstrumentType]);
            }

            Printer.Print("Loaded billing user data from User Struct!", Printer.Color.Info);
        }

        private static int GetPointsBalance(User user)
        {
            int pointsBalance = 0;
            bool aboveLowBalance;
            DMPWSDL.Status statusUser;
            string country;

            DMPClient dmp = new DMPClient(user.CountryId);
            dmp.GetBalance(user.BillingPuid, out pointsBalance, out aboveLowBalance, out statusUser, out country);

            return pointsBalance;
        }

        private void AddTable_xuid( string tableName,
                                    string primaryColumnName)
        {
            tables.Add(tableName, "xuid", primaryColumnName, xuid);
        }

        private void AddTable_passportPuid( string tableName,
                                            string primaryColumnName)
        {
            tables.Add(tableName, "passportPuid", primaryColumnName, passportData.UserPassportPuid);
        }

        private void AddTable_offlineXuid(  string tableName,
                                            string primaryColumnName)
        {
            tables.Add(tableName, "offlineXuid", primaryColumnName, offlineXuid);
        }

        private void AddTable_gamertag( string tableName,
                                        string primaryColumnName)
        {
            tables.Add(tableName, "gamertag", primaryColumnName, gamertag);
        }

        public void WriteUser(string newGamertag, ref string userEmail, ref string userPassword)
        {
            tables.VerifySchema();

            Printer.Print("Writing user into current environment...", Printer.Color.Debug);

            // hide any personal data
            HidePII();

            // update user info for new environment
            TranslateUser(newGamertag, ref userEmail, ref userPassword);

            // write the user into uodb
            Printer.Print("Writing user to uodb...", Printer.Color.Debug);
            tables.WriteToDB("xuid", xuid);
            tables.WriteToDB("passportPuid", passportData.UserPassportPuid);
            tables.WriteToDB("offlineXuid", offlineXuid);
            tables.WriteToDB("gamertag", gamertag);
            Printer.Print("Done Writing user to uodb!", Printer.Color.Info);

            // load up the user
            User u = new User();
            u.Load(xuid);

            // create user in the billing system
            CreateBillingUser(u);

            // set no age out
            Printer.Print("    Calling Set No Age Out...", Printer.Color.Debug);
            SetNoAgeOutUtil.SetNoAgeOut(xuid, passportData.UserPassportPuid);
            Printer.Print("    Called Set No Age Out!", Printer.Color.Info);

            // ups
            Printer.Print("    Updating UPS Profile...", Printer.Color.Debug);
            AccountUtil.UpsUpdateGamertag(u);
            Printer.Print("    Updated UPS Profile!", Printer.Color.Info);

            //if the user is supposed to have an invalid passport account, then make it so.
            passportData.InvalidatePassport();

            Printer.Print("Wrote user into current environment!", Printer.Color.Info);
        }

        private static Address CreateDummyAddress(string countryCode)
        {
            Address addr = new Address();
            addr.FriendlyName = BillingProvider.FriendlyName;
            addr.Street1 = "9931 Lovely Lane NE";
            addr.Street2 = "";
            addr.City = "Redmond";
            addr.District = "";
            addr.StateProvince = "WA";
            addr.PostalCode = "98052";
            addr.CountryCode = countryCode;

            return addr;
        }

        private static Phone CreateDummyPhone(string countryCode)
        {
            Phone ph = new Phone();
            ph.AreaCode = "425";
            ph.PhoneNumber = "7075555";
            ph.PhoneExtension = "";
            ph.CountryCode = countryCode;

            return ph;
        }

        private static PaymentInfo CreateDummyPaymentInfo(PaymentInstrumentTypeEnum piType, string countryCode)
        {
            Printer.Print("        Creating Payment Instrument...", Printer.Color.Debug);
            PaymentInfo pay = new PaymentInfo();
            pay.FriendlyName = BillingProvider.FriendlyName;
            pay.PaymentInstrumentType = piType;

            switch (piType)
            {
                case PaymentInstrumentTypeEnum.CreditCard:
                    CreateDummyPaymentInfo_CreditCard(pay);
                    break;

                case PaymentInstrumentTypeEnum.DirectDebit:
                    CreateDummyPaymentInfo_DebitCard(pay);
                    break;

                case PaymentInstrumentTypeEnum.Wholesale:
                    CreateDummyPaymentInfo_Wholesale(pay);
                    break;

                case PaymentInstrumentTypeEnum.PayPalPayin:
                    CreateDummyPaymentInfo_PayPalPayin(pay);
                    break;

                case PaymentInstrumentTypeEnum.None:
                    break;

                default:
                    string errorString = "Unknown payment instrument: '" + piType + "'";
                    Printer.Print(errorString, Printer.Color.Error);
                    throw new Exception(errorString);
            }

            pay.BillingPhone = CreateDummyPhone(countryCode);
            pay.BillingAddress = CreateDummyAddress(countryCode);
            Printer.Print("        Created [" + PaymentInstrumentTypes[(int)piType] + "] Payment Instrument!", Printer.Color.Info);
            return pay;
        }

        private static void CreateDummyPaymentInfo_CreditCard(PaymentInfo pay)
        {
            pay.CreditCard.CardType = CardTypeEnum.Visa;
            pay.CreditCard.AccountHolderName = "John Connor";
            pay.CreditCard.AccountNumber = AccountUtil.GenerateCCNumber();
            pay.CreditCard.CvmCode = "007";
            pay.CreditCard.ExpirationDate = DateTime.Now.AddYears(4);
        }

        private static void CreateDummyPaymentInfo_DebitCard(PaymentInfo pay)
        {
            pay.DirectDebit.AccountHolderName = "John Connor";
            // copied from DirectDebitRandomizer
            Random rand = new Random();
            pay.DirectDebit.BankCode = String.Empty;
            pay.DirectDebit.BranchCode = System.Math.Floor((rand.NextDouble() * 90000000) + 10000000).ToString();
            pay.DirectDebit.AccountNumber = System.Math.Floor((rand.NextDouble() * 9999999990) + 10).ToString();
            pay.DirectDebit.CheckDigits = String.Empty;
        }

        private static void CreateDummyPaymentInfo_Wholesale(PaymentInfo pay)
        {
            pay.Wholesale.AccountHolderName = "John Connor";
            // copied from XrlXeCreateWholesaleAccountTestBase
            pay.Wholesale.ExternalReferenceId = Util.GenerateRandomString(12);
            pay.Wholesale.WholesalePartner = "CHINATELCOM Wireline";
            pay.Wholesale.EncryptedPassword = string.Empty;
        }

        private static void CreateDummyPaymentInfo_PayPalPayin(PaymentInfo pay)
        {
            // bwah?
        }

        private static Account CreateDummyAccountInfo(User u, PaymentInstrumentTypeEnum piType)
        {
            string countryCode = CountryDictionary.CountryCode(u.CountryId);

            Account acct = new Account();
            acct.FriendlyName = BillingProvider.FriendlyName;
            acct.IsBusinessAccount = false;
            acct.CompanyName = "";
            acct.FirstName = "John";
            acct.LastName = "Connor";
            acct.Email = "jconnor@cyberdyne.net";
            acct.CountryCode = countryCode;
            acct.Locale = AccountUtil.BuildLocale((ushort)u.LanguageId, u.CountryId);
            acct.PayInfo = CreateDummyPaymentInfo(piType, countryCode);
            acct.UserPhone = acct.PayInfo.BillingPhone;
            acct.UserAddress = acct.PayInfo.BillingAddress;

            return acct;
        }

        private void AddPaymentInstruments(User u, PaymentInstrumentTypeEnum existingPaymentType)
        {
            string countryCode = CountryDictionary.CountryCode(u.CountryId);
            foreach (string paymentInstrument in paymentInstruments)
            {
                // if we already gave them this payment type, pass on the first one.
                PaymentInstrumentTypeEnum piType = (PaymentInstrumentTypeEnum)Array.IndexOf(PaymentInstrumentTypes, paymentInstrument);
                if (piType == existingPaymentType)
                {
                    existingPaymentType = PaymentInstrumentTypeEnum.None;
                    continue;
                }

                PaymentInfo payInfo = CreateDummyPaymentInfo(piType, countryCode);
                payInfo.AddToBillingAccount(u.BillingPuid, u.AccountId);
            }
        }

        private static void GetTokenFromOffer(User u, Offer o, ref string billingToken)
        {
            if (o.AcceptsVoucher(u.CountryId, (int)TierEnum.NewUser))
            {
                Printer.Print("    This offer [ " + String.Format("0x{0:X}", o.OfferId) + " ] needs a token, getting one...", Printer.Color.Debug);
                switch (o.OfferId)
                {
                    // copied these from \private\test\LiveInfra\LiveLib\lib\common\Offers.cs
                    case 0XFFFE07D180000018: //BaseOffers.GoldPP1Month:
                        billingToken = "CRYCP-BM9W4-KH3B6-6MRQT-HHGBF";
                        break;
                    case 0XFFFE07D180000019: //BaseOffers.GoldPP3Month:
                        billingToken = "MBYVH-KCWDH-7HXBB-HT7F7-7QTH8";
                        break;
                    case 0XFFFE07D18000001A: //BaseOffers.GoldPP1Year:
                        billingToken = "89R44-J8JBF-TJQQB-8QCQC-HW8BF";
                        break;
                    case 0XFFFE07D18000001B: //BaseOffers.GoldPP13Month:
                        billingToken = "V28YB-4F6MW-YMMWY-QX8G4-BPGBK";
                        break;
                    default:
                        {
                            string errorString = "No token found for offer id: [ " + String.Format("0x{0:X}", o.OfferId) + " ] !";
                            Printer.Print(errorString, Printer.Color.Error);
                            throw new Exception(errorString);
                        }
                }
                Printer.Print("    Got a token: " + billingToken, Printer.Color.Info);
            }
        }

        private void GetBaseOffer(ref Offer baseOffer)
        {
            Printer.Print("    Finding user's base offer...", Printer.Color.Debug);
            baseOffer = null;
            foreach (ulong offerId in offerIds)
            {
                Offer o = Offer.CreateInstance(offerId);
                if (o.IsBaseOffer)
                {
                    baseOffer = o;
                    break;
                }
            }
            if (baseOffer == null)
            {
                Printer.Print("Failed to find a base offer, user must be silver.", Printer.Color.Warning);
                baseOffer = Offer.CreateInstance(SILVER_OFFER_ID);
            }

            Printer.Print("    Found the user's base offer: OfferId = [ " + String.Format("0x{0:X}", baseOffer.OfferId) + " ] !", Printer.Color.Info);
        }

        private static int GetPaymentTypeForOffer(byte countryId, Offer o)
        {
            if(o.AcceptsVoucherNoTier(countryId))
                return (int)PaymentTypeEnum.Token;

            if(o.AcceptsCreditCardNoTier(countryId))
                return (int)PaymentTypeEnum.CreditCard;

            if (o.AcceptsWholesaleNoTier(countryId))
                return (int)PaymentTypeEnum.Wholesale;

            string errorString = "Unable to determine payment type for offer id: [ " + String.Format("0x{0:X}", o.OfferId) + " ] !";
            Printer.Print(errorString, Printer.Color.Error);
            throw new Exception(errorString);
        }

        private static PaymentInstrumentTypeEnum PaymentTypeToPaymentInstrument(PaymentTypeEnum paymentType)
        {
            switch (paymentType)
            {
                case PaymentTypeEnum.CreditCard:
                    return PaymentInstrumentTypeEnum.CreditCard;

                case PaymentTypeEnum.Wholesale:
                    return PaymentInstrumentTypeEnum.Wholesale;

                default:
                    return PaymentInstrumentTypeEnum.None;
            }
        }

        private void CreateBillingUser(User u)
        {
            Printer.Print("Creating Billing user...", Printer.Color.Debug);

            if (BillingProvider.IsDummyId(billingAccountId))
            {
                Printer.Print("User has a dummy billing account id!", Printer.Color.Warning);
                return;
            }

            Offer baseOffer = null;
            GetBaseOffer(ref baseOffer);

            string billingToken = "";
            GetTokenFromOffer(u, baseOffer, ref billingToken);

            int paymentType = GetPaymentTypeForOffer(u.CountryId, baseOffer);

            Printer.Print("    Creating Billing Account...", Printer.Color.Debug);
            Account acct = CreateDummyAccountInfo(u, PaymentTypeToPaymentInstrument((PaymentTypeEnum)paymentType));
            string guid = Guid.NewGuid().ToString();
            string acctId = acct.Create(u.BillingPuid, u.BillingPMN, guid);
            string acctPayInfoId = acct.PaymentInstrumentId;
            DMPClient dmpClient = new DMPClient(u.CountryId);
            dmpClient.RegisterUser(u.BillingPuid);
            Printer.Print("    Created Billing Account!", Printer.Color.Info);

            Printer.Print("    Purchasing Base Offer...", Printer.Color.Debug);
            Price price;
            string subscriptionId = "";
            string serviceInstanceId = "";
            string encryptedBillingToken = "";

            if (!string.IsNullOrEmpty(billingToken))
            {
                Debug.Assert(paymentType == (int)PaymentTypeEnum.Token);
                BillingProvider bdk = new BillingProvider();
                encryptedBillingToken = bdk.EncryptNumber(billingToken);
            }
            if (!string.IsNullOrEmpty(encryptedBillingToken))
            {
                acctPayInfoId = "";
            }

            string billingOfferId = baseOffer.BillingOfferId(u.CountryId, (int)TierEnum.NewUser, paymentType);

            // it's okay if we don't get a billing offer id, not all offers need this (like silver)
            if (!string.IsNullOrEmpty(billingOfferId))
            {
                string purchGuid = Guid.NewGuid().ToString();
                Offering.PurchaseEx(
                    billingOfferId,
                    u.BillingPuid,
                    u.Puid,
                    u.BillingPMN,
                    acctId,
                    acctPayInfoId,
                    encryptedBillingToken,
                    purchGuid,
                    baseOffer.ServiceComponentId,
                    out price,
                    out subscriptionId,
                    out serviceInstanceId);
            }

            u.AccountId = acctId;
            u.PaymentInfoId = acctPayInfoId;
            u.Save();
            Printer.Print("    Purchased Base Offer!", Printer.Color.Info);

            // commit this to the transactions table when it finally succeeds
            Printer.Print("    Committing transaction...", Printer.Color.Debug);
            Transaction.RecordNewAccount(u.OwnerPuid, subscriptionId, acctId, u.MachinePuid);
            Printer.Print("    Committed transaction!", Printer.Color.Info);

            // add payment instruments
            Printer.Print("    Adding Payment Instruments...", Printer.Color.Debug);
            AddPaymentInstruments(u, PaymentTypeToPaymentInstrument((PaymentTypeEnum)paymentType));
            Printer.Print("    Added Payment Instruments!", Printer.Color.Info);

            Printer.Print("Creating Billing user!", Printer.Color.Info);
        }

        private byte GetAccountType(string accountTypeString)
        {
            string errorString;
            switch ((byte)Array.IndexOf(AccountTypes, accountTypeString))
            {
                case User.XenonAccount:
                    return User.XenonAccount;

                case User.Xbox1Account:
                case User.XboxComAccount:
                case User.ZuneAccount:
                case User.PanoramaAccount:
                    errorString = "Unsupported account type for write: '" + accountTypeString + "'";
                    Printer.Print(errorString, Printer.Color.Error);
                    throw new Exception(errorString);

                default:
                    errorString = "Unknown account type: '" + accountTypeString + "'";
                    Printer.Print(errorString, Printer.Color.Error);
                    throw new Exception(errorString);
            }
        }

        private void TranslateUser(string newGamertag, ref string userEmail, ref string userPassword)
        {
            Printer.Print("Translating user data...", Printer.Color.Debug);

            // generate new key values

            Printer.Print("    Creating new Xuid...", Printer.Color.Debug);
            ulong newXuid = PUIDMgr.GetNewPUID();
            Printer.Print("    Created new Xuid!", Printer.Color.Info);

            ulong newPassportPuid, newOwnerPassportPuid;
            passportData.TranslateUser( newGamertag, birthdate, countryCode,
                                        ref userEmail, ref userPassword,
                                        out newPassportPuid, out newOwnerPassportPuid);

            Printer.Print("    Creating new Offline Xuid...", Printer.Color.Debug);
            long newOfflineXuid = (long)AccountUtil.GenerateOfflineXuid(newPassportPuid);
            Printer.Print("    Created new Offline Xuid!", Printer.Color.Info);

            // swap to new values

            Printer.Print("    Swapping XUID ( " + xuid.ToString() + " ) ==> ( " + newXuid.ToString() + " )", Printer.Color.Debug);
            tables.SwapValues(xuid.ToString(), newXuid.ToString());
            Printer.Print("    Success swapping XUID!", Printer.Color.Info);

            Printer.Print("    Swapping Offline XUID ( " + offlineXuid.ToString() + " ) ==> ( " + newOfflineXuid.ToString() + " )", Printer.Color.Debug);
            tables.SwapValues(offlineXuid.ToString(), newOfflineXuid.ToString());
            Printer.Print("    Success swapping Offline XUID!", Printer.Color.Info);

            Printer.Print("    Swapping Passport Puid ( " +  passportData.UserPassportPuid.ToString() + " ) ==> ( " + newPassportPuid.ToString()+ " )", Printer.Color.Debug);
            tables.SwapValues(passportData.UserPassportPuid.ToString(), newPassportPuid.ToString());
            Printer.Print("    Success swapping Passport Puid!", Printer.Color.Info);

            if (passportData.ChildAccount)
            {
                Printer.Print("    Swapping Owner Passport Puid ( " + passportData.OwnerPassportPuid.ToString() + " ) ==> ( " + newOwnerPassportPuid.ToString() + " )", Printer.Color.Debug);
                tables.SwapValues(passportData.OwnerPassportPuid.ToString(), newOwnerPassportPuid.ToString());
                Printer.Print("    Success swapping Owner Passport Puid!", Printer.Color.Info);
            }

            Printer.Print("    Swapping Gamertag ( " + gamertag + " ) ==> ( " + newGamertag + " )", Printer.Color.Debug);
            tables.SwapValues(gamertag, newGamertag);
            Printer.Print("    Success swapping Gamertag!", Printer.Color.Info);

            xuid = newXuid;
            offlineXuid = newOfflineXuid;
            passportData.UserPassportPuid = newPassportPuid;
            passportData.OwnerPassportPuid = newOwnerPassportPuid;
            gamertag = newGamertag;

            // apply new hash values to the si_hash_value columns

            Printer.Print("    Swapping hash values...", Printer.Color.Debug);
            tables.SetHashValues(SqlUtil.GetPartition("uodb", xuid), "xuid");
            tables.SetHashValues(SqlUtil.GetPartition("uodb", offlineXuid), "offlineXuid");
            tables.SetHashValues(SqlUtil.GetPartition("uodb", passportData.UserPassportPuid), "passportPuid");
            tables.SetHashValues(SqlUtil.GetPartition("uodb", gamertag), "gamertag");
            Printer.Print("    Success swapping hash values!", Printer.Color.Info);

            Printer.Print("Done Translating UserData!", Printer.Color.Info);
        }

        private static DateTime GenerateRandomBirthdate(DateTime birthdate, string countryCode)
        {
            int age = User.ComputeAge(birthdate);
            MinAge countryMinAgeInfo = CountryDictionary.MinAge(CountryDictionary.CountryId(countryCode));

            DateTime minBirthdate, maxBirthdate;
            if (age >= countryMinAgeInfo.Billing)
            {
                minBirthdate = DateTime.Now.AddYears(-countryMinAgeInfo.Billing - 20);
                maxBirthdate = DateTime.Now.AddYears(-countryMinAgeInfo.Billing - 1);
            }
            else if (age >= countryMinAgeInfo.User)
            {
                minBirthdate = DateTime.Now.AddYears(-countryMinAgeInfo.Billing + 1);
                maxBirthdate = DateTime.Now.AddYears(-countryMinAgeInfo.User - 1);
            }
            else
            {
                minBirthdate = DateTime.Now.AddYears(-countryMinAgeInfo.User + 1);
                maxBirthdate = DateTime.Now.AddYears(-countryMinAgeInfo.User + 5);
            }

            Random rand = new Random();
            return minBirthdate.AddTicks((long)(maxBirthdate.Subtract(minBirthdate).Ticks * rand.NextDouble()));
        }

        private void HidePII()
        {
            Printer.Print("    Hiding PII...", Printer.Color.Debug);

            DateTime newBirthdate = GenerateRandomBirthdate(birthdate, countryCode);

            Printer.Print("    Swapping birthdate ( " + birthdate + " ) ==> ( " + newBirthdate + " )", Printer.Color.Debug);
            tables.SwapValues(birthdate.ToString(), newBirthdate.ToString());
            Printer.Print("    Success swapping birthdate!", Printer.Color.Info);

            birthdate = newBirthdate;

            Printer.Print("    Done Hiding PII!", Printer.Color.Info);
        }

        public void Ensure()
        {
            bool haveAllData = true;

            Printer.Print("Making sure we have all the user's data...", Printer.Color.Debug);
            if (!Util.FindAllInstancesOfValue("gamertag", gamertag, tables)) haveAllData = false;
            if (!Util.FindAllInstancesOfValue("xuid", xuid.ToString(), tables)) haveAllData = false;
            if (!Util.FindAllInstancesOfValue("offlineXuid", offlineXuid.ToString(), tables)) haveAllData = false;
            if (!Util.FindAllInstancesOfValue("passportPuid", passportData.UserPassportPuid.ToString(), tables)) haveAllData = false;

            if(!haveAllData)
            {
                string errorString = "We don't have all of the user's data!";
                Printer.Print(errorString, Printer.Color.Error);
                throw new Exception(errorString);
            }

            Printer.Print("We have all of the user's data (probably)!", Printer.Color.Info);
        }
    }

    internal class PassportData
    {
        #region private data
        // used for read and write
        private bool childAccount = false;
        private ulong userPassportPuid = 0;
        private ulong ownerPassportPuid = 0;

        public ulong UserPassportPuid { set { userPassportPuid = value; }  get { return userPassportPuid; } }
        public ulong OwnerPassportPuid { set { ownerPassportPuid = value; } get { return ownerPassportPuid; } }
        public bool ChildAccount { get { return childAccount; } }

        // used only to display in xml
        const string INVALID_PASSPORT_ID = "PUID does not exist in Passport";
        const string INVALID_XUID = "XUID does not exist in Xbox LIVE";
        private string userPassportMemberName = INVALID_PASSPORT_ID;
        private ulong activeUserPassportPuid = 0;
        private ulong ownerXuid = 0;
        private string ownerGamertag = INVALID_XUID;
        private string ownerPassportMemberName = INVALID_PASSPORT_ID;
        private ulong activeOwnerPassportPuid = 0;

        private enum PassportCredentialState
        {
            DoesNotExist = 0,
            Inactive = 1,
            Active = 2,
        }

        #endregion

        public PassportData(User user)
        {
            Printer.Print("Loading PassportData...", Printer.Color.Debug);
            PassportClientBase pp = PassportClientGlobal.Global;

            userPassportPuid = user.PassportPuid;

            // not the normal way of doing things, but still valid in normal situations, and allows 'half-graduated' cases to work.
            childAccount = (user.Puid != user.OwnerPuid || user.PassportPuid != user.OwnerPassportPuid);

            try
            {
                if (userPassportPuid != 0)
                {
                    userPassportMemberName = PassportHelper.GetPassportMemberName(userPassportPuid);
                }
            }
            catch (Exception e)
            {
                if (!(e is ExceptionWithHResult)
                || ((ExceptionWithHResult)e).HResult != HResult.XONLINE_E_PASSPORT_INVALID_ID)
                {
                    throw;
                }
            }

            if (userPassportMemberName != INVALID_PASSPORT_ID)
            {
                List<PassportMemberNameCredentials> creds = pp.EnumCredentialsByName(userPassportMemberName);

                if (GetCredentialState(creds, userPassportPuid) == PassportCredentialState.Inactive)
                {
                    activeUserPassportPuid = GetActivePassportPuid(creds);
                }
            }

            if(childAccount)
            {
                ownerPassportPuid = user.OwnerPassportPuid;

                try
                {
                    if (ownerPassportPuid != 0)
                    {
                        ownerPassportMemberName = PassportHelper.GetPassportMemberName(ownerPassportPuid);
                    }
                }
                catch (Exception e)
                {
                    if (!(e is ExceptionWithHResult)
                    || ((ExceptionWithHResult)e).HResult != HResult.XONLINE_E_PASSPORT_INVALID_ID)
                    {
                        throw;
                    }
                }

                if (ownerPassportMemberName != INVALID_PASSPORT_ID)
                {
                    List<PassportMemberNameCredentials> creds = pp.EnumCredentialsByName(ownerPassportMemberName);

                    if (GetCredentialState(creds, ownerPassportPuid) == PassportCredentialState.Inactive)
                    {
                        activeOwnerPassportPuid = GetActivePassportPuid(creds);
                    }
                }

                try
                {
                    User ownerAccount = new User();
                    if (HResult.Succeeded(ownerAccount.LoadFromPassportPuid(ownerPassportPuid)))
                    {
                        ownerXuid = ownerAccount.Puid;
                        ownerGamertag = ownerAccount.GamerTag;
                    }
                }
                catch (Exception e)
                {
                    if (!(e is ExceptionWithHResult)
                    || ((ExceptionWithHResult)e).HResult != HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
                    {
                        throw;
                    }
                }
            }

            Printer.Print("Loaded PassportData!", Printer.Color.Info);
        }

        public PassportData(XmlNode passportNode)
        {
            childAccount = false;

            XmlNode node = passportNode.FirstChild;
            userPassportPuid = Convert.ToUInt64(XmlUtil.ReadNode(node, "Passport_Puid"));

            node = node.NextSibling;
            userPassportMemberName = XmlUtil.ReadNode(node, "Passport_Member_Name");

            if (node.NextSibling != null && node.NextSibling.Name == "Active_Passport_Puid")
            {
                node = node.NextSibling;
                activeUserPassportPuid = Convert.ToUInt64(XmlUtil.ReadNode(node, "Active_Passport_Puid"));
            }

            if (node.NextSibling != null && node.NextSibling.Name == "Owner_Data")
            {
                node = node.NextSibling;
                childAccount = true;

                XmlNode ownerDataNode = node.FirstChild;
                ownerXuid = Convert.ToUInt64(XmlUtil.ReadNode(ownerDataNode, "Owner_Xuid"));

                ownerDataNode = ownerDataNode.NextSibling;
                ownerGamertag = XmlUtil.ReadNode(ownerDataNode, "Owner_Gamertag");

                ownerDataNode = ownerDataNode.NextSibling;
                ownerPassportPuid = Convert.ToUInt64(XmlUtil.ReadNode(ownerDataNode, "Owner_Passport_Puid"));

                ownerDataNode = ownerDataNode.NextSibling;
                ownerPassportMemberName = XmlUtil.ReadNode(ownerDataNode, "Owner_Passport_Member_Name");

                if (ownerDataNode.NextSibling != null && node.NextSibling.Name == "Active_Owner_Passport_Puid")
                {
                    ownerDataNode = ownerDataNode.NextSibling;
                    activeOwnerPassportPuid = Convert.ToUInt64(XmlUtil.ReadNode(node, "Active_Owner_Passport_Puid"));
                }
            }
        }

        public void WriteToStream(XmlTextWriter w)
        {
            w.WriteStartElement("Passport_Data");
                w.WriteElementString("Passport_Puid", userPassportPuid.ToString());
                w.WriteElementString("Passport_Member_Name", userPassportMemberName);
                if (activeUserPassportPuid != 0)
                {
                    w.WriteElementString("Active_Passport_Puid", activeUserPassportPuid.ToString());
                }
                if (childAccount)
                {
                    w.WriteStartElement("Owner_Data");
                        w.WriteElementString("Owner_Xuid", ownerXuid.ToString());
                        w.WriteElementString("Owner_Gamertag", ownerGamertag);
                        w.WriteElementString("Owner_Passport_Puid", ownerPassportPuid.ToString());
                        w.WriteElementString("Owner_Passport_Member_Name", ownerPassportMemberName);
                        if (activeOwnerPassportPuid != 0)
                        {
                            w.WriteElementString("Active_Owner_Passport_Puid", activeOwnerPassportPuid.ToString());
                        }
                    w.WriteEndElement();
                }
            w.WriteEndElement();
        }

        private void GeneratePassportAccount(   string baseEmailName,
                                                DateTime birthdate,
                                                string countryCode,
                                                ref ulong puid,
                                                ref string userEmail,
                                                ref string userPassword)
        {
            PassportClientBase pp = PassportClientGlobal.Global;
            userEmail = Util.GenerateRandomPassportMemberName(baseEmailName);
            userPassword = "supersecret";
            string secretQuestion = "What's the meaning of life?";
            string secretAnswer = "Forty two";
            byte[] encryptedPassword = pp.GenerateEncryptedCredentials( "",
                                                                        userPassword,
                                                                        secretAnswer);
            pp.CreatePassport(  userEmail,
                                secretQuestion,
                                encryptedPassword,
                                null,
                                countryCode,
                                birthdate,
                                out puid);
        }

        public void TranslateUser(  string newGamertag,
                                    DateTime birthdate,
                                    string countryCode,
                                    ref string userEmail,
                                    ref string userPassword,
                                    out ulong newPassportPuid,
                                    out ulong newOwnerPassportPuid)
        {
            Printer.Print("    Creating new Passport Account...", Printer.Color.Debug);
            newPassportPuid = 0;
            GeneratePassportAccount(newGamertag, birthdate, countryCode, ref newPassportPuid, ref userEmail, ref userPassword);
            Printer.Print("    Created new Passport Account!", Printer.Color.Info);

            newOwnerPassportPuid = newPassportPuid;
            if (childAccount)
            {
                Printer.Print("    Creating new Owner Passport Account...", Printer.Color.Debug);
                string ownerEmail = "";
                string ownerPassword = "";
                GeneratePassportAccount(newGamertag + "owner", AdultBirthdate(), countryCode, ref newOwnerPassportPuid, ref ownerEmail, ref ownerPassword);
                Printer.Print("    Created new Owner Passport Account!", Printer.Color.Info);
            }
        }

        private static DateTime AdultBirthdate()
        {
            DateTime adultBirthdate = DateTime.UtcNow;
            return adultBirthdate.AddYears(-42);
        }

        public void InvalidatePassport()
        {
            PassportClientBase pp = PassportClientGlobal.Global;

            if (userPassportMemberName == INVALID_PASSPORT_ID)
            {
                pp.DeleteCredential(userPassportPuid);
            }

            if (childAccount && ownerPassportMemberName == INVALID_PASSPORT_ID)
            {
                pp.DeleteCredential(ownerPassportPuid);
            }
        }

        private PassportCredentialState GetCredentialState(List<PassportMemberNameCredentials> creds, Puid passportPuid)
        {
            for (int i = 0; i < creds.Count; i++)
            {
                if (creds[i].PassportPuid == passportPuid)
                {
                    if (creds[i].IsActive)
                    {
                        return PassportCredentialState.Active;
                    }
                    else
                    {
                        return PassportCredentialState.Inactive;
                    }
                }
            }

            return PassportCredentialState.DoesNotExist;
        }

        private Puid GetActivePassportPuid(List<PassportMemberNameCredentials> creds)
        {
            for (int i = 0; i < creds.Count; i++)
            {
                if (creds[i].IsActive)
                {
                    return creds[i].PassportPuid;
                }
            }

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\MigrateUserUtil.cs ===
/*
 * MigrateUserUtil.cs
 *
 * MigrateUser tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;                           // Exception
using System.Collections.Generic;       // List<T>
using System.Text.RegularExpressions;   // Regex
using System.Security.Cryptography;     // RandomNumberGenerator
using System.Runtime.InteropServices;   // DllImport
using System.Xml;                       // XmlNode

using Microsoft.Webstore.WstClient;     // WstPartitionType

using xonline.common.config;            // ConfigUtil
using xonline.common.sql.webstore;      // WSClient
using xonline.common.user;              // User

namespace xonline.common.billing.migrateuser
{
    internal class StringList : List<string>
    {

    }

    internal static class XmlUtil
    {
        public static string ReadNode(XmlNode node, string nodeName)
        {
            ValidateNode(node, nodeName);
            return node.InnerText;
        }

        public static void ValidateNode(XmlNode node, string nodeName)
        {
            if (node.Name != nodeName)
            {
                Printer.Print("Unexpected xml node: " + node.Name, Printer.Color.Error);
                throw new Exception();
            }
        }
    }

    internal static class SqlUtil
    {
        public enum Partition : int
        {
            Any = -2,
            All = -1,
        }

        public static bool ValidSqlIdentifier(string identifier)
        {
            return Regex.Match(identifier, "^[a-z_]+$", RegexOptions.IgnoreCase).Success;
        }

        public static bool ValidSqlDatabase(string databaseName)
        {
            if (!ValidSqlIdentifier(databaseName))
            {
                return false;
            }

            try
            {
                ConfigUtil.GetWebstoreApp(databaseName);
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        public static bool ValidSqlTable(string databaseName, string tableName)
        {
            if (!ValidSqlIdentifier(databaseName))
            {
                return false;
            }

            if (1 != (int)ExecuteSqlScalar(databaseName, @"IF EXISTS    (
                                                                            SELECT 1
                                                                            FROM INFORMATION_SCHEMA.TABLES
                                                                            WHERE TABLE_NAME='" + tableName + @"'
                                                                        )
                                                                SELECT 1
                                                           ELSE
                                                               SELECT 0", Partition.Any))
            {
                return false;
            }

            return true;
        }

        public static bool ValidSqlColumn(string databaseName, string tableName, string columnName)
        {
            if (!ValidSqlIdentifier(columnName))
            {
                return false;
            }

            if (1 != (int)ExecuteSqlScalar(databaseName, @"IF EXISTS    (
                                                                            SELECT 1
                                                                            FROM INFORMATION_SCHEMA.COLUMNS
                                                                            WHERE COLUMN_NAME='" + columnName + @"'
                                                                                AND TABLE_NAME='" + tableName + @"'
                                                                        )
                                                                SELECT 1
                                                           ELSE
                                                               SELECT 0", Partition.Any))
            {
                return false;
            }

            return true;
        }

        public static bool ValidSqlValue(string databaseName, string tableName, string columnName, string value)
        {
            string dataType = (string)ExecuteSqlScalar(databaseName, @" SELECT DATA_TYPE
                                                                        FROM INFORMATION_SCHEMA.COLUMNS
                                                                        WHERE COLUMN_NAME='" + columnName + @"'
                                                                            AND TABLE_NAME='" + tableName + @"'", Partition.Any);

            try
            {
                string castedValue = ExecuteSqlScalar(databaseName, @"  DECLARE @value nvarchar(" + value.Length.ToString() + @")
                                                                                SELECT @value = '" + value + @"'
                                                                                SELECT CAST(@value AS " + dataType + @")", Partition.Any).ToString();
            }
            catch (Exception)
            {
                return false;
            }

            return true;

        }

        public static int GetPartition(string databaseName, int hashVal)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.READORWRITE_COMMANDTYPE))
            {
                return ws.CalcPartition(hashVal);
            }
        }

        public static int GetPartition(string databaseName, long hashVal)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.READORWRITE_COMMANDTYPE))
            {
                return ws.CalcPartition(hashVal);
            }
        }

        public static int GetPartition(string databaseName, ulong hashVal)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.READORWRITE_COMMANDTYPE))
            {
                return ws.CalcPartition(hashVal);
            }
        }

        public static int GetPartition(string databaseName, string hashVal)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.READORWRITE_COMMANDTYPE))
            {
                return ws.CalcPartition(hashVal);
            }
        }

        public static object ExecuteSqlScalar(string databaseName, string sqlCommand, Partition partition)
        {
            return ExecuteSqlScalar(databaseName, sqlCommand, (int)partition);
        }

        public static object ExecuteSqlScalar(string databaseName, string sqlCommand, int partition)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.CommandSql = sqlCommand;

                switch (partition)
                {
                    case (int)Partition.Any:
                        {
                            ws.Partition = WstCommand.AnyPartition;

                            return ws.ExecuteScalar();
                        }

                    case (int)Partition.All:
                        {
                            Printer.Print("ExecuteSqlScalar cannot be called with partition = All", Printer.Color.Error);
                            throw new Exception();
                        }

                    default:
                        {
                            ws.Partition = partition;

                            return ws.ExecuteScalar();
                        }
                }
            }
        }

        public static object ExecuteSqlNonQuery(string databaseName, string sqlCommand, Partition partition)
        {
            return ExecuteSqlNonQuery(databaseName, sqlCommand, (int)partition);
        }

        public static ulong ExecuteSqlNonQuery(string databaseName, string sqlCommand, int partition)
        {
            ulong rowsAffected = 0;
            using (WSClient ws = new WSClient(ConfigUtil.GetWebstoreApp(databaseName), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.CommandSql = sqlCommand;

                switch (partition)
                {
                    case (int)Partition.Any:
                        {
                            ws.PartitionType = WstPartitionType.Logical;
                            ws.Partition = WstCommand.AnyPartition;

                            rowsAffected += (ulong)ws.ExecuteNonQuery();
                        }
                        break;

                    case (int)Partition.All:
                        {
                            ws.PartitionType = WstPartitionType.Physical;
                            for (int p = 0; p < ws.PhysicalPartitions; p++)
                            {
                                ws.PhysicalPartition = p;

                                rowsAffected += (ulong)ws.ExecuteNonQuery();
                            }
                        }
                        break;

                    default:
                        {
                            ws.PartitionType = WstPartitionType.Logical;
                            ws.Partition = partition;

                            rowsAffected += (ulong)ws.ExecuteNonQuery();
                        }
                        break;
                }
            }
            return rowsAffected;
        }
    }

    internal static class Util
    {
        public static bool IsCurrentEnvironmentProduction()
        {
            return 0 != (int)SqlUtil.ExecuteSqlScalar("npdb", "SELECT COUNT(*) FROM t_environments WHERE b_current = 1 AND vc_environment_type = 'production'", SqlUtil.Partition.Any);
        }

        public static string GenerateRandomPassportMemberName(string gamertag)
        {
            return gamertag + GenerateRandomString(4) + "@xboxtest.com";
        }

        public static string GenerateRandomGamertag()
        {
            return "Test" + GenerateRandomString(4);
        }

        public static string GenerateRandomString(int length)
        {
            RandomNumberGenerator rand = RandomNumberGenerator.Create();
            byte[] randBytes = new byte[length];
            rand.GetBytes(randBytes);
            return String.Join("", BitConverter.ToString(randBytes).Split('-'));
        }

        public static void FindAllInstancesOfUser(string gamertag)
        {
            Printer.Print("Finding all instances of user: " + gamertag, Printer.Color.Debug);

            try
            {
                User user = new User();
                user.LoadFromGamerTag(gamertag);
                FindAllInstancesOfValue("gamertag", gamertag);
                FindAllInstancesOfValue("xuid", user.Puid.ToString());
                FindAllInstancesOfValue("offline xuid", ((long)user.OfflineXuid).ToString());
                FindAllInstancesOfValue("passport puid", user.PassportPuid.ToString());
            }
            catch (Exception e)
            {
                Printer.Print("ERROR: " + e.Message, Printer.Color.Error);
                return;
            }

            Printer.Print("\n\tFinished finding all instances of user: " + gamertag + "\n", Printer.Color.Complete);
        }

        public static bool FindAllInstancesOfValue(string valueName, string value)
        {
            return FindAllInstancesOfValue(valueName, value, null);
        }

        public static bool FindAllInstancesOfValue(string valueName, string value, TableList tables)
        {
            Printer.Print("Finding all instances of user based off of [" + valueName + "] = " + value, Printer.Color.Debug);

            bool returnValue = true;
            List<string> tableList = new List<string>();
            Dictionary<string, List<string>> tableColumnList = new Dictionary<string, List<string>>();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;

                ws.CommandSql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'dbo'";

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        string tableName = r.GetValue(0).ToString();
                        List<string> columnList = new List<string>();
                        tableList.Add(tableName);
                        tableColumnList.Add(tableName, columnList);
                    }
                }
            }

            foreach (string tableName in tableList)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.Partition = WstCommand.AnyPartition;
                    ws.CommandSql = "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '" + tableName + "'";

                    using (WstDataReader r = ws.Execute())
                    {
                        while (r.Read())
                        {
                            string columnName = r.GetValue(0).ToString();
                            tableColumnList[tableName].Add(columnName);
                        }
                    }
                }
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Physical;
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.PhysicalPartition = p;

                    foreach (string tableName in tableList)
                    {
                        foreach (string columnName in tableColumnList[tableName])
                        {
                            ws.CommandSql = "SELECT " + columnName + " FROM " + tableName;

                            using (WstDataReader r = ws.Execute())
                            {
                                while (r.Read())
                                {
                                    string columnValue = r.GetValue(0).ToString();
                                    if (columnValue == value)
                                    {
                                        if (tables == null)
                                        {
                                            Printer.Print("    " + valueName + " found in " + tableName + "." + columnName, Printer.Color.Info);
                                        }
                                        else
                                        {
                                            if (!tables.TableExists(tableName))
                                            {
                                                Printer.Print("    " + valueName + " found in " + tableName + "." + columnName + " but this table has not been loaded! - This tool needs to be updated. Yell at someone who's not damitche.", Printer.Color.Error);
                                                returnValue = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return returnValue;
        }
    }

    internal static class Printer
    {
        [DllImport("kernel32.dll")]
        public static extern bool SetConsoleTextAttribute(IntPtr hConsoleOutput, int wAttributes);
        [DllImport("kernel32.dll")]
        public static extern IntPtr GetStdHandle(int nStdHandle); 

        private static readonly IntPtr hOut;

        public enum Color : int
        {
            Debug = 15,     // White
            Info = 11,      // Blue
            Warning = 14,   // Yellow
            Error = 12,     // Red
            Complete = 10,  // Green
        }

        static Printer()
        {
            hOut = GetStdHandle(-11);
        }

        public static void Print(string text, Color color)
        {
            SetConsoleTextAttribute(hOut, (int)color);
            Console.WriteLine(text);
            SetConsoleTextAttribute(hOut, (int)Color.Debug);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\bdkwsdl.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace BDKWSDL
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "bdkSoap", Namespace = "http://tempuri.org/")]
    public partial class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        private UserContextualInfoSoapHeader userContextualInfoSoapHeaderValueField;

        private OnBehalfOfSoapHeader onBehalfOfSoapHeaderValueField;

        private System.Threading.SendOrPostCallback GetTokenInfoOperationCompleted;

        private System.Threading.SendOrPostCallback GetTokenInfoExOperationCompleted;

        private System.Threading.SendOrPostCallback GetTransactionsOperationCompleted;

        private System.Threading.SendOrPostCallback GetUnconditionalReplacementTokenOperationCompleted;

        private System.Threading.SendOrPostCallback GetUserProfileOperationCompleted;

        private System.Threading.SendOrPostCallback ImportSettledBillingItemOperationCompleted;

        private System.Threading.SendOrPostCallback IssueTokenTrustedOperationCompleted;

        private System.Threading.SendOrPostCallback IsPaymentInstrumentBannedOperationCompleted;

        private System.Threading.SendOrPostCallback LoadTokenInstanceOperationCompleted;

        private System.Threading.SendOrPostCallback MarkTokenDistributionStatusOperationCompleted;

        private System.Threading.SendOrPostCallback MapAddressOperationCompleted;

        private System.Threading.SendOrPostCallback MatchPaymentInstrumentInfoOperationCompleted;

        private System.Threading.SendOrPostCallback MigrateOfferOperationCompleted;

        private System.Threading.SendOrPostCallback OffsetLineItemOperationCompleted;

        private System.Threading.SendOrPostCallback OffsetLineItem2OperationCompleted;

        private System.Threading.SendOrPostCallback OffsetOrderOperationCompleted;

        private System.Threading.SendOrPostCallback OffsetSingleUsageEventOperationCompleted;

        private System.Threading.SendOrPostCallback OrderCDforAccountOperationCompleted;

        private System.Threading.SendOrPostCallback OrderCDforAnonymousOperationCompleted;

        private System.Threading.SendOrPostCallback PayUserOperationCompleted;

        private System.Threading.SendOrPostCallback ProcessChargebackOperationCompleted;

        private System.Threading.SendOrPostCallback ProvisionServicesOperationCompleted;

        private System.Threading.SendOrPostCallback PurchaseItemOperationCompleted;

        private System.Threading.SendOrPostCallback PurchaseItemExOperationCompleted;

        private System.Threading.SendOrPostCallback PurchaseOfferingOperationCompleted;

        private System.Threading.SendOrPostCallback PurchaseOfferingExOperationCompleted;

        private System.Threading.SendOrPostCallback PurchaseOfferingEx2OperationCompleted;

        private System.Threading.SendOrPostCallback PurchaseOfferingEx3OperationCompleted;

        private System.Threading.SendOrPostCallback ReconcileTokenTrustedOperationCompleted;

        private System.Threading.SendOrPostCallback RefundTaxForAccountOperationCompleted;

        private System.Threading.SendOrPostCallback RegisterPaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback ReinstateSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback RemoveBillingReferenceOperationCompleted;

        private System.Threading.SendOrPostCallback RemovePaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback RemovePMNBasedServicesOperationCompleted;

        private System.Threading.SendOrPostCallback RemoveRoleAssignmentOperationCompleted;

        private System.Threading.SendOrPostCallback RemoveViolationOperationCompleted;

        private System.Threading.SendOrPostCallback ReportSingleUsageEventOperationCompleted;

        private System.Threading.SendOrPostCallback ReportTransactionEventOperationCompleted;

        private System.Threading.SendOrPostCallback ReportUsageEventOperationCompleted;

        private System.Threading.SendOrPostCallback ReschedulePaymentOperationCompleted;

        private System.Threading.SendOrPostCallback SearchAccountsOperationCompleted;

        private System.Threading.SendOrPostCallback SearchAccountsExOperationCompleted;

        private System.Threading.SendOrPostCallback SearchBillingInfoOperationCompleted;

        private System.Threading.SendOrPostCallback SendHCIOperationCompleted;

        private System.Threading.SendOrPostCallback SendValidationTokenInfoOperationCompleted;

        private System.Threading.SendOrPostCallback SetBillingReferenceOperationCompleted;

        private System.Threading.SendOrPostCallback SetPartnerConfigurationOperationCompleted;

        private System.Threading.SendOrPostCallback SettleBalanceOperationCompleted;

        private System.Threading.SendOrPostCallback SettleOrderOperationCompleted;

        private System.Threading.SendOrPostCallback SignAgreementOperationCompleted;

        private System.Threading.SendOrPostCallback StopPaymentsOperationCompleted;

        private System.Threading.SendOrPostCallback SubmitOrderOperationCompleted;

        private System.Threading.SendOrPostCallback SwitchPaymentInstrumentsOperationCompleted;

        private System.Threading.SendOrPostCallback SyncUPSCacheForPUIDOperationCompleted;

        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;

        private System.Threading.SendOrPostCallback TokenRedemptionOperationCompleted;

        private System.Threading.SendOrPostCallback TransferBalanceOperationCompleted;

        private System.Threading.SendOrPostCallback UnbanPaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback UnbanUserOperationCompleted;

        private System.Threading.SendOrPostCallback UnIssueTokenTrustedOperationCompleted;

        private System.Threading.SendOrPostCallback UpdateAccountInfoOperationCompleted;

        private System.Threading.SendOrPostCallback UpdatePaymentInstrumentInfoOperationCompleted;

        private System.Threading.SendOrPostCallback UpdateSubscriptionInfoOperationCompleted;

        private System.Threading.SendOrPostCallback ValidateProvisioningDataOperationCompleted;

        private System.Threading.SendOrPostCallback ValidateTokenOperationCompleted;

        private System.Threading.SendOrPostCallback ActivateTokenOperationCompleted;

        private System.Threading.SendOrPostCallback ActivateTokenExOperationCompleted;

        private System.Threading.SendOrPostCallback AddCommentOperationCompleted;

        private System.Threading.SendOrPostCallback AddPaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback AddRoleAssignmentOperationCompleted;

        private System.Threading.SendOrPostCallback AddViolationOperationCompleted;

        private System.Threading.SendOrPostCallback AdjustGotoBAMDateOperationCompleted;

        private System.Threading.SendOrPostCallback AdjustResourceBalanceOperationCompleted;

        private System.Threading.SendOrPostCallback AdjustSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback BanPaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback BanUserOperationCompleted;

        private System.Threading.SendOrPostCallback BlacklistTokenOperationCompleted;

        private System.Threading.SendOrPostCallback CalculateTaxOperationCompleted;

        private System.Threading.SendOrPostCallback CancelConversionOperationCompleted;

        private System.Threading.SendOrPostCallback CancelPaymentOperationCompleted;

        private System.Threading.SendOrPostCallback CancelRenewalOperationCompleted;

        private System.Threading.SendOrPostCallback CancelSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback CancelSubscriptionExOperationCompleted;

        private System.Threading.SendOrPostCallback CancelTransactionOperationCompleted;

        private System.Threading.SendOrPostCallback ChargePaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback CheckCDAvailabilityOperationCompleted;

        private System.Threading.SendOrPostCallback CheckProvisioningStatusOperationCompleted;

        private System.Threading.SendOrPostCallback CloseAccountOperationCompleted;

        private System.Threading.SendOrPostCallback CloseBalanceOperationCompleted;

        private System.Threading.SendOrPostCallback CompleteConversionOperationCompleted;

        private System.Threading.SendOrPostCallback ConsumeTokenOperationCompleted;

        private System.Threading.SendOrPostCallback ConvertSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback ConvertSubscriptionExOperationCompleted;

        private System.Threading.SendOrPostCallback ConvertSubscriptionEx2OperationCompleted;

        private System.Threading.SendOrPostCallback ConvertSubscriptionEx3OperationCompleted;

        private BdkSoapHeader bdkSoapHeaderValueField;

        private System.Threading.SendOrPostCallback CreateAccountOperationCompleted;

        private System.Threading.SendOrPostCallback CreditPaymentInstrumentOperationCompleted;

        private System.Threading.SendOrPostCallback CreditPaymentInstrumentExOperationCompleted;

        private System.Threading.SendOrPostCallback SetUserProfileOperationCompleted;

        private System.Threading.SendOrPostCallback DeactivateTokenOperationCompleted;

        private System.Threading.SendOrPostCallback DeactivateTokenExOperationCompleted;

        private System.Threading.SendOrPostCallback DeliverTokenOperationCompleted;

        private System.Threading.SendOrPostCallback DeprovisionServicesOperationCompleted;

        private System.Threading.SendOrPostCallback ExtendSubscriptionOperationCompleted;

        private System.Threading.SendOrPostCallback FixExistingAddressOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountIdFromAdminPUIDOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountIdFromPaymentInstrumentInfoOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountIdFromPuidOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountIdFromTokenOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountIdFromTokenIdOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountInfoOperationCompleted;

        private System.Threading.SendOrPostCallback GetAccountStatusOperationCompleted;

        private System.Threading.SendOrPostCallback GetAdjustmentsOperationCompleted;

        private System.Threading.SendOrPostCallback GetBaseOfferingsOperationCompleted;

        private System.Threading.SendOrPostCallback GetBaseOfferingsExOperationCompleted;

        private System.Threading.SendOrPostCallback GetBillingPeriodsOperationCompleted;

        private System.Threading.SendOrPostCallback GetBillingReferenceOperationCompleted;

        private System.Threading.SendOrPostCallback GetCommentsOperationCompleted;

        private System.Threading.SendOrPostCallback GetEligibleOfferingsOperationCompleted;

        private System.Threading.SendOrPostCallback GetEligibleOfferingsExOperationCompleted;

        private System.Threading.SendOrPostCallback GetEligibleSwitchPITypesOperationCompleted;

        private System.Threading.SendOrPostCallback GetExistingAccountsByCriteriaOperationCompleted;

        private System.Threading.SendOrPostCallback GetKeyOperationCompleted;

        private System.Threading.SendOrPostCallback GetLineItemHistoryOperationCompleted;

        private System.Threading.SendOrPostCallback GetPartnerConfigurationOperationCompleted;

        private System.Threading.SendOrPostCallback GetPaymentInstrumentsOperationCompleted;

        private System.Threading.SendOrPostCallback GetPaymentInstrumentsExOperationCompleted;

        private System.Threading.SendOrPostCallback GetPaymentMethodTypePropertiesOperationCompleted;

        private System.Threading.SendOrPostCallback GetPermitHistoryForObjectIdOperationCompleted;

        private System.Threading.SendOrPostCallback GetPermitsForObjectIdOperationCompleted;

        private System.Threading.SendOrPostCallback GetPermitsForPUIDOperationCompleted;

        private System.Threading.SendOrPostCallback GetPolicyOperationCompleted;

        private System.Threading.SendOrPostCallback GetProductClassesOperationCompleted;

        private System.Threading.SendOrPostCallback GetProvisioningInfoOperationCompleted;

        private System.Threading.SendOrPostCallback GetReferralDataOperationCompleted;

        private System.Threading.SendOrPostCallback GetReferralEventsOperationCompleted;

        private System.Threading.SendOrPostCallback GetResourceBalancesOperationCompleted;

        private System.Threading.SendOrPostCallback GetReplacementTokenOperationCompleted;

        private System.Threading.SendOrPostCallback GetReplacementTokenFromPuidOperationCompleted;

        private System.Threading.SendOrPostCallback GetResourcePricesOperationCompleted;

        private System.Threading.SendOrPostCallback GetStatementOperationCompleted;

        private System.Threading.SendOrPostCallback GetStatementExOperationCompleted;

        private System.Threading.SendOrPostCallback GetSubscriptionHistoryOperationCompleted;

        private System.Threading.SendOrPostCallback GetServiceComponentsOperationCompleted;

        private System.Threading.SendOrPostCallback GetSubscriptionsOperationCompleted;

        private System.Threading.SendOrPostCallback GetSubscriptionStatusOperationCompleted;

        private System.Threading.SendOrPostCallback GetTokenClassRestrictionInfoForPUIDOperationCompleted;

        private System.Threading.SendOrPostCallback GetTokenClassesOperationCompleted;

        /// <remarks/>
        public bdk()
        {
            this.Url = "https://vm1box/scs/scsapiwebservice.asmx";
        }

        public UserContextualInfoSoapHeader UserContextualInfoSoapHeaderValue
        {
            get
            {
                return this.userContextualInfoSoapHeaderValueField;
            }
            set
            {
                this.userContextualInfoSoapHeaderValueField = value;
            }
        }

        public OnBehalfOfSoapHeader OnBehalfOfSoapHeaderValue
        {
            get
            {
                return this.onBehalfOfSoapHeaderValueField;
            }
            set
            {
                this.onBehalfOfSoapHeaderValueField = value;
            }
        }

        public BdkSoapHeader BdkSoapHeaderValue
        {
            get
            {
                return this.bdkSoapHeaderValueField;
            }
            set
            {
                this.bdkSoapHeaderValueField = value;
            }
        }

        /// <remarks/>
        public event GetTokenInfoCompletedEventHandler GetTokenInfoCompleted;

        /// <remarks/>
        public event GetTokenInfoExCompletedEventHandler GetTokenInfoExCompleted;

        /// <remarks/>
        public event GetTransactionsCompletedEventHandler GetTransactionsCompleted;

        /// <remarks/>
        public event GetUnconditionalReplacementTokenCompletedEventHandler GetUnconditionalReplacementTokenCompleted;

        /// <remarks/>
        public event GetUserProfileCompletedEventHandler GetUserProfileCompleted;

        /// <remarks/>
        public event ImportSettledBillingItemCompletedEventHandler ImportSettledBillingItemCompleted;

        /// <remarks/>
        public event IssueTokenTrustedCompletedEventHandler IssueTokenTrustedCompleted;

        /// <remarks/>
        public event IsPaymentInstrumentBannedCompletedEventHandler IsPaymentInstrumentBannedCompleted;

        /// <remarks/>
        public event LoadTokenInstanceCompletedEventHandler LoadTokenInstanceCompleted;

        /// <remarks/>
        public event MarkTokenDistributionStatusCompletedEventHandler MarkTokenDistributionStatusCompleted;

        /// <remarks/>
        public event MapAddressCompletedEventHandler MapAddressCompleted;

        /// <remarks/>
        public event MatchPaymentInstrumentInfoCompletedEventHandler MatchPaymentInstrumentInfoCompleted;

        /// <remarks/>
        public event MigrateOfferCompletedEventHandler MigrateOfferCompleted;

        /// <remarks/>
        public event OffsetLineItemCompletedEventHandler OffsetLineItemCompleted;

        /// <remarks/>
        public event OffsetLineItem2CompletedEventHandler OffsetLineItem2Completed;

        /// <remarks/>
        public event OffsetOrderCompletedEventHandler OffsetOrderCompleted;

        /// <remarks/>
        public event OffsetSingleUsageEventCompletedEventHandler OffsetSingleUsageEventCompleted;

        /// <remarks/>
        public event OrderCDforAccountCompletedEventHandler OrderCDforAccountCompleted;

        /// <remarks/>
        public event OrderCDforAnonymousCompletedEventHandler OrderCDforAnonymousCompleted;

        /// <remarks/>
        public event PayUserCompletedEventHandler PayUserCompleted;

        /// <remarks/>
        public event ProcessChargebackCompletedEventHandler ProcessChargebackCompleted;

        /// <remarks/>
        public event ProvisionServicesCompletedEventHandler ProvisionServicesCompleted;

        /// <remarks/>
        public event PurchaseItemCompletedEventHandler PurchaseItemCompleted;

        /// <remarks/>
        public event PurchaseItemExCompletedEventHandler PurchaseItemExCompleted;

        /// <remarks/>
        public event PurchaseOfferingCompletedEventHandler PurchaseOfferingCompleted;

        /// <remarks/>
        public event PurchaseOfferingExCompletedEventHandler PurchaseOfferingExCompleted;

        /// <remarks/>
        public event PurchaseOfferingEx2CompletedEventHandler PurchaseOfferingEx2Completed;

        /// <remarks/>
        public event PurchaseOfferingEx3CompletedEventHandler PurchaseOfferingEx3Completed;

        /// <remarks/>
        public event ReconcileTokenTrustedCompletedEventHandler ReconcileTokenTrustedCompleted;

        /// <remarks/>
        public event RefundTaxForAccountCompletedEventHandler RefundTaxForAccountCompleted;

        /// <remarks/>
        public event RegisterPaymentInstrumentCompletedEventHandler RegisterPaymentInstrumentCompleted;

        /// <remarks/>
        public event ReinstateSubscriptionCompletedEventHandler ReinstateSubscriptionCompleted;

        /// <remarks/>
        public event RemoveBillingReferenceCompletedEventHandler RemoveBillingReferenceCompleted;

        /// <remarks/>
        public event RemovePaymentInstrumentCompletedEventHandler RemovePaymentInstrumentCompleted;

        /// <remarks/>
        public event RemovePMNBasedServicesCompletedEventHandler RemovePMNBasedServicesCompleted;

        /// <remarks/>
        public event RemoveRoleAssignmentCompletedEventHandler RemoveRoleAssignmentCompleted;

        /// <remarks/>
        public event RemoveViolationCompletedEventHandler RemoveViolationCompleted;

        /// <remarks/>
        public event ReportSingleUsageEventCompletedEventHandler ReportSingleUsageEventCompleted;

        /// <remarks/>
        public event ReportTransactionEventCompletedEventHandler ReportTransactionEventCompleted;

        /// <remarks/>
        public event ReportUsageEventCompletedEventHandler ReportUsageEventCompleted;

        /// <remarks/>
        public event ReschedulePaymentCompletedEventHandler ReschedulePaymentCompleted;

        /// <remarks/>
        public event SearchAccountsCompletedEventHandler SearchAccountsCompleted;

        /// <remarks/>
        public event SearchAccountsExCompletedEventHandler SearchAccountsExCompleted;

        /// <remarks/>
        public event SearchBillingInfoCompletedEventHandler SearchBillingInfoCompleted;

        /// <remarks/>
        public event SendHCICompletedEventHandler SendHCICompleted;

        /// <remarks/>
        public event SendValidationTokenInfoCompletedEventHandler SendValidationTokenInfoCompleted;

        /// <remarks/>
        public event SetBillingReferenceCompletedEventHandler SetBillingReferenceCompleted;

        /// <remarks/>
        public event SetPartnerConfigurationCompletedEventHandler SetPartnerConfigurationCompleted;

        /// <remarks/>
        public event SettleBalanceCompletedEventHandler SettleBalanceCompleted;

        /// <remarks/>
        public event SettleOrderCompletedEventHandler SettleOrderCompleted;

        /// <remarks/>
        public event SignAgreementCompletedEventHandler SignAgreementCompleted;

        /// <remarks/>
        public event StopPaymentsCompletedEventHandler StopPaymentsCompleted;

        /// <remarks/>
        public event SubmitOrderCompletedEventHandler SubmitOrderCompleted;

        /// <remarks/>
        public event SwitchPaymentInstrumentsCompletedEventHandler SwitchPaymentInstrumentsCompleted;

        /// <remarks/>
        public event SyncUPSCacheForPUIDCompletedEventHandler SyncUPSCacheForPUIDCompleted;

        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;

        /// <remarks/>
        public event TokenRedemptionCompletedEventHandler TokenRedemptionCompleted;

        /// <remarks/>
        public event TransferBalanceCompletedEventHandler TransferBalanceCompleted;

        /// <remarks/>
        public event UnbanPaymentInstrumentCompletedEventHandler UnbanPaymentInstrumentCompleted;

        /// <remarks/>
        public event UnbanUserCompletedEventHandler UnbanUserCompleted;

        /// <remarks/>
        public event UnIssueTokenTrustedCompletedEventHandler UnIssueTokenTrustedCompleted;

        /// <remarks/>
        public event UpdateAccountInfoCompletedEventHandler UpdateAccountInfoCompleted;

        /// <remarks/>
        public event UpdatePaymentInstrumentInfoCompletedEventHandler UpdatePaymentInstrumentInfoCompleted;

        /// <remarks/>
        public event UpdateSubscriptionInfoCompletedEventHandler UpdateSubscriptionInfoCompleted;

        /// <remarks/>
        public event ValidateProvisioningDataCompletedEventHandler ValidateProvisioningDataCompleted;

        /// <remarks/>
        public event ValidateTokenCompletedEventHandler ValidateTokenCompleted;

        /// <remarks/>
        public event ActivateTokenCompletedEventHandler ActivateTokenCompleted;

        /// <remarks/>
        public event ActivateTokenExCompletedEventHandler ActivateTokenExCompleted;

        /// <remarks/>
        public event AddCommentCompletedEventHandler AddCommentCompleted;

        /// <remarks/>
        public event AddPaymentInstrumentCompletedEventHandler AddPaymentInstrumentCompleted;

        /// <remarks/>
        public event AddRoleAssignmentCompletedEventHandler AddRoleAssignmentCompleted;

        /// <remarks/>
        public event AddViolationCompletedEventHandler AddViolationCompleted;

        /// <remarks/>
        public event AdjustGotoBAMDateCompletedEventHandler AdjustGotoBAMDateCompleted;

        /// <remarks/>
        public event AdjustResourceBalanceCompletedEventHandler AdjustResourceBalanceCompleted;

        /// <remarks/>
        public event AdjustSubscriptionCompletedEventHandler AdjustSubscriptionCompleted;

        /// <remarks/>
        public event BanPaymentInstrumentCompletedEventHandler BanPaymentInstrumentCompleted;

        /// <remarks/>
        public event BanUserCompletedEventHandler BanUserCompleted;

        /// <remarks/>
        public event BlacklistTokenCompletedEventHandler BlacklistTokenCompleted;

        /// <remarks/>
        public event CalculateTaxCompletedEventHandler CalculateTaxCompleted;

        /// <remarks/>
        public event CancelConversionCompletedEventHandler CancelConversionCompleted;

        /// <remarks/>
        public event CancelPaymentCompletedEventHandler CancelPaymentCompleted;

        /// <remarks/>
        public event CancelRenewalCompletedEventHandler CancelRenewalCompleted;

        /// <remarks/>
        public event CancelSubscriptionCompletedEventHandler CancelSubscriptionCompleted;

        /// <remarks/>
        public event CancelSubscriptionExCompletedEventHandler CancelSubscriptionExCompleted;

        /// <remarks/>
        public event CancelTransactionCompletedEventHandler CancelTransactionCompleted;

        /// <remarks/>
        public event ChargePaymentInstrumentCompletedEventHandler ChargePaymentInstrumentCompleted;

        /// <remarks/>
        public event CheckCDAvailabilityCompletedEventHandler CheckCDAvailabilityCompleted;

        /// <remarks/>
        public event CheckProvisioningStatusCompletedEventHandler CheckProvisioningStatusCompleted;

        /// <remarks/>
        public event CloseAccountCompletedEventHandler CloseAccountCompleted;

        /// <remarks/>
        public event CloseBalanceCompletedEventHandler CloseBalanceCompleted;

        /// <remarks/>
        public event CompleteConversionCompletedEventHandler CompleteConversionCompleted;

        /// <remarks/>
        public event ConsumeTokenCompletedEventHandler ConsumeTokenCompleted;

        /// <remarks/>
        public event ConvertSubscriptionCompletedEventHandler ConvertSubscriptionCompleted;

        /// <remarks/>
        public event ConvertSubscriptionExCompletedEventHandler ConvertSubscriptionExCompleted;

        /// <remarks/>
        public event ConvertSubscriptionEx2CompletedEventHandler ConvertSubscriptionEx2Completed;

        /// <remarks/>
        public event ConvertSubscriptionEx3CompletedEventHandler ConvertSubscriptionEx3Completed;

        /// <remarks/>
        public event CreateAccountCompletedEventHandler CreateAccountCompleted;

        /// <remarks/>
        public event CreditPaymentInstrumentCompletedEventHandler CreditPaymentInstrumentCompleted;

        /// <remarks/>
        public event CreditPaymentInstrumentExCompletedEventHandler CreditPaymentInstrumentExCompleted;

        /// <remarks/>
        public event SetUserProfileCompletedEventHandler SetUserProfileCompleted;

        /// <remarks/>
        public event DeactivateTokenCompletedEventHandler DeactivateTokenCompleted;

        /// <remarks/>
        public event DeactivateTokenExCompletedEventHandler DeactivateTokenExCompleted;

        /// <remarks/>
        public event DeliverTokenCompletedEventHandler DeliverTokenCompleted;

        /// <remarks/>
        public event DeprovisionServicesCompletedEventHandler DeprovisionServicesCompleted;

        /// <remarks/>
        public event ExtendSubscriptionCompletedEventHandler ExtendSubscriptionCompleted;

        /// <remarks/>
        public event FixExistingAddressCompletedEventHandler FixExistingAddressCompleted;

        /// <remarks/>
        public event GetAccountIdFromAdminPUIDCompletedEventHandler GetAccountIdFromAdminPUIDCompleted;

        /// <remarks/>
        public event GetAccountIdFromPaymentInstrumentInfoCompletedEventHandler GetAccountIdFromPaymentInstrumentInfoCompleted;

        /// <remarks/>
        public event GetAccountIdFromPuidCompletedEventHandler GetAccountIdFromPuidCompleted;

        /// <remarks/>
        public event GetAccountIdFromTokenCompletedEventHandler GetAccountIdFromTokenCompleted;

        /// <remarks/>
        public event GetAccountIdFromTokenIdCompletedEventHandler GetAccountIdFromTokenIdCompleted;

        /// <remarks/>
        public event GetAccountInfoCompletedEventHandler GetAccountInfoCompleted;

        /// <remarks/>
        public event GetAccountStatusCompletedEventHandler GetAccountStatusCompleted;

        /// <remarks/>
        public event GetAdjustmentsCompletedEventHandler GetAdjustmentsCompleted;

        /// <remarks/>
        public event GetBaseOfferingsCompletedEventHandler GetBaseOfferingsCompleted;

        /// <remarks/>
        public event GetBaseOfferingsExCompletedEventHandler GetBaseOfferingsExCompleted;

        /// <remarks/>
        public event GetBillingPeriodsCompletedEventHandler GetBillingPeriodsCompleted;

        /// <remarks/>
        public event GetBillingReferenceCompletedEventHandler GetBillingReferenceCompleted;

        /// <remarks/>
        public event GetCommentsCompletedEventHandler GetCommentsCompleted;

        /// <remarks/>
        public event GetEligibleOfferingsCompletedEventHandler GetEligibleOfferingsCompleted;

        /// <remarks/>
        public event GetEligibleOfferingsExCompletedEventHandler GetEligibleOfferingsExCompleted;

        /// <remarks/>
        public event GetEligibleSwitchPITypesCompletedEventHandler GetEligibleSwitchPITypesCompleted;

        /// <remarks/>
        public event GetExistingAccountsByCriteriaCompletedEventHandler GetExistingAccountsByCriteriaCompleted;

        /// <remarks/>
        public event GetKeyCompletedEventHandler GetKeyCompleted;

        /// <remarks/>
        public event GetLineItemHistoryCompletedEventHandler GetLineItemHistoryCompleted;

        /// <remarks/>
        public event GetPartnerConfigurationCompletedEventHandler GetPartnerConfigurationCompleted;

        /// <remarks/>
        public event GetPaymentInstrumentsCompletedEventHandler GetPaymentInstrumentsCompleted;

        /// <remarks/>
        public event GetPaymentInstrumentsExCompletedEventHandler GetPaymentInstrumentsExCompleted;

        /// <remarks/>
        public event GetPaymentMethodTypePropertiesCompletedEventHandler GetPaymentMethodTypePropertiesCompleted;

        /// <remarks/>
        public event GetPermitHistoryForObjectIdCompletedEventHandler GetPermitHistoryForObjectIdCompleted;

        /// <remarks/>
        public event GetPermitsForObjectIdCompletedEventHandler GetPermitsForObjectIdCompleted;

        /// <remarks/>
        public event GetPermitsForPUIDCompletedEventHandler GetPermitsForPUIDCompleted;

        /// <remarks/>
        public event GetPolicyCompletedEventHandler GetPolicyCompleted;

        /// <remarks/>
        public event GetProductClassesCompletedEventHandler GetProductClassesCompleted;

        /// <remarks/>
        public event GetProvisioningInfoCompletedEventHandler GetProvisioningInfoCompleted;

        /// <remarks/>
        public event GetReferralDataCompletedEventHandler GetReferralDataCompleted;

        /// <remarks/>
        public event GetReferralEventsCompletedEventHandler GetReferralEventsCompleted;

        /// <remarks/>
        public event GetResourceBalancesCompletedEventHandler GetResourceBalancesCompleted;

        /// <remarks/>
        public event GetReplacementTokenCompletedEventHandler GetReplacementTokenCompleted;

        /// <remarks/>
        public event GetReplacementTokenFromPuidCompletedEventHandler GetReplacementTokenFromPuidCompleted;

        /// <remarks/>
        public event GetResourcePricesCompletedEventHandler GetResourcePricesCompleted;

        /// <remarks/>
        public event GetStatementCompletedEventHandler GetStatementCompleted;

        /// <remarks/>
        public event GetStatementExCompletedEventHandler GetStatementExCompleted;

        /// <remarks/>
        public event GetSubscriptionHistoryCompletedEventHandler GetSubscriptionHistoryCompleted;

        /// <remarks/>
        public event GetServiceComponentsCompletedEventHandler GetServiceComponentsCompleted;

        /// <remarks/>
        public event GetSubscriptionsCompletedEventHandler GetSubscriptionsCompleted;

        /// <remarks/>
        public event GetSubscriptionStatusCompletedEventHandler GetSubscriptionStatusCompleted;

        /// <remarks/>
        public event GetTokenClassRestrictionInfoForPUIDCompletedEventHandler GetTokenClassRestrictionInfoForPUIDCompleted;

        /// <remarks/>
        public event GetTokenClassesCompletedEventHandler GetTokenClassesCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML)
        {
            object[] results = this.Invoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetTokenInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId)
        {
            this.GetTokenInfoAsync(lDelegateIdHigh, lDelegateIdLow, bstrTokenId, null);
        }

        /// <remarks/>
        public void GetTokenInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, object userState)
        {
            if ((this.GetTokenInfoOperationCompleted == null))
            {
                this.GetTokenInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTokenInfoOperationCompleted);
            }
            this.InvokeAsync("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId}, this.GetTokenInfoOperationCompleted, userState);
        }

        private void OnGetTokenInfoOperationCompleted(object arg)
        {
            if ((this.GetTokenInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTokenInfoCompleted(this, new GetTokenInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML)
        {
            object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetTokenInfoExAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType)
        {
            this.GetTokenInfoExAsync(lDelegateIdHigh, lDelegateIdLow, bstrToken, lTokenType, null);
        }

        /// <remarks/>
        public void GetTokenInfoExAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, object userState)
        {
            if ((this.GetTokenInfoExOperationCompleted == null))
            {
                this.GetTokenInfoExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTokenInfoExOperationCompleted);
            }
            this.InvokeAsync("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType}, this.GetTokenInfoExOperationCompleted, userState);
        }

        private void OnGetTokenInfoExOperationCompleted(object arg)
        {
            if ((this.GetTokenInfoExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTokenInfoExCompleted(this, new GetTokenInfoExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTransactions", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, out string transactionSetXml)
        {
            object[] results = this.Invoke("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml});
            transactionSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetTransactions(System.IAsyncResult asyncResult, out string transactionSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            transactionSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetTransactionsAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml)
        {
            this.GetTransactionsAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, accountId, offeringGuid, transactionId, filteringCriteriaXml, null);
        }

        /// <remarks/>
        public void GetTransactionsAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, object userState)
        {
            if ((this.GetTransactionsOperationCompleted == null))
            {
                this.GetTransactionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransactionsOperationCompleted);
            }
            this.InvokeAsync("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml}, this.GetTransactionsOperationCompleted, userState);
        }

        private void OnGetTransactionsOperationCompleted(object arg)
        {
            if ((this.GetTransactionsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransactionsCompleted(this, new GetTransactionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUnconditionalReplacementToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber)
        {
            object[] results = this.Invoke("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid});
            replacementPin = ((string)(results[0]));
            signature = ((int)(results[1]));
            sequenceNumber = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetUnconditionalReplacementToken(System.IAsyncResult asyncResult, out string replacementPin, out int signature, out string sequenceNumber)
        {
            object[] results = this.EndInvoke(asyncResult);
            replacementPin = ((string)(results[0]));
            signature = ((int)(results[1]));
            sequenceNumber = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetUnconditionalReplacementTokenAsync(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid)
        {
            this.GetUnconditionalReplacementTokenAsync(delegateIdHigh, delegateIdLow, replacementPuidHigh, replacementPuidLow, tiePinRedemptionToPuid, replacementReasonCode, tokenClassGuid, emailAddress, sessionKey, trackingGuid, null);
        }

        /// <remarks/>
        public void GetUnconditionalReplacementTokenAsync(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, object userState)
        {
            if ((this.GetUnconditionalReplacementTokenOperationCompleted == null))
            {
                this.GetUnconditionalReplacementTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnconditionalReplacementTokenOperationCompleted);
            }
            this.InvokeAsync("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, this.GetUnconditionalReplacementTokenOperationCompleted, userState);
        }

        private void OnGetUnconditionalReplacementTokenOperationCompleted(object arg)
        {
            if ((this.GetUnconditionalReplacementTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnconditionalReplacementTokenCompleted(this, new GetUnconditionalReplacementTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUserProfile", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetUserProfile(string version, string callerInfoXml, string filterInfoXml, out string userProfileXml)
        {
            object[] results = this.Invoke("GetUserProfile", new object[] {
                    version,
                    callerInfoXml,
                    filterInfoXml});
            userProfileXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetUserProfile(string version, string callerInfoXml, string filterInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetUserProfile", new object[] {
                    version,
                    callerInfoXml,
                    filterInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetUserProfile(System.IAsyncResult asyncResult, out string userProfileXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            userProfileXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetUserProfileAsync(string version, string callerInfoXml, string filterInfoXml)
        {
            this.GetUserProfileAsync(version, callerInfoXml, filterInfoXml, null);
        }

        /// <remarks/>
        public void GetUserProfileAsync(string version, string callerInfoXml, string filterInfoXml, object userState)
        {
            if ((this.GetUserProfileOperationCompleted == null))
            {
                this.GetUserProfileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserProfileOperationCompleted);
            }
            this.InvokeAsync("GetUserProfile", new object[] {
                    version,
                    callerInfoXml,
                    filterInfoXml}, this.GetUserProfileOperationCompleted, userState);
        }

        private void OnGetUserProfileOperationCompleted(object arg)
        {
            if ((this.GetUserProfileCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserProfileCompleted(this, new GetUserProfileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML)
        {
            object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void ImportSettledBillingItemAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML)
        {
            this.ImportSettledBillingItemAsync(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, bstrPaymentInstrumentId, bstrTaxAddressId, bstrTrackingGUID, bstrSettledBillingItemXML, null);
        }

        /// <remarks/>
        public void ImportSettledBillingItemAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, object userState)
        {
            if ((this.ImportSettledBillingItemOperationCompleted == null))
            {
                this.ImportSettledBillingItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnImportSettledBillingItemOperationCompleted);
            }
            this.InvokeAsync("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, this.ImportSettledBillingItemOperationCompleted, userState);
        }

        private void OnImportSettledBillingItemOperationCompleted(object arg)
        {
            if ((this.ImportSettledBillingItemCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ImportSettledBillingItemCompleted(this, new ImportSettledBillingItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IssueTokenTrusted", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void IssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId)
        {
            this.Invoke("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndIssueTokenTrusted(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void IssueTokenTrustedAsync(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId)
        {
            this.IssueTokenTrustedAsync(partnerName, delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, null);
        }

        /// <remarks/>
        public void IssueTokenTrustedAsync(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, object userState)
        {
            if ((this.IssueTokenTrustedOperationCompleted == null))
            {
                this.IssueTokenTrustedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIssueTokenTrustedOperationCompleted);
            }
            this.InvokeAsync("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, this.IssueTokenTrustedOperationCompleted, userState);
        }

        private void OnIssueTokenTrustedOperationCompleted(object arg)
        {
            if ((this.IssueTokenTrustedCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IssueTokenTrustedCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned)
        {
            object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }

        /// <remarks/>
        public void IsPaymentInstrumentBannedAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML)
        {
            this.IsPaymentInstrumentBannedAsync(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void IsPaymentInstrumentBannedAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.IsPaymentInstrumentBannedOperationCompleted == null))
            {
                this.IsPaymentInstrumentBannedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsPaymentInstrumentBannedOperationCompleted);
            }
            this.InvokeAsync("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, this.IsPaymentInstrumentBannedOperationCompleted, userState);
        }

        private void OnIsPaymentInstrumentBannedOperationCompleted(object arg)
        {
            if ((this.IsPaymentInstrumentBannedCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IsPaymentInstrumentBannedCompleted(this, new IsPaymentInstrumentBannedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.LoadTokenInstance", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void LoadTokenInstance(System.Guid trackingGuid, string tokenInfoXML, out string responseXML)
        {
            object[] results = this.Invoke("LoadTokenInstance", new object[] {
                    trackingGuid,
                    tokenInfoXML});
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginLoadTokenInstance(System.Guid trackingGuid, string tokenInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("LoadTokenInstance", new object[] {
                    trackingGuid,
                    tokenInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndLoadTokenInstance(System.IAsyncResult asyncResult, out string responseXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void LoadTokenInstanceAsync(System.Guid trackingGuid, string tokenInfoXML)
        {
            this.LoadTokenInstanceAsync(trackingGuid, tokenInfoXML, null);
        }

        /// <remarks/>
        public void LoadTokenInstanceAsync(System.Guid trackingGuid, string tokenInfoXML, object userState)
        {
            if ((this.LoadTokenInstanceOperationCompleted == null))
            {
                this.LoadTokenInstanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLoadTokenInstanceOperationCompleted);
            }
            this.InvokeAsync("LoadTokenInstance", new object[] {
                    trackingGuid,
                    tokenInfoXML}, this.LoadTokenInstanceOperationCompleted, userState);
        }

        private void OnLoadTokenInstanceOperationCompleted(object arg)
        {
            if ((this.LoadTokenInstanceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LoadTokenInstanceCompleted(this, new LoadTokenInstanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MarkTokenDistributionStatus", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void MarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber)
        {
            this.Invoke("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber});
        }

        /// <remarks/>
        public System.IAsyncResult BeginMarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber}, callback, asyncState);
        }

        /// <remarks/>
        public void EndMarkTokenDistributionStatus(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void MarkTokenDistributionStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber)
        {
            this.MarkTokenDistributionStatusAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrTokenId, lTokenType, bstrStatusName, bstrStatusValue, bstrPartNumber, null);
        }

        /// <remarks/>
        public void MarkTokenDistributionStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber, object userState)
        {
            if ((this.MarkTokenDistributionStatusOperationCompleted == null))
            {
                this.MarkTokenDistributionStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMarkTokenDistributionStatusOperationCompleted);
            }
            this.InvokeAsync("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber}, this.MarkTokenDistributionStatusOperationCompleted, userState);
        }

        private void OnMarkTokenDistributionStatusOperationCompleted(object arg)
        {
            if ((this.MarkTokenDistributionStatusCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MarkTokenDistributionStatusCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MapAddress", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void MapAddress(int delegateIdHigh, int delegateIdLow, string referenceTrackingGuid, string addressInfoXML, out string MapAddressInfoSet)
        {
            object[] results = this.Invoke("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    referenceTrackingGuid,
                    addressInfoXML});
            MapAddressInfoSet = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginMapAddress(int delegateIdHigh, int delegateIdLow, string referenceTrackingGuid, string addressInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    referenceTrackingGuid,
                    addressInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndMapAddress(System.IAsyncResult asyncResult, out string MapAddressInfoSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            MapAddressInfoSet = ((string)(results[0]));
        }

        /// <remarks/>
        public void MapAddressAsync(int delegateIdHigh, int delegateIdLow, string referenceTrackingGuid, string addressInfoXML)
        {
            this.MapAddressAsync(delegateIdHigh, delegateIdLow, referenceTrackingGuid, addressInfoXML, null);
        }

        /// <remarks/>
        public void MapAddressAsync(int delegateIdHigh, int delegateIdLow, string referenceTrackingGuid, string addressInfoXML, object userState)
        {
            if ((this.MapAddressOperationCompleted == null))
            {
                this.MapAddressOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMapAddressOperationCompleted);
            }
            this.InvokeAsync("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    referenceTrackingGuid,
                    addressInfoXML}, this.MapAddressOperationCompleted, userState);
        }

        private void OnMapAddressOperationCompleted(object arg)
        {
            if ((this.MapAddressCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MapAddressCompleted(this, new MapAddressCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow)
        {
            object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }

        /// <remarks/>
        public void MatchPaymentInstrumentInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML)
        {
            this.MatchPaymentInstrumentInfoAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTelenumericLastName, bstrZipCode, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void MatchPaymentInstrumentInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.MatchPaymentInstrumentInfoOperationCompleted == null))
            {
                this.MatchPaymentInstrumentInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMatchPaymentInstrumentInfoOperationCompleted);
            }
            this.InvokeAsync("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML}, this.MatchPaymentInstrumentInfoOperationCompleted, userState);
        }

        private void OnMatchPaymentInstrumentInfoOperationCompleted(object arg)
        {
            if ((this.MatchPaymentInstrumentInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MatchPaymentInstrumentInfoCompleted(this, new MatchPaymentInstrumentInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MigrateOffer", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void MigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.Invoke("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
            plAddedServiceInstanceSetCount = ((int)(results[0]));
            pbstrAddedServiceInstanceSet = ((string)(results[1]));
            plRemovedServiceInstanceSetCount = ((int)(results[2]));
            pbstrRemoveServiceInstanceSet = ((string)(results[3]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginMigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
        }

        /// <remarks/>
        public void EndMigrateOffer(System.IAsyncResult asyncResult, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            plAddedServiceInstanceSetCount = ((int)(results[0]));
            pbstrAddedServiceInstanceSet = ((string)(results[1]));
            plRemovedServiceInstanceSetCount = ((int)(results[2]));
            pbstrRemoveServiceInstanceSet = ((string)(results[3]));
        }

        /// <remarks/>
        public void MigrateOfferAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime)
        {
            this.MigrateOfferAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, bstrOfferingGUID, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, null);
        }

        /// <remarks/>
        public void MigrateOfferAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, object userState)
        {
            if ((this.MigrateOfferOperationCompleted == null))
            {
                this.MigrateOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMigrateOfferOperationCompleted);
            }
            this.InvokeAsync("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, this.MigrateOfferOperationCompleted, userState);
        }

        private void OnMigrateOfferOperationCompleted(object arg)
        {
            if ((this.MigrateOfferCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MigrateOfferCompleted(this, new MigrateOfferCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError)
        {
            object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public void OffsetLineItemAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML)
        {
            this.OffsetLineItemAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrLineItemId, lFinancialReportingCode, fImmediatelySettle, bstrAmount, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void OffsetLineItemAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, object userState)
        {
            if ((this.OffsetLineItemOperationCompleted == null))
            {
                this.OffsetLineItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOffsetLineItemOperationCompleted);
            }
            this.InvokeAsync("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, this.OffsetLineItemOperationCompleted, userState);
        }

        private void OnOffsetLineItemOperationCompleted(object arg)
        {
            if ((this.OffsetLineItemCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OffsetLineItemCompleted(this, new OffsetLineItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML)
        {
            object[] results = this.Invoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML});
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void OffsetLineItem2Async(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML)
        {
            this.OffsetLineItem2Async(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrLineItemId, lFinancialReportingCode, fImmediatelySettle, bstrAmount, bstrCommentInfoXML, bstrReservedXML, null);
        }

        /// <remarks/>
        public void OffsetLineItem2Async(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, object userState)
        {
            if ((this.OffsetLineItem2OperationCompleted == null))
            {
                this.OffsetLineItem2OperationCompleted = new System.Threading.SendOrPostCallback(this.OnOffsetLineItem2OperationCompleted);
            }
            this.InvokeAsync("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML}, this.OffsetLineItem2OperationCompleted, userState);
        }

        private void OnOffsetLineItem2OperationCompleted(object arg)
        {
            if ((this.OffsetLineItem2Completed != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OffsetLineItem2Completed(this, new OffsetLineItem2CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetOrder", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void OffsetOrder(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, out string orderReceiptXml)
        {
            object[] results = this.Invoke("OffsetOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    correlationInfoXml,
                    orderDetailXml,
                    commentInfoXml});
            orderReceiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOffsetOrder(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OffsetOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    correlationInfoXml,
                    orderDetailXml,
                    commentInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndOffsetOrder(System.IAsyncResult asyncResult, out string orderReceiptXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            orderReceiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void OffsetOrderAsync(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml)
        {
            this.OffsetOrderAsync(version, trackingGuid, callerInfoXml, objectId, correlationInfoXml, orderDetailXml, commentInfoXml, null);
        }

        /// <remarks/>
        public void OffsetOrderAsync(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, object userState)
        {
            if ((this.OffsetOrderOperationCompleted == null))
            {
                this.OffsetOrderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOffsetOrderOperationCompleted);
            }
            this.InvokeAsync("OffsetOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    correlationInfoXml,
                    orderDetailXml,
                    commentInfoXml}, this.OffsetOrderOperationCompleted, userState);
        }

        private void OnOffsetOrderOperationCompleted(object arg)
        {
            if ((this.OffsetOrderCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OffsetOrderCompleted(this, new OffsetOrderCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetSingleUsageEvent", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void OffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, out string newLineItemXML)
        {
            object[] results = this.Invoke("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity});
            newLineItemXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity}, callback, asyncState);
        }

        /// <remarks/>
        public void EndOffsetSingleUsageEvent(System.IAsyncResult asyncResult, out string newLineItemXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            newLineItemXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void OffsetSingleUsageEventAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity)
        {
            this.OffsetSingleUsageEventAsync(delegateIdHigh, delegateIdLow, trackingGuid, lineItemId, units, CommentInfoXML, reservedXML, returnAsUsageActivity, null);
        }

        /// <remarks/>
        public void OffsetSingleUsageEventAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, object userState)
        {
            if ((this.OffsetSingleUsageEventOperationCompleted == null))
            {
                this.OffsetSingleUsageEventOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOffsetSingleUsageEventOperationCompleted);
            }
            this.InvokeAsync("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity}, this.OffsetSingleUsageEventOperationCompleted, userState);
        }

        private void OnOffsetSingleUsageEventOperationCompleted(object arg)
        {
            if ((this.OffsetSingleUsageEventCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OffsetSingleUsageEventCompleted(this, new OffsetSingleUsageEventCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAccount", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void OrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, out long orderId)
        {
            object[] results = this.Invoke("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode});
            orderId = ((long)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode}, callback, asyncState);
        }

        /// <remarks/>
        public void EndOrderCDforAccount(System.IAsyncResult asyncResult, out long orderId)
        {
            object[] results = this.EndInvoke(asyncResult);
            orderId = ((long)(results[0]));
        }

        /// <remarks/>
        public void OrderCDforAccountAsync(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode)
        {
            this.OrderCDforAccountAsync(accountIDBlob, subscriptionRefIDBlob, surveyResultCode, null);
        }

        /// <remarks/>
        public void OrderCDforAccountAsync(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, object userState)
        {
            if ((this.OrderCDforAccountOperationCompleted == null))
            {
                this.OrderCDforAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOrderCDforAccountOperationCompleted);
            }
            this.InvokeAsync("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode}, this.OrderCDforAccountOperationCompleted, userState);
        }

        private void OnOrderCDforAccountOperationCompleted(object arg)
        {
            if ((this.OrderCDforAccountCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OrderCDforAccountCompleted(this, new OrderCDforAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAnonymous", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void OrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, out long orderId)
        {
            object[] results = this.Invoke("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo});
            orderId = ((long)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo}, callback, asyncState);
        }

        /// <remarks/>
        public void EndOrderCDforAnonymous(System.IAsyncResult asyncResult, out long orderId)
        {
            object[] results = this.EndInvoke(asyncResult);
            orderId = ((long)(results[0]));
        }

        /// <remarks/>
        public void OrderCDforAnonymousAsync(string anonymousInfoXml, string category, string requestorInfo)
        {
            this.OrderCDforAnonymousAsync(anonymousInfoXml, category, requestorInfo, null);
        }

        /// <remarks/>
        public void OrderCDforAnonymousAsync(string anonymousInfoXml, string category, string requestorInfo, object userState)
        {
            if ((this.OrderCDforAnonymousOperationCompleted == null))
            {
                this.OrderCDforAnonymousOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOrderCDforAnonymousOperationCompleted);
            }
            this.InvokeAsync("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo}, this.OrderCDforAnonymousOperationCompleted, userState);
        }

        private void OnOrderCDforAnonymousOperationCompleted(object arg)
        {
            if ((this.OrderCDforAnonymousCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OrderCDforAnonymousCompleted(this, new OrderCDforAnonymousCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PayUser", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PayUser(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, out string payUserResultXml)
        {
            object[] results = this.Invoke("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml});
            payUserResultXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPayUser(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPayUser(System.IAsyncResult asyncResult, out string payUserResultXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            payUserResultXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void PayUserAsync(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml)
        {
            this.PayUserAsync(delegateIdHigh, delegateIdLow, targetIdHigh, targetIdLow, trackingGuid, amount, currency, offeringGuid, description, externalReferenceId, payUserInfoXml, null);
        }

        /// <remarks/>
        public void PayUserAsync(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, object userState)
        {
            if ((this.PayUserOperationCompleted == null))
            {
                this.PayUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPayUserOperationCompleted);
            }
            this.InvokeAsync("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml}, this.PayUserOperationCompleted, userState);
        }

        private void OnPayUserOperationCompleted(object arg)
        {
            if ((this.PayUserCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PayUserCompleted(this, new PayUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProcessChargeback", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, out string chargebackResponseInfoXml)
        {
            object[] results = this.Invoke("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml});
            chargebackResponseInfoXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndProcessChargeback(System.IAsyncResult asyncResult, out string chargebackResponseInfoXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            chargebackResponseInfoXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void ProcessChargebackAsync(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml)
        {
            this.ProcessChargebackAsync(delegateIdHigh, delegateIdLow, lineItemId, fileId, fileNamespace, recordOnly, mode, chargebackInstanceXml, commentInfoXml, null);
        }

        /// <remarks/>
        public void ProcessChargebackAsync(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, object userState)
        {
            if ((this.ProcessChargebackOperationCompleted == null))
            {
                this.ProcessChargebackOperationCompleted = new System.Threading.SendOrPostCallback(this.OnProcessChargebackOperationCompleted);
            }
            this.InvokeAsync("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml}, this.ProcessChargebackOperationCompleted, userState);
        }

        private void OnProcessChargebackOperationCompleted(object arg)
        {
            if ((this.ProcessChargebackCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ProcessChargebackCompleted(this, new ProcessChargebackCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void ProvisionServicesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML)
        {
            this.ProvisionServicesAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceInstanceSetXML, null);
        }

        /// <remarks/>
        public void ProvisionServicesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, object userState)
        {
            if ((this.ProvisionServicesOperationCompleted == null))
            {
                this.ProvisionServicesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnProvisionServicesOperationCompleted);
            }
            this.InvokeAsync("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, this.ProvisionServicesOperationCompleted, userState);
        }

        private void OnProvisionServicesOperationCompleted(object arg)
        {
            if ((this.ProvisionServicesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ProvisionServicesCompleted(this, new ProvisionServicesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseItem", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, out string receiptXml)
        {
            object[] results = this.Invoke("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml});
            receiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPurchaseItem(System.IAsyncResult asyncResult, out string receiptXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            receiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void PurchaseItemAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml)
        {
            this.PurchaseItemAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, trackingGuid, itemSetXml, paymentMethodXml, transactionContextXml, null);
        }

        /// <remarks/>
        public void PurchaseItemAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, object userState)
        {
            if ((this.PurchaseItemOperationCompleted == null))
            {
                this.PurchaseItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseItemOperationCompleted);
            }
            this.InvokeAsync("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml}, this.PurchaseItemOperationCompleted, userState);
        }

        private void OnPurchaseItemOperationCompleted(object arg)
        {
            if ((this.PurchaseItemCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseItemCompleted(this, new PurchaseItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseItemEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PurchaseItemEx(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, int recipientIdHigh, int recipientIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, out string receiptXml)
        {
            object[] results = this.Invoke("PurchaseItemEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    recipientIdHigh,
                    recipientIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml});
            receiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPurchaseItemEx(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, int recipientIdHigh, int recipientIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("PurchaseItemEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    recipientIdHigh,
                    recipientIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPurchaseItemEx(System.IAsyncResult asyncResult, out string receiptXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            receiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void PurchaseItemExAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, int recipientIdHigh, int recipientIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml)
        {
            this.PurchaseItemExAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, recipientIdHigh, recipientIdLow, trackingGuid, itemSetXml, paymentMethodXml, transactionContextXml, null);
        }

        /// <remarks/>
        public void PurchaseItemExAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, int recipientIdHigh, int recipientIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, object userState)
        {
            if ((this.PurchaseItemExOperationCompleted == null))
            {
                this.PurchaseItemExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseItemExOperationCompleted);
            }
            this.InvokeAsync("PurchaseItemEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    recipientIdHigh,
                    recipientIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml}, this.PurchaseItemExOperationCompleted, userState);
        }

        private void OnPurchaseItemExOperationCompleted(object arg)
        {
            if ((this.PurchaseItemExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseItemExCompleted(this, new PurchaseItemExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PurchaseOffering(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    out string pbstrErrorXML,
                    out string pbstrSubscriptionId,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceCount,
                    out string pbstrAddedServiceInstanceSetXML)
        {
            object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOffering(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public void PurchaseOfferingAsync(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML)
        {
            this.PurchaseOfferingAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionName, bstrAccountId, bstrBaseSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrPaymentInstrumentId, bstrShippingAddressId, bstrActivationDate, bstrSubscriptionEndDate, bstrReferralSetXML, null);
        }

        /// <remarks/>
        public void PurchaseOfferingAsync(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    object userState)
        {
            if ((this.PurchaseOfferingOperationCompleted == null))
            {
                this.PurchaseOfferingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseOfferingOperationCompleted);
            }
            this.InvokeAsync("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, this.PurchaseOfferingOperationCompleted, userState);
        }

        private void OnPurchaseOfferingOperationCompleted(object arg)
        {
            if ((this.PurchaseOfferingCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseOfferingCompleted(this, new PurchaseOfferingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PurchaseOfferingEx(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    out string pbstrErrorXML,
                    out string pbstrSubscriptionId,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceCount,
                    out string pbstrAddedServiceInstanceSetXML)
        {
            object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public void PurchaseOfferingExAsync(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime)
        {
            this.PurchaseOfferingExAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionName, bstrAccountId, bstrBaseSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrPaymentInstrumentId, bstrShippingAddressId, bstrActivationDate, bstrSubscriptionEndDate, bstrReferralSetXML, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, null);
        }

        /// <remarks/>
        public void PurchaseOfferingExAsync(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    object userState)
        {
            if ((this.PurchaseOfferingExOperationCompleted == null))
            {
                this.PurchaseOfferingExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseOfferingExOperationCompleted);
            }
            this.InvokeAsync("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, this.PurchaseOfferingExOperationCompleted, userState);
        }

        private void OnPurchaseOfferingExOperationCompleted(object arg)
        {
            if ((this.PurchaseOfferingExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseOfferingExCompleted(this, new PurchaseOfferingExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx2", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PurchaseOfferingEx2(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    out string pbstrErrorXML,
                    out string pbstrSubscriptionId,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceCount,
                    out string pbstrAddedServiceInstanceSetXML,
                    out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.Invoke("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
            pbstrRedirectOutputInfoXML = ((string)(results[5]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx2(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPurchaseOfferingEx2(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML, out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
            pbstrRedirectOutputInfoXML = ((string)(results[5]));
        }

        /// <remarks/>
        public void PurchaseOfferingEx2Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML)
        {
            this.PurchaseOfferingEx2Async(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionName, bstrAccountId, bstrBaseSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrPaymentInstrumentId, bstrShippingAddressId, bstrActivationDate, bstrSubscriptionEndDate, bstrReferralSetXML, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, bstrRedirectInputInfoXML, null);
        }

        /// <remarks/>
        public void PurchaseOfferingEx2Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    object userState)
        {
            if ((this.PurchaseOfferingEx2OperationCompleted == null))
            {
                this.PurchaseOfferingEx2OperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseOfferingEx2OperationCompleted);
            }
            this.InvokeAsync("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, this.PurchaseOfferingEx2OperationCompleted, userState);
        }

        private void OnPurchaseOfferingEx2OperationCompleted(object arg)
        {
            if ((this.PurchaseOfferingEx2Completed != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseOfferingEx2Completed(this, new PurchaseOfferingEx2CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx3", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void PurchaseOfferingEx3(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML,
                    out string pbstrErrorXML,
                    out string pbstrSubscriptionId,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceCount,
                    out string pbstrAddedServiceInstanceSetXML,
                    out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.Invoke("PurchaseOfferingEx3", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML,
                    bstrDiscountGuid,
                    bstrExtraInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
            pbstrRedirectOutputInfoXML = ((string)(results[5]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx3(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("PurchaseOfferingEx3", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML,
                    bstrDiscountGuid,
                    bstrExtraInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndPurchaseOfferingEx3(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML, out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
            pbstrRedirectOutputInfoXML = ((string)(results[5]));
        }

        /// <remarks/>
        public void PurchaseOfferingEx3Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML)
        {
            this.PurchaseOfferingEx3Async(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionName, bstrAccountId, bstrBaseSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrPaymentInstrumentId, bstrShippingAddressId, bstrActivationDate, bstrSubscriptionEndDate, bstrReferralSetXML, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, bstrRedirectInputInfoXML, bstrDiscountGuid, bstrExtraInfoXML, null);
        }

        /// <remarks/>
        public void PurchaseOfferingEx3Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    string bstrSubscriptionName,
                    string bstrAccountId,
                    string bstrBaseSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrPaymentInstrumentId,
                    string bstrShippingAddressId,
                    string bstrActivationDate,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML,
                    object userState)
        {
            if ((this.PurchaseOfferingEx3OperationCompleted == null))
            {
                this.PurchaseOfferingEx3OperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseOfferingEx3OperationCompleted);
            }
            this.InvokeAsync("PurchaseOfferingEx3", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML,
                    bstrDiscountGuid,
                    bstrExtraInfoXML}, this.PurchaseOfferingEx3OperationCompleted, userState);
        }

        private void OnPurchaseOfferingEx3OperationCompleted(object arg)
        {
            if ((this.PurchaseOfferingEx3Completed != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseOfferingEx3Completed(this, new PurchaseOfferingEx3CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReconcileTokenTrusted", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, out int reconStatus)
        {
            object[] results = this.Invoke("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action});
            reconStatus = ((int)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, System.AsyncCallback callback, object asyncState)
        {

            return this.BeginInvoke("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReconcileTokenTrusted(System.IAsyncResult asyncResult, out int reconStatus)
        {
            object[] results = this.EndInvoke(asyncResult);
            reconStatus = ((int)(results[0]));
        }

        /// <remarks/>
        public void ReconcileTokenTrustedAsync(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action)
        {
            this.ReconcileTokenTrustedAsync(partnerName, delegateIdHigh, delegateIdLow, token, tokenType, externalReferenceId, timeStamp, action, null);
        }

        /// <remarks/>
        public void ReconcileTokenTrustedAsync(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, object userState)
        {
            if ((this.ReconcileTokenTrustedOperationCompleted == null))
            {
                this.ReconcileTokenTrustedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReconcileTokenTrustedOperationCompleted);
            }
            this.InvokeAsync("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action}, this.ReconcileTokenTrustedOperationCompleted, userState);
        }

        private void OnReconcileTokenTrustedOperationCompleted(object arg)
        {
            if ((this.ReconcileTokenTrustedCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReconcileTokenTrustedCompleted(this, new ReconcileTokenTrustedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RefundTaxForAccount", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RefundTaxForAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, out string pbstrNewLineItemSetXML)
        {
            object[] results = this.Invoke("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund});
            pbstrNewLineItemSetXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRefundTaxForAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRefundTaxForAccount(System.IAsyncResult asyncResult, out string pbstrNewLineItemSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrNewLineItemSetXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void RefundTaxForAccountAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund)
        {
            this.RefundTaxForAccountAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrAccountId, bstrCommentInfoXML, fRevertTaxRefund, null);
        }

        /// <remarks/>
        public void RefundTaxForAccountAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, object userState)
        {
            if ((this.RefundTaxForAccountOperationCompleted == null))
            {
                this.RefundTaxForAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRefundTaxForAccountOperationCompleted);
            }
            this.InvokeAsync("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund}, this.RefundTaxForAccountOperationCompleted, userState);
        }

        private void OnRefundTaxForAccountOperationCompleted(object arg)
        {
            if ((this.RefundTaxForAccountCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RefundTaxForAccountCompleted(this, new RefundTaxForAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RegisterPaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml)
        {
            object[] results = this.Invoke("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml});
            paymentInstrumentId = ((string)(results[0]));
            requiredPaperWorkUrl = ((string)(results[1]));
            paymentInstrumentsResultsXml = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRegisterPaymentInstrument(System.IAsyncResult asyncResult, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            paymentInstrumentId = ((string)(results[0]));
            requiredPaperWorkUrl = ((string)(results[1]));
            paymentInstrumentsResultsXml = ((string)(results[2]));
        }

        /// <remarks/>
        public void RegisterPaymentInstrumentAsync(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml)
        {
            this.RegisterPaymentInstrumentAsync(delegateIdHigh, delegateIdLow, requestorIdHigh, requestorIdLow, trackingGuid, paymentInstrumentInfoXml, accountInfoXml, responseOptionsXml, null);
        }

        /// <remarks/>
        public void RegisterPaymentInstrumentAsync(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, object userState)
        {
            if ((this.RegisterPaymentInstrumentOperationCompleted == null))
            {
                this.RegisterPaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRegisterPaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml}, this.RegisterPaymentInstrumentOperationCompleted, userState);
        }

        private void OnRegisterPaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.RegisterPaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RegisterPaymentInstrumentCompleted(this, new RegisterPaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML)
        {
            object[] results = this.Invoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void ReinstateSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML)
        {
            this.ReinstateSubscriptionAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, lReserved, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void ReinstateSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, object userState)
        {
            if ((this.ReinstateSubscriptionOperationCompleted == null))
            {
                this.ReinstateSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReinstateSubscriptionOperationCompleted);
            }
            this.InvokeAsync("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML}, this.ReinstateSubscriptionOperationCompleted, userState);
        }

        private void OnReinstateSubscriptionOperationCompleted(object arg)
        {
            if ((this.ReinstateSubscriptionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReinstateSubscriptionCompleted(this, new ReinstateSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveBillingReference", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RemoveBillingReference(string version, string callerInfoXml, string billingReferenceId)
        {
            this.Invoke("RemoveBillingReference", new object[] {
                    version,
                    callerInfoXml,
                    billingReferenceId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginRemoveBillingReference(string version, string callerInfoXml, string billingReferenceId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RemoveBillingReference", new object[] {
                    version,
                    callerInfoXml,
                    billingReferenceId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRemoveBillingReference(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void RemoveBillingReferenceAsync(string version, string callerInfoXml, string billingReferenceId)
        {
            this.RemoveBillingReferenceAsync(version, callerInfoXml, billingReferenceId, null);
        }

        /// <remarks/>
        public void RemoveBillingReferenceAsync(string version, string callerInfoXml, string billingReferenceId, object userState)
        {
            if ((this.RemoveBillingReferenceOperationCompleted == null))
            {
                this.RemoveBillingReferenceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveBillingReferenceOperationCompleted);
            }
            this.InvokeAsync("RemoveBillingReference", new object[] {
                    version,
                    callerInfoXml,
                    billingReferenceId}, this.RemoveBillingReferenceOperationCompleted, userState);
        }

        private void OnRemoveBillingReferenceOperationCompleted(object arg)
        {
            if ((this.RemoveBillingReferenceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveBillingReferenceCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void RemovePaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId)
        {
            this.RemovePaymentInstrumentAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, null);
        }

        /// <remarks/>
        public void RemovePaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, object userState)
        {
            if ((this.RemovePaymentInstrumentOperationCompleted == null))
            {
                this.RemovePaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemovePaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, this.RemovePaymentInstrumentOperationCompleted, userState);
        }

        private void OnRemovePaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.RemovePaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemovePaymentInstrumentCompleted(this, new RemovePaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePMNBasedServices", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow)
        {
            this.Invoke("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow});
        }

        /// <remarks/>
        public System.IAsyncResult BeginRemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRemovePMNBasedServices(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void RemovePMNBasedServicesAsync(int lRequesterIdHigh, int lRequesterIdLow)
        {
            this.RemovePMNBasedServicesAsync(lRequesterIdHigh, lRequesterIdLow, null);
        }

        /// <remarks/>
        public void RemovePMNBasedServicesAsync(int lRequesterIdHigh, int lRequesterIdLow, object userState)
        {
            if ((this.RemovePMNBasedServicesOperationCompleted == null))
            {
                this.RemovePMNBasedServicesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemovePMNBasedServicesOperationCompleted);
            }
            this.InvokeAsync("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow}, this.RemovePMNBasedServicesOperationCompleted, userState);
        }

        private void OnRemovePMNBasedServicesOperationCompleted(object arg)
        {
            if ((this.RemovePMNBasedServicesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemovePMNBasedServicesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void RemoveRoleAssignmentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML)
        {
            this.RemoveRoleAssignmentAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrRoleAssignmentXML, null);
        }

        /// <remarks/>
        public void RemoveRoleAssignmentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, object userState)
        {
            if ((this.RemoveRoleAssignmentOperationCompleted == null))
            {
                this.RemoveRoleAssignmentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveRoleAssignmentOperationCompleted);
            }
            this.InvokeAsync("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, this.RemoveRoleAssignmentOperationCompleted, userState);
        }

        private void OnRemoveRoleAssignmentOperationCompleted(object arg)
        {
            if ((this.RemoveRoleAssignmentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveRoleAssignmentCompleted(this, new RemoveRoleAssignmentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void RemoveViolationAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML)
        {
            this.RemoveViolationAsync(lDelegateIdHigh, lDelegateIdLow, bstrObjectId, lViolationId, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void RemoveViolationAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, object userState)
        {
            if ((this.RemoveViolationOperationCompleted == null))
            {
                this.RemoveViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveViolationOperationCompleted);
            }
            this.InvokeAsync("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, this.RemoveViolationOperationCompleted, userState);
        }

        private void OnRemoveViolationOperationCompleted(object arg)
        {
            if ((this.RemoveViolationCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveViolationCompleted(this, new RemoveViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportSingleUsageEvent", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, out string lineItemId, out string usageInfoXml, out string amountChargedXml)
        {
            object[] results = this.Invoke("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml});
            lineItemId = ((string)(results[0]));
            usageInfoXml = ((string)(results[1]));
            amountChargedXml = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReportSingleUsageEvent(System.IAsyncResult asyncResult, out string lineItemId, out string usageInfoXml, out string amountChargedXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            lineItemId = ((string)(results[0]));
            usageInfoXml = ((string)(results[1]));
            amountChargedXml = ((string)(results[2]));
        }

        /// <remarks/>
        public void ReportSingleUsageEventAsync(string trackingGuid, bool computeOnly, string usageEventXml)
        {
            this.ReportSingleUsageEventAsync(trackingGuid, computeOnly, usageEventXml, null);
        }

        /// <remarks/>
        public void ReportSingleUsageEventAsync(string trackingGuid, bool computeOnly, string usageEventXml, object userState)
        {
            if ((this.ReportSingleUsageEventOperationCompleted == null))
            {
                this.ReportSingleUsageEventOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReportSingleUsageEventOperationCompleted);
            }
            this.InvokeAsync("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml}, this.ReportSingleUsageEventOperationCompleted, userState);
        }

        private void OnReportSingleUsageEventOperationCompleted(object arg)
        {
            if ((this.ReportSingleUsageEventCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReportSingleUsageEventCompleted(this, new ReportSingleUsageEventCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportTransactionEvent", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml)
        {
            this.Invoke("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml});
        }

        /// <remarks/>
        public System.IAsyncResult BeginReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReportTransactionEvent(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ReportTransactionEventAsync(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml)
        {
            this.ReportTransactionEventAsync(sequenceNumber, transactionId, merchantId, vendorInternalTransactionId, amountXml, transactionEventXml, paymentDetailsXml, null);
        }

        /// <remarks/>
        public void ReportTransactionEventAsync(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml, object userState)
        {
            if ((this.ReportTransactionEventOperationCompleted == null))
            {
                this.ReportTransactionEventOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReportTransactionEventOperationCompleted);
            }
            this.InvokeAsync("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml}, this.ReportTransactionEventOperationCompleted, userState);
        }

        private void OnReportTransactionEventOperationCompleted(object arg)
        {
            if ((this.ReportTransactionEventCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReportTransactionEventCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void ReportUsageEventAsync(string bstrTrackingGUID, string bstrUsageSetXML)
        {
            this.ReportUsageEventAsync(bstrTrackingGUID, bstrUsageSetXML, null);
        }

        /// <remarks/>
        public void ReportUsageEventAsync(string bstrTrackingGUID, string bstrUsageSetXML, object userState)
        {
            if ((this.ReportUsageEventOperationCompleted == null))
            {
                this.ReportUsageEventOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReportUsageEventOperationCompleted);
            }
            this.InvokeAsync("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, this.ReportUsageEventOperationCompleted, userState);
        }

        private void OnReportUsageEventOperationCompleted(object arg)
        {
            if ((this.ReportUsageEventCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReportUsageEventCompleted(this, new ReportUsageEventCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML)
        {
            object[] results = this.Invoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void ReschedulePaymentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML)
        {
            this.ReschedulePaymentAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, fApplyDeclineEffects, bstrNewDueDate, fStickyDueDate, lTransactionType, bstrSettlementDetailsXML, null);
        }

        /// <remarks/>
        public void ReschedulePaymentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, object userState)
        {
            if ((this.ReschedulePaymentOperationCompleted == null))
            {
                this.ReschedulePaymentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReschedulePaymentOperationCompleted);
            }
            this.InvokeAsync("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML}, this.ReschedulePaymentOperationCompleted, userState);
        }

        private void OnReschedulePaymentOperationCompleted(object arg)
        {
            if ((this.ReschedulePaymentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReschedulePaymentCompleted(this, new ReschedulePaymentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public void SearchAccountsAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML)
        {
            this.SearchAccountsAsync(lDelegateIdHigh, lDelegateIdLow, fFullData, lMax, bstrSearchXML, null);
        }

        /// <remarks/>
        public void SearchAccountsAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, object userState)
        {
            if ((this.SearchAccountsOperationCompleted == null))
            {
                this.SearchAccountsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSearchAccountsOperationCompleted);
            }
            this.InvokeAsync("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, this.SearchAccountsOperationCompleted, userState);
        }

        private void OnSearchAccountsOperationCompleted(object arg)
        {
            if ((this.SearchAccountsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SearchAccountsCompleted(this, new SearchAccountsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccountsEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml)
        {
            object[] results = this.Invoke("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax});
            bookmarkNew = ((string)(results[0]));
            returnedAccountCount = ((int)(results[1]));
            accountInfoSetXml = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSearchAccountsEx(System.IAsyncResult asyncResult, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            bookmarkNew = ((string)(results[0]));
            returnedAccountCount = ((int)(results[1]));
            accountInfoSetXml = ((string)(results[2]));
        }

        /// <remarks/>
        public void SearchAccountsExAsync(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax)
        {
            this.SearchAccountsExAsync(delegatePuidHigh, delegatePuidLow, accountSearchCriteriaXml, bookmark, returnedAccountCountMax, null);
        }

        /// <remarks/>
        public void SearchAccountsExAsync(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, object userState)
        {
            if ((this.SearchAccountsExOperationCompleted == null))
            {
                this.SearchAccountsExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSearchAccountsExOperationCompleted);
            }
            this.InvokeAsync("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax}, this.SearchAccountsExOperationCompleted, userState);
        }

        private void OnSearchAccountsExOperationCompleted(object arg)
        {
            if ((this.SearchAccountsExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SearchAccountsExCompleted(this, new SearchAccountsExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchBillingInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, out string billingInfoSetXML)
        {
            object[] results = this.Invoke("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML});
            billingInfoSetXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSearchBillingInfo(System.IAsyncResult asyncResult, out string billingInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            billingInfoSetXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void SearchBillingInfoAsync(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML)
        {
            this.SearchBillingInfoAsync(delegateIdHigh, delegateIdLow, billingInfoSearchCriteriaXML, null);
        }

        /// <remarks/>
        public void SearchBillingInfoAsync(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, object userState)
        {
            if ((this.SearchBillingInfoOperationCompleted == null))
            {
                this.SearchBillingInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSearchBillingInfoOperationCompleted);
            }
            this.InvokeAsync("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML}, this.SearchBillingInfoOperationCompleted, userState);
        }

        private void OnSearchBillingInfoOperationCompleted(object arg)
        {
            if ((this.SearchBillingInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SearchBillingInfoCompleted(this, new SearchBillingInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale)
        {
            this.Invoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSendHCI(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void SendHCIAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale)
        {
            this.SendHCIAsync(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, lBillingPeriodId, bstrLocale, null);
        }

        /// <remarks/>
        public void SendHCIAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, object userState)
        {
            if ((this.SendHCIOperationCompleted == null))
            {
                this.SendHCIOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendHCIOperationCompleted);
            }
            this.InvokeAsync("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale}, this.SendHCIOperationCompleted, userState);
        }

        private void OnSendHCIOperationCompleted(object arg)
        {
            if ((this.SendHCICompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendHCICompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendValidationTokenInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SendValidationTokenInfo(string version, System.Guid trackingGuid, string callerInfoXml, string validationTokenXml, string paymentInstrumentInfoXml)
        {
            this.Invoke("SendValidationTokenInfo", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    validationTokenXml,
                    paymentInstrumentInfoXml});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSendValidationTokenInfo(string version, System.Guid trackingGuid, string callerInfoXml, string validationTokenXml, string paymentInstrumentInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SendValidationTokenInfo", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    validationTokenXml,
                    paymentInstrumentInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSendValidationTokenInfo(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void SendValidationTokenInfoAsync(string version, System.Guid trackingGuid, string callerInfoXml, string validationTokenXml, string paymentInstrumentInfoXml)
        {
            this.SendValidationTokenInfoAsync(version, trackingGuid, callerInfoXml, validationTokenXml, paymentInstrumentInfoXml, null);
        }

        /// <remarks/>
        public void SendValidationTokenInfoAsync(string version, System.Guid trackingGuid, string callerInfoXml, string validationTokenXml, string paymentInstrumentInfoXml, object userState)
        {
            if ((this.SendValidationTokenInfoOperationCompleted == null))
            {
                this.SendValidationTokenInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendValidationTokenInfoOperationCompleted);
            }
            this.InvokeAsync("SendValidationTokenInfo", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    validationTokenXml,
                    paymentInstrumentInfoXml}, this.SendValidationTokenInfoOperationCompleted, userState);
        }

        private void OnSendValidationTokenInfoOperationCompleted(object arg)
        {
            if ((this.SendValidationTokenInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendValidationTokenInfoCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SetBillingReference", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SetBillingReference(string version, System.Guid trackingGuid, string callerInfoXml, string paymentInstrumentId, string billingConfigGroup, out string billingReferenceId)
        {
            object[] results = this.Invoke("SetBillingReference", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    paymentInstrumentId,
                    billingConfigGroup});
            billingReferenceId = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetBillingReference(string version, System.Guid trackingGuid, string callerInfoXml, string paymentInstrumentId, string billingConfigGroup, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetBillingReference", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    paymentInstrumentId,
                    billingConfigGroup}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetBillingReference(System.IAsyncResult asyncResult, out string billingReferenceId)
        {
            object[] results = this.EndInvoke(asyncResult);
            billingReferenceId = ((string)(results[0]));
        }

        /// <remarks/>
        public void SetBillingReferenceAsync(string version, System.Guid trackingGuid, string callerInfoXml, string paymentInstrumentId, string billingConfigGroup)
        {
            this.SetBillingReferenceAsync(version, trackingGuid, callerInfoXml, paymentInstrumentId, billingConfigGroup, null);
        }

        /// <remarks/>
        public void SetBillingReferenceAsync(string version, System.Guid trackingGuid, string callerInfoXml, string paymentInstrumentId, string billingConfigGroup, object userState)
        {
            if ((this.SetBillingReferenceOperationCompleted == null))
            {
                this.SetBillingReferenceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetBillingReferenceOperationCompleted);
            }
            this.InvokeAsync("SetBillingReference", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    paymentInstrumentId,
                    billingConfigGroup}, this.SetBillingReferenceOperationCompleted, userState);
        }

        private void OnSetBillingReferenceOperationCompleted(object arg)
        {
            if ((this.SetBillingReferenceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetBillingReferenceCompleted(this, new SetBillingReferenceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SetPartnerConfiguration", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SetPartnerConfiguration(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigObjectXML, out string responseXML)
        {
            object[] results = this.Invoke("SetPartnerConfiguration", new object[] {
                    trackingGuid,
                    ownerID,
                    partnerConfigObjectXML});
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetPartnerConfiguration(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigObjectXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetPartnerConfiguration", new object[] {
                    trackingGuid,
                    ownerID,
                    partnerConfigObjectXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetPartnerConfiguration(System.IAsyncResult asyncResult, out string responseXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void SetPartnerConfigurationAsync(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigObjectXML)
        {
            this.SetPartnerConfigurationAsync(trackingGuid, ownerID, partnerConfigObjectXML, null);
        }

        /// <remarks/>
        public void SetPartnerConfigurationAsync(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigObjectXML, object userState)
        {
            if ((this.SetPartnerConfigurationOperationCompleted == null))
            {
                this.SetPartnerConfigurationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetPartnerConfigurationOperationCompleted);
            }
            this.InvokeAsync("SetPartnerConfiguration", new object[] {
                    trackingGuid,
                    ownerID,
                    partnerConfigObjectXML}, this.SetPartnerConfigurationOperationCompleted, userState);
        }

        private void OnSetPartnerConfigurationOperationCompleted(object arg)
        {
            if ((this.SetPartnerConfigurationCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetPartnerConfigurationCompleted(this, new SetPartnerConfigurationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void SettleBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId)
        {
            this.SettleBalanceAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, null);
        }

        /// <remarks/>
        public void SettleBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, object userState)
        {
            if ((this.SettleBalanceOperationCompleted == null))
            {
                this.SettleBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSettleBalanceOperationCompleted);
            }
            this.InvokeAsync("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, this.SettleBalanceOperationCompleted, userState);
        }

        private void OnSettleBalanceOperationCompleted(object arg)
        {
            if ((this.SettleBalanceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SettleBalanceCompleted(this, new SettleBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleOrder", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SettleOrder(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, out string orderReceiptXml)
        {
            object[] results = this.Invoke("SettleOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    correlationInfoXml,
                    orderDetailXml});
            orderReceiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSettleOrder(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SettleOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    correlationInfoXml,
                    orderDetailXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSettleOrder(System.IAsyncResult asyncResult, out string orderReceiptXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            orderReceiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void SettleOrderAsync(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml)
        {
            this.SettleOrderAsync(version, trackingGuid, callerInfoXml, objectId, correlationInfoXml, orderDetailXml, null);
        }

        /// <remarks/>
        public void SettleOrderAsync(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, object userState)
        {
            if ((this.SettleOrderOperationCompleted == null))
            {
                this.SettleOrderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSettleOrderOperationCompleted);
            }
            this.InvokeAsync("SettleOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    correlationInfoXml,
                    orderDetailXml}, this.SettleOrderOperationCompleted, userState);
        }

        private void OnSettleOrderOperationCompleted(object arg)
        {
            if ((this.SettleOrderCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SettleOrderCompleted(this, new SettleOrderCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void SignAgreementAsync(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime)
        {
            this.SignAgreementAsync(lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, null);
        }

        /// <remarks/>
        public void SignAgreementAsync(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, object userState)
        {
            if ((this.SignAgreementOperationCompleted == null))
            {
                this.SignAgreementOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSignAgreementOperationCompleted);
            }
            this.InvokeAsync("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, this.SignAgreementOperationCompleted, userState);
        }

        private void OnSignAgreementOperationCompleted(object arg)
        {
            if ((this.SignAgreementCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SignAgreementCompleted(this, new SignAgreementCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void StopPaymentsAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId)
        {
            this.StopPaymentsAsync(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentId, null);
        }

        /// <remarks/>
        public void StopPaymentsAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, object userState)
        {
            if ((this.StopPaymentsOperationCompleted == null))
            {
                this.StopPaymentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnStopPaymentsOperationCompleted);
            }
            this.InvokeAsync("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, this.StopPaymentsOperationCompleted, userState);
        }

        private void OnStopPaymentsOperationCompleted(object arg)
        {
            if ((this.StopPaymentsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.StopPaymentsCompleted(this, new StopPaymentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SubmitOrder", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SubmitOrder(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml, out string orderReceiptXml)
        {
            object[] results = this.Invoke("SubmitOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    paymentInstrumentInfoXml,
                    orderDetailXml});
            orderReceiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSubmitOrder(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SubmitOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    paymentInstrumentInfoXml,
                    orderDetailXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSubmitOrder(System.IAsyncResult asyncResult, out string orderReceiptXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            orderReceiptXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void SubmitOrderAsync(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml)
        {
            this.SubmitOrderAsync(version, trackingGuid, callerInfoXml, objectId, paymentInstrumentInfoXml, orderDetailXml, null);
        }

        /// <remarks/>
        public void SubmitOrderAsync(string version, System.Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml, object userState)
        {
            if ((this.SubmitOrderOperationCompleted == null))
            {
                this.SubmitOrderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSubmitOrderOperationCompleted);
            }
            this.InvokeAsync("SubmitOrder", new object[] {
                    version,
                    trackingGuid,
                    callerInfoXml,
                    objectId,
                    paymentInstrumentInfoXml,
                    orderDetailXml}, this.SubmitOrderOperationCompleted, userState);
        }

        private void OnSubmitOrderOperationCompleted(object arg)
        {
            if ((this.SubmitOrderCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SubmitOrderCompleted(this, new SubmitOrderCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void SwitchPaymentInstrumentsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId)
        {
            this.SwitchPaymentInstrumentsAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentId, null);
        }

        /// <remarks/>
        public void SwitchPaymentInstrumentsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, object userState)
        {
            if ((this.SwitchPaymentInstrumentsOperationCompleted == null))
            {
                this.SwitchPaymentInstrumentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSwitchPaymentInstrumentsOperationCompleted);
            }
            this.InvokeAsync("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, this.SwitchPaymentInstrumentsOperationCompleted, userState);
        }

        private void OnSwitchPaymentInstrumentsOperationCompleted(object arg)
        {
            if ((this.SwitchPaymentInstrumentsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SwitchPaymentInstrumentsCompleted(this, new SwitchPaymentInstrumentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void SyncUPSCacheForPUIDAsync(int lCustomerPUIDHigh, int lCustomerPUIDLow)
        {
            this.SyncUPSCacheForPUIDAsync(lCustomerPUIDHigh, lCustomerPUIDLow, null);
        }

        /// <remarks/>
        public void SyncUPSCacheForPUIDAsync(int lCustomerPUIDHigh, int lCustomerPUIDLow, object userState)
        {
            if ((this.SyncUPSCacheForPUIDOperationCompleted == null))
            {
                this.SyncUPSCacheForPUIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSyncUPSCacheForPUIDOperationCompleted);
            }
            this.InvokeAsync("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, this.SyncUPSCacheForPUIDOperationCompleted, userState);
        }

        private void OnSyncUPSCacheForPUIDOperationCompleted(object arg)
        {
            if ((this.SyncUPSCacheForPUIDCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SyncUPSCacheForPUIDCompleted(this, new SyncUPSCacheForPUIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void TestConnection(string bstrInputString, out string pbstrOutputString)
        {
            object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
            pbstrOutputString = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
        }

        /// <remarks/>
        public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrOutputString = ((string)(results[0]));
        }

        /// <remarks/>
        public void TestConnectionAsync(string bstrInputString)
        {
            this.TestConnectionAsync(bstrInputString, null);
        }

        /// <remarks/>
        public void TestConnectionAsync(string bstrInputString, object userState)
        {
            if ((this.TestConnectionOperationCompleted == null))
            {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                    bstrInputString}, this.TestConnectionOperationCompleted, userState);
        }

        private void OnTestConnectionOperationCompleted(object arg)
        {
            if ((this.TestConnectionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TokenRedemption", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void TokenRedemption(string apiContextXML, string detailsXML, out string responseXML)
        {
            object[] results = this.Invoke("TokenRedemption", new object[] {
                    apiContextXML,
                    detailsXML});
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginTokenRedemption(string apiContextXML, string detailsXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("TokenRedemption", new object[] {
                    apiContextXML,
                    detailsXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndTokenRedemption(System.IAsyncResult asyncResult, out string responseXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void TokenRedemptionAsync(string apiContextXML, string detailsXML)
        {
            this.TokenRedemptionAsync(apiContextXML, detailsXML, null);
        }

        /// <remarks/>
        public void TokenRedemptionAsync(string apiContextXML, string detailsXML, object userState)
        {
            if ((this.TokenRedemptionOperationCompleted == null))
            {
                this.TokenRedemptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTokenRedemptionOperationCompleted);
            }
            this.InvokeAsync("TokenRedemption", new object[] {
                    apiContextXML,
                    detailsXML}, this.TokenRedemptionOperationCompleted, userState);
        }

        private void OnTokenRedemptionOperationCompleted(object arg)
        {
            if ((this.TokenRedemptionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TokenRedemptionCompleted(this, new TokenRedemptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void TransferBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId)
        {
            this.TransferBalanceAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentId, null);
        }

        /// <remarks/>
        public void TransferBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, object userState)
        {
            if ((this.TransferBalanceOperationCompleted == null))
            {
                this.TransferBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferBalanceOperationCompleted);
            }
            this.InvokeAsync("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, this.TransferBalanceOperationCompleted, userState);
        }

        private void OnTransferBalanceOperationCompleted(object arg)
        {
            if ((this.TransferBalanceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferBalanceCompleted(this, new TransferBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void UnbanPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML)
        {
            this.UnbanPaymentInstrumentAsync(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void UnbanPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.UnbanPaymentInstrumentOperationCompleted == null))
            {
                this.UnbanPaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnbanPaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, this.UnbanPaymentInstrumentOperationCompleted, userState);
        }

        private void OnUnbanPaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.UnbanPaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnbanPaymentInstrumentCompleted(this, new UnbanPaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void UnbanUserAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML)
        {
            this.UnbanUserAsync(lDelegateIdHigh, lDelegateIdLow, bstrAccountInfoXML, null);
        }

        /// <remarks/>
        public void UnbanUserAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, object userState)
        {
            if ((this.UnbanUserOperationCompleted == null))
            {
                this.UnbanUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnbanUserOperationCompleted);
            }
            this.InvokeAsync("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, this.UnbanUserOperationCompleted, userState);
        }

        private void OnUnbanUserOperationCompleted(object arg)
        {
            if ((this.UnbanUserCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnbanUserCompleted(this, new UnbanUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnIssueTokenTrusted", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void UnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId)
        {
            this.Invoke("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUnIssueTokenTrusted(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void UnIssueTokenTrustedAsync(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId)
        {
            this.UnIssueTokenTrustedAsync(partnerName, delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, null);
        }

        /// <remarks/>
        public void UnIssueTokenTrustedAsync(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, object userState)
        {
            if ((this.UnIssueTokenTrustedOperationCompleted == null))
            {
                this.UnIssueTokenTrustedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnIssueTokenTrustedOperationCompleted);
            }
            this.InvokeAsync("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, this.UnIssueTokenTrustedOperationCompleted, userState);
        }

        private void OnUnIssueTokenTrustedOperationCompleted(object arg)
        {
            if ((this.UnIssueTokenTrustedCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnIssueTokenTrustedCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL)
        {
            object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }

        /// <remarks/>
        public void UpdateAccountInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML)
        {
            this.UpdateAccountInfoAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrAccountInfoXML, null);
        }

        /// <remarks/>
        public void UpdateAccountInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, object userState)
        {
            if ((this.UpdateAccountInfoOperationCompleted == null))
            {
                this.UpdateAccountInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateAccountInfoOperationCompleted);
            }
            this.InvokeAsync("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, this.UpdateAccountInfoOperationCompleted, userState);
        }

        private void OnUpdateAccountInfoOperationCompleted(object arg)
        {
            if ((this.UpdateAccountInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateAccountInfoCompleted(this, new UpdateAccountInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void UpdatePaymentInstrumentInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML)
        {
            this.UpdatePaymentInstrumentInfoAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void UpdatePaymentInstrumentInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.UpdatePaymentInstrumentInfoOperationCompleted == null))
            {
                this.UpdatePaymentInstrumentInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdatePaymentInstrumentInfoOperationCompleted);
            }
            this.InvokeAsync("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, this.UpdatePaymentInstrumentInfoOperationCompleted, userState);
        }

        private void OnUpdatePaymentInstrumentInfoOperationCompleted(object arg)
        {
            if ((this.UpdatePaymentInstrumentInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdatePaymentInstrumentInfoCompleted(this, new UpdatePaymentInstrumentInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void UpdateSubscriptionInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML)
        {
            this.UpdateSubscriptionInfoAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, bstrSubscriptionInfoXML, bstrReferralSetXML, null);
        }

        /// <remarks/>
        public void UpdateSubscriptionInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, object userState)
        {
            if ((this.UpdateSubscriptionInfoOperationCompleted == null))
            {
                this.UpdateSubscriptionInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateSubscriptionInfoOperationCompleted);
            }
            this.InvokeAsync("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, this.UpdateSubscriptionInfoOperationCompleted, userState);
        }

        private void OnUpdateSubscriptionInfoOperationCompleted(object arg)
        {
            if ((this.UpdateSubscriptionInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateSubscriptionInfoCompleted(this, new UpdateSubscriptionInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML)
        {
            object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void ValidateProvisioningDataAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML)
        {
            this.ValidateProvisioningDataAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceComponentId, bstrDetailsXML, null);
        }

        /// <remarks/>
        public void ValidateProvisioningDataAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, object userState)
        {
            if ((this.ValidateProvisioningDataOperationCompleted == null))
            {
                this.ValidateProvisioningDataOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateProvisioningDataOperationCompleted);
            }
            this.InvokeAsync("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, this.ValidateProvisioningDataOperationCompleted, userState);
        }

        private void OnValidateProvisioningDataOperationCompleted(object arg)
        {
            if ((this.ValidateProvisioningDataCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateProvisioningDataCompleted(this, new ValidateProvisioningDataCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber)
        {
            this.Invoke("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber});
        }

        /// <remarks/>
        public System.IAsyncResult BeginValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber}, callback, asyncState);
        }

        /// <remarks/>
        public void EndValidateToken(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ValidateTokenAsync(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber)
        {
            this.ValidateTokenAsync(delegateIdHigh, delegateIdLow, tokenClassGuid, pin, sequenceNumber, signature, partNumber, null);
        }

        /// <remarks/>
        public void ValidateTokenAsync(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber, object userState)
        {
            if ((this.ValidateTokenOperationCompleted == null))
            {
                this.ValidateTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateTokenOperationCompleted);
            }
            this.InvokeAsync("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber}, this.ValidateTokenOperationCompleted, userState);
        }

        private void OnValidateTokenOperationCompleted(object arg)
        {
            if ((this.ValidateTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateTokenCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus)
        {
            this.Invoke("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus});
        }

        /// <remarks/>
        public System.IAsyncResult BeginActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, callback, asyncState);
        }

        /// <remarks/>
        public void EndActivateToken(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ActivateTokenAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus)
        {
            this.ActivateTokenAsync(delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, timeStamp, committedStatus, null);
        }

        /// <remarks/>
        public void ActivateTokenAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, object userState)
        {
            if ((this.ActivateTokenOperationCompleted == null))
            {
                this.ActivateTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnActivateTokenOperationCompleted);
            }
            this.InvokeAsync("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, this.ActivateTokenOperationCompleted, userState);
        }

        private void OnActivateTokenOperationCompleted(object arg)
        {
            if ((this.ActivateTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ActivateTokenCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateTokenEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ActivateTokenEx(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML)
        {
            this.Invoke("ActivateTokenEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus,
                    tokenInfoXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginActivateTokenEx(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ActivateTokenEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus,
                    tokenInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndActivateTokenEx(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ActivateTokenExAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML)
        {
            this.ActivateTokenExAsync(delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, timeStamp, committedStatus, tokenInfoXML, null);
        }

        /// <remarks/>
        public void ActivateTokenExAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML, object userState)
        {
            if ((this.ActivateTokenExOperationCompleted == null))
            {
                this.ActivateTokenExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnActivateTokenExOperationCompleted);
            }
            this.InvokeAsync("ActivateTokenEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus,
                    tokenInfoXML}, this.ActivateTokenExOperationCompleted, userState);
        }

        private void OnActivateTokenExOperationCompleted(object arg)
        {
            if ((this.ActivateTokenExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ActivateTokenExCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void AddCommentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML)
        {
            this.AddCommentAsync(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void AddCommentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, object userState)
        {
            if ((this.AddCommentOperationCompleted == null))
            {
                this.AddCommentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCommentOperationCompleted);
            }
            this.InvokeAsync("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, this.AddCommentOperationCompleted, userState);
        }

        private void OnAddCommentOperationCompleted(object arg)
        {
            if ((this.AddCommentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCommentCompleted(this, new AddCommentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL)
        {
            object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }

        /// <remarks/>
        public void AddPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML)
        {
            this.AddPaymentInstrumentAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrAccountId, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void AddPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.AddPaymentInstrumentOperationCompleted == null))
            {
                this.AddPaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddPaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, this.AddPaymentInstrumentOperationCompleted, userState);
        }

        private void OnAddPaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.AddPaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddPaymentInstrumentCompleted(this, new AddPaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void AddRoleAssignmentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML)
        {
            this.AddRoleAssignmentAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrRoleAssignmentXML, null);
        }

        /// <remarks/>
        public void AddRoleAssignmentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, object userState)
        {
            if ((this.AddRoleAssignmentOperationCompleted == null))
            {
                this.AddRoleAssignmentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddRoleAssignmentOperationCompleted);
            }
            this.InvokeAsync("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, this.AddRoleAssignmentOperationCompleted, userState);
        }

        private void OnAddRoleAssignmentOperationCompleted(object arg)
        {
            if ((this.AddRoleAssignmentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddRoleAssignmentCompleted(this, new AddRoleAssignmentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void AddViolationAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML)
        {
            this.AddViolationAsync(lDelegateIdHigh, lDelegateIdLow, bstrObjectId, lViolationId, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void AddViolationAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, object userState)
        {
            if ((this.AddViolationOperationCompleted == null))
            {
                this.AddViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddViolationOperationCompleted);
            }
            this.InvokeAsync("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, this.AddViolationOperationCompleted, userState);
        }

        private void OnAddViolationOperationCompleted(object arg)
        {
            if ((this.AddViolationCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddViolationCompleted(this, new AddViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void AdjustGotoBAMDateAsync(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId)
        {
            this.AdjustGotoBAMDateAsync(lRequesterIdHigh, lRequesterIdLow, lOffset, bstrObjectId, null);
        }

        /// <remarks/>
        public void AdjustGotoBAMDateAsync(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, object userState)
        {
            if ((this.AdjustGotoBAMDateOperationCompleted == null))
            {
                this.AdjustGotoBAMDateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdjustGotoBAMDateOperationCompleted);
            }
            this.InvokeAsync("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId}, this.AdjustGotoBAMDateOperationCompleted, userState);
        }

        private void OnAdjustGotoBAMDateOperationCompleted(object arg)
        {
            if ((this.AdjustGotoBAMDateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdjustGotoBAMDateCompleted(this, new AdjustGotoBAMDateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError)
        {
            object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public void AdjustResourceBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML)
        {
            this.AdjustResourceBalanceAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrObjectId, bstrResourceGUID, lNumberOfUnits, bstrUnitsOfMeasure, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void AdjustResourceBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, object userState)
        {
            if ((this.AdjustResourceBalanceOperationCompleted == null))
            {
                this.AdjustResourceBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdjustResourceBalanceOperationCompleted);
            }
            this.InvokeAsync("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, this.AdjustResourceBalanceOperationCompleted, userState);
        }

        private void OnAdjustResourceBalanceOperationCompleted(object arg)
        {
            if ((this.AdjustResourceBalanceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdjustResourceBalanceCompleted(this, new AdjustResourceBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void AdjustSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML)
        {
            this.AdjustSubscriptionAsync(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, lBillingPeriodId, bstrAdjustmentGUID, bstrAmount, bstrCommentTextXML, null);
        }

        /// <remarks/>
        public void AdjustSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, object userState)
        {
            if ((this.AdjustSubscriptionOperationCompleted == null))
            {
                this.AdjustSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdjustSubscriptionOperationCompleted);
            }
            this.InvokeAsync("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, this.AdjustSubscriptionOperationCompleted, userState);
        }

        private void OnAdjustSubscriptionOperationCompleted(object arg)
        {
            if ((this.AdjustSubscriptionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdjustSubscriptionCompleted(this, new AdjustSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void BanPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML)
        {
            this.BanPaymentInstrumentAsync(lDelegateIdHigh, lDelegateIdLow, lReasonCode, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void BanPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.BanPaymentInstrumentOperationCompleted == null))
            {
                this.BanPaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBanPaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, this.BanPaymentInstrumentOperationCompleted, userState);
        }

        private void OnBanPaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.BanPaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BanPaymentInstrumentCompleted(this, new BanPaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void BanUserAsync(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML)
        {
            this.BanUserAsync(lDelegateIdHigh, lDelegateIdLow, lReasonCode, bstrAccountInfoXML, null);
        }

        /// <remarks/>
        public void BanUserAsync(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, object userState)
        {
            if ((this.BanUserOperationCompleted == null))
            {
                this.BanUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBanUserOperationCompleted);
            }
            this.InvokeAsync("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, this.BanUserOperationCompleted, userState);
        }

        private void OnBanUserOperationCompleted(object arg)
        {
            if ((this.BanUserCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BanUserCompleted(this, new BanUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount)
        {
            object[] results = this.Invoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription});
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }

        /// <remarks/>
        public void BlacklistTokenAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription)
        {
            this.BlacklistTokenAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrToken, lTokenType, bstrEffectiveTime, bstrSubscriptionAction, bstrReason, bstrDescription, null);
        }

        /// <remarks/>
        public void BlacklistTokenAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, object userState)
        {

            if ((this.BlacklistTokenOperationCompleted == null))
            {
                this.BlacklistTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBlacklistTokenOperationCompleted);
            }
            this.InvokeAsync("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription}, this.BlacklistTokenOperationCompleted, userState);
        }

        private void OnBlacklistTokenOperationCompleted(object arg)
        {
            if ((this.BlacklistTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BlacklistTokenCompleted(this, new BlacklistTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CalculateTax", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CalculateTax(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml, out string returnOrderDetailXml)
        {
            object[] results = this.Invoke("CalculateTax", new object[] {
                    version,
                    callerInfoXml,
                    accountId,
                    taxCalculationInfoXml,
                    orderDetailXml});
            returnOrderDetailXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCalculateTax(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CalculateTax", new object[] {
                    version,
                    callerInfoXml,
                    accountId,
                    taxCalculationInfoXml,
                    orderDetailXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCalculateTax(System.IAsyncResult asyncResult, out string returnOrderDetailXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            returnOrderDetailXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void CalculateTaxAsync(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml)
        {
            this.CalculateTaxAsync(version, callerInfoXml, accountId, taxCalculationInfoXml, orderDetailXml, null);
        }

        /// <remarks/>
        public void CalculateTaxAsync(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml, object userState)
        {
            if ((this.CalculateTaxOperationCompleted == null))
            {
                this.CalculateTaxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCalculateTaxOperationCompleted);
            }
            this.InvokeAsync("CalculateTax", new object[] {
                    version,
                    callerInfoXml,
                    accountId,
                    taxCalculationInfoXml,
                    orderDetailXml}, this.CalculateTaxOperationCompleted, userState);
        }

        private void OnCalculateTaxOperationCompleted(object arg)
        {
            if ((this.CalculateTaxCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CalculateTaxCompleted(this, new CalculateTaxCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }

        /// <remarks/>
        public void CancelConversionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId)
        {
            this.CancelConversionAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, null);
        }

        /// <remarks/>
        public void CancelConversionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, object userState)
        {
            if ((this.CancelConversionOperationCompleted == null))
            {
                this.CancelConversionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelConversionOperationCompleted);
            }
            this.InvokeAsync("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, this.CancelConversionOperationCompleted, userState);
        }

        private void OnCancelConversionOperationCompleted(object arg)
        {
            if ((this.CancelConversionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelConversionCompleted(this, new CancelConversionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelPayment", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CancelPayment(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml)
        {
            this.Invoke("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelPayment(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCancelPayment(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void CancelPaymentAsync(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml)
        {
            this.CancelPaymentAsync(delegateIdHigh, delegateIdLow, targetIdHigh, targetIdLow, trackingGuid, confirmationId, commentInfoXml, null);
        }

        /// <remarks/>
        public void CancelPaymentAsync(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml, object userState)
        {
            if ((this.CancelPaymentOperationCompleted == null))
            {
                this.CancelPaymentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelPaymentOperationCompleted);
            }
            this.InvokeAsync("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml}, this.CancelPaymentOperationCompleted, userState);
        }

        private void OnCancelPaymentOperationCompleted(object arg)
        {
            if ((this.CancelPaymentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelPaymentCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelRenewal", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId)
        {
            this.Invoke("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCancelRenewal(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void CancelRenewalAsync(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId)
        {
            this.CancelRenewalAsync(delegatePUIDHigh, delegatePUIDLow, requesterPUIDHigh, requesterPUIDLow, trackingGUID, subscriptionId, null);
        }

        /// <remarks/>
        public void CancelRenewalAsync(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId, object userState)
        {
            if ((this.CancelRenewalOperationCompleted == null))
            {
                this.CancelRenewalOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelRenewalOperationCompleted);
            }
            this.InvokeAsync("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId}, this.CancelRenewalOperationCompleted, userState);
        }

        private void OnCancelRenewalOperationCompleted(object arg)
        {
            if ((this.CancelRenewalCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelRenewalCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML)
        {
            object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public void CancelSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML)
        {
            this.CancelSubscriptionAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionId, bstrCancelDate, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void CancelSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, object userState)
        {
            if ((this.CancelSubscriptionOperationCompleted == null))
            {
                this.CancelSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelSubscriptionOperationCompleted);
            }
            this.InvokeAsync("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, this.CancelSubscriptionOperationCompleted, userState);
        }

        private void OnCancelSubscriptionOperationCompleted(object arg)
        {
            if ((this.CancelSubscriptionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelSubscriptionCompleted(this, new CancelSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscriptionEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML)
        {
            object[] results = this.Invoke("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance});
            amountChargedXML = ((string)(results[0]));
            subscriptionStatusInfoXML = ((string)(results[1]));
            removedServiceInstanceCount = ((int)(results[2]));
            removedServiceInstanceSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCancelSubscriptionEx(System.IAsyncResult asyncResult, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            amountChargedXML = ((string)(results[0]));
            subscriptionStatusInfoXML = ((string)(results[1]));
            removedServiceInstanceCount = ((int)(results[2]));
            removedServiceInstanceSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public void CancelSubscriptionExAsync(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance)
        {
            this.CancelSubscriptionExAsync(delegatePUIDHigh, delegatePUIDLow, requesterPUIDHigh, requesterPUIDLow, trackingGUID, computeOnly, subscriptionId, cancelDate, commentInfoXML, closeBalance, null);
        }

        /// <remarks/>
        public void CancelSubscriptionExAsync(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, object userState)
        {
            if ((this.CancelSubscriptionExOperationCompleted == null))
            {
                this.CancelSubscriptionExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelSubscriptionExOperationCompleted);
            }
            this.InvokeAsync("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance}, this.CancelSubscriptionExOperationCompleted, userState);
        }

        private void OnCancelSubscriptionExOperationCompleted(object arg)
        {
            if ((this.CancelSubscriptionExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelSubscriptionExCompleted(this, new CancelSubscriptionExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelTransaction", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId)
        {
            this.Invoke("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCancelTransaction(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void CancelTransactionAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId)
        {
            this.CancelTransactionAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, trackingGuid, transactionId, null);
        }

        /// <remarks/>
        public void CancelTransactionAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId, object userState)
        {
            if ((this.CancelTransactionOperationCompleted == null))
            {
                this.CancelTransactionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelTransactionOperationCompleted);
            }
            this.InvokeAsync("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId}, this.CancelTransactionOperationCompleted, userState);
        }

        private void OnCancelTransactionOperationCompleted(object arg)
        {
            if ((this.CancelTransactionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelTransactionCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ChargePaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, out string paymentInstrumentResultsXml)
        {
            object[] results = this.Invoke("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml});
            paymentInstrumentResultsXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndChargePaymentInstrument(System.IAsyncResult asyncResult, out string paymentInstrumentResultsXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            paymentInstrumentResultsXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void ChargePaymentInstrumentAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml)
        {
            this.ChargePaymentInstrumentAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, trackingGuid, paymentInstrumentId, chargeInfoXml, null);
        }

        /// <remarks/>
        public void ChargePaymentInstrumentAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, object userState)
        {
            if ((this.ChargePaymentInstrumentOperationCompleted == null))
            {
                this.ChargePaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnChargePaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml}, this.ChargePaymentInstrumentOperationCompleted, userState);
        }

        private void OnChargePaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.ChargePaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ChargePaymentInstrumentCompleted(this, new ChargePaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckCDAvailability", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, out string partnerName)
        {
            object[] results = this.Invoke("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob});
            partnerName = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCheckCDAvailability(System.IAsyncResult asyncResult, out string partnerName)
        {
            object[] results = this.EndInvoke(asyncResult);
            partnerName = ((string)(results[0]));
        }

        /// <remarks/>
        public void CheckCDAvailabilityAsync(string accountIDBlob, string subscriptionRefIDBlob)
        {
            this.CheckCDAvailabilityAsync(accountIDBlob, subscriptionRefIDBlob, null);
        }

        /// <remarks/>
        public void CheckCDAvailabilityAsync(string accountIDBlob, string subscriptionRefIDBlob, object userState)
        {
            if ((this.CheckCDAvailabilityOperationCompleted == null))
            {
                this.CheckCDAvailabilityOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCheckCDAvailabilityOperationCompleted);
            }
            this.InvokeAsync("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob}, this.CheckCDAvailabilityOperationCompleted, userState);
        }

        private void OnCheckCDAvailabilityOperationCompleted(object arg)
        {
            if ((this.CheckCDAvailabilityCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CheckCDAvailabilityCompleted(this, new CheckCDAvailabilityCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML)
        {
            object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void CheckProvisioningStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId)
        {
            this.CheckProvisioningStatusAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceComponentId, null);
        }

        /// <remarks/>
        public void CheckProvisioningStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, object userState)
        {
            if ((this.CheckProvisioningStatusOperationCompleted == null))
            {
                this.CheckProvisioningStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCheckProvisioningStatusOperationCompleted);
            }
            this.InvokeAsync("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, this.CheckProvisioningStatusOperationCompleted, userState);
        }

        private void OnCheckProvisioningStatusOperationCompleted(object arg)
        {
            if ((this.CheckProvisioningStatusCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CheckProvisioningStatusCompleted(this, new CheckProvisioningStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void CloseAccountAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML)
        {
            this.CloseAccountAsync(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void CloseAccountAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, object userState)
        {
            if ((this.CloseAccountOperationCompleted == null))
            {
                this.CloseAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCloseAccountOperationCompleted);
            }
            this.InvokeAsync("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, this.CloseAccountOperationCompleted, userState);
        }

        private void OnCloseAccountOperationCompleted(object arg)
        {
            if ((this.CloseAccountCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CloseAccountCompleted(this, new CloseAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void CloseBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId)
        {
            this.CloseBalanceAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrObjectId, bstrLineItemId, null);
        }

        /// <remarks/>
        public void CloseBalanceAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, object userState)
        {
            if ((this.CloseBalanceOperationCompleted == null))
            {
                this.CloseBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCloseBalanceOperationCompleted);
            }
            this.InvokeAsync("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, this.CloseBalanceOperationCompleted, userState);
        }

        private void OnCloseBalanceOperationCompleted(object arg)
        {
            if ((this.CloseBalanceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CloseBalanceCompleted(this, new CloseBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }

        /// <remarks/>
        public void CompleteConversionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId)
        {
            this.CompleteConversionAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, null);
        }

        /// <remarks/>
        public void CompleteConversionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, object userState)
        {
            if ((this.CompleteConversionOperationCompleted == null))
            {
                this.CompleteConversionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompleteConversionOperationCompleted);
            }
            this.InvokeAsync("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, this.CompleteConversionOperationCompleted, userState);
        }

        private void OnCompleteConversionOperationCompleted(object arg)
        {
            if ((this.CompleteConversionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompleteConversionCompleted(this, new CompleteConversionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConsumeToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, out string consumedTokenDetailsXML)
        {
            object[] results = this.Invoke("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID});
            consumedTokenDetailsXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConsumeToken(System.IAsyncResult asyncResult, out string consumedTokenDetailsXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            consumedTokenDetailsXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void ConsumeTokenAsync(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID)
        {
            this.ConsumeTokenAsync(delegateIdHigh, delegateIdLow, lRequesterIdHigh, lRequesterIdLow, trackingGuid, computeOnly, tokenID, null);
        }

        /// <remarks/>
        public void ConsumeTokenAsync(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, object userState)
        {
            if ((this.ConsumeTokenOperationCompleted == null))
            {
                this.ConsumeTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsumeTokenOperationCompleted);
            }
            this.InvokeAsync("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID}, this.ConsumeTokenOperationCompleted, userState);
        }

        private void OnConsumeTokenOperationCompleted(object arg)
        {
            if ((this.ConsumeTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConsumeTokenCompleted(this, new ConsumeTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ConvertSubscription(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    out string pbstrErrorXML,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceSetCount,
                    out string pbstrAddedServiceInstanceSet,
                    out int plRemovedServiceInstanceSetCount,
                    out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscription(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }

        /// <remarks/>
        public void ConvertSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, int lConvertMode, int lOverrideFlags, string bstrSubscriptionName, string bstrSubscriptionId, string bstrOfferingGUID, int lOverrideAmount, string bstrSubscriptionEndDate, string bstrReferralSetXML)
        {
            this.ConvertSubscriptionAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, lConvertMode, lOverrideFlags, bstrSubscriptionName, bstrSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrSubscriptionEndDate, bstrReferralSetXML, null);
        }

        /// <remarks/>
        public void ConvertSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, int lConvertMode, int lOverrideFlags, string bstrSubscriptionName, string bstrSubscriptionId, string bstrOfferingGUID, int lOverrideAmount, string bstrSubscriptionEndDate, string bstrReferralSetXML, object userState)
        {
            if ((this.ConvertSubscriptionOperationCompleted == null))
            {
                this.ConvertSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConvertSubscriptionOperationCompleted);
            }
            this.InvokeAsync("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, this.ConvertSubscriptionOperationCompleted, userState);
        }

        private void OnConvertSubscriptionOperationCompleted(object arg)
        {
            if ((this.ConvertSubscriptionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConvertSubscriptionCompleted(this, new ConvertSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ConvertSubscriptionEx(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    out string pbstrErrorXML,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceSetCount,
                    out string pbstrAddedServiceInstanceSet,
                    out int plRemovedServiceInstanceSetCount,
                    out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }

        /// <remarks/>
        public void ConvertSubscriptionExAsync(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime)
        {
            this.ConvertSubscriptionExAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, lConvertMode, lOverrideFlags, bstrSubscriptionName, bstrSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrSubscriptionEndDate, bstrReferralSetXML, bstrPaymentInstrumentId, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, null);
        }

        /// <remarks/>
        public void ConvertSubscriptionExAsync(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    object userState)
        {
            if ((this.ConvertSubscriptionExOperationCompleted == null))
            {
                this.ConvertSubscriptionExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConvertSubscriptionExOperationCompleted);
            }
            this.InvokeAsync("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, this.ConvertSubscriptionExOperationCompleted, userState);
        }

        private void OnConvertSubscriptionExOperationCompleted(object arg)
        {
            if ((this.ConvertSubscriptionExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConvertSubscriptionExCompleted(this, new ConvertSubscriptionExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx2", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ConvertSubscriptionEx2(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    out string pbstrErrorXML,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceSetCount,
                    out string pbstrAddedServiceInstanceSet,
                    out int plRemovedServiceInstanceSetCount,
                    out string pbstrRemoveServiceInstanceSet,
                    out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.Invoke("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
            pbstrRedirectOutputInfoXML = ((string)(results[6]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx2(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConvertSubscriptionEx2(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet, out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
            pbstrRedirectOutputInfoXML = ((string)(results[6]));
        }

        /// <remarks/>
        public void ConvertSubscriptionEx2Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML)
        {
            this.ConvertSubscriptionEx2Async(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, lConvertMode, lOverrideFlags, bstrSubscriptionName, bstrSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrSubscriptionEndDate, bstrReferralSetXML, bstrPaymentInstrumentId, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, bstrRedirectInputInfoXML, null);
        }

        /// <remarks/>
        public void ConvertSubscriptionEx2Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    object userState)
        {
            if ((this.ConvertSubscriptionEx2OperationCompleted == null))
            {
                this.ConvertSubscriptionEx2OperationCompleted = new System.Threading.SendOrPostCallback(this.OnConvertSubscriptionEx2OperationCompleted);
            }
            this.InvokeAsync("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, this.ConvertSubscriptionEx2OperationCompleted, userState);
        }

        private void OnConvertSubscriptionEx2OperationCompleted(object arg)
        {
            if ((this.ConvertSubscriptionEx2Completed != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConvertSubscriptionEx2Completed(this, new ConvertSubscriptionEx2CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx3", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ConvertSubscriptionEx3(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML,
                    out string pbstrErrorXML,
                    out string pbstrAmountChargedXML,
                    out int plAddedServiceInstanceSetCount,
                    out string pbstrAddedServiceInstanceSet,
                    out int plRemovedServiceInstanceSetCount,
                    out string pbstrRemoveServiceInstanceSet,
                    out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.Invoke("ConvertSubscriptionEx3", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML,
                    bstrDiscountGuid,
                    bstrExtraInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
            pbstrRedirectOutputInfoXML = ((string)(results[6]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx3(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML,
                    System.AsyncCallback callback,
                    object asyncState)
        {
            return this.BeginInvoke("ConvertSubscriptionEx3", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML,
                    bstrDiscountGuid,
                    bstrExtraInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConvertSubscriptionEx3(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet, out string pbstrRedirectOutputInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
            pbstrRedirectOutputInfoXML = ((string)(results[6]));
        }

        /// <remarks/>
        public void ConvertSubscriptionEx3Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML)
        {
            this.ConvertSubscriptionEx3Async(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, lConvertMode, lOverrideFlags, bstrSubscriptionName, bstrSubscriptionId, bstrOfferingGUID, lOverrideAmount, bstrSubscriptionEndDate, bstrReferralSetXML, bstrPaymentInstrumentId, bstrTokenId, bstrPolicyGUID, lPolicyVersion, bstrSignatureDateTime, bstrRedirectInputInfoXML, bstrDiscountGuid, bstrExtraInfoXML, null);
        }

        /// <remarks/>
        public void ConvertSubscriptionEx3Async(
                    int lDelegateIdHigh,
                    int lDelegateIdLow,
                    int lRequesterIdHigh,
                    int lRequesterIdLow,
                    string bstrTrackingGUID,
                    bool fComputeOnly,
                    int lConvertMode,
                    int lOverrideFlags,
                    string bstrSubscriptionName,
                    string bstrSubscriptionId,
                    string bstrOfferingGUID,
                    int lOverrideAmount,
                    string bstrSubscriptionEndDate,
                    string bstrReferralSetXML,
                    string bstrPaymentInstrumentId,
                    string bstrTokenId,
                    string bstrPolicyGUID,
                    int lPolicyVersion,
                    string bstrSignatureDateTime,
                    string bstrRedirectInputInfoXML,
                    string bstrDiscountGuid,
                    string bstrExtraInfoXML,
                    object userState)
        {
            if ((this.ConvertSubscriptionEx3OperationCompleted == null))
            {
                this.ConvertSubscriptionEx3OperationCompleted = new System.Threading.SendOrPostCallback(this.OnConvertSubscriptionEx3OperationCompleted);
            }
            this.InvokeAsync("ConvertSubscriptionEx3", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML,
                    bstrDiscountGuid,
                    bstrExtraInfoXML}, this.ConvertSubscriptionEx3OperationCompleted, userState);
        }

        private void OnConvertSubscriptionEx3OperationCompleted(object arg)
        {
            if ((this.ConvertSubscriptionEx3Completed != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConvertSubscriptionEx3Completed(this, new ConvertSubscriptionEx3CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("BdkSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL)
        {
            object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }

        /// <remarks/>
        public void CreateAccountAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML)
        {
            this.CreateAccountAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPPMemberName, bstrTrackingGUID, bstrAccountInfoXML, bstrPaymentInstrumentXML, null);
        }

        /// <remarks/>
        public void CreateAccountAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, object userState)
        {
            if ((this.CreateAccountOperationCompleted == null))
            {
                this.CreateAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateAccountOperationCompleted);
            }
            this.InvokeAsync("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, this.CreateAccountOperationCompleted, userState);
        }

        private void OnCreateAccountOperationCompleted(object arg)
        {
            if ((this.CreateAccountCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateAccountCompleted(this, new CreateAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError)
        {
            object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public void CreditPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML)
        {
            this.CreditPaymentInstrumentAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, lFinancialReportingCode, bstrAmount, fImmediatelySettle, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void CreditPaymentInstrumentAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, object userState)
        {
            if ((this.CreditPaymentInstrumentOperationCompleted == null))
            {
                this.CreditPaymentInstrumentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreditPaymentInstrumentOperationCompleted);
            }
            this.InvokeAsync("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, this.CreditPaymentInstrumentOperationCompleted, userState);
        }

        private void OnCreditPaymentInstrumentOperationCompleted(object arg)
        {
            if ((this.CreditPaymentInstrumentCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreditPaymentInstrumentCompleted(this, new CreditPaymentInstrumentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError)
        {
            object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }

        /// <remarks/>
        public void CreditPaymentInstrumentExAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML)
        {
            this.CreditPaymentInstrumentExAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, bstrSubscriptionId, lFinancialReportingCode, bstrAmount, fImmediatelySettle, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void CreditPaymentInstrumentExAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, object userState)
        {
            if ((this.CreditPaymentInstrumentExOperationCompleted == null))
            {
                this.CreditPaymentInstrumentExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreditPaymentInstrumentExOperationCompleted);
            }
            this.InvokeAsync("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, this.CreditPaymentInstrumentExOperationCompleted, userState);
        }

        private void OnCreditPaymentInstrumentExOperationCompleted(object arg)
        {
            if ((this.CreditPaymentInstrumentExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreditPaymentInstrumentExCompleted(this, new CreditPaymentInstrumentExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SetUserProfile", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void SetUserProfile(string version, string callerInfoXml, string userProfileXml)
        {
            this.Invoke("SetUserProfile", new object[] {
                    version,
                    callerInfoXml,
                    userProfileXml});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetUserProfile(string version, string callerInfoXml, string userProfileXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetUserProfile", new object[] {
                    version,
                    callerInfoXml,
                    userProfileXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetUserProfile(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void SetUserProfileAsync(string version, string callerInfoXml, string userProfileXml)
        {
            this.SetUserProfileAsync(version, callerInfoXml, userProfileXml, null);
        }

        /// <remarks/>
        public void SetUserProfileAsync(string version, string callerInfoXml, string userProfileXml, object userState)
        {
            if ((this.SetUserProfileOperationCompleted == null))
            {
                this.SetUserProfileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserProfileOperationCompleted);
            }
            this.InvokeAsync("SetUserProfile", new object[] {
                    version,
                    callerInfoXml,
                    userProfileXml}, this.SetUserProfileOperationCompleted, userState);
        }

        private void OnSetUserProfileOperationCompleted(object arg)
        {
            if ((this.SetUserProfileCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserProfileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeactivateToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void DeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus)
        {
            this.Invoke("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeactivateToken(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void DeactivateTokenAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus)
        {
            this.DeactivateTokenAsync(delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, timeStamp, committedStatus, null);
        }

        /// <remarks/>
        public void DeactivateTokenAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, object userState)
        {
            if ((this.DeactivateTokenOperationCompleted == null))
            {
                this.DeactivateTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeactivateTokenOperationCompleted);
            }
            this.InvokeAsync("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, this.DeactivateTokenOperationCompleted, userState);
        }

        private void OnDeactivateTokenOperationCompleted(object arg)
        {
            if ((this.DeactivateTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeactivateTokenCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeactivateTokenEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void DeactivateTokenEx(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML)
        {
            this.Invoke("DeactivateTokenEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus,
                    tokenInfoXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeactivateTokenEx(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeactivateTokenEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus,
                    tokenInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeactivateTokenEx(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void DeactivateTokenExAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML)
        {
            this.DeactivateTokenExAsync(delegateIdHigh, delegateIdLow, trackingGuid, token, tokenType, externalReferenceId, timeStamp, committedStatus, tokenInfoXML, null);
        }

        /// <remarks/>
        public void DeactivateTokenExAsync(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, string tokenInfoXML, object userState)
        {
            if ((this.DeactivateTokenExOperationCompleted == null))
            {
                this.DeactivateTokenExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeactivateTokenExOperationCompleted);
            }
            this.InvokeAsync("DeactivateTokenEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus,
                    tokenInfoXML}, this.DeactivateTokenExOperationCompleted, userState);
        }

        private void OnDeactivateTokenExOperationCompleted(object arg)
        {
            if ((this.DeactivateTokenExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeactivateTokenExCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeliverToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void DeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML)
        {
            object[] results = this.Invoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey});
            pbstrErrorXML = ((string)(results[0]));
            pbstrEncryptedTokenSetXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeliverToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrEncryptedTokenSetXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void DeliverTokenAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey)
        {
            this.DeliverTokenAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrFilterInfoXML, bstrSessionKey, null);
        }

        /// <remarks/>
        public void DeliverTokenAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, object userState)
        {
            if ((this.DeliverTokenOperationCompleted == null))
            {
                this.DeliverTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeliverTokenOperationCompleted);
            }
            this.InvokeAsync("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey}, this.DeliverTokenOperationCompleted, userState);
        }

        private void OnDeliverTokenOperationCompleted(object arg)
        {
            if ((this.DeliverTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeliverTokenCompleted(this, new DeliverTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void DeprovisionServicesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML)
        {
            this.DeprovisionServicesAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceInstanceSetXML, null);
        }

        /// <remarks/>
        public void DeprovisionServicesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, object userState)
        {
            if ((this.DeprovisionServicesOperationCompleted == null))
            {
                this.DeprovisionServicesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeprovisionServicesOperationCompleted);
            }
            this.InvokeAsync("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, this.DeprovisionServicesOperationCompleted, userState);
        }

        private void OnDeprovisionServicesOperationCompleted(object arg)
        {
            if ((this.DeprovisionServicesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeprovisionServicesCompleted(this, new DeprovisionServicesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate)
        {
            object[] results = this.Invoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }

        /// <remarks/>
        public void ExtendSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML)
        {
            this.ExtendSubscriptionAsync(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrSubscriptionId, lNumberOfDays, bstrCommentInfoXML, null);
        }

        /// <remarks/>
        public void ExtendSubscriptionAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, object userState)
        {
            if ((this.ExtendSubscriptionOperationCompleted == null))
            {
                this.ExtendSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExtendSubscriptionOperationCompleted);
            }
            this.InvokeAsync("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML}, this.ExtendSubscriptionOperationCompleted, userState);
        }

        private void OnExtendSubscriptionOperationCompleted(object arg)
        {
            if ((this.ExtendSubscriptionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExtendSubscriptionCompleted(this, new ExtendSubscriptionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.FixExistingAddress", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void FixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, double confidenceScoreThreshold, bool readOnlyMode, out bool result, out double confidenceScore, out int tryNumber)
        {
            object[] results = this.Invoke("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode});
            result = ((bool)(results[0]));
            confidenceScore = ((double)(results[1]));
            tryNumber = ((int)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginFixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, double confidenceScoreThreshold, bool readOnlyMode, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode}, callback, asyncState);
        }

        /// <remarks/>
        public void EndFixExistingAddress(System.IAsyncResult asyncResult, out bool result, out double confidenceScore, out int tryNumber)
        {
            object[] results = this.EndInvoke(asyncResult);
            result = ((bool)(results[0]));
            confidenceScore = ((double)(results[1]));
            tryNumber = ((int)(results[2]));
        }

        /// <remarks/>
        public void FixExistingAddressAsync(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, double confidenceScoreThreshold, bool readOnlyMode)
        {
            this.FixExistingAddressAsync(acctId, subRefID, addId, mappingCombination, maxReturnRange, confidenceScoreThreshold, readOnlyMode, null);
        }

        /// <remarks/>
        public void FixExistingAddressAsync(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, double confidenceScoreThreshold, bool readOnlyMode, object userState)
        {
            if ((this.FixExistingAddressOperationCompleted == null))
            {
                this.FixExistingAddressOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFixExistingAddressOperationCompleted);
            }
            this.InvokeAsync("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode}, this.FixExistingAddressOperationCompleted, userState);
        }

        private void OnFixExistingAddressOperationCompleted(object arg)
        {
            if ((this.FixExistingAddressCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FixExistingAddressCompleted(this, new FixExistingAddressCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public void GetAccountIdFromAdminPUIDAsync(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax)
        {
            this.GetAccountIdFromAdminPUIDAsync(lDelegateIdHigh, lDelegateIdLow, lSearchPUIDHigh, lSearchPUIDLow, fFullData, lMax, null);
        }

        /// <remarks/>
        public void GetAccountIdFromAdminPUIDAsync(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, object userState)
        {
            if ((this.GetAccountIdFromAdminPUIDOperationCompleted == null))
            {
                this.GetAccountIdFromAdminPUIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountIdFromAdminPUIDOperationCompleted);
            }
            this.InvokeAsync("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, this.GetAccountIdFromAdminPUIDOperationCompleted, userState);
        }

        private void OnGetAccountIdFromAdminPUIDOperationCompleted(object arg)
        {
            if ((this.GetAccountIdFromAdminPUIDCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountIdFromAdminPUIDCompleted(this, new GetAccountIdFromAdminPUIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }

        /// <remarks/>
        public void GetAccountIdFromPaymentInstrumentInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML)
        {
            this.GetAccountIdFromPaymentInstrumentInfoAsync(lDelegateIdHigh, lDelegateIdLow, fFullData, lMax, bstrPaymentInstrumentInfoXML, null);
        }

        /// <remarks/>
        public void GetAccountIdFromPaymentInstrumentInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, object userState)
        {
            if ((this.GetAccountIdFromPaymentInstrumentInfoOperationCompleted == null))
            {
                this.GetAccountIdFromPaymentInstrumentInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountIdFromPaymentInstrumentInfoOperationCompleted);
            }
            this.InvokeAsync("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, this.GetAccountIdFromPaymentInstrumentInfoOperationCompleted, userState);
        }

        private void OnGetAccountIdFromPaymentInstrumentInfoOperationCompleted(object arg)
        {
            if ((this.GetAccountIdFromPaymentInstrumentInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountIdFromPaymentInstrumentInfoCompleted(this, new GetAccountIdFromPaymentInstrumentInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPuid", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml)
        {
            object[] results = this.Invoke("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max});
            errorXml = ((string)(results[0]));
            moreRows = ((int)(results[1]));
            accountInfoCount = ((int)(results[2]));
            accountInfoSetXml = ((string)(results[3]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountIdFromPuid(System.IAsyncResult asyncResult, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            moreRows = ((int)(results[1]));
            accountInfoCount = ((int)(results[2]));
            accountInfoSetXml = ((string)(results[3]));
        }

        /// <remarks/>
        public void GetAccountIdFromPuidAsync(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max)
        {
            this.GetAccountIdFromPuidAsync(delegateIdHigh, delegateIdLow, searchPuidHigh, searchPuidLow, roleSetXml, fullData, max, null);
        }

        /// <remarks/>
        public void GetAccountIdFromPuidAsync(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, object userState)
        {
            if ((this.GetAccountIdFromPuidOperationCompleted == null))
            {
                this.GetAccountIdFromPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountIdFromPuidOperationCompleted);
            }
            this.InvokeAsync("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max}, this.GetAccountIdFromPuidOperationCompleted, userState);
        }

        private void OnGetAccountIdFromPuidOperationCompleted(object arg)
        {
            if ((this.GetAccountIdFromPuidCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountIdFromPuidCompleted(this, new GetAccountIdFromPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.Invoke("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType});
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountIdFromToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetAccountIdFromTokenAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType)
        {
            this.GetAccountIdFromTokenAsync(lDelegateIdHigh, lDelegateIdLow, fFullData, bstrTokenId, lTokenType, null);
        }

        /// <remarks/>
        public void GetAccountIdFromTokenAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, object userState)
        {
            if ((this.GetAccountIdFromTokenOperationCompleted == null))
            {
                this.GetAccountIdFromTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountIdFromTokenOperationCompleted);
            }
            this.InvokeAsync("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType}, this.GetAccountIdFromTokenOperationCompleted, userState);
        }

        private void OnGetAccountIdFromTokenOperationCompleted(object arg)
        {
            if ((this.GetAccountIdFromTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountIdFromTokenCompleted(this, new GetAccountIdFromTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetAccountIdFromTokenIdAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId)
        {
            this.GetAccountIdFromTokenIdAsync(lDelegateIdHigh, lDelegateIdLow, fFullData, bstrTokenId, null);
        }

        /// <remarks/>
        public void GetAccountIdFromTokenIdAsync(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, object userState)
        {
            if ((this.GetAccountIdFromTokenIdOperationCompleted == null))
            {
                this.GetAccountIdFromTokenIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountIdFromTokenIdOperationCompleted);
            }
            this.InvokeAsync("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId}, this.GetAccountIdFromTokenIdOperationCompleted, userState);
        }

        private void OnGetAccountIdFromTokenIdOperationCompleted(object arg)
        {
            if ((this.GetAccountIdFromTokenIdCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountIdFromTokenIdCompleted(this, new GetAccountIdFromTokenIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML)
        {
            object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetAccountInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId)
        {
            this.GetAccountInfoAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, null);
        }

        /// <remarks/>
        public void GetAccountInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, object userState)
        {
            if ((this.GetAccountInfoOperationCompleted == null))
            {
                this.GetAccountInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountInfoOperationCompleted);
            }
            this.InvokeAsync("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, this.GetAccountInfoOperationCompleted, userState);
        }

        private void OnGetAccountInfoOperationCompleted(object arg)
        {
            if ((this.GetAccountInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountInfoCompleted(this, new GetAccountInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML)
        {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetAccountStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId)
        {
            this.GetAccountStatusAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, null);
        }

        /// <remarks/>
        public void GetAccountStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, object userState)
        {
            if ((this.GetAccountStatusOperationCompleted == null))
            {
                this.GetAccountStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountStatusOperationCompleted);
            }
            this.InvokeAsync("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, this.GetAccountStatusOperationCompleted, userState);
        }

        private void OnGetAccountStatusOperationCompleted(object arg)
        {
            if ((this.GetAccountStatusCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountStatusCompleted(this, new GetAccountStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML)
        {
            object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }

        /// <remarks/>
        public void GetAdjustmentsAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId)
        {
            this.GetAdjustmentsAsync(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, lBillingPeriodId, null);
        }

        /// <remarks/>
        public void GetAdjustmentsAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, object userState)
        {
            if ((this.GetAdjustmentsOperationCompleted == null))
            {
                this.GetAdjustmentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAdjustmentsOperationCompleted);
            }
            this.InvokeAsync("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, this.GetAdjustmentsOperationCompleted, userState);
        }

        private void OnGetAdjustmentsOperationCompleted(object arg)
        {
            if ((this.GetAdjustmentsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAdjustmentsCompleted(this, new GetAdjustmentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetBaseOfferingsAsync(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency)
        {
            this.GetBaseOfferingsAsync(bstrOfferingGUID, bstrCategory, bstrCountry, bstrLocale, bstrCurrency, null);
        }

        /// <remarks/>
        public void GetBaseOfferingsAsync(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, object userState)
        {
            if ((this.GetBaseOfferingsOperationCompleted == null))
            {
                this.GetBaseOfferingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBaseOfferingsOperationCompleted);
            }
            this.InvokeAsync("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, this.GetBaseOfferingsOperationCompleted, userState);
        }

        private void OnGetBaseOfferingsOperationCompleted(object arg)
        {
            if ((this.GetBaseOfferingsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBaseOfferingsCompleted(this, new GetBaseOfferingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetBaseOfferingsExAsync(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId)
        {
            this.GetBaseOfferingsExAsync(bstrOfferingGUID, bstrCategory, bstrCountry, bstrLocale, bstrCurrency, bstrTokenId, null);
        }

        /// <remarks/>
        public void GetBaseOfferingsExAsync(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, object userState)
        {
            if ((this.GetBaseOfferingsExOperationCompleted == null))
            {
                this.GetBaseOfferingsExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBaseOfferingsExOperationCompleted);
            }
            this.InvokeAsync("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId}, this.GetBaseOfferingsExOperationCompleted, userState);
        }

        private void OnGetBaseOfferingsExOperationCompleted(object arg)
        {
            if ((this.GetBaseOfferingsExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBaseOfferingsExCompleted(this, new GetBaseOfferingsExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML)
        {
            object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetBillingPeriodsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale)
        {
            this.GetBillingPeriodsAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrLocale, null);
        }

        /// <remarks/>
        public void GetBillingPeriodsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, object userState)
        {
            if ((this.GetBillingPeriodsOperationCompleted == null))
            {
                this.GetBillingPeriodsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBillingPeriodsOperationCompleted);
            }
            this.InvokeAsync("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, this.GetBillingPeriodsOperationCompleted, userState);
        }

        private void OnGetBillingPeriodsOperationCompleted(object arg)
        {
            if ((this.GetBillingPeriodsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBillingPeriodsCompleted(this, new GetBillingPeriodsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingReference", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetBillingReference(string version, string callerInfoXml, string objectId, string paymentMethodType, string billingConfigGroup, out string billingReferenceInfoSetXml)
        {
            object[] results = this.Invoke("GetBillingReference", new object[] {
                    version,
                    callerInfoXml,
                    objectId,
                    paymentMethodType,
                    billingConfigGroup});
            billingReferenceInfoSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetBillingReference(string version, string callerInfoXml, string objectId, string paymentMethodType, string billingConfigGroup, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetBillingReference", new object[] {
                    version,
                    callerInfoXml,
                    objectId,
                    paymentMethodType,
                    billingConfigGroup}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetBillingReference(System.IAsyncResult asyncResult, out string billingReferenceInfoSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            billingReferenceInfoSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetBillingReferenceAsync(string version, string callerInfoXml, string objectId, string paymentMethodType, string billingConfigGroup)
        {
            this.GetBillingReferenceAsync(version, callerInfoXml, objectId, paymentMethodType, billingConfigGroup, null);
        }

        /// <remarks/>
        public void GetBillingReferenceAsync(string version, string callerInfoXml, string objectId, string paymentMethodType, string billingConfigGroup, object userState)
        {
            if ((this.GetBillingReferenceOperationCompleted == null))
            {
                this.GetBillingReferenceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBillingReferenceOperationCompleted);
            }
            this.InvokeAsync("GetBillingReference", new object[] {
                    version,
                    callerInfoXml,
                    objectId,
                    paymentMethodType,
                    billingConfigGroup}, this.GetBillingReferenceOperationCompleted, userState);
        }

        private void OnGetBillingReferenceOperationCompleted(object arg)
        {
            if ((this.GetBillingReferenceCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBillingReferenceCompleted(this, new GetBillingReferenceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML)
        {
            object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetCommentsAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId)
        {
            this.GetCommentsAsync(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, null);
        }

        /// <remarks/>
        public void GetCommentsAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, object userState)
        {
            if ((this.GetCommentsOperationCompleted == null))
            {
                this.GetCommentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCommentsOperationCompleted);
            }
            this.InvokeAsync("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, this.GetCommentsOperationCompleted, userState);
        }

        private void OnGetCommentsOperationCompleted(object arg)
        {
            if ((this.GetCommentsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCommentsCompleted(this, new GetCommentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetEligibleOfferingsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter)
        {
            this.GetEligibleOfferingsAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrOfferingGUID, bstrCategory, bstrFilter, null);
        }

        /// <remarks/>
        public void GetEligibleOfferingsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, object userState)
        {
            if ((this.GetEligibleOfferingsOperationCompleted == null))
            {
                this.GetEligibleOfferingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetEligibleOfferingsOperationCompleted);
            }
            this.InvokeAsync("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, this.GetEligibleOfferingsOperationCompleted, userState);
        }

        private void OnGetEligibleOfferingsOperationCompleted(object arg)
        {
            if ((this.GetEligibleOfferingsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetEligibleOfferingsCompleted(this, new GetEligibleOfferingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetEligibleOfferingsExAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId)
        {
            this.GetEligibleOfferingsExAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrOfferingGUID, bstrCategory, bstrFilter, bstrTokenId, null);
        }

        /// <remarks/>
        public void GetEligibleOfferingsExAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, object userState)
        {
            if ((this.GetEligibleOfferingsExOperationCompleted == null))
            {
                this.GetEligibleOfferingsExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetEligibleOfferingsExOperationCompleted);
            }
            this.InvokeAsync("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId}, this.GetEligibleOfferingsExOperationCompleted, userState);
        }

        private void OnGetEligibleOfferingsExOperationCompleted(object arg)
        {
            if ((this.GetEligibleOfferingsExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetEligibleOfferingsExCompleted(this, new GetEligibleOfferingsExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML)
        {
            object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetEligibleSwitchPITypesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId)
        {
            this.GetEligibleSwitchPITypesAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, null);
        }

        /// <remarks/>
        public void GetEligibleSwitchPITypesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, object userState)
        {
            if ((this.GetEligibleSwitchPITypesOperationCompleted == null))
            {
                this.GetEligibleSwitchPITypesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetEligibleSwitchPITypesOperationCompleted);
            }
            this.InvokeAsync("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, this.GetEligibleSwitchPITypesOperationCompleted, userState);
        }

        private void OnGetEligibleSwitchPITypesOperationCompleted(object arg)
        {
            if ((this.GetEligibleSwitchPITypesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetEligibleSwitchPITypesCompleted(this, new GetEligibleSwitchPITypesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML)
        {
            object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML});
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetExistingAccountsByCriteriaAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML)
        {
            this.GetExistingAccountsByCriteriaAsync(lDelegateIdHigh, lDelegateIdLow, bstrCriteriaXML, null);
        }

        /// <remarks/>
        public void GetExistingAccountsByCriteriaAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, object userState)
        {
            if ((this.GetExistingAccountsByCriteriaOperationCompleted == null))
            {
                this.GetExistingAccountsByCriteriaOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExistingAccountsByCriteriaOperationCompleted);
            }
            this.InvokeAsync("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML}, this.GetExistingAccountsByCriteriaOperationCompleted, userState);
        }

        private void OnGetExistingAccountsByCriteriaOperationCompleted(object arg)
        {
            if ((this.GetExistingAccountsByCriteriaCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExistingAccountsByCriteriaCompleted(this, new GetExistingAccountsByCriteriaCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml)
        {
            object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetKeyAsync(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid)
        {
            this.GetKeyAsync(lRequesterIdHigh, lRequesterIdLow, bstrKeyGuid, null);
        }

        /// <remarks/>
        public void GetKeyAsync(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, object userState)
        {
            if ((this.GetKeyOperationCompleted == null))
            {
                this.GetKeyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetKeyOperationCompleted);
            }
            this.InvokeAsync("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, this.GetKeyOperationCompleted, userState);
        }

        private void OnGetKeyOperationCompleted(object arg)
        {
            if ((this.GetKeyCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetKeyCompleted(this, new GetKeyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv)
        {
            object[] results = this.Invoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory});
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv)
        {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetLineItemHistoryAsync(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory)
        {
            this.GetLineItemHistoryAsync(delegateIdHigh, delegateIdLow, lineItemId, returnHistory, null);
        }

        /// <remarks/>
        public void GetLineItemHistoryAsync(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, object userState)
        {
            if ((this.GetLineItemHistoryOperationCompleted == null))
            {
                this.GetLineItemHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLineItemHistoryOperationCompleted);
            }
            this.InvokeAsync("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory}, this.GetLineItemHistoryOperationCompleted, userState);
        }

        private void OnGetLineItemHistoryOperationCompleted(object arg)
        {
            if ((this.GetLineItemHistoryCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLineItemHistoryCompleted(this, new GetLineItemHistoryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPartnerConfiguration", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPartnerConfiguration(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigQueryXML, out string responseXML)
        {
            object[] results = this.Invoke("GetPartnerConfiguration", new object[] {
                    trackingGuid,
                    ownerID,
                    partnerConfigQueryXML});
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPartnerConfiguration(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigQueryXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPartnerConfiguration", new object[] {
                    trackingGuid,
                    ownerID,
                    partnerConfigQueryXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPartnerConfiguration(System.IAsyncResult asyncResult, out string responseXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            responseXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetPartnerConfigurationAsync(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigQueryXML)
        {
            this.GetPartnerConfigurationAsync(trackingGuid, ownerID, partnerConfigQueryXML, null);
        }

        /// <remarks/>
        public void GetPartnerConfigurationAsync(System.Guid trackingGuid, System.Guid ownerID, string partnerConfigQueryXML, object userState)
        {
            if ((this.GetPartnerConfigurationOperationCompleted == null))
            {
                this.GetPartnerConfigurationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPartnerConfigurationOperationCompleted);
            }
            this.InvokeAsync("GetPartnerConfiguration", new object[] {
                    trackingGuid,
                    ownerID,
                    partnerConfigQueryXML}, this.GetPartnerConfigurationOperationCompleted, userState);
        }

        private void OnGetPartnerConfigurationOperationCompleted(object arg)
        {
            if ((this.GetPartnerConfigurationCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPartnerConfigurationCompleted(this, new GetPartnerConfigurationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML)
        {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetPaymentInstrumentsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId)
        {
            this.GetPaymentInstrumentsAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, null);
        }

        /// <remarks/>
        public void GetPaymentInstrumentsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, object userState)
        {
            if ((this.GetPaymentInstrumentsOperationCompleted == null))
            {
                this.GetPaymentInstrumentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentInstrumentsOperationCompleted);
            }
            this.InvokeAsync("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, this.GetPaymentInstrumentsOperationCompleted, userState);
        }

        private void OnGetPaymentInstrumentsOperationCompleted(object arg)
        {
            if ((this.GetPaymentInstrumentsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentInstrumentsCompleted(this, new GetPaymentInstrumentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML)
        {
            object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetPaymentInstrumentsExAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved)
        {
            this.GetPaymentInstrumentsExAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, fReturnRemoved, null);
        }

        /// <remarks/>
        public void GetPaymentInstrumentsExAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, object userState)
        {
            if ((this.GetPaymentInstrumentsExOperationCompleted == null))
            {
                this.GetPaymentInstrumentsExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentInstrumentsExOperationCompleted);
            }
            this.InvokeAsync("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved}, this.GetPaymentInstrumentsExOperationCompleted, userState);
        }

        private void OnGetPaymentInstrumentsExOperationCompleted(object arg)
        {
            if ((this.GetPaymentInstrumentsExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentInstrumentsExCompleted(this, new GetPaymentInstrumentsExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentMethodTypeProperties", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPaymentMethodTypeProperties(out string paymentTypeInfoSetXml)
        {
            object[] results = this.Invoke("GetPaymentMethodTypeProperties", new object[0]);
            paymentTypeInfoSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentMethodTypeProperties(System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPaymentMethodTypeProperties", new object[0], callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPaymentMethodTypeProperties(System.IAsyncResult asyncResult, out string paymentTypeInfoSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            paymentTypeInfoSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetPaymentMethodTypePropertiesAsync()
        {
            this.GetPaymentMethodTypePropertiesAsync(null);
        }

        /// <remarks/>
        public void GetPaymentMethodTypePropertiesAsync(object userState)
        {
            if ((this.GetPaymentMethodTypePropertiesOperationCompleted == null))
            {
                this.GetPaymentMethodTypePropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentMethodTypePropertiesOperationCompleted);
            }
            this.InvokeAsync("GetPaymentMethodTypeProperties", new object[0], this.GetPaymentMethodTypePropertiesOperationCompleted, userState);
        }

        private void OnGetPaymentMethodTypePropertiesOperationCompleted(object arg)
        {
            if ((this.GetPaymentMethodTypePropertiesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentMethodTypePropertiesCompleted(this, new GetPaymentMethodTypePropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitHistoryForObjectId", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, out string errorXml, out int permitCount, out string permitSetXML)
        {
            object[] results = this.Invoke("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId});
            errorXml = ((string)(results[0]));
            permitCount = ((int)(results[1]));
            permitSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPermitHistoryForObjectId(System.IAsyncResult asyncResult, out string errorXml, out int permitCount, out string permitSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            permitCount = ((int)(results[1]));
            permitSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetPermitHistoryForObjectIdAsync(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId)
        {
            this.GetPermitHistoryForObjectIdAsync(delegateIdHigh, delegateIdLow, requestorIdHigh, requestorIdLow, objectId, null);
        }

        /// <remarks/>
        public void GetPermitHistoryForObjectIdAsync(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, object userState)
        {
            if ((this.GetPermitHistoryForObjectIdOperationCompleted == null))
            {
                this.GetPermitHistoryForObjectIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPermitHistoryForObjectIdOperationCompleted);
            }
            this.InvokeAsync("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId}, this.GetPermitHistoryForObjectIdOperationCompleted, userState);
        }

        private void OnGetPermitHistoryForObjectIdOperationCompleted(object arg)
        {
            if ((this.GetPermitHistoryForObjectIdCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPermitHistoryForObjectIdCompleted(this, new GetPermitHistoryForObjectIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML)
        {
            object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetPermitsForObjectIdAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep)
        {
            this.GetPermitsForObjectIdAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, fDeep, null);
        }

        /// <remarks/>
        public void GetPermitsForObjectIdAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, object userState)
        {
            if ((this.GetPermitsForObjectIdOperationCompleted == null))
            {
                this.GetPermitsForObjectIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPermitsForObjectIdOperationCompleted);
            }
            this.InvokeAsync("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, this.GetPermitsForObjectIdOperationCompleted, userState);
        }

        private void OnGetPermitsForObjectIdOperationCompleted(object arg)
        {
            if ((this.GetPermitsForObjectIdCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPermitsForObjectIdCompleted(this, new GetPermitsForObjectIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML)
        {
            object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
          